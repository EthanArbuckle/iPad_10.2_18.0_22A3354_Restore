uint64_t MRCContextPreflightForDecoderUsingOptions(const void *a1, const __CFDictionary *a2, void *a3)
{
  void *v3;
  CFDictionaryRef Copy;
  _QWORD *v6;
  _QWORD *v7;
  void **v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  _QWORD v14[8];
  void *__p[2];
  char v16;
  _QWORD v17[2];
  uint64_t v18;
  _QWORD v19[10];
  char v20;
  uint64_t v21;

  v3 = a3;
  if (a2)
  {
    Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
    if (!v3)
      goto LABEL_4;
    goto LABEL_3;
  }
  Copy = 0;
  if (a3)
LABEL_3:
    v3 = _Block_copy(v3);
LABEL_4:
  sub_1D3DDC604((uint64_t)v17);
  v6 = sub_1D3D8C900(&v18, (uint64_t)"com.apple.Quagga.MRCContext-", 28);
  *(_DWORD *)((char *)v6 + *(_QWORD *)(v18 - 24) + 8) = *(_DWORD *)((_BYTE *)v6 + *(_QWORD *)(v18 - 24) + 8) & 0xFFFFFFB5 | 8;
  v7 = (_QWORD *)std::ostream::operator<<();
  sub_1D3D8C900(v7, (uint64_t)".preflight", 10);
  v8 = __p;
  sub_1D3D93B64(__p, (uint64_t)v19);
  if (v16 < 0)
    v8 = (void **)__p[0];
  v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v10 = dispatch_queue_attr_make_with_qos_class(v9, QOS_CLASS_UTILITY, -15);
  v11 = dispatch_queue_create((const char *)v8, v10);
  if (v16 < 0)
    operator delete(__p[0]);
  CFRetain(a1);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = sub_1D3E22B3C;
  v14[3] = &unk_1E95B3B08;
  v14[4] = v3;
  v14[5] = a1;
  v14[6] = Copy;
  v14[7] = v11;
  dispatch_async(v11, v14);
  v17[0] = *MEMORY[0x1E0DE4F50];
  v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v17 + *(_QWORD *)(v17[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v18 = v12;
  v19[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v20 < 0)
    operator delete((void *)v19[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1D8254BF4](&v21);
}

void sub_1D3D6C7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  sub_1D3DDC730((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t MRCContextCreateWithOptions(CFTypeRef a1)
{
  const void *Instance;
  unint64_t v2;
  CFTypeID v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  const __CFDictionary *v7;
  const __CFString *v8;
  CFTypeRef v9;
  unint64_t v10;
  char v11;
  char v12;
  void *v14;
  const __CFDictionary *v15;
  id v16;
  const char *v17;
  void *v18;
  NSObject *v19;
  unint64_t v21;
  const void *v22;
  void *v24;
  const __CFDictionary *v25;
  id v26;
  void *v27;
  unint64_t v29;
  const void *v30;
  const __CFString *v31;
  CFTypeRef v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  unint64_t v38;
  char v39;
  unsigned __int16 v40;
  unint64_t v41;
  _QWORD *v42;
  NSObject *v43;
  NSObject *v44;
  dispatch_qos_class_t v45;
  unsigned int v46;
  unint64_t v47;
  int v48;
  void **v49;
  uint64_t v50;
  CFTypeID v51;
  unint64_t v52;
  const void *v53;
  NSObject *v55;
  CFTypeRef v56;
  unint64_t v57;
  void *__p[2];
  char v59;
  id v60;
  id v61;
  uint8_t buf[16];
  uint64_t v63;
  _QWORD v64[10];
  char v65;
  _QWORD v66[20];

  v66[19] = *MEMORY[0x1E0C80C00];
  if (a1)
    a1 = CFRetain(a1);
  v56 = a1;
  if (qword_1EDB893E0 != -1)
    dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
  Instance = (const void *)_CFRuntimeCreateInstance();
  v2 = (unint64_t)Instance;
  if (Instance)
  {
    v3 = CFGetTypeID(Instance);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v3 != qword_1EDB893D8)
      _os_assumes_log();
    v4 = operator new();
    *(_QWORD *)v4 = 1;
    *(_QWORD *)(v4 + 8) = 0;
    v5 = (unint64_t *)(v4 + 8);
    *(_QWORD *)(v4 + 16) = 0;
    v6 = (unint64_t *)(v4 + 16);
    *(_BYTE *)(v4 + 40) = 0;
    *(_BYTE *)(v4 + 48) = 0;
    *(_WORD *)(v4 + 56) = 0;
    *(_QWORD *)(v4 + 24) = 0;
    *(_WORD *)(v4 + 32) = 0;
    v7 = (const __CFDictionary *)atomic_load((unint64_t *)&v56);
    sub_1D3DEA648((CFDictionaryRef *)__p, v7);
    v8 = sub_1D3DEA428(CFSTR("MRCContextOptionInferenceFlags"));
    if (v8)
    {
      v9 = sub_1D3DEA6E0((CFDictionaryRef *)__p, v8);
      CFRelease(v8);
      if (v9)
      {
        v10 = sub_1D3DEA20C(v9);
        v12 = v11;
        CFRelease(v9);
        if (v12)
          *(_QWORD *)v4 = v10;
      }
    }
    if (atomic_load((unint64_t *)&v56))
    {
      v14 = (void *)MEMORY[0x1D8255128]();
      v15 = (const __CFDictionary *)atomic_load((unint64_t *)&v56);
      v16 = (id)CFDictionaryGetValue(v15, CFSTR("MRCContextOptionPreferredMetalDevice"));
      v18 = v16;
      if (v16)
      {
        if ((objc_msgSend_conformsToProtocol_(v16, v17, (uint64_t)&unk_1EFE352B0) & 1) != 0)
        {
          v16 = v18;
        }
        else
        {
          if (qword_1EDB89F30 != -1)
            dispatch_once(&qword_1EDB89F30, &unk_1E95B3348);
          v19 = (id)qword_1EDB89F88;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v18;
            _os_log_error_impl(&dword_1D3D6B000, v19, OS_LOG_TYPE_ERROR, "Unrecognized Metal device: %{public}@", buf, 0xCu);
          }

          v16 = 0;
        }
      }
      v61 = v16;

      objc_autoreleasePoolPop(v14);
    }
    else
    {
      v61 = 0;
    }
    if (atomic_load((unint64_t *)&v61))
    {
      do
        v21 = __ldaxr((unint64_t *)&v61);
      while (__stlxr(0, (unint64_t *)&v61));
      do
        v22 = (const void *)__ldaxr(v5);
      while (__stlxr(v21, v5));
      if (v22)
        CFRelease(v22);
    }
    if (atomic_load((unint64_t *)&v56))
    {
      v24 = (void *)MEMORY[0x1D8255128]();
      v25 = (const __CFDictionary *)atomic_load((unint64_t *)&v56);
      v26 = (id)CFDictionaryGetValue(v25, CFSTR("MRCContextOptionComputeDevice"));
      v27 = v26;
      if (v26)
      {
        sub_1D3E182B4();
        if ((objc_opt_isKindOfClass() & 1) != 0
          || (sub_1D3E1836C(), (objc_opt_isKindOfClass() & 1) != 0)
          || (sub_1D3E18424(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          v26 = v27;
        }
        else
        {
          if (qword_1EDB89F30 != -1)
            dispatch_once(&qword_1EDB89F30, &unk_1E95B3348);
          v55 = (id)qword_1EDB89F88;
          if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v27;
            _os_log_error_impl(&dword_1D3D6B000, v55, OS_LOG_TYPE_ERROR, "Unrecognized compute device: %{public}@", buf, 0xCu);
          }

          v26 = 0;
        }
      }
      v60 = v26;

      objc_autoreleasePoolPop(v24);
    }
    else
    {
      v60 = 0;
    }
    if (atomic_load((unint64_t *)&v60))
    {
      do
        v29 = __ldaxr((unint64_t *)&v60);
      while (__stlxr(0, (unint64_t *)&v60));
      do
        v30 = (const void *)__ldaxr(v6);
      while (__stlxr(v29, v6));
      if (v30)
        CFRelease(v30);
    }
    v31 = sub_1D3DEA428(CFSTR("MRCContextOptionQoSClass"));
    if (v31)
    {
      v32 = sub_1D3DEA6E0((CFDictionaryRef *)__p, v31);
      CFRelease(v31);
      if (v32)
      {
        v33 = sub_1D3DEA098(v32);
        CFRelease(v32);
        v34 = v33 | 0x100000000;
        if (!HIDWORD(v33))
          v34 = 0;
        if ((v34 & 0x100000000) != 0)
          *(_DWORD *)(v4 + 24) = v34;
      }
    }
    v35 = sub_1D3DDA4D0((CFDictionaryRef *)__p, CFSTR("MRCContextOptionRelativePriority"));
    if (HIDWORD(v35))
      *(_DWORD *)(v4 + 28) = v35;
    v36 = sub_1D3DDA65C((CFDictionaryRef *)__p, CFSTR("_MRCContextOptionIsGlobal"));
    if (v36 >= 0x100u)
      *(_BYTE *)(v4 + 32) = v36;
    v37 = sub_1D3DDA65C((CFDictionaryRef *)__p, CFSTR("_MRCContextOptionIsOneShot"));
    if (v37 >= 0x100u)
      *(_BYTE *)(v4 + 33) = v37;
    v38 = sub_1D3DDA5C0((CFDictionaryRef *)__p, CFSTR("MRCContextOptionMaximumBufferAge"));
    if (v39)
    {
      *(_QWORD *)(v4 + 40) = v38;
      *(_BYTE *)(v4 + 48) = 1;
    }
    v40 = sub_1D3DDA65C((CFDictionaryRef *)__p, CFSTR("MRCContextOptionIsStreaming"));
    v41 = v2 + 16;
    if (v40 >= 0x100u)
      *(_WORD *)(v4 + 56) = v40 | 0x100;
    sub_1D3D8BA0C((unint64_t *)&v60);
    sub_1D3D8BA0C((unint64_t *)&v61);
    sub_1D3DEA6B0((const void **)__p);
    *(_OWORD *)(v2 + 40) = 0u;
    *(_QWORD *)(v2 + 16) = v4;
    *(_DWORD *)(v2 + 24) = 0;
    *(_OWORD *)(v2 + 56) = 0u;
    *(_DWORD *)(v2 + 72) = 1065353216;
    sub_1D3DDC604((uint64_t)buf);
    v42 = sub_1D3D8C900(&v63, (uint64_t)"com.apple.Quagga.MRCContext-", 28);
    *(_DWORD *)((char *)v42 + *(_QWORD *)(v63 - 24) + 8) = *(_DWORD *)((_BYTE *)v42 + *(_QWORD *)(v63 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    v43 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v44 = v43;
    v45 = *(_DWORD *)(*(_QWORD *)v41 + 24);
    HIDWORD(v47) = v45 - 9;
    LODWORD(v47) = v45 - 9;
    v46 = v47 >> 2;
    if (v46 <= 6 && ((1 << v46) & 0x5D) != 0)
    {
      if ((*(_DWORD *)(*(_QWORD *)v41 + 28) & (*(int *)(*(_QWORD *)v41 + 28) >> 31)) <= -15)
        v48 = -15;
      else
        v48 = *(_DWORD *)(*(_QWORD *)v41 + 28) & (*(int *)(*(_QWORD *)v41 + 28) >> 31);
      v44 = dispatch_queue_attr_make_with_qos_class(v43, v45, v48);
    }
    sub_1D3D93B64(__p, (uint64_t)v64);
    if (v59 >= 0)
      v49 = __p;
    else
      v49 = (void **)__p[0];
    *(_QWORD *)(v2 + 32) = dispatch_queue_create((const char *)v49, v44);
    if (v59 < 0)
      operator delete(__p[0]);
    *(_QWORD *)buf = *MEMORY[0x1E0DE4F50];
    v50 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
    *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
    v63 = v50;
    v64[0] = MEMORY[0x1E0DE4FB8] + 16;
    if (v65 < 0)
      operator delete((void *)v64[8]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1D8254BF4](v66);
    v51 = CFGetTypeID((CFTypeRef)v2);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v51 != qword_1EDB893D8)
      _os_assumes_log();
  }
  v57 = v2;
  do
    v52 = __ldaxr(&v57);
  while (__stlxr(0, &v57));
  do
    v53 = (const void *)__ldaxr(&v57);
  while (__stlxr(0, &v57));
  if (v53)
    CFRelease(v53);
  sub_1D3D8BAAC((unint64_t *)&v56);
  return v52;
}

void sub_1D3D6CF38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t *v4;
  void *v5;
  unint64_t v7;
  va_list va;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);

  sub_1D3DEA6B0((const void **)va1);
  sub_1D3D8BA0C(v4);
  sub_1D3D8BA0C(v3);
  MEMORY[0x1D8254C54](v2, 0x10C0C40B18511C9);
  sub_1D3D8BAAC((unint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D3D6D020()
{
  JUMPOUT(0x1D3D6D018);
}

uint64_t sub_1D3D6D028(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float v10;
  uint64_t v11;
  _DWORD *v13;
  int *v14;
  unint64_t v15;
  uint64_t v16;
  int *v17;
  _DWORD *v18;
  uint64_t v19;
  int v20;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a4 + 8) = 0;
  *(_QWORD *)a4 = 0;
  v5 = a5;
  do
  {
    v6 = v5--;
    v7 = result + 12 * v5;
    v8 = 4;
    v9 = 3;
    do
    {
      v10 = *(float *)(v7 + 4 * (v9 - 1));
      v11 = v8;
      do
      {
        *(float *)(a3 + 12 * (v9 - 1) + 4 * (v11 - 2)) = *(float *)(a3
                                                                                  + 12 * (v9 - 1)
                                                                                  + 4 * (v11 - 2))
                                                                       + (float)(*(float *)(v7
                                                                                          + 4
                                                                                          * (v11 - 2))
                                                                               * v10);
        --v11;
      }
      while (v11 > 1);
      *(float *)(a4 + 4 * (v9 - 1)) = *(float *)(a4 + 4 * (v9 - 1)) + (float)(v10 * *(float *)(a2 + 4 * v5));
      --v8;
    }
    while (v9-- > 1);
  }
  while (v6 > 1);
  v13 = (_DWORD *)(a3 + 36);
  v14 = (int *)(a3 + 44);
  v15 = 3;
  v16 = 4;
  do
  {
    if (v15 <= 2)
    {
      v17 = v14;
      v18 = v13;
      v19 = v16;
      do
      {
        v20 = *v17;
        v17 += 3;
        *v18++ = v20;
      }
      while ((_DWORD)v19++ != 3);
    }
    --v16;
    v13 -= 4;
    v14 -= 4;
  }
  while (v15-- >= 2);
  return result;
}

unsigned int **sub_1D3D6D10C(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

unsigned int *sub_1D3D6D13C(unsigned int *result)
{
  unsigned int v1;
  BOOL v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v1 = result[2];
  if (v1)
    v2 = v1 == 800000;
  else
    v2 = 1;
  if (v2)
    abort();
  v3 = result + 2;
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
  {
    result[2] = -559026175;
    return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

char ***sub_1D3D6D19C(char ***a1, uint64_t a2)
{
  char **v4;
  unint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;

  v4 = *a1;
  v6 = (*a1)[1];
  v5 = (unint64_t)(*a1)[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = *v4;
    v9 = (v6 - *v4) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      sub_1D3D6D4F8();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      if (v12 >> 61)
        sub_1D3D6D50C();
      v13 = (char *)operator new(8 * v12);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    *(_QWORD *)v14 = a2;
    v7 = v14 + 8;
    if (v6 != v8)
    {
      do
      {
        v15 = *((_QWORD *)v6 - 1);
        v6 -= 8;
        *((_QWORD *)v14 - 1) = v15;
        v14 -= 8;
      }
      while (v6 != v8);
      v6 = *v4;
    }
    *v4 = v14;
    v4[1] = v7;
    v4[2] = &v13[8 * v12];
    if (v6)
      operator delete(v6);
  }
  else
  {
    *(_QWORD *)v6 = a2;
    v7 = v6 + 8;
  }
  v4[1] = v7;
  return a1;
}

uint64_t sub_1D3D6D294(uint64_t result)
{
  unsigned __int8 *v1;
  _OWORD *v2;
  _OWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;

  v1 = (unsigned __int8 *)result;
  v2 = (_OWORD *)(result + 40);
  v3 = (_OWORD *)(result + 24);
  v4 = *(_QWORD *)(result + 80);
  if (v4 <= *(_QWORD *)(result + 88))
    v5 = *(_QWORD *)(result + 88);
  else
    v5 = *(_QWORD *)(result + 80);
  while (1)
  {
    v6 = 0;
    *((_QWORD *)v1 + 8) = *((_QWORD *)v1 + 2);
    v7 = *((_QWORD *)v1 + 5);
    do
    {
      *(_DWORD *)&v1[v6 + 16] += *(_DWORD *)(v7 + v6);
      v6 += 4;
    }
    while (v6 != 8);
    *((_QWORD *)v1 + 5) = v7 + 8;
    if (v7 + 8 == *((_QWORD *)v1 + 6))
      *v2 = *v3;
    if (v4 == v5)
      break;
    result = sub_1D3D6D438((uint64_t)v1);
    if (!(_DWORD)result)
      break;
    *((_QWORD *)v1 + 10) = ++v4;
    result = sub_1D3D6D4A0(*((_QWORD **)v1 + 1), *((int *)v1 + 4), *((int *)v1 + 5));
    v8 = *v1;
    if (v8 == (_DWORD)result)
    {
      v9 = 0;
    }
    else
    {
      v10 = *((_DWORD *)v1 + 18);
      if (v10)
      {
        if (v10 >= *((_DWORD *)v1 + 19))
        {
          *v1 = v8 ^ 1;
          *((_DWORD *)v1 + 18) = 0;
          return result;
        }
        v9 = v10 + 1;
      }
      else
      {
        v11 = *((_QWORD *)v1 + 2);
        *((_QWORD *)v1 + 7) = v11;
        v12 = *((_DWORD *)v1 + 16);
        if (v12 > (int)v11)
          *((_DWORD *)v1 + 14) = v12;
        v13 = HIDWORD(v11);
        v14 = *((_DWORD *)v1 + 17);
        if (v14 > (int)v13)
          *((_DWORD *)v1 + 15) = v14;
        v9 = 1;
      }
    }
    *((_DWORD *)v1 + 18) = v9;
  }
  return result;
}

void sub_1D3D6D3BC(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void *v7;
  void *v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = (char *)v1[1];
      do
      {
        v8 = (void *)*((_QWORD *)v6 - 3);
        v6 -= 24;
        v7 = v8;
        if (v8)
        {
          *((_QWORD *)v4 - 2) = v7;
          operator delete(v7);
        }
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL sub_1D3D6D438(uint64_t a1)
{
  unint64_t v1;
  _BOOL8 result;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *(_QWORD *)(a1 + 16);
  if ((v1 & 0x80000000) != 0)
    return 0;
  result = 0;
  if ((v1 & 0x8000000000000000) == 0)
  {
    v4 = *(_QWORD **)(a1 + 8);
    v5 = v4[7];
    v6 = -v5;
    v7 = v4[4];
    v8 = v7 & -v5;
    v9 = v5 - 1;
    v10 = v4[2];
    if ((v10 & v9 | (unint64_t)v8) > v1)
      return (v7 & v9 | v10 & (unint64_t)v6) > HIDWORD(v1);
  }
  return result;
}

uint64_t sub_1D3D6D4A0(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;

  v3 = ((a1[2] + ~a3) & -a1[7] | (a1[7] - 1) & a2) + ((a1[4] + ~a2) & -a1[7] | (a1[7] - 1) & a3) * a1[3];
  return (*(_DWORD *)(a1[6] + ((v3 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v3) & 1;
}

void sub_1D3D6D4F8()
{
  sub_1D3D6D534("vector");
}

void sub_1D3D6D50C()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

void sub_1D3D6D534(const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1D3D6D584(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E95AAC00, MEMORY[0x1E0DE42D0]);
}

void sub_1D3D6D570(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1D3D6D584(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void sub_1D3D6D5A8(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

double sub_1D3D6D5B8(int a1, int a2, uint64_t a3)
{
  float64x2_t v3;
  int64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;

  v3.f64[0] = (double)a1;
  v3.f64[1] = (double)a2;
  v4.i64[0] = (int)*(_QWORD *)a3;
  v4.i64[1] = (int)HIDWORD(*(_QWORD *)a3);
  v5 = vcvtq_f64_s64(v4);
  v6 = vmulq_f64(v3, v5);
  return (double)a1
       - (v6.f64[0] + 0.0 + v6.f64[1] + (double)*(int *)(a3 + 8))
       / (vmulq_f64(v5, v5).f64[0] + vmuld_lane_f64(v5.f64[1], v5, 1))
       * v5.f64[0];
}

double sub_1D3D6D62C(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v8;
  double v9;
  double v10;

  for (i = 0; i != 3; ++i)
    *(&v8 + i) = (double)*(int *)(a1 + 4 * i);
  v3 = 0;
  v4 = v8;
  v5 = v9;
  v6 = v10;
  do
  {
    *(&v8 + v3) = (double)*(int *)(a2 + 4 * v3);
    ++v3;
  }
  while (v3 != 3);
  return (v5 * v10 - v6 * v9) / (v4 * v9 - v5 * v8);
}

unsigned int *sub_1D3D6D6A8(unsigned int *result, unsigned int **a2, unsigned int **a3, unint64_t a4)
{
  unsigned int *v6;
  uint64_t v7;
  unsigned int **v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;

  if (a4)
  {
    v6 = result;
    result = (unsigned int *)sub_1D3D6D864(result, a4);
    if (a2 == a3)
    {
      v8 = (unsigned int **)*((_QWORD *)v6 + 1);
    }
    else
    {
      v7 = 0;
      v8 = (unsigned int **)*((_QWORD *)v6 + 1);
      do
      {
        *v8 = 0;
        v9 = *a2;
        if (*a2)
        {
          v10 = v9 + 2;
          do
            v11 = __ldxr(v10);
          while (__stxr(v11 + 1, v10));
          result = *v8;
          if (*v8)
            result = sub_1D3D6D13C(result);
        }
        *v8++ = v9;
        ++a2;
        v7 += 8;
      }
      while (a2 != a3);
    }
    *((_QWORD *)v6 + 1) = v8;
  }
  return result;
}

void sub_1D3D6D760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_1D3D6D79C(&a9);
  _Unwind_Resume(a1);
}

void sub_1D3D6D79C(void ***a1)
{
  void **v1;
  unsigned int **v2;
  unsigned int **v4;
  void *v5;

  v1 = *a1;
  v2 = (unsigned int **)**a1;
  if (v2)
  {
    v4 = (unsigned int **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3D6D834(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1D3D6D810(uint64_t a1)
{
  sub_1D3DB457C(a1);
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3D6D834(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

char *sub_1D3D6D864(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    sub_1D3D6D4F8();
  result = (char *)sub_1D3D6D8A0(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *sub_1D3D6D8A0(unint64_t a1)
{
  if (a1 >> 61)
    sub_1D3D6D50C();
  return operator new(8 * a1);
}

uint64_t sub_1D3D6D8D4(uint64_t a1, unsigned int *a2, unsigned int ***a3, char a4, char a5, int a6, int a7)
{
  unsigned int *v12;
  unsigned int v13;
  unsigned int **v15[3];
  unsigned int *v16;
  unsigned int ***v17;

  if (a2)
  {
    v12 = a2 + 2;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v16 = a2;
  memset(v15, 0, sizeof(v15));
  sub_1D3D6D6A8((unsigned int *)v15, *a3, a3[1], a3[1] - *a3);
  sub_1D3DB4618(a1, (uint64_t *)&v16, v15, a4);
  v17 = v15;
  sub_1D3D6D79C((void ***)&v17);
  sub_1D3D6D10C(&v16);
  *(_QWORD *)a1 = &off_1E95AF630;
  *(_BYTE *)(a1 + 88) = a5;
  *(_DWORD *)(a1 + 92) = a6;
  *(_DWORD *)(a1 + 96) = a7;
  return a1;
}

void sub_1D3D6D990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  unsigned int *v6;
  va_list va;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, unsigned int *);
  sub_1D3D6D79C((void ***)va1);
  sub_1D3D6D10C((unsigned int **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1D3D6D9B8(_DWORD *a1, double a2)
{
  int32x4_t *v3;
  int v4;

  if ((LODWORD(a2) & 0x80000000) != 0
    || (v3 = *(int32x4_t **)a1, *(_QWORD *)(*(_QWORD *)a1 + 8) <= (unint64_t)LODWORD(a2))
    || (HIDWORD(a2) & 0x80000000) != 0
    || v3[1].i64[0] <= (unint64_t)HIDWORD(a2))
  {
    v4 = -1;
  }
  else
  {
    v4 = sub_1D3E0BA8C(v3, a2);
  }
  return v4 == a1[6];
}

BOOL sub_1D3D6DA18(int32x2_t *a1, float a2)
{
  int v3;
  signed int v4;
  int v5;
  double v6;
  char v7;
  uint64_t v8;
  signed int v9;
  char v10;
  char v11;
  int v12;
  double v14;

  v3 = 0;
  v4 = (int)(float)(a2 + a2);
  v5 = (int)(float)(a2 - a2);
  v6 = *(double *)&a1[1];
  v7 = 1;
  while (2)
  {
    v8 = 0;
    v9 = 0;
    v10 = 1;
    do
    {
      v11 = v10;
      *(double *)&a1[1] = v6;
      a1[2] = qword_1D3E5D528[2 * (v7 & 1) + v8];
      v12 = sub_1D3D6E654(a1, 1, v4, 0, 1);
      if (v12 == -1)
        return 0;
      v10 = 0;
      v9 += v12;
      v8 = 1;
    }
    while ((v11 & 1) != 0);
    if (v3 && (v9 + 1 < v5 || v9 >= v4))
      return 0;
    v7 ^= 1u;
    v14 = *(double *)&a1[1];
    *(_DWORD *)((unint64_t)&v14 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v7 & 1))) -= (v9 + 1) / 2;
    v6 = v14;
    *(double *)&a1[1] = v14;
    if (++v3 != 4)
      continue;
    break;
  }
  return sub_1D3D6D9B8(a1, v6);
}

void *sub_1D3D6DB64(unint64_t a1)
{
  if (a1 >> 60)
    sub_1D3D6D50C();
  return operator new(16 * a1);
}

uint64_t sub_1D3D6DB98(uint64_t result, int32x4_t *a2, uint64_t a3, char a4)
{
  int32x4_t *v7;
  int32x4_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int32x4_t *v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  __int8 v16;
  int32x4_t v17;
  int32x4_t v18;
  __int8 v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t v22;
  unint64_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  __int8 v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  int32x4_t *v32;
  int32x4_t *v33;
  int32x4_t v34;
  int32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  __int8 v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  __int8 v44;
  int32x4_t v45;
  int32x4_t v46;
  __int32 v47;
  int32x4_t *v48;
  int32x4_t *v49;
  int32x4_t *v50;
  int32x4_t *v51;
  __int32 v52;
  int32x4_t *v53;
  __int32 v54;
  int32x4_t *v55;
  int32x4_t *v56;
  int32x4_t v57;
  __int32 v58;
  BOOL v59;
  int32x4_t *v60;
  int v61;
  unint64_t v62;
  int v63;
  int32x4_t *v64;
  int32x4_t *v65;
  int v66;
  int32x4_t v67;
  int v68;
  int v69;
  int32x4_t *v70;
  int32x4_t v71;
  int32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  int32x4_t v75;
  __int8 v76;
  int32x4_t *v77;
  int32x4_t v78;
  int32x4_t *v79;
  int32x4_t v80;
  int32x4_t v81;
  __int8 v82;
  int32x4_t *v83;
  int32x4_t v84;
  int32x4_t *v85;
  int32x4_t v86;
  int32x4_t *v87;
  int32x4_t v88;
  int32x4_t v89;
  __int8 v90;
  int32x4_t *v91;
  BOOL v93;
  uint64_t v94;
  int32x4_t *v95;
  int32x4_t v96;
  int v97;
  uint64_t v98;
  int v99;
  int32x4_t *v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  uint64_t v104;
  int32x4_t *v105;
  __int32 v106;
  __int32 v107;
  int32x4_t *v108;
  int32x4_t v109;
  int v110;
  int32x4_t *v111;
  uint64_t v112;
  uint64_t v113;
  __int32 v114;
  __int32 v115;
  uint64_t v116;
  uint64_t v117;
  int32x4_t v118;
  _OWORD *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  int v124;
  uint64_t v125;
  unint64_t v126;
  int32x4_t *v127;
  int32x4_t v128;
  __int32 v129;
  int32x4_t *v130;
  int32x4_t v132;
  int32x4_t *v133;
  int32x4_t v134;
  int v135;
  int32x4_t *v136;
  int32x4_t v137;
  int32x4_t v138;
  int32x4_t v139;
  int32x4_t v140;
  int32x4_t v141;
  int32x4_t v142;
  int32x4_t v143;
  int32x4_t v144;
  int32x4_t v145;

  v7 = (int32x4_t *)result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = a2 - v8;
    switch(v10)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v71 = a2[-1];
        v72 = *v8;
        if ((vmovn_s32(vcgtq_s32(*v8, v71)).i32[1] & 1) != 0)
        {
          *v8 = v71;
          a2[-1] = v72;
        }
        return result;
      case 3:
        v73 = *v8;
        v74 = v8[1];
        v75 = a2[-1];
        v76 = vmovn_s32(vcgtq_s32(v74, v75)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v8, v74)).i32[1] & 1) != 0)
        {
          if ((v76 & 1) != 0)
          {
            *v8 = v75;
          }
          else
          {
            *v8 = v74;
            v8[1] = v73;
            v138 = a2[-1];
            if ((vmovn_s32(vcgtq_s32(v73, v138)).i32[1] & 1) == 0)
              return result;
            v8[1] = v138;
          }
          a2[-1] = v73;
        }
        else if ((v76 & 1) != 0)
        {
          v8[1] = v75;
          a2[-1] = v74;
          v132 = v8[1];
          goto LABEL_201;
        }
        return result;
      case 4:
        v85 = v8 + 1;
        v86 = v8[1];
        v87 = v8 + 2;
        v88 = v8[2];
        v89 = *v8;
        v90 = vmovn_s32(vcgtq_s32(v86, v88)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v8, v86)).i32[1] & 1) != 0)
        {
          if ((v90 & 1) != 0)
          {
            *v8 = v88;
          }
          else
          {
            *v8 = v86;
            v8[1] = v89;
            if ((vmovn_s32(vcgtq_s32(v89, v88)).i32[1] & 1) == 0)
              goto LABEL_186;
            *v85 = v88;
          }
          v133 = v8 + 2;
          v86 = v89;
          goto LABEL_184;
        }
        if ((v90 & 1) == 0)
          goto LABEL_186;
        *v85 = v88;
        *v87 = v86;
        if ((vmovn_s32(vcgtq_s32(v89, v88)).i32[1] & 1) != 0)
        {
          *v8 = v88;
          v133 = v8 + 1;
LABEL_184:
          *v133 = v89;
        }
        v88 = v86;
LABEL_186:
        v140 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v88, v140)).i32[1] & 1) != 0)
        {
          *v87 = v140;
          a2[-1] = v88;
          v132 = *v87;
          v141 = *v85;
          goto LABEL_199;
        }
        return result;
      case 5:
        v77 = v8 + 1;
        v78 = v8[1];
        v79 = v8 + 2;
        v80 = v8[2];
        v81 = *v8;
        v82 = vmovn_s32(vcgtq_s32(v78, v80)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v8, v78)).i32[1] & 1) == 0)
        {
          if ((v82 & 1) == 0)
          {
            v139 = *v8;
            v81 = v8[1];
            goto LABEL_191;
          }
          *v77 = v80;
          *v79 = v78;
          if ((vmovn_s32(vcgtq_s32(v81, v80)).i32[1] & 1) == 0)
          {
            v139 = v81;
            v81 = v80;
            goto LABEL_190;
          }
          *v8 = v80;
          v83 = v8 + 1;
          v84 = v81;
LABEL_180:
          *v83 = v81;
          v139 = v80;
          v81 = v84;
LABEL_190:
          v80 = v78;
          goto LABEL_191;
        }
        if ((v82 & 1) != 0)
        {
          *v8 = v80;
          v83 = v8 + 2;
          v84 = v78;
LABEL_179:
          v78 = v81;
          goto LABEL_180;
        }
        *v8 = v78;
        v8[1] = v81;
        if ((vmovn_s32(vcgtq_s32(v81, v80)).i32[1] & 1) != 0)
        {
          v84 = v80;
          *v77 = v80;
          v83 = v8 + 2;
          v80 = v78;
          goto LABEL_179;
        }
        v139 = v78;
LABEL_191:
        v142 = v8[3];
        if ((vmovn_s32(vcgtq_s32(v80, v142)).i32[1] & 1) != 0)
        {
          v8[2] = v142;
          v8[3] = v80;
          if ((vmovn_s32(vcgtq_s32(v81, v142)).i32[1] & 1) != 0)
          {
            *v77 = v142;
            *v79 = v81;
            if ((vmovn_s32(vcgtq_s32(v139, v142)).i32[1] & 1) != 0)
            {
              *v8 = v142;
              v8[1] = v139;
            }
          }
        }
        else
        {
          v80 = v8[3];
        }
        v143 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v80, v143)).i32[1] & 1) != 0)
        {
          v8[3] = v143;
          a2[-1] = v80;
          v144 = v8[2];
          v132 = v8[3];
          if ((vmovn_s32(vcgtq_s32(v144, v132)).i32[1] & 1) != 0)
          {
            v8[2] = v132;
            v8[3] = v144;
            v141 = v8[1];
LABEL_199:
            if ((vmovn_s32(vcgtq_s32(v141, v132)).i32[1] & 1) != 0)
            {
              v8[1] = v132;
              v8[2] = v141;
LABEL_201:
              v145 = *v8;
              if ((vmovn_s32(vcgtq_s32(*v8, v132)).i32[1] & 1) != 0)
              {
                *v8 = v132;
                v8[1] = v145;
              }
            }
          }
        }
        return result;
      default:
        if (v9 > 383)
        {
          if (!a3)
          {
            if (v8 != a2)
            {
              v101 = (unint64_t)(v10 - 2) >> 1;
              v102 = v101;
              do
              {
                v103 = v102;
                if (v101 >= v102)
                {
                  v104 = (2 * v102) | 1;
                  v105 = &v8[v104];
                  if (2 * v103 + 2 < v10)
                  {
                    v106 = v105->i32[2];
                    v107 = v105[1].i32[2];
                    v105 += v106 < v107;
                    if (v106 < v107)
                      v104 = 2 * v103 + 2;
                  }
                  v108 = &v8[v103];
                  v109 = *v108;
                  v110 = v108->i64[1];
                  if (v105->i32[2] >= v110)
                  {
                    do
                    {
                      v111 = v105;
                      *v108 = *v105;
                      if (v101 < v104)
                        break;
                      v112 = (2 * v104) | 1;
                      v105 = &v8[v112];
                      v113 = 2 * v104 + 2;
                      if (v113 < v10)
                      {
                        v114 = v105->i32[2];
                        v115 = v105[1].i32[2];
                        v105 += v114 < v115;
                        if (v114 < v115)
                          v112 = v113;
                      }
                      result = v105->u32[2];
                      v108 = v111;
                      v104 = v112;
                    }
                    while ((int)result >= v110);
                    *v111 = v109;
                  }
                }
                v102 = v103 - 1;
              }
              while (v103);
              v116 = (unint64_t)v9 >> 4;
              do
              {
                v117 = 0;
                v118 = *v8;
                v119 = v8;
                do
                {
                  v120 = (uint64_t)&v119[v117 + 1];
                  v121 = (2 * v117) | 1;
                  v122 = 2 * v117 + 2;
                  if (v122 < v116)
                  {
                    v123 = *(_DWORD *)(v120 + 8);
                    v124 = *(_DWORD *)(v120 + 24);
                    v120 += 16 * (v123 < v124);
                    if (v123 < v124)
                      v121 = v122;
                  }
                  *v119 = *(_OWORD *)v120;
                  v119 = (_OWORD *)v120;
                  v117 = v121;
                }
                while (v121 <= (uint64_t)((unint64_t)(v116 - 2) >> 1));
                if ((int32x4_t *)v120 == --a2)
                {
                  *(int32x4_t *)v120 = v118;
                }
                else
                {
                  *(int32x4_t *)v120 = *a2;
                  *a2 = v118;
                  v125 = v120 - (_QWORD)v8 + 16;
                  if (v125 >= 17)
                  {
                    v126 = (((unint64_t)v125 >> 4) - 2) >> 1;
                    v127 = &v8[v126];
                    v128 = *(int32x4_t *)v120;
                    v129 = *(_QWORD *)(v120 + 8);
                    if (v127->i32[2] < v129)
                    {
                      do
                      {
                        v130 = v127;
                        *(int32x4_t *)v120 = *v127;
                        if (!v126)
                          break;
                        v126 = (v126 - 1) >> 1;
                        v127 = &v8[v126];
                        v120 = (uint64_t)v130;
                      }
                      while (v127->i32[2] < v129);
                      *v130 = v128;
                    }
                  }
                }
              }
              while (v116-- > 2);
            }
            return result;
          }
          v11 = (unint64_t)v10 >> 1;
          v12 = &v8[(unint64_t)v10 >> 1];
          v13 = a2[-1];
          if ((unint64_t)v9 >= 0x801)
          {
            v14 = *v12;
            v15 = *v8;
            v16 = vmovn_s32(vcgtq_s32(*v12, v13)).i8[4];
            if ((vmovn_s32(vcgtq_s32(*v8, *v12)).i32[1] & 1) != 0)
            {
              if ((v16 & 1) != 0)
              {
                *v8 = v13;
              }
              else
              {
                *v8 = v14;
                *v12 = v15;
                v22 = a2[-1];
                if ((vmovn_s32(vcgtq_s32(v15, v22)).i32[1] & 1) == 0)
                  goto LABEL_22;
                *v12 = v22;
              }
              a2[-1] = v15;
            }
            else if ((v16 & 1) != 0)
            {
              *v12 = v13;
              a2[-1] = v14;
              v20 = *v8;
              if ((vmovn_s32(vcgtq_s32(*v8, *v12)).i32[1] & 1) != 0)
              {
                *v8 = *v12;
                *v12 = v20;
              }
            }
LABEL_22:
            v23 = v11 - 1;
            v24 = v8[v11 - 1];
            v25 = v8[1];
            v26 = a2[-2];
            v27 = vmovn_s32(vcgtq_s32(v24, v26)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v25, v24)).i32[1] & 1) != 0)
            {
              if ((v27 & 1) != 0)
              {
                v8[1] = v26;
              }
              else
              {
                v8[1] = v24;
                v8[v23] = v25;
                v31 = a2[-2];
                if ((vmovn_s32(vcgtq_s32(v25, v31)).i32[1] & 1) == 0)
                  goto LABEL_34;
                v8[v23] = v31;
              }
              a2[-2] = v25;
            }
            else if ((v27 & 1) != 0)
            {
              v8[v23] = v26;
              a2[-2] = v24;
              v28 = v8[v23];
              v29 = v8[1];
              if ((vmovn_s32(vcgtq_s32(v29, v28)).i32[1] & 1) != 0)
              {
                v8[1] = v28;
                v8[v23] = v29;
              }
            }
LABEL_34:
            v32 = &v8[v11];
            v34 = v32[1];
            v33 = v32 + 1;
            v35 = v34;
            v36 = v8[2];
            v37 = a2[-3];
            v38 = vmovn_s32(vcgtq_s32(v34, v37)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v36, v34)).i32[1] & 1) != 0)
            {
              if ((v38 & 1) != 0)
              {
                v8[2] = v37;
              }
              else
              {
                v8[2] = v35;
                *v33 = v36;
                v40 = a2[-3];
                if ((vmovn_s32(vcgtq_s32(v36, v40)).i32[1] & 1) == 0)
                  goto LABEL_43;
                *v33 = v40;
              }
              a2[-3] = v36;
            }
            else if ((v38 & 1) != 0)
            {
              *v33 = v37;
              a2[-3] = v35;
              v39 = v8[2];
              if ((vmovn_s32(vcgtq_s32(v39, *v33)).i32[1] & 1) != 0)
              {
                v8[2] = *v33;
                *v33 = v39;
              }
            }
LABEL_43:
            v41 = *v12;
            v42 = v8[v23];
            v43 = *v33;
            v44 = vmovn_s32(vcgtq_s32(*v12, *v33)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v42, *v12)).i32[1] & 1) != 0)
            {
              if ((v44 & 1) != 0)
              {
                v8[v23] = v43;
              }
              else
              {
                v8[v23] = v41;
                *v12 = v42;
                if ((vmovn_s32(vcgtq_s32(v42, v43)).i32[1] & 1) == 0)
                {
                  v41 = v42;
                  goto LABEL_52;
                }
                *v12 = v43;
                v41 = v43;
              }
            }
            else
            {
              if ((v44 & 1) == 0)
              {
LABEL_52:
                v45 = *v8;
                *v8 = v41;
                *v12 = v45;
                goto LABEL_53;
              }
              *v12 = v43;
              *v33 = v41;
              if ((vmovn_s32(vcgtq_s32(v42, v43)).i32[1] & 1) == 0)
              {
                v41 = v43;
                goto LABEL_52;
              }
              v8[v23] = v43;
              v33 = v12;
              v41 = v42;
            }
            *v33 = v42;
            goto LABEL_52;
          }
          v17 = *v8;
          v18 = *v12;
          v19 = vmovn_s32(vcgtq_s32(*v8, v13)).i8[4];
          if ((vmovn_s32(vcgtq_s32(*v12, *v8)).i32[1] & 1) != 0)
          {
            if ((v19 & 1) != 0)
            {
              *v12 = v13;
            }
            else
            {
              *v12 = v17;
              *v8 = v18;
              v30 = a2[-1];
              if ((vmovn_s32(vcgtq_s32(v18, v30)).i32[1] & 1) == 0)
                goto LABEL_53;
              *v8 = v30;
            }
            a2[-1] = v18;
          }
          else if ((v19 & 1) != 0)
          {
            *v8 = v13;
            a2[-1] = v17;
            v21 = *v12;
            if ((vmovn_s32(vcgtq_s32(*v12, *v8)).i32[1] & 1) != 0)
            {
              *v12 = *v8;
              *v8 = v21;
            }
          }
LABEL_53:
          --a3;
          v46 = *v8;
          if ((a4 & 1) == 0)
          {
            v47 = v8->i64[1];
            if (v8[-1].i32[2] < v46.i32[2])
              goto LABEL_56;
            if (v46.i32[2] >= a2[-1].i32[2])
            {
              v62 = (unint64_t)&v8[1];
              do
              {
                v8 = (int32x4_t *)v62;
                if (v62 >= (unint64_t)a2)
                  break;
                v63 = *(_DWORD *)(v62 + 8);
                v62 += 16;
              }
              while (v46.i32[2] >= v63);
            }
            else
            {
              v60 = v8;
              do
              {
                v8 = v60 + 1;
                v61 = v60[1].i32[2];
                ++v60;
              }
              while (v46.i32[2] >= v61);
            }
            v64 = a2;
            if (v8 < a2)
            {
              v65 = a2;
              do
              {
                v64 = v65 - 1;
                v66 = v65[-1].i32[2];
                --v65;
              }
              while (v46.i32[2] < v66);
            }
            while (v8 < v64)
            {
              v67 = *v8;
              *v8 = *v64;
              *v64 = v67;
              do
              {
                v68 = v8[1].i32[2];
                ++v8;
              }
              while (v46.i32[2] >= v68);
              do
              {
                v69 = v64[-1].i32[2];
                --v64;
              }
              while (v46.i32[2] < v69);
            }
            v70 = v8 - 1;
            if (&v8[-1] != v7)
              *v7 = *v70;
            a4 = 0;
            *v70 = v46;
            continue;
          }
          v47 = v8->i64[1];
LABEL_56:
          v48 = v8;
          do
            v49 = v48++;
          while (v49[1].i32[2] < v47);
          v50 = a2;
          if (v49 == v8)
          {
            v53 = a2;
            while (v48 < v53)
            {
              v51 = v53 - 1;
              v54 = v53[-1].i32[2];
              --v53;
              if (v54 < v47)
                goto LABEL_66;
            }
            v51 = v53;
          }
          else
          {
            do
            {
              v51 = v50 - 1;
              v52 = v50[-1].i32[2];
              --v50;
            }
            while (v52 >= v47);
          }
LABEL_66:
          if (v48 < v51)
          {
            v55 = v48;
            v56 = v51;
            do
            {
              v57 = *v55;
              *v55 = *v56;
              *v56 = v57;
              do
                v49 = v55++;
              while (v49[1].i32[2] < v47);
              do
              {
                v58 = v56[-1].i32[2];
                --v56;
              }
              while (v58 >= v47);
            }
            while (v55 < v56);
          }
          if (v49 != v8)
            *v8 = *v49;
          *v49 = v46;
          if (v48 < v51)
            goto LABEL_77;
          v59 = sub_1D3D6F4D0(v8, v49);
          v8 = v49 + 1;
          result = sub_1D3D6F4D0(v49 + 1, a2);
          if (!(_DWORD)result)
          {
            if (v59)
              continue;
LABEL_77:
            result = sub_1D3D6DB98(v7, v49, a3, a4 & 1);
            a4 = 0;
            v8 = v49 + 1;
            continue;
          }
          a2 = v49;
          if (v59)
            return result;
          goto LABEL_2;
        }
        v91 = v8 + 1;
        v93 = v8 == a2 || v91 == a2;
        if ((a4 & 1) != 0)
        {
          if (!v93)
          {
            v94 = 0;
            v95 = v8;
            do
            {
              v96 = v95[1];
              v97 = v95->i32[2];
              v95 = v91;
              if (v96.i32[2] < v97)
              {
                v98 = v94;
                while (1)
                {
                  *(int32x4_t *)((char *)&v8[1] + v98) = *(int32x4_t *)((char *)v8 + v98);
                  if (!v98)
                    break;
                  v99 = *(__int32 *)((char *)&v8->i32[-2] + v98);
                  v98 -= 16;
                  if (v96.i32[2] >= v99)
                  {
                    v100 = (int32x4_t *)((char *)v8 + v98 + 16);
                    goto LABEL_127;
                  }
                }
                v100 = v8;
LABEL_127:
                *v100 = v96;
              }
              v91 = v95 + 1;
              v94 += 16;
            }
            while (&v95[1] != a2);
          }
        }
        else if (!v93)
        {
          do
          {
            v134 = v7[1];
            v135 = v7->i32[2];
            v7 = v91;
            if (v134.i32[2] < v135)
            {
              do
              {
                v136 = v91;
                v137 = v91[-1];
                --v91;
                *v136 = v137;
              }
              while (v134.i32[2] < v136[-2].i32[2]);
              *v91 = v134;
            }
            v91 = v7 + 1;
          }
          while (&v7[1] != a2);
        }
        return result;
    }
  }
}

uint64_t sub_1D3D6E654(int32x2_t *a1, int a2, signed int a3, int a4, int a5)
{
  int v8;
  unsigned int v9;
  double v10;
  int32x4_t *v11;
  int v12;
  signed int v13;
  int v14;
  int v15;
  uint64_t result;
  double v17;
  int32x4_t *v18;
  int v19;
  int v20;
  double v21;
  int32x4_t *v22;
  int v23;

  if (a2 <= 1)
    v8 = 1;
  else
    v8 = a2;
  if (a5 <= 1)
    v9 = 1;
  else
    v9 = a5;
  v10 = *(double *)&a1[1];
  if ((LODWORD(v10) & 0x80000000) != 0
    || (v11 = (int32x4_t *)*a1, *(_QWORD *)(*(_QWORD *)a1 + 8) <= (unint64_t)LODWORD(v10))
    || (HIDWORD(v10) & 0x80000000) != 0
    || v11[1].i64[0] <= (unint64_t)HIDWORD(v10))
  {
    v12 = -1;
  }
  else
  {
    v12 = sub_1D3E0BA8C(v11, v10);
  }
  v13 = 0;
  v14 = 0;
  do
  {
    v15 = v12;
    if (a3)
    {
      result = 0xFFFFFFFFLL;
      if (v13 >= a3 || v12 == -1)
        return result;
    }
    else if (v12 == -1)
    {
      return 0xFFFFFFFFLL;
    }
    v13 += v9;
    v17 = COERCE_DOUBLE(vmla_s32(a1[1], a1[2], vdup_n_s32(v13)));
    if ((LODWORD(v17) & 0x80000000) != 0
      || (v18 = (int32x4_t *)*a1, *(_QWORD *)(*(_QWORD *)a1 + 8) <= (unint64_t)LODWORD(v17))
      || (HIDWORD(v17) & 0x80000000) != 0
      || v18[1].i64[0] <= (unint64_t)HIDWORD(v17))
    {
      v12 = -1;
    }
    else
    {
      v12 = sub_1D3E0BA8C(v18, v17);
    }
    v19 = v15 != v12 && (int)(v14 + v9) >= a4;
    if (v15 != v12 && (int)(v14 + v9) >= a4)
      v14 = 0;
    else
      v14 += v9;
    v8 -= v19;
  }
  while (v8);
  if (v9 < 2)
  {
LABEL_43:
    v23 = 1;
  }
  else
  {
    v13 -= v9;
    v20 = v12;
    if (!a3)
      goto LABEL_32;
LABEL_31:
    if (v13 < a3)
    {
LABEL_32:
      while (v20 != -1)
      {
        v21 = COERCE_DOUBLE(vmla_s32(a1[1], a1[2], vdup_n_s32(v13)));
        if ((LODWORD(v21) & 0x80000000) != 0
          || (v22 = (int32x4_t *)*a1, *(_QWORD *)(*(_QWORD *)a1 + 8) <= (unint64_t)LODWORD(v21))
          || (HIDWORD(v21) & 0x80000000) != 0
          || v22[1].i64[0] <= (unint64_t)HIDWORD(v21))
        {
          v20 = -1;
        }
        else
        {
          v20 = sub_1D3E0BA8C(v22, v21);
        }
        if (v20 == v12)
          goto LABEL_43;
        ++v13;
        if (a3)
          goto LABEL_31;
      }
    }
    v23 = 0;
  }
  a1[1] = vmla_s32(a1[1], vdup_n_s32(v13 - 1), a1[2]);
  if (v23)
    return (v13 - 1);
  else
    return 0xFFFFFFFFLL;
}

void sub_1D3D6E838(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      sub_1D3D6D4F8();
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)sub_1D3D6D8A0(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    v7 = &v4[8 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_QWORD *)v8 - 1);
        v8 -= 8;
        *((_QWORD *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void sub_1D3D6E8CC(float32x2_t **a1, char **a2, float32x2_t a3)
{
  char *v6;
  char *v7;
  float32x2_t *v8;
  float32x2_t v9;
  char *v10;
  float32x2_t *v11;
  float32x2_t v12;
  int8x8_t v13;
  float32x2_t v14;
  int32x2_t v15;
  float32x2_t v16;
  int32x2_t v17;
  float32x2_t v18;
  unsigned __int8 v19;
  unsigned int v20;
  char *v21;
  char *v22;
  _QWORD *v23;
  float32x2_t v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t v27;
  float32x2_t *v28;
  unint64_t v29;
  float32x2_t *v30;
  float32x2_t v32;
  uint64_t v33;
  int32x2_t *v34;
  float32x2_t *v35;
  float32x2_t v36;
  int8x8_t v37;
  float32x2_t v38;
  int32x2_t v39;
  float32x2_t v40;
  int32x2_t v41;
  float32x2_t v42;
  unsigned __int8 v43;
  unsigned int v44;
  double v45;
  int32x2_t v46;
  __int128 v47;
  unint64_t v48;
  float32x2_t v49;
  float32x2_t *v50;
  float32x2_t *v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x2_t v54;
  uint64_t v55;
  float32x2_t *v56;
  float32x2_t v57;
  int8x8_t v58;
  int32x2_t v59;
  int32x2_t v60;
  float32x2_t v61;
  unsigned __int8 v62;
  unsigned int v63;
  char *v64;
  float32x2_t v65;
  float32x2_t *v66;
  unint64_t v67;
  float32x2_t *v68;
  float32x2_t v69;
  float32x2_t v70;
  float32x2_t v71;
  uint64_t v72;
  float32x2_t *v73;
  float32x2_t v74;
  int8x8_t v75;
  int32x2_t v76;
  int32x2_t v77;
  float32x2_t v78;
  unsigned __int8 v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  int32x2_t v83;
  float32x2_t *v84;
  int32x2_t v85;
  double v86;
  float32x2_t v87;
  float32x2_t *v88;
  unint64_t v89;
  int32x2_t v90;
  double v91;
  float32x2_t v92;
  float32x2_t *v93;
  uint64_t v94;
  int32x2_t v95;
  float32x2_t *v96;
  unint64_t v97;
  void *v98;
  float32x2_t *v99;
  int32x2_t v100;
  float32x2_t *v101;
  uint64_t v102;
  float32x2_t *v103;
  float v104;
  float32x2_t *v105;
  float32x2_t v106;
  float32x2_t v107;
  float32x2_t v108;
  float32x2_t v109;
  float32x2_t v110;
  float32x2_t v111;
  float v112;
  uint64_t v113;
  float32x2_t v114;
  float32x2_t v115;
  float32x2_t v116;
  float v117;
  float *v118;
  uint64_t v119;
  char *v120;
  uint64_t i;
  void *v122;
  void *v123[2];
  _BYTE v124[24];
  int v125;
  void *v126;
  void *v127;
  uint64_t v128;
  __int128 v129;
  int32x2_t v130;
  void *__p;
  void *v132;
  uint64_t v133;
  __int128 v134;
  int32x2_t v135;
  __int128 v136;
  _BYTE v137[24];
  __int32 v138;
  unsigned int *v139;
  float32x2_t v140[4];
  int v141;
  void *v142[3];
  __int128 v143;
  int v144;
  uint64_t v145;

  v145 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = a2[1];
  if (*a2 == v7 || (v8 = (float32x2_t *)(v6 + 8), v6 + 8 == v7))
  {
    v10 = *a2;
  }
  else
  {
    v9 = *(float32x2_t *)v6;
    v10 = *a2;
    v11 = (float32x2_t *)(v6 + 8);
    do
    {
      v12 = *v11++;
      v13 = (int8x8_t)v12;
      v14 = vsub_f32(v9, a3);
      v15 = (int32x2_t)vmul_f32(v14, v14);
      v16 = vsub_f32(v12, a3);
      v17 = (int32x2_t)vmul_f32(v16, v16);
      v18 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v15, v17), (float32x2_t)vzip2_s32(v15, v17)));
      v19 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v18, 1), v18).u8[0];
      if ((v19 & 1) != 0)
        v20 = -1;
      else
        v20 = 0;
      v9 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v20), v13, (int8x8_t)v9);
      if ((v19 & 1) != 0)
        v10 = (char *)v8;
      v8 = v11;
    }
    while (v11 != (float32x2_t *)v7);
  }
  sub_1D3D6F124(v6, v10, v7);
  v22 = *a2;
  v21 = a2[1];
  v23 = operator new(0x20uLL);
  v25 = v23;
  v26 = (v21 - v22) >> 3;
  v23[2] = 0;
  v23[3] = 0;
  *v23 = v22;
  v23[1] = 0;
  v27 = (3 * v26) >> 3;
  v28 = (float32x2_t *)&v22[8 * v27];
  v29 = (5 * v26) >> 3;
  v30 = v28 + 1;
  if (v27 == v29 || v30 == (float32x2_t *)&v22[8 * v29])
  {
    v34 = (int32x2_t *)&v22[8 * v27];
  }
  else
  {
    v32 = *v28;
    v33 = 8 * v29 - 8 * v27 - 8;
    v34 = (int32x2_t *)&v22[8 * v27];
    v35 = v28 + 1;
    do
    {
      v36 = *v35++;
      v37 = (int8x8_t)v36;
      v38 = vsub_f32(v32, a3);
      v39 = (int32x2_t)vmul_f32(v38, v38);
      v40 = vsub_f32(v36, a3);
      v41 = (int32x2_t)vmul_f32(v40, v40);
      v42 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v39, v41), (float32x2_t)vzip2_s32(v39, v41)));
      v24 = (float32x2_t)vdup_lane_s32((int32x2_t)v42, 1);
      v43 = vcgt_f32(v24, v42).u8[0];
      if ((v43 & 1) != 0)
        v44 = -1;
      else
        v44 = 0;
      v32 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v44), v37, (int8x8_t)v32);
      if ((v43 & 1) != 0)
        v34 = (int32x2_t *)v30;
      v30 = v35;
      v33 -= 8;
    }
    while (v33);
  }
  v23[2] = v34;
  v45 = *(double *)v22;
  v46 = *v34;
  v136 = 0u;
  *(_OWORD *)v137 = 0u;
  *(int32x2_t *)&v137[16] = vdup_n_s32(0x7FC00000u);
  v138 = 2143289344;
  v140[0] = *(float32x2_t *)&v45;
  v140[1] = (float32x2_t)v46;
  sub_1D3D6F310((float32x2_t *)&v136, v140, 2uLL, v45, v46, *(double *)&v137[16], v24);
  v132 = 0;
  v133 = 0;
  __p = 0;
  v47 = v136;
  v48 = (uint64_t)(*((_QWORD *)&v136 + 1) - v136) >> 3;
  sub_1D3D6F268(&__p, (const void *)v136, *((uint64_t *)&v136 + 1), v48);
  v50 = (float32x2_t *)&v22[8 * (v26 >> 3)];
  v134 = *(_OWORD *)&v137[8];
  v135.i32[0] = v138;
  if (v26 >> 3 != v27)
  {
    v51 = v50 + 1;
    if (&v50[1] != v28)
    {
      v49.i32[0] = 0;
      v52 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(v49, *(float32x2_t *)((char *)&v134 + 8)), (int8x8_t)vcge_f32(*(float32x2_t *)((char *)&v134 + 8), v49)), 0), *(int8x8_t *)((char *)&v134 + 8), *(int8x8_t *)&v134);
      v53 = *v50;
      v54 = (float32x2_t)vdup_lane_s32(v135, 0);
      v55 = 8 * v27 - 8 * (v26 >> 3) - 8;
      v56 = v50 + 1;
      do
      {
        v57 = *v56++;
        v58 = (int8x8_t)v57;
        v59 = (int32x2_t)vmul_f32(v52, v53);
        v60 = (int32x2_t)vmul_f32(v52, v57);
        v61 = vabd_f32(vadd_f32((float32x2_t)vzip1_s32(v59, v60), (float32x2_t)vzip2_s32(v59, v60)), v54);
        v62 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v61, 1), v61).u8[0];
        if ((v62 & 1) != 0)
          v63 = -1;
        else
          v63 = 0;
        v53 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v63), v58, (int8x8_t)v53);
        if ((v62 & 1) != 0)
          v50 = v51;
        v51 = v56;
        v55 -= 8;
      }
      while (v55);
    }
  }
  v25[1] = v50;
  if (__p)
  {
    v132 = __p;
    operator delete(__p);
  }
  v64 = *a2;
  v127 = 0;
  v128 = 0;
  v126 = 0;
  sub_1D3D6F268(&v126, (const void *)v47, *((uint64_t *)&v47 + 1), v48);
  v66 = (float32x2_t *)&v64[8 * v29];
  v67 = (7 * v26) >> 3;
  v129 = *(_OWORD *)&v137[8];
  v130.i32[0] = v138;
  if (v29 != v67)
  {
    v68 = v66 + 1;
    if (&v66[1] != (float32x2_t *)&v64[8 * v67])
    {
      v65.i32[0] = 0;
      v69 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(v65, *(float32x2_t *)((char *)&v129 + 8)), (int8x8_t)vcge_f32(*(float32x2_t *)((char *)&v129 + 8), v65)), 0), *(int8x8_t *)((char *)&v129 + 8), *(int8x8_t *)&v129);
      v70 = *v66;
      v71 = (float32x2_t)vdup_lane_s32(v130, 0);
      v72 = 8 * v67 - 8 * v29 - 8;
      v73 = v66 + 1;
      do
      {
        v74 = *v73++;
        v75 = (int8x8_t)v74;
        v76 = (int32x2_t)vmul_f32(v69, v70);
        v77 = (int32x2_t)vmul_f32(v69, v74);
        v78 = vabd_f32(vadd_f32((float32x2_t)vzip1_s32(v76, v77), (float32x2_t)vzip2_s32(v76, v77)), v71);
        v79 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v78, 1), v78).u8[0];
        if ((v79 & 1) != 0)
          v80 = -1;
        else
          v80 = 0;
        v70 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v80), v75, (int8x8_t)v70);
        if ((v79 & 1) != 0)
          v66 = v68;
        v68 = v73;
        v72 -= 8;
      }
      while (v72);
    }
  }
  v25[3] = v66;
  if (v126)
  {
    v127 = v126;
    operator delete(v126);
  }
  v81 = 0;
  v82 = 0;
  v83 = vdup_n_s32(0x7FC00000u);
  do
  {
    v84 = &v140[v81];
    *(_OWORD *)v84->f32 = 0u;
    *(_OWORD *)v84[2].f32 = 0u;
    v84[4] = (float32x2_t)v83;
    v84[5].i32[0] = 2143289344;
    sub_1D3D6E838((void **)&v140[v81], 0x10uLL);
    ++v82;
    v81 += 6;
  }
  while (v81 != 24);
  v88 = (float32x2_t *)v25[3];
  v89 = (a2[1] - (char *)v88) >> 3;
  *(_OWORD *)v123 = 0u;
  *(_OWORD *)v124 = 0u;
  *(int32x2_t *)&v124[16] = vdup_n_s32(0x7FC00000u);
  v125 = 2143289344;
  sub_1D3D6F310((float32x2_t *)v123, v88, v89, *(double *)&v124[16], v85, v86, v87);
  if (v142[0])
  {
    v142[1] = v142[0];
    operator delete(v142[0]);
  }
  *(_OWORD *)v142 = *(_OWORD *)v123;
  v142[2] = *(void **)v124;
  v143 = *(_OWORD *)&v124[8];
  v144 = v125;
  v93 = v140;
  v94 = 1;
  v95 = vdup_n_s32(0x7FC00000u);
  while (v94 != 4)
  {
    v96 = (float32x2_t *)v25[v94 - 1];
    v97 = (uint64_t)(v25[v94] - (_QWORD)v96) >> 3;
    *(_OWORD *)v123 = 0u;
    *(_OWORD *)v124 = 0u;
    *(int32x2_t *)&v124[16] = v95;
    v125 = 2143289344;
    sub_1D3D6F310((float32x2_t *)v123, v96, v97, 0.0, v90, v91, v92);
    v98 = (void *)*v93;
    if (*v93)
    {
      v93[1] = (float32x2_t)v98;
      operator delete(v98);
    }
    *(_OWORD *)v93->f32 = *(_OWORD *)v123;
    v93[2] = *(float32x2_t *)v124;
    *(_OWORD *)v93[3].f32 = *(_OWORD *)&v124[8];
    v93[5].i32[0] = v125;
    ++v94;
    v93 += 6;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v99 = (float32x2_t *)operator new(0x20uLL);
  v101 = v99;
  v102 = 0;
  a1[1] = v99 + 4;
  a1[2] = v99 + 4;
  *(_OWORD *)v99->f32 = 0u;
  *(_OWORD *)v99[2].f32 = 0u;
  *a1 = v99;
  v103 = (float32x2_t *)&v141;
  do
  {
    v104 = v103[-1].f32[1];
    v105 = &v140[6 * (((int)v102 + 1) & 3)];
    v106 = *v103;
    v103 += 6;
    v107 = vneg_f32(v106);
    v108 = *(float32x2_t *)((char *)v105 + 36);
    *(float *)v100.i32 = vmlas_n_f32(v105[4].f32[0] * v107.f32[0], v104, v108.f32[0]);
    v109.i32[0] = vdup_lane_s32((int32x2_t)v108, 1).u32[0];
    v109.i32[1] = v105[4].i32[0];
    v110.i32[0] = vdup_lane_s32((int32x2_t)v106, 1).u32[0];
    v110.f32[1] = v104;
    v99[v102++] = vdiv_f32(vmla_f32(vmul_f32(v109, v107), v108, v110), (float32x2_t)vdup_lane_s32(v100, 0));
  }
  while (v102 != 4);
  v111 = vsub_f32(*v99, v99[3]);
  v112 = sqrtf(vaddv_f32(vmul_f32(v111, v111)));
  v113 = 1;
  v114 = *v99;
  do
  {
    v115 = v99[v113];
    v116 = vsub_f32(v114, v115);
    v112 = v112 + sqrtf(vaddv_f32(vmul_f32(v116, v116)));
    ++v113;
    v114 = v115;
  }
  while (v113 != 4);
  v117 = v112 * 0.25;
  sub_1D3DB93EC((uint64_t *)&v139, 0.0, 0.0, v117, 0.0, v117, v117, 0.0, v117, COERCE_FLOAT(*v99), COERCE_FLOAT(HIDWORD(*(unint64_t *)v99)), COERCE_FLOAT(*(_QWORD *)&v99[1]), COERCE_FLOAT(HIDWORD(*(_QWORD *)&v99[1])), COERCE_FLOAT(*(_QWORD *)&v99[2]), COERCE_FLOAT(HIDWORD(*(_QWORD *)&v99[2])), COERCE_FLOAT(*(_QWORD *)&v99[3]), COERCE_FLOAT(HIDWORD(*(_QWORD *)&v99[3])));
  v118 = (float *)operator new(0x20uLL);
  v123[1] = v118 + 8;
  *(_QWORD *)v124 = v118 + 8;
  *(_QWORD *)v118 = 0xBF000000BF000000;
  v118[2] = v117 + 0.5;
  v118[3] = -0.5;
  v118[4] = v117 + 0.5;
  v118[5] = v117 + 0.5;
  v118[6] = -0.5;
  v118[7] = v117 + 0.5;
  v123[0] = v118;
  (*(void (**)(unsigned int *, void **))(*(_QWORD *)v139 + 16))(v139, v123);
  v119 = 0;
  v120 = (char *)v123[0];
  do
  {
    v101[v119] = *(float32x2_t *)&v120[v119 * 8];
    ++v119;
  }
  while (v119 != 4);
  v123[1] = v120;
  operator delete(v120);
  sub_1D3D6F2E0(&v139);
  for (i = 0; i != -24; i -= 6)
  {
    v122 = v142[i];
    if (v122)
    {
      v142[i + 1] = v122;
      operator delete(v122);
    }
  }
  if ((_QWORD)v47)
    operator delete((void *)v47);
  operator delete(v25);
}

void sub_1D3D6EFC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,unsigned int *a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  void *v61;
  void *v62;
  void *v63;
  uint64_t v65;
  void *v66;

  if (__p)
    operator delete(__p);
  sub_1D3D6F2E0(&a39);
  *(_QWORD *)(a14 + 8) = v63;
  operator delete(v63);
  v65 = 0;
  while (1)
  {
    v66 = *(void **)((char *)&a60 + v65);
    if (v66)
    {
      *(uint64_t *)((char *)&a61 + v65) = (uint64_t)v66;
      operator delete(v66);
    }
    v65 -= 48;
    if (v65 == -192)
    {
      if (v62)
        operator delete(v62);
      operator delete(v61);
      _Unwind_Resume(a1);
    }
  }
}

BOOL sub_1D3D6F09C(float32x2_t *a1, uint64_t a2, int a3)
{
  float32x2_t v4;
  float32x2_t v5;
  float v6;
  uint64_t v7;
  float v8;
  float32x2_t v9;
  float32x2_t v10;
  float v11;

  if ((unint64_t)(a2 - (_QWORD)a1) < 0x20)
    return 0;
  v4 = *a1;
  v5 = vsub_f32(a1[3], a1[1]);
  v6 = sqrtf(vaddv_f32(vmul_f32(v5, v5)));
  v7 = 1;
  v8 = v6;
  do
  {
    v9 = a1[v7];
    v10 = vsub_f32(v4, v9);
    v11 = sqrtf(vaddv_f32(vmul_f32(v10, v10)));
    if (v11 < v6)
      v6 = v11;
    if (v8 < v11)
      v8 = v11;
    ++v7;
    v4 = v9;
  }
  while (v7 != 4);
  return v6 > (float)(v8 / 3.0) && v6 >= (float)a3;
}

char *sub_1D3D6F124(char *__src, char *a2, char *a3)
{
  _QWORD *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  BOOL v22;
  char v23;
  uint64_t v24;

  if (__src != a2 && a2 != a3)
  {
    v3 = __src;
    if (__src + 8 == a2)
    {
      v9 = *(_QWORD *)__src;
      v10 = a3 - a2;
      __src = (char *)memmove(__src, a2, a3 - a2);
      *(_QWORD *)((char *)v3 + v10) = v9;
    }
    else if (a2 + 8 == a3)
    {
      v11 = *((_QWORD *)a3 - 1);
      if (a3 - 8 != __src)
        __src = (char *)memmove(__src + 8, __src, a3 - 8 - __src);
      *v3 = v11;
    }
    else
    {
      v4 = (a2 - __src) >> 3;
      if (v4 == (a3 - a2) >> 3)
      {
        v5 = __src + 8;
        v6 = a2 + 8;
        do
        {
          v7 = *((_QWORD *)v5 - 1);
          *((_QWORD *)v5 - 1) = *((_QWORD *)v6 - 1);
          *((_QWORD *)v6 - 1) = v7;
          if (v5 == a2)
            break;
          v5 += 8;
          v8 = v6 == a3;
          v6 += 8;
        }
        while (!v8);
      }
      else
      {
        v12 = (a3 - a2) >> 3;
        v13 = (a2 - __src) >> 3;
        do
        {
          v14 = v13;
          v13 = v12;
          v12 = v14 % v12;
        }
        while (v12);
        if (v13)
        {
          v15 = &__src[8 * v13];
          do
          {
            v16 = *((_QWORD *)v15 - 1);
            v15 -= 8;
            v17 = v16;
            v18 = &v15[8 * v4];
            v19 = v15;
            do
            {
              v20 = v18;
              *(_QWORD *)v19 = *(_QWORD *)v18;
              v21 = &v18[8 * v4];
              v22 = __OFSUB__(v4, (a3 - v18) >> 3);
              v24 = v4 - ((a3 - v18) >> 3);
              v23 = (v24 < 0) ^ v22;
              v18 = &__src[8 * v24];
              if (v23)
                v18 = v21;
              v19 = v20;
            }
            while (v18 != v15);
            *(_QWORD *)v20 = v17;
          }
          while (v15 != __src);
        }
      }
    }
  }
  return __src;
}

_QWORD *sub_1D3D6F268(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_1D3D6D864(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1D3D6F2C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned int **sub_1D3D6F2E0(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

float sub_1D3D6F310(float32x2_t *a1, float32x2_t *a2, unint64_t a3, double a4, int32x2_t a5, double a6, float32x2_t a7)
{
  uint64_t v7;
  float32x2_t v8;
  uint64_t v9;
  float32x2_t *v10;
  float32x2_t v11;
  int32x2_t v12;
  float32x2_t v13;
  float v14;
  float v15;
  float32x2_t v16;
  float v24;
  float v25;
  float32x2_t v26;
  int8x8_t v27;
  float result;

  if (a3)
  {
    v7 = 8 * a3;
    v8 = 0;
    v9 = 8 * a3;
    v10 = a2;
    do
    {
      v11 = *v10++;
      v12.i32[1] = v11.i32[1];
      v8 = vadd_f32(v8, v11);
      v9 -= 8;
    }
    while (v9);
    *(float *)v12.i32 = (float)a3;
    a5 = vdup_lane_s32(v12, 0);
    v13 = vdiv_f32(v8, (float32x2_t)a5);
    v14 = 0.0;
    v15 = 0.0;
    do
    {
      v16 = *a2++;
      _D4 = vsub_f32(v16, v13);
      v14 = vmlas_n_f32(v14, _D4.f32[0], _D4.f32[0]);
      _S5 = _D4.i32[1];
      __asm { FMLA            S1, S5, V4.S[1] }
      v15 = vmlas_n_f32(v15, _D4.f32[1], _D4.f32[0]);
      v7 -= 8;
    }
    while (v7);
    if (_S1 < v14)
    {
      v24 = sqrtf((float)(v15 * v15) + (float)(v14 * v14));
      *(float *)a5.i32 = v15 / v24;
      goto LABEL_10;
    }
  }
  else
  {
    v13 = (float32x2_t)vdup_n_s32(0x7FC00000u);
    _S1 = 0.0;
    v15 = 0.0;
  }
  v24 = sqrtf((float)(v15 * v15) + (float)(_S1 * _S1));
  *(float *)a5.i32 = _S1 / v24;
  v14 = v15;
LABEL_10:
  v25 = (float)-v14 / v24;
  a1[4].i32[0] = a5.i32[0];
  a1[4].f32[1] = v25;
  v26 = a1[3];
  a7.i32[0] = 0;
  v27 = (int8x8_t)__PAIR64__(LODWORD(v25), a5.u32[0]);
  if (vaddv_f32(vmul_f32(v26, (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(a7, (float32x2_t)a5), (int8x8_t)vcge_f32((float32x2_t)a5, a7)), 0), (int8x8_t)__PAIR64__(LODWORD(v25), a5.u32[0]), (int8x8_t)v26))) < 0.0)
  {
    *(float *)&a5.i32[1] = v25;
    v27 = (int8x8_t)vneg_f32((float32x2_t)a5);
    a1[4] = (float32x2_t)v27;
    a5.i32[0] = v27.i32[0];
  }
  result = vaddv_f32(vmul_f32(v13, (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(a7, (float32x2_t)a5), (int8x8_t)vcge_f32((float32x2_t)a5, a7)), 0), v27, (int8x8_t)v26)));
  a1[5].f32[0] = result;
  return result;
}

uint64_t sub_1D3D6F420(uint64_t a1, int32x2_t a2)
{
  double v4;
  int32x4_t *v5;
  unsigned int v6;
  double v7;
  int v8;

  v4 = *(double *)(a1 + 8);
  v5 = *(int32x4_t **)a1;
  if ((LODWORD(v4) & 0x80000000) != 0
    || v5->i64[1] <= (unint64_t)LODWORD(v4)
    || (HIDWORD(v4) & 0x80000000) != 0
    || v5[1].i64[0] <= (unint64_t)HIDWORD(v4))
  {
    v6 = -1;
  }
  else
  {
    v6 = sub_1D3E0BA8C(v5, v4);
    v4 = *(double *)(a1 + 8);
    v5 = *(int32x4_t **)a1;
  }
  v7 = COERCE_DOUBLE(vadd_s32(*(int32x2_t *)&v4, a2));
  if ((LODWORD(v7) & 0x80000000) != 0
    || v5->i64[1] <= (unint64_t)LODWORD(v7)
    || (HIDWORD(v7) & 0x80000000) != 0
    || v5[1].i64[0] <= (unint64_t)HIDWORD(v7))
  {
    v8 = -1;
  }
  else
  {
    v8 = sub_1D3E0BA8C(v5, v7);
  }
  if (v8 == v6)
    return 0xFFFFFFFFLL;
  else
    return v6;
}

BOOL sub_1D3D6F4D0(int32x4_t *a1, int32x4_t *a2)
{
  uint64_t v2;
  int32x4_t v3;
  int32x4_t v4;
  int32x4_t *v5;
  int32x4_t v6;
  int32x4_t *v7;
  int32x4_t v8;
  int32x4_t v9;
  __int8 v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  __int8 v14;
  int32x4_t *v15;
  int32x4_t v16;
  int32x4_t *v17;
  int32x4_t v18;
  int32x4_t v19;
  __int8 v20;
  int32x4_t *v21;
  int32x4_t v22;
  int32x4_t *v23;
  int32x4_t v24;
  int32x4_t *v25;
  int32x4_t v26;
  int32x4_t v27;
  __int8 v28;
  int32x4_t v29;
  int32x4_t *v30;
  int32x4_t *v31;
  uint64_t v32;
  int v33;
  int32x4_t v34;
  __int32 v35;
  uint64_t v36;
  __int32 v37;
  int32x4_t *v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;

  v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      v3 = a2[-1];
      v4 = *a1;
      if ((vmovn_s32(vcgtq_s32(*a1, v3)).i32[1] & 1) != 0)
      {
        *a1 = v3;
        a2[-1] = v4;
      }
      return 1;
    case 3:
      v11 = *a1;
      v12 = a1[1];
      v13 = a2[-1];
      v14 = vmovn_s32(vcgtq_s32(v12, v13)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v12)).i32[1] & 1) == 0)
      {
        if ((v14 & 1) == 0)
          return 1;
        a1[1] = v13;
        a2[-1] = v12;
        v29 = a1[1];
        goto LABEL_70;
      }
      if ((v14 & 1) != 0)
      {
        *a1 = v13;
      }
      else
      {
        *a1 = v12;
        a1[1] = v11;
        v39 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v11, v39)).i32[1] & 1) == 0)
          return 1;
        a1[1] = v39;
      }
      a2[-1] = v11;
      return 1;
    case 4:
      v23 = a1 + 1;
      v24 = a1[1];
      v25 = a1 + 2;
      v26 = a1[2];
      v27 = *a1;
      v28 = vmovn_s32(vcgtq_s32(v24, v26)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v24)).i32[1] & 1) != 0)
      {
        if ((v28 & 1) != 0)
        {
          *a1 = v26;
        }
        else
        {
          *a1 = v24;
          a1[1] = v27;
          if ((vmovn_s32(vcgtq_s32(v27, v26)).i32[1] & 1) == 0)
            goto LABEL_54;
          *v23 = v26;
        }
        v30 = a1 + 2;
        v24 = v27;
        goto LABEL_52;
      }
      if ((v28 & 1) == 0)
        goto LABEL_54;
      *v23 = v26;
      *v25 = v24;
      if ((vmovn_s32(vcgtq_s32(v27, v26)).i32[1] & 1) != 0)
      {
        *a1 = v26;
        v30 = a1 + 1;
LABEL_52:
        *v30 = v27;
      }
      v26 = v24;
LABEL_54:
      v41 = a2[-1];
      if ((vmovn_s32(vcgtq_s32(v26, v41)).i32[1] & 1) == 0)
        return 1;
      *v25 = v41;
      a2[-1] = v26;
      v29 = *v25;
      v42 = *v23;
      goto LABEL_68;
    case 5:
      v15 = a1 + 1;
      v16 = a1[1];
      v17 = a1 + 2;
      v18 = a1[2];
      v19 = *a1;
      v20 = vmovn_s32(vcgtq_s32(v16, v18)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v16)).i32[1] & 1) == 0)
      {
        if ((v20 & 1) == 0)
        {
          v40 = *a1;
          v19 = a1[1];
          goto LABEL_60;
        }
        *v15 = v18;
        *v17 = v16;
        if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) == 0)
        {
          v40 = v19;
          v19 = v18;
          goto LABEL_59;
        }
        *a1 = v18;
        v21 = a1 + 1;
        v22 = v19;
LABEL_48:
        *v21 = v19;
        v40 = v18;
        v19 = v22;
LABEL_59:
        v18 = v16;
        goto LABEL_60;
      }
      if ((v20 & 1) != 0)
      {
        *a1 = v18;
        v21 = a1 + 2;
        v22 = v16;
LABEL_47:
        v16 = v19;
        goto LABEL_48;
      }
      *a1 = v16;
      a1[1] = v19;
      if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) != 0)
      {
        v22 = v18;
        *v15 = v18;
        v21 = a1 + 2;
        v18 = v16;
        goto LABEL_47;
      }
      v40 = v16;
LABEL_60:
      v43 = a1[3];
      if ((vmovn_s32(vcgtq_s32(v18, v43)).i32[1] & 1) != 0)
      {
        a1[2] = v43;
        a1[3] = v18;
        if ((vmovn_s32(vcgtq_s32(v19, v43)).i32[1] & 1) != 0)
        {
          *v15 = v43;
          *v17 = v19;
          if ((vmovn_s32(vcgtq_s32(v40, v43)).i32[1] & 1) != 0)
          {
            *a1 = v43;
            a1[1] = v40;
          }
        }
      }
      else
      {
        v18 = a1[3];
      }
      v44 = a2[-1];
      if ((vmovn_s32(vcgtq_s32(v18, v44)).i32[1] & 1) != 0)
      {
        a1[3] = v44;
        a2[-1] = v18;
        v45 = a1[2];
        v29 = a1[3];
        if ((vmovn_s32(vcgtq_s32(v45, v29)).i32[1] & 1) != 0)
        {
          a1[2] = v29;
          a1[3] = v45;
          v42 = a1[1];
LABEL_68:
          if ((vmovn_s32(vcgtq_s32(v42, v29)).i32[1] & 1) != 0)
          {
            a1[1] = v29;
            a1[2] = v42;
LABEL_70:
            v46 = *a1;
            if ((vmovn_s32(vcgtq_s32(*a1, v29)).i32[1] & 1) != 0)
            {
              *a1 = v29;
              a1[1] = v46;
            }
          }
        }
      }
      return 1;
    default:
      v5 = a1 + 2;
      v6 = a1[2];
      v7 = a1 + 1;
      v8 = a1[1];
      v9 = *a1;
      v10 = vmovn_s32(vcgtq_s32(v8, v6)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v8)).i32[1] & 1) != 0)
      {
        if ((v10 & 1) != 0)
        {
          *a1 = v6;
        }
        else
        {
          *a1 = v8;
          a1[1] = v9;
          if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) == 0)
            goto LABEL_31;
          *v7 = v6;
        }
        v7 = a1 + 2;
        goto LABEL_30;
      }
      if ((v10 & 1) != 0)
      {
        *v7 = v6;
        *v5 = v8;
        if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) != 0)
        {
          *a1 = v6;
LABEL_30:
          *v7 = v9;
        }
      }
LABEL_31:
      v31 = a1 + 3;
      if (&a1[3] == a2)
        return 1;
      v32 = 0;
      v33 = 0;
      while (1)
      {
        v34 = *v31;
        v35 = v31->i64[1];
        if (v35 < v5->i32[2])
        {
          v36 = v32;
          while (1)
          {
            *(int32x4_t *)((char *)&a1[3] + v36) = *(int32x4_t *)((char *)&a1[2] + v36);
            if (v36 == -32)
              break;
            v37 = *(__int32 *)((char *)&a1[1].i32[2] + v36);
            v36 -= 16;
            if (v35 >= v37)
            {
              v38 = (int32x4_t *)((char *)a1 + v36 + 48);
              goto LABEL_39;
            }
          }
          v38 = a1;
LABEL_39:
          *v38 = v34;
          if (++v33 == 8)
            return &v31[1] == a2;
        }
        v5 = v31;
        v32 += 16;
        if (++v31 == a2)
          return 1;
      }
  }
}

BOOL sub_1D3D6F8DC(unsigned __int8 *a1, int a2, double a3)
{
  int v4;

  if ((LODWORD(a3) & 0x80000000) != 0
    || *((_QWORD *)a1 + 1) <= (unint64_t)LODWORD(a3)
    || (HIDWORD(a3) & 0x80000000) != 0
    || *((_QWORD *)a1 + 2) <= (unint64_t)HIDWORD(a3))
  {
    v4 = -1;
  }
  else
  {
    v4 = *a1 != sub_1D3D6D4A0(*((_QWORD **)a1 + 3), LODWORD(a3), HIDWORD(a3));
  }
  return v4 == a2;
}

BOOL sub_1D3D6F948(int32x2_t *a1, float a2)
{
  int v3;
  signed int v4;
  int v5;
  double v6;
  char v7;
  uint64_t v8;
  signed int v9;
  char v10;
  char v11;
  int v12;
  double v14;

  v3 = 0;
  v4 = (int)(float)((float)(a2 * 3.0) + a2);
  v5 = (int)(float)((float)(a2 * 3.0) - a2);
  v6 = *(double *)&a1[1];
  v7 = 1;
  while (2)
  {
    v8 = 0;
    v9 = 0;
    v10 = 1;
    do
    {
      v11 = v10;
      *(double *)&a1[1] = v6;
      a1[2] = qword_1D3E5D528[2 * (v7 & 1) + v8];
      v12 = sub_1D3D7055C(a1, 1, v4, 0, 1);
      if (v12 == -1)
        return 0;
      v10 = 0;
      v9 += v12;
      v8 = 1;
    }
    while ((v11 & 1) != 0);
    if (v3 && (v9 + 1 < v5 || v9 >= v4))
      return 0;
    v7 ^= 1u;
    v14 = *(double *)&a1[1];
    *(_DWORD *)((unint64_t)&v14 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v7 & 1))) -= (v9 + 1) / 2;
    v6 = v14;
    *(double *)&a1[1] = v14;
    if (++v3 != 4)
      continue;
    break;
  }
  return sub_1D3D6F8DC(*(unsigned __int8 **)a1, a1[3].i32[0], v6);
}

uint64_t sub_1D3D6FAA0(uint64_t result, int32x4_t *a2, uint64_t a3, char a4)
{
  int32x4_t *v7;
  int32x4_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int32x4_t *v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  __int8 v16;
  int32x4_t v17;
  int32x4_t v18;
  __int8 v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t v22;
  unint64_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  __int8 v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  int32x4_t *v32;
  int32x4_t *v33;
  int32x4_t v34;
  int32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  __int8 v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  __int8 v44;
  int32x4_t v45;
  int32x4_t v46;
  __int32 v47;
  int32x4_t *v48;
  int32x4_t *v49;
  int32x4_t *v50;
  int32x4_t *v51;
  __int32 v52;
  int32x4_t *v53;
  __int32 v54;
  int32x4_t *v55;
  int32x4_t *v56;
  int32x4_t v57;
  __int32 v58;
  BOOL v59;
  int32x4_t *v60;
  int v61;
  unint64_t v62;
  int v63;
  int32x4_t *v64;
  int32x4_t *v65;
  int v66;
  int32x4_t v67;
  int v68;
  int v69;
  int32x4_t *v70;
  int32x4_t v71;
  int32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  int32x4_t v75;
  __int8 v76;
  int32x4_t *v77;
  int32x4_t v78;
  int32x4_t *v79;
  int32x4_t v80;
  int32x4_t v81;
  __int8 v82;
  int32x4_t *v83;
  int32x4_t v84;
  int32x4_t *v85;
  int32x4_t v86;
  int32x4_t *v87;
  int32x4_t v88;
  int32x4_t v89;
  __int8 v90;
  int32x4_t *v91;
  BOOL v93;
  uint64_t v94;
  int32x4_t *v95;
  int32x4_t v96;
  int v97;
  uint64_t v98;
  int v99;
  int32x4_t *v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  uint64_t v104;
  int32x4_t *v105;
  __int32 v106;
  __int32 v107;
  int32x4_t *v108;
  int32x4_t v109;
  int v110;
  int32x4_t *v111;
  uint64_t v112;
  uint64_t v113;
  __int32 v114;
  __int32 v115;
  uint64_t v116;
  uint64_t v117;
  int32x4_t v118;
  _OWORD *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  int v124;
  uint64_t v125;
  unint64_t v126;
  int32x4_t *v127;
  int32x4_t v128;
  __int32 v129;
  int32x4_t *v130;
  int32x4_t v132;
  int32x4_t *v133;
  int32x4_t v134;
  int v135;
  int32x4_t *v136;
  int32x4_t v137;
  int32x4_t v138;
  int32x4_t v139;
  int32x4_t v140;
  int32x4_t v141;
  int32x4_t v142;
  int32x4_t v143;
  int32x4_t v144;
  int32x4_t v145;

  v7 = (int32x4_t *)result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = a2 - v8;
    switch(v10)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v71 = a2[-1];
        v72 = *v8;
        if ((vmovn_s32(vcgtq_s32(*v8, v71)).i32[1] & 1) != 0)
        {
          *v8 = v71;
          a2[-1] = v72;
        }
        return result;
      case 3:
        v73 = *v8;
        v74 = v8[1];
        v75 = a2[-1];
        v76 = vmovn_s32(vcgtq_s32(v74, v75)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v8, v74)).i32[1] & 1) != 0)
        {
          if ((v76 & 1) != 0)
          {
            *v8 = v75;
          }
          else
          {
            *v8 = v74;
            v8[1] = v73;
            v138 = a2[-1];
            if ((vmovn_s32(vcgtq_s32(v73, v138)).i32[1] & 1) == 0)
              return result;
            v8[1] = v138;
          }
          a2[-1] = v73;
        }
        else if ((v76 & 1) != 0)
        {
          v8[1] = v75;
          a2[-1] = v74;
          v132 = v8[1];
          goto LABEL_201;
        }
        return result;
      case 4:
        v85 = v8 + 1;
        v86 = v8[1];
        v87 = v8 + 2;
        v88 = v8[2];
        v89 = *v8;
        v90 = vmovn_s32(vcgtq_s32(v86, v88)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v8, v86)).i32[1] & 1) != 0)
        {
          if ((v90 & 1) != 0)
          {
            *v8 = v88;
          }
          else
          {
            *v8 = v86;
            v8[1] = v89;
            if ((vmovn_s32(vcgtq_s32(v89, v88)).i32[1] & 1) == 0)
              goto LABEL_186;
            *v85 = v88;
          }
          v133 = v8 + 2;
          v86 = v89;
          goto LABEL_184;
        }
        if ((v90 & 1) == 0)
          goto LABEL_186;
        *v85 = v88;
        *v87 = v86;
        if ((vmovn_s32(vcgtq_s32(v89, v88)).i32[1] & 1) != 0)
        {
          *v8 = v88;
          v133 = v8 + 1;
LABEL_184:
          *v133 = v89;
        }
        v88 = v86;
LABEL_186:
        v140 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v88, v140)).i32[1] & 1) != 0)
        {
          *v87 = v140;
          a2[-1] = v88;
          v132 = *v87;
          v141 = *v85;
          goto LABEL_199;
        }
        return result;
      case 5:
        v77 = v8 + 1;
        v78 = v8[1];
        v79 = v8 + 2;
        v80 = v8[2];
        v81 = *v8;
        v82 = vmovn_s32(vcgtq_s32(v78, v80)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v8, v78)).i32[1] & 1) == 0)
        {
          if ((v82 & 1) == 0)
          {
            v139 = *v8;
            v81 = v8[1];
            goto LABEL_191;
          }
          *v77 = v80;
          *v79 = v78;
          if ((vmovn_s32(vcgtq_s32(v81, v80)).i32[1] & 1) == 0)
          {
            v139 = v81;
            v81 = v80;
            goto LABEL_190;
          }
          *v8 = v80;
          v83 = v8 + 1;
          v84 = v81;
LABEL_180:
          *v83 = v81;
          v139 = v80;
          v81 = v84;
LABEL_190:
          v80 = v78;
          goto LABEL_191;
        }
        if ((v82 & 1) != 0)
        {
          *v8 = v80;
          v83 = v8 + 2;
          v84 = v78;
LABEL_179:
          v78 = v81;
          goto LABEL_180;
        }
        *v8 = v78;
        v8[1] = v81;
        if ((vmovn_s32(vcgtq_s32(v81, v80)).i32[1] & 1) != 0)
        {
          v84 = v80;
          *v77 = v80;
          v83 = v8 + 2;
          v80 = v78;
          goto LABEL_179;
        }
        v139 = v78;
LABEL_191:
        v142 = v8[3];
        if ((vmovn_s32(vcgtq_s32(v80, v142)).i32[1] & 1) != 0)
        {
          v8[2] = v142;
          v8[3] = v80;
          if ((vmovn_s32(vcgtq_s32(v81, v142)).i32[1] & 1) != 0)
          {
            *v77 = v142;
            *v79 = v81;
            if ((vmovn_s32(vcgtq_s32(v139, v142)).i32[1] & 1) != 0)
            {
              *v8 = v142;
              v8[1] = v139;
            }
          }
        }
        else
        {
          v80 = v8[3];
        }
        v143 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v80, v143)).i32[1] & 1) != 0)
        {
          v8[3] = v143;
          a2[-1] = v80;
          v144 = v8[2];
          v132 = v8[3];
          if ((vmovn_s32(vcgtq_s32(v144, v132)).i32[1] & 1) != 0)
          {
            v8[2] = v132;
            v8[3] = v144;
            v141 = v8[1];
LABEL_199:
            if ((vmovn_s32(vcgtq_s32(v141, v132)).i32[1] & 1) != 0)
            {
              v8[1] = v132;
              v8[2] = v141;
LABEL_201:
              v145 = *v8;
              if ((vmovn_s32(vcgtq_s32(*v8, v132)).i32[1] & 1) != 0)
              {
                *v8 = v132;
                v8[1] = v145;
              }
            }
          }
        }
        return result;
      default:
        if (v9 > 383)
        {
          if (!a3)
          {
            if (v8 != a2)
            {
              v101 = (unint64_t)(v10 - 2) >> 1;
              v102 = v101;
              do
              {
                v103 = v102;
                if (v101 >= v102)
                {
                  v104 = (2 * v102) | 1;
                  v105 = &v8[v104];
                  if (2 * v103 + 2 < v10)
                  {
                    v106 = v105->i32[2];
                    v107 = v105[1].i32[2];
                    v105 += v106 < v107;
                    if (v106 < v107)
                      v104 = 2 * v103 + 2;
                  }
                  v108 = &v8[v103];
                  v109 = *v108;
                  v110 = v108->i64[1];
                  if (v105->i32[2] >= v110)
                  {
                    do
                    {
                      v111 = v105;
                      *v108 = *v105;
                      if (v101 < v104)
                        break;
                      v112 = (2 * v104) | 1;
                      v105 = &v8[v112];
                      v113 = 2 * v104 + 2;
                      if (v113 < v10)
                      {
                        v114 = v105->i32[2];
                        v115 = v105[1].i32[2];
                        v105 += v114 < v115;
                        if (v114 < v115)
                          v112 = v113;
                      }
                      result = v105->u32[2];
                      v108 = v111;
                      v104 = v112;
                    }
                    while ((int)result >= v110);
                    *v111 = v109;
                  }
                }
                v102 = v103 - 1;
              }
              while (v103);
              v116 = (unint64_t)v9 >> 4;
              do
              {
                v117 = 0;
                v118 = *v8;
                v119 = v8;
                do
                {
                  v120 = (uint64_t)&v119[v117 + 1];
                  v121 = (2 * v117) | 1;
                  v122 = 2 * v117 + 2;
                  if (v122 < v116)
                  {
                    v123 = *(_DWORD *)(v120 + 8);
                    v124 = *(_DWORD *)(v120 + 24);
                    v120 += 16 * (v123 < v124);
                    if (v123 < v124)
                      v121 = v122;
                  }
                  *v119 = *(_OWORD *)v120;
                  v119 = (_OWORD *)v120;
                  v117 = v121;
                }
                while (v121 <= (uint64_t)((unint64_t)(v116 - 2) >> 1));
                if ((int32x4_t *)v120 == --a2)
                {
                  *(int32x4_t *)v120 = v118;
                }
                else
                {
                  *(int32x4_t *)v120 = *a2;
                  *a2 = v118;
                  v125 = v120 - (_QWORD)v8 + 16;
                  if (v125 >= 17)
                  {
                    v126 = (((unint64_t)v125 >> 4) - 2) >> 1;
                    v127 = &v8[v126];
                    v128 = *(int32x4_t *)v120;
                    v129 = *(_QWORD *)(v120 + 8);
                    if (v127->i32[2] < v129)
                    {
                      do
                      {
                        v130 = v127;
                        *(int32x4_t *)v120 = *v127;
                        if (!v126)
                          break;
                        v126 = (v126 - 1) >> 1;
                        v127 = &v8[v126];
                        v120 = (uint64_t)v130;
                      }
                      while (v127->i32[2] < v129);
                      *v130 = v128;
                    }
                  }
                }
              }
              while (v116-- > 2);
            }
            return result;
          }
          v11 = (unint64_t)v10 >> 1;
          v12 = &v8[(unint64_t)v10 >> 1];
          v13 = a2[-1];
          if ((unint64_t)v9 >= 0x801)
          {
            v14 = *v12;
            v15 = *v8;
            v16 = vmovn_s32(vcgtq_s32(*v12, v13)).i8[4];
            if ((vmovn_s32(vcgtq_s32(*v8, *v12)).i32[1] & 1) != 0)
            {
              if ((v16 & 1) != 0)
              {
                *v8 = v13;
              }
              else
              {
                *v8 = v14;
                *v12 = v15;
                v22 = a2[-1];
                if ((vmovn_s32(vcgtq_s32(v15, v22)).i32[1] & 1) == 0)
                  goto LABEL_22;
                *v12 = v22;
              }
              a2[-1] = v15;
            }
            else if ((v16 & 1) != 0)
            {
              *v12 = v13;
              a2[-1] = v14;
              v20 = *v8;
              if ((vmovn_s32(vcgtq_s32(*v8, *v12)).i32[1] & 1) != 0)
              {
                *v8 = *v12;
                *v12 = v20;
              }
            }
LABEL_22:
            v23 = v11 - 1;
            v24 = v8[v11 - 1];
            v25 = v8[1];
            v26 = a2[-2];
            v27 = vmovn_s32(vcgtq_s32(v24, v26)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v25, v24)).i32[1] & 1) != 0)
            {
              if ((v27 & 1) != 0)
              {
                v8[1] = v26;
              }
              else
              {
                v8[1] = v24;
                v8[v23] = v25;
                v31 = a2[-2];
                if ((vmovn_s32(vcgtq_s32(v25, v31)).i32[1] & 1) == 0)
                  goto LABEL_34;
                v8[v23] = v31;
              }
              a2[-2] = v25;
            }
            else if ((v27 & 1) != 0)
            {
              v8[v23] = v26;
              a2[-2] = v24;
              v28 = v8[v23];
              v29 = v8[1];
              if ((vmovn_s32(vcgtq_s32(v29, v28)).i32[1] & 1) != 0)
              {
                v8[1] = v28;
                v8[v23] = v29;
              }
            }
LABEL_34:
            v32 = &v8[v11];
            v34 = v32[1];
            v33 = v32 + 1;
            v35 = v34;
            v36 = v8[2];
            v37 = a2[-3];
            v38 = vmovn_s32(vcgtq_s32(v34, v37)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v36, v34)).i32[1] & 1) != 0)
            {
              if ((v38 & 1) != 0)
              {
                v8[2] = v37;
              }
              else
              {
                v8[2] = v35;
                *v33 = v36;
                v40 = a2[-3];
                if ((vmovn_s32(vcgtq_s32(v36, v40)).i32[1] & 1) == 0)
                  goto LABEL_43;
                *v33 = v40;
              }
              a2[-3] = v36;
            }
            else if ((v38 & 1) != 0)
            {
              *v33 = v37;
              a2[-3] = v35;
              v39 = v8[2];
              if ((vmovn_s32(vcgtq_s32(v39, *v33)).i32[1] & 1) != 0)
              {
                v8[2] = *v33;
                *v33 = v39;
              }
            }
LABEL_43:
            v41 = *v12;
            v42 = v8[v23];
            v43 = *v33;
            v44 = vmovn_s32(vcgtq_s32(*v12, *v33)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v42, *v12)).i32[1] & 1) != 0)
            {
              if ((v44 & 1) != 0)
              {
                v8[v23] = v43;
              }
              else
              {
                v8[v23] = v41;
                *v12 = v42;
                if ((vmovn_s32(vcgtq_s32(v42, v43)).i32[1] & 1) == 0)
                {
                  v41 = v42;
                  goto LABEL_52;
                }
                *v12 = v43;
                v41 = v43;
              }
            }
            else
            {
              if ((v44 & 1) == 0)
              {
LABEL_52:
                v45 = *v8;
                *v8 = v41;
                *v12 = v45;
                goto LABEL_53;
              }
              *v12 = v43;
              *v33 = v41;
              if ((vmovn_s32(vcgtq_s32(v42, v43)).i32[1] & 1) == 0)
              {
                v41 = v43;
                goto LABEL_52;
              }
              v8[v23] = v43;
              v33 = v12;
              v41 = v42;
            }
            *v33 = v42;
            goto LABEL_52;
          }
          v17 = *v8;
          v18 = *v12;
          v19 = vmovn_s32(vcgtq_s32(*v8, v13)).i8[4];
          if ((vmovn_s32(vcgtq_s32(*v12, *v8)).i32[1] & 1) != 0)
          {
            if ((v19 & 1) != 0)
            {
              *v12 = v13;
            }
            else
            {
              *v12 = v17;
              *v8 = v18;
              v30 = a2[-1];
              if ((vmovn_s32(vcgtq_s32(v18, v30)).i32[1] & 1) == 0)
                goto LABEL_53;
              *v8 = v30;
            }
            a2[-1] = v18;
          }
          else if ((v19 & 1) != 0)
          {
            *v8 = v13;
            a2[-1] = v17;
            v21 = *v12;
            if ((vmovn_s32(vcgtq_s32(*v12, *v8)).i32[1] & 1) != 0)
            {
              *v12 = *v8;
              *v8 = v21;
            }
          }
LABEL_53:
          --a3;
          v46 = *v8;
          if ((a4 & 1) == 0)
          {
            v47 = v8->i64[1];
            if (v8[-1].i32[2] < v46.i32[2])
              goto LABEL_56;
            if (v46.i32[2] >= a2[-1].i32[2])
            {
              v62 = (unint64_t)&v8[1];
              do
              {
                v8 = (int32x4_t *)v62;
                if (v62 >= (unint64_t)a2)
                  break;
                v63 = *(_DWORD *)(v62 + 8);
                v62 += 16;
              }
              while (v46.i32[2] >= v63);
            }
            else
            {
              v60 = v8;
              do
              {
                v8 = v60 + 1;
                v61 = v60[1].i32[2];
                ++v60;
              }
              while (v46.i32[2] >= v61);
            }
            v64 = a2;
            if (v8 < a2)
            {
              v65 = a2;
              do
              {
                v64 = v65 - 1;
                v66 = v65[-1].i32[2];
                --v65;
              }
              while (v46.i32[2] < v66);
            }
            while (v8 < v64)
            {
              v67 = *v8;
              *v8 = *v64;
              *v64 = v67;
              do
              {
                v68 = v8[1].i32[2];
                ++v8;
              }
              while (v46.i32[2] >= v68);
              do
              {
                v69 = v64[-1].i32[2];
                --v64;
              }
              while (v46.i32[2] < v69);
            }
            v70 = v8 - 1;
            if (&v8[-1] != v7)
              *v7 = *v70;
            a4 = 0;
            *v70 = v46;
            continue;
          }
          v47 = v8->i64[1];
LABEL_56:
          v48 = v8;
          do
            v49 = v48++;
          while (v49[1].i32[2] < v47);
          v50 = a2;
          if (v49 == v8)
          {
            v53 = a2;
            while (v48 < v53)
            {
              v51 = v53 - 1;
              v54 = v53[-1].i32[2];
              --v53;
              if (v54 < v47)
                goto LABEL_66;
            }
            v51 = v53;
          }
          else
          {
            do
            {
              v51 = v50 - 1;
              v52 = v50[-1].i32[2];
              --v50;
            }
            while (v52 >= v47);
          }
LABEL_66:
          if (v48 < v51)
          {
            v55 = v48;
            v56 = v51;
            do
            {
              v57 = *v55;
              *v55 = *v56;
              *v56 = v57;
              do
                v49 = v55++;
              while (v49[1].i32[2] < v47);
              do
              {
                v58 = v56[-1].i32[2];
                --v56;
              }
              while (v58 >= v47);
            }
            while (v55 < v56);
          }
          if (v49 != v8)
            *v8 = *v49;
          *v49 = v46;
          if (v48 < v51)
            goto LABEL_77;
          v59 = sub_1D3D70850(v8, v49);
          v8 = v49 + 1;
          result = sub_1D3D70850(v49 + 1, a2);
          if (!(_DWORD)result)
          {
            if (v59)
              continue;
LABEL_77:
            result = sub_1D3D6FAA0(v7, v49, a3, a4 & 1);
            a4 = 0;
            v8 = v49 + 1;
            continue;
          }
          a2 = v49;
          if (v59)
            return result;
          goto LABEL_2;
        }
        v91 = v8 + 1;
        v93 = v8 == a2 || v91 == a2;
        if ((a4 & 1) != 0)
        {
          if (!v93)
          {
            v94 = 0;
            v95 = v8;
            do
            {
              v96 = v95[1];
              v97 = v95->i32[2];
              v95 = v91;
              if (v96.i32[2] < v97)
              {
                v98 = v94;
                while (1)
                {
                  *(int32x4_t *)((char *)&v8[1] + v98) = *(int32x4_t *)((char *)v8 + v98);
                  if (!v98)
                    break;
                  v99 = *(__int32 *)((char *)&v8->i32[-2] + v98);
                  v98 -= 16;
                  if (v96.i32[2] >= v99)
                  {
                    v100 = (int32x4_t *)((char *)v8 + v98 + 16);
                    goto LABEL_127;
                  }
                }
                v100 = v8;
LABEL_127:
                *v100 = v96;
              }
              v91 = v95 + 1;
              v94 += 16;
            }
            while (&v95[1] != a2);
          }
        }
        else if (!v93)
        {
          do
          {
            v134 = v7[1];
            v135 = v7->i32[2];
            v7 = v91;
            if (v134.i32[2] < v135)
            {
              do
              {
                v136 = v91;
                v137 = v91[-1];
                --v91;
                *v136 = v137;
              }
              while (v134.i32[2] < v136[-2].i32[2]);
              *v91 = v134;
            }
            v91 = v7 + 1;
          }
          while (&v7[1] != a2);
        }
        return result;
    }
  }
}

uint64_t sub_1D3D7055C(int32x2_t *a1, int a2, signed int a3, int a4, int a5)
{
  int v8;
  unsigned int v9;
  int32x2_t v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  signed int v14;
  int v15;
  int v16;
  uint64_t result;
  int32x2_t v18;
  int32x2_t v19;
  int v20;
  int v21;
  int v22;
  int32x2_t v23;
  int v24;
  unsigned int v25;
  int32x2_t v26;

  if (a2 <= 1)
    v8 = 1;
  else
    v8 = a2;
  if (a5 <= 1)
    v9 = 1;
  else
    v9 = a5;
  v10 = a1[1];
  v11 = (unsigned __int8 *)*a1;
  v26 = v10;
  if (v10.i32[0] < 0
    || *((_QWORD *)v11 + 1) <= (unint64_t)*(_QWORD *)&a1[1]
    || v10.i32[1] < 0
    || *((_QWORD *)v11 + 2) <= (unint64_t)v10.u32[1])
  {
    v13 = -1;
  }
  else
  {
    v12 = sub_1D3D6D4A0(*((_QWORD **)v11 + 3), v10.u32[0], v10.u32[1]);
    v10 = v26;
    v13 = *v11 != v12;
  }
  v14 = 0;
  v15 = 0;
  do
  {
    v16 = v13;
    if (a3)
    {
      result = 0xFFFFFFFFLL;
      if (v14 >= a3 || v13 == -1)
        return result;
    }
    else if (v13 == -1)
    {
      return 0xFFFFFFFFLL;
    }
    v14 += v9;
    v18 = a1[2];
    v19 = vmla_s32(v10, v18, vdup_n_s32(v14));
    if (v19.i32[0] < 0
      || *((_QWORD *)v11 + 1) <= (unint64_t)v19.u32[0]
      || v19.i32[1] < 0
      || *((_QWORD *)v11 + 2) <= (unint64_t)v19.u32[1])
    {
      v13 = -1;
    }
    else
    {
      v20 = sub_1D3D6D4A0(*((_QWORD **)v11 + 3), v19.u32[0], v19.u32[1]);
      v10 = v26;
      v13 = *v11 != v20;
    }
    v21 = v16 != v13 && (int)(v15 + v9) >= a4;
    if (v16 != v13 && (int)(v15 + v9) >= a4)
      v15 = 0;
    else
      v15 += v9;
    v8 -= v21;
  }
  while (v8);
  if (v9 < 2)
  {
LABEL_43:
    v25 = v14 - 1;
    result = (v14 - 1);
  }
  else
  {
    v14 -= v9;
    v22 = v13;
    if (!a3)
      goto LABEL_32;
LABEL_31:
    if (v14 < a3)
    {
LABEL_32:
      while (v22 != -1)
      {
        v23 = vmla_s32(v10, v18, vdup_n_s32(v14));
        if (v23.i32[0] < 0
          || *((_QWORD *)v11 + 1) <= (unint64_t)v23.u32[0]
          || v23.i32[1] < 0
          || *((_QWORD *)v11 + 2) <= (unint64_t)v23.u32[1])
        {
          v22 = -1;
        }
        else
        {
          v24 = sub_1D3D6D4A0(*((_QWORD **)v11 + 3), v23.u32[0], v23.u32[1]);
          v10 = v26;
          v22 = *v11 != v24;
        }
        if (v22 == v13)
          goto LABEL_43;
        ++v14;
        if (a3)
          goto LABEL_31;
      }
    }
    v25 = v14 - 1;
    result = 0xFFFFFFFFLL;
  }
  a1[1] = vmla_s32(v10, vdup_n_s32(v25), v18);
  return result;
}

uint64_t sub_1D3D70784(unsigned __int8 *a1, int32x2_t a2, int32x2_t a3)
{
  int v5;
  unsigned int v6;
  int32x2_t v7;
  int v8;
  int32x2_t v10;

  if (a2.i32[0] < 0
    || *((_QWORD *)a1 + 1) <= (unint64_t)a2.u32[0]
    || a2.i32[1] < 0
    || *((_QWORD *)a1 + 2) <= (unint64_t)a2.u32[1])
  {
    v6 = -1;
  }
  else
  {
    v10 = a2;
    v5 = sub_1D3D6D4A0(*((_QWORD **)a1 + 3), a2.u32[0], a2.u32[1]);
    a2 = v10;
    v6 = *a1 != v5;
  }
  v7 = vadd_s32(a2, a3);
  if (v7.i32[0] < 0
    || *((_QWORD *)a1 + 1) <= (unint64_t)v7.u32[0]
    || v7.i32[1] < 0
    || *((_QWORD *)a1 + 2) <= (unint64_t)v7.u32[1])
  {
    v8 = -1;
  }
  else
  {
    v8 = *a1 != sub_1D3D6D4A0(*((_QWORD **)a1 + 3), v7.u32[0], v7.u32[1]);
  }
  if (v8 == v6)
    return 0xFFFFFFFFLL;
  else
    return v6;
}

BOOL sub_1D3D70850(int32x4_t *a1, int32x4_t *a2)
{
  uint64_t v2;
  int32x4_t v3;
  int32x4_t v4;
  int32x4_t *v5;
  int32x4_t v6;
  int32x4_t *v7;
  int32x4_t v8;
  int32x4_t v9;
  __int8 v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  __int8 v14;
  int32x4_t *v15;
  int32x4_t v16;
  int32x4_t *v17;
  int32x4_t v18;
  int32x4_t v19;
  __int8 v20;
  int32x4_t *v21;
  int32x4_t v22;
  int32x4_t *v23;
  int32x4_t v24;
  int32x4_t *v25;
  int32x4_t v26;
  int32x4_t v27;
  __int8 v28;
  int32x4_t v29;
  int32x4_t *v30;
  int32x4_t *v31;
  uint64_t v32;
  int v33;
  int32x4_t v34;
  __int32 v35;
  uint64_t v36;
  __int32 v37;
  int32x4_t *v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;

  v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      v3 = a2[-1];
      v4 = *a1;
      if ((vmovn_s32(vcgtq_s32(*a1, v3)).i32[1] & 1) != 0)
      {
        *a1 = v3;
        a2[-1] = v4;
      }
      return 1;
    case 3:
      v11 = *a1;
      v12 = a1[1];
      v13 = a2[-1];
      v14 = vmovn_s32(vcgtq_s32(v12, v13)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v12)).i32[1] & 1) == 0)
      {
        if ((v14 & 1) == 0)
          return 1;
        a1[1] = v13;
        a2[-1] = v12;
        v29 = a1[1];
        goto LABEL_70;
      }
      if ((v14 & 1) != 0)
      {
        *a1 = v13;
      }
      else
      {
        *a1 = v12;
        a1[1] = v11;
        v39 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v11, v39)).i32[1] & 1) == 0)
          return 1;
        a1[1] = v39;
      }
      a2[-1] = v11;
      return 1;
    case 4:
      v23 = a1 + 1;
      v24 = a1[1];
      v25 = a1 + 2;
      v26 = a1[2];
      v27 = *a1;
      v28 = vmovn_s32(vcgtq_s32(v24, v26)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v24)).i32[1] & 1) != 0)
      {
        if ((v28 & 1) != 0)
        {
          *a1 = v26;
        }
        else
        {
          *a1 = v24;
          a1[1] = v27;
          if ((vmovn_s32(vcgtq_s32(v27, v26)).i32[1] & 1) == 0)
            goto LABEL_54;
          *v23 = v26;
        }
        v30 = a1 + 2;
        v24 = v27;
        goto LABEL_52;
      }
      if ((v28 & 1) == 0)
        goto LABEL_54;
      *v23 = v26;
      *v25 = v24;
      if ((vmovn_s32(vcgtq_s32(v27, v26)).i32[1] & 1) != 0)
      {
        *a1 = v26;
        v30 = a1 + 1;
LABEL_52:
        *v30 = v27;
      }
      v26 = v24;
LABEL_54:
      v41 = a2[-1];
      if ((vmovn_s32(vcgtq_s32(v26, v41)).i32[1] & 1) == 0)
        return 1;
      *v25 = v41;
      a2[-1] = v26;
      v29 = *v25;
      v42 = *v23;
      goto LABEL_68;
    case 5:
      v15 = a1 + 1;
      v16 = a1[1];
      v17 = a1 + 2;
      v18 = a1[2];
      v19 = *a1;
      v20 = vmovn_s32(vcgtq_s32(v16, v18)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v16)).i32[1] & 1) == 0)
      {
        if ((v20 & 1) == 0)
        {
          v40 = *a1;
          v19 = a1[1];
          goto LABEL_60;
        }
        *v15 = v18;
        *v17 = v16;
        if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) == 0)
        {
          v40 = v19;
          v19 = v18;
          goto LABEL_59;
        }
        *a1 = v18;
        v21 = a1 + 1;
        v22 = v19;
LABEL_48:
        *v21 = v19;
        v40 = v18;
        v19 = v22;
LABEL_59:
        v18 = v16;
        goto LABEL_60;
      }
      if ((v20 & 1) != 0)
      {
        *a1 = v18;
        v21 = a1 + 2;
        v22 = v16;
LABEL_47:
        v16 = v19;
        goto LABEL_48;
      }
      *a1 = v16;
      a1[1] = v19;
      if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) != 0)
      {
        v22 = v18;
        *v15 = v18;
        v21 = a1 + 2;
        v18 = v16;
        goto LABEL_47;
      }
      v40 = v16;
LABEL_60:
      v43 = a1[3];
      if ((vmovn_s32(vcgtq_s32(v18, v43)).i32[1] & 1) != 0)
      {
        a1[2] = v43;
        a1[3] = v18;
        if ((vmovn_s32(vcgtq_s32(v19, v43)).i32[1] & 1) != 0)
        {
          *v15 = v43;
          *v17 = v19;
          if ((vmovn_s32(vcgtq_s32(v40, v43)).i32[1] & 1) != 0)
          {
            *a1 = v43;
            a1[1] = v40;
          }
        }
      }
      else
      {
        v18 = a1[3];
      }
      v44 = a2[-1];
      if ((vmovn_s32(vcgtq_s32(v18, v44)).i32[1] & 1) != 0)
      {
        a1[3] = v44;
        a2[-1] = v18;
        v45 = a1[2];
        v29 = a1[3];
        if ((vmovn_s32(vcgtq_s32(v45, v29)).i32[1] & 1) != 0)
        {
          a1[2] = v29;
          a1[3] = v45;
          v42 = a1[1];
LABEL_68:
          if ((vmovn_s32(vcgtq_s32(v42, v29)).i32[1] & 1) != 0)
          {
            a1[1] = v29;
            a1[2] = v42;
LABEL_70:
            v46 = *a1;
            if ((vmovn_s32(vcgtq_s32(*a1, v29)).i32[1] & 1) != 0)
            {
              *a1 = v29;
              a1[1] = v46;
            }
          }
        }
      }
      return 1;
    default:
      v5 = a1 + 2;
      v6 = a1[2];
      v7 = a1 + 1;
      v8 = a1[1];
      v9 = *a1;
      v10 = vmovn_s32(vcgtq_s32(v8, v6)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v8)).i32[1] & 1) != 0)
      {
        if ((v10 & 1) != 0)
        {
          *a1 = v6;
        }
        else
        {
          *a1 = v8;
          a1[1] = v9;
          if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) == 0)
            goto LABEL_31;
          *v7 = v6;
        }
        v7 = a1 + 2;
        goto LABEL_30;
      }
      if ((v10 & 1) != 0)
      {
        *v7 = v6;
        *v5 = v8;
        if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) != 0)
        {
          *a1 = v6;
LABEL_30:
          *v7 = v9;
        }
      }
LABEL_31:
      v31 = a1 + 3;
      if (&a1[3] == a2)
        return 1;
      v32 = 0;
      v33 = 0;
      while (1)
      {
        v34 = *v31;
        v35 = v31->i64[1];
        if (v35 < v5->i32[2])
        {
          v36 = v32;
          while (1)
          {
            *(int32x4_t *)((char *)&a1[3] + v36) = *(int32x4_t *)((char *)&a1[2] + v36);
            if (v36 == -32)
              break;
            v37 = *(__int32 *)((char *)&a1[1].i32[2] + v36);
            v36 -= 16;
            if (v35 >= v37)
            {
              v38 = (int32x4_t *)((char *)a1 + v36 + 48);
              goto LABEL_39;
            }
          }
          v38 = a1;
LABEL_39:
          *v38 = v34;
          if (++v33 == 8)
            return &v31[1] == a2;
        }
        v5 = v31;
        v32 += 16;
        if (++v31 == a2)
          return 1;
      }
  }
}

float sub_1D3D70C5C(float *a1, uint64_t a2, float result, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;

  if (a5 >= 1)
  {
    v6 = 0;
    result = a1[2];
    v7 = *a1;
    v8 = -a1[1];
    v9 = (float *)(a2 + 8);
    do
    {
      if ((v6 & 1) != 0)
        v10 = 1.0;
      else
        v10 = -1.0;
      v11 = *(float *)(a6 + 4 * v6) + (float)(v7 * v10);
      v12 = (float)(v8 * v11) + 1.0;
      v13 = v11 / v12;
      *(v9 - 2) = (float)(result * v10) / (float)(v12 * v12);
      *(v9 - 1) = v13 * (float)(result * v13);
      *v9 = v13;
      v9 += 3;
      ++v6;
    }
    while (a5 != v6);
  }
  return result;
}

void sub_1D3D70CCC()
{
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D70CE0(unint64_t *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, uint64_t *a11, unint64_t *a12, unint64_t *a13, uint64_t a14, uint64_t *a15, os_signpost_id_t *a16, dispatch_group_t *a17, uint64_t a18, dispatch_group_t *p_group, dispatch_group_t group,void (*a21)(void),char *a22,uint64_t *a23,unint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,_QWORD *a37,unint64_t a38,char a39,_BYTE *a40,char a41,uint64_t a42,uint64_t a43,char a44,__int128 a45,uint64_t a46,timespec a47,char a48,timespec __tp,char a50,os_signpost_id_t a51,_QWORD *a52,uint64_t a53,char a54,void *a55,void *a56,uint64_t a57,unsigned int *a58,float *a59,__int128 a60,int *a61,uint64_t a62,CFTypeRef a63)
{
  CFTypeRef a64;
  uint64_t a65;
  uint64_t *a68;
  CFTypeID v68;
  unint64_t *v72;
  unint64_t **v73;
  uint64_t *v74;
  uint64_t i;
  char v76;
  __CVBuffer *v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t j;
  _QWORD *v81;
  uint64_t k;
  char *v83;
  uint64_t m;
  uint64_t v85;
  int v86;
  const void *v88;
  _QWORD *v89;
  unint64_t *v90;
  uint64_t v91;
  double v92;
  unint64_t v93;
  CFTypeRef v94;
  __CFDictionary *v95;
  const void *v96;
  unint64_t v97;
  unint64_t *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t *v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t *v105;
  uint64_t v106;
  unint64_t v107;
  _QWORD *v108;
  CFTypeRef v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  CFTypeRef v115;
  unint64_t *v116;
  CGFloat MinX;
  CGFloat MinY;
  CGFloat v119;
  CGFloat MaxY;
  CGFloat MaxX;
  CGFloat v122;
  CGFloat v123;
  CGFloat v124;
  const void *v125;
  const void *v126;
  _QWORD *v127;
  _QWORD *v128;
  unint64_t v129;
  CFTypeRef v130;
  __CFDictionary *v131;
  const void *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t v137;
  _QWORD *v138;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  void *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t *v146;
  uint64_t *v147;
  uint64_t v148;
  unint64_t v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t *v152;
  uint64_t *v153;
  os_signpost_id_t v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t *v158;
  uint64_t v159;
  uint64_t v160;
  size_t v161;
  uint64_t v162;
  _BYTE *v163;
  _BYTE *v164;
  _BYTE *v165;
  _QWORD *v166;
  uint64_t v167;
  unint64_t *v168;
  __int128 v169;
  char v170;
  unint64_t *v171;
  uint64_t v172;
  unint64_t v173;
  CGFloat v174;
  CGFloat v175;
  CGFloat v176;
  CGFloat v177;
  unint64_t v178;
  double v179;
  double v180;
  CGFloat v181;
  double v182;
  CGFloat v183;
  double v184;
  CGFloat v185;
  unint64_t v186;
  int v187;
  char *v188;
  unint64_t *v189;
  __int128 v190;
  int v192;
  _BOOL4 v193;
  unint64_t *v194;
  const void *v195;
  int64_t v196;
  char *v197;
  uint64_t v198;
  char *v199;
  char *v200;
  BOOL v201;
  unint64_t v202;
  char *v203;
  unint64_t v204;
  uint64_t v205;
  uint64_t v206;
  _BYTE *v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  char *v211;
  char *v212;
  uint64_t v213;
  char *v214;
  uint64_t v215;
  uint64_t v216;
  size_t v217;
  char *v218;
  uint64_t v219;
  char *v220;
  unint64_t v221;
  char *v222;
  char *v223;
  char *v224;
  uint64_t v225;
  unint64_t *v226;
  unint64_t v227;
  unint64_t *v228;
  unint64_t v229;
  char *v230;
  unint64_t v231;
  uint64_t v232;
  unint64_t v233;
  uint64_t v234;
  unint64_t v235;
  unint64_t v236;
  double v237;
  double v238;
  CGFloat v239;
  double v240;
  CGFloat v241;
  double v242;
  CGFloat v243;
  const void *v244;
  const void *v245;
  BOOL v246;
  unint64_t v247;
  unint64_t v248;
  const __CFString *v249;
  const __CFString *v250;
  unint64_t v251;
  unint64_t v252;
  const void *v253;
  const void *v254;
  const __CFString *v257;
  const __CFString *v258;
  BOOL v259;
  char v260;
  CGFloat v261;
  CGFloat v262;
  CGFloat v263;
  uint64_t v264;
  unint64_t v265;
  unint64_t v266;
  uint64_t v267;
  unint64_t v268;
  char *v269;
  char *v270;
  uint64_t v271;
  char *n;
  unint64_t v273;
  const void *v274;
  const void *v275;
  BOOL v276;
  unint64_t v277;
  unint64_t v278;
  const __CFString *v279;
  const __CFString *v280;
  const __CFString *v281;
  const void *v282;
  const void *v283;
  CFTypeID v284;
  _QWORD *v285;
  unint64_t v286;
  uint64_t v287;
  int64_t v288;
  uint64_t v289;
  unint64_t v290;
  uint64_t v291;
  _QWORD *v292;
  uint64_t *v293;
  uint64_t *v294;
  char *v295;
  uint64_t v296;
  uint64_t v297;
  _QWORD *v298;
  _QWORD *v299;
  _QWORD *v300;
  unint64_t *v301;
  unint64_t v303;
  unint64_t *v304;
  unint64_t v305;
  unint64_t *v306;
  unint64_t *v307;
  unint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  unint64_t v312;
  uint64_t v313;
  unint64_t *v314;
  unint64_t v315;
  unint64_t v316;
  CFTypeRef v317;
  const __CFDictionary *v318;
  CFTypeRef v319;
  void *v320;
  unint64_t v321;
  unint64_t v322;
  unint64_t *v323;
  uint64_t v324;
  unint64_t *v325;
  uint64_t v326;
  unint64_t *v327;
  uint64_t v328;
  uint64_t v329;
  unsigned int v330;
  unint64_t v331;
  const void *v332;
  const void *v333;
  BOOL v334;
  unint64_t v335;
  unint64_t v336;
  const __CFString *v337;
  const __CFString *v338;
  const void *v339;
  const void *v340;
  double *v341;
  uint64_t v342;
  int v343;
  float v344;
  double v345;
  double v346;
  float v347;
  float v348;
  float v349;
  float v350;
  float v351;
  float v352;
  double v353;
  double v354;
  float v355;
  float v356;
  float v357;
  int32x2_t v358;
  float v359;
  float v360;
  float v361;
  int v362;
  unint64_t v363;
  unint64_t v364;
  const __CFString *v365;
  const __CFString *v366;
  CFComparisonResult v367;
  uint64_t v368;
  _BOOL4 v371;
  unint64_t v372;
  CFTypeRef v373;
  unint64_t v374;
  BOOL v375;
  const void *v376;
  const void *v377;
  unint64_t v378;
  unint64_t v379;
  const __CFString *v380;
  const __CFString *v381;
  const void *v382;
  const void *v383;
  unint64_t v384;
  unint64_t v385;
  const __CFString *v386;
  const __CFString *v387;
  const void *v388;
  const void *v389;
  uint64_t v390;
  unint64_t *v391;
  uint64_t v392;
  unint64_t *v393;
  unint64_t *v394;
  BOOL v395;
  unint64_t *v396;
  unint64_t *v397;
  void *v398;
  float v399;
  int v400;
  float v401;
  float v402;
  float v403;
  const void *v404;
  float v405;
  float v406;
  float v407;
  const float *v408;
  double *v409;
  unint64_t v410;
  unint64_t v411;
  uint64_t v412;
  const __CFString *v413;
  const __CFString *v414;
  CFComparisonResult v415;
  BOOL v416;
  int v417;
  int *v418;
  int *v419;
  unint64_t *v420;
  unint64_t *v421;
  unint64_t *v422;
  unint64_t v423;
  const void *v424;
  unint64_t *v425;
  uint64_t v426;
  double v427;
  unint64_t v428;
  CFTypeRef v429;
  __CFDictionary *v430;
  const void *v431;
  os_signpost_id_t v432;
  unint64_t v433;
  uint64_t v434;
  const __CFAllocator *v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  __CFArray *v439;
  const void *v440;
  const __CFArray *v441;
  unint64_t v442;
  CFTypeRef v443;
  __CFDictionary *v444;
  const void *v445;
  uint64_t v446;
  unint64_t v448;
  uint64_t v449;
  unint64_t *v450;
  dispatch_group_t v451;
  _BYTE *v452;
  uint64_t v453;
  uint64_t v454;
  void *v455;
  uint64_t ii;
  unint64_t v458;
  unint64_t v459;
  float v460;
  unint64_t v461;
  uint64_t v462;
  float v463;
  unint64_t v464;
  char *v465;
  void *v466;
  _BYTE *__p;
  char *__pa;
  _BOOL4 __pb;
  BOOL v470;
  uint64_t v471;
  int v472;
  NSObject *oslog;
  unint64_t *v476;
  os_signpost_id_t vars8;
  float32x4x2_t v478;
  float64x2x2_t v479;
  CGRect v480;
  CGRect v481;
  CGRect v482;
  CGRect v483;
  CGRect v484;
  CGRect v485;

  STACK[0x1498] = *MEMORY[0x1E0C80C00];
  v73 = (unint64_t **)(a3 + 16);
  v72 = *(unint64_t **)(a3 + 16);
  a53 = a3 + 16;
  if (!sub_1D3DE7874(v72))
  {
LABEL_12:
    a54 = 0;
    STACK[0xF20] = -2002;
    STACK[0x12E0] = (unint64_t)CFSTR("Unable to acquire CVPixelBuffer lock.");
    sub_1D3D73E0C((unint64_t *)a5, (uint64_t *)&STACK[0xF20], (CFTypeRef *)&STACK[0x12E0]);
LABEL_13:
    *a1 = 0;
    return sub_1D3D74E1C((uint64_t)&a53);
  }
  v74 = *(uint64_t **)(a3 + 72);
  if (v74)
  {
    for (i = *v74; ; i += 216)
    {
      if (i == v74[1])
        goto LABEL_14;
      v76 = sub_1D3DE7874((unint64_t *)(i + 8));
      v74 = *(uint64_t **)(a3 + 72);
      if ((v76 & 1) == 0)
        break;
    }
    while (i != *v74)
    {
      if ((sub_1D3DE78D8((unint64_t *)(i - 208)) & 1) == 0)
        _os_assumes_log();
      i -= 216;
      v74 = *(uint64_t **)(a3 + 72);
    }
    sub_1D3DE78D8(*v73);
    goto LABEL_12;
  }
LABEL_14:
  a54 = 1;
  v77 = (__CVBuffer *)atomic_load(*v73);
  if ((CVPixelBufferGetPixelFormatType(v77) | 0x10) != 0x34323076)
  {
    STACK[0xF20] = -2001;
    STACK[0x12E0] = (unint64_t)CFSTR("Unsupported pixel format.");
    sub_1D3D73E0C((unint64_t *)a5, (uint64_t *)&STACK[0xF20], (CFTypeRef *)&STACK[0x12E0]);
    goto LABEL_13;
  }
  v78 = sub_1D3D73E50();
  v79 = 0;
  a52 = v78;
  do
  {
    *(unint64_t *)((char *)&STACK[0x12E0] + v79) = 0;
    v79 += 64;
  }
  while (v79 != 320);
  for (j = 0; j != 320; j += 64)
  {
    v81 = (unint64_t *)((char *)&STACK[0x11A0] + j);
    *v81 = 0;
    v81[1] = 0;
    v81[2] = 0;
  }
  for (k = 0; k != 640; k += 128)
  {
    v83 = (char *)&STACK[0xF20] + k;
    *v83 = 0;
    v83[96] = 0;
  }
  for (m = 0; m != 320; m += 64)
    *(_WORD *)((char *)&STACK[0xDE0] + m) = 0;
  if (qword_1EDB89FA0 != -1)
    dispatch_once(&qword_1EDB89FA0, &unk_1E95B04B0);
  oslog = qword_1EDB89FA8;
  a51 = os_signpost_id_generate((os_log_t)qword_1EDB89FA8);
  LOBYTE(__tp.tv_sec) = 0;
  a50 = 0;
  LOBYTE(a47.tv_sec) = 0;
  a48 = 0;
  a45 = *a4;
  a46 = *((_QWORD *)a4 + 2);
  a41 = 0;
  a44 = 0;
  v85 = *(_QWORD *)(a2 + 8);
  if ((_os_feature_enabled_impl() & 1) == 0)
    goto LABEL_55;
  v86 = a46;
  if (*(uint64_t *)(v85 + 56) >= 196608 && a46 == 0)
  {
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
    {
      LOWORD(STACK[0xD60]) = 0;
      _os_log_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_INFO, "All prerequisites are met, will run ANMD inference.", (uint8_t *)&STACK[0xD60], 2u);
      v85 = *(_QWORD *)(a2 + 8);
    }
    if (*(_BYTE *)(v85 + 68))
    {
      __tp.tv_sec = 0;
      __tp.tv_nsec = 0;
      a50 = 1;
      clock_gettime(_CLOCK_MONOTONIC, &__tp);
    }
    v88 = (const void *)atomic_load((unint64_t *)a2);
    if (v88)
    {
      v68 = CFGetTypeID(v88);
      if (qword_1EDB893E0 != -1)
        dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
      if (v68 != qword_1EDB893D8)
        _os_assumes_log();
    }
    STACK[0xDD8] = 0;
    v89 = operator new(0x30uLL);
    *v89 = &off_1E95AC778;
    v89[1] = a5;
    v89[2] = &a41;
    v89[3] = a3;
    v89[4] = &a51;
    v89[5] = &a45;
    STACK[0xDD8] = (unint64_t)v89;
    sub_1D3DADACC((uint64_t)v88 + 16, &STACK[0xDC0]);
    v90 = (unint64_t *)STACK[0xDD8];
    if ((unint64_t *)STACK[0xDD8] == &STACK[0xDC0])
    {
      v91 = 4;
      v90 = &STACK[0xDC0];
    }
    else
    {
      if (!v90)
        goto LABEL_46;
      v91 = 5;
    }
    (*(void (**)(void))(*v90 + 8 * v91))();
LABEL_46:
    if (*(_BYTE *)(*(_QWORD *)(a2 + 8) + 68))
    {
      a47.tv_sec = 0;
      a47.tv_nsec = 0;
      a48 = 1;
      clock_gettime(_CLOCK_MONOTONIC, &a47);
      v92 = (double)(a47.tv_nsec - __tp.tv_nsec) / 1000000000.0 + (double)(a47.tv_sec - __tp.tv_sec);
      *(double *)&STACK[0x1420] = v92;
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(STACK[0xD60]) = 134349056;
        *(double *)&STACK[0xD64] = v92;
        _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "Elapsed time during inference: %{public}g", (uint8_t *)&STACK[0xD60], 0xCu);
      }
      STACK[0xD60] = (unint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &STACK[0x1420]);
      v93 = atomic_load((unint64_t *)&a52);
      v94 = (CFTypeRef)atomic_load((unint64_t *)(v93 + 40));
      if (v94)
        v94 = CFRetain(v94);
      STACK[0x1470] = (unint64_t)v94;
      v95 = (__CFDictionary *)atomic_load(&STACK[0x1470]);
      v96 = (const void *)atomic_load(&STACK[0xD60]);
      CFDictionarySetValue(v95, CFSTR("MRCDecoderResultAttributeInferenceElapsedTime"), v96);
      sub_1D3D740C8(&STACK[0x1470]);
      sub_1D3D74100(&STACK[0xD60]);
    }
    if (*(_BYTE *)(a5 + 96))
    {
      if (*(_QWORD *)a5 != -6001)
      {
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        {
          LOWORD(STACK[0xD60]) = 0;
          _os_log_error_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_ERROR, "Underlying errors occurred during inference, bail out immediately.", (uint8_t *)&STACK[0xD60], 2u);
        }
        *a1 = 0;
        goto LABEL_580;
      }
      sub_1D3DF4F24((unint64_t *)a5);
      *(_BYTE *)(a5 + 96) = 0;
    }
LABEL_55:
    v86 = a46;
  }
  if (v86)
  {
    v97 = *((_QWORD *)&a45 + 1);
    if (!*((_QWORD *)&a45 + 1))
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
      {
        LOWORD(STACK[0xD60]) = 0;
        _os_log_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_INFO, "\"regions\" is not NULL but empty, presumably ANMD has been run without results.", (uint8_t *)&STACK[0xD60], 2u);
      }
      if (*(_BYTE *)(*(_QWORD *)(a2 + 8) + 52))
      {
        STACK[0xD60] = (unint64_t)CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
        v129 = atomic_load((unint64_t *)&a52);
        v130 = (CFTypeRef)atomic_load((unint64_t *)(v129 + 40));
        if (v130)
          v130 = CFRetain(v130);
        STACK[0x1420] = (unint64_t)v130;
        v131 = (__CFDictionary *)atomic_load(&STACK[0x1420]);
        v132 = (const void *)atomic_load(&STACK[0xD60]);
        CFDictionarySetValue(v131, CFSTR("MRCDecoderResultAttributeUnrecognizedRegions"), v132);
        sub_1D3D740C8(&STACK[0x1420]);
        sub_1D3D74138(&STACK[0xD60]);
      }
      do
        v133 = __ldaxr((unint64_t *)&a52);
      while (__stlxr(0, (unint64_t *)&a52));
      *a1 = v133;
      goto LABEL_580;
    }
    a40 = 0;
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(STACK[0xD60]) = 134349056;
      STACK[0xD64] = v97;
      _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "%{public}zu region(s)", (uint8_t *)&STACK[0xD60], 0xCu);
      if (*((_QWORD *)&a45 + 1))
      {
        v98 = (unint64_t *)a45;
        v99 = 8 * *((_QWORD *)&a45 + 1);
        v68 = (CFTypeID)"region: %{public}@";
        do
        {
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
          {
            v100 = atomic_load(v98);
            LODWORD(STACK[0xD60]) = 138543362;
            STACK[0xD64] = v100;
            _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "region: %{public}@", (uint8_t *)&STACK[0xD60], 0xCu);
          }
          ++v98;
          v99 -= 8;
        }
        while (v99);
      }
    }
  }
  else
  {
    a40 = 0;
  }
  LOBYTE(a36) = 0;
  a39 = 0;
  if ((_BYTE)a46)
  {
    if (*((_QWORD *)&a45 + 1))
    {
      v101 = 0;
      v102 = (unint64_t *)a45;
      v103 = 8 * *((_QWORD *)&a45 + 1);
      do
      {
        v104 = atomic_load(v102);
        v101 += sub_1D3D91948((unint64_t *)(v104 + 136), 4);
        ++v102;
        v103 -= 8;
      }
      while (v103);
      if (v101 >= 2)
      {
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(STACK[0xD60]) = 134349056;
          STACK[0xD64] = v101;
          _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "There are %{public}zu regions matching App Clip codes to be consolidated.", (uint8_t *)&STACK[0xD60], 0xCu);
        }
        if (a39)
        {
          STACK[0xD60] = (unint64_t)&a36;
          sub_1D3D74170((void ***)&STACK[0xD60]);
        }
        a36 = 0;
        a37 = 0;
        a38 = 0;
        a39 = 1;
        if (*((_QWORD *)&a45 + 1))
        {
          v105 = (unint64_t *)a45;
          v106 = 8 * *((_QWORD *)&a45 + 1);
          do
          {
            v107 = atomic_load(v105);
            if (!sub_1D3D91948((unint64_t *)(v107 + 136), 4))
            {
              v108 = a37;
              if ((unint64_t)a37 >= a38)
              {
                v110 = ((uint64_t)a37 - a36) >> 3;
                if ((unint64_t)(v110 + 1) >> 61)
                  sub_1D3D6D4F8();
                v111 = (uint64_t)(a38 - a36) >> 2;
                if (v111 <= v110 + 1)
                  v111 = v110 + 1;
                if (a38 - a36 >= 0x7FFFFFFFFFFFFFF8)
                  v112 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v112 = v111;
                STACK[0xD80] = (unint64_t)&a38;
                if (v112)
                  v112 = (unint64_t)sub_1D3D6D8A0(v112);
                else
                  v113 = 0;
                v114 = (_QWORD *)(v112 + 8 * v110);
                STACK[0xD60] = v112;
                STACK[0xD68] = (unint64_t)v114;
                STACK[0xD70] = (unint64_t)v114;
                STACK[0xD78] = v112 + 8 * v113;
                v115 = (CFTypeRef)atomic_load(v105);
                if (v115)
                  v115 = CFRetain(v115);
                *v114 = v115;
                STACK[0xD70] += 8;
                sub_1D3D742F0(&a36, &STACK[0xD60]);
                v68 = (CFTypeID)a37;
                sub_1D3D743C8((uint64_t)&STACK[0xD60]);
              }
              else
              {
                v109 = (CFTypeRef)atomic_load(v105);
                if (v109)
                  v109 = CFRetain(v109);
                *v108 = v109;
                v68 = (CFTypeID)(v108 + 1);
              }
              a37 = (_QWORD *)v68;
            }
            ++v105;
            v106 -= 8;
          }
          while (v106);
        }
        v116 = *v73;
        MinX = CGRectGetMinX(*(CGRect *)(*v73 + 1));
        MinY = CGRectGetMinY(*(CGRect *)(v116 + 1));
        *(CGFloat *)&STACK[0xD60] = MinX;
        *(CGFloat *)&STACK[0xD68] = MinY;
        v119 = CGRectGetMinX(*(CGRect *)(v116 + 1));
        MaxY = CGRectGetMaxY(*(CGRect *)(v116 + 1));
        *(CGFloat *)&STACK[0xD70] = v119;
        *(CGFloat *)&STACK[0xD78] = MaxY;
        MaxX = CGRectGetMaxX(*(CGRect *)(v116 + 1));
        v122 = CGRectGetMaxY(*(CGRect *)(v116 + 1));
        *(CGFloat *)&STACK[0xD80] = MaxX;
        *(CGFloat *)&STACK[0xD88] = v122;
        v123 = CGRectGetMaxX(*(CGRect *)(v116 + 1));
        v124 = CGRectGetMinY(*(CGRect *)(v116 + 1));
        *(CGFloat *)&STACK[0xD90] = v123;
        *(CGFloat *)&STACK[0xD98] = v124;
        v125 = (const void *)MRCRegionCreate((__int128 *)&STACK[0xD60], 0, CFSTR("PseudoExternal"), 0.0, 1.0);
        v126 = v125;
        if (v125)
        {
          v68 = CFGetTypeID(v125);
          if (qword_1EDB89308 != -1)
            dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
          if (v68 != qword_1EDB89320)
            _os_assumes_log();
        }
        v127 = a37;
        if ((unint64_t)a37 >= a38)
        {
          v134 = ((uint64_t)a37 - a36) >> 3;
          if ((unint64_t)(v134 + 1) >> 61)
            sub_1D3D6D4F8();
          v135 = (uint64_t)(a38 - a36) >> 2;
          if (v135 <= v134 + 1)
            v135 = v134 + 1;
          if (a38 - a36 >= 0x7FFFFFFFFFFFFFF8)
            v136 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v136 = v135;
          STACK[0x1440] = (unint64_t)&a38;
          if (v136)
            v136 = (unint64_t)sub_1D3D6D8A0(v136);
          else
            v137 = 0;
          v138 = (_QWORD *)(v136 + 8 * v134);
          STACK[0x1420] = v136;
          STACK[0x1428] = (unint64_t)v138;
          STACK[0x1438] = v136 + 8 * v137;
          *v138 = v126;
          STACK[0x1430] = (unint64_t)(v138 + 1);
          sub_1D3D742F0(&a36, &STACK[0x1420]);
          v128 = a37;
          sub_1D3D743C8((uint64_t)&STACK[0x1420]);
        }
        else
        {
          *a37 = v126;
          v128 = v127 + 1;
        }
        a37 = v128;
        if (!(_BYTE)a46)
          LOBYTE(a46) = 1;
        *(_QWORD *)&a45 = a36;
        *((_QWORD *)&a45 + 1) = ((uint64_t)v128 - a36) >> 3;
      }
    }
  }
  LOBYTE(a32) = 0;
  a35 = 0;
  if (!atomic_load((unint64_t *)(a3 + 64)))
  {
    v167 = *(_QWORD *)(a2 + 8);
    if (*(_BYTE *)(v167 + 65))
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(STACK[0xD60]) = 0;
        _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "Sample has no pyramid, and pyramid generation on demand is allowed.", (uint8_t *)&STACK[0xD60], 2u);
        v167 = *(_QWORD *)(a2 + 8);
      }
      v168 = (unint64_t *)MEMORY[0x1E0C9D628];
      v169 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
      *(_OWORD *)&STACK[0x1420] = *MEMORY[0x1E0C9D628];
      *(_OWORD *)&STACK[0x1430] = v169;
      LOBYTE(STACK[0xD60]) = 0;
      LOBYTE(STACK[0xD64]) = 0;
      if (((sub_1D3DDC428((unint64_t *)v167, CFSTR("QR"), (uint64_t)&STACK[0xD60]) & 1) != 0
         || *(uint64_t *)(v167 + 56) < 0x40000)
        && (_BYTE)a46
        && *((_QWORD *)&a45 + 1))
      {
        v170 = 0;
        v171 = (unint64_t *)a45;
        v172 = 8 * *((_QWORD *)&a45 + 1);
        do
        {
          v173 = atomic_load(v171);
          if (sub_1D3D91948((unint64_t *)(v173 + 136), 1))
          {
            v174 = *(double *)&STACK[0x1420];
            v175 = *(double *)&STACK[0x1428];
            v176 = *(double *)&STACK[0x1430];
            v177 = *(double *)&STACK[0x1438];
            v178 = atomic_load(v171);
            v179 = sub_1D3D8F9B0(v178 + 16, 0.1);
            v181 = v180;
            v183 = v182;
            v185 = v184;
            v186 = atomic_load(v171);
            v167 &= 0xFFFFFFFFFFFFFF00;
            v68 &= 0xFFFFFFFFFFFFFF00;
            sub_1D3D8F8B8((CGAffineTransform *)&a26, (_OWORD *)(v186 + 16), *(_QWORD *)(a3 + 16), *(uint64_t **)(a3 + 72), (uint64_t *)v167, 0, v68, 0);
            v480.origin.x = v179;
            v480.origin.y = v181;
            v480.size.width = v183;
            v480.size.height = v185;
            v484 = CGRectApplyAffineTransform(v480, (CGAffineTransform *)&a26);
            v481.origin.x = v174;
            v481.origin.y = v175;
            v481.size.width = v176;
            v481.size.height = v177;
            v482 = CGRectUnion(v481, v484);
            STACK[0x1420] = *(_QWORD *)&v482.origin.x;
            STACK[0x1428] = *(_QWORD *)&v482.origin.y;
            v170 = 1;
            STACK[0x1430] = *(_QWORD *)&v482.size.width;
            STACK[0x1438] = *(_QWORD *)&v482.size.height;
          }
          ++v171;
          v172 -= 8;
        }
        while (v172);
        if ((v170 & 1) != 0)
        {
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
          {
            LOWORD(STACK[0xD60]) = 0;
            _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "At least one region contains symbologies requiring pyramid.", (uint8_t *)&STACK[0xD60], 2u);
          }
          v187 = _os_feature_enabled_impl();
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(STACK[0xD60]) = 67240192;
            LODWORD(STACK[0xD64]) = v187;
            _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "On-demand pyramid generation: disablesCropping=%{public, BOOL}d", (uint8_t *)&STACK[0xD60], 8u);
          }
          v188 = sub_1D3D74414((unint64_t *)a2);
          v189 = &STACK[0x1420];
          if (v187)
            v189 = v168;
          v190 = *((_OWORD *)v189 + 1);
          *(_OWORD *)&STACK[0xD60] = *(_OWORD *)v189;
          *(_OWORD *)&STACK[0xD70] = v190;
          LOBYTE(STACK[0xD80]) = 1;
          STACK[0x1470] = a51;
          LOBYTE(STACK[0x1478]) = 1;
          sub_1D3D96110(&STACK[0x1450], (uint64_t)v188, (uint64_t)v73, (uint64_t)&STACK[0xD60], a5, (uint64_t)&STACK[0x1470]);
          if (atomic_load(&STACK[0x1450]))
          {
            sub_1D3D744C4((uint64_t)&a32, &STACK[0x1450], (CGRect *)(a3 + 32), (_OWORD *)(*(_QWORD *)(a3 + 16) + 8));
          }
          else
          {
            if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
            {
              if (*(_BYTE *)(a5 + 96))
              {
                sub_1D3DF4F6C((uint64_t)&STACK[0xD60], a5);
              }
              else
              {
                *(_OWORD *)&STACK[0xD70] = 0u;
                *(_OWORD *)&STACK[0xD80] = 0u;
                STACK[0xD60] = -1;
                STACK[0xD68] = 0;
                *(_OWORD *)&STACK[0xD90] = 0u;
                *(_OWORD *)&STACK[0xDA0] = 0u;
                LOBYTE(STACK[0xD7C]) = 0;
                LOBYTE(STACK[0xD94]) = 0;
                *(_OWORD *)&STACK[0xDB0] = 0u;
              }
              sub_1D3DF53CC((CFErrorRef *)&a22, (uint64_t)&STACK[0xD60]);
              v459 = atomic_load((unint64_t *)&a22);
              LODWORD(STACK[0x1470]) = 138543362;
              STACK[0x1474] = v459;
              _os_log_error_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_ERROR, "On-demand pyramid generation failed: %{public}@", (uint8_t *)&STACK[0x1470], 0xCu);
              sub_1D3D7448C((unint64_t *)&a22);
              sub_1D3DF4F24(&STACK[0xD60]);
            }
            if (*(_BYTE *)(a5 + 96))
            {
              sub_1D3DF4F24((unint64_t *)a5);
              *(_BYTE *)(a5 + 96) = 0;
            }
          }
          sub_1D3D74138(&STACK[0x1450]);
        }
      }
    }
  }
  LOBYTE(a22) = 0;
  a25 = 0;
  if (!a35)
    goto LABEL_148;
  a22 = 0;
  a23 = 0;
  a24 = 0;
  a25 = 1;
  v140 = a32;
  v141 = a33;
  if (a33 != a32)
  {
    v142 = 0x84BDA12F684BDA13 * ((a33 - a32) >> 3);
    if (v142 >> 61)
      sub_1D3D6D4F8();
    STACK[0xD80] = (unint64_t)&a24;
    v143 = sub_1D3D6D8A0(v142);
    STACK[0xD60] = (unint64_t)v143;
    STACK[0xD68] = (unint64_t)v143;
    STACK[0xD70] = (unint64_t)v143;
    STACK[0xD78] = (unint64_t)v143 + 8 * v144;
    sub_1D3D74530(&a22, &STACK[0xD60]);
    sub_1D3D7458C((uint64_t)&STACK[0xD60]);
    v140 = a32;
    v141 = a33;
  }
  for (; v140 != v141; v140 += 216)
  {
    v145 = operator new();
    *(_QWORD *)v145 = v140 + 8;
    *(_QWORD *)(v145 + 8) = a5;
    *(_BYTE *)(v145 + 16) = sub_1D3DE79DC((unint64_t *)(v140 + 8), a5);
    v146 = a23;
    if ((unint64_t)a23 >= a24)
    {
      v148 = ((char *)a23 - a22) >> 3;
      if ((unint64_t)(v148 + 1) >> 61)
        sub_1D3D6D4F8();
      v149 = (uint64_t)(a24 - (_QWORD)a22) >> 2;
      if (v149 <= v148 + 1)
        v149 = v148 + 1;
      if (a24 - (unint64_t)a22 >= 0x7FFFFFFFFFFFFFF8)
        v150 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v150 = v149;
      STACK[0xD80] = (unint64_t)&a24;
      if (v150)
        v150 = (unint64_t)sub_1D3D6D8A0(v150);
      else
        v151 = 0;
      v152 = (uint64_t *)(v150 + 8 * v148);
      STACK[0xD60] = v150;
      STACK[0xD68] = (unint64_t)v152;
      STACK[0xD78] = v150 + 8 * v151;
      *v152 = v145;
      STACK[0xD70] = (unint64_t)(v152 + 1);
      sub_1D3D74530(&a22, &STACK[0xD60]);
      v147 = a23;
      sub_1D3D7458C((uint64_t)&STACK[0xD60]);
    }
    else
    {
      *a23 = v145;
      v147 = v146 + 1;
    }
    a23 = v147;
  }
  if (a35)
    v153 = &a32;
  else
LABEL_148:
    v153 = *(uint64_t **)(a3 + 72);
  group = dispatch_group_create();
  a21 = (void (*)(void))MEMORY[0x1E0C82E98];
  a18 = a2;
  p_group = &group;
  a14 = a3;
  a15 = v153;
  a16 = &a51;
  a17 = &group;
  a10 = &STACK[0x12E0];
  a11 = &a14;
  v154 = a51;
  a12 = &STACK[0xF20];
  a13 = &STACK[0xDE0];
  if (a51 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(oslog))
  {
    v155 = atomic_load(*(unint64_t **)(a2 + 8));
    if (!v155)
      v155 = *MEMORY[0x1E0C9B0D0];
    LODWORD(STACK[0xD60]) = 138543362;
    STACK[0xD64] = v155;
    _os_signpost_emit_with_name_impl(&dword_1D3D6B000, oslog, OS_SIGNPOST_INTERVAL_BEGIN, v154, "SampleDecoding", "Begin decoding: symbologies=%{public, signpost.description:attribute}@", (uint8_t *)&STACK[0xD60], 0xCu);
  }
  v156 = *(_QWORD *)(a2 + 8);
  v157 = a2;
  if (*(_BYTE *)(v156 + 68))
  {
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    a50 = 1;
    clock_gettime(_CLOCK_MONOTONIC, &__tp);
    v156 = *(_QWORD *)(a2 + 8);
  }
  if (*(uint64_t *)(v156 + 56) < 196608)
  {
    STACK[0xD40] = (unint64_t)&off_1E95AC7D0;
    STACK[0xD48] = (unint64_t)&a10;
    STACK[0xD50] = (unint64_t)&a18;
    STACK[0xD58] = (unint64_t)&STACK[0xD40];
    sub_1D3D74630(a2, &STACK[0xD40]);
    v158 = (unint64_t *)STACK[0xD58];
    if ((unint64_t *)STACK[0xD58] == &STACK[0xD40])
    {
      v159 = 4;
      v158 = &STACK[0xD40];
LABEL_197:
      (*(void (**)(void))(*v158 + 8 * v159))();
      goto LABEL_198;
    }
    goto LABEL_195;
  }
  if ((_BYTE)a46)
  {
    v160 = *((_QWORD *)&a45 + 1);
    v161 = *((_QWORD *)&a45 + 1) << 6;
    if (*((_QWORD *)&a45 + 1) >> 58)
      v162 = -1;
    else
      v162 = *((_QWORD *)&a45 + 1) << 6;
    v163 = (_BYTE *)MEMORY[0x1D8254C60](v162, 64);
    v164 = v163;
    if (v160)
      bzero(v163, v161);
    v165 = a40;
    a40 = v164;
    if (v165)
    {
      MEMORY[0x1D8254C30](v165, 64);
      v164 = a40;
      v160 = *((_QWORD *)&a45 + 1);
    }
    for (; v160; --v160)
    {
      *v164 = 0;
      v164 += 64;
    }
    STACK[0xD38] = 0;
    v166 = operator new(0x38uLL);
    v157 = a2;
    *v166 = &off_1E95AC828;
    v166[1] = &a45;
    v166[2] = &a40;
    v166[3] = &a10;
    v166[4] = &STACK[0xDE0];
    v166[5] = &STACK[0x11A0];
    v166[6] = &a18;
    STACK[0xD38] = (unint64_t)v166;
    sub_1D3D74630(a2, &STACK[0xD20]);
    v158 = (unint64_t *)STACK[0xD38];
    if ((unint64_t *)STACK[0xD38] == &STACK[0xD20])
    {
      v159 = 4;
      v158 = &STACK[0xD20];
      goto LABEL_197;
    }
LABEL_195:
    if (!v158)
      goto LABEL_198;
    v159 = 5;
    goto LABEL_197;
  }
  v192 = *(unsigned __int8 *)(v156 + 64);
  v193 = os_log_type_enabled(oslog, OS_LOG_TYPE_INFO);
  if (v192)
  {
    if (v193)
    {
      LOWORD(STACK[0xD60]) = 0;
      _os_log_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_INFO, "For v3, regions should always have value. Due to either the MachineReadableCode/ANMD feature flag is not being turned on, or no applicable inference execution targets are found. Fallback to v2.", (uint8_t *)&STACK[0xD60], 2u);
    }
    STACK[0xD00] = (unint64_t)&off_1E95AC880;
    STACK[0xD08] = (unint64_t)&a10;
    STACK[0xD10] = (unint64_t)&a18;
    STACK[0xD18] = (unint64_t)&STACK[0xD00];
    sub_1D3D74630(a2, &STACK[0xD00]);
    v158 = (unint64_t *)STACK[0xD18];
    if ((unint64_t *)STACK[0xD18] == &STACK[0xD00])
    {
      v159 = 4;
      v158 = &STACK[0xD00];
      goto LABEL_197;
    }
    goto LABEL_195;
  }
  if (v193)
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_INFO, "Regions are not provided, algorithmic versioning fallback has also been explicitly disabled.", (uint8_t *)&STACK[0xD60], 2u);
  }
LABEL_198:
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "Waiting for any pending decoding passes...", (uint8_t *)&STACK[0xD60], 2u);
  }
  dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  v194 = (unint64_t *)os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)v194)
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "Done waiting for pending decoding passes.", (uint8_t *)&STACK[0xD60], 2u);
  }
  v476 = (unint64_t *)a5;
  if (!*(_BYTE *)(*(_QWORD *)(v157 + 8) + 67) || !(_BYTE)a46)
    goto LABEL_353;
  v195 = (const void *)STACK[0x11A0];
  v196 = STACK[0x11A8] - STACK[0x11A0];
  if (STACK[0x11A8] == STACK[0x11A0])
  {
    v199 = 0;
    v200 = 0;
    __p = 0;
    STACK[0x1478] = 0;
    STACK[0x1470] = 0;
    v201 = 1;
    STACK[0x1480] = 0;
  }
  else
  {
    if (v196 < 0)
      sub_1D3D6D4F8();
    v197 = (char *)sub_1D3D6D8A0(v196 >> 3);
    v199 = &v197[8 * v198];
    memmove(v197, v195, v196);
    __p = v197;
    v200 = &v197[8 * (v196 >> 3)];
    STACK[0x1478] = 0;
    STACK[0x1470] = 0;
    STACK[0x1480] = 0;
    v201 = 8 * (v196 >> 3) == 0;
    if (8 * (v196 >> 3))
    {
      v202 = atomic_load(&STACK[0x12E0]);
      sub_1D3D7493C((uint64_t *)&STACK[0x1470], (unint64_t *)STACK[0x1478], *(unint64_t **)(v202 + 16), *(unint64_t **)(v202 + 24), (uint64_t)(*(_QWORD *)(v202 + 24) - *(_QWORD *)(v202 + 16)) >> 3);
    }
  }
  v203 = (char *)STACK[0x1220];
  v204 = STACK[0x1228];
  if (STACK[0x1220] != STACK[0x1228])
  {
    if ((uint64_t)(v204 - (_QWORD)v203) >= 1)
    {
      v205 = (uint64_t)(v204 - (_QWORD)v203) >> 3;
      v206 = v200 - __p;
      v207 = &__p[(v200 - __p) & 0xFFFFFFFFFFFFFFF8];
      if (v205 > (v199 - v200) >> 3)
      {
        v208 = v206 >> 3;
        v209 = (v206 >> 3) + v205;
        if (v209 >> 61)
          sub_1D3D6D4F8();
        if ((v199 - __p) >> 2 > v209)
          v209 = (v199 - __p) >> 2;
        if ((unint64_t)(v199 - __p) >= 0x7FFFFFFFFFFFFFF8)
          v210 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v210 = v209;
        if (v210)
          v210 = (unint64_t)sub_1D3D6D8A0(v210);
        v211 = (char *)(v210 + 8 * v208);
        v212 = &v211[8 * v205];
        v213 = 8 * v205;
        v214 = v211;
        do
        {
          v215 = *(_QWORD *)v203;
          v203 += 8;
          *(_QWORD *)v214 = v215;
          v214 += 8;
          v213 -= 8;
        }
        while (v213);
        if (!v201)
        {
          v216 = 8 * v208;
          do
          {
            *(_QWORD *)(v210 + v216 - 8) = *(_QWORD *)&__p[v216 - 8];
            v216 -= 8;
          }
          while (v216);
          v211 = (char *)v210;
        }
        v217 = v200 - v207;
        if (v217)
          memmove(v212, v207, v217);
        v218 = &v212[v217];
        if (__p)
          operator delete(__p);
        goto LABEL_247;
      }
      v219 = (v200 - v207) >> 3;
      if (v219 >= v205)
      {
        v220 = &v203[8 * v205];
        v222 = v200;
        v211 = __p;
      }
      else
      {
        v220 = &v203[8 * v219];
        v221 = v204 - (_QWORD)v220;
        v211 = __p;
        if ((char *)v204 != v220)
          memmove(v200, &v203[8 * v219], v204 - (_QWORD)v220);
        v222 = &v200[v221];
        if (v200 - v207 < 1)
        {
          v218 = &v200[v221];
          goto LABEL_247;
        }
      }
      v223 = &v207[8 * v205];
      v224 = &v222[-8 * v205];
      v218 = v222;
      if (v224 < v200)
      {
        v218 = v222;
        do
        {
          v225 = *(_QWORD *)v224;
          v224 += 8;
          *(_QWORD *)v218 = v225;
          v218 += 8;
        }
        while (v224 < v200);
      }
      if (v222 != v223)
        memmove(&v222[-8 * ((v222 - v223) >> 3)], v207, v222 - v223);
      if (v220 != v203)
        memmove(v207, v203, v220 - v203);
      goto LABEL_247;
    }
    v218 = v200;
    v211 = __p;
LABEL_247:
    v226 = (unint64_t *)STACK[0x1478];
    v227 = atomic_load(&STACK[0x1360]);
    v228 = *(unint64_t **)(v227 + 16);
    v229 = atomic_load(&STACK[0x1360]);
    sub_1D3D7493C((uint64_t *)&STACK[0x1470], v226, v228, *(unint64_t **)(v229 + 24), (uint64_t)(*(_QWORD *)(v229 + 24) - (_QWORD)v228) >> 3);
    v200 = v218;
    goto LABEL_248;
  }
  v211 = __p;
LABEL_248:
  __pa = v211;
  if (!(_BYTE)a46)
    sub_1D3D74BBC();
  if (!*((_QWORD *)&a45 + 1) || v211 == v200 || STACK[0x1470] == STACK[0x1478])
  {
    STACK[0x1458] = 0;
    STACK[0x1450] = 0;
    STACK[0x1460] = 0;
    goto LABEL_342;
  }
  v471 = a45;
  sub_1D3D82334(&STACK[0x1420], (v200 - v211) >> 3);
  v464 = 0;
  v465 = 0;
  v230 = 0;
  v231 = 0;
  if ((unint64_t)((v200 - v211) >> 3) <= 1)
    v232 = 1;
  else
    v232 = (v200 - v211) >> 3;
  do
  {
    v233 = v231 >> 6;
    v234 = 1 << v231;
    if ((*(_QWORD *)(STACK[0x1420] + 8 * (v231 >> 6)) & (1 << v231)) != 0)
      goto LABEL_304;
    v235 = atomic_load((unint64_t *)(STACK[0x1470] + 8 * v231));
    if (!*(_BYTE *)(v235 + 208) || (unint64_t)(*(_QWORD *)(v235 + 176) - 2) > 3)
      goto LABEL_304;
    v236 = atomic_load((unint64_t *)(v471 + 8 * *(_QWORD *)&v211[8 * v231]));
    v237 = sub_1D3D8F9B0(v236 + 16, 0.1);
    v239 = v238;
    v241 = v240;
    v243 = v242;
    STACK[0xD60] = (unint64_t)CFRetain(CFSTR("PseudoPDF417"));
    v244 = (const void *)atomic_load(&STACK[0xD60]);
    v245 = (const void *)atomic_load((unint64_t *)(v236 + 136));
    if (v245 == v244 || v244 && v245 && CFEqual(v245, v244))
    {
      v246 = 1;
    }
    else
    {
      v247 = atomic_load((unint64_t *)(v236 + 136));
      if (!v247 || (v248 = atomic_load(&STACK[0xD60])) == 0)
      {
        v470 = 0;
        goto LABEL_269;
      }
      v249 = (const __CFString *)atomic_load((unint64_t *)(v236 + 136));
      v250 = (const __CFString *)atomic_load(&STACK[0xD60]);
      v246 = CFStringCompare(v249, v250, 0) == kCFCompareEqualTo;
    }
    v470 = v246;
LABEL_269:
    sub_1D3D8C70C(&STACK[0xD60]);
    v251 = 0;
    while (1)
    {
      if (v231 == v251 || (*(_QWORD *)(STACK[0x1420] + 8 * (v251 >> 6)) & (1 << v251)) != 0)
        goto LABEL_284;
      v252 = atomic_load((unint64_t *)(v471 + 8 * *(_QWORD *)&v211[8 * v251]));
      STACK[0xD60] = (unint64_t)CFRetain(CFSTR("PseudoPDF417"));
      v253 = (const void *)atomic_load(&STACK[0xD60]);
      v254 = (const void *)atomic_load((unint64_t *)(v252 + 136));
      if (v254 == v253 || v253 && v254 && CFEqual(v254, v253))
        break;
      if (atomic_load((unint64_t *)(v252 + 136)))
      {
        if (atomic_load(&STACK[0xD60]))
        {
          v257 = (const __CFString *)atomic_load((unint64_t *)(v252 + 136));
          v258 = (const __CFString *)atomic_load(&STACK[0xD60]);
          v259 = CFStringCompare(v257, v258, 0) == kCFCompareEqualTo;
          sub_1D3D8C70C(&STACK[0xD60]);
          v260 = v470 ^ v259;
          v211 = __pa;
          if ((v260 & 1) == 0)
            goto LABEL_284;
          goto LABEL_283;
        }
      }
      sub_1D3D8C70C(&STACK[0xD60]);
      if (v470)
        goto LABEL_283;
LABEL_284:
      if (v232 == ++v251)
        goto LABEL_285;
    }
    sub_1D3D8C70C(&STACK[0xD60]);
    if (v470)
      goto LABEL_284;
LABEL_283:
    v485.origin.x = sub_1D3D8F9B0(v252 + 16, 0.1);
    v485.origin.y = v261;
    v485.size.width = v262;
    v485.size.height = v263;
    v483.origin.x = v237;
    v483.origin.y = v239;
    v483.size.width = v241;
    v483.size.height = v243;
    if (!CGRectIntersectsRect(v483, v485))
      goto LABEL_284;
    v268 = STACK[0x1420];
    *(_QWORD *)(STACK[0x1420] + 8 * (v251 >> 6)) |= 1 << v251;
    *(_QWORD *)(v268 + 8 * v233) |= v234;
LABEL_285:
    if ((*(_QWORD *)(STACK[0x1420] + 8 * v233) & v234) == 0)
    {
      if ((unint64_t)v230 >= v464)
      {
        v264 = (v230 - v465) >> 3;
        v265 = v264 + 1;
        if ((unint64_t)(v264 + 1) >> 61)
          sub_1D3D6D4F8();
        if ((uint64_t)(v464 - (_QWORD)v465) >> 2 > v265)
          v265 = (uint64_t)(v464 - (_QWORD)v465) >> 2;
        if (v464 - (unint64_t)v465 >= 0x7FFFFFFFFFFFFFF8)
          v266 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v266 = v265;
        if (v266)
          v266 = (unint64_t)sub_1D3D6D8A0(v266);
        else
          v267 = 0;
        v269 = (char *)(v266 + 8 * v264);
        *(_QWORD *)v269 = v231;
        v270 = v269 + 8;
        while (v230 != v465)
        {
          v271 = *((_QWORD *)v230 - 1);
          v230 -= 8;
          *((_QWORD *)v269 - 1) = v271;
          v269 -= 8;
        }
        v464 = v266 + 8 * v267;
        if (v465)
          operator delete(v465);
        v230 = v270;
        v465 = v269;
        v211 = __pa;
      }
      else
      {
        *(_QWORD *)v230 = v231;
        v230 += 8;
      }
    }
LABEL_304:
    ++v231;
  }
  while (v231 != v232);
  STACK[0x1458] = 0;
  STACK[0x1450] = 0;
  STACK[0x1460] = 0;
  sub_1D3DAB9DC((uint64_t *)&STACK[0x1450], (v230 - v465) >> 3);
  if (v465 != v230)
  {
    for (n = v465; n != v230; n += 8)
    {
      v273 = atomic_load((unint64_t *)(v471 + 8 * *(_QWORD *)n));
      STACK[0xD60] = (unint64_t)CFRetain(CFSTR("PseudoPDF417"));
      v274 = (const void *)atomic_load(&STACK[0xD60]);
      v275 = (const void *)atomic_load((unint64_t *)(v273 + 136));
      if (v275 == v274)
        goto LABEL_316;
      v276 = !v274 || v275 == 0;
      if (!v276 && CFEqual(v275, v274))
        goto LABEL_316;
      v277 = atomic_load((unint64_t *)(v273 + 136));
      if (!v277 || (v278 = atomic_load(&STACK[0xD60])) == 0)
      {
        v281 = CFSTR("PseudoPDF417");
        goto LABEL_318;
      }
      v279 = (const __CFString *)atomic_load((unint64_t *)(v273 + 136));
      v280 = (const __CFString *)atomic_load(&STACK[0xD60]);
      v281 = CFSTR("PseudoPDF417");
      if (CFStringCompare(v279, v280, 0) == kCFCompareEqualTo)
LABEL_316:
        v281 = CFSTR("Pseudo1D");
LABEL_318:
      sub_1D3D8C70C(&STACK[0xD60]);
      v282 = (const void *)MRCRegionCreate((__int128 *)(v273 + 16), (__int128 *)(v273 + 80), v281, *(double *)(v273 + 128), *(float *)(v273 + 144));
      v283 = v282;
      if (v282)
      {
        v284 = CFGetTypeID(v282);
        if (qword_1EDB89308 != -1)
          dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
        if (v284 != qword_1EDB89320)
          _os_assumes_log();
      }
      v285 = (_QWORD *)STACK[0x1458];
      if (STACK[0x1458] >= STACK[0x1460])
      {
        v287 = (uint64_t)((uint64_t)v285 - STACK[0x1450]) >> 3;
        if ((unint64_t)(v287 + 1) >> 61)
          sub_1D3D6D4F8();
        v288 = STACK[0x1460] - STACK[0x1450];
        v289 = v288 >> 2;
        if (v288 >> 2 <= (unint64_t)(v287 + 1))
          v289 = v287 + 1;
        if ((unint64_t)v288 >= 0x7FFFFFFFFFFFFFF8)
          v290 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v290 = v289;
        STACK[0xD80] = (unint64_t)&STACK[0x1460];
        if (v290)
          v290 = (unint64_t)sub_1D3D6D8A0(v290);
        else
          v291 = 0;
        v292 = (_QWORD *)(v290 + 8 * v287);
        STACK[0xD60] = v290;
        STACK[0xD68] = (unint64_t)v292;
        STACK[0xD78] = v290 + 8 * v291;
        *v292 = v283;
        STACK[0xD70] = (unint64_t)(v292 + 1);
        sub_1D3D742F0((uint64_t *)&STACK[0x1450], &STACK[0xD60]);
        v286 = STACK[0x1458];
        sub_1D3D743C8((uint64_t)&STACK[0xD60]);
      }
      else
      {
        *v285 = v283;
        v286 = (unint64_t)(v285 + 1);
      }
      STACK[0x1458] = v286;
    }
  }
  if (STACK[0x1420])
    operator delete((void *)STACK[0x1420]);
  v157 = a2;
  if (v465)
    operator delete(v465);
LABEL_342:
  a68 = 0;
  v293 = (uint64_t *)operator new(0x20uLL);
  *v293 = (uint64_t)&off_1E95AC8D8;
  v293[1] = (uint64_t)&STACK[0x1450];
  v293[2] = (uint64_t)&a10;
  v293[3] = (uint64_t)&a18;
  a68 = v293;
  sub_1D3D74630(v157, &a65);
  v294 = a68;
  if (a68 == &a65)
  {
    v296 = 4;
    v294 = &a65;
    v295 = __pa;
LABEL_346:
    (*(void (**)(void))(*v294 + 8 * v296))();
  }
  else
  {
    v295 = __pa;
    if (a68)
    {
      v296 = 5;
      goto LABEL_346;
    }
  }
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "Waiting for any pending GS1Composite region reusing decoding passes...", (uint8_t *)&STACK[0xD60], 2u);
  }
  dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "Done waiting for pending GS1Composite region reusing decoding passes.", (uint8_t *)&STACK[0xD60], 2u);
  }
  STACK[0xD60] = (unint64_t)&STACK[0x1450];
  sub_1D3D74170((void ***)&STACK[0xD60]);
  STACK[0xD60] = (unint64_t)&STACK[0x1470];
  sub_1D3D74BF0((void ***)&STACK[0xD60]);
  if (v295)
    operator delete(v295);
LABEL_353:
  v297 = 0;
  v298 = (_QWORD *)atomic_load((unint64_t *)&a52);
  v299 = v298 + 2;
  v300 = v298 + 4;
  do
  {
    v301 = &STACK[0x12E0] + 8 * v297;
    if (atomic_load(v301))
    {
      v303 = atomic_load(v301);
      v304 = *(unint64_t **)(v303 + 16);
      v305 = atomic_load(v301);
      v306 = *(unint64_t **)(v305 + 24);
      if (v304 != v306)
      {
        v307 = (unint64_t *)v298[3];
        do
        {
          if ((unint64_t)v307 >= *v300)
          {
            v309 = ((uint64_t)v307 - *v299) >> 3;
            if ((unint64_t)(v309 + 1) >> 61)
              sub_1D3D6D4F8();
            v310 = *v300 - *v299;
            v311 = v310 >> 2;
            if (v310 >> 2 <= (unint64_t)(v309 + 1))
              v311 = v309 + 1;
            if ((unint64_t)v310 >= 0x7FFFFFFFFFFFFFF8)
              v312 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v312 = v311;
            STACK[0xD80] = (unint64_t)v300;
            if (v312)
              v312 = (unint64_t)sub_1D3D6D8A0(v312);
            else
              v313 = 0;
            v314 = (unint64_t *)(v312 + 8 * v309);
            STACK[0xD60] = v312;
            STACK[0xD68] = (unint64_t)v314;
            STACK[0xD70] = (unint64_t)v314;
            STACK[0xD78] = v312 + 8 * v313;
            do
              v315 = __ldaxr(v304);
            while (__stlxr(0, v304));
            *v314 = v315;
            STACK[0xD70] += 8;
            sub_1D3DB37F8(v298 + 2, &STACK[0xD60]);
            v307 = (unint64_t *)v298[3];
            sub_1D3D75F10((uint64_t)&STACK[0xD60]);
          }
          else
          {
            do
              v308 = __ldaxr(v304);
            while (__stlxr(0, v304));
            *v307++ = v308;
            v298[3] = v307;
          }
          v298[3] = v307;
          ++v304;
        }
        while (v304 != v306);
      }
      v316 = atomic_load(v301);
      v317 = (CFTypeRef)atomic_load((unint64_t *)(v316 + 40));
      if (v317)
        v317 = CFRetain(v317);
      STACK[0xD60] = (unint64_t)v317;
      v318 = (const __CFDictionary *)atomic_load(&STACK[0xD60]);
      v319 = (CFTypeRef)atomic_load(v298 + 5);
      if (v319)
        v319 = CFRetain(v319);
      STACK[0x1420] = (unint64_t)v319;
      v320 = (void *)atomic_load(&STACK[0x1420]);
      CFDictionaryApplyFunction(v318, (CFDictionaryApplierFunction)sub_1D3E024D8, v320);
      sub_1D3D740C8(&STACK[0x1420]);
      v194 = sub_1D3D740C8(&STACK[0xD60]);
    }
    ++v297;
  }
  while (v297 != 5);
  v321 = atomic_load((unint64_t *)&a52);
  v322 = a51;
  vars8 = a51;
  STACK[0x1470] = (unint64_t)&off_1E95B0098;
  STACK[0x1488] = (unint64_t)&STACK[0x1470];
  STACK[0x1450] = (unint64_t)&off_1E95B00F0;
  STACK[0x1468] = (unint64_t)&STACK[0x1450];
  STACK[0xD80] = (unint64_t)&STACK[0xD68];
  STACK[0xD60] = (unint64_t)&vars8;
  STACK[0xD68] = (unint64_t)&off_1E95B00F0;
  STACK[0x1420] = v322;
  sub_1D3DC6B50((uint64_t)v194, &STACK[0x1420]);
  v323 = (unint64_t *)STACK[0x1468];
  if ((unint64_t *)STACK[0x1468] == &STACK[0x1450])
  {
    v326 = 4;
    v323 = &STACK[0x1450];
    v324 = a2;
    v325 = v476;
LABEL_383:
    (*(void (**)(void))(*v323 + 8 * v326))();
  }
  else
  {
    v324 = a2;
    v325 = v476;
    if (v323)
    {
      v326 = 5;
      goto LABEL_383;
    }
  }
  v327 = (unint64_t *)STACK[0x1488];
  if ((unint64_t *)STACK[0x1488] == &STACK[0x1470])
  {
    v328 = 4;
    v327 = &STACK[0x1470];
LABEL_388:
    (*(void (**)(void))(*v327 + 8 * v328))();
  }
  else if (v327)
  {
    v328 = 5;
    goto LABEL_388;
  }
  if (!*(_BYTE *)(*(_QWORD *)(v324 + 8) + 67))
    goto LABEL_527;
  v329 = (*(_QWORD *)(v321 + 24) - *(_QWORD *)(v321 + 16)) >> 3;
  a61 = 0;
  HIDWORD(a60) = 0;
  a62 = 0;
  v330 = v329 - 1;
  *(_QWORD *)((char *)&a60 + 4) = (v329 - 1);
  if ((int)v329 <= 0)
    goto LABEL_526;
  while (2)
  {
    v331 = atomic_load((unint64_t *)(*(_QWORD *)(v321 + 16) + 8 * v330));
    STACK[0x1420] = (unint64_t)CFRetain(CFSTR("PDF417"));
    v332 = (const void *)atomic_load(&STACK[0x1420]);
    v333 = (const void *)atomic_load((unint64_t *)(v331 + 16));
    if (v333 != v332)
    {
      v334 = !v332 || v333 == 0;
      if (v334 || !CFEqual(v333, v332))
      {
        v335 = atomic_load((unint64_t *)(v331 + 16));
        if (!v335
          || (v336 = atomic_load(&STACK[0x1420])) == 0
          || (v337 = (const __CFString *)atomic_load((unint64_t *)(v331 + 16)),
              v338 = (const __CFString *)atomic_load(&STACK[0x1420]),
              CFStringCompare(v337, v338, 0)))
        {
          a55 = (void *)CFRetain(CFSTR("MicroPDF417"));
          v339 = (const void *)atomic_load((unint64_t *)&a55);
          v340 = (const void *)atomic_load((unint64_t *)(v331 + 16));
          if (v340 == v339 || v339 && v340 && CFEqual(v340, v339))
          {
            sub_1D3D8C70C((unint64_t *)&a55);
            goto LABEL_405;
          }
          v363 = atomic_load((unint64_t *)(v331 + 16));
          if (v363 && (v364 = atomic_load((unint64_t *)&a55)) != 0)
          {
            v365 = (const __CFString *)atomic_load((unint64_t *)(v331 + 16));
            v366 = (const __CFString *)atomic_load((unint64_t *)&a55);
            v367 = CFStringCompare(v365, v366, 0);
            sub_1D3D8C70C((unint64_t *)&a55);
            sub_1D3D8C70C(&STACK[0x1420]);
            if (v367 == kCFCompareEqualTo)
              goto LABEL_406;
          }
          else
          {
            sub_1D3D8C70C((unint64_t *)&a55);
            sub_1D3D8C70C(&STACK[0x1420]);
          }
          goto LABEL_510;
        }
      }
    }
LABEL_405:
    sub_1D3D8C70C(&STACK[0x1420]);
LABEL_406:
    if (*(_BYTE *)(v331 + 208))
    {
      if (*(_BYTE *)(v331 + 164))
      {
        if (*(_BYTE *)(v331 + 156))
        {
          if (*(_BYTE *)(v331 + 280))
          {
            if (*(_BYTE *)(v331 + 64))
            {
              v341 = *(double **)(v331 + 40);
              if (*(_QWORD *)(v331 + 48) - (_QWORD)v341 == 64)
              {
                v342 = *(_QWORD *)(v331 + 176);
                v343 = *(_DWORD *)(v331 + 152);
                v344 = *(float *)(v331 + 272);
                v345 = v341[4];
                v346 = v341[5];
                v347 = *v341;
                v348 = v341[1];
                v349 = v341[6];
                v350 = v341[7];
                v351 = v345;
                v352 = v346;
                v353 = v341[2];
                v354 = v341[3];
                v355 = v353;
                v356 = v354;
                v357 = *(float *)(v331 + 276);
                sub_1D3DB9500((uint64_t *)&a59, v347, v348, v349, v350, v351, v352, v355, v356);
                v472 = v343;
                sub_1D3DB983C(&a58, a59, v358);
                if (!a58)
                {
LABEL_509:
                  sub_1D3D6F2E0(&a58);
                  sub_1D3D6F2E0((unsigned int **)&a59);
                  goto LABEL_510;
                }
                v359 = v346 - v354;
                v360 = v345 - v353;
                v361 = (float)(atan2f(v359, v360) * 180.0) / 3.14159265;
                if (v361 >= -90.0)
                {
                  v362 = v343;
                  if (v361 > 90.0)
                    v361 = v361 + -180.0;
                }
                else
                {
                  v361 = v361 + 180.0;
                  v362 = v343;
                }
                v368 = 0;
                v466 = (void *)(v342 - 3);
                v371 = (unint64_t)(v342 - 3) < 2 && (v362 - 2) < 3 || v342 == 5;
                __pb = v371;
                while (2)
                {
                  if (v368 == DWORD1(a60))
                    goto LABEL_508;
                  v372 = atomic_load((unint64_t *)(*(_QWORD *)(v321 + 16) + 8 * v368));
                  if (!*(_BYTE *)(v372 + 228)
                    || !*(_BYTE *)(v372 + 280)
                    || !*(_BYTE *)(v372 + 264)
                    || !*(_BYTE *)(v372 + 64)
                    || *(_QWORD *)(v372 + 48) - *(_QWORD *)(v372 + 40) != 64)
                  {
                    goto LABEL_508;
                  }
                  v373 = (CFTypeRef)atomic_load((unint64_t *)(v372 + 16));
                  if (v373)
                    v373 = CFRetain(v373);
                  STACK[0x1420] = (unint64_t)v373;
                  v374 = v372 + 168;
                  if (*(_BYTE *)(v372 + 208))
                    v375 = *(_BYTE *)(v372 + 168) == 0;
                  else
                    v375 = 1;
                  if (!v375)
                  {
LABEL_466:
                    if (__pb)
                      goto LABEL_467;
                    goto LABEL_507;
                  }
                  a55 = (void *)CFRetain(CFSTR("UPCE"));
                  v376 = (const void *)atomic_load((unint64_t *)&a55);
                  v377 = (const void *)atomic_load(&STACK[0x1420]);
                  if (v377 != v376 && (!v376 || !v377 || !CFEqual(v377, v376)))
                  {
                    v378 = atomic_load(&STACK[0x1420]);
                    if (!v378
                      || (v379 = atomic_load((unint64_t *)&a55)) == 0
                      || (v380 = (const __CFString *)atomic_load(&STACK[0x1420]),
                          v381 = (const __CFString *)atomic_load((unint64_t *)&a55),
                          CFStringCompare(v380, v381, 0)))
                    {
                      a64 = CFRetain(CFSTR("EAN8"));
                      v382 = (const void *)atomic_load((unint64_t *)&a64);
                      v383 = (const void *)atomic_load(&STACK[0x1420]);
                      if (v383 != v382 && (!v382 || !v383 || !CFEqual(v383, v382)))
                      {
                        v384 = atomic_load(&STACK[0x1420]);
                        if (!v384
                          || (v385 = atomic_load((unint64_t *)&a64)) == 0
                          || (v386 = (const __CFString *)atomic_load(&STACK[0x1420]),
                              v387 = (const __CFString *)atomic_load((unint64_t *)&a64),
                              CFStringCompare(v386, v387, 0)))
                        {
                          a63 = CFRetain(CFSTR("EAN13"));
                          v388 = (const void *)atomic_load((unint64_t *)&a63);
                          v389 = (const void *)atomic_load(&STACK[0x1420]);
                          if (v389 == v388 || v388 && v389 && CFEqual(v389, v388))
                          {
                            sub_1D3D8C70C((unint64_t *)&a63);
                            goto LABEL_464;
                          }
                          v410 = atomic_load(&STACK[0x1420]);
                          if (!v410 || (v411 = atomic_load((unint64_t *)&a63)) == 0)
                          {
                            sub_1D3D8C70C((unint64_t *)&a63);
                            sub_1D3D8C70C((unint64_t *)&a64);
                            sub_1D3D8C70C((unint64_t *)&a55);
                            goto LABEL_507;
                          }
                          v412 = v342;
                          v413 = (const __CFString *)atomic_load(&STACK[0x1420]);
                          v414 = (const __CFString *)atomic_load((unint64_t *)&a63);
                          v415 = CFStringCompare(v413, v414, 0);
                          sub_1D3D8C70C((unint64_t *)&a63);
                          sub_1D3D8C70C((unint64_t *)&a64);
                          sub_1D3D8C70C((unint64_t *)&a55);
                          v416 = __pb;
                          if (v415)
                            v416 = 0;
                          v342 = v412;
                          v374 = v372 + 168;
                          if (v416)
                          {
LABEL_467:
                            if (qword_1EFE317B0 != -1)
                              dispatch_once(&qword_1EFE317B0, &unk_1E95B3230);
                            if ((unint64_t)v466 >= 2)
                            {
                              if (v342 != 5)
                                goto LABEL_507;
                              v461 = v374;
                              v392 = qword_1EFE317A8;
                              v393 = sub_1D3DC6BF0(*(unint64_t **)qword_1EFE317A8, *(unint64_t **)(qword_1EFE317A8 + 8), &STACK[0x1420]);
                              v394 = *(unint64_t **)(v392 + 8);
                              sub_1D3D8C70C(&STACK[0x1420]);
                              v395 = v393 == v394;
                              v342 = 5;
                            }
                            else
                            {
                              switch(v472)
                              {
                                case 4:
                                  v461 = v374;
                                  v462 = v342;
                                  v390 = qword_1EFE317A0;
                                  v391 = sub_1D3DC6BF0(*(unint64_t **)qword_1EFE317A0, *(unint64_t **)(qword_1EFE317A0 + 8), &STACK[0x1420]);
                                  break;
                                case 3:
                                  v461 = v374;
                                  v462 = v342;
                                  v390 = qword_1EFE31798;
                                  v391 = sub_1D3DC6BF0(*(unint64_t **)qword_1EFE31798, *(unint64_t **)(qword_1EFE31798 + 8), &STACK[0x1420]);
                                  break;
                                case 2:
                                  v461 = v374;
                                  v462 = v342;
                                  v390 = qword_1EFE31790;
                                  v391 = sub_1D3DC6BF0(*(unint64_t **)qword_1EFE31790, *(unint64_t **)(qword_1EFE31790 + 8), &STACK[0x1420]);
                                  break;
                                default:
                                  goto LABEL_507;
                              }
                              v396 = v391;
                              v397 = *(unint64_t **)(v390 + 8);
                              sub_1D3D8C70C(&STACK[0x1420]);
                              v395 = v396 == v397;
                              v342 = v462;
                            }
                            if (!v395)
                            {
                              if (!*(_BYTE *)(v372 + 280))
                                sub_1D3D74BBC();
                              if (vabds_f32(*(float *)(v372 + 272), v344) <= (float)(v344 * 0.4)
                                && vabds_f32(*(float *)(v372 + 276), v357) <= (float)(v357 * 0.4))
                              {
                                if (!*(_BYTE *)(v372 + 228))
                                  sub_1D3D74BBC();
                                if (vabds_f32(v361, *(float *)(v372 + 224)) <= 10.0)
                                {
                                  if (!*(_BYTE *)(v372 + 264))
                                    sub_1D3D74BBC();
                                  if (!*(_BYTE *)(v372 + 64))
                                    sub_1D3D74BBC();
                                  *(float32x4_t *)&STACK[0x1420] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v372 + 232)), *(float64x2_t *)(v372 + 248));
                                  STACK[0x1430] = (unint64_t)vcvt_f32_f64(*(float64x2_t *)(*(_QWORD *)(v372 + 40)
                                                                                                + 32));
                                  sub_1D3DC6C5C(&a55, &STACK[0x1420], 6uLL);
                                  (*(void (**)(unsigned int *, void **))(*(_QWORD *)a58 + 16))(a58, &a55);
                                  v398 = a55;
                                  v399 = *(float *)a55;
                                  v400 = 1;
                                  if (*(float *)a55 < 0.5)
                                  {
                                    v401 = *((float *)a55 + 2);
                                    if (v401 > 0.5 && (float)(v401 - v399) > 0.5)
                                    {
                                      v402 = *((float *)a55 + 1);
                                      if (v402 > 1.0 && v402 < 20.0)
                                      {
                                        v403 = *((float *)a55 + 3);
                                        if (v403 > 1.0 && v403 < 20.0)
                                        {
                                          v463 = *((float *)a55 + 2);
                                          v460 = *((float *)a55 + 5);
                                          if (!*(_BYTE *)(v372 + 208))
                                          {
                                            *(_QWORD *)(v461 + 32) = 0;
                                            *(_OWORD *)v461 = 0u;
                                            *(_OWORD *)(v461 + 16) = 0u;
                                            *(_BYTE *)(v372 + 208) = 1;
                                          }
                                          *(_QWORD *)(v372 + 176) = 2;
                                          *(_QWORD *)(v372 + 184) = v342;
                                          *(_BYTE *)(v372 + 192) = 1;
                                          v404 = (const void *)atomic_load((unint64_t *)(v331 + 24));
                                          sub_1D3D95C6C((unint64_t *)(v372 + 200), v404);
                                          v405 = fminf(v399, 0.0);
                                          v406 = fmaxf(v463, 1.0);
                                          *(float *)&STACK[0x1420] = v405;
                                          v407 = fmaxf(v460, 1.0);
                                          LODWORD(STACK[0x1424]) = 0;
                                          *(float *)&STACK[0x1428] = v405;
                                          *(float *)&STACK[0x142C] = v407;
                                          *(float *)&STACK[0x1430] = v406;
                                          *(float *)&STACK[0x1434] = v407;
                                          STACK[0x1438] = LODWORD(v406);
                                          sub_1D3DC6CDC((char *)&a55, (char *)&STACK[0x1420], (uint64_t)&STACK[0x1440]);
                                          (*(void (**)(float *, void **))(*(_QWORD *)a59 + 16))(a59, &a55);
                                          v408 = (const float *)a55;
                                          v409 = *(double **)(v372 + 40);
                                          v478 = vld2q_f32(v408);
                                          v479.val[0] = vcvtq_f64_f32(*(float32x2_t *)v478.val[0].f32);
                                          v479.val[1] = vcvtq_f64_f32(*(float32x2_t *)v478.val[1].f32);
                                          vst2q_f64(v409, v479);
                                          v409 += 4;
                                          v479.val[0] = vcvt_hight_f64_f32(v478.val[0]);
                                          v479.val[1] = vcvt_hight_f64_f32(v478.val[1]);
                                          vst2q_f64(v409, v479);
                                          sub_1D3DC6DD0((uint64_t)&a60 + 8, (_DWORD *)&a60 + 1);
                                          v398 = a55;
                                          if (!a55)
                                            goto LABEL_509;
                                          v400 = 0;
                                        }
                                      }
                                    }
                                  }
                                  a56 = v398;
                                  operator delete(v398);
                                  if (!v400)
                                    goto LABEL_509;
                                }
                              }
                            }
                          }
                          else
                          {
LABEL_507:
                            sub_1D3D8C70C(&STACK[0x1420]);
                          }
LABEL_508:
                          if ((int)++v368 >= (int)v329)
                            goto LABEL_509;
                          continue;
                        }
                      }
LABEL_464:
                      sub_1D3D8C70C((unint64_t *)&a64);
                    }
                  }
                  break;
                }
                sub_1D3D8C70C((unint64_t *)&a55);
                goto LABEL_466;
              }
            }
          }
        }
      }
    }
LABEL_510:
    v417 = DWORD1(a60);
    v330 = --DWORD1(a60);
    v325 = v476;
    if (v417 > 0)
      continue;
    break;
  }
  v418 = (int *)*((_QWORD *)&a60 + 1);
  v419 = a61;
  if (*((int **)&a60 + 1) != a61)
  {
    v420 = *(unint64_t **)(v321 + 24);
    do
    {
      v421 = (unint64_t *)(*(_QWORD *)(v321 + 16) + 8 * *v418);
      v422 = v421 + 1;
      if (v421 + 1 != v420)
      {
        do
        {
          do
            v423 = __ldaxr(v422);
          while (__stlxr(0, v422));
          do
            v424 = (const void *)__ldaxr(v421);
          while (__stlxr(v423, v421));
          if (v424)
            CFRelease(v424);
          ++v422;
          ++v421;
        }
        while (v422 != v420);
        v420 = *(unint64_t **)(v321 + 24);
      }
      while (v420 != v421)
        sub_1D3D74F14(--v420);
      *(_QWORD *)(v321 + 24) = v421;
      ++v418;
      v420 = v421;
    }
    while (v418 != v419);
    v418 = (int *)*((_QWORD *)&a60 + 1);
  }
  if (v418)
    operator delete(v418);
LABEL_526:
  v324 = a2;
LABEL_527:
  v425 = (unint64_t *)STACK[0xD80];
  if (*(_BYTE *)(STACK[0xD60] + 8))
  {
    if (v425)
    {
      STACK[0x1420] = *(_QWORD *)STACK[0xD60];
      (*(void (**)(unint64_t *, unint64_t *))(*v425 + 48))(v425, &STACK[0x1420]);
      v425 = (unint64_t *)STACK[0xD80];
      goto LABEL_530;
    }
  }
  else
  {
LABEL_530:
    if (v425 == &STACK[0xD68])
    {
      v426 = 4;
      v425 = &STACK[0xD68];
    }
    else
    {
      if (!v425)
        goto LABEL_535;
      v426 = 5;
    }
    (*(void (**)(void))(*v425 + 8 * v426))();
  }
LABEL_535:
  if (*(_BYTE *)(*(_QWORD *)(v324 + 8) + 68))
  {
    a47.tv_sec = 0;
    a47.tv_nsec = 0;
    a48 = 1;
    clock_gettime(_CLOCK_MONOTONIC, &a47);
    v427 = (double)(a47.tv_nsec - __tp.tv_nsec) / 1000000000.0 + (double)(a47.tv_sec - __tp.tv_sec);
    *(double *)&STACK[0x1420] = v427;
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(STACK[0xD60]) = 134349056;
      *(double *)&STACK[0xD64] = v427;
      _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "Elapsed time during decoding: %{public}g", (uint8_t *)&STACK[0xD60], 0xCu);
    }
    STACK[0xD60] = (unint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &STACK[0x1420]);
    v428 = atomic_load((unint64_t *)&a52);
    v429 = (CFTypeRef)atomic_load((unint64_t *)(v428 + 40));
    if (v429)
      v429 = CFRetain(v429);
    STACK[0x1470] = (unint64_t)v429;
    v430 = (__CFDictionary *)atomic_load(&STACK[0x1470]);
    v431 = (const void *)atomic_load(&STACK[0xD60]);
    CFDictionarySetValue(v430, CFSTR("MRCDecoderResultAttributeDecodingElapsedTime"), v431);
    sub_1D3D740C8(&STACK[0x1470]);
    sub_1D3D74100(&STACK[0xD60]);
  }
  v432 = a51;
  if (a51 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(oslog))
  {
    v433 = atomic_load((unint64_t *)&a52);
    LODWORD(STACK[0xD60]) = 138739971;
    STACK[0xD64] = v433;
    _os_signpost_emit_with_name_impl(&dword_1D3D6B000, oslog, OS_SIGNPOST_INTERVAL_END, v432, "SampleDecoding", "End decoding: decoderResult=%{sensitive, signpost.description:attribute}@", (uint8_t *)&STACK[0xD60], 0xCu);
  }
  v434 = *(_QWORD *)(a2 + 8);
  if ((_BYTE)a46 && *(_BYTE *)(v434 + 52))
  {
    v435 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    STACK[0xD60] = (unint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v436 = *((_QWORD *)&a45 + 1);
    if (*((_QWORD *)&a45 + 1))
    {
      v437 = 0;
      v438 = 0;
      do
      {
        if ((a40[v437] & 1) == 0)
        {
          v439 = (__CFArray *)atomic_load(&STACK[0xD60]);
          v440 = (const void *)atomic_load((unint64_t *)(a45 + 8 * v438));
          CFArrayAppendValue(v439, v440);
        }
        ++v438;
        v437 += 64;
      }
      while (v436 != v438);
    }
    v441 = (const __CFArray *)atomic_load(&STACK[0xD60]);
    STACK[0x1420] = (unint64_t)CFArrayCreateCopy(v435, v441);
    v442 = atomic_load((unint64_t *)&a52);
    v443 = (CFTypeRef)atomic_load((unint64_t *)(v442 + 40));
    if (v443)
      v443 = CFRetain(v443);
    STACK[0x1470] = (unint64_t)v443;
    v444 = (__CFDictionary *)atomic_load(&STACK[0x1470]);
    v445 = (const void *)atomic_load(&STACK[0x1420]);
    CFDictionarySetValue(v444, CFSTR("MRCDecoderResultAttributeUnrecognizedRegions"), v445);
    sub_1D3D740C8(&STACK[0x1470]);
    sub_1D3D74138(&STACK[0x1420]);
    sub_1D3D74C60(&STACK[0xD60]);
    v434 = *(_QWORD *)(a2 + 8);
  }
  if (*(uint64_t *)(v434 + 56) >= 196608)
  {
    v448 = atomic_load((unint64_t *)&a52);
    if (*(_QWORD *)(v448 + 16) != *(_QWORD *)(v448 + 24))
      goto LABEL_569;
LABEL_564:
    v449 = 0;
    v450 = &STACK[0xF20];
    while (!*((_BYTE *)v450 + 96))
    {
      ++v449;
      v450 += 16;
      if (v449 == 5)
        goto LABEL_569;
    }
    sub_1D3D74C98(v325, (uint64_t)v450);
    v458 = 0;
  }
  else
  {
    v446 = 0;
    while (!*((_BYTE *)&STACK[0xDE0] + v446 + 1) || *((_BYTE *)&STACK[0xDE0] + v446) == 0)
    {
      v446 += 64;
      if (v446 == 320)
        goto LABEL_564;
    }
    do
LABEL_569:
      v458 = __ldaxr((unint64_t *)&a52);
    while (__stlxr(0, (unint64_t *)&a52));
  }
  *a1 = v458;
  v451 = group;
  group = 0;
  if (v451)
    a21();
  if (a25)
  {
    STACK[0xD60] = (unint64_t)&a22;
    sub_1D3D74CFC((void ***)&STACK[0xD60]);
  }
  if (a35)
  {
    STACK[0xD60] = (unint64_t)&a32;
    sub_1D3D74D70((void ***)&STACK[0xD60]);
  }
  if (a39)
  {
    STACK[0xD60] = (unint64_t)&a36;
    sub_1D3D74170((void ***)&STACK[0xD60]);
  }
  v452 = a40;
  a40 = 0;
  if (v452)
    MEMORY[0x1D8254C30](v452, 64);
LABEL_580:
  if (a44)
  {
    STACK[0xD60] = (unint64_t)&a41;
    sub_1D3D74170((void ***)&STACK[0xD60]);
  }
  v453 = 640;
  do
  {
    if (*((_BYTE *)&STACK[0xF20] + v453 - 32))
      sub_1D3DF4F24((unint64_t *)((char *)&STACK[0xF20] + v453 - 128));
    v453 -= 128;
  }
  while (v453);
  v454 = 320;
  do
  {
    v455 = *(void **)((char *)&STACK[0x11A0] + v454 - 64);
    if (v455)
    {
      *(unint64_t *)((char *)&STACK[0x11A0] + v454 - 56) = (unint64_t)v455;
      operator delete(v455);
    }
    v454 -= 64;
  }
  while (v454);
  for (ii = 256; ii != -64; ii -= 64)
    sub_1D3D74DE4((unint64_t *)((char *)&STACK[0x12E0] + ii));
  sub_1D3D74DE4((unint64_t *)&a52);
  return sub_1D3D74E1C((uint64_t)&a53);
}

void sub_1D3D73894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *****a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void (*a41)(void),void ****a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void ***a52,uint64_t a53,uint64_t a54,char a55,void **a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  char a64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  uint64_t i;

  v65 = (void *)STACK[0x228];
  if (STACK[0x228])
  {
    STACK[0x230] = (unint64_t)v65;
    operator delete(v65);
  }
  sub_1D3D6F2E0((unsigned int **)&STACK[0x240]);
  sub_1D3D6F2E0((unsigned int **)&STACK[0x248]);
  if (STACK[0x258])
    operator delete((void *)STACK[0x258]);
  sub_1D3D87C3C(&STACK[0x300]);
  v66 = a40;
  a40 = 0;
  if (v66)
    a41();
  if (a45)
  {
    a34 = &a42;
    sub_1D3D74CFC((void ***)&a34);
  }
  if (a55)
  {
    a42 = &a52;
    sub_1D3D74D70((void ***)&a42);
  }
  if (a59)
  {
    a52 = &a56;
    sub_1D3D74170((void ***)&a52);
  }
  v67 = a60;
  a60 = 0;
  if (v67)
    MEMORY[0x1D8254C30](v67, 64);
  if (a64)
  {
    a56 = (void **)&a61;
    sub_1D3D74170(&a56);
  }
  v68 = 640;
  while (1)
  {
    if (*((_BYTE *)&STACK[0x4C0] + v68 - 32))
      sub_1D3DF4F24((unint64_t *)((char *)&STACK[0x4C0] + v68 - 128));
    v68 -= 128;
    if (!v68)
    {
      v69 = 320;
      while (1)
      {
        v70 = *(void **)((char *)&STACK[0x740] + v69 - 64);
        if (v70)
        {
          *(unint64_t *)((char *)&STACK[0x740] + v69 - 56) = (unint64_t)v70;
          operator delete(v70);
        }
        v69 -= 64;
        if (!v69)
        {
          for (i = 256; i != -64; i -= 64)
            sub_1D3D74DE4((unint64_t *)((char *)&STACK[0x880] + i));
          sub_1D3D74DE4(&STACK[0x210]);
          sub_1D3D74E1C((uint64_t)&STACK[0x218]);
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

uint64_t sub_1D3D73E0C(unint64_t *a1, uint64_t *a2, CFTypeRef *a3)
{
  uint64_t result;

  if (*((_BYTE *)a1 + 96))
  {
    a1 = sub_1D3DF4F24(a1);
    *((_BYTE *)a1 + 96) = 0;
  }
  result = sub_1D3DF4E68((uint64_t)a1, *a2, *a3);
  *(_BYTE *)(result + 96) = 1;
  return result;
}

_QWORD *sub_1D3D73E50()
{
  const __CFAllocator *v0;
  _QWORD *Instance;
  _QWORD *v2;
  CFTypeID v3;
  CFTypeID v4;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (qword_1EDB89338[0] != -1)
    dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v2 = Instance;
  if (Instance)
  {
    v3 = CFGetTypeID(Instance);
    if (qword_1EDB89338[0] != -1)
      dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
    if (v3 != qword_1EDB89310)
      _os_assumes_log();
    v2[2] = 0;
    v2[3] = 0;
    v2[4] = 0;
    v2[5] = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v4 = CFGetTypeID(v2);
    if (qword_1EDB89338[0] != -1)
      dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
    if (v4 != qword_1EDB89310)
      _os_assumes_log();
  }
  return v2;
}

void sub_1D3D73FA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D74BF0((void ***)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D73FB8()
{
  _QWORD *result;
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB892A0)
    _os_assumes_log();
  if (qword_1EDB893D8)
    _os_assumes_log();
  qword_1EDB892A0 = (uint64_t)"MRCContext";
  qword_1EDB893D8 = _CFRuntimeRegisterClass();
  v3 = 0;
  sub_1D3DAFDB4(qword_1EDB893D8, v2);
  result = v3;
  if (v3 == v2)
  {
    v1 = 4;
    result = v2;
  }
  else
  {
    if (!v3)
      return result;
    v1 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
}

void sub_1D3D74084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t *sub_1D3D740C8(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

unint64_t *sub_1D3D74100(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

unint64_t *sub_1D3D74138(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

void sub_1D3D74170(void ***a1)
{
  void **v1;
  unint64_t *v2;
  unint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (unint64_t *)**a1;
  if (v2)
  {
    v4 = (unint64_t *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3D78858(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *sub_1D3D741E0()
{
  _QWORD *result;
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB89168)
    _os_assumes_log();
  if (qword_1EDB89320)
    _os_assumes_log();
  qword_1EDB89168 = (uint64_t)"MRCRegion";
  qword_1EDB89320 = _CFRuntimeRegisterClass();
  v3 = 0;
  sub_1D3DAFDB4(qword_1EDB89320, v2);
  result = v3;
  if (v3 == v2)
  {
    v1 = 4;
    result = v2;
  }
  else
  {
    if (!v3)
      return result;
    v1 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
}

void sub_1D3D742AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1D3D742F0(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 != *result)
  {
    v7 = 0;
    do
    {
      result = (uint64_t *)atomic_load((unint64_t *)(v4 + v7 - 8));
      if (result)
        result = (uint64_t *)CFRetain(result);
      *(_QWORD *)(v6 + v7 - 8) = result;
      v7 -= 8;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  v8 = *v3;
  *v3 = v6;
  a2[1] = v8;
  v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1D3D743C8(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    sub_1D3D78858((unint64_t *)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

char *sub_1D3D74414(unint64_t *a1)
{
  char *v1;
  CFTypeID v2;

  v1 = (char *)atomic_load(a1);
  if (v1)
  {
    v2 = CFGetTypeID(v1);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v2 != qword_1EDB893D8)
      _os_assumes_log();
  }
  return v1 + 16;
}

unint64_t *sub_1D3D7448C(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

int64x2_t *sub_1D3D744C4(uint64_t a1, unint64_t *a2, CGRect *a3, _OWORD *a4)
{
  int64x2_t *result;
  void **v9;

  if (*(_BYTE *)(a1 + 24))
  {
    v9 = (void **)a1;
    sub_1D3D74D70(&v9);
    *(_BYTE *)(a1 + 24) = 0;
  }
  result = sub_1D3DE677C((int64x2_t *)a1, a2, a3, a4);
  *(_BYTE *)(a1 + 24) = 1;
  return result;
}

_QWORD *sub_1D3D74530(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *--v2;
    *v2 = 0;
    *(_QWORD *)(v4 - 8) = v5;
    v4 -= 8;
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1D3D7458C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      sub_1D3D745E4(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1D3D745E4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
    *(_BYTE *)(a1 + 16) = sub_1D3DE793C(*(unint64_t **)a1, *(_QWORD *)(a1 + 8)) ^ 1;
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D74630(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t i;
  char *v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _QWORD v13[3];
  __int128 v14;
  uint64_t v15;
  _QWORD v16[4];
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t);
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t (*v26)();
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(uint64_t, __int128 *);
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  _BYTE v41[24];
  _BYTE *v42;
  _BYTE v43[24];
  _BYTE *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v3 = a2 + 3;
  v4 = (_QWORD *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      v42 = v41;
      (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v41);
      goto LABEL_7;
    }
    v42 = (_BYTE *)a2[3];
  }
  else
  {
    v3 = &v42;
  }
  *v3 = 0;
LABEL_7:
  v13[0] = sub_1D3D7CF70;
  v13[1] = 0;
  v13[2] = a1;
  v14 = xmmword_1E95B0568;
  v15 = 0;
  v16[0] = 0;
  v16[1] = sub_1D3E4B124;
  v16[2] = 0;
  v16[3] = a1;
  v17 = xmmword_1E95B0578;
  v18 = 0x100000000;
  v19 = 1;
  v20 = sub_1D3E29A70;
  v21 = 0;
  v22 = a1;
  v23 = xmmword_1E95B0588;
  v24 = 0x200000000;
  v25 = 2;
  v26 = nullsub_323;
  v27 = 0;
  v28 = a1;
  v29 = xmmword_1E95B0598;
  v30 = 0x300000000;
  v31 = 3;
  v32 = sub_1D3DB1128;
  v33 = 0;
  v34 = a1;
  v35 = xmmword_1E95B05A8;
  v36 = 0x47FFFFFFFLL;
  v37 = 4;
  sub_1D3D76D70((uint64_t)v13, (unint64_t)&v38, 4, 1, COERCE_DOUBLE(0x47FFFFFFFLL));
  for (i = 0; i != 35; i += 7)
  {
    v6 = (char *)operator new(0x20uLL);
    *(_QWORD *)v6 = &off_1E95AFB18;
    *(_OWORD *)(v6 + 8) = *(_OWORD *)&v13[i];
    *((_QWORD *)v6 + 3) = v13[i + 2];
    v44 = v6;
    v7 = v16[i - 1];
    v8 = v16[i];
    v39 = *(_DWORD *)((char *)&v15 + i * 8 + 4);
    v40 = v7;
    v38 = v8;
    if (!v42)
      sub_1D3D75A24();
    (*(void (**)(_BYTE *, _BYTE *, _QWORD *, int *, int *, uint64_t *))(*(_QWORD *)v42 + 48))(v42, v43, &v13[i + 3], &v40, &v39, &v38);
    v9 = v44;
    if (v44 == v43)
    {
      v9 = v43;
      v10 = 4;
    }
    else
    {
      if (!v44)
        continue;
      v10 = 5;
    }
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  result = v42;
  if (v42 == v41)
  {
    v12 = 4;
    result = v41;
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }
  else if (v42)
  {
    v12 = 5;
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }
  return result;
}

void sub_1D3D748B4(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

void sub_1D3D7493C(uint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, uint64_t a5)
{
  unint64_t *v6;
  unint64_t *v7;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v21;
  uint64_t v22;
  CFTypeRef v23;
  unint64_t *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  CFTypeRef v28;
  unint64_t *v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  const void *v35;
  CFTypeRef v36;
  const void *v37;
  _QWORD v38[2];
  _QWORD *v39;
  unint64_t v40;
  uint64_t *v41;

  if (a5 < 1)
    return;
  v6 = a3;
  v7 = a2;
  v9 = a1 + 2;
  v10 = a1[2];
  v11 = a1[1];
  if (a5 > (uint64_t)(v10 - v11) >> 3)
  {
    v12 = *a1;
    v13 = a5 + ((uint64_t)(v11 - *a1) >> 3);
    if (v13 >> 61)
      sub_1D3D6D4F8();
    v14 = ((uint64_t)a2 - v12) >> 3;
    v15 = v10 - v12;
    if (v15 >> 2 > v13)
      v13 = v15 >> 2;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
      v16 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v16 = v13;
    v41 = v9;
    if (v16)
      v16 = (unint64_t)sub_1D3D6D8A0(v16);
    else
      v17 = 0;
    v25 = (_QWORD *)(v16 + 8 * v14);
    v38[0] = v16;
    v38[1] = v25;
    v39 = v25;
    v40 = v16 + 8 * v17;
    v26 = 8 * a5;
    v27 = &v25[a5];
    do
    {
      v28 = (CFTypeRef)atomic_load(v6);
      if (v28)
        v28 = CFRetain(v28);
      *v25++ = v28;
      ++v6;
      v26 -= 8;
    }
    while (v26);
    v39 = v27;
    sub_1D3D75E08(a1, v38, (uint64_t)v7);
    sub_1D3D75F10((uint64_t)v38);
    return;
  }
  v18 = v11 - (_QWORD)a2;
  v19 = (uint64_t)(v11 - (_QWORD)a2) >> 3;
  if (v19 >= a5)
  {
    v21 = &a3[a5];
    v24 = (unint64_t *)a1[1];
LABEL_27:
    v29 = &v7[a5];
    v30 = &v24[-a5];
    v31 = v24;
    if ((unint64_t)v30 < v11)
    {
      v32 = v30;
      v31 = v24;
      do
      {
        do
          v33 = __ldaxr(v32);
        while (__stlxr(0, v32));
        *v31++ = v33;
        ++v32;
      }
      while ((unint64_t)v32 < v11);
    }
    a1[1] = (uint64_t)v31;
    if (v24 != v29)
    {
      do
      {
        --v30;
        --v24;
        do
          v34 = __ldaxr(v30);
        while (__stlxr(0, v30));
        do
          v35 = (const void *)__ldaxr(v24);
        while (__stlxr(v34, v24));
        if (v35)
          CFRelease(v35);
      }
      while (v30 != v7);
    }
    for (; v6 != v21; ++v7)
    {
      v36 = (CFTypeRef)atomic_load(v6);
      if (v36)
        v36 = CFRetain(v36);
      do
        v37 = (const void *)__ldaxr(v7);
      while (__stlxr((unint64_t)v36, v7));
      if (v37)
        CFRelease(v37);
      ++v6;
    }
    return;
  }
  v21 = &a3[v19];
  if (v21 == a4)
  {
    v24 = (unint64_t *)a1[1];
  }
  else
  {
    v22 = 0;
    do
    {
      v23 = (CFTypeRef)atomic_load(&v21[v22]);
      if (v23)
        v23 = CFRetain(v23);
      *(_QWORD *)(v11 + v22 * 8) = v23;
      ++v22;
    }
    while (&v21[v22] != a4);
    v24 = (unint64_t *)(v11 + v22 * 8);
  }
  a1[1] = (uint64_t)v24;
  if (v18 >= 1)
    goto LABEL_27;
}

void sub_1D3D74B74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D75F10((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1D3D74BBC()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE5048] + 16;
  __cxa_throw(exception, MEMORY[0x1E0DE4E90], MEMORY[0x1E0DE4380]);
}

void sub_1D3D74BF0(void ***a1)
{
  void **v1;
  unint64_t *v2;
  unint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (unint64_t *)**a1;
  if (v2)
  {
    v4 = (unint64_t *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3D74F14(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unint64_t *sub_1D3D74C60(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

unint64_t *sub_1D3D74C98(unint64_t *result, uint64_t a2)
{
  unint64_t *v3;

  if (*((unsigned __int8 *)result + 96) == *(unsigned __int8 *)(a2 + 96))
  {
    if (*((_BYTE *)result + 96))
    {
      v3 = sub_1D3DF4F24(result);
      return sub_1D3DF50BC(v3, (uint64_t *)a2);
    }
  }
  else if (*((_BYTE *)result + 96))
  {
    result = sub_1D3DF4F24(result);
    *((_BYTE *)result + 96) = 0;
  }
  else
  {
    result = sub_1D3DF50BC(result, (uint64_t *)a2);
    *((_BYTE *)result + 96) = 1;
  }
  return result;
}

void sub_1D3D74CFC(void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          sub_1D3D745E4(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1D3D74D70(void ***a1)
{
  void **v1;
  unint64_t *v2;
  unint64_t *v4;
  void *v5;
  unint64_t *v6;

  v1 = *a1;
  v2 = (unint64_t *)**a1;
  if (v2)
  {
    v4 = (unint64_t *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 27;
        sub_1D3D74EDC(v4 - 26);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unint64_t *sub_1D3D74DE4(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1D3D74E1C(uint64_t a1)
{
  unint64_t **v2;
  unint64_t *v3;
  unint64_t i;
  char v5;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(unint64_t ***)a1;
    if (sub_1D3DE78D8(**(unint64_t ***)a1))
    {
      v3 = v2[7];
      if (v3)
      {
        for (i = *v3; i != v3[1]; i += 216)
        {
          v5 = sub_1D3DE78D8((unint64_t *)(i + 8));
          v3 = v2[7];
          if ((v5 & 1) == 0)
          {
            while (i != *v3)
            {
              if ((sub_1D3DE7874((unint64_t *)(i - 208)) & 1) == 0)
                _os_assumes_log();
              i -= 216;
              v3 = v2[7];
            }
            if ((sub_1D3DE7874(*v2) & 1) == 0)
              _os_assumes_log();
            goto LABEL_14;
          }
        }
      }
    }
    else
    {
LABEL_14:
      _os_assumes_log();
    }
  }
  return a1;
}

unint64_t *sub_1D3D74EDC(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

unint64_t *sub_1D3D74F14(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

void sub_1D3D74F50()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D74F64(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E95AC8D8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 sub_1D3D74FA4(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AC8D8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *sub_1D3D74FCC(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, uint64_t *a6)
{
  int v9;
  uint64_t v10;
  dispatch_group_t **v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  __int128 v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *result;
  uint64_t v21;
  int v22;
  _BYTE v23[24];
  _BYTE *v24;
  _BYTE v25[24];
  _BYTE *v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[24];
  _BYTE *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  sub_1D3D75260((uint64_t)v23, a2);
  v9 = *a5;
  v10 = *a6;
  v22 = v9;
  v11 = (dispatch_group_t **)a1[3];
  sub_1D3D75260((uint64_t)v25, (uint64_t)v23);
  v12 = a1[1];
  v13 = a1[2];
  *(_QWORD *)&v27 = v10;
  *((_QWORD *)&v27 + 1) = v12;
  *(_QWORD *)&v28 = &v22;
  *((_QWORD *)&v28 + 1) = v13;
  v30 = 0;
  v14 = (char *)operator new(0x48uLL);
  *(_QWORD *)v14 = &off_1E95ACA90;
  sub_1D3D75260((uint64_t)(v14 + 8), (uint64_t)v25);
  v15 = v28;
  *(_OWORD *)(v14 + 40) = v27;
  *(_OWORD *)(v14 + 56) = v15;
  v30 = v14;
  sub_1D3D752C4(v11, (uint64_t)v29);
  v16 = v30;
  if (v30 == v29)
  {
    v17 = 4;
    v16 = v29;
  }
  else
  {
    if (!v30)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_6:
  v18 = v26;
  if (v26 == v25)
  {
    v19 = 4;
    v18 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_11:
  result = v24;
  if (v24 == v23)
  {
    v21 = 4;
    result = v23;
  }
  else
  {
    if (!v24)
      return result;
    v21 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v21))();
}

void sub_1D3D75138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;

  v20 = *(_QWORD **)(v18 - 48);
  if (v20 == v17)
  {
    v21 = 4;
    v20 = (_QWORD *)(v18 - 72);
  }
  else
  {
    if (!v20)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_6:
  v22 = a17;
  if (a17 == &a14)
  {
    v23 = 4;
    v22 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_11;
    v23 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v22 + 8 * v23))();
LABEL_11:
  v24 = a13;
  if (a13 == &a10)
  {
    v25 = 4;
    v24 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_16;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D751D8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_7"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D75210()
{
  return &unk_1E95ABDC8;
}

BOOL sub_1D3D7521C(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
    return 1;
  if ((a2 & a1) < 0 != __OFSUB__(a1, a2))
    return strcmp((const char *)(a1 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(a2 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t sub_1D3D75260(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

_QWORD *sub_1D3D752C4(dispatch_group_t **a1, uint64_t a2)
{
  unint64_t *v3;
  const void *v5;
  CFTypeID v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  CFTypeID v11;
  uint64_t v12;
  _QWORD *result;
  dispatch_qos_class_t v14;
  unsigned int v15;
  unint64_t v16;
  BOOL v17;
  int v18;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  dispatch_block_t v23;
  const void *v24;
  uint64_t v25;
  _BYTE v26[24];
  _BYTE *v27;
  dispatch_group_t *v28;
  _BYTE v29[24];
  _BYTE *v30;
  _QWORD v31[3];
  _QWORD *v32;
  _QWORD block[4];
  _BYTE v34[24];
  _BYTE *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v3 = (unint64_t *)*a1;
  if (!BYTE2((*a1)[1][8].isa))
  {
    v10 = (_QWORD *)atomic_load(v3);
    if (v10)
    {
      v11 = CFGetTypeID(v10);
      if (qword_1EDB893E0 != -1)
        dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
      if (v11 != qword_1EDB893D8)
        _os_assumes_log();
    }
    v12 = v10[2];
    sub_1D3D756E8((uint64_t)v31, a2);
    result = v32;
    if (!v32)
    {
LABEL_41:
      if (result == v31)
      {
        v22 = 4;
        result = v31;
        return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v22))();
      }
      goto LABEL_42;
    }
    v14 = *(_DWORD *)(v12 + 24);
    HIDWORD(v16) = v14 - 9;
    LODWORD(v16) = v14 - 9;
    v15 = v16 >> 2;
    v17 = v15 > 6;
    v18 = (1 << v15) & 0x5D;
    if (v17 || v18 == 0)
    {
      (*(void (**)(void))(*v32 + 48))();
      goto LABEL_40;
    }
    if ((*(_DWORD *)(v12 + 28) & (*(int *)(v12 + 28) >> 31)) <= -15)
      v20 = -15;
    else
      v20 = *(_DWORD *)(v12 + 28) & (*(int *)(v12 + 28) >> 31);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 1174405120;
    block[2] = sub_1D3E23DDC;
    block[3] = &unk_1E95B3B28;
    v21 = v34;
    if (v32 == v31)
    {
      v35 = v34;
      (*(void (**)(_QWORD *, _BYTE *))(v31[0] + 24))(v31, v34);
    }
    else
    {
      v35 = (_BYTE *)(*(uint64_t (**)(void))(*v32 + 16))();
    }
    v23 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v14, v20, block);
    if (v23)
    {
      v24 = v23;
      (*((void (**)(void))v23 + 2))();
      _Block_release(v24);
    }
    else
    {
      if (!v32)
        sub_1D3D75A24();
      (*(void (**)(_QWORD *))(*v32 + 48))(v32);
    }
    if (v35 == v34)
    {
      v25 = 4;
    }
    else
    {
      if (!v35)
      {
LABEL_40:
        result = v32;
        goto LABEL_41;
      }
      v25 = 5;
      v21 = v35;
    }
    (*(void (**)(_QWORD *))(*v21 + 8 * v25))(v21);
    goto LABEL_40;
  }
  dispatch_group_enter(*a1[1]);
  v5 = (const void *)atomic_load(v3);
  if (v5)
  {
    v6 = CFGetTypeID(v5);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v6 != qword_1EDB893D8)
      _os_assumes_log();
  }
  sub_1D3D7574C((uint64_t)v26, a2);
  v28 = a1[1];
  v30 = 0;
  v7 = operator new(0x30uLL);
  *v7 = &off_1E95ACAE8;
  sub_1D3D756E8((uint64_t)(v7 + 1), (uint64_t)v26);
  v7[5] = v28;
  v30 = v7;
  sub_1D3E23840((uint64_t)v5 + 16, 1, (uint64_t)v29);
  v8 = v30;
  if (v30 == v29)
  {
    v9 = 4;
    v8 = v29;
  }
  else
  {
    if (!v30)
      goto LABEL_27;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_27:
  result = v27;
  if (v27 == v26)
  {
    v22 = 4;
    result = v26;
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v22))();
  }
LABEL_42:
  if (!result)
    return result;
  v22 = 5;
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v22))();
}

void sub_1D3D75614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  char *v30;
  uint64_t v31;

  v30 = a21;
  if (a21 == &a18)
  {
    v31 = 4;
    v30 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D756E8(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t sub_1D3D7574C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

_QWORD *sub_1D3D757B0(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E95ACAE8;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1D3D7580C(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E95ACAE8;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D75878(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = a1 + 8;
  v3 = operator new(0x30uLL);
  *v3 = &off_1E95ACAE8;
  sub_1D3D7574C((uint64_t)(v3 + 1), v2);
  v3[5] = *(_QWORD *)(a1 + 40);
  return v3;
}

void sub_1D3D758CC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D758E0(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  *a2 = &off_1E95ACAE8;
  result = sub_1D3D7574C((uint64_t)(a2 + 1), a1 + 8);
  a2[5] = *(_QWORD *)(a1 + 40);
  return result;
}

_QWORD *sub_1D3D75920(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1D3D75954(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

void sub_1D3D759A4(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    sub_1D3D75A24();
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  dispatch_group_leave(**(dispatch_group_t **)(a1 + 40));
}

uint64_t sub_1D3D759E0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK4$_10clENS9_8functionIFvvEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D75A18()
{
  return &unk_1E95ABE28;
}

void sub_1D3D75A24()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = &off_1E95B0240;
  __cxa_throw(exception, (struct type_info *)&unk_1E95AE9A0, (void (*)(void *))std::exception::~exception);
}

void sub_1D3D75A58(std::exception *a1)
{
  std::exception::~exception(a1);
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D75A7C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E95ACA90;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1D3D75AD8(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E95ACA90;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D8254C54);
}

char *sub_1D3D75B44(uint64_t a1)
{
  uint64_t v2;
  char *v3;

  v2 = a1 + 8;
  v3 = (char *)operator new(0x48uLL);
  *(_QWORD *)v3 = &off_1E95ACA90;
  sub_1D3D7574C((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v3 + 56) = *(_OWORD *)(a1 + 56);
  return v3;
}

void sub_1D3D75BA0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1D3D75BB4(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95ACA90;
  sub_1D3D7574C(a2 + 8, a1 + 8);
  result = *(__n128 *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

_QWORD *sub_1D3D75BFC(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1D3D75C30(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

uint64_t sub_1D3D75C80(uint64_t result)
{
  unint64_t **v1;
  unint64_t *v2;
  unint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21[4];
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;

  v1 = *(unint64_t ***)(result + 48);
  v2 = *v1;
  v3 = v1[1];
  if (*v1 != v3)
  {
    v4 = result;
    do
    {
      v5 = atomic_load(v2);
      result = sub_1D3D91948((unint64_t *)(v5 + 136), **(_DWORD **)(v4 + 56));
      if ((_DWORD)result)
      {
        v6 = *(_QWORD **)(v4 + 64);
        v7 = *(_QWORD *)(v4 + 40);
        v8 = (unint64_t *)(*v6 + (v7 << 6));
        if (!atomic_load(v8))
        {
          v21[0] = (unint64_t)sub_1D3D73E50();
          do
            v10 = __ldaxr(v21);
          while (__stlxr(0, v21));
          do
            v11 = (const void *)__ldaxr(v8);
          while (__stlxr(v10, v8));
          if (v11)
            CFRelease(v11);
          sub_1D3D74DE4(v21);
        }
        v12 = v6[1];
        v13 = v6[2];
        v14 = atomic_load(v8);
        v15 = v6[3] + (v7 << 6);
        v16 = *(_QWORD *)(v12 + 8);
        v17 = *(_QWORD *)v12 + 16;
        v18 = *(uint64_t **)(v12 + 16);
        v19 = **(_QWORD **)(v12 + 24);
        v21[0] = v14 + 16;
        v21[1] = v17;
        v21[2] = v16;
        v21[3] = v5 + 16;
        v22 = 1;
        v23 = v13 + (v7 << 7);
        v24 = *v18;
        v25 = 1;
        v26 = v15;
        v27 = v19;
        v20 = *(_QWORD *)(v4 + 32);
        if (!v20)
          sub_1D3D75A24();
        result = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)v20 + 48))(v20, v21);
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_1D3D75DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  sub_1D3D74DE4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D75DC4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_7clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D75DFC()
{
  return &unk_1E95ABE18;
}

uint64_t sub_1D3D75E08(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = a2[1];
  v7 = sub_1D3D75F5C(a3, a3, *a1, *a1, v6, v6);
  a2[1] = v7;
  v8 = a1[1];
  v9 = a2[2];
  if (v8 != a3)
  {
    v10 = 0;
    do
    {
      v11 = (CFTypeRef)atomic_load((unint64_t *)(a3 + v10));
      if (v11)
        v11 = CFRetain(v11);
      *(_QWORD *)(v9 + v10) = v11;
      v10 += 8;
    }
    while (a3 + v10 != v8);
    v9 += v10;
    v7 = a2[1];
  }
  a2[2] = v9;
  v12 = *a1;
  *a1 = v7;
  a2[1] = v12;
  v13 = a1[1];
  a1[1] = a2[2];
  a2[2] = v13;
  v14 = a1[2];
  a1[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_1D3D75F10(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    sub_1D3D74F14((unint64_t *)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1D3D75F5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  CFTypeRef v10;

  if (a2 != a4)
  {
    v9 = 0;
    do
    {
      v10 = (CFTypeRef)atomic_load((unint64_t *)(a2 + v9 - 8));
      if (v10)
        v10 = CFRetain(v10);
      *(_QWORD *)(a6 + v9 - 8) = v10;
      v9 -= 8;
    }
    while (a2 + v9 != a4);
    a6 += v9;
  }
  return a6;
}

void sub_1D3D75FF8()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D7600C(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95AC880;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3D76044(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AC880;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *sub_1D3D76064(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v8;
  dispatch_group_t **v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *result;
  uint64_t v17;
  _BYTE v18[24];
  _BYTE *v19;
  _BYTE v20[24];
  _BYTE *v21;
  __int128 v22;
  _BYTE v23[24];
  _BYTE *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  sub_1D3D75260((uint64_t)v18, a2);
  v8 = *a6;
  v9 = *(dispatch_group_t ***)(a1 + 16);
  sub_1D3D75260((uint64_t)v20, (uint64_t)v18);
  v10 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)&v22 = v8;
  *((_QWORD *)&v22 + 1) = v10;
  v24 = 0;
  v11 = (char *)operator new(0x38uLL);
  *(_QWORD *)v11 = &off_1E95ACA38;
  sub_1D3D75260((uint64_t)(v11 + 8), (uint64_t)v20);
  *(_OWORD *)(v11 + 40) = v22;
  v24 = v11;
  sub_1D3D752C4(v9, (uint64_t)v23);
  v12 = v24;
  if (v24 == v23)
  {
    v13 = 4;
    v12 = v23;
  }
  else
  {
    if (!v24)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  v14 = v21;
  if (v21 == v20)
  {
    v15 = 4;
    v14 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_11;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v17 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v17 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v17))();
}

void sub_1D3D761B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;

  v20 = *(_QWORD **)(v18 - 48);
  if (v20 == v17)
  {
    v21 = 4;
    v20 = (_QWORD *)(v18 - 72);
  }
  else
  {
    if (!v20)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_6:
  v22 = a17;
  if (a17 == &a14)
  {
    v23 = 4;
    v22 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_11;
    v23 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v22 + 8 * v23))();
LABEL_11:
  v24 = a13;
  if (a13 == &a10)
  {
    v25 = 4;
    v24 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_16;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D76254(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_6"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D7628C()
{
  return &unk_1E95ABDB8;
}

_QWORD *sub_1D3D76298(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E95ACA38;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1D3D762F4(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E95ACA38;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D8254C54);
}

char *sub_1D3D76360(uint64_t a1)
{
  uint64_t v2;
  char *v3;

  v2 = a1 + 8;
  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)v3 = &off_1E95ACA38;
  sub_1D3D7574C((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  return v3;
}

void sub_1D3D763B4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1D3D763C8(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95ACA38;
  sub_1D3D7574C(a2 + 8, a1 + 8);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

_QWORD *sub_1D3D76408(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1D3D7643C(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

uint64_t sub_1D3D7648C(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v18[3];
  char v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;

  v3 = a1[5];
  v2 = (_QWORD *)a1[6];
  v4 = (unint64_t *)(*v2 + (v3 << 6));
  if (!atomic_load(v4))
  {
    v18[0] = (unint64_t)sub_1D3D73E50();
    do
      v6 = __ldaxr(v18);
    while (__stlxr(0, v18));
    do
      v7 = (const void *)__ldaxr(v4);
    while (__stlxr(v6, v4));
    if (v7)
      CFRelease(v7);
    sub_1D3D74DE4(v18);
  }
  v8 = v2[1];
  v9 = v2[2];
  v10 = atomic_load(v4);
  v11 = v2[3] + (v3 << 6);
  v12 = *(_QWORD *)(v8 + 8);
  v13 = *(_QWORD *)v8 + 16;
  v14 = *(uint64_t **)(v8 + 16);
  v15 = **(_QWORD **)(v8 + 24);
  v18[0] = v10 + 16;
  v18[1] = v13;
  v18[2] = v12;
  v19 = 0;
  v20 = 0;
  v21 = v9 + (v3 << 7);
  v22 = *v14;
  v23 = 1;
  v24 = v11;
  v25 = v15;
  v16 = a1[4];
  if (!v16)
    sub_1D3D75A24();
  return (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)v16 + 48))(v16, v18);
}

void sub_1D3D7656C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  sub_1D3D74DE4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D76580(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_6clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D765B8()
{
  return &unk_1E95ABE08;
}

void sub_1D3D765C8()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D765DC(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x38uLL);
  *(_QWORD *)v2 = &off_1E95AC828;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 sub_1D3D76624(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E95AC828;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *sub_1D3D76654(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v9;
  dispatch_group_t **v10;
  __int128 v11;
  char *v12;
  __int128 v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *result;
  uint64_t v19;
  _BYTE v20[24];
  _BYTE *v21;
  _BYTE v22[24];
  _BYTE *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  sub_1D3D75260((uint64_t)v20, a2);
  LODWORD(a5) = *a5;
  v9 = *a6;
  v10 = *(dispatch_group_t ***)(a1 + 48);
  sub_1D3D75260((uint64_t)v22, (uint64_t)v20);
  LODWORD(v24) = (_DWORD)a5;
  *((_QWORD *)&v24 + 1) = v9;
  v11 = *(_OWORD *)(a1 + 24);
  v25 = *(_OWORD *)(a1 + 8);
  v26 = v11;
  v27 = *(_QWORD *)(a1 + 40);
  v29 = 0;
  v12 = (char *)operator new(0x60uLL);
  *(_QWORD *)v12 = &off_1E95AC9E0;
  sub_1D3D75260((uint64_t)(v12 + 8), (uint64_t)v22);
  v13 = v25;
  *(_OWORD *)(v12 + 40) = v24;
  *(_OWORD *)(v12 + 56) = v13;
  *(_OWORD *)(v12 + 72) = v26;
  *((_QWORD *)v12 + 11) = v27;
  v29 = v12;
  sub_1D3D752C4(v10, (uint64_t)v28);
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_6:
  v16 = v23;
  if (v23 == v22)
  {
    v17 = 4;
    v16 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  result = v21;
  if (v21 == v20)
  {
    v19 = 4;
    result = v20;
  }
  else
  {
    if (!v21)
      return result;
    v19 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v19))();
}

void sub_1D3D767E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, char a13, uint64_t a14, uint64_t a15, char *a16)
{
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;

  v19 = *(_QWORD **)(v17 - 64);
  if (v19 == v16)
  {
    v20 = 4;
    v19 = (_QWORD *)(v17 - 88);
  }
  else
  {
    if (!v19)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_6:
  v21 = a16;
  if (a16 == &a13)
  {
    v22 = 4;
    v21 = &a13;
  }
  else
  {
    if (!a16)
      goto LABEL_11;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_11:
  v23 = a12;
  if (a12 == &a9)
  {
    v24 = 4;
    v23 = &a9;
  }
  else
  {
    if (!a12)
      goto LABEL_16;
    v24 = 5;
  }
  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D76880(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_5"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D768B8()
{
  return &unk_1E95ABDA8;
}

_QWORD *sub_1D3D768C4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E95AC9E0;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1D3D76920(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E95AC9E0;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D8254C54);
}

char *sub_1D3D7698C(uint64_t a1)
{
  uint64_t v2;
  char *v3;

  v2 = a1 + 8;
  v3 = (char *)operator new(0x60uLL);
  *(_QWORD *)v3 = &off_1E95AC9E0;
  sub_1D3D7574C((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v3 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v3 + 72) = *(_OWORD *)(a1 + 72);
  *((_QWORD *)v3 + 11) = *(_QWORD *)(a1 + 88);
  return v3;
}

void sub_1D3D769F8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1D3D76A0C(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v5;
  __int128 v6;

  *(_QWORD *)a2 = &off_1E95AC9E0;
  sub_1D3D7574C(a2 + 8, a1 + 8);
  result = *(__n128 *)(a1 + 40);
  v5 = *(_OWORD *)(a1 + 56);
  v6 = *(_OWORD *)(a1 + 72);
  *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v6;
  *(_OWORD *)(a2 + 56) = v5;
  *(__n128 *)(a2 + 40) = result;
  return result;
}

_QWORD *sub_1D3D76A64(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1D3D76A98(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

void sub_1D3D76AE8(uint64_t a1)
{
  uint64_t v1;
  uint64_t i;
  unsigned __int8 v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36[4];
  char v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  uint64_t v42;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  if (v1)
  {
    for (i = 0; i != v1; ++i)
    {
      v4 = atomic_load((unsigned __int8 *)(**(_QWORD **)(a1 + 64) + (i << 6)));
      if ((v4 & 1) == 0)
      {
        v5 = (unint64_t *)(**(_QWORD **)(a1 + 56) + 8 * i);
        v6 = atomic_load(v5);
        if (sub_1D3D91948((unint64_t *)(v6 + 136), *(_DWORD *)(a1 + 40)))
        {
          v7 = *(_QWORD **)(a1 + 72);
          v8 = atomic_load(v5);
          v9 = *(_QWORD *)(a1 + 48);
          v10 = (unint64_t *)(*v7 + (v9 << 6));
          if (!atomic_load(v10))
          {
            v36[0] = (unint64_t)sub_1D3D73E50();
            do
              v12 = __ldaxr(v36);
            while (__stlxr(0, v36));
            do
              v13 = (const void *)__ldaxr(v10);
            while (__stlxr(v12, v10));
            if (v13)
              CFRelease(v13);
            sub_1D3D74DE4(v36);
          }
          v14 = v7[1];
          v15 = v7[2];
          v16 = atomic_load(v10);
          v17 = v7[3] + (v9 << 6);
          v18 = *(_QWORD *)(v14 + 8);
          v19 = *(_QWORD *)v14 + 16;
          v20 = *(uint64_t **)(v14 + 16);
          v21 = **(_QWORD **)(v14 + 24);
          v36[0] = v16 + 16;
          v36[1] = v19;
          v36[2] = v18;
          v36[3] = v8 + 16;
          v37 = 1;
          v38 = v15 + (v9 << 7);
          v39 = *v20;
          v40 = 1;
          v41 = v17;
          v42 = v21;
          v22 = *(_QWORD *)(a1 + 32);
          if (!v22)
            sub_1D3D75A24();
          (*(void (**)(uint64_t, unint64_t *))(*(_QWORD *)v22 + 48))(v22, v36);
          v23 = (_BYTE *)(*(_QWORD *)(a1 + 80) + (*(_QWORD *)(a1 + 48) << 6));
          if (v23[1] && *v23)
          {
            atomic_store(1u, (unsigned __int8 *)(**(_QWORD **)(a1 + 64) + (i << 6)));
            v24 = *(_QWORD *)(a1 + 88) + (*(_QWORD *)(a1 + 48) << 6);
            v26 = *(_QWORD **)(v24 + 8);
            v25 = *(_QWORD *)(v24 + 16);
            if ((unint64_t)v26 >= v25)
            {
              v28 = *(_QWORD **)v24;
              v29 = ((uint64_t)v26 - *(_QWORD *)v24) >> 3;
              v30 = v29 + 1;
              if ((unint64_t)(v29 + 1) >> 61)
                sub_1D3D6D4F8();
              v31 = v25 - (_QWORD)v28;
              if (v31 >> 2 > v30)
                v30 = v31 >> 2;
              if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8)
                v32 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v32 = v30;
              if (v32)
              {
                v32 = (unint64_t)sub_1D3D6D8A0(v32);
                v28 = *(_QWORD **)v24;
                v26 = *(_QWORD **)(v24 + 8);
              }
              else
              {
                v33 = 0;
              }
              v34 = (_QWORD *)(v32 + 8 * v29);
              *v34 = i;
              v27 = v34 + 1;
              while (v26 != v28)
              {
                v35 = *--v26;
                *--v34 = v35;
              }
              *(_QWORD *)v24 = v34;
              *(_QWORD *)(v24 + 8) = v27;
              *(_QWORD *)(v24 + 16) = v32 + 8 * v33;
              if (v28)
                operator delete(v28);
            }
            else
            {
              *v26 = i;
              v27 = v26 + 1;
            }
            *(_QWORD *)(v24 + 8) = v27;
          }
        }
      }
    }
  }
}

void sub_1D3D76D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  sub_1D3D74DE4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D76D2C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_5clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D76D64()
{
  return &unk_1E95ABDF8;
}

double sub_1D3D76D70(uint64_t a1, unint64_t a2, uint64_t a3, char a4, double result)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __int128 *v15;
  __int128 *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  BOOL v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  BOOL v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  _BOOL4 v35;
  _BOOL4 v36;
  unint64_t v37;
  int v38;
  BOOL v39;
  BOOL v40;
  unint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  int v46;
  int v47;
  BOOL v48;
  BOOL v49;
  int v50;
  int v51;
  _BOOL4 v52;
  _BOOL4 v53;
  BOOL v54;
  __int128 v55;
  uint64_t v56;
  int v57;
  BOOL v58;
  unint64_t v59;
  int v60;
  BOOL v61;
  BOOL v62;
  unint64_t v63;
  int v64;
  _BOOL4 v65;
  _BOOL4 v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  BOOL v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  int v77;
  int v78;
  _BOOL4 v79;
  _BOOL4 v80;
  int v81;
  int v82;
  BOOL v83;
  BOOL v84;
  int v85;
  int v86;
  _BOOL4 v87;
  uint64_t v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;
  char *v92;
  BOOL v93;
  char v94;
  uint64_t v95;
  _OWORD *v96;
  _OWORD *v97;
  int v98;
  int v99;
  int v100;
  _BOOL4 v101;
  __int128 v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  BOOL v109;
  BOOL v110;
  unint64_t v111;
  _OWORD *v112;
  int64_t v113;
  int64_t v114;
  int64_t v115;
  uint64_t v116;
  unint64_t v117;
  int v118;
  int v119;
  _BOOL4 v120;
  unint64_t v121;
  int v122;
  int v123;
  int v124;
  BOOL v125;
  __int128 v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  int v133;
  _BOOL4 v134;
  int v135;
  _BOOL4 v136;
  _BOOL4 v137;
  int64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  int v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  int v153;
  _BOOL4 v154;
  __int128 *v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  int v159;
  int v160;
  int v161;
  _BOOL4 v162;
  __int128 v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  BOOL v168;
  _QWORD *v170;
  _OWORD *v171;
  int v172;
  int v173;
  int v174;
  _BOOL4 v175;
  __int128 v176;
  uint64_t v177;
  uint64_t v178;
  _QWORD *v179;
  _QWORD *v180;
  uint64_t v181;
  int v182;
  BOOL v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;

LABEL_1:
  v9 = a1;
  while (2)
  {
    a1 = v9;
    v10 = a2 - v9;
    v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a2 - v9) >> 3);
    switch(v11)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v85 = *(_DWORD *)(a2 - 16);
        v86 = *(_DWORD *)(v9 + 40);
        v93 = v85 == v86;
        v87 = v85 > v86;
        if (v93)
          v87 = *(_DWORD *)(a2 - 12) < *(_DWORD *)(v9 + 44);
        if (v87)
        {
          v88 = *(_QWORD *)(v9 + 16);
          v89 = *(_OWORD *)v9;
          *(_OWORD *)v9 = *(_OWORD *)(a2 - 56);
          *(_QWORD *)(v9 + 16) = *(_QWORD *)(a2 - 40);
          *(_OWORD *)(a2 - 56) = v89;
          *(_QWORD *)(a2 - 40) = v88;
          v90 = *(_OWORD *)(v9 + 24);
          *(_OWORD *)(v9 + 24) = *(_OWORD *)(a2 - 32);
          *(_OWORD *)(a2 - 32) = v90;
          result = *(double *)(a2 - 16);
          *(_QWORD *)&v89 = *(_QWORD *)(v9 + 40);
          *(double *)(v9 + 40) = result;
          *(_QWORD *)(a2 - 16) = v89;
          v91 = *(_QWORD *)(v9 + 48);
          *(_QWORD *)(v9 + 48) = *(_QWORD *)(a2 - 8);
          *(_QWORD *)(a2 - 8) = v91;
        }
        return result;
      case 3:
        sub_1D3D77A44((__int128 *)v9, (__int128 *)(v9 + 56), (__int128 *)(a2 - 56));
        return result;
      case 4:
        return sub_1D3D77C6C(v9, v9 + 56, v9 + 112, a2 - 56);
      case 5:
        return sub_1D3D77E0C(v9, v9 + 56, v9 + 112, v9 + 168, a2 - 56);
      default:
        if (v10 <= 1343)
        {
          v92 = (char *)(v9 + 56);
          v93 = v9 == a2 || v92 == (char *)a2;
          v94 = v93;
          if ((a4 & 1) != 0)
          {
            if ((v94 & 1) == 0)
            {
              v95 = 0;
              v96 = (_OWORD *)v9;
              do
              {
                v97 = v92;
                v98 = *((_DWORD *)v96 + 24);
                v99 = *((_DWORD *)v96 + 25);
                v100 = *((_DWORD *)v96 + 10);
                v93 = v98 == v100;
                v101 = v98 > v100;
                if (v93)
                  v101 = v99 < *((_DWORD *)v96 + 11);
                if (v101)
                {
                  v102 = *v97;
                  v103 = *((_QWORD *)v96 + 9);
                  v187 = v96[5];
                  v104 = *((_QWORD *)v96 + 13);
                  v105 = v95;
                  while (1)
                  {
                    v106 = v105;
                    v107 = v9 + v105;
                    *(_OWORD *)(v107 + 56) = *(_OWORD *)v107;
                    *(_QWORD *)(v107 + 72) = *(_QWORD *)(v107 + 16);
                    *(_OWORD *)(v107 + 80) = *(_OWORD *)(v107 + 24);
                    *(_QWORD *)(v107 + 96) = *(_QWORD *)(v107 + 40);
                    *(_QWORD *)(v107 + 104) = *(_QWORD *)(v107 + 48);
                    if (!v106)
                      break;
                    v108 = *(_DWORD *)(v107 - 16);
                    v109 = v99 < *(_DWORD *)(v107 - 12);
                    v93 = v98 == v108;
                    v110 = v98 > v108;
                    if (v93)
                      v110 = v109;
                    v105 = v106 - 56;
                    if (!v110)
                    {
                      v111 = v9 + v106;
                      v112 = (_OWORD *)(v9 + v106 + 24);
                      goto LABEL_106;
                    }
                  }
                  v112 = (_OWORD *)(v107 + 24);
                  v111 = v9;
LABEL_106:
                  *(_OWORD *)v111 = v102;
                  *(_QWORD *)(v111 + 16) = v103;
                  result = *(double *)&v187;
                  *v112 = v187;
                  *(_DWORD *)(v111 + 40) = v98;
                  *(_DWORD *)(v111 + 44) = v99;
                  *(_QWORD *)(v111 + 48) = v104;
                }
                v92 = (char *)v97 + 56;
                v95 += 56;
                v96 = v97;
              }
              while ((_OWORD *)((char *)v97 + 56) != (_OWORD *)a2);
            }
          }
          else if ((v94 & 1) == 0)
          {
            v170 = (_QWORD *)(v9 + 104);
            do
            {
              v171 = v92;
              v172 = *(_DWORD *)(a1 + 96);
              v173 = *(_DWORD *)(a1 + 100);
              v174 = *(_DWORD *)(a1 + 40);
              v93 = v172 == v174;
              v175 = v172 > v174;
              if (v93)
                v175 = v173 < *(_DWORD *)(a1 + 44);
              if (v175)
              {
                v176 = *v171;
                v177 = *(_QWORD *)(a1 + 72);
                v190 = *(_OWORD *)(a1 + 80);
                v178 = *(_QWORD *)(a1 + 104);
                v179 = v170;
                do
                {
                  v180 = v179;
                  *((_OWORD *)v179 - 3) = *(_OWORD *)(v179 - 13);
                  *(v179 - 4) = *(v179 - 11);
                  *(_OWORD *)(v179 - 3) = *((_OWORD *)v179 - 5);
                  *(v179 - 1) = *(v179 - 8);
                  v181 = *(v179 - 7);
                  v179 -= 7;
                  *v180 = v181;
                  v182 = *((_DWORD *)v180 - 30);
                  v93 = v172 == v182;
                  v183 = v172 > v182;
                  if (v93)
                    v183 = v173 < *((_DWORD *)v180 - 29);
                }
                while (v183);
                *((_OWORD *)v179 - 3) = v176;
                *(v179 - 4) = v177;
                result = *(double *)&v190;
                *((_OWORD *)v180 - 5) = v190;
                *((_DWORD *)v179 - 2) = v172;
                *((_DWORD *)v179 - 1) = v173;
                *v179 = v178;
              }
              v92 = (char *)v171 + 56;
              v170 += 7;
              a1 = (uint64_t)v171;
            }
            while ((_OWORD *)((char *)v171 + 56) != (_OWORD *)a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v9 != a2)
          {
            v113 = (unint64_t)(v11 - 2) >> 1;
            v114 = v113;
            do
            {
              v115 = v114;
              if (v113 >= v114)
              {
                v116 = (2 * v114) | 1;
                v117 = v9 + 56 * v116;
                if (2 * v115 + 2 < v11)
                {
                  v118 = *(_DWORD *)(v117 + 40);
                  v119 = *(_DWORD *)(v117 + 96);
                  v93 = v118 == v119;
                  v120 = v118 > v119;
                  if (v93)
                    v120 = *(_DWORD *)(v117 + 44) < *(_DWORD *)(v117 + 100);
                  v117 += 56 * v120;
                  if (v120)
                    v116 = 2 * v115 + 2;
                }
                v121 = v9 + 56 * v115;
                v122 = *(_DWORD *)(v117 + 40);
                v124 = *(_DWORD *)(v121 + 40);
                v123 = *(_DWORD *)(v121 + 44);
                v93 = v122 == v124;
                v125 = v122 > v124;
                if (v93)
                  v125 = *(_DWORD *)(v117 + 44) < v123;
                if (!v125)
                {
                  v126 = *(_OWORD *)v121;
                  v127 = *(_QWORD *)(v121 + 16);
                  v188 = *(_OWORD *)(v121 + 24);
                  v128 = *(_QWORD *)(v121 + 48);
                  do
                  {
                    v129 = v121;
                    v121 = v117;
                    *(_OWORD *)v129 = *(_OWORD *)v117;
                    *(_QWORD *)(v129 + 16) = *(_QWORD *)(v117 + 16);
                    *(_OWORD *)(v129 + 24) = *(_OWORD *)(v117 + 24);
                    *(_QWORD *)(v129 + 40) = *(_QWORD *)(v117 + 40);
                    *(_QWORD *)(v129 + 48) = *(_QWORD *)(v117 + 48);
                    if (v113 < v116)
                      break;
                    v130 = (2 * v116) | 1;
                    v117 = v9 + 56 * v130;
                    v131 = 2 * v116 + 2;
                    if (v131 < v11)
                    {
                      v132 = *(_DWORD *)(v117 + 40);
                      v133 = *(_DWORD *)(v117 + 96);
                      v93 = v132 == v133;
                      v134 = v132 > v133;
                      if (v93)
                        v134 = *(_DWORD *)(v117 + 44) < *(_DWORD *)(v117 + 100);
                      v117 += 56 * v134;
                      if (v134)
                        v130 = v131;
                    }
                    v135 = *(_DWORD *)(v117 + 40);
                    v136 = *(_DWORD *)(v117 + 44) < v123;
                    v93 = v135 == v124;
                    v137 = v135 > v124;
                    if (!v93)
                      v136 = v137;
                    v116 = v130;
                  }
                  while (!v136);
                  *(_OWORD *)v121 = v126;
                  *(_QWORD *)(v121 + 16) = v127;
                  *(_OWORD *)(v121 + 24) = v188;
                  *(_DWORD *)(v121 + 40) = v124;
                  *(_DWORD *)(v121 + 44) = v123;
                  *(_QWORD *)(v121 + 48) = v128;
                }
              }
              v114 = v115 - 1;
            }
            while (v115);
            v138 = v10 / 0x38uLL;
            do
            {
              v139 = 0;
              v140 = *(_QWORD *)v9;
              v141 = *(_QWORD *)(v9 + 8);
              v142 = *(_QWORD *)(v9 + 16);
              v184 = *(_OWORD *)(v9 + 24);
              v143 = *(_DWORD *)(v9 + 40);
              v144 = *(_DWORD *)(v9 + 44);
              v145 = *(_QWORD *)(v9 + 48);
              v146 = v138 - 2;
              if (v138 < 2)
                v146 = v138 - 1;
              v147 = v146 >> 1;
              v148 = v9;
              do
              {
                v149 = v148 + 56 * v139 + 56;
                v150 = (2 * v139) | 1;
                v151 = 2 * v139 + 2;
                if (v151 < v138)
                {
                  v152 = *(_DWORD *)(v149 + 40);
                  v153 = *(_DWORD *)(v149 + 96);
                  v93 = v152 == v153;
                  v154 = v152 > v153;
                  if (v93)
                    v154 = *(_DWORD *)(v149 + 44) < *(_DWORD *)(v149 + 100);
                  v149 += 56 * v154;
                  if (v154)
                    v150 = v151;
                }
                *(_OWORD *)v148 = *(_OWORD *)v149;
                *(_QWORD *)(v148 + 16) = *(_QWORD *)(v149 + 16);
                *(_OWORD *)(v148 + 24) = *(_OWORD *)(v149 + 24);
                *(_QWORD *)(v148 + 40) = *(_QWORD *)(v149 + 40);
                *(_QWORD *)(v148 + 48) = *(_QWORD *)(v149 + 48);
                v148 = v149;
                v139 = v150;
              }
              while (v150 <= v147);
              v155 = (__int128 *)(v149 + 24);
              if (v149 == a2 - 56)
              {
                *(_QWORD *)v149 = v140;
                *(_QWORD *)(v149 + 8) = v141;
                *(_QWORD *)(v149 + 16) = v142;
                result = *(double *)&v184;
                *v155 = v184;
                *(_DWORD *)(v149 + 40) = v143;
                *(_DWORD *)(v149 + 44) = v144;
                *(_QWORD *)(v149 + 48) = v145;
              }
              else
              {
                *(_OWORD *)v149 = *(_OWORD *)(a2 - 56);
                *(_QWORD *)(v149 + 16) = *(_QWORD *)(a2 - 40);
                *v155 = *(_OWORD *)(a2 - 32);
                *(_QWORD *)(v149 + 40) = *(_QWORD *)(a2 - 16);
                *(_QWORD *)(v149 + 48) = *(_QWORD *)(a2 - 8);
                *(_QWORD *)(a2 - 56) = v140;
                *(_QWORD *)(a2 - 48) = v141;
                *(_QWORD *)(a2 - 40) = v142;
                result = *(double *)&v184;
                *(_OWORD *)(a2 - 32) = v184;
                *(_DWORD *)(a2 - 16) = v143;
                *(_DWORD *)(a2 - 12) = v144;
                *(_QWORD *)(a2 - 8) = v145;
                v156 = v149 - v9 + 56;
                if (v156 >= 57)
                {
                  v157 = (unint64_t)(0x6DB6DB6DB6DB6DB7 * (v156 >> 3) - 2) >> 1;
                  v158 = v9 + 56 * v157;
                  v159 = *(_DWORD *)(v158 + 40);
                  v161 = *(_DWORD *)(v149 + 40);
                  v160 = *(_DWORD *)(v149 + 44);
                  v93 = v159 == v161;
                  v162 = v159 > v161;
                  if (v93)
                    v162 = *(_DWORD *)(v158 + 44) < v160;
                  if (v162)
                  {
                    v163 = *(_OWORD *)v149;
                    v164 = *(_QWORD *)(v149 + 16);
                    v189 = *v155;
                    v165 = *(_QWORD *)(v149 + 48);
                    do
                    {
                      v166 = v149;
                      v149 = v158;
                      *(_OWORD *)v166 = *(_OWORD *)v158;
                      *(_QWORD *)(v166 + 16) = *(_QWORD *)(v158 + 16);
                      *(_OWORD *)(v166 + 24) = *(_OWORD *)(v158 + 24);
                      *(_QWORD *)(v166 + 40) = *(_QWORD *)(v158 + 40);
                      *(_QWORD *)(v166 + 48) = *(_QWORD *)(v158 + 48);
                      if (!v157)
                        break;
                      v157 = (v157 - 1) >> 1;
                      v158 = v9 + 56 * v157;
                      v167 = *(_DWORD *)(v158 + 40);
                      v93 = v167 == v161;
                      v168 = v167 > v161;
                      if (v93)
                        v168 = *(_DWORD *)(v158 + 44) < v160;
                    }
                    while (v168);
                    *(_OWORD *)v149 = v163;
                    *(_QWORD *)(v149 + 16) = v164;
                    result = *(double *)&v189;
                    *(_OWORD *)(v149 + 24) = v189;
                    *(_DWORD *)(v149 + 40) = v161;
                    *(_DWORD *)(v149 + 44) = v160;
                    *(_QWORD *)(v149 + 48) = v165;
                  }
                }
              }
              a2 -= 56;
            }
            while (v138-- > 2);
          }
          return result;
        }
        v12 = (unint64_t)v11 >> 1;
        v13 = v9 + 56 * ((unint64_t)v11 >> 1);
        if ((unint64_t)v10 < 0x1C01)
        {
          sub_1D3D77A44((__int128 *)v13, (__int128 *)a1, (__int128 *)(a2 - 56));
        }
        else
        {
          sub_1D3D77A44((__int128 *)a1, (__int128 *)v13, (__int128 *)(a2 - 56));
          v14 = 56 * v12;
          v15 = (__int128 *)(56 * v12 + a1 - 56);
          sub_1D3D77A44((__int128 *)(a1 + 56), v15, (__int128 *)(a2 - 112));
          v16 = (__int128 *)(a1 + 56 + v14);
          sub_1D3D77A44((__int128 *)(a1 + 112), v16, (__int128 *)(a2 - 168));
          sub_1D3D77A44(v15, (__int128 *)v13, v16);
          v17 = *(_QWORD *)(a1 + 16);
          v18 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v13;
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(v13 + 16);
          *(_OWORD *)v13 = v18;
          *(_QWORD *)(v13 + 16) = v17;
          v19 = *(_OWORD *)(a1 + 24);
          *(_OWORD *)(a1 + 24) = *(_OWORD *)(v13 + 24);
          *(_OWORD *)(v13 + 24) = v19;
          *(_QWORD *)&v18 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(a1 + 40) = *(_QWORD *)(v13 + 40);
          *(_QWORD *)(v13 + 40) = v18;
          v20 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)(a1 + 48) = *(_QWORD *)(v13 + 48);
          *(_QWORD *)(v13 + 48) = v20;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v23 = *(_DWORD *)(a1 - 16);
          v21 = *(_DWORD *)(a1 + 40);
          v22 = *(_DWORD *)(a1 + 44);
          v93 = v23 == v21;
          v24 = v23 > v21;
          if (v93)
            v24 = *(_DWORD *)(a1 - 12) < v22;
          if (v24)
            goto LABEL_13;
          v55 = *(_OWORD *)a1;
          v56 = *(_QWORD *)(a1 + 16);
          v186 = *(_OWORD *)(a1 + 24);
          v57 = *(_DWORD *)(a2 - 16);
          v93 = v21 == v57;
          v58 = v21 > v57;
          if (v93)
            v58 = v22 < *(_DWORD *)(a2 - 12);
          if (v58)
          {
            v59 = a1;
            do
            {
              v9 = v59 + 56;
              v60 = *(_DWORD *)(v59 + 96);
              v61 = v22 < *(_DWORD *)(v59 + 100);
              v93 = v21 == v60;
              v62 = v21 > v60;
              if (v93)
                v62 = v61;
              v59 = v9;
            }
            while (!v62);
          }
          else
          {
            v63 = a1 + 56;
            do
            {
              v9 = v63;
              if (v63 >= a2)
                break;
              v64 = *(_DWORD *)(v63 + 40);
              v65 = v22 < *(_DWORD *)(v9 + 44);
              v93 = v21 == v64;
              v66 = v21 > v64;
              if (!v93)
                v65 = v66;
              v63 = v9 + 56;
            }
            while (!v65);
          }
          v67 = a2;
          if (v9 < a2)
          {
            v68 = a2;
            do
            {
              v67 = v68 - 56;
              v69 = *(_DWORD *)(v68 - 16);
              v70 = v22 < *(_DWORD *)(v68 - 12);
              v93 = v21 == v69;
              v71 = v21 > v69;
              if (v93)
                v71 = v70;
              v68 = v67;
            }
            while (v71);
          }
          v72 = *(_QWORD *)(a1 + 48);
          while (v9 < v67)
          {
            v73 = *(_QWORD *)(v9 + 16);
            v74 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v67;
            *(_QWORD *)(v9 + 16) = *(_QWORD *)(v67 + 16);
            *(_OWORD *)v67 = v74;
            *(_QWORD *)(v67 + 16) = v73;
            v75 = *(_OWORD *)(v9 + 24);
            *(_OWORD *)(v9 + 24) = *(_OWORD *)(v67 + 24);
            *(_OWORD *)(v67 + 24) = v75;
            *(_QWORD *)&v74 = *(_QWORD *)(v9 + 40);
            *(_QWORD *)(v9 + 40) = *(_QWORD *)(v67 + 40);
            *(_QWORD *)(v67 + 40) = v74;
            v76 = *(_QWORD *)(v9 + 48);
            *(_QWORD *)(v9 + 48) = *(_QWORD *)(v67 + 48);
            *(_QWORD *)(v67 + 48) = v76;
            do
            {
              v77 = *(_DWORD *)(v9 + 96);
              v78 = *(_DWORD *)(v9 + 100);
              v9 += 56;
              v79 = v22 < v78;
              v93 = v21 == v77;
              v80 = v21 > v77;
              if (v93)
                v80 = v79;
            }
            while (!v80);
            do
            {
              v81 = *(_DWORD *)(v67 - 16);
              v82 = *(_DWORD *)(v67 - 12);
              v67 -= 56;
              v83 = v22 < v82;
              v93 = v21 == v81;
              v84 = v21 > v81;
              if (v93)
                v84 = v83;
            }
            while (v84);
          }
          if (v9 - 56 != a1)
          {
            *(_OWORD *)a1 = *(_OWORD *)(v9 - 56);
            *(_QWORD *)(a1 + 16) = *(_QWORD *)(v9 - 40);
            *(_OWORD *)(a1 + 24) = *(_OWORD *)(v9 - 32);
            *(_QWORD *)(a1 + 40) = *(_QWORD *)(v9 - 16);
            *(_QWORD *)(a1 + 48) = *(_QWORD *)(v9 - 8);
          }
          a4 = 0;
          *(_OWORD *)(v9 - 56) = v55;
          *(_QWORD *)(v9 - 40) = v56;
          result = *(double *)&v186;
          *(_OWORD *)(v9 - 32) = v186;
          *(_DWORD *)(v9 - 16) = v21;
          *(_DWORD *)(v9 - 12) = v22;
          *(_QWORD *)(v9 - 8) = v72;
          continue;
        }
        v21 = *(_DWORD *)(a1 + 40);
        v22 = *(_DWORD *)(a1 + 44);
LABEL_13:
        v25 = *(_OWORD *)a1;
        v26 = *(_QWORD *)(a1 + 16);
        v185 = *(_OWORD *)(a1 + 24);
        v27 = *(_QWORD *)(a1 + 48);
        v28 = a1;
        do
        {
          v29 = v28;
          v28 += 56;
          v30 = *(_DWORD *)(v29 + 96);
          v93 = v30 == v21;
          v31 = v30 > v21;
          if (v93)
            v31 = *(_DWORD *)(v29 + 100) < v22;
        }
        while (v31);
        v32 = a2;
        if (v29 == a1)
        {
          v37 = a2;
          while (v28 < v37)
          {
            v33 = v37 - 56;
            v38 = *(_DWORD *)(v37 - 16);
            v39 = *(_DWORD *)(v37 - 12) < v22;
            v93 = v38 == v21;
            v40 = v38 > v21;
            if (v93)
              v40 = v39;
            v37 = v33;
            if (v40)
              goto LABEL_29;
          }
          v33 = v37;
        }
        else
        {
          do
          {
            v33 = v32 - 56;
            v34 = *(_DWORD *)(v32 - 16);
            v35 = *(_DWORD *)(v32 - 12) < v22;
            v93 = v34 == v21;
            v36 = v34 > v21;
            if (v93)
              v36 = v35;
            v32 = v33;
          }
          while (!v36);
        }
LABEL_29:
        v9 = v28;
        if (v28 < v33)
        {
          v41 = v33;
          do
          {
            v42 = *(_QWORD *)(v9 + 16);
            v43 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v41;
            *(_QWORD *)(v9 + 16) = *(_QWORD *)(v41 + 16);
            *(_OWORD *)v41 = v43;
            *(_QWORD *)(v41 + 16) = v42;
            v44 = *(_OWORD *)(v9 + 24);
            *(_OWORD *)(v9 + 24) = *(_OWORD *)(v41 + 24);
            *(_OWORD *)(v41 + 24) = v44;
            *(_QWORD *)&v43 = *(_QWORD *)(v9 + 40);
            *(_QWORD *)(v9 + 40) = *(_QWORD *)(v41 + 40);
            *(_QWORD *)(v41 + 40) = v43;
            v45 = *(_QWORD *)(v9 + 48);
            *(_QWORD *)(v9 + 48) = *(_QWORD *)(v41 + 48);
            *(_QWORD *)(v41 + 48) = v45;
            do
            {
              v46 = *(_DWORD *)(v9 + 96);
              v47 = *(_DWORD *)(v9 + 100);
              v9 += 56;
              v48 = v47 < v22;
              v93 = v46 == v21;
              v49 = v46 > v21;
              if (v93)
                v49 = v48;
            }
            while (v49);
            do
            {
              v50 = *(_DWORD *)(v41 - 16);
              v51 = *(_DWORD *)(v41 - 12);
              v41 -= 56;
              v52 = v51 < v22;
              v93 = v50 == v21;
              v53 = v50 > v21;
              if (v93)
                v53 = v52;
            }
            while (!v53);
          }
          while (v9 < v41);
        }
        if (v9 - 56 != a1)
        {
          *(_OWORD *)a1 = *(_OWORD *)(v9 - 56);
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(v9 - 40);
          *(_OWORD *)(a1 + 24) = *(_OWORD *)(v9 - 32);
          *(_QWORD *)(a1 + 40) = *(_QWORD *)(v9 - 16);
          *(_QWORD *)(a1 + 48) = *(_QWORD *)(v9 - 8);
        }
        *(_OWORD *)(v9 - 56) = v25;
        *(_QWORD *)(v9 - 40) = v26;
        *(_OWORD *)(v9 - 32) = v185;
        *(_DWORD *)(v9 - 16) = v21;
        *(_DWORD *)(v9 - 12) = v22;
        *(_QWORD *)(v9 - 8) = v27;
        if (v28 < v33)
        {
LABEL_44:
          sub_1D3D76D70(a1, v9 - 56, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v54 = sub_1D3D78030(a1, v9 - 56);
        if (!sub_1D3D78030(v9, a2))
        {
          if (v54)
            continue;
          goto LABEL_44;
        }
        a2 = v9 - 56;
        if (!v54)
          goto LABEL_1;
        return result;
    }
  }
}

  v8 = (_OWORD *)((char *)a2 - 28);
  v9 = a1;
  while (2)
  {
    a1 = v9;
    v10 = (uint64_t)a2 - v9;
    v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v9) >> 2);
    switch(v11)
    {
      case 0:
      case 1:
        return;
      case 2:
        if (*((float *)a2 - 3) > *(float *)(v9 + 16))
        {
          *(_OWORD *)&v101[12] = *(_OWORD *)(v9 + 12);
          *(_OWORD *)v101 = *(_OWORD *)v9;
          v47 = *v8;
          *(_OWORD *)(v9 + 12) = *(a2 - 1);
          *(_OWORD *)v9 = v47;
          *(a2 - 1) = *(_OWORD *)&v101[12];
          *v8 = *(_OWORD *)v101;
        }
        return;
      case 3:
        sub_1D3DAC424(v9, v9 + 28, (uint64_t)a2 - 28);
        return;
      case 4:
        sub_1D3DAC55C(v9, v9 + 28, v9 + 56, (uint64_t)a2 - 28);
        return;
      case 5:
        v48 = (_OWORD *)(v9 + 28);
        v49 = (_OWORD *)(v9 + 56);
        v50 = (_OWORD *)(v9 + 84);
        sub_1D3DAC55C(v9, v9 + 28, v9 + 56, v9 + 84);
        if (*((float *)a2 - 3) > *(float *)(v9 + 100))
        {
          *(_OWORD *)v102 = *v50;
          *(_OWORD *)&v102[12] = *(_OWORD *)(v9 + 96);
          v51 = *v8;
          *(_OWORD *)(v9 + 96) = *(a2 - 1);
          *v50 = v51;
          *(a2 - 1) = *(_OWORD *)&v102[12];
          *v8 = *(_OWORD *)v102;
          if (*(float *)(v9 + 100) > *(float *)(v9 + 72))
          {
            *(_OWORD *)v103 = *v49;
            *(_OWORD *)&v103[12] = *(_OWORD *)(v9 + 68);
            *v49 = *v50;
            *(_OWORD *)(v9 + 68) = *(_OWORD *)(v9 + 96);
            *v50 = *(_OWORD *)v103;
            *(_OWORD *)(v9 + 96) = *(_OWORD *)&v103[12];
            if (*(float *)(v9 + 72) > *(float *)(v9 + 44))
            {
              *(_OWORD *)v104 = *v48;
              *(_OWORD *)&v104[12] = *(_OWORD *)(v9 + 40);
              *v48 = *v49;
              *(_OWORD *)(v9 + 40) = *(_OWORD *)(v9 + 68);
              *v49 = *(_OWORD *)v104;
              *(_OWORD *)(v9 + 68) = *(_OWORD *)&v104[12];
              if (*(float *)(v9 + 44) > *(float *)(v9 + 16))
              {
                *(_OWORD *)&v105[12] = *(_OWORD *)(v9 + 12);
                *(_OWORD *)v105 = *(_OWORD *)v9;
                *(_OWORD *)v9 = *v48;
                *(_OWORD *)(v9 + 12) = *(_OWORD *)(v9 + 40);
                *v48 = *(_OWORD *)v105;
                *(_OWORD *)(v9 + 40) = *(_OWORD *)&v105[12];
              }
            }
          }
        }
        return;
      default:
        if (v10 <= 671)
        {
          v52 = (_OWORD *)(v9 + 28);
          v54 = (_OWORD *)v9 == a2 || v52 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v54)
            {
              v55 = 0;
              v56 = v9;
              do
              {
                v57 = v52;
                v58 = *(float *)(v56 + 44);
                if (v58 > *(float *)(v56 + 16))
                {
                  v106 = *v52;
                  v59 = *(_QWORD *)(v56 + 48);
                  v60 = v55;
                  while (1)
                  {
                    v61 = v9 + v60;
                    *(_OWORD *)(v61 + 28) = *(_OWORD *)(v9 + v60);
                    *(_OWORD *)(v61 + 40) = *(_OWORD *)(v9 + v60 + 12);
                    if (!v60)
                      break;
                    v60 -= 28;
                    if (v58 <= *(float *)(v61 - 12))
                    {
                      v62 = v9 + v60 + 28;
                      goto LABEL_79;
                    }
                  }
                  v62 = v9;
LABEL_79:
                  *(_OWORD *)v62 = v106;
                  *(float *)(v62 + 16) = v58;
                  *(_QWORD *)(v62 + 20) = v59;
                }
                v52 = (_OWORD *)((char *)v57 + 28);
                v55 += 28;
                v56 = (unint64_t)v57;
              }
              while ((_OWORD *)((char *)v57 + 28) != a2);
            }
          }
          else if (!v54)
          {
            do
            {
              v91 = (uint64_t)v52;
              v92 = *(float *)(a1 + 44);
              if (v92 > *(float *)(a1 + 16))
              {
                v109 = *v52;
                v93 = *(_QWORD *)(a1 + 48);
                do
                {
                  *v52 = *(_OWORD *)((char *)v52 - 28);
                  *(_OWORD *)((char *)v52 + 12) = *(v52 - 1);
                  v94 = *((float *)v52 - 10);
                  v52 = (_OWORD *)((char *)v52 - 28);
                }
                while (v92 > v94);
                *v52 = v109;
                *((float *)v52 + 4) = v92;
                *(_QWORD *)((char *)v52 + 20) = v93;
              }
              v52 = (_OWORD *)(v91 + 28);
              a1 = v91;
            }
            while ((_OWORD *)(v91 + 28) != a2);
          }
          return;
        }
        if (!a3)
        {
          if ((_OWORD *)v9 != a2)
          {
            v63 = (unint64_t)(v11 - 2) >> 1;
            v64 = v63;
            do
            {
              v65 = v64;
              if (v63 >= v64)
              {
                v66 = (2 * v64) | 1;
                v67 = v9 + 28 * v66;
                if (2 * v65 + 2 < v11 && *(float *)(v9 + 28 * v66 + 16) > *(float *)(v67 + 44))
                {
                  v67 += 28;
                  v66 = 2 * v65 + 2;
                }
                v68 = *(float *)(v9 + 28 * v65 + 16);
                if (*(float *)(v67 + 16) <= v68)
                {
                  v69 = v9 + 28 * v65;
                  v107 = *(_OWORD *)v69;
                  v70 = *(_QWORD *)(v69 + 20);
                  do
                  {
                    v71 = (_OWORD *)v69;
                    v69 = v67;
                    v72 = *(_OWORD *)v67;
                    *(_OWORD *)((char *)v71 + 12) = *(_OWORD *)(v67 + 12);
                    *v71 = v72;
                    if (v63 < v66)
                      break;
                    v73 = (2 * v66) | 1;
                    v67 = v9 + 28 * v73;
                    v74 = 2 * v66 + 2;
                    if (v74 < v11 && *(float *)(v9 + 28 * v73 + 16) > *(float *)(v67 + 44))
                    {
                      v67 += 28;
                      v73 = v74;
                    }
                    v66 = v73;
                  }
                  while (*(float *)(v67 + 16) <= v68);
                  *(_OWORD *)v69 = v107;
                  *(float *)(v69 + 16) = v68;
                  *(_QWORD *)(v69 + 20) = v70;
                }
              }
              v64 = v65 - 1;
            }
            while (v65);
            v75 = v10 / 0x1CuLL;
            do
            {
              v76 = 0;
              *(_OWORD *)&v108[12] = *(_OWORD *)(v9 + 12);
              *(_OWORD *)v108 = *(_OWORD *)v9;
              v77 = v9;
              do
              {
                v78 = (_OWORD *)v77;
                v79 = v76 + 1;
                v77 += 28 * (v76 + 1);
                v80 = 2 * v76;
                v76 = (2 * v76) | 1;
                v81 = v80 + 2;
                if (v81 < v75 && *((float *)v78 + 7 * v79 + 4) > *(float *)(v77 + 44))
                {
                  v77 += 28;
                  v76 = v81;
                }
                v82 = *(_OWORD *)v77;
                *(_OWORD *)((char *)v78 + 12) = *(_OWORD *)(v77 + 12);
                *v78 = v82;
              }
              while (v76 <= (uint64_t)((unint64_t)(v75 - 2) >> 1));
              a2 = (_OWORD *)((char *)a2 - 28);
              if ((_OWORD *)v77 == a2)
              {
                *(_OWORD *)(v77 + 12) = *(_OWORD *)&v108[12];
                *(_OWORD *)v77 = *(_OWORD *)v108;
              }
              else
              {
                v83 = *a2;
                *(_OWORD *)(v77 + 12) = *(_OWORD *)((char *)a2 + 12);
                *(_OWORD *)v77 = v83;
                *(_OWORD *)((char *)a2 + 12) = *(_OWORD *)&v108[12];
                *a2 = *(_OWORD *)v108;
                v84 = v77 - v9 + 28;
                if (v84 >= 29)
                {
                  v85 = (v84 / 0x1CuLL - 2) >> 1;
                  v86 = *(float *)(v77 + 16);
                  if (*(float *)(v9 + 28 * v85 + 16) > v86)
                  {
                    v97 = *(_OWORD *)v77;
                    v87 = *(_QWORD *)(v77 + 20);
                    do
                    {
                      v88 = (_OWORD *)v77;
                      v77 = v9 + 28 * v85;
                      v89 = *(_OWORD *)v77;
                      *(_OWORD *)((char *)v88 + 12) = *(_OWORD *)(v77 + 12);
                      *v88 = v89;
                      if (!v85)
                        break;
                      v85 = (v85 - 1) >> 1;
                    }
                    while (*(float *)(v9 + 28 * v85 + 16) > v86);
                    *(_OWORD *)v77 = v97;
                    *(float *)(v77 + 16) = v86;
                    *(_QWORD *)(v77 + 20) = v87;
                  }
                }
              }
            }
            while (v75-- > 2);
          }
          return;
        }
        v12 = (unint64_t)v11 >> 1;
        v13 = (__int128 *)(v9 + 28 * ((unint64_t)v11 >> 1));
        if ((unint64_t)v10 < 0xE01)
        {
          sub_1D3DAC424(a1 + 28 * v12, a1, (uint64_t)a2 - 28);
        }
        else
        {
          sub_1D3DAC424(a1, a1 + 28 * v12, (uint64_t)a2 - 28);
          v14 = 28 * v12;
          v15 = 28 * v12 + a1 - 28;
          sub_1D3DAC424(a1 + 28, v15, (uint64_t)a2 - 56);
          v16 = a1 + 28 + v14;
          sub_1D3DAC424(a1 + 56, v16, (uint64_t)a2 - 84);
          sub_1D3DAC424(v15, (uint64_t)v13, v16);
          *(_OWORD *)&v98[12] = *(_OWORD *)(a1 + 12);
          *(_OWORD *)v98 = *(_OWORD *)a1;
          v17 = *v13;
          *(_OWORD *)(a1 + 12) = *(__int128 *)((char *)v13 + 12);
          *(_OWORD *)a1 = v17;
          *(__int128 *)((char *)v13 + 12) = *(_OWORD *)&v98[12];
          *v13 = *(_OWORD *)v98;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v18 = *(float *)(a1 + 16);
          if (*(float *)(a1 - 12) > v18)
            goto LABEL_11;
          v96 = *(_OWORD *)a1;
          if (v18 <= *((float *)a2 - 3))
          {
            v36 = a1 + 28;
            do
            {
              v9 = v36;
              if (v36 >= (unint64_t)a2)
                break;
              v37 = *(float *)(v36 + 16);
              v36 += 28;
            }
            while (v18 <= v37);
          }
          else
          {
            v34 = a1;
            do
            {
              v9 = v34 + 28;
              v35 = *(float *)(v34 + 44);
              v34 += 28;
            }
            while (v18 <= v35);
          }
          v38 = (float *)a2;
          if (v9 < (unint64_t)a2)
          {
            v39 = (float *)a2;
            do
            {
              v38 = v39 - 7;
              v40 = *(v39 - 3);
              v39 -= 7;
            }
            while (v18 > v40);
          }
          v41 = *(_QWORD *)(a1 + 20);
          while (v9 < (unint64_t)v38)
          {
            *(_OWORD *)&v100[12] = *(_OWORD *)(v9 + 12);
            *(_OWORD *)v100 = *(_OWORD *)v9;
            v42 = *(_OWORD *)v38;
            *(_OWORD *)(v9 + 12) = *(_OWORD *)(v38 + 3);
            *(_OWORD *)v9 = v42;
            *(_OWORD *)(v38 + 3) = *(_OWORD *)&v100[12];
            *(_OWORD *)v38 = *(_OWORD *)v100;
            do
            {
              v43 = *(float *)(v9 + 44);
              v9 += 28;
            }
            while (v18 <= v43);
            do
            {
              v44 = *(v38 - 3);
              v38 -= 7;
            }
            while (v18 > v44);
          }
          v45 = (__int128 *)(v9 - 28);
          if (v9 - 28 != a1)
          {
            v46 = *v45;
            *(_OWORD *)(a1 + 12) = *(_OWORD *)(v9 - 16);
            *(_OWORD *)a1 = v46;
          }
          a4 = 0;
          *v45 = v96;
          *(float *)(v9 - 12) = v18;
          *(_QWORD *)(v9 - 8) = v41;
          continue;
        }
        v18 = *(float *)(a1 + 16);
LABEL_11:
        v95 = *(_OWORD *)a1;
        v19 = *(_QWORD *)(a1 + 20);
        v20 = a1;
        do
        {
          v21 = v20;
          v20 += 28;
        }
        while (*(float *)(v21 + 44) > v18);
        v22 = (float *)a2;
        if (v21 == a1)
        {
          v25 = (float *)a2;
          while (v20 < (unint64_t)v25)
          {
            v23 = v25 - 7;
            v26 = *(v25 - 3);
            v25 -= 7;
            if (v26 > v18)
              goto LABEL_21;
          }
          v23 = v25;
        }
        else
        {
          do
          {
            v23 = v22 - 7;
            v24 = *(v22 - 3);
            v22 -= 7;
          }
          while (v24 <= v18);
        }
LABEL_21:
        v9 = v20;
        if (v20 < (unint64_t)v23)
        {
          v27 = v23;
          do
          {
            *(_OWORD *)v99 = *(_OWORD *)v9;
            *(_OWORD *)&v99[12] = *(_OWORD *)(v9 + 12);
            v28 = *(_OWORD *)v27;
            *(_OWORD *)(v9 + 12) = *(_OWORD *)(v27 + 3);
            *(_OWORD *)v9 = v28;
            *(_OWORD *)(v27 + 3) = *(_OWORD *)&v99[12];
            *(_OWORD *)v27 = *(_OWORD *)v99;
            do
            {
              v29 = *(float *)(v9 + 44);
              v9 += 28;
            }
            while (v29 > v18);
            do
            {
              v30 = *(v27 - 3);
              v27 -= 7;
            }
            while (v30 <= v18);
          }
          while (v9 < (unint64_t)v27);
        }
        v31 = (__int128 *)(v9 - 28);
        if (v9 - 28 != a1)
        {
          v32 = *v31;
          *(_OWORD *)(a1 + 12) = *(_OWORD *)(v9 - 16);
          *(_OWORD *)a1 = v32;
        }
        *v31 = v95;
        *(float *)(v9 - 12) = v18;
        *(_QWORD *)(v9 - 8) = v19;
        if (v20 < (unint64_t)v23)
        {
LABEL_32:
          sub_1D3DABA70(a1, v9 - 28, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v33 = sub_1D3DAC658(a1, v9 - 28);
        if (!sub_1D3DAC658(v9, (uint64_t)a2))
        {
          if (v33)
            continue;
          goto LABEL_32;
        }
        a2 = (_OWORD *)(v9 - 28);
        if (!v33)
          goto LABEL_1;
        return;
    }
  }
}

void sub_1D3D77968()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D7797C(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E95AFB18;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 sub_1D3D779BC(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AFB18;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1D3D779E4(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *);
  _QWORD *v3;

  v1 = a1[2];
  v2 = (uint64_t (*)(_QWORD *))a1[1];
  v3 = (_QWORD *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *))(*v3 + v2);
  return v2(v3);
}

uint64_t sub_1D3D77A00(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__16__bindIRKMN3mrc7DecoderEKFvRKNS2_4PassEEJNS_17reference_wrapperIKS2_EERKNS_12placeholders4__phILi1EEEEEE"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D77A38()
{
  return &unk_1E95AEAB8;
}

__int128 *sub_1D3D77A44(__int128 *result, __int128 *a2, __int128 *a3)
{
  int v3;
  int v4;
  int v5;
  BOOL v6;
  BOOL v7;
  int v8;
  _BOOL4 v9;
  _BOOL4 v10;
  uint64_t v11;
  __int128 v12;
  __int128 *v13;
  uint64_t *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t *v21;
  int v22;
  _BOOL4 v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  _BOOL4 v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v3 = *((_DWORD *)a2 + 10);
  v4 = *((_DWORD *)a2 + 11);
  v5 = *((_DWORD *)result + 10);
  v6 = v3 == v5;
  v7 = v3 > v5;
  if (v6)
    v7 = v4 < *((_DWORD *)result + 11);
  v8 = *((_DWORD *)a3 + 10);
  v9 = *((_DWORD *)a3 + 11) < v4;
  v6 = v8 == v3;
  v10 = v8 > v3;
  if (v6)
    v10 = v9;
  if (v7)
  {
    v11 = *((_QWORD *)result + 2);
    v12 = *result;
    v13 = (__int128 *)((char *)result + 24);
    if (v10)
    {
      v14 = (uint64_t *)(result + 3);
      *result = *a3;
      *((_QWORD *)result + 2) = *((_QWORD *)a3 + 2);
      *a3 = v12;
      *((_QWORD *)a3 + 2) = v11;
      v15 = *v13;
      *v13 = *(__int128 *)((char *)a3 + 24);
      *(__int128 *)((char *)a3 + 24) = v15;
      v16 = *((_QWORD *)result + 5);
      *((_QWORD *)result + 5) = *((_QWORD *)a3 + 5);
LABEL_17:
      *((_QWORD *)a3 + 5) = v16;
      v21 = (uint64_t *)(a3 + 3);
      goto LABEL_18;
    }
    *result = *a2;
    *((_QWORD *)result + 2) = *((_QWORD *)a2 + 2);
    *a2 = v12;
    *((_QWORD *)a2 + 2) = v11;
    v27 = *v13;
    *v13 = *(__int128 *)((char *)a2 + 24);
    *(__int128 *)((char *)a2 + 24) = v27;
    v28 = *((_QWORD *)result + 5);
    *((_QWORD *)result + 5) = *((_QWORD *)a2 + 5);
    *((_QWORD *)a2 + 5) = v28;
    v14 = (uint64_t *)(a2 + 3);
    v29 = *((_QWORD *)result + 6);
    *((_QWORD *)result + 6) = *((_QWORD *)a2 + 6);
    *((_QWORD *)a2 + 6) = v29;
    LODWORD(v29) = *((_DWORD *)a3 + 10);
    v30 = (int)v29 > (int)v28;
    if ((_DWORD)v29 == (_DWORD)v28)
      v30 = *((_DWORD *)a3 + 11) < *((_DWORD *)a2 + 11);
    if (v30)
    {
      v31 = *((_QWORD *)a2 + 2);
      v32 = *a2;
      *a2 = *a3;
      *((_QWORD *)a2 + 2) = *((_QWORD *)a3 + 2);
      *a3 = v32;
      *((_QWORD *)a3 + 2) = v31;
      v33 = *(__int128 *)((char *)a2 + 24);
      *(__int128 *)((char *)a2 + 24) = *(__int128 *)((char *)a3 + 24);
      *(__int128 *)((char *)a3 + 24) = v33;
      v16 = *((_QWORD *)a2 + 5);
      *((_QWORD *)a2 + 5) = *((_QWORD *)a3 + 5);
      goto LABEL_17;
    }
  }
  else if (v10)
  {
    v17 = *((_QWORD *)a2 + 2);
    v18 = *a2;
    *a2 = *a3;
    *((_QWORD *)a2 + 2) = *((_QWORD *)a3 + 2);
    *a3 = v18;
    *((_QWORD *)a3 + 2) = v17;
    v19 = *(__int128 *)((char *)a2 + 24);
    *(__int128 *)((char *)a2 + 24) = *(__int128 *)((char *)a3 + 24);
    *(__int128 *)((char *)a3 + 24) = v19;
    *(_QWORD *)&v18 = *((_QWORD *)a2 + 5);
    *((_QWORD *)a2 + 5) = *((_QWORD *)a3 + 5);
    *((_QWORD *)a3 + 5) = v18;
    v21 = (uint64_t *)(a2 + 3);
    v20 = *((_QWORD *)a2 + 6);
    *((_QWORD *)a2 + 6) = *((_QWORD *)a3 + 6);
    *((_QWORD *)a3 + 6) = v20;
    LODWORD(v20) = *((_DWORD *)a2 + 10);
    v22 = *((_DWORD *)result + 10);
    v6 = (_DWORD)v20 == v22;
    v23 = (int)v20 > v22;
    if (v6)
      v23 = *((_DWORD *)a2 + 11) < *((_DWORD *)result + 11);
    if (v23)
    {
      v24 = *((_QWORD *)result + 2);
      v25 = *result;
      *result = *a2;
      *((_QWORD *)result + 2) = *((_QWORD *)a2 + 2);
      *a2 = v25;
      *((_QWORD *)a2 + 2) = v24;
      v26 = *(__int128 *)((char *)result + 24);
      *(__int128 *)((char *)result + 24) = *(__int128 *)((char *)a2 + 24);
      *(__int128 *)((char *)a2 + 24) = v26;
      *(_QWORD *)&v25 = *((_QWORD *)result + 5);
      *((_QWORD *)result + 5) = *((_QWORD *)a2 + 5);
      *((_QWORD *)a2 + 5) = v25;
      v14 = (uint64_t *)(result + 3);
LABEL_18:
      v34 = *v14;
      *v14 = *v21;
      *v21 = v34;
    }
  }
  return result;
}

double sub_1D3D77C6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;
  int v9;
  int v10;
  BOOL v11;
  _BOOL4 v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  int v23;
  _BOOL4 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  sub_1D3D77A44((__int128 *)a1, (__int128 *)a2, (__int128 *)a3);
  v9 = *(_DWORD *)(a4 + 40);
  v10 = *(_DWORD *)(a3 + 40);
  v11 = v9 == v10;
  v12 = v9 > v10;
  if (v11)
    v12 = *(_DWORD *)(a4 + 44) < *(_DWORD *)(a3 + 44);
  if (v12)
  {
    v13 = *(_QWORD *)(a3 + 16);
    v14 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_QWORD *)(a3 + 16) = *(_QWORD *)(a4 + 16);
    *(_OWORD *)a4 = v14;
    *(_QWORD *)(a4 + 16) = v13;
    v15 = *(_OWORD *)(a3 + 24);
    *(_OWORD *)(a3 + 24) = *(_OWORD *)(a4 + 24);
    *(_OWORD *)(a4 + 24) = v15;
    result = *(double *)(a4 + 40);
    *(_QWORD *)&v14 = *(_QWORD *)(a3 + 40);
    *(double *)(a3 + 40) = result;
    *(_QWORD *)(a4 + 40) = v14;
    v16 = *(_QWORD *)(a3 + 48);
    *(_QWORD *)(a3 + 48) = *(_QWORD *)(a4 + 48);
    *(_QWORD *)(a4 + 48) = v16;
    LODWORD(v16) = *(_DWORD *)(a3 + 40);
    v17 = *(_DWORD *)(a2 + 40);
    v11 = (_DWORD)v16 == v17;
    v18 = (int)v16 > v17;
    if (v11)
      v18 = *(_DWORD *)(a3 + 44) < *(_DWORD *)(a2 + 44);
    if (v18)
    {
      v19 = *(_QWORD *)(a2 + 16);
      v20 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a3 = v20;
      *(_QWORD *)(a3 + 16) = v19;
      v21 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
      *(_OWORD *)(a3 + 24) = v21;
      result = *(double *)(a3 + 40);
      *(_QWORD *)&v20 = *(_QWORD *)(a2 + 40);
      *(double *)(a2 + 40) = result;
      *(_QWORD *)(a3 + 40) = v20;
      v22 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
      *(_QWORD *)(a3 + 48) = v22;
      LODWORD(v22) = *(_DWORD *)(a2 + 40);
      v23 = *(_DWORD *)(a1 + 40);
      v11 = (_DWORD)v22 == v23;
      v24 = (int)v22 > v23;
      if (v11)
        v24 = *(_DWORD *)(a2 + 44) < *(_DWORD *)(a1 + 44);
      if (v24)
      {
        v25 = *(_QWORD *)(a1 + 16);
        v26 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
        *(_OWORD *)a2 = v26;
        *(_QWORD *)(a2 + 16) = v25;
        v27 = *(_OWORD *)(a1 + 24);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a2 + 24) = v27;
        result = *(double *)(a2 + 40);
        *(_QWORD *)&v26 = *(_QWORD *)(a1 + 40);
        *(double *)(a1 + 40) = result;
        *(_QWORD *)(a2 + 40) = v26;
        v28 = *(_QWORD *)(a1 + 48);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_QWORD *)(a2 + 48) = v28;
      }
    }
  }
  return result;
}

double sub_1D3D77E0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;
  int v11;
  int v12;
  BOOL v13;
  _BOOL4 v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  int v19;
  _BOOL4 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  int v25;
  _BOOL4 v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  int v31;
  _BOOL4 v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  result = sub_1D3D77C6C(a1, a2, a3, a4);
  v11 = *(_DWORD *)(a5 + 40);
  v12 = *(_DWORD *)(a4 + 40);
  v13 = v11 == v12;
  v14 = v11 > v12;
  if (v13)
    v14 = *(_DWORD *)(a5 + 44) < *(_DWORD *)(a4 + 44);
  if (v14)
  {
    v15 = *(_QWORD *)(a4 + 16);
    v16 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(a5 + 16);
    *(_OWORD *)a5 = v16;
    *(_QWORD *)(a5 + 16) = v15;
    v17 = *(_OWORD *)(a4 + 24);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a5 + 24);
    *(_OWORD *)(a5 + 24) = v17;
    result = *(double *)(a5 + 40);
    *(_QWORD *)&v16 = *(_QWORD *)(a4 + 40);
    *(double *)(a4 + 40) = result;
    *(_QWORD *)(a5 + 40) = v16;
    v18 = *(_QWORD *)(a4 + 48);
    *(_QWORD *)(a4 + 48) = *(_QWORD *)(a5 + 48);
    *(_QWORD *)(a5 + 48) = v18;
    LODWORD(v18) = *(_DWORD *)(a4 + 40);
    v19 = *(_DWORD *)(a3 + 40);
    v13 = (_DWORD)v18 == v19;
    v20 = (int)v18 > v19;
    if (v13)
      v20 = *(_DWORD *)(a4 + 44) < *(_DWORD *)(a3 + 44);
    if (v20)
    {
      v21 = *(_QWORD *)(a3 + 16);
      v22 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(a4 + 16);
      *(_OWORD *)a4 = v22;
      *(_QWORD *)(a4 + 16) = v21;
      v23 = *(_OWORD *)(a3 + 24);
      *(_OWORD *)(a3 + 24) = *(_OWORD *)(a4 + 24);
      *(_OWORD *)(a4 + 24) = v23;
      result = *(double *)(a4 + 40);
      *(_QWORD *)&v22 = *(_QWORD *)(a3 + 40);
      *(double *)(a3 + 40) = result;
      *(_QWORD *)(a4 + 40) = v22;
      v24 = *(_QWORD *)(a3 + 48);
      *(_QWORD *)(a3 + 48) = *(_QWORD *)(a4 + 48);
      *(_QWORD *)(a4 + 48) = v24;
      LODWORD(v24) = *(_DWORD *)(a3 + 40);
      v25 = *(_DWORD *)(a2 + 40);
      v13 = (_DWORD)v24 == v25;
      v26 = (int)v24 > v25;
      if (v13)
        v26 = *(_DWORD *)(a3 + 44) < *(_DWORD *)(a2 + 44);
      if (v26)
      {
        v27 = *(_QWORD *)(a2 + 16);
        v28 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
        *(_OWORD *)a3 = v28;
        *(_QWORD *)(a3 + 16) = v27;
        v29 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
        *(_OWORD *)(a3 + 24) = v29;
        result = *(double *)(a3 + 40);
        *(_QWORD *)&v28 = *(_QWORD *)(a2 + 40);
        *(double *)(a2 + 40) = result;
        *(_QWORD *)(a3 + 40) = v28;
        v30 = *(_QWORD *)(a2 + 48);
        *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 48) = v30;
        LODWORD(v30) = *(_DWORD *)(a2 + 40);
        v31 = *(_DWORD *)(a1 + 40);
        v13 = (_DWORD)v30 == v31;
        v32 = (int)v30 > v31;
        if (v13)
          v32 = *(_DWORD *)(a2 + 44) < *(_DWORD *)(a1 + 44);
        if (v32)
        {
          v33 = *(_QWORD *)(a1 + 16);
          v34 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
          *(_OWORD *)a2 = v34;
          *(_QWORD *)(a2 + 16) = v33;
          v35 = *(_OWORD *)(a1 + 24);
          *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
          *(_OWORD *)(a2 + 24) = v35;
          result = *(double *)(a2 + 40);
          *(_QWORD *)&v34 = *(_QWORD *)(a1 + 40);
          *(double *)(a1 + 40) = result;
          *(_QWORD *)(a2 + 40) = v34;
          v36 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
          *(_QWORD *)(a2 + 48) = v36;
        }
      }
    }
  }
  return result;
}

BOOL sub_1D3D78030(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  int v6;
  int v7;
  BOOL v8;
  _BOOL4 v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  _BOOL4 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  BOOL v30;
  uint64_t v31;
  _OWORD *v32;
  __int128 v33;

  v4 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(_DWORD *)(a2 - 16);
      v7 = *(_DWORD *)(a1 + 40);
      v8 = v6 == v7;
      v9 = v6 > v7;
      if (v8)
        v9 = *(_DWORD *)(a2 - 12) < *(_DWORD *)(a1 + 44);
      if (v9)
      {
        v10 = *(_QWORD *)(a1 + 16);
        v11 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 56);
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 - 40);
        *(_OWORD *)(a2 - 56) = v11;
        *(_QWORD *)(a2 - 40) = v10;
        v12 = *(_OWORD *)(a1 + 24);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a2 - 32) = v12;
        *(_QWORD *)&v11 = *(_QWORD *)(a1 + 40);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 - 16);
        *(_QWORD *)(a2 - 16) = v11;
        v13 = *(_QWORD *)(a1 + 48);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(a2 - 8) = v13;
      }
      return result;
    case 3:
      sub_1D3D77A44((__int128 *)a1, (__int128 *)(a1 + 56), (__int128 *)(a2 - 56));
      return 1;
    case 4:
      sub_1D3D77C6C(a1, a1 + 56, a1 + 112, a2 - 56);
      return 1;
    case 5:
      sub_1D3D77E0C(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56);
      return 1;
    default:
      v14 = a1 + 112;
      sub_1D3D77A44((__int128 *)a1, (__int128 *)(a1 + 56), (__int128 *)(a1 + 112));
      v15 = a1 + 168;
      if (a1 + 168 == a2)
        return 1;
      v16 = 0;
      v17 = 0;
      break;
  }
  while (1)
  {
    v18 = *(_DWORD *)(v15 + 40);
    v19 = *(_DWORD *)(v15 + 44);
    v20 = *(_DWORD *)(v14 + 40);
    v8 = v18 == v20;
    v21 = v18 > v20;
    if (v8)
      v21 = v19 < *(_DWORD *)(v14 + 44);
    if (v21)
    {
      v22 = *(_OWORD *)v15;
      v23 = *(_QWORD *)(v15 + 16);
      v33 = *(_OWORD *)(v15 + 24);
      v24 = *(_QWORD *)(v15 + 48);
      v25 = v16;
      while (1)
      {
        v26 = v25;
        v27 = a1 + v25;
        *(_OWORD *)(v27 + 168) = *(_OWORD *)(v27 + 112);
        *(_QWORD *)(v27 + 184) = *(_QWORD *)(v27 + 128);
        *(_OWORD *)(v27 + 192) = *(_OWORD *)(v27 + 136);
        *(_QWORD *)(v27 + 208) = *(_QWORD *)(v27 + 152);
        *(_QWORD *)(v27 + 216) = *(_QWORD *)(v27 + 160);
        if (v26 == -112)
          break;
        v28 = *(_DWORD *)(v27 + 96);
        v29 = v19 < *(_DWORD *)(v27 + 100);
        v8 = v18 == v28;
        v30 = v18 > v28;
        if (v8)
          v30 = v29;
        v25 = v26 - 56;
        if (!v30)
        {
          v31 = a1 + v25 + 168;
          v32 = (_OWORD *)(a1 + v26 + 136);
          goto LABEL_18;
        }
      }
      v32 = (_OWORD *)(v27 + 136);
      v31 = a1;
LABEL_18:
      *(_OWORD *)v31 = v22;
      *(_QWORD *)(v31 + 16) = v23;
      *v32 = v33;
      *(_DWORD *)(v31 + 40) = v18;
      *(_DWORD *)(v31 + 44) = v19;
      *(_QWORD *)(v31 + 48) = v24;
      if (++v17 == 8)
        return v15 + 56 == a2;
    }
    v14 = v15;
    v16 += 56;
    v15 += 56;
    if (v15 == a2)
      return 1;
  }
}

void sub_1D3D7828C()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D782A0(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95AC7D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3D782D8(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AC7D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *sub_1D3D782F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v8;
  dispatch_group_t **v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *result;
  uint64_t v17;
  _BYTE v18[24];
  _BYTE *v19;
  _BYTE v20[24];
  _BYTE *v21;
  __int128 v22;
  _BYTE v23[24];
  _BYTE *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  sub_1D3D75260((uint64_t)v18, a2);
  v8 = *a6;
  v9 = *(dispatch_group_t ***)(a1 + 16);
  sub_1D3D75260((uint64_t)v20, (uint64_t)v18);
  v10 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)&v22 = v8;
  *((_QWORD *)&v22 + 1) = v10;
  v24 = 0;
  v11 = (char *)operator new(0x38uLL);
  *(_QWORD *)v11 = &off_1E95AC988;
  sub_1D3D75260((uint64_t)(v11 + 8), (uint64_t)v20);
  *(_OWORD *)(v11 + 40) = v22;
  v24 = v11;
  sub_1D3D752C4(v9, (uint64_t)v23);
  v12 = v24;
  if (v24 == v23)
  {
    v13 = 4;
    v12 = v23;
  }
  else
  {
    if (!v24)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  v14 = v21;
  if (v21 == v20)
  {
    v15 = 4;
    v14 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_11;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v17 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v17 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v17))();
}

void sub_1D3D78448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;

  v20 = *(_QWORD **)(v18 - 48);
  if (v20 == v17)
  {
    v21 = 4;
    v20 = (_QWORD *)(v18 - 72);
  }
  else
  {
    if (!v20)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_6:
  v22 = a17;
  if (a17 == &a14)
  {
    v23 = 4;
    v22 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_11;
    v23 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v22 + 8 * v23))();
LABEL_11:
  v24 = a13;
  if (a13 == &a10)
  {
    v25 = 4;
    v24 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_16;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D784E8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D78520()
{
  return &unk_1E95ABD98;
}

_QWORD *sub_1D3D7852C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E95AC988;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1D3D78588(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E95AC988;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D8254C54);
}

char *sub_1D3D785F4(uint64_t a1)
{
  uint64_t v2;
  char *v3;

  v2 = a1 + 8;
  v3 = (char *)operator new(0x38uLL);
  *(_QWORD *)v3 = &off_1E95AC988;
  sub_1D3D7574C((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  return v3;
}

void sub_1D3D78648(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1D3D7865C(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AC988;
  sub_1D3D7574C(a2 + 8, a1 + 8);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

_QWORD *sub_1D3D7869C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1D3D786D0(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

uint64_t sub_1D3D78720(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v18[3];
  char v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;

  v3 = a1[5];
  v2 = (_QWORD *)a1[6];
  v4 = (unint64_t *)(*v2 + (v3 << 6));
  if (!atomic_load(v4))
  {
    v18[0] = (unint64_t)sub_1D3D73E50();
    do
      v6 = __ldaxr(v18);
    while (__stlxr(0, v18));
    do
      v7 = (const void *)__ldaxr(v4);
    while (__stlxr(v6, v4));
    if (v7)
      CFRelease(v7);
    sub_1D3D74DE4(v18);
  }
  v8 = v2[1];
  v9 = v2[2];
  v10 = atomic_load(v4);
  v11 = v2[3] + (v3 << 6);
  v12 = *(_QWORD *)(v8 + 8);
  v13 = *(_QWORD *)v8 + 16;
  v14 = *(uint64_t **)(v8 + 16);
  v15 = **(_QWORD **)(v8 + 24);
  v18[0] = v10 + 16;
  v18[1] = v13;
  v18[2] = v12;
  v19 = 0;
  v20 = 0;
  v21 = v9 + (v3 << 7);
  v22 = *v14;
  v23 = 1;
  v24 = v11;
  v25 = v15;
  v16 = a1[4];
  if (!v16)
    sub_1D3D75A24();
  return (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)v16 + 48))(v16, v18);
}

void sub_1D3D78800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  sub_1D3D74DE4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D78814(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_1clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D7884C()
{
  return &unk_1E95ABDE8;
}

unint64_t *sub_1D3D78858(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

unint64_t *sub_1D3D78890(unint64_t *cf)
{
  CFTypeID v2;
  CFTypeID v3;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v2 != qword_1EDB89320)
      _os_assumes_log();
    v3 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v3 != qword_1EDB89320)
      _os_assumes_log();
  }
  return sub_1D3D8C70C(cf + 17);
}

uint64_t sub_1D3D7895C(unint64_t *cf, unint64_t *a2)
{
  CFTypeID v4;
  CFTypeID v5;
  uint64_t i;
  int32x2_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t result;
  const void *v11;
  const void *v12;
  CGAffineTransform v13;
  CGAffineTransform t1;

  if (!cf)
    goto LABEL_5;
  v4 = CFGetTypeID(cf);
  if (qword_1EDB89308 != -1)
    dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
  if (v4 != qword_1EDB89320)
  {
    _os_assumes_log();
    if (a2)
      goto LABEL_6;
  }
  else
  {
LABEL_5:
    if (a2)
    {
LABEL_6:
      v5 = CFGetTypeID(a2);
      if (qword_1EDB89308 != -1)
        dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
      if (v5 != qword_1EDB89320)
        _os_assumes_log();
    }
  }
  for (i = 0; i != 8; i += 2)
  {
    v7 = vmovn_s64(vceqq_f64(*(float64x2_t *)&cf[i + 2], *(float64x2_t *)&a2[i + 2]));
    if ((v7.i32[0] & v7.i32[1] & 1) == 0)
      return 0;
  }
  v8 = *((_OWORD *)cf + 6);
  *(_OWORD *)&t1.a = *((_OWORD *)cf + 5);
  *(_OWORD *)&t1.c = v8;
  *(_OWORD *)&t1.tx = *((_OWORD *)cf + 7);
  v9 = *((_OWORD *)a2 + 6);
  *(_OWORD *)&v13.a = *((_OWORD *)a2 + 5);
  *(_OWORD *)&v13.c = v9;
  *(_OWORD *)&v13.tx = *((_OWORD *)a2 + 7);
  result = CGAffineTransformEqualToTransform(&t1, &v13);
  if (!(_DWORD)result)
    return result;
  if (*((double *)cf + 16) != *((double *)a2 + 16))
    return 0;
  v11 = (const void *)atomic_load(a2 + 17);
  v12 = (const void *)atomic_load(cf + 17);
  if (v12 == v11)
    return *((float *)cf + 36) == *((float *)a2 + 36);
  result = 0;
  if (v11)
  {
    if (v12)
    {
      result = CFEqual(v12, v11);
      if ((_DWORD)result)
        return *((float *)cf + 36) == *((float *)a2 + 36);
    }
  }
  return result;
}

unint64_t sub_1D3D78B04(unint64_t *cf)
{
  CFTypeID v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  const void *v18;
  CFHashCode v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  float v50;
  uint64_t v51;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v2 != qword_1EDB89320)
      _os_assumes_log();
  }
  v3 = *((double *)cf + 2);
  v4 = *((double *)cf + 3);
  v5 = *((double *)cf + 4);
  v6 = *((double *)cf + 5);
  v7 = *((double *)cf + 6);
  v8 = *((double *)cf + 7);
  v10 = *((double *)cf + 8);
  v9 = *((double *)cf + 9);
  v12 = *((double *)cf + 10);
  v11 = *((double *)cf + 11);
  v14 = *((double *)cf + 12);
  v13 = *((double *)cf + 13);
  v16 = *((double *)cf + 14);
  v15 = *((double *)cf + 15);
  v17 = *((double *)cf + 16);
  v18 = (const void *)atomic_load(cf + 17);
  if (v18)
  {
    v58 = *((double *)cf + 4);
    v59 = *((double *)cf + 8);
    v56 = *((double *)cf + 2);
    v57 = *((double *)cf + 14);
    v54 = *((double *)cf + 6);
    v55 = *((double *)cf + 12);
    v53 = *((double *)cf + 10);
    v19 = CFHash(v18);
    v12 = v53;
    v7 = v54;
    v14 = v55;
    v3 = v56;
    v16 = v57;
    v5 = v58;
    v10 = v59;
    v20 = v19 + 2654435769u;
  }
  else
  {
    v20 = 3317042773;
  }
  v21 = *(_QWORD *)&v12 + 2654435769;
  if (v12 == 0.0)
    v21 = 2654435769;
  v22 = *(_QWORD *)&v11 + 2654435769;
  if (v11 == 0.0)
    v22 = 2654435769;
  v23 = ((v21 >> 2) + (v21 << 6) + v22) ^ v21;
  v24 = *(_QWORD *)&v14 + 2654435769;
  if (v14 == 0.0)
    v24 = 2654435769;
  v25 = (v24 + (v23 << 6) + (v23 >> 2)) ^ v23;
  v26 = *(_QWORD *)&v13 + 2654435769;
  if (v13 == 0.0)
    v26 = 2654435769;
  v27 = (v26 + (v25 << 6) + (v25 >> 2)) ^ v25;
  v28 = *(_QWORD *)&v16 + 2654435769;
  if (v16 == 0.0)
    v28 = 2654435769;
  v29 = (v28 + (v27 << 6) + (v27 >> 2)) ^ v27;
  v30 = *(_QWORD *)&v15 + 2654435769;
  if (v15 == 0.0)
    v30 = 2654435769;
  v31 = (v30 + (v29 << 6) + (v29 >> 2)) ^ v29;
  v32 = *(_QWORD *)&v10 + 2654435769;
  if (v10 == 0.0)
    v32 = 2654435769;
  v33 = *(_QWORD *)&v9 + 2654435769;
  if (v9 == 0.0)
    v33 = 2654435769;
  v34 = (((v32 >> 2) + (v32 << 6) + v33) ^ v32) + 2654435769u;
  v35 = *(_QWORD *)&v7 + 2654435769;
  if (v7 == 0.0)
    v35 = 2654435769;
  v36 = *(_QWORD *)&v8 + 2654435769;
  if (v8 == 0.0)
    v36 = 2654435769;
  v37 = (((v35 >> 2) + (v35 << 6) + v36) ^ v35) + 2654435769u;
  v38 = *(_QWORD *)&v3 + 2654435769;
  if (v3 == 0.0)
    v38 = 2654435769;
  v39 = *(_QWORD *)&v4 + 2654435769;
  if (v4 == 0.0)
    v39 = 2654435769;
  v40 = (((v38 >> 2) + (v38 << 6) + v39) ^ v38) + 2654435769u;
  v41 = *(_QWORD *)&v5 + 2654435769;
  if (v5 == 0.0)
    v41 = 2654435769;
  v42 = *(_QWORD *)&v6 + 2654435769;
  if (v6 == 0.0)
    v42 = 2654435769;
  v43 = ((v40 << 6) + 2654435769u + (v40 >> 2) + (((v41 >> 2) + (v41 << 6) + v42) ^ v41)) ^ v40;
  v44 = (v37 + (v43 << 6) + (v43 >> 2)) ^ v43;
  v45 = ((v34 + (v44 << 6) + (v44 >> 2)) ^ v44) + 2654435769u;
  v46 = (v31 + 2654435769 + (v45 << 6) + (v45 >> 2)) ^ v45;
  v47 = *(_QWORD *)&v17 + 2654435769;
  if (v17 == 0.0)
    v47 = 2654435769;
  v48 = (v47 + (v46 << 6) + (v46 >> 2)) ^ v46;
  v49 = ((v48 >> 2) + (v48 << 6) + v20) ^ v48;
  v50 = *((float *)cf + 36);
  v51 = LODWORD(v50) + 2654435769;
  if (v50 == 0.0)
    v51 = 2654435769;
  return ((v49 >> 2) + (v49 << 6) + v51) ^ v49;
}

CFStringRef sub_1D3D78E00(char *cf)
{
  CFTypeID v2;
  const __CFAllocator *v3;
  __CFString *v5;
  __CFString *v6;
  uint64_t i;
  __CFString *v8;
  __CFString *v9;
  __CFString *v10;
  __CFString *v11;
  __int128 v13;
  __int128 v14;
  BOOL v15;
  __CFString *v16;
  const __CFString *v17;
  __CFString *v18;
  __CFString *v19;
  __CFString *v20;
  __CFString *v21;
  __CFString *v22;
  __CFString *v23;
  __CFString *v24;
  __CFString *v25;
  __CFString *v26;
  unint64_t v27;
  __CFString *v28;
  __CFString *v29;
  const __CFString *v30;
  CFStringRef Copy;
  CFMutableStringRef Mutable;
  CGAffineTransform t2;
  CGAffineTransform t1;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v2 != qword_1EDB89320)
      _os_assumes_log();
  }
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (atomic_load((unint64_t *)&Mutable))
  {
    v5 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v5, 0, CFSTR("<%s %p> {\n"), "MRCRegion", cf);
    v6 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v6, CFSTR("    cornerPoints {\n"));
    for (i = 0; i != 64; i += 16)
    {
      v8 = (__CFString *)atomic_load((unint64_t *)&Mutable);
      CFStringAppend(v8, CFSTR("        "));
      sub_1D3E2D678((unint64_t *)&Mutable, (double *)&cf[i + 16]);
      v9 = (__CFString *)atomic_load((unint64_t *)&Mutable);
      CFStringAppend(v9, CFSTR("\n"));
    }
    v10 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v10, CFSTR("    }\n"));
    v11 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v11, CFSTR("    transform "));
    if (atomic_load((unint64_t *)&Mutable))
    {
      v13 = *((_OWORD *)cf + 6);
      *(_OWORD *)&t1.a = *((_OWORD *)cf + 5);
      *(_OWORD *)&t1.c = v13;
      *(_OWORD *)&t1.tx = *((_OWORD *)cf + 7);
      v14 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
      *(_OWORD *)&t2.a = *MEMORY[0x1E0C9BAA8];
      *(_OWORD *)&t2.c = v14;
      *(_OWORD *)&t2.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
      v15 = CGAffineTransformEqualToTransform(&t1, &t2);
      v16 = (__CFString *)atomic_load((unint64_t *)&Mutable);
      if (v15)
      {
        v17 = CFSTR("<identity>");
      }
      else
      {
        CFStringAppend(v16, CFSTR("{a="));
        sub_1D3E2D5D0((unint64_t *)&Mutable, *((double *)cf + 10));
        v18 = (__CFString *)atomic_load((unint64_t *)&Mutable);
        CFStringAppend(v18, CFSTR(", b="));
        sub_1D3E2D5D0((unint64_t *)&Mutable, *((double *)cf + 11));
        v19 = (__CFString *)atomic_load((unint64_t *)&Mutable);
        CFStringAppend(v19, CFSTR(", c="));
        sub_1D3E2D5D0((unint64_t *)&Mutable, *((double *)cf + 12));
        v20 = (__CFString *)atomic_load((unint64_t *)&Mutable);
        CFStringAppend(v20, CFSTR(", d="));
        sub_1D3E2D5D0((unint64_t *)&Mutable, *((double *)cf + 13));
        v21 = (__CFString *)atomic_load((unint64_t *)&Mutable);
        CFStringAppend(v21, CFSTR(", tx="));
        sub_1D3E2D5D0((unint64_t *)&Mutable, *((double *)cf + 14));
        v22 = (__CFString *)atomic_load((unint64_t *)&Mutable);
        CFStringAppend(v22, CFSTR(", ty="));
        sub_1D3E2D5D0((unint64_t *)&Mutable, *((double *)cf + 15));
        v16 = (__CFString *)atomic_load((unint64_t *)&Mutable);
        v17 = CFSTR("}");
      }
      CFStringAppend(v16, v17);
    }
    v23 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v23, CFSTR("\n"));
    v24 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v24, CFSTR("    orientation "));
    sub_1D3E2D5D0((unint64_t *)&Mutable, *((double *)cf + 16));
    v25 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v25, CFSTR("\n"));
    v26 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    v27 = atomic_load((unint64_t *)cf + 17);
    CFStringAppendFormat(v26, 0, CFSTR("    symbology %@\n"), v27);
    v28 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v28, 0, CFSTR("    confidence %f\n"), *((float *)cf + 36));
    v29 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v29, CFSTR("}"));
    v30 = (const __CFString *)atomic_load((unint64_t *)&Mutable);
    Copy = CFStringCreateCopy(v3, v30);
    sub_1D3D8FA0C((unint64_t *)&Mutable);
    if (Copy)
      return Copy;
  }
  else
  {
    sub_1D3D8FA0C((unint64_t *)&Mutable);
  }
  return CFStringCreateWithFormat(v3, 0, CFSTR("<%s %p>"), "MRCRegion", cf);
}

void sub_1D3D7916C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  sub_1D3D8FA0C((unint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D3D79188()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D7919C(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E95AC778;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 sub_1D3D791E4(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E95AC778;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1D3D79214(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  CGFloat v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  NSObject *v15;
  int d_low;
  uint64_t v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t *v20;
  uint64_t *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t *v28;
  __int128 v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  __int128 v41;
  unint64_t v42;
  NSObject *v43;
  _QWORD *v44;
  unint64_t v45;
  uint64_t v47;
  __CVBuffer *v48;
  const void *IOSurface;
  char v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  void **p_cache;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  const char *v62;
  uint64_t v63;
  __int128 v64;
  _QWORD *v65;
  uint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  Class isa;
  Class v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  uint64_t v76;
  int v77;
  CFTypeRef v78;
  CFTypeRef v79;
  CFTypeRef v80;
  int v81;
  BOOL v82;
  int v83;
  NSObject *v84;
  int v85;
  NSObject *v86;
  NSObject *v87;
  _QWORD *v88;
  uint64_t v89;
  NSObject *v90;
  const char *v91;
  NSObject *v92;
  NSObject *v93;
  CFTypeRef v94;
  CFTypeRef v95;
  CFTypeRef v96;
  int v97;
  BOOL v98;
  int v99;
  NSObject *v100;
  int v101;
  __IOSurface *v102;
  __IOSurface *v103;
  __IOSurface *v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v110;
  uint64_t v111;
  uint64_t k;
  NSObject *v119;
  float v127;
  float v128;
  NSObject *v129;
  __IOSurface *v130;
  _DWORD *BaseAddress;
  __IOSurface *v132;
  __IOSurface *v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t i;
  float v140;
  float v141;
  NSObject *v142;
  float v143;
  float v144;
  char *v145;
  char *v146;
  CGFloat v147;
  char *v148;
  unint64_t v149;
  unint64_t v150;
  float *v151;
  uint64_t v152;
  unint64_t v153;
  unint64_t v154;
  char *v155;
  float *v156;
  float *v157;
  float *v158;
  unint64_t v159;
  float *v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float v166;
  char *v167;
  __int128 v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  CGFloat c;
  char *v174;
  char *v175;
  CGFloat b;
  char *v177;
  __int128 v178;
  CGFloat v179;
  char *v180;
  char *j;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  CGFloat v185;
  CGFloat v186;
  __int128 v187;
  double Width;
  double v189;
  double v190;
  double v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  double v196;
  char *v197;
  CGFloat v198;
  int8x16_t v199;
  uint64_t v200;
  const void *v201;
  const void *v202;
  CFTypeID v203;
  CGFloat v204;
  CGFloat v205;
  uint64_t v206;
  unint64_t v207;
  CGFloat v208;
  uint64_t v209;
  _QWORD *v210;
  int v211;
  double v212;
  float v213;
  double v214;
  float v215;
  CGFloat v216;
  double v217;
  char v218;
  int v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  unint64_t v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  _WORD *v245;
  _WORD *v246;
  float *v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  unint64_t v251;
  unint64_t v252;
  _WORD *v253;
  float *v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  char *v259;
  NSObject *oslog;
  os_log_t log[3];
  uint64_t loga;
  uint64_t logb;
  NSObject *logc;
  CGFloat v265;
  char v266;
  __int128 v267;
  CGFloat v268;
  char v269;
  unint64_t v270;
  CGAffineTransform v271;
  CGAffineTransform v272;
  void *__p;
  char *v274;
  CGFloat d;
  int v276;
  float v277;
  float v278;
  int v279;
  int v280;
  CGAffineTransform buf;
  _OWORD v282[2];
  __int128 v283;
  _QWORD v284[3];
  _QWORD *v285;
  _QWORD v286[3];
  _QWORD *v287;
  CGFloat *v288;
  _QWORD v289[3];
  _QWORD *v290;
  CGAffineTransform v291;
  int8x16_t v292;
  CGAffineTransform v293;
  _QWORD v294[3];
  _QWORD *v295;
  _QWORD v296[3];
  _QWORD *v297;
  CGFloat *v298;
  _QWORD v299[3];
  _QWORD *v300;
  CGAffineTransform t2;
  uint64_t v302;

  v302 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)a2 + 8))
    _ZF = *(_BYTE *)(a3 + 96) == 0;
  else
    _ZF = 0;
  if (!_ZF)
  {
    sub_1D3D74C98(*(unint64_t **)(a1 + 8), a3);
    if (qword_1EDB89FA0 != -1)
      dispatch_once(&qword_1EDB89FA0, &unk_1E95B04B0);
    v5 = qword_1EDB89FA8;
    if (os_log_type_enabled((os_log_t)qword_1EDB89FA8, OS_LOG_TYPE_ERROR))
    {
      v6 = *(_QWORD *)(a1 + 8);
      if (*(_BYTE *)(v6 + 96))
      {
        sub_1D3DF4F6C((uint64_t)&buf, v6);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        memset(v282, 0, sizeof(v282));
        v283 = 0u;
      }
      sub_1D3DF53CC((CFErrorRef *)&t2, (uint64_t)&buf);
      v59 = atomic_load((unint64_t *)&t2);
      LODWORD(v291.a) = 138543362;
      *(_QWORD *)((char *)&v291.a + 4) = v59;
      v60 = "Cannot retrieve or instantiate ANMD model: %{public}@";
LABEL_100:
      _os_log_error_impl(&dword_1D3D6B000, v5, OS_LOG_TYPE_ERROR, v60, (uint8_t *)&v291, 0xCu);
      sub_1D3D7448C((unint64_t *)&t2);
      sub_1D3DF4F24((unint64_t *)&buf);
      return;
    }
    return;
  }
  v7 = *a2;
  v8 = *(unint64_t **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 24);
  v10 = **(double **)(a1 + 32);
  v265 = v10;
  v266 = 1;
  if (!*(_BYTE *)(v7 + 200)
    || (v11 = *(_QWORD *)(v7 + 264)) == 0
    || (v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11), (v12 & 1) == 0))
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v15 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_ERROR, "ANMDModel is not ready.", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    *(_QWORD *)&v291.a = CFSTR("ANMDModel is not ready.");
    sub_1D3D73E0C(v8, (uint64_t *)&buf, (CFTypeRef *)&v291);
    d_low = 0;
    LOBYTE(buf.a) = 0;
    LOBYTE(buf.d) = 0;
    goto LABEL_21;
  }
  v286[0] = &off_1E95B2D40;
  v287 = v286;
  v284[0] = &off_1E95B2DC0;
  v285 = v284;
  v290 = v289;
  v288 = &v265;
  v289[0] = &off_1E95B2DC0;
  buf.a = v10;
  sub_1D3DAD53C(v12, (os_signpost_id_t *)&buf);
  v13 = v285;
  if (v285 == v284)
  {
    v14 = 4;
    v13 = v284;
  }
  else
  {
    if (!v285)
      goto LABEL_53;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_53:
  v26 = v287;
  if (v287 == v286)
  {
    v27 = 4;
    v26 = v286;
    goto LABEL_57;
  }
  if (v287)
  {
    v27 = 5;
LABEL_57:
    (*(void (**)(void))(*v26 + 8 * v27))();
  }
  v28 = (uint64_t *)(v9 + 16);
  v29 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *(_OWORD *)&v271.a = *MEMORY[0x1E0C9BAA8];
  *(_OWORD *)&v271.c = v29;
  *(_OWORD *)&v271.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
  v30 = *(_QWORD **)(v9 + 72);
  if (v30 && (v31 = *(_QWORD *)(*(_QWORD *)(v9 + 72) + 8) - *v30) != 0)
  {
    v32 = v31 / 216;
    v33 = v32 - 1;
    v34 = 216 * v32 - 208;
    while (1)
    {
      if (*(_BYTE *)(v7 + 200))
      {
        v35 = *(_QWORD *)(v7 + 264);
        if (v35)
        {
          v36 = **(_QWORD **)(v9 + 72);
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35))
          {
            v37 = v36 + v34;
            if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v7 + 264) + 16))(*(_QWORD *)(v7 + 264), v36 + v34) & 1) != 0)break;
          }
        }
      }
      --v33;
      v34 -= 216;
      if (v33 == -1)
        goto LABEL_66;
    }
    v40 = 0;
    v63 = v36 + 216 * v33;
    v64 = *(_OWORD *)(v63 + 184);
    *(_OWORD *)&v271.a = *(_OWORD *)(v63 + 168);
    *(_OWORD *)&v271.c = v64;
    *(_OWORD *)&v271.tx = *(_OWORD *)(v63 + 200);
  }
  else
  {
LABEL_66:
    if (!*(_BYTE *)(v7 + 200)
      || (v38 = *(_QWORD *)(v7 + 264)) == 0
      || (v39 = *v28, !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v38 + 24))(v38))
      || !(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v7 + 264) + 16))(*(_QWORD *)(v7 + 264), v39))
    {
      LOBYTE(v37) = 0;
      v42 = 0;
      v40 = 1;
      goto LABEL_72;
    }
    v40 = 0;
    v41 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *(_OWORD *)&v271.a = *MEMORY[0x1E0C9BAA8];
    *(_OWORD *)&v271.c = v41;
    *(_OWORD *)&v271.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
    v37 = *v28;
  }
  v42 = v37 & 0xFFFFFFFFFFFFFF00;
LABEL_72:
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  v43 = qword_1EDB89F78;
  if (v40)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.a) = 138543362;
      *(_QWORD *)((char *)&buf.a + 4) = v28 - 2;
      _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "Unable to find any supported pixel buffer from MRCSample: %{public}@", (uint8_t *)&buf, 0xCu);
    }
    buf.a = NAN;
    *(_QWORD *)&v291.a = CFSTR("Unable to find any supported pixel buffer from MRCSample.");
    sub_1D3D73E0C(v8, (uint64_t *)&buf, (CFTypeRef *)&v291);
    d_low = 0;
    LOBYTE(buf.a) = 0;
    LOBYTE(buf.d) = 0;
    v44 = v289;
    goto LABEL_112;
  }
  v45 = v42 | v37;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
  {
    v67 = atomic_load((unint64_t *)v45);
    LODWORD(buf.a) = 138543362;
    *(_QWORD *)((char *)&buf.a + 4) = v67;
    _os_log_debug_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_DEBUG, "Found best pixel buffer: %{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (((*(uint64_t (**)(_QWORD, unint64_t, unint64_t *, CGFloat *))(**(_QWORD **)(v7 + 264)
                                                                                           + 40))(*(_QWORD *)(v7 + 264), v42 | v37, v8, &v265) & 1) == 0)
  {
    v44 = v289;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf.a) = 0;
      _os_log_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_INFO, "Failed to run image preprocessor.", (uint8_t *)&buf, 2u);
    }
    d_low = 0;
    LOBYTE(buf.a) = 0;
    LOBYTE(buf.d) = 0;
    goto LABEL_112;
  }
  v44 = v289;
  (*(void (**)(unint64_t *__return_ptr))(**(_QWORD **)(v7 + 264) + 48))(&v270);
  if (!atomic_load(&v270))
  {
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      goto LABEL_110;
    LOWORD(buf.a) = 0;
    v62 = "Failed to create input pixel buffer.";
LABEL_109:
    _os_log_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_INFO, v62, (uint8_t *)&buf, 2u);
    goto LABEL_110;
  }
  v47 = *(_QWORD *)(v7 + 208);
  v48 = (__CVBuffer *)atomic_load(&v270);
  IOSurface = CVPixelBufferGetIOSurface(v48);
  if (IOSurface)
    IOSurface = CFRetain(IOSurface);
  *(_QWORD *)&buf.a = IOSurface;
  v50 = sub_1D3D835F8(v47, (unint64_t *)&buf, (uint64_t)v8);
  sub_1D3D82B54((unint64_t *)&buf);
  if ((v50 & 1) == 0)
  {
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      goto LABEL_110;
    LOWORD(buf.a) = 0;
    v62 = "Failed to bind input surface.";
    goto LABEL_109;
  }
  v51 = v7 + 72;
  v52 = sub_1D3D87334(v7 + 72, (qos_class_t *)(v7 + 24), (uint64_t)v8, (uint64_t)&v265);
  if ((v52 & 1) == 0)
  {
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf.a) = 0;
      v62 = "Failed to execute.";
      goto LABEL_109;
    }
LABEL_110:
    d_low = 0;
    LOBYTE(buf.a) = 0;
    LOBYTE(buf.d) = 0;
    goto LABEL_111;
  }
  v256 = *(_QWORD *)(v7 + 232);
  oslog = v43;
  *(_OWORD *)log = *(_OWORD *)(v7 + 216);
  v255 = *(_QWORD *)(v7 + 264);
  v296[0] = &off_1E95ADB50;
  v297 = v296;
  v294[0] = &off_1E95ADBA8;
  v295 = v294;
  v53 = v299;
  v300 = v299;
  v298 = &v265;
  v299[0] = &off_1E95ADBA8;
  if (!v266 || (buf.a = v265, sub_1D3DAB93C(v52, (os_signpost_id_t *)&buf), v54 = v295, v295 == v294))
  {
    v56 = 4;
    v54 = v294;
    p_cache = &OBJC_METACLASS____MRCBase_DummyClass___.cache;
  }
  else
  {
    p_cache = (void **)(&OBJC_METACLASS____MRCBase_DummyClass___ + 16);
    if (!v295)
      goto LABEL_122;
    v56 = 5;
  }
  (*(void (**)(void))(*v54 + 8 * v56))();
LABEL_122:
  v68 = v297;
  if (v297 == v296)
  {
    v69 = 4;
    v68 = v296;
    goto LABEL_126;
  }
  if (v297)
  {
    v69 = 5;
LABEL_126:
    (*(void (**)(void))(*v68 + 8 * v69))();
  }
  isa = log[0][1].isa;
  if (*((_QWORD *)isa + 6) != 4 || *((_QWORD *)isa + 7) != 1 || *((_QWORD *)isa + 8) != 4)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v86 = p_cache[495];
    if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v86, OS_LOG_TYPE_ERROR, "Unexpected output.", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    *(_QWORD *)&v291.a = CFSTR("Unexpected output.");
    sub_1D3D73E0C(v8, (uint64_t *)&buf, (CFTypeRef *)&v291);
    goto LABEL_174;
  }
  v71 = log[1][1].isa;
  if (*((_QWORD *)v71 + 6) != 4
    || *((_QWORD *)v71 + 7) != 1
    || *((_QWORD *)v71 + 8) != 4
    || (v72 = *((_QWORD *)v71 + 9), v72 != *((_QWORD *)isa + 9))
    || (v73 = *((_QWORD *)v71 + 10), v73 != *((_QWORD *)isa + 10))
    || (v74 = *((_DWORD *)v71 + 4), v74 != *((_DWORD *)isa + 4))
    || (v75 = *((_DWORD *)v71 + 5), v75 != *((_DWORD *)isa + 5)))
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v87 = p_cache[495];
    if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v87, OS_LOG_TYPE_ERROR, "Unexpected output scores.", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    *(_QWORD *)&v291.a = CFSTR("Unexpected output scores.");
    sub_1D3D73E0C(v8, (uint64_t *)&buf, (CFTypeRef *)&v291);
LABEL_174:
    LOBYTE(v267) = 0;
    v269 = 0;
    goto LABEL_175;
  }
  v250 = log[1][1].isa;
  v76 = *(_QWORD *)(v256 + 8);
  if (*(_QWORD *)(v76 + 48) != 4
    || *(_QWORD *)(v76 + 56) != 1
    || *(_QWORD *)(v76 + 64) != 1
    || *(_QWORD *)(v76 + 72) != v72
    || *(_QWORD *)(v76 + 80) != v73
    || *(_DWORD *)(v76 + 16) != v74
    || *(_DWORD *)(v76 + 20) != v75)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v92 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v92, OS_LOG_TYPE_ERROR, "Unexpected output angles.", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    *(_QWORD *)&v291.a = CFSTR("Unexpected output angles.");
    sub_1D3D73E0C(v8, (uint64_t *)&buf, (CFTypeRef *)&v291);
    LOBYTE(v267) = 0;
    v269 = 0;
    goto LABEL_204;
  }
  v274 = 0;
  d = 0.0;
  __p = 0;
  if (*((_DWORD *)isa + 4) != 4)
    goto LABEL_205;
  v77 = *((_DWORD *)isa + 5);
  if (v77 == 6)
  {
    v94 = (CFTypeRef)atomic_load((unint64_t *)&log[0][3]);
    if (v94)
      v94 = CFRetain(v94);
    *(_QWORD *)&buf.a = v94;
    LOBYTE(buf.b) = 0;
    *(_DWORD *)((char *)&buf.b + 1) = LODWORD(t2.a);
    HIDWORD(buf.b) = *(_DWORD *)((char *)&t2.a + 3);
    LOBYTE(buf.c) = 0;
    *(_DWORD *)((char *)&buf.c + 1) = LODWORD(v293.a);
    HIDWORD(buf.c) = *(_DWORD *)((char *)&v293.a + 3);
    *(_QWORD *)&buf.d = v8;
    LOBYTE(buf.tx) = sub_1D3DD4C10((unint64_t *)&buf, (uint64_t)&buf.b, 1, (uint64_t)v8);
    v95 = (CFTypeRef)atomic_load((unint64_t *)&log[1][3]);
    if (v95)
      v95 = CFRetain(v95);
    *(_QWORD *)&v291.a = v95;
    LOBYTE(v291.b) = 0;
    *(_DWORD *)((char *)&v291.b + 1) = LODWORD(t2.a);
    HIDWORD(v291.b) = *(_DWORD *)((char *)&t2.a + 3);
    LOBYTE(v291.c) = 0;
    *(_DWORD *)((char *)&v291.c + 1) = LODWORD(v293.a);
    HIDWORD(v291.c) = *(_DWORD *)((char *)&v293.a + 3);
    *(_QWORD *)&v291.d = v8;
    LOBYTE(v291.tx) = sub_1D3DD4C10((unint64_t *)&v291, (uint64_t)&v291.b, 1, (uint64_t)v8);
    v96 = (CFTypeRef)atomic_load((unint64_t *)(v256 + 24));
    if (v96)
      v96 = CFRetain(v96);
    *(_QWORD *)&t2.a = v96;
    LOBYTE(t2.b) = 0;
    *(_DWORD *)((char *)&t2.b + 1) = LODWORD(v293.a);
    HIDWORD(t2.b) = *(_DWORD *)((char *)&v293.a + 3);
    LOBYTE(t2.c) = 0;
    *(_DWORD *)((char *)&t2.c + 1) = LODWORD(v272.a);
    HIDWORD(t2.c) = *(_DWORD *)((char *)&v272.a + 3);
    *(_QWORD *)&t2.d = v8;
    v97 = sub_1D3DD4C10((unint64_t *)&t2, (uint64_t)&t2.b, 1, (uint64_t)v8);
    LOBYTE(t2.tx) = v97;
    if (LOBYTE(buf.tx))
      v98 = LOBYTE(v291.tx) == 0;
    else
      v98 = 1;
    v99 = v97 ^ 1;
    if (v98)
      v99 = 1;
    v219 = v99;
    if (v99 == 1)
    {
      if (qword_1EDB89F20 != -1)
        dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
      v100 = qword_1EDB89F78;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
      {
        v101 = *((_DWORD *)v8 + 14);
        LODWORD(v293.a) = 67240192;
        HIDWORD(v293.a) = v101;
        _os_log_error_impl(&dword_1D3D6B000, v100, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", (uint8_t *)&v293, 8u);
      }
    }
    else
    {
      v130 = (__IOSurface *)atomic_load((unint64_t *)&log[0][3]);
      BaseAddress = IOSurfaceGetBaseAddress(v130);
      v132 = (__IOSurface *)atomic_load((unint64_t *)&log[1][3]);
      v254 = (float *)IOSurfaceGetBaseAddress(v132);
      v133 = (__IOSurface *)atomic_load((unint64_t *)(v256 + 24));
      v247 = (float *)IOSurfaceGetBaseAddress(v133);
      v227 = v250[9];
      if (v227)
      {
        v229 = 0;
        v134 = *((_QWORD *)isa + 4);
        v241 = *((_QWORD *)isa + 15) / v134;
        v225 = *((_QWORD *)isa + 14) / v134;
        v135 = *((_QWORD *)isa + 13) / v134;
        v243 = v250[10];
        v258 = v250[8];
        v136 = v250[4];
        v239 = v250[15] / v136;
        v223 = v250[14] / v136;
        v252 = v250[13] / v136;
        v137 = *(_QWORD *)(v76 + 32);
        v237 = *(_QWORD *)(v76 + 120) / v137;
        v233 = 2 * v135;
        v235 = v135;
        v231 = 3 * v135;
        v221 = *(_QWORD *)(v76 + 112) / v137;
        do
        {
          if (v243)
          {
            v244 = 0;
            v249 = v229 * v221;
            logb = v229 * v223;
            v138 = v229 * v225;
            do
            {
              if (v258)
              {
                for (i = 0; i != v258; ++i)
                {
                  v140 = v254[logb + i * v252];
                  if (v140 > 0.1)
                  {
                    v141 = v247[v249];
                    if (fabsf(v141) == INFINITY)
                    {
                      if (qword_1EDB89F20 != -1)
                        dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
                      v142 = qword_1EDB89F78;
                      if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_INFO))
                      {
                        LODWORD(v293.a) = 134349056;
                        *(double *)((char *)&v293.a + 4) = v141;
                        _os_log_impl(&dword_1D3D6B000, v142, OS_LOG_TYPE_INFO, "Predicted orientation is inf or nan: %{public}f", (uint8_t *)&v293, 0xCu);
                      }
                    }
                    else
                    {
                      LODWORD(v293.a) = BaseAddress[v138];
                      LODWORD(v272.a) = BaseAddress[v138 + v235];
                      v280 = BaseAddress[v138 + v233];
                      v279 = BaseAddress[v138 + v231];
                      v278 = sqrtf(v140);
                      v143 = -v141;
                      if (v141 > 0.0)
                        v144 = 2.0;
                      else
                        v144 = -2.0;
                      if (v141 > 1.0 || v141 < -1.0)
                      {
                        do
                        {
                          do
                            v143 = v144 + v143;
                          while (v143 < -1.0);
                        }
                        while (v143 > 1.0);
                      }
                      v277 = v143 * 90.0;
                      v276 = i;
                      sub_1D3DAC930((char **)&__p, &v293, (int *)&v272, &v280, &v279, (int *)&v278, (int *)&v277, &v276);
                    }
                  }
                }
              }
              v138 += v241;
              logb += v239;
              v249 += v237;
              ++v244;
            }
            while (v244 != v243);
          }
          ++v229;
        }
        while (v229 != v227);
      }
    }
    if (LOBYTE(t2.tx))
      LOBYTE(t2.tx) = sub_1D3DD4E7C((unint64_t *)&t2, (uint64_t)&t2.b, 1, *(uint64_t *)&t2.d) ^ 1;
    sub_1D3D82B54((unint64_t *)&t2);
    if (LOBYTE(v291.tx))
      LOBYTE(v291.tx) = sub_1D3DD4E7C((unint64_t *)&v291, (uint64_t)&v291.b, 1, *(uint64_t *)&v291.d) ^ 1;
    sub_1D3D82B54((unint64_t *)&v291);
    if (LOBYTE(buf.tx))
      LOBYTE(buf.tx) = sub_1D3DD4E7C((unint64_t *)&buf, (uint64_t)&buf.b, 1, *(uint64_t *)&buf.d) ^ 1;
    sub_1D3D82B54((unint64_t *)&buf);
    if (v219)
      goto LABEL_260;
LABEL_294:
    v145 = (char *)__p;
    v146 = v274;
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    logc = qword_1EDB89F78;
    if (v145 == v146)
    {
      if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf.a) = 0;
        _os_log_impl(&dword_1D3D6B000, logc, OS_LOG_TYPE_INFO, "No candidate with scores above pre-NMS-thresholds has been found.", (uint8_t *)&buf, 2u);
      }
      v267 = 0uLL;
      v268 = 0.0;
      v269 = 1;
      goto LABEL_211;
    }
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf.a) = 134349056;
      *(_QWORD *)((char *)&buf.a + 4) = 0x6DB6DB6DB6DB6DB7 * ((v146 - v145) >> 2);
      _os_log_debug_impl(&dword_1D3D6B000, logc, OS_LOG_TYPE_DEBUG, "%{public}zu candidate(s) with scores above pre-NMS-thresholds has/have been found.", (uint8_t *)&buf, 0xCu);
    }
    v147 = *(double *)&__p;
    if (__p != v274)
    {
      sub_1D3DABA70((uint64_t)__p, v274, 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * ((v274 - (_BYTE *)__p) >> 2)), 1);
      v148 = (char *)__p;
      v147 = *(double *)&v274;
      v149 = 0x6DB6DB6DB6DB6DB7 * ((v274 - (_BYTE *)__p) >> 2);
      if (v274 == __p)
      {
        v169 = 0;
        v148 = v274;
      }
      else
      {
        v150 = 0;
        v151 = (float *)((char *)__p + 52);
        v152 = -1;
        v153 = 0x6DB6DB6DB6DB6DB7 * ((v274 - (_BYTE *)__p) >> 2);
        while (1)
        {
          v154 = v150 + 1;
          if (v150 + 1 >= v153)
            break;
          v155 = &v148[28 * v150];
          v156 = (float *)(v155 + 4);
          v157 = (float *)(v155 + 8);
          v158 = (float *)(v155 + 12);
          v159 = v153 + v152;
          v160 = v151;
          v153 = v154;
          do
          {
            if (*((_DWORD *)v155 + 6) != *(_DWORD *)v160
              || (v161 = *(v160 - 6),
                  v162 = *(v160 - 5),
                  v163 = *(v160 - 4),
                  v164 = *(v160 - 3),
                  v165 = fmax((float)(fminf(*v157, v163) - fmaxf(*(float *)v155, v161)), 0.0),
                  v166 = fmax((float)(fminf(*v158, v164) - fmaxf(*v156, v162)), 0.0),
                  (float)((float)(v165 * v166)
                        / (float)((float)((float)((float)(v163 - v161) * (float)(v164 - v162))
                                        + (float)((float)(*v157 - *(float *)v155) * (float)(*v158 - *v156)))
                                - (float)(v165 * v166))) <= 0.5))
            {
              v167 = &v148[28 * v153];
              v168 = *(_OWORD *)(v160 - 6);
              ++v153;
              *(_OWORD *)(v167 + 12) = *(_OWORD *)(v160 - 3);
              *(_OWORD *)v167 = v168;
            }
            v160 += 7;
            --v159;
          }
          while (v159);
          v151 += 7;
          --v152;
          v150 = v154;
          if (v154 >= v153)
          {
            v169 = v149;
            v149 = v153;
            goto LABEL_315;
          }
        }
        v169 = v149;
        v149 = v150 + 1;
      }
LABEL_315:
      v170 = v149 - v169;
      if (v149 > v169)
      {
        if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)&d - *(_QWORD *)&v147) >> 2) < v170)
        {
          if (v149 > 0x924924924924924)
            sub_1D3D6D4F8();
          v171 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)&d - (_QWORD)v148) >> 2);
          if (2 * v171 > v149)
            v149 = 2 * v171;
          if (v171 >= 0x492492492492492)
            v172 = 0x924924924924924;
          else
            v172 = v149;
          sub_1D3DAC3A8(&buf, v172, v169, (uint64_t)&d);
          c = buf.c;
          bzero(*(void **)&buf.c, 28 * ((28 * v170 - 28) / 0x1C) + 28);
          *(_QWORD *)&v147 = *(_QWORD *)&c + 28 * ((28 * v170 - 28) / 0x1C) + 28;
          buf.c = v147;
          v174 = (char *)__p;
          v175 = v274;
          b = buf.b;
          if (v274 == __p)
          {
            v174 = v274;
          }
          else
          {
            v177 = v274;
            do
            {
              v178 = *(_OWORD *)(v177 - 28);
              *(_OWORD *)(*(_QWORD *)&b - 16) = *((_OWORD *)v177 - 1);
              *(_OWORD *)(*(_QWORD *)&b - 28) = v178;
              *(_QWORD *)&b -= 28;
              v177 -= 28;
            }
            while (v177 != v174);
            v147 = buf.c;
          }
          __p = *(void **)&b;
          v274 = *(char **)&v147;
          v179 = d;
          d = buf.d;
          *(_QWORD *)&buf.c = v175;
          buf.d = v179;
          *(_QWORD *)&buf.b = v174;
          *(_QWORD *)&buf.a = v174;
          if (v175 != v174)
            *(_QWORD *)&buf.c = &v174[(v175 - v174 - 28) % 0x1CuLL];
          if (v174)
          {
            operator delete(v174);
            v147 = *(double *)&v274;
          }
          goto LABEL_336;
        }
        bzero(*(void **)&v147, 28 * ((28 * v170 - 28) / 0x1C) + 28);
        *(_QWORD *)&v147 += 28 * ((28 * v170 - 28) / 0x1C) + 28;
        goto LABEL_330;
      }
      if (v149 < v169)
      {
        *(_QWORD *)&v147 = &v148[28 * v149];
LABEL_330:
        v274 = *(char **)&v147;
      }
    }
LABEL_336:
    v180 = (char *)__p;
    if (__p != *(void **)&v147)
    {
      while (*((float *)v180 + 4) >= flt_1D3E82230[*((unsigned int *)v180 + 6)])
      {
        v180 += 28;
        if (v180 == *(char **)&v147)
          goto LABEL_346;
      }
      if (v180 != *(char **)&v147)
      {
        for (j = v180 + 28; j != *(char **)&v147; j += 28)
        {
          if (*((float *)j + 4) >= flt_1D3E82230[*((unsigned int *)j + 6)])
          {
            v182 = *(_OWORD *)j;
            *(_OWORD *)(v180 + 12) = *(_OWORD *)(j + 12);
            *(_OWORD *)v180 = v182;
            v180 += 28;
          }
        }
      }
    }
LABEL_346:
    v183 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
    v184 = *MEMORY[0x1E0C9BAA8];
    *(_OWORD *)&v293.c = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *(_OWORD *)&v293.tx = v183;
    *(_OWORD *)&v293.a = v184;
    if (*(_BYTE *)(v255 + 28))
    {
      v185 = (double)*(unint64_t *)(v255 + 32) * 0.5;
      v186 = (double)*(unint64_t *)(v255 + 40) * 0.5;
      CGAffineTransformMakeTranslation(&v272, -v185, -v186);
      v187 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
      *(_OWORD *)&v291.a = *MEMORY[0x1E0C9BAA8];
      *(_OWORD *)&v291.c = v187;
      *(_OWORD *)&v291.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
      t2 = v272;
      CGAffineTransformConcat(&buf, &v291, &t2);
      v293 = buf;
      CGAffineTransformMakeRotation(&v272, -1.57079633);
      v291 = v293;
      t2 = v272;
      CGAffineTransformConcat(&buf, &v291, &t2);
      v293 = buf;
      CGAffineTransformMakeTranslation(&v272, v186, v185);
      v291 = v293;
      t2 = v272;
      CGAffineTransformConcat(&buf, &v291, &t2);
      v293 = buf;
    }
    Width = CGRectGetWidth(*(CGRect *)(v45 + 8));
    v189 = Width / CGRectGetHeight(*(CGRect *)(v45 + 8));
    if (*(_BYTE *)(v255 + 28))
      v190 = (double)*(unint64_t *)(v255 + 16);
    else
      v190 = (double)*(unint64_t *)(v255 + 8);
    if (*(_BYTE *)(v255 + 28))
      v191 = (double)*(unint64_t *)(v255 + 8);
    else
      v191 = (double)*(unint64_t *)(v255 + 16);
    v192 = *(_QWORD *)(v45 + 8);
    v193 = *(_QWORD *)(v45 + 16);
    v194 = *(_QWORD *)(v45 + 24);
    v195 = *(_QWORD *)(v45 + 32);
    if (v189 >= v190 / v191)
      v196 = CGRectGetWidth(*(CGRect *)&v192) / v190;
    else
      v196 = CGRectGetHeight(*(CGRect *)&v192) / v191;
    CGAffineTransformMakeScale(&v272, v196, v196);
    v291 = v293;
    t2 = v272;
    CGAffineTransformConcat(&buf, &v291, &t2);
    v293 = buf;
    v291 = buf;
    t2 = v271;
    CGAffineTransformConcat(&buf, &v291, &t2);
    v293 = buf;
    memset(&v272, 0, 24);
    sub_1D3DAB9DC((uint64_t *)&v272, 0x6DB6DB6DB6DB6DB7 * ((v274 - (_BYTE *)__p) >> 2));
    *(_QWORD *)&t2.a = CFSTR("Pseudo1D");
    *(_QWORD *)&t2.b = CFSTR("Pseudo2D");
    *(_QWORD *)&t2.c = CFSTR("PseudoPDF417");
    *(_QWORD *)&t2.d = CFSTR("PseudoExternal");
    v197 = (char *)__p;
    v259 = v274;
    if (__p != v274)
    {
      do
      {
        *(float64x2_t *)&v291.a = vcvtq_f64_f32(*(float32x2_t *)v197);
        v198 = *((float *)v197 + 3);
        v291.c = *(float *)v197;
        v291.d = v198;
        *(float64x2_t *)&v291.tx = vcvtq_f64_f32(*(float32x2_t *)(v197 + 8));
        v199 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)(v197 + 4));
        v292 = vextq_s8(v199, v199, 8uLL);
        if (os_log_type_enabled(logc, OS_LOG_TYPE_DEBUG))
        {
          v211 = *((_DWORD *)v197 + 6);
          v212 = *((float *)v197 + 4);
          v213 = *((float *)v197 + 1);
          v214 = *(float *)v197;
          v215 = *((float *)v197 + 3) - v213;
          v216 = (float)(*((float *)v197 + 2) - *(float *)v197);
          v217 = *((float *)v197 + 5);
          LODWORD(buf.a) = 67241728;
          HIDWORD(buf.a) = v211;
          LOWORD(buf.b) = 2050;
          *(double *)((char *)&buf.b + 2) = v212;
          WORD1(buf.c) = 2050;
          *(double *)((char *)&buf.c + 4) = v214;
          WORD2(buf.d) = 2050;
          *(double *)((char *)&buf.d + 6) = v213;
          HIWORD(buf.tx) = 2050;
          buf.ty = v216;
          LOWORD(v282[0]) = 2050;
          *(double *)((char *)v282 + 2) = v215;
          WORD5(v282[0]) = 2050;
          *(double *)((char *)v282 + 12) = v217;
          _os_log_debug_impl(&dword_1D3D6B000, logc, OS_LOG_TYPE_DEBUG, "class=%{public}u | score=%{public}f | x=%{public}f, y=%{public}f, width=%{public}f, height=%{public}f | angle=%{public}f", (uint8_t *)&buf, 0x44u);
        }
        v200 = *((unsigned int *)v197 + 6);
        if (v200 >= 4)
        {
          if (os_log_type_enabled(logc, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf.a) = 67240192;
            HIDWORD(buf.a) = v200;
            _os_log_error_impl(&dword_1D3D6B000, logc, OS_LOG_TYPE_ERROR, "Invalid coarse class id: %{public}u, skipping...", (uint8_t *)&buf, 8u);
          }
        }
        else
        {
          v201 = (const void *)MRCRegionCreate((__int128 *)&v291, (__int128 *)&v293, *((const void **)&t2.a + v200), *((float *)v197 + 5), *((float *)v197 + 4));
          v202 = v201;
          if (v201)
          {
            v203 = CFGetTypeID(v201);
            if (qword_1EDB89308 != -1)
              dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
            if (v203 != qword_1EDB89320)
              _os_assumes_log();
          }
          v204 = v272.b;
          if (*(_QWORD *)&v272.b >= *(_QWORD *)&v272.c)
          {
            v206 = (uint64_t)(*(_QWORD *)&v272.b - *(_QWORD *)&v272.a) >> 3;
            if ((unint64_t)(v206 + 1) >> 61)
              sub_1D3D6D4F8();
            v207 = (uint64_t)(*(_QWORD *)&v272.c - *(_QWORD *)&v272.a) >> 2;
            if (v207 <= v206 + 1)
              v207 = v206 + 1;
            if (*(_QWORD *)&v272.c - *(_QWORD *)&v272.a >= 0x7FFFFFFFFFFFFFF8uLL)
              v208 = 1.49166815e-154;
            else
              v208 = *(double *)&v207;
            *(_QWORD *)&buf.tx = &v272.c;
            if (v208 == 0.0)
              v209 = 0;
            else
              v208 = COERCE_DOUBLE(sub_1D3D6D8A0(*(unint64_t *)&v208));
            v210 = (_QWORD *)(*(_QWORD *)&v208 + 8 * v206);
            buf.a = v208;
            *(_QWORD *)&buf.b = v210;
            *(_QWORD *)&buf.d = *(_QWORD *)&v208 + 8 * v209;
            *v210 = v202;
            *(_QWORD *)&buf.c = v210 + 1;
            sub_1D3D742F0((uint64_t *)&v272, &buf);
            v205 = v272.b;
            sub_1D3D743C8((uint64_t)&buf);
          }
          else
          {
            **(_QWORD **)&v272.b = v202;
            *(_QWORD *)&v205 = *(_QWORD *)&v204 + 8;
          }
          v272.b = v205;
        }
        v197 += 28;
      }
      while (v197 != v259);
    }
    v267 = *(_OWORD *)&v272.a;
    v268 = v272.c;
    memset(&v272, 0, 24);
    v269 = 1;
    *(_QWORD *)&buf.a = &v272;
    sub_1D3D74170((void ***)&buf);
    goto LABEL_211;
  }
  if (v77 != 3)
  {
LABEL_205:
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v93 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v93, OS_LOG_TYPE_ERROR, "Unsupported output tensor data type", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    *(_QWORD *)&v291.a = CFSTR("Unsupported output tensor data type.");
    sub_1D3D73E0C(v8, (uint64_t *)&buf, (CFTypeRef *)&v291);
    goto LABEL_210;
  }
  v78 = (CFTypeRef)atomic_load((unint64_t *)&log[0][3]);
  if (v78)
    v78 = CFRetain(v78);
  *(_QWORD *)&buf.a = v78;
  LOBYTE(buf.b) = 0;
  *(_DWORD *)((char *)&buf.b + 1) = LODWORD(t2.a);
  HIDWORD(buf.b) = *(_DWORD *)((char *)&t2.a + 3);
  LOBYTE(buf.c) = 0;
  *(_DWORD *)((char *)&buf.c + 1) = LODWORD(v293.a);
  HIDWORD(buf.c) = *(_DWORD *)((char *)&v293.a + 3);
  *(_QWORD *)&buf.d = v8;
  LOBYTE(buf.tx) = sub_1D3DD4C10((unint64_t *)&buf, (uint64_t)&buf.b, 1, (uint64_t)v8);
  v79 = (CFTypeRef)atomic_load((unint64_t *)&log[1][3]);
  if (v79)
    v79 = CFRetain(v79);
  *(_QWORD *)&v291.a = v79;
  LOBYTE(v291.b) = 0;
  *(_DWORD *)((char *)&v291.b + 1) = LODWORD(t2.a);
  HIDWORD(v291.b) = *(_DWORD *)((char *)&t2.a + 3);
  LOBYTE(v291.c) = 0;
  *(_DWORD *)((char *)&v291.c + 1) = LODWORD(v293.a);
  HIDWORD(v291.c) = *(_DWORD *)((char *)&v293.a + 3);
  *(_QWORD *)&v291.d = v8;
  LOBYTE(v291.tx) = sub_1D3DD4C10((unint64_t *)&v291, (uint64_t)&v291.b, 1, (uint64_t)v8);
  v80 = (CFTypeRef)atomic_load((unint64_t *)(v256 + 24));
  if (v80)
    v80 = CFRetain(v80);
  *(_QWORD *)&t2.a = v80;
  LOBYTE(t2.b) = 0;
  *(_DWORD *)((char *)&t2.b + 1) = LODWORD(v293.a);
  HIDWORD(t2.b) = *(_DWORD *)((char *)&v293.a + 3);
  LOBYTE(t2.c) = 0;
  *(_DWORD *)((char *)&t2.c + 1) = LODWORD(v272.a);
  HIDWORD(t2.c) = *(_DWORD *)((char *)&v272.a + 3);
  *(_QWORD *)&t2.d = v8;
  v81 = sub_1D3DD4C10((unint64_t *)&t2, (uint64_t)&t2.b, 1, (uint64_t)v8);
  LOBYTE(t2.tx) = v81;
  if (LOBYTE(buf.tx))
    v82 = LOBYTE(v291.tx) == 0;
  else
    v82 = 1;
  v83 = v81 ^ 1;
  if (v82)
    v83 = 1;
  v218 = v83;
  if (v83 == 1)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v84 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      v85 = *((_DWORD *)v8 + 14);
      LODWORD(v293.a) = 67240192;
      HIDWORD(v293.a) = v85;
      _os_log_error_impl(&dword_1D3D6B000, v84, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", (uint8_t *)&v293, 8u);
    }
  }
  else
  {
    v102 = (__IOSurface *)atomic_load((unint64_t *)&log[0][3]);
    v245 = IOSurfaceGetBaseAddress(v102);
    v103 = (__IOSurface *)atomic_load((unint64_t *)&log[1][3]);
    v253 = IOSurfaceGetBaseAddress(v103);
    v104 = (__IOSurface *)atomic_load((unint64_t *)(v256 + 24));
    v246 = IOSurfaceGetBaseAddress(v104);
    v226 = v250[9];
    if (v226)
    {
      v228 = 0;
      v105 = *((_QWORD *)isa + 4);
      v240 = *((_QWORD *)isa + 15) / v105;
      v224 = *((_QWORD *)isa + 14) / v105;
      v106 = *((_QWORD *)isa + 13) / v105;
      v242 = v250[10];
      v257 = v250[8];
      v107 = v250[4];
      v238 = v250[15] / v107;
      v222 = v250[14] / v107;
      v251 = v250[13] / v107;
      v108 = *(_QWORD *)(v76 + 32);
      v236 = *(_QWORD *)(v76 + 120) / v108;
      v232 = 2 * v106;
      v234 = v106;
      v230 = 3 * v106;
      HIWORD(_S0) = 2050;
      v220 = *(_QWORD *)(v76 + 112) / v108;
      do
      {
        if (v242)
        {
          v110 = 0;
          v248 = v228 * v220;
          loga = v228 * v222;
          v111 = v228 * v224;
          do
          {
            if (v257)
            {
              for (k = 0; k != v257; ++k)
              {
                _H0 = v253[loga + k * v251];
                __asm { FCVT            S1, H0 }
                if (_S1 > 0.099976)
                {
                  LOWORD(_S0) = v246[v248];
                  if ((~_S0 & 0x7C00) != 0)
                  {
                    _H2 = v245[v111];
                    __asm { FCVT            S2, H2 }
                    LODWORD(v293.a) = _S2;
                    LOWORD(_S2) = v245[v111 + v234];
                    __asm { FCVT            S2, H2 }
                    LODWORD(v272.a) = _S2;
                    LOWORD(_S2) = v245[v111 + v232];
                    __asm { FCVT            S2, H2 }
                    v280 = _S2;
                    LOWORD(_S2) = v245[v111 + v230];
                    __asm { FCVT            S2, H2 }
                    v279 = _S2;
                    v278 = sqrtf(_S1);
                    __asm { FCVT            S2, H0 }
                    v127 = -_S2;
                    if (_S2 > 0.0)
                      v128 = 2.0;
                    else
                      v128 = -2.0;
                    if (_S2 > 1.0 || _S2 < -1.0)
                    {
                      do
                      {
                        do
                          v127 = v128 + v127;
                        while (v127 < -1.0);
                      }
                      while (v127 > 1.0);
                    }
                    v277 = v127 * 90.0;
                    v276 = k;
                    sub_1D3DAC930((char **)&__p, &v293, (int *)&v272, &v280, &v279, (int *)&v278, (int *)&v277, &v276);
                  }
                  else
                  {
                    _H13 = v246[v248];
                    if (qword_1EDB89F20 != -1)
                      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
                    v119 = qword_1EDB89F78;
                    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_INFO))
                    {
                      __asm { FCVT            D0, H13 }
                      LODWORD(v293.a) = 134349056;
                      *(_QWORD *)((char *)&v293.a + 4) = _D0;
                      _os_log_impl(&dword_1D3D6B000, v119, OS_LOG_TYPE_INFO, "Predicted orientation is inf or nan: %{public}f", (uint8_t *)&v293, 0xCu);
                    }
                  }
                }
              }
            }
            v111 += v240;
            loga += v238;
            v248 += v236;
            ++v110;
          }
          while (v110 != v242);
        }
        ++v228;
      }
      while (v228 != v226);
    }
  }
  if (LOBYTE(t2.tx))
    LOBYTE(t2.tx) = sub_1D3DD4E7C((unint64_t *)&t2, (uint64_t)&t2.b, 1, *(uint64_t *)&t2.d) ^ 1;
  sub_1D3D82B54((unint64_t *)&t2);
  if (LOBYTE(v291.tx))
    LOBYTE(v291.tx) = sub_1D3DD4E7C((unint64_t *)&v291, (uint64_t)&v291.b, 1, *(uint64_t *)&v291.d) ^ 1;
  sub_1D3D82B54((unint64_t *)&v291);
  if (LOBYTE(buf.tx))
    LOBYTE(buf.tx) = sub_1D3DD4E7C((unint64_t *)&buf, (uint64_t)&buf.b, 1, *(uint64_t *)&buf.d) ^ 1;
  sub_1D3D82B54((unint64_t *)&buf);
  if ((v218 & 1) == 0)
    goto LABEL_294;
LABEL_260:
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  v129 = qword_1EDB89F78;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf.a) = 0;
    _os_log_impl(&dword_1D3D6B000, v129, OS_LOG_TYPE_INFO, "Failed to collect det boxes.", (uint8_t *)&buf, 2u);
  }
LABEL_210:
  LOBYTE(v267) = 0;
  v269 = 0;
LABEL_211:
  if (__p)
  {
    v274 = (char *)__p;
    operator delete(__p);
  }
LABEL_204:
  v44 = v289;
  v51 = v7 + 72;
  v53 = v299;
LABEL_175:
  v88 = v300;
  if (*((_BYTE *)v298 + 8))
  {
    if (!v300)
      goto LABEL_183;
    buf.a = *v298;
    (*(void (**)(void))(*v300 + 48))();
    v88 = v300;
  }
  if (v88 == v299)
  {
    v89 = 4;
  }
  else
  {
    if (!v88)
      goto LABEL_183;
    v89 = 5;
    v53 = v88;
  }
  (*(void (**)(_QWORD *))(*v53 + 8 * v89))(v53);
LABEL_183:
  if (!v269)
  {
    v90 = oslog;
    if (!os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
      goto LABEL_195;
    LOWORD(buf.a) = 0;
    v91 = "Failed to run postprocessor.";
LABEL_194:
    _os_log_impl(&dword_1D3D6B000, v90, OS_LOG_TYPE_INFO, v91, (uint8_t *)&buf, 2u);
    goto LABEL_195;
  }
  v90 = oslog;
  if (!sub_1D3D87F0C(v51, (uint64_t)v8))
  {
    if (!os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
      goto LABEL_195;
    LOWORD(buf.a) = 0;
    v91 = "Failed to reset network.";
    goto LABEL_194;
  }
  if (!sub_1D3D83A2C(*(_QWORD **)(v7 + 208), (uint64_t)v8))
  {
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf.a) = 0;
      v91 = "Failed to unbind input surface.";
      goto LABEL_194;
    }
LABEL_195:
    d_low = 0;
    LOBYTE(buf.a) = 0;
    LOBYTE(buf.d) = 0;
LABEL_196:
    if (v269)
    {
      *(_QWORD *)&v291.a = &v267;
      sub_1D3D74170((void ***)&v291);
    }
    goto LABEL_111;
  }
  LOBYTE(buf.a) = 0;
  LOBYTE(buf.d) = 0;
  if (v269)
  {
    *(_OWORD *)&buf.a = v267;
    buf.c = v268;
    v268 = 0.0;
    v267 = 0uLL;
    d_low = 1;
    LOBYTE(buf.d) = 1;
    goto LABEL_196;
  }
  d_low = 0;
LABEL_111:
  sub_1D3D74EDC(&v270);
LABEL_112:
  v65 = v290;
  if (*((_BYTE *)v288 + 8))
  {
    if (!v290)
      goto LABEL_21;
    v291.a = *v288;
    (*(void (**)(void))(*v290 + 48))();
    v65 = v290;
  }
  if (v65 == v289)
  {
    v66 = 4;
  }
  else
  {
    if (!v65)
      goto LABEL_21;
    v66 = 5;
    v44 = v65;
  }
  (*(void (**)(_QWORD *))(*v44 + 8 * v66))(v44);
  d_low = LOBYTE(buf.d);
LABEL_21:
  v17 = *(_QWORD *)(a1 + 16);
  if (*(unsigned __int8 *)(v17 + 24) != d_low)
  {
    if (!*(_BYTE *)(v17 + 24))
    {
      *(_OWORD *)v17 = *(_OWORD *)&buf.a;
      *(CGFloat *)(v17 + 16) = buf.c;
      memset(&buf, 0, 24);
      *(_BYTE *)(v17 + 24) = 1;
      if (!d_low)
        goto LABEL_34;
      goto LABEL_33;
    }
    v291.a = *(CGFloat *)(a1 + 16);
    sub_1D3D74170((void ***)&v291);
    *(_BYTE *)(v17 + 24) = 0;
    goto LABEL_32;
  }
  if (!*(_BYTE *)(v17 + 24))
  {
LABEL_32:
    if (!d_low)
      goto LABEL_34;
LABEL_33:
    *(_QWORD *)&v291.a = &buf;
    sub_1D3D74170((void ***)&v291);
    goto LABEL_34;
  }
  v18 = *(unint64_t **)v17;
  if (*(_QWORD *)v17)
  {
    v19 = *(unint64_t **)(v17 + 8);
    v20 = *(unint64_t **)v17;
    if (v19 != v18)
    {
      do
        v19 = sub_1D3D78858(v19 - 1);
      while (v19 != v18);
      v20 = *(unint64_t **)v17;
      d_low = LOBYTE(buf.d);
    }
    *(_QWORD *)(v17 + 8) = v18;
    operator delete(v20);
    *(_QWORD *)v17 = 0;
    *(_QWORD *)(v17 + 8) = 0;
    *(_QWORD *)(v17 + 16) = 0;
  }
  *(_OWORD *)v17 = *(_OWORD *)&buf.a;
  *(CGFloat *)(v17 + 16) = buf.c;
  memset(&buf, 0, 24);
  if (d_low)
    goto LABEL_33;
LABEL_34:
  v21 = *(uint64_t **)(a1 + 16);
  if (*((_BYTE *)v21 + 24) && !*(_BYTE *)(*(_QWORD *)(a1 + 8) + 96))
  {
    if (qword_1EDB89FA0 != -1)
      dispatch_once(&qword_1EDB89FA0, &unk_1E95B04B0);
    v22 = qword_1EDB89FA8;
    if (os_log_type_enabled((os_log_t)qword_1EDB89FA8, OS_LOG_TYPE_INFO))
    {
      v23 = (v21[1] - *v21) >> 3;
      LODWORD(buf.a) = 134349056;
      *(_QWORD *)((char *)&buf.a + 4) = v23;
      _os_log_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_INFO, "ANMD inference yields %{public}zu region(s).", (uint8_t *)&buf, 0xCu);
      v21 = *(uint64_t **)(a1 + 16);
    }
    v24 = *(_QWORD *)(a1 + 40);
    if (*(unsigned __int8 *)(v24 + 16) == *((unsigned __int8 *)v21 + 24))
    {
      if (*(_BYTE *)(v24 + 16))
      {
        v25 = (v21[1] - *v21) >> 3;
        *(_QWORD *)v24 = *v21;
        *(_QWORD *)(v24 + 8) = v25;
      }
    }
    else if (*(_BYTE *)(v24 + 16))
    {
      *(_BYTE *)(v24 + 16) = 0;
    }
    else
    {
      v58 = *v21;
      *(_QWORD *)v24 = *v21;
      *(_QWORD *)(v24 + 8) = (v21[1] - v58) >> 3;
      *(_BYTE *)(v24 + 16) = 1;
    }
  }
  else
  {
    if (qword_1EDB89FA0 != -1)
      dispatch_once(&qword_1EDB89FA0, &unk_1E95B04B0);
    v5 = qword_1EDB89FA8;
    if (os_log_type_enabled((os_log_t)qword_1EDB89FA8, OS_LOG_TYPE_ERROR))
    {
      v57 = *(_QWORD *)(a1 + 8);
      if (*(_BYTE *)(v57 + 96))
      {
        sub_1D3DF4F6C((uint64_t)&buf, v57);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        memset(v282, 0, sizeof(v282));
        v283 = 0u;
      }
      sub_1D3DF53CC((CFErrorRef *)&t2, (uint64_t)&buf);
      v61 = atomic_load((unint64_t *)&t2);
      LODWORD(v291.a) = 138543362;
      *(_QWORD *)((char *)&v291.a + 4) = v61;
      v60 = "Cannot run ANMD inference: %{public}@";
      goto LABEL_100;
    }
  }
}

void sub_1D3D7B73C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,_QWORD *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,_QWORD *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,unint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  uint64_t a68;
  uint64_t v68;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;

  if (__p)
  {
    a68 = (uint64_t)__p;
    operator delete(__p);
  }
  v70 = *(_QWORD *)(v68 - 248);
  v71 = *(_QWORD **)(v68 - 216);
  if (*(_BYTE *)(v70 + 8))
  {
    if (!v71)
      goto LABEL_11;
    STACK[0x2D0] = *(_QWORD *)v70;
    (*(void (**)(_QWORD *, unint64_t *))(*v71 + 48))(v71, &STACK[0x2D0]);
    v71 = *(_QWORD **)(v68 - 216);
  }
  if (v71 == a22)
  {
    v72 = 4;
  }
  else
  {
    if (!v71)
      goto LABEL_11;
    v72 = 5;
    a22 = v71;
  }
  (*(void (**)(void))(*a22 + 8 * v72))();
LABEL_11:
  sub_1D3D74EDC(&a54);
  v73 = STACK[0x2C8];
  if (*(_BYTE *)(STACK[0x2A8] + 8))
  {
    if (!v73)
      goto LABEL_19;
    STACK[0x2D0] = *(_QWORD *)STACK[0x2A8];
    (*(void (**)(unint64_t, unint64_t *))(*(_QWORD *)v73 + 48))(v73, &STACK[0x2D0]);
    v73 = STACK[0x2C8];
  }
  if ((_QWORD *)v73 == a46)
  {
    v74 = 4;
  }
  else
  {
    if (!v73)
      goto LABEL_19;
    v74 = 5;
    a46 = (_QWORD *)v73;
  }
  (*(void (**)(void))(*a46 + 8 * v74))();
LABEL_19:
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D7BAA4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D7BADC()
{
  return &unk_1E95ABD88;
}

uint64_t *sub_1D3D7BAE8(CFTypeRef cf)
{
  CFTypeID v2;
  CFTypeID v3;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v2 != qword_1EDB893D8)
      _os_assumes_log();
    v3 = CFGetTypeID(cf);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v3 != qword_1EDB893D8)
      _os_assumes_log();
  }
  dispatch_release(*((dispatch_object_t *)cf + 4));
  sub_1D3E22A74((uint64_t)cf + 40);
  return sub_1D3E22AAC((uint64_t *)cf + 2);
}

BOOL sub_1D3D7BBC8(CFTypeRef cf, CFTypeRef a2)
{
  CFTypeID v4;
  CFTypeID v5;

  if (!cf)
    goto LABEL_5;
  v4 = CFGetTypeID(cf);
  if (qword_1EDB893E0 != -1)
    dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
  if (v4 != qword_1EDB893D8)
  {
    _os_assumes_log();
    if (!a2)
      return cf == a2;
  }
  else
  {
LABEL_5:
    if (!a2)
      return cf == a2;
  }
  v5 = CFGetTypeID(a2);
  if (qword_1EDB893E0 != -1)
    dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
  if (v5 != qword_1EDB893D8)
    _os_assumes_log();
  return cf == a2;
}

unint64_t sub_1D3D7BCAC(CFTypeRef cf)
{
  CFTypeID v2;
  unint64_t v3;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v2 != qword_1EDB893D8)
      _os_assumes_log();
  }
  v3 = 0x9DDFEA08EB382D69
     * (((((((unint64_t)cf + 16) >> 3) & 0x3FFFFFF) << 6) | 8) ^ (((unint64_t)cf + 16) >> 32));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * ((((unint64_t)cf + 16) >> 32) ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69
                                                                                             * ((((unint64_t)cf
                                                                                                + 16) >> 32) ^ (v3 >> 47) ^ v3)) >> 47));
}

CFStringRef sub_1D3D7BD64(char *cf)
{
  CFTypeID v2;
  const __CFAllocator *v3;
  unint64_t **v5;
  __CFString *v6;
  __CFString *v7;
  __CFString *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __CFString *v12;
  unint64_t *v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  __CFString *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  const void *v21;
  const void *v22;
  int v23;
  __CFString *v24;
  unint64_t v25;
  __CFString *v26;
  unint64_t v27;
  __CFString *v28;
  int v29;
  const __CFString *v30;
  void *v31;
  unint64_t v32;
  __CFString *v33;
  __CFString *v34;
  const char *v35;
  __CFString *v36;
  const char *v37;
  int v38;
  __CFString *v39;
  __CFString *v40;
  const char *v41;
  __CFString *v42;
  __CFString *v43;
  _QWORD *v44;
  __CFString *v45;
  size_t v46;
  const void *v47;
  void **v48;
  __CFString *v49;
  uint64_t v50;
  uint64_t v51;
  __CFString *v52;
  void **v53;
  __CFString *v54;
  __CFString *v55;
  const __CFString *v56;
  CFStringRef Copy;
  CFMutableStringRef Mutable;
  void *__dst[2];
  int64_t v61;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v2 != qword_1EDB893D8)
      _os_assumes_log();
  }
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!atomic_load((unint64_t *)&Mutable))
  {
    sub_1D3D8FA0C((unint64_t *)&Mutable);
    return CFStringCreateWithFormat(v3, 0, CFSTR("<%s %p>"), "MRCContext", cf);
  }
  v5 = (unint64_t **)(cf + 16);
  v6 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  CFStringAppendFormat(v6, 0, CFSTR("<%s %p> {\n"), "MRCContext", cf);
  v7 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  CFStringAppend(v7, CFSTR("    options {\n"));
  v8 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  v9 = **((_QWORD **)cf + 2);
  sub_1D3E23CA4(__dst, v9);
  v10 = atomic_load((unint64_t *)__dst);
  CFStringAppendFormat(v8, 0, CFSTR("        inferenceFlags 0x%lx (%@)\n"), v9, v10);
  sub_1D3D8C70C((unint64_t *)__dst);
  v11 = **((_QWORD **)cf + 2);
  if (v11 != sub_1D3E181F0(*((unint64_t **)cf + 2)))
  {
    v12 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    v13 = *v5;
    v14 = sub_1D3E181F0(*v5);
    v15 = sub_1D3E181F0(v13);
    sub_1D3E23CA4(__dst, v15);
    v16 = atomic_load((unint64_t *)__dst);
    CFStringAppendFormat(v12, 0, CFSTR("        effectiveInferenceFlags 0x%lx (%@)\n"), v14, v16);
    sub_1D3D8C70C((unint64_t *)__dst);
  }
  v17 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  v18 = atomic_load(*v5 + 1);
  v19 = *MEMORY[0x1E0C9B0D0];
  if (!v18)
    v18 = *MEMORY[0x1E0C9B0D0];
  CFStringAppendFormat(v17, 0, CFSTR("        preferredMetalDevice %@\n"), v18);
  v20 = *v5 + 1;
  sub_1D3E18620((uint64_t *)__dst, (uint64_t)*v5);
  v21 = (const void *)atomic_load((unint64_t *)__dst);
  v22 = (const void *)atomic_load(v20);
  if (v22 != v21)
  {
    if (v21 && v22)
    {
      v23 = CFEqual(v22, v21);
      sub_1D3D8BA0C((unint64_t *)__dst);
      if (v23)
        goto LABEL_22;
    }
    else
    {
      sub_1D3D8BA0C((unint64_t *)__dst);
    }
    v24 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    sub_1D3E18620((uint64_t *)__dst, (uint64_t)*v5);
    v25 = atomic_load((unint64_t *)__dst);
    if (!v25)
      v25 = v19;
    CFStringAppendFormat(v24, 0, CFSTR("        effectivePreferredMetalDevice %@\n"), v25);
  }
  sub_1D3D8BA0C((unint64_t *)__dst);
LABEL_22:
  v26 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  v27 = atomic_load(*v5 + 2);
  if (!v27)
    v27 = v19;
  CFStringAppendFormat(v26, 0, CFSTR("        computeDevice %@\n"), v27);
  v28 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  v29 = *((_DWORD *)*v5 + 6);
  if (v29 > 20)
  {
    switch(v29)
    {
      case 21:
        v30 = CFSTR("default");
        goto LABEL_38;
      case 33:
        v30 = CFSTR("user-interactive");
        goto LABEL_38;
      case 25:
        v30 = CFSTR("user-initiated");
        goto LABEL_38;
    }
  }
  else
  {
    switch(v29)
    {
      case 0:
        v30 = CFSTR("unspecified");
        goto LABEL_38;
      case 9:
        v30 = CFSTR("background");
        goto LABEL_38;
      case 17:
        v30 = CFSTR("utility");
LABEL_38:
        v31 = (void *)CFRetain(v30);
        goto LABEL_39;
    }
  }
  v31 = (void *)CFStringCreateWithFormat(v3, 0, CFSTR("unspecified (0x%x)"), *((unsigned int *)*v5 + 6));
LABEL_39:
  __dst[0] = v31;
  v32 = atomic_load((unint64_t *)__dst);
  CFStringAppendFormat(v28, 0, CFSTR("        qosClass %@\n"), v32);
  sub_1D3D8C70C((unint64_t *)__dst);
  v33 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  CFStringAppendFormat(v33, 0, CFSTR("        relativePriority %d\n"), *((unsigned int *)*v5 + 7));
  v34 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  if (*((_BYTE *)*v5 + 32))
    v35 = "true";
  else
    v35 = "false";
  CFStringAppendFormat(v34, 0, CFSTR("        isGlobal %s\n"), v35);
  v36 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  if (*((_BYTE *)*v5 + 33))
    v37 = "true";
  else
    v37 = "false";
  CFStringAppendFormat(v36, 0, CFSTR("        isOneShot %s\n"), v37);
  v38 = *((unsigned __int8 *)*v5 + 48);
  v39 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  if (v38)
    CFStringAppendFormat(v39, 0, CFSTR("        maximumBufferAge %g\n"), (*v5)[5]);
  else
    CFStringAppendFormat(v39, 0, CFSTR("        maximumBufferAge <unspecified>\n"));
  v40 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  if (*((_BYTE *)*v5 + 57))
  {
    if (*((_BYTE *)*v5 + 56))
      v41 = "true";
    else
      v41 = "false";
  }
  else
  {
    v41 = "<unspecified>";
  }
  CFStringAppendFormat(v40, 0, CFSTR("        isStreaming %s\n"), v41);
  v42 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  CFStringAppend(v42, CFSTR("    }\n"));
  os_unfair_lock_lock_with_options();
  v43 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  CFStringAppendFormat(v43, 0, CFSTR("    concreteContexts [%zu] {\n"), *((_QWORD *)cf + 8));
  v44 = cf + 56;
  while (1)
  {
    v44 = (_QWORD *)*v44;
    v45 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    if (!v44)
      break;
    CFStringAppend(v45, CFSTR("        "));
    v46 = v44[5];
    if (v46)
    {
      if (v46 >= 0x7FFFFFFFFFFFFFF8)
        sub_1D3D7FD48();
      v47 = (const void *)v44[4];
      if (v46 >= 0x17)
      {
        v50 = (v46 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v46 | 7) != 0x17)
          v50 = v46 | 7;
        v51 = v50 + 1;
        v48 = (void **)operator new(v50 + 1);
        __dst[1] = (void *)v46;
        v61 = v51 | 0x8000000000000000;
        __dst[0] = v48;
      }
      else
      {
        HIBYTE(v61) = v44[5];
        v48 = __dst;
      }
      memmove(v48, v47, v46);
      *((_BYTE *)v48 + v46) = 0;
      v52 = (__CFString *)atomic_load((unint64_t *)&Mutable);
      if (v61 >= 0)
        v53 = __dst;
      else
        v53 = (void **)__dst[0];
      CFStringAppendFormat(v52, 0, CFSTR("<%s %p>"), v53, v44[6]);
      if (SHIBYTE(v61) < 0)
        operator delete(__dst[0]);
    }
    else
    {
      v49 = (__CFString *)atomic_load((unint64_t *)&Mutable);
      CFStringAppendFormat(v49, 0, CFSTR("<ConcreteContext(classID=%p) %p>"), v44[3], v44[6]);
    }
    v54 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v54, CFSTR("\n"));
  }
  CFStringAppend(v45, CFSTR("    }\n"));
  os_unfair_lock_unlock((os_unfair_lock_t)cf + 6);
  v55 = (__CFString *)atomic_load((unint64_t *)&Mutable);
  CFStringAppend(v55, CFSTR("}"));
  v56 = (const __CFString *)atomic_load((unint64_t *)&Mutable);
  Copy = CFStringCreateCopy(v3, v56);
  sub_1D3D8FA0C((unint64_t *)&Mutable);
  if (Copy)
    return Copy;
  return CFStringCreateWithFormat(v3, 0, CFSTR("<%s %p>"), "MRCContext", cf);
}

void sub_1D3D7C3C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, os_unfair_lock_t lock, unint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1D3D8BA0C((unint64_t *)&__p);
  sub_1D3D8FA0C(&a15);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D7C440()
{
  _QWORD *result;
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB89108)
    _os_assumes_log();
  if (qword_1EDB89310)
    _os_assumes_log();
  qword_1EDB89108 = (uint64_t)"MRCDecoderResult";
  qword_1EDB89310 = _CFRuntimeRegisterClass();
  v2[0] = &off_1E95B38E0;
  v3 = v2;
  sub_1D3DAFDB4(qword_1EDB89310, v2);
  result = v3;
  if (v3 == v2)
  {
    v1 = 4;
    result = v2;
  }
  else
  {
    if (!v3)
      return result;
    v1 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
}

void sub_1D3D7C518(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D7C560()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D7C574()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B38E0;
  return result;
}

void sub_1D3D7C598(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B38E0;
}

CFStringRef sub_1D3D7C5B0@<X0>(CFTypeRef *a1@<X1>, CFStringRef *a2@<X8>)
{
  _QWORD *v3;
  CFTypeID v4;
  CFStringRef result;

  v3 = *a1;
  if (*a1)
  {
    v4 = CFGetTypeID(*a1);
    if (qword_1EDB89338[0] != -1)
      dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
    if (v4 != qword_1EDB89310)
      _os_assumes_log();
  }
  result = sub_1D3E02234(v3 + 2, 1);
  *a2 = result;
  return result;
}

uint64_t sub_1D3D7C640(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc2CFINS_13DecoderResultENS_2cf6TraitsIS1_NS2_13PersonalitiesIS1_XtlNS_12fixed_stringILm16EEEtlNS_18basic_fixed_stringIcLm16ENSt3__111char_traitsIcEEEEtlA17_cLc77ELc82ELc67ELc68ELc101ELc99ELc111ELc100ELc101ELc114ELc82ELc101ELc115ELc117ELc108ELc116EEEEEJEEEEEE18registerClassOnce_EPvEUlPKvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D7C678()
{
  return &unk_1E95B3940;
}

void sub_1D3D7C684(char *cf)
{
  CFTypeID v2;
  CFTypeID v3;
  void **v4;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89338[0] != -1)
      dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
    if (v2 != qword_1EDB89310)
      _os_assumes_log();
    v3 = CFGetTypeID(cf);
    if (qword_1EDB89338[0] != -1)
      dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
    if (v3 != qword_1EDB89310)
      _os_assumes_log();
  }
  sub_1D3D740C8((unint64_t *)cf + 5);
  v4 = (void **)(cf + 16);
  sub_1D3D74BF0(&v4);
}

uint64_t sub_1D3D7C76C(unint64_t *cf, unint64_t *a2)
{
  CFTypeID v4;
  CFTypeID v5;
  unint64_t *v6;
  unint64_t *v7;
  unint64_t *v8;
  const void *v9;
  const void *v10;
  BOOL v11;
  uint64_t result;
  const void *v13;
  const void *v14;
  BOOL v15;

  if (!cf)
    goto LABEL_5;
  v4 = CFGetTypeID(cf);
  if (qword_1EDB89338[0] != -1)
    dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
  if (v4 != qword_1EDB89310)
  {
    _os_assumes_log();
    if (a2)
      goto LABEL_6;
  }
  else
  {
LABEL_5:
    if (a2)
    {
LABEL_6:
      v5 = CFGetTypeID(a2);
      if (qword_1EDB89338[0] != -1)
        dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
      if (v5 != qword_1EDB89310)
        _os_assumes_log();
    }
  }
  v7 = (unint64_t *)cf[2];
  v6 = (unint64_t *)cf[3];
  v8 = (unint64_t *)a2[2];
  if ((char *)v6 - (char *)v7 != a2[3] - (_QWORD)v8)
    return 0;
  while (v7 != v6)
  {
    v9 = (const void *)atomic_load(v8);
    v10 = (const void *)atomic_load(v7);
    if (v10 != v9)
    {
      if (v9)
        v11 = v10 == 0;
      else
        v11 = 1;
      if (v11)
        return 0;
      result = CFEqual(v10, v9);
      if (!(_DWORD)result)
        return result;
    }
    ++v7;
    ++v8;
  }
  v13 = (const void *)atomic_load(a2 + 5);
  v14 = (const void *)atomic_load(cf + 5);
  if (v14 == v13)
    return 1;
  v15 = !v13 || v14 == 0;
  return !v15 && CFEqual(v14, v13);
}

CFHashCode sub_1D3D7C8D0(unint64_t *cf)
{
  CFTypeID v2;
  CFHashCode v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  const void *v8;
  CFHashCode v9;
  const void *v10;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89338[0] != -1)
      dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
    if (v2 != qword_1EDB89310)
      _os_assumes_log();
  }
  v3 = 3317042773;
  v4 = (unint64_t *)cf[2];
  v5 = (unint64_t *)cf[3];
  v6 = 3317042773;
  if (v4 != v5)
  {
    v7 = 0;
    do
    {
      v8 = (const void *)atomic_load(v4);
      v9 = 3317042773;
      if (v8)
        v9 = CFHash(v8) + 2654435769u;
      v7 ^= (v7 >> 2) + (v7 << 6) + v9;
      ++v4;
    }
    while (v4 != v5);
    v6 = v7 + 2654435769u;
  }
  v10 = (const void *)atomic_load(cf + 5);
  if (v10)
    v3 = CFHash(v10) + 2654435769u;
  return (v3 + (v6 << 6) + (v6 >> 2)) ^ v6;
}

CFStringRef sub_1D3D7C9D4(CFTypeRef cf)
{
  CFTypeID v2;
  CFStringRef result;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89338[0] != -1)
      dispatch_once_f(qword_1EDB89338, 0, (dispatch_function_t)sub_1D3D7C440);
    if (v2 != qword_1EDB89310)
      _os_assumes_log();
  }
  result = sub_1D3E02234((_QWORD *)cf + 2, 0);
  if (!result)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<%s %p>"), "MRCDecoderResult", cf);
  return result;
}

float sub_1D3D7CA88(float32x4_t *a1, int32x4_t *a2)
{
  uint64_t v4;
  __n128 v5;
  float *v6;
  float v7;
  int i;
  uint64_t j;
  float v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  float v15;
  uint64_t v16;
  __int32 v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  int v21;
  float v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x4_t v30;
  float32x4_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  malloc_type_malloc(0x10uLL, 0x100004052888210uLL);
  v4 = 0;
  v5.n128_u32[0] = 0;
  do
    v5.n128_f32[0] = v5.n128_f32[0] + a1->f32[v4++];
  while (v4 != 4);
  a2->i64[0] = -1;
  a2->i64[1] = -1;
  v6 = (float *)MEMORY[0x1E0C80A78](v5);
  for (i = 0; i != 4; ++i)
  {
    for (j = 0; j != 4; ++j)
    {
      v10 = a1->f32[j] / v7;
      v11 = llroundf(v10);
      if (v11 >= 4)
        v11 = 4;
      if (v11 <= 1)
        v11 = 1;
      v30.i32[j] = v11;
      v6[j] = v10 - (float)v11;
    }
    v12 = vaddvq_s32(v30);
    if (v12 >= 8)
    {
      while (1)
      {
        v13 = 0;
        v14 = 0;
        v15 = *v6;
        do
        {
          if (v6[v13] < v15)
          {
            v15 = v6[v13];
            v14 = v13;
          }
          ++v13;
        }
        while (v13 != 4);
        v16 = v14;
        v17 = v30.i32[v14];
        v18 = __OFSUB__(v17, 1);
        v19 = v17 - 1;
        if (!((v19 < 0) ^ v18 | (v19 == 0)))
          break;
        if (!v19)
          goto LABEL_18;
LABEL_19:
        if (v12 <= 7)
          goto LABEL_31;
      }
      --v12;
      v30.i32[v16] = v19;
LABEL_18:
      v6[v16] = v6[v16] + 1.0;
      goto LABEL_19;
    }
    if (v12 != 7)
    {
      while (1)
      {
        v20 = 0;
        v21 = 0;
        v22 = *v6;
        do
        {
          if (v6[v20] > v22)
          {
            v22 = v6[v20];
            v21 = v20;
          }
          ++v20;
        }
        while (v20 != 4);
        v23 = v21;
        v24 = v30.i32[v21];
        if (v24 < 4)
          break;
        if (v24 == 4)
          goto LABEL_29;
LABEL_30:
        if (v12 >= 7)
          goto LABEL_31;
      }
      ++v12;
      v30.i32[v23] = v24 + 1;
LABEL_29:
      v6[v23] = v6[v23] + -1.0;
      goto LABEL_30;
    }
LABEL_31:
    v25 = 0;
    v26 = vmulq_f32(*a1, vcvtq_f32_s32(v30));
    v27 = vcvtq_f32_s32(vmulq_s32(v30, v30));
    v7 = (float)((float)((float)((float)(v26.f32[0] + 0.0) + v26.f32[1]) + v26.f32[2]) + v26.f32[3])
       / (float)((float)((float)((float)(v27.f32[0] + 0.0) + v27.f32[1]) + v27.f32[2]) + v27.f32[3]);
    while (v30.i32[v25] == a2->i32[v25])
    {
      if (++v25 == 4)
        goto LABEL_36;
    }
    *a2 = v30;
  }
LABEL_36:
  v31 = *(float32x4_t *)v6;
  free(v6);
  v28 = vabsq_f32(v31);
  return (float)((float)((float)(v28.f32[0] + 0.0) + v28.f32[1]) + v28.f32[2]) + v28.f32[3];
}

uint64_t sub_1D3D7CD24(int32x4_t *a1, int a2, char a3)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  char v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int32x4_t *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  int64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;

  v4 = 0;
  LODWORD(v5) = 0;
  v6 = 0;
  v7 = vaddvq_s32(*a1);
  v31 = a3 ^ 1;
  v30 = a2;
  v24 = 1;
  v22 = a1;
  do
  {
    v8 = 1 << v4;
    v9 = a1->u32[v4];
    if ((int)v9 < 2)
    {
      LODWORD(v5) = v8 | v5;
      LODWORD(v9) = 1;
    }
    else
    {
      v10 = 1;
      v11 = 1 - v4;
      v23 = v7;
      v32 = v7;
      v25 = v4 - 3;
      v26 = v4 - 4;
      v5 = v5 & ~v8;
      v28 = 3 - (int)v4;
      v29 = 3 - v4;
      v33 = 2 - (int)v4;
      v12 = 1;
      v27 = v4;
      do
      {
        v13 = v32 - v10;
        v14 = sub_1D3D7CF00((int)v32 - (int)v10 - 1, v33);
        v15 = v31;
        if (v12)
          v15 = 1;
        if ((v15 & 1) == 0 && v29 <= v13 - v28)
          v14 -= sub_1D3D7CF00(v26 + (int)v13, v33);
        if (v4 > 1)
        {
          v20 = v14 - (v13 > v30);
        }
        else
        {
          v16 = v5;
          v17 = v13 - v33;
          if (v13 - v33 <= v30)
          {
            v18 = 0;
          }
          else
          {
            v18 = 0;
            v19 = v24;
            do
            {
              v18 += sub_1D3D7CF00(v19, v11);
              --v17;
              ++v19;
            }
            while (v17 > a2);
          }
          v20 = v14 + v18 * v25;
          v5 = v16;
          v4 = v27;
        }
        v6 = (v20 + v6);
        ++v10;
        v12 = v5;
      }
      while (v10 != v9);
      a1 = v22;
      v7 = v23;
    }
    v7 -= v9;
    ++v4;
    --v24;
  }
  while (v4 != 3);
  return v6;
}

uint64_t sub_1D3D7CF00(int a1, int a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t result;

  if (a1 - a2 <= a2)
    v2 = a2;
  else
    v2 = a1 - a2;
  if (a1 - a2 >= a2)
    v3 = a2;
  else
    v3 = a1 - a2;
  if (v2 >= a1)
  {
    result = 1;
    v5 = 1;
  }
  else
  {
    v4 = a1;
    v5 = 1;
    LODWORD(result) = 1;
    do
    {
      result = (v4 * result);
      if (v5 <= v3)
        result = ((int)result / v5++);
      --v4;
    }
    while (v4 > v2);
  }
  if (v5 <= v3)
  {
    do
      result = ((int)result / v5++);
    while (v3 + 1 != v5);
  }
  return result;
}

uint64_t sub_1D3D7CF70(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int32x2_t v5;
  unsigned int v6;
  int32x4_t v7;
  int8x16_t v8;
  uint32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  uint32x4_t v12;
  int8x16_t v13;
  __int32 v14;
  uint64_t v15;
  CGSize v16;
  CGPoint *v17;
  CGSize v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  _BOOL4 v22;
  unint64_t v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  float v33;
  double v34;
  float v35;
  int v36;
  int v37;
  BOOL v38;
  __int128 v39;
  double v40;
  uint64_t v41;
  uint64_t v42;
  double x;
  double y;
  double width;
  double height;
  float v47;
  const UInt8 *v48;
  double v49;
  CGFloat v50;
  __int16 *v51;
  __int16 v52;
  CGAffineTransform v53;
  int v54;
  char v55;
  CGPoint v56;
  CGSize v57;
  CGRect v58;
  CGRect v59;
  CGRect v60;
  CGRect v61;

  sub_1D3E36CA0();
  LODWORD(v56.x) = 0;
  BYTE4(v56.x) = 1;
  result = sub_1D3DDC334(*(unint64_t **)(a1 + 8), (uint64_t)&v56);
  if (dword_1EDB89DD8 < 1)
  {
    v14 = 0;
  }
  else
  {
    v6 = (dword_1EDB89DD8 + 3) & 0xFFFFFFFC;
    v7 = (int32x4_t)xmmword_1D3E82000;
    v8 = 0uLL;
    v9.i64[0] = 0x100000001;
    v9.i64[1] = 0x100000001;
    v10.i64[0] = 0x400000004;
    v10.i64[1] = 0x400000004;
    do
    {
      v11 = v8;
      v12 = (uint32x4_t)v7;
      v8 = vorrq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)v7), v8);
      v7 = vaddq_s32(v7, v10);
      v6 -= 4;
    }
    while (v6);
    v5.i32[0] = dword_1EDB89DD8 - 1;
    v13 = vbslq_s8((int8x16_t)vcgtq_u32(v12, (uint32x4_t)vdupq_lane_s32(v5, 0)), v11, v8);
    *(int8x8_t *)v13.i8 = vorr_s8(*(int8x8_t *)v13.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
    v14 = v13.i32[0] | v13.i32[1];
  }
  if ((v14 & result) == 0)
    goto LABEL_33;
  v15 = *(_QWORD *)(a2 + 8);
  v16 = *(CGSize *)(v15 + 32);
  v56 = *(CGPoint *)(v15 + 16);
  v57 = v16;
  v61.origin = v56;
  v61.size = v16;
  v17 = CGRectIsInfinite(v61) ? (CGPoint *)(**(_QWORD **)(a2 + 8) + 8) : &v56;
  v18 = (CGSize)v17[1];
  v56 = *v17;
  v57 = v18;
  v54 = 0;
  v55 = 1;
  v19 = *(_QWORD *)(a1 + 8);
  v20 = sub_1D3DDC334((unint64_t *)v19, (uint64_t)&v54);
  v21 = *(uint64_t *)(v19 + 56) < 196608 || *(_BYTE *)(a2 + 32) == 0;
  v22 = !v21;
  if (v21)
  {
    y = v56.y;
    x = v56.x;
    v47 = 0.0;
    height = v57.height;
    width = v57.width;
  }
  else
  {
    v23 = sub_1D3D9102C((unint64_t *)(*(_QWORD *)(a2 + 24) + 120));
    v24 = *(_QWORD *)(a2 + 24);
    v25 = sub_1D3D8F9B0(v24, 0.0);
    v27 = v26;
    v29 = v28;
    v31 = v30;
    v32 = *(double *)(v24 + 112);
    v33 = *(double *)(v24 + 72);
    *(float *)&v26 = *(double *)(v24 + 64);
    v34 = (float)(atan2f(v33, *(float *)&v26) * -180.0) / 3.14159265;
    v35 = v32;
    v36 = (int)(v34 + fmodf(v35, 180.0));
    if (v36 > 90)
      v36 -= 180;
    v37 = v36 >= -90 ? v36 : v36 + 180;
    v38 = (_DWORD)v23 != 2 || HIDWORD(v23) == 0;
    v20 = v38 ? v20 & 0xFFFF9FFF : 24576;
    v39 = *(_OWORD *)(v24 + 80);
    *(_OWORD *)&v53.a = *(_OWORD *)(v24 + 64);
    *(_OWORD *)&v53.c = v39;
    *(_OWORD *)&v53.tx = *(_OWORD *)(v24 + 96);
    v40 = v25;
    *(_QWORD *)&v39 = v27;
    v41 = v29;
    v42 = v31;
    v58 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v39 - 8), &v53);
    x = v58.origin.x;
    y = v58.origin.y;
    width = v58.size.width;
    height = v58.size.height;
    v47 = (float)v37;
  }
  v59.origin.x = x;
  v59.origin.y = y;
  v59.size.width = width;
  v59.size.height = height;
  result = CGRectIsNull(v59);
  if ((result & 1) != 0)
    goto LABEL_33;
  v60.origin.x = x;
  v60.origin.y = y;
  v60.size.width = width;
  v60.size.height = height;
  result = CGRectIsEmpty(v60);
  if ((result & 1) != 0
    || (v48 = (const UInt8 *)sub_1D3DE7F08(**(unint64_t ***)(a2 + 8)),
        v49 = CGRectGetWidth(*(CGRect *)(**(_QWORD **)(a2 + 8) + 8)),
        v50 = CGRectGetHeight(*(CGRect *)(**(_QWORD **)(a2 + 8) + 8)),
        result = sub_1D3E2F428(a1, v48, (unint64_t)v49, (unint64_t)v50, *(_QWORD *)(**(_QWORD **)(a2 + 8) + 40), v20, v22, *(uint64_t **)a2, x, y, width, height, v47), (_DWORD)result))
  {
LABEL_33:
    v51 = *(__int16 **)(a2 + 64);
    v52 = 256;
  }
  else
  {
    v51 = *(__int16 **)(a2 + 64);
    v52 = 257;
  }
  *v51 = v52;
  return result;
}

void sub_1D3D7D28C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D3D7D24CLL);
}

unsigned int **sub_1D3D7D2A0@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  float v12;
  float v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  _OWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  char *v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int v40;
  int v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  char *v51;
  int v52;
  unsigned int *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  void *v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  double v83;
  unsigned int **v84;
  unsigned int *v85;
  uint64_t i;
  uint64_t v87;
  int *v88;
  uint64_t v89;
  uint64_t v90;
  double v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  double v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  double v99;
  uint64_t v100;
  uint64_t v101;
  double v102;
  uint64_t v103;
  uint64_t v104;
  double *v105;
  double *v106;
  __int128 v107;
  __int128 v108;
  unsigned int *v109;
  unint64_t v110;
  BOOL v111;
  double v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  float64x2_t v116;
  double v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  unsigned int *v126;
  unsigned int *v127;
  unsigned int v128;
  unsigned int *v129;
  unsigned int *v130;
  unsigned int v131;
  int v132;
  unsigned int *v133;
  unsigned int *v134;
  unsigned int v135;
  int v136;
  unsigned int *v137;
  unsigned int *v138;
  unsigned int v139;
  int v140;
  unsigned int *v141;
  unsigned int *v142;
  unsigned int v143;
  int v144;
  int v145;
  BOOL v146;
  unsigned int v147;
  unsigned int *v148;
  unsigned int *v149;
  unsigned int v150;
  unsigned int *v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int *v154;
  unsigned int *v155;
  unsigned int v156;
  unsigned int *v157;
  unsigned int *v158;
  unsigned int v159;
  unsigned int *v160;
  unsigned int *v161;
  unsigned int v162;
  unsigned int *v163;
  unsigned int *v164;
  unsigned int v165;
  int v166;
  unint64_t v167;
  unint64_t v168;
  unsigned int *v169;
  unsigned int *v170;
  unsigned int v171;
  uint64_t v172;
  float v173;
  float v174;
  float v175;
  unsigned int *v176;
  unsigned int *v177;
  unsigned int v178;
  float v179;
  float v180;
  float v181;
  unsigned int *v182;
  unsigned int *v183;
  unsigned int v184;
  float v185;
  float v186;
  float v187;
  unsigned int *v188;
  unsigned int *v189;
  unsigned int v190;
  float v191;
  float v192;
  float v193;
  unsigned int *v194;
  unsigned int *v195;
  unsigned int v196;
  unsigned int *v197;
  unsigned int *v198;
  unsigned int v199;
  unsigned int v200;
  unsigned int *v201;
  unsigned int *v202;
  unsigned int v203;
  int v204;
  float *v205;
  float v206;
  uint64_t v207;
  _QWORD *v208;
  unsigned int *v209;
  unsigned int v210;
  uint64_t v211;
  _QWORD *v212;
  unsigned int *v213;
  unsigned int v214;
  uint64_t v215;
  _QWORD *v216;
  unsigned int *v217;
  unsigned int v218;
  uint64_t v219;
  _QWORD *v220;
  unsigned int *v221;
  unsigned int v222;
  uint64_t j;
  int v224;
  _QWORD *v225;
  int v226;
  unsigned int *v227;
  unsigned int *v228;
  unsigned int v229;
  uint64_t v230;
  uint64_t v231;
  unsigned int *v232;
  unsigned int v233;
  uint64_t v234;
  unsigned int *v235;
  unsigned int *v236;
  unsigned int v237;
  unsigned int *v238;
  int v239;
  _QWORD *v240;
  int v241;
  unsigned int *v242;
  unsigned int *v243;
  unsigned int v244;
  uint64_t v245;
  uint64_t v246;
  unsigned int *v247;
  unsigned int v248;
  uint64_t v249;
  unsigned int *v250;
  unsigned int *v251;
  unsigned int v252;
  unsigned int *v253;
  int v254;
  unsigned int **v255;
  unsigned int **v256;
  int v257;
  unsigned int **v258;
  unsigned int **v259;
  int v260;
  unsigned int **v261;
  unsigned int **v262;
  int v263;
  unsigned int **v264;
  unsigned int **v265;
  unsigned int *v266;
  unsigned int *v267;
  unsigned int v268;
  unsigned int **v269;
  unsigned int *v270;
  unsigned int *v271;
  unsigned int v272;
  unsigned int *v273;
  unsigned int *v274;
  unsigned int v275;
  unsigned int *v276;
  unsigned int *v277;
  unsigned int v278;
  unsigned int *v279;
  unsigned int *v280;
  unsigned int v281;
  unsigned int *v282;
  unsigned int *v283;
  unsigned int *v284;
  unsigned int v285;
  unsigned int *v286;
  unsigned int v287;
  uint64_t k;
  unsigned int *v289;
  unsigned int *v290;
  unsigned int v291;
  int v292;
  unsigned int **v293;
  unsigned int *v294;
  unsigned int *v295;
  unsigned int v296;
  unsigned int *v297;
  unsigned int v298;
  unint64_t v299;
  unsigned int **v300;
  _QWORD *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  _QWORD *v320;
  _QWORD v321[3];
  unsigned int **v322[3];
  uint64_t (**v323)(_QWORD);
  int v324;
  unsigned int *v325;
  unsigned int *v326;
  unsigned int *v327;
  unsigned int *v328;
  unsigned int ***v329;
  unsigned int *v330;
  unsigned int *v331;
  uint64_t (**v332)();
  int v333;
  unsigned int *v334;
  unsigned __int8 v335;
  uint64_t v336;
  uint64_t v337;
  __int16 v338;
  unsigned int **v339[3];
  unsigned int *v340;
  unsigned int *v341;
  unsigned int *v342;
  unsigned int *v343;
  unsigned int *v344;
  unsigned int *v345;
  unsigned int *v346;
  unsigned int **v347;
  unsigned int **v348;
  unint64_t v349;
  unsigned int *v350;
  unsigned int *v351;
  unsigned int *v352;
  unsigned int *v353;
  unsigned int *v354;
  char *v355;
  char *v356;
  unsigned int **v357;
  unsigned int *v358;
  _OWORD v359[2];
  __int128 v360;
  __int128 v361;
  __int128 v362;
  unsigned int *v363;
  char **v364;
  unsigned int *v365;
  unsigned int *v366;
  unsigned int *v367;
  unsigned int *v368;
  unsigned int *v369;
  int v370;
  unsigned int *v371;
  unsigned int *v372;
  unsigned int *v373;
  unsigned int *v374;
  unsigned int *v375;
  unsigned int *v376;
  unsigned int *v377;
  void *__p;
  void *v379;
  char *v380;
  void *v381;
  void *v382;
  float *v383;
  void **p_p;
  char v385;
  unsigned int **v386;
  unsigned int **v387;
  __int128 v388;
  __int128 v389;
  __int128 v390;
  __int128 v391;
  __int128 v392;
  uint64_t v393;

  v393 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  (*(void (**)(unsigned int **__return_ptr))(**(_QWORD **)(*(_QWORD *)a1 + 16) + 16))(&v331);
  v333 = 0;
  v332 = &off_1E95AF650;
  v334 = 0;
  v4 = v331;
  if (v331)
  {
    v5 = v331 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    if (v334)
      sub_1D3D6D13C(v334);
  }
  v334 = v4;
  v335 = 0;
  v337 = 0;
  v336 = 0;
  v338 = 0;
  sub_1D3D6D10C(&v331);
  v7 = *(_QWORD **)a2;
  v303 = *(_QWORD **)(a2 + 8);
  if (*(_QWORD **)a2 != v303)
  {
    do
    {
      v8 = *v7;
      if (*v7)
      {
        v9 = (unsigned int *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
        do
          v11 = __ldxr(v9);
        while (__stxr(v11 + 1, v9));
      }
      v330 = (unsigned int *)v8;
      v328 = (unsigned int *)v8;
      HIBYTE(v338) = *(_BYTE *)(v8 + 180);
      v12 = (*(float (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
      v13 = (*(float (**)(unsigned int *))(*(_QWORD *)v328 + 24))(v328);
      v14 = v334;
      if (v334)
      {
        v15 = v334 + 2;
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      v353 = v14;
      v356 = 0;
      v354 = 0;
      v355 = 0;
      *(double *)&v386 = COERCE_DOUBLE(&v354);
      LOBYTE(v387) = 0;
      v17 = operator new(0x180uLL);
      v18 = 0;
      v19 = (int)v12;
      v20 = (int)v13;
      v21 = v19 | (v20 << 32);
      v356 = (char *)(v17 + 24);
      *v17 = 0u;
      v17[1] = 0u;
      v17[2] = 0u;
      v17[3] = 0u;
      v17[4] = 0u;
      v17[5] = 0u;
      v17[6] = 0u;
      v17[7] = 0u;
      v17[8] = 0u;
      v17[9] = 0u;
      v17[10] = 0u;
      v17[11] = 0u;
      v17[12] = 0u;
      v17[13] = 0u;
      v17[14] = 0u;
      v17[15] = 0u;
      v17[16] = 0u;
      v17[17] = 0u;
      v17[18] = 0u;
      v17[19] = 0u;
      v17[20] = 0u;
      v17[21] = 0u;
      v17[22] = 0u;
      v17[23] = 0u;
      v22 = (int)v19;
      v23 = (int)v20;
      v354 = (unsigned int *)v17;
      v355 = (char *)(v17 + 24);
      do
      {
        v24 = &unk_1D3E5D348;
        v25 = (char *)&unk_1D3E5D340;
        switch((int)v18)
        {
          case 0:
            break;
          case 1:
            v25 = (char *)&unk_1D3E5D380;
            goto LABEL_28;
          case 2:
            v25 = (char *)&unk_1D3E5D348;
            goto LABEL_32;
          case 3:
            v25 = (char *)&unk_1D3E5D3A8;
            goto LABEL_28;
          case 4:
            v25 = (char *)&unk_1D3E5D350;
            goto LABEL_32;
          case 5:
            v25 = (char *)&unk_1D3E5D3D0;
            goto LABEL_28;
          case 6:
            v25 = (char *)&unk_1D3E5D358;
            goto LABEL_32;
          case 7:
            v25 = (char *)&unk_1D3E5D3F8;
            goto LABEL_28;
          case 8:
            v25 = (char *)&unk_1D3E5D360;
            goto LABEL_32;
          case 9:
            v25 = (char *)&unk_1D3E5D420;
            goto LABEL_28;
          case 10:
            v25 = (char *)&unk_1D3E5D368;
            goto LABEL_32;
          case 11:
            v25 = (char *)&unk_1D3E5D448;
            goto LABEL_28;
          case 12:
            v25 = (char *)&unk_1D3E5D370;
            goto LABEL_32;
          case 13:
            v25 = (char *)&unk_1D3E5D470;
            goto LABEL_28;
          case 14:
            v25 = (char *)&unk_1D3E5D378;
LABEL_32:
            v24 = v25 + 8;
            break;
          case 15:
            v25 = (char *)&unk_1D3E5D498;
LABEL_28:
            v24 = v25 + 40;
            break;
          default:
            v25 = 0;
            v24 = 0;
            break;
        }
        v26 = v353;
        v27 = v353 + 2;
        do
          v28 = __ldxr(v27);
        while (__stxr(v28 + 1, v27));
        v363 = v26;
        v29 = *((_QWORD *)v26 + 7);
        v30 = -v29;
        v31 = *((_QWORD *)v26 + 4);
        v32 = v31 & -v29--;
        v33 = *((_QWORD *)v26 + 2);
        v34 = v33 & v29 | v32;
        v35 = v31 & v29 | v33 & v30;
        if (v34 > v35)
          LODWORD(v35) = v34;
        do
          v36 = __ldxr(v27);
        while (__stxr(v36 + 1, v27));
        v365 = v26;
        LOBYTE(v386) = 0;
        v387 = 0;
        do
          v37 = __ldxr(v27);
        while (__stxr(v37 + 1, v27));
        v387 = (unsigned int **)v26;
        *(_QWORD *)&v388 = v21;
        *((_QWORD *)&v388 + 1) = v25;
        *(_QWORD *)&v389 = v24;
        *((_QWORD *)&v389 + 1) = v25;
        *(_QWORD *)&v390 = v24;
        *((_QWORD *)&v390 + 1) = v21;
        *(_QWORD *)&v391 = 0;
        *((_QWORD *)&v391 + 1) = 0x300000000;
        *(_QWORD *)&v392 = 0;
        *((_QWORD *)&v392 + 1) = v35;
        if (sub_1D3D6D438((uint64_t)&v386))
        {
          LOBYTE(v386) = sub_1D3D6D4A0(v26, v22, v23);
          sub_1D3D6D294((uint64_t)&v386);
        }
        sub_1D3D6D10C(&v365);
        sub_1D3D6D10C(&v363);
        LOBYTE(v357) = (_BYTE)v386;
        v358 = 0;
        v38 = (unsigned int *)v387;
        if (v387)
        {
          v39 = (unsigned int *)(v387 + 1);
          do
            v40 = __ldxr(v39);
          while (__stxr(v40 + 1, v39));
          if (v358)
            sub_1D3D6D13C(v358);
        }
        v358 = v38;
        v361 = v391;
        v362 = v392;
        v359[1] = v389;
        v360 = v390;
        v359[0] = v388;
        v364 = (char **)&v354[6 * v18];
        sub_1D3D6D19C(&v364, *((uint64_t *)&v390 + 1));
        v41 = -3;
        do
        {
          sub_1D3D6D294((uint64_t)&v357);
          sub_1D3D6D19C(&v364, *((uint64_t *)&v360 + 1));
        }
        while (!__CFADD__(v41++, 1));
        sub_1D3D6D10C(&v358);
        sub_1D3D6D10C((unsigned int **)&v387);
        ++v18;
      }
      while (v18 != 16);
      v320 = v7;
      sub_1D3D6D10C(&v353);
      v315 = *(_QWORD *)(*((_QWORD *)v354 + 3) + 24);
      v312 = *(_QWORD *)(*(_QWORD *)v354 + 24);
      v310 = *(_QWORD *)(*((_QWORD *)v354 + 6) + 24);
      v43 = *(_QWORD *)(*((_QWORD *)v354 + 12) + 24);
      v318 = *(_QWORD *)(*((_QWORD *)v354 + 15) + 24);
      v319 = *(_QWORD *)(*((_QWORD *)v354 + 45) + 24);
      v44 = *(_QWORD *)(*((_QWORD *)v354 + 18) + 24);
      v316 = *(_QWORD *)(*((_QWORD *)v354 + 9) + 24);
      v317 = *(_QWORD *)(*((_QWORD *)v354 + 21) + 24);
      v45 = *(_QWORD *)(*((_QWORD *)v354 + 24) + 24);
      v46 = *(_QWORD *)(*((_QWORD *)v354 + 27) + 24);
      v47 = *(_QWORD *)(*((_QWORD *)v354 + 30) + 24);
      v48 = *(_QWORD *)(*((_QWORD *)v354 + 33) + 24);
      v49 = *(_QWORD *)(*((_QWORD *)v354 + 36) + 24);
      v314 = *(_QWORD *)(*((_QWORD *)v354 + 39) + 24);
      v50 = *(_QWORD *)(*((_QWORD *)v354 + 42) + 24);
      v51 = (char *)operator new(0xC0uLL);
      v52 = v49;
      v49 >>= 32;
      *(_QWORD *)v51 = (HIDWORD(v319) - HIDWORD(v315)) | ((unint64_t)(v315 - v319) << 32);
      *((_DWORD *)v51 + 2) = HIDWORD(v315) * v319 - v315 * HIDWORD(v319);
      *(_QWORD *)(v51 + 12) = (HIDWORD(v312) - HIDWORD(v310)) | ((unint64_t)(v310 - v312) << 32);
      *((_DWORD *)v51 + 5) = HIDWORD(v310) * v312 - v310 * HIDWORD(v312);
      *((_QWORD *)v51 + 3) = (HIDWORD(v315) - HIDWORD(v316)) | ((unint64_t)(v316 - v315) << 32);
      *((_DWORD *)v51 + 8) = HIDWORD(v316) * v315 - v316 * HIDWORD(v315);
      *(_QWORD *)(v51 + 36) = (HIDWORD(v310) - HIDWORD(v43)) | ((unint64_t)(v43 - v310) << 32);
      *((_DWORD *)v51 + 11) = HIDWORD(v43) * v310 - v43 * HIDWORD(v310);
      *((_QWORD *)v51 + 6) = (HIDWORD(v316) - HIDWORD(v318)) | ((unint64_t)(v318 - v316) << 32);
      *((_DWORD *)v51 + 14) = HIDWORD(v318) * v316 - v318 * HIDWORD(v316);
      *(_QWORD *)(v51 + 60) = (HIDWORD(v43) - HIDWORD(v44)) | ((unint64_t)(v44 - v43) << 32);
      *((_DWORD *)v51 + 17) = HIDWORD(v44) * v43 - v44 * HIDWORD(v43);
      *((_QWORD *)v51 + 9) = (HIDWORD(v318) - HIDWORD(v317)) | ((unint64_t)(v317 - v318) << 32);
      *(_QWORD *)(v51 + 84) = (HIDWORD(v44) - HIDWORD(v45)) | ((unint64_t)(v45 - v44) << 32);
      *((_DWORD *)v51 + 20) = HIDWORD(v317) * v318 - v317 * HIDWORD(v318);
      *((_DWORD *)v51 + 23) = HIDWORD(v45) * v44 - v45 * HIDWORD(v44);
      *((_QWORD *)v51 + 12) = (HIDWORD(v317) - HIDWORD(v46)) | ((unint64_t)(v46 - v317) << 32);
      *((_DWORD *)v51 + 26) = HIDWORD(v46) * v317 - v46 * HIDWORD(v317);
      *(_QWORD *)(v51 + 108) = (HIDWORD(v45) - HIDWORD(v47)) | ((unint64_t)(v47 - v45) << 32);
      *((_QWORD *)v51 + 15) = (HIDWORD(v46) - HIDWORD(v48)) | ((unint64_t)(v48 - v46) << 32);
      *((_DWORD *)v51 + 29) = HIDWORD(v47) * v45 - v47 * HIDWORD(v45);
      *((_DWORD *)v51 + 32) = HIDWORD(v48) * v46 - v48 * HIDWORD(v46);
      *(_QWORD *)(v51 + 132) = (HIDWORD(v47) - v49) | ((unint64_t)(v52 - v47) << 32);
      *((_DWORD *)v51 + 35) = v49 * v47 - v52 * HIDWORD(v47);
      *((_DWORD *)v51 + 38) = HIDWORD(v314) * v48 - v314 * HIDWORD(v48);
      *((_DWORD *)v51 + 41) = HIDWORD(v50) * v52 - v50 * v49;
      *((_DWORD *)v51 + 44) = HIDWORD(v319) * v314 - v319 * HIDWORD(v314);
      *((_DWORD *)v51 + 47) = HIDWORD(v312) * v50 - v312 * HIDWORD(v50);
      *((_QWORD *)v51 + 18) = (HIDWORD(v48) - HIDWORD(v314)) | ((unint64_t)(v314 - v48) << 32);
      *(_QWORD *)(v51 + 156) = (v49 - HIDWORD(v50)) | ((unint64_t)(v50 - v52) << 32);
      v53 = v354;
      *((_QWORD *)v51 + 21) = (HIDWORD(v314) - HIDWORD(v319)) | ((unint64_t)(v319 - v314) << 32);
      *(_QWORD *)(v51 + 180) = (HIDWORD(v50) - HIDWORD(v312)) | ((unint64_t)(v312 - v50) << 32);
      sub_1D3D6D5B8(*(_DWORD *)(*(_QWORD *)v53 + 24), *(_DWORD *)(*(_QWORD *)v53 + 28), (uint64_t)v51);
      v309 = v54;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 3) + 24), *(_DWORD *)(*((_QWORD *)v53 + 3) + 28), (uint64_t)(v51 + 12));
      v308 = v55;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 6) + 24), *(_DWORD *)(*((_QWORD *)v53 + 6) + 28), (uint64_t)(v51 + 24));
      v307 = v56;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 9) + 24), *(_DWORD *)(*((_QWORD *)v53 + 9) + 28), (uint64_t)(v51 + 36));
      v306 = v57;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 12) + 24), *(_DWORD *)(*((_QWORD *)v53 + 12) + 28), (uint64_t)(v51 + 48));
      v305 = v58;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 15) + 24), *(_DWORD *)(*((_QWORD *)v53 + 15) + 28), (uint64_t)(v51 + 60));
      v311 = v59;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 18) + 24), *(_DWORD *)(*((_QWORD *)v53 + 18) + 28), (uint64_t)(v51 + 72));
      v304 = v60;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 21) + 24), *(_DWORD *)(*((_QWORD *)v53 + 21) + 28), (uint64_t)(v51 + 84));
      v313 = v61;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 24) + 24), *(_DWORD *)(*((_QWORD *)v53 + 24) + 28), (uint64_t)(v51 + 96));
      v63 = v62;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 27) + 24), *(_DWORD *)(*((_QWORD *)v53 + 27) + 28), (uint64_t)(v51 + 108));
      v65 = v64;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 30) + 24), *(_DWORD *)(*((_QWORD *)v53 + 30) + 28), (uint64_t)(v51 + 120));
      v67 = v66;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 33) + 24), *(_DWORD *)(*((_QWORD *)v53 + 33) + 28), (uint64_t)(v51 + 132));
      v69 = v68;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 36) + 24), *(_DWORD *)(*((_QWORD *)v53 + 36) + 28), (uint64_t)(v51 + 144));
      v71 = v70;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 39) + 24), *(_DWORD *)(*((_QWORD *)v53 + 39) + 28), (uint64_t)(v51 + 156));
      v73 = v72;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 42) + 24), *(_DWORD *)(*((_QWORD *)v53 + 42) + 28), (uint64_t)(v51 + 168));
      v75 = v74;
      sub_1D3D6D5B8(*(_DWORD *)(*((_QWORD *)v53 + 45) + 24), *(_DWORD *)(*((_QWORD *)v53 + 45) + 28), (uint64_t)(v51 + 180));
      v77 = v76;
      v78 = operator new(0x80uLL);
      v79 = v78;
      v80 = 0;
      *v78 = v309;
      v78[1] = v308;
      v78[2] = v307;
      v78[3] = v306;
      v78[4] = v305;
      v78[5] = v311;
      v78[6] = v304;
      v78[7] = v313;
      v78[8] = v63;
      v78[9] = v65;
      v78[10] = v67;
      v78[11] = v69;
      v78[12] = v71;
      v78[13] = v73;
      v81 = (char *)&unk_1D3E5D4C0;
      v78[14] = v75;
      v78[15] = v77;
      do
      {
        v82 = 0;
        v83 = 0.0;
        do
        {
          v83 = *(double *)&v78[*(int *)&v81[v82]] + v83;
          v82 += 4;
        }
        while (v82 != 16);
        *(double *)&(&v386)[v80++] = v83;
        v81 += 16;
      }
      while (v80 != 4);
      v84 = (unsigned int **)&v386;
      v85 = (unsigned int *)v386;
      for (i = 1; i != 4; ++i)
      {
        if (*(double *)&(&v386)[i] < *(double *)&v85)
        {
          v85 = (unsigned int *)(&v386)[i];
          v84 = (unsigned int **)&(&v386)[i];
        }
      }
      v87 = (char *)v84 - (char *)&v386;
      v88 = (int *)((char *)&unk_1D3E5D4C0 + 2 * ((char *)v84 - (char *)&v386));
      v89 = (uint64_t)&v51[12 * *v88];
      v90 = (uint64_t)&v51[12 * v88[1]];
      v91 = sub_1D3D6D62C(v89, v90);
      v93 = v92;
      v94 = (uint64_t)&v51[12 * v88[2]];
      v95 = sub_1D3D6D62C(v90, v94);
      v97 = v96;
      v98 = (uint64_t)&v51[12 * v88[3]];
      v99 = sub_1D3D6D62C(v94, v98);
      v101 = v100;
      v102 = sub_1D3D6D62C(v98, v89);
      v104 = v103;
      v105 = (double *)operator new(0x40uLL);
      *v105 = v91;
      *((_QWORD *)v105 + 1) = v93;
      v105[2] = v95;
      *((_QWORD *)v105 + 3) = v97;
      v105[4] = v99;
      *((_QWORD *)v105 + 5) = v101;
      v105[6] = v102;
      *((_QWORD *)v105 + 7) = v104;
      v106 = (double *)operator new(0x40uLL);
      v107 = *((_OWORD *)v105 + 1);
      *(_OWORD *)v106 = *(_OWORD *)v105;
      *((_OWORD *)v106 + 1) = v107;
      v108 = *((_OWORD *)v105 + 3);
      *((_OWORD *)v106 + 2) = *((_OWORD *)v105 + 2);
      *((_OWORD *)v106 + 3) = v108;
      v109 = (unsigned int *)(&v386)[v87 >> 3];
      operator delete(v105);
      operator delete(v79);
      operator delete(v51);
      v110 = 0;
      v111 = 0;
      v112 = 1.79769313e308;
      v113 = 16;
LABEL_61:
      v114 = v110++;
      v115 = v113;
      while (1)
      {
        v116 = vsubq_f64(*(float64x2_t *)&v106[2 * v114], *(float64x2_t *)((char *)v106 + v115));
        v117 = sqrt(vaddvq_f64(vmulq_f64(v116, v116)));
        if (v117 < 15.0)
          break;
        if (v117 < v112)
          v112 = v117;
        v115 += 16;
        if (v115 == 64)
        {
          v111 = v114 > 1;
          v113 += 16;
          if (v110 != 3)
            goto LABEL_61;
          v111 = 1;
          break;
        }
      }
      if (v111 && v112 > *(double *)&v109)
      {
        v118 = *v106;
        v119 = v106[1];
        v120 = v106[2];
        v121 = v106[3];
        v122 = v106[4];
        v123 = v106[5];
        v124 = v106[6];
        v125 = v106[7];
        sub_1D3DB93EC((uint64_t *)&v365, 3.5, -3.5, 3.5, 3.5, -3.5, 3.5, -3.5, -3.5, v118, v119, v120, v121, v122, v123, v124, v125);
        v126 = v365;
        if (v365)
        {
          v127 = v365 + 2;
          do
            v128 = __ldxr(v127);
          while (__stxr(v128 + 1, v127));
        }
        v352 = v126;
        v370 = 0;
        sub_1D3D8CDDC(&__p, 2uLL, &v370);
        v129 = v352;
        if (v352)
        {
          v130 = v352 + 2;
          do
            v131 = __ldxr(v130);
          while (__stxr(v131 + 1, v130));
        }
        v369 = v129;
        v132 = sub_1D3D8CCDC((uint64_t)&v332, &v369, 5u, 0xFFFFFFFB, 0, 1u);
        sub_1D3D6F2E0(&v369);
        v133 = v352;
        if (v352)
        {
          v134 = v352 + 2;
          do
            v135 = __ldxr(v134);
          while (__stxr(v135 + 1, v134));
        }
        v368 = v133;
        v136 = sub_1D3D8CCDC((uint64_t)&v332, &v368, 5u, 5u, 0xFFFFFFFF, 0);
        sub_1D3D6F2E0(&v368);
        v137 = v352;
        if (v352)
        {
          v138 = v352 + 2;
          do
            v139 = __ldxr(v138);
          while (__stxr(v139 + 1, v138));
        }
        v367 = v137;
        v140 = sub_1D3D8CCDC((uint64_t)&v332, &v367, 0xFFFFFFFB, 5u, 0, 0xFFFFFFFF);
        sub_1D3D6F2E0(&v367);
        v141 = v352;
        if (v352)
        {
          v142 = v352 + 2;
          do
            v143 = __ldxr(v142);
          while (__stxr(v143 + 1, v142));
        }
        v366 = v141;
        v144 = sub_1D3D8CCDC((uint64_t)&v332, &v366, 0xFFFFFFFB, 0xFFFFFFFB, 1u, 0);
        sub_1D3D6F2E0(&v366);
        if (__p)
        {
          v379 = __p;
          operator delete(__p);
        }
        v145 = v136 + v132 + v140 + v144;
        sub_1D3D6F2E0(&v352);
        v146 = v145 > 5;
        if (v145 <= 5)
          v147 = 7;
        else
          v147 = 5;
        v335 = v146;
        LODWORD(v337) = v147;
        v148 = v365;
        if (v365)
        {
          v149 = v365 + 2;
          do
            v150 = __ldxr(v149);
          while (__stxr(v150 + 1, v149));
          v147 = v337;
          v351 = v148;
          v151 = v148 + 2;
          do
            v152 = __ldxr(v151);
          while (__stxr(v152 + 1, v151));
          v153 = v337;
        }
        else
        {
          v351 = 0;
          v153 = v147;
        }
        v374 = v148;
        sub_1D3D8CE5C((uint64_t *)&v357, (uint64_t)&v332, &v374, v147, -v147, 0, 1u, (2 * v153) | 1);
        v154 = v351;
        if (v351)
        {
          v155 = v351 + 2;
          do
            v156 = __ldxr(v155);
          while (__stxr(v156 + 1, v155));
        }
        v373 = v154;
        sub_1D3D8CE5C((uint64_t *)&v358, (uint64_t)&v332, &v373, v147, v147, 0xFFFFFFFF, 0, (2 * v337) | 1);
        v157 = v351;
        if (v351)
        {
          v158 = v351 + 2;
          do
            v159 = __ldxr(v158);
          while (__stxr(v159 + 1, v158));
        }
        v372 = v157;
        sub_1D3D8CE5C((uint64_t *)v359, (uint64_t)&v332, &v372, -v147, v147, 0, 0xFFFFFFFF, (2 * v337) | 1);
        v160 = v351;
        if (v351)
        {
          v161 = v351 + 2;
          do
            v162 = __ldxr(v161);
          while (__stxr(v162 + 1, v161));
        }
        v371 = v160;
        sub_1D3D8CE5C((uint64_t *)v359 + 1, (uint64_t)&v332, &v371, -v147, -v147, 1u, 0, (2 * v337) | 1);
        sub_1D3D6F2E0(&v371);
        sub_1D3D6F2E0(&v372);
        sub_1D3D6F2E0(&v373);
        sub_1D3D6F2E0(&v374);
        sub_1D3D6F2E0(&v351);
        sub_1D3D8E680((uint64_t)&v332, (uint64_t *)&v357);
        v163 = v365;
        if (v365)
        {
          v164 = v365 + 2;
          do
            v165 = __ldxr(v164);
          while (__stxr(v165 + 1, v164));
        }
        v350 = v163;
        v166 = sub_1D3D8CB94(v335, v336);
        if (!v335 && v166 >= 34)
        {
          v167 = v166 >> 1;
          v168 = 16;
          do
          {
            v169 = v350;
            if (v350)
            {
              v170 = v350 + 2;
              do
                v171 = __ldxr(v170);
              while (__stxr(v171 + 1, v170));
            }
            v347 = (unsigned int **)v169;
            v172 = -(int)v168 & 0xFFFFFFF0;
            v173 = sub_1D3D8DCD8((uint64_t)&v332, (unsigned int **)&v347, v168 | (v172 << 32));
            v175 = v174;
            sub_1D3D6F2E0((unsigned int **)&v347);
            v176 = v350;
            if (v350)
            {
              v177 = v350 + 2;
              do
                v178 = __ldxr(v177);
              while (__stxr(v178 + 1, v177));
            }
            p_p = (void **)v176;
            v179 = sub_1D3D8DCD8((uint64_t)&v332, (unsigned int **)&p_p, v168 | (v168 << 32));
            v181 = v180;
            sub_1D3D6F2E0((unsigned int **)&p_p);
            v182 = v350;
            if (v350)
            {
              v183 = v350 + 2;
              do
                v184 = __ldxr(v183);
              while (__stxr(v184 + 1, v183));
            }
            v377 = v182;
            v185 = sub_1D3D8DCD8((uint64_t)&v332, &v377, (v168 << 32) | v172);
            v187 = v186;
            sub_1D3D6F2E0(&v377);
            v188 = v350;
            if (v350)
            {
              v189 = v350 + 2;
              do
                v190 = __ldxr(v189);
              while (__stxr(v190 + 1, v189));
            }
            v376 = v188;
            v191 = sub_1D3D8DCD8((uint64_t)&v332, &v376, (v172 << 32) | v172);
            v193 = v192;
            sub_1D3D6F2E0(&v376);
            sub_1D3DB93EC((uint64_t *)&v375, (float)(int)v168, -(float)(int)v168, (float)(int)v168, (float)(int)v168, -(float)(int)v168, (float)(int)v168, -(float)(int)v168, -(float)(int)v168, v173, v175, v179, v181, v185, v187, v191, v193);
            v194 = v375;
            if (v375)
            {
              v195 = v375 + 2;
              do
                v196 = __ldxr(v195);
              while (__stxr(v196 + 1, v195));
            }
            if (v350)
              sub_1D3D6D13C(v350);
            v350 = v194;
            sub_1D3D6F2E0(&v375);
            v168 += 16;
          }
          while (v168 < v167);
        }
        v197 = v350;
        if (v350)
        {
          v198 = v350 + 2;
          do
            v199 = __ldxr(v198);
          while (__stxr(v199 + 1, v198));
          v386 = (unsigned int **)v197;
          do
            v200 = __ldxr(v198);
          while (__stxr(v200 + 1, v198));
        }
        else
        {
          *(double *)&v197 = 0.0;
          *(double *)&v386 = 0.0;
        }
        if (v365)
          sub_1D3D6D13C(v365);
        v365 = v197;
        sub_1D3D6F2E0((unsigned int **)&v386);
        sub_1D3D6F2E0(&v350);
        v201 = v365;
        if (v365)
        {
          v202 = v365 + 2;
          do
            v203 = __ldxr(v202);
          while (__stxr(v203 + 1, v202));
        }
        v346 = v201;
        v204 = sub_1D3D8CB94(v335, v336);
        v205 = (float *)operator new(0x20uLL);
        v206 = (float)v204 * 0.5;
        v383 = v205 + 8;
        *v205 = v206;
        v205[1] = -v206;
        v205[2] = v206;
        v205[3] = v206;
        v205[4] = -v206;
        v205[5] = v206;
        v205[6] = -v206;
        v205[7] = -v206;
        v381 = v205;
        v382 = v205 + 8;
        (*(void (**)(unsigned int *, void **))(*(_QWORD *)v346 + 16))(v346, &v381);
        *(double *)&v207 = COERCE_DOUBLE(operator new());
        v208 = v381;
        *(_DWORD *)(v207 + 8) = 0;
        v209 = (unsigned int *)(v207 + 8);
        *(_QWORD *)v207 = &off_1E95AF250;
        *(_QWORD *)(v207 + 12) = *v208;
        do
          v210 = __ldxr(v209);
        while (__stxr(v210 + 1, v209));
        v386 = (unsigned int **)v207;
        v211 = operator new();
        v212 = v381;
        *(_DWORD *)(v211 + 8) = 0;
        v213 = (unsigned int *)(v211 + 8);
        *(_QWORD *)v211 = &off_1E95AF250;
        *(_QWORD *)(v211 + 12) = v212[1];
        do
          v214 = __ldxr(v213);
        while (__stxr(v214 + 1, v213));
        v387 = (unsigned int **)v211;
        v215 = operator new();
        v216 = v381;
        *(_DWORD *)(v215 + 8) = 0;
        v217 = (unsigned int *)(v215 + 8);
        *(_QWORD *)v215 = &off_1E95AF250;
        *(_QWORD *)(v215 + 12) = v216[2];
        do
          v218 = __ldxr(v217);
        while (__stxr(v218 + 1, v217));
        *(_QWORD *)&v388 = v215;
        v219 = operator new();
        v220 = v381;
        *(_DWORD *)(v219 + 8) = 0;
        v221 = (unsigned int *)(v219 + 8);
        *(_QWORD *)v219 = &off_1E95AF250;
        *(_QWORD *)(v219 + 12) = v220[3];
        do
          v222 = __ldxr(v221);
        while (__stxr(v222 + 1, v221));
        *((_QWORD *)&v388 + 1) = v219;
        v380 = 0;
        __p = 0;
        v379 = 0;
        p_p = &__p;
        v385 = 0;
        __p = operator new(0x20uLL);
        v379 = __p;
        v380 = (char *)__p + 32;
        v379 = sub_1D3D8CFF8((unsigned int **)&v386, (unsigned int **)&v389, (unsigned int **)__p);
        for (j = 3; j != -1; --j)
          sub_1D3D6D834((unsigned int **)&(&v386)[j]);
        if ((_BYTE)v338)
        {
          v224 = (HIDWORD(v337) + 2) & 3;
          if (HIDWORD(v337) + 2 <= 0)
            v224 = -(-(HIDWORD(v337) + 2) & 3);
          v225 = __p;
          v226 = (HIDWORD(v337) + 3) & 3;
          if (HIDWORD(v337) + 3 <= 0)
            v226 = -(-(HIDWORD(v337) + 3) & 3);
          v227 = *((unsigned int **)__p + v224);
          if (*(double *)&v227 != 0.0)
          {
            v228 = v227 + 2;
            do
              v229 = __ldxr(v228);
            while (__stxr(v229 + 1, v228));
          }
          v230 = v226;
          v386 = (unsigned int **)v227;
          v231 = v225[v226];
          if (v231)
          {
            v232 = (unsigned int *)(v231 + 8);
            do
              v233 = __ldxr(v232);
            while (__stxr(v233 + 1, v232));
          }
          v234 = v224;
          v235 = (unsigned int *)v225[v224];
          if (v235)
          {
            sub_1D3D6D13C(v235);
            v227 = (unsigned int *)v386;
          }
          v225[v234] = v231;
          if (*(double *)&v227 != 0.0)
          {
            v236 = v227 + 2;
            do
              v237 = __ldxr(v236);
            while (__stxr(v237 + 1, v236));
          }
          v238 = (unsigned int *)v225[v230];
          if (v238)
            sub_1D3D6D13C(v238);
          v225[v230] = v227;
          sub_1D3D6D834((unsigned int **)&v386);
          if (SHIDWORD(v337) <= 0)
            v239 = -(-HIDWORD(v337) & 3);
          else
            v239 = BYTE4(v337) & 3;
          v240 = __p;
          v241 = (HIDWORD(v337) + 1) & 3;
          if (HIDWORD(v337) + 1 <= 0)
            v241 = -(-(HIDWORD(v337) + 1) & 3);
          v242 = *((unsigned int **)__p + v239);
          if (*(double *)&v242 != 0.0)
          {
            v243 = v242 + 2;
            do
              v244 = __ldxr(v243);
            while (__stxr(v244 + 1, v243));
          }
          v245 = v241;
          v386 = (unsigned int **)v242;
          v246 = v240[v241];
          if (v246)
          {
            v247 = (unsigned int *)(v246 + 8);
            do
              v248 = __ldxr(v247);
            while (__stxr(v248 + 1, v247));
          }
          v249 = v239;
          v250 = (unsigned int *)v240[v239];
          if (v250)
          {
            sub_1D3D6D13C(v250);
            v242 = (unsigned int *)v386;
          }
          v240[v249] = v246;
          if (*(double *)&v242 != 0.0)
          {
            v251 = v242 + 2;
            do
              v252 = __ldxr(v251);
            while (__stxr(v252 + 1, v251));
          }
          v253 = (unsigned int *)v240[v245];
          if (v253)
            sub_1D3D6D13C(v253);
          v240[v245] = v242;
          sub_1D3D6D834((unsigned int **)&v386);
        }
        v348 = 0;
        v347 = 0;
        v349 = 0;
        v254 = BYTE4(v337) & 3;
        if (SHIDWORD(v337) <= 0)
          v254 = -(-HIDWORD(v337) & 3);
        v255 = (unsigned int **)sub_1D3D8D0B0((uint64_t)&v347, (unsigned int **)__p + v254);
        v256 = v255;
        v348 = v255;
        v257 = (HIDWORD(v337) + 3) & 3;
        if (HIDWORD(v337) + 3 <= 0)
          v257 = -(-(HIDWORD(v337) + 3) & 3);
        v258 = (unsigned int **)((char *)__p + 8 * v257);
        if ((unint64_t)v255 >= v349)
        {
          v259 = (unsigned int **)sub_1D3D8D0B0((uint64_t)&v347, v258);
        }
        else
        {
          sub_1D3D8D1BC((unsigned int *)&v347, v258);
          v259 = v256 + 1;
        }
        v348 = v259;
        v260 = (HIDWORD(v337) + 2) & 3;
        if (HIDWORD(v337) + 2 <= 0)
          v260 = -(-(HIDWORD(v337) + 2) & 3);
        v261 = (unsigned int **)((char *)__p + 8 * v260);
        if ((unint64_t)v259 >= v349)
        {
          v262 = (unsigned int **)sub_1D3D8D0B0((uint64_t)&v347, v261);
        }
        else
        {
          sub_1D3D8D1BC((unsigned int *)&v347, v261);
          v262 = v259 + 1;
        }
        v348 = v262;
        v263 = (HIDWORD(v337) + 1) & 3;
        if (HIDWORD(v337) + 1 <= 0)
          v263 = -(-(HIDWORD(v337) + 1) & 3);
        v264 = (unsigned int **)((char *)__p + 8 * v263);
        if ((unint64_t)v262 >= v349)
        {
          v265 = (unsigned int **)sub_1D3D8D0B0((uint64_t)&v347, v264);
        }
        else
        {
          sub_1D3D8D1BC((unsigned int *)&v347, v264);
          v265 = v262 + 1;
        }
        v348 = v265;
        *(double *)&v386 = COERCE_DOUBLE(&__p);
        sub_1D3D6D79C((void ***)&v386);
        if (v381)
        {
          v382 = v381;
          operator delete(v381);
        }
        sub_1D3D6F2E0(&v346);
        v266 = v334;
        if (v334)
        {
          v267 = v334 + 2;
          do
            v268 = __ldxr(v267);
          while (__stxr(v268 + 1, v267));
        }
        v345 = v266;
        v269 = v347;
        v270 = *v347;
        if (*v347)
        {
          v271 = v270 + 2;
          do
            v272 = __ldxr(v271);
          while (__stxr(v272 + 1, v271));
        }
        v344 = v270;
        v273 = v269[1];
        if (v273)
        {
          v274 = v273 + 2;
          do
            v275 = __ldxr(v274);
          while (__stxr(v275 + 1, v274));
        }
        v343 = v273;
        v276 = v269[2];
        if (v276)
        {
          v277 = v276 + 2;
          do
            v278 = __ldxr(v277);
          while (__stxr(v278 + 1, v277));
        }
        v342 = v276;
        v279 = v269[3];
        if (v279)
        {
          v280 = v279 + 2;
          do
            v281 = __ldxr(v280);
          while (__stxr(v281 + 1, v280));
        }
        v341 = v279;
        sub_1D3D8F02C((uint64_t *)&v381, v335, v336, &v345, &v344, &v343, &v342, &v341, HIBYTE(v338));
        sub_1D3D6D834(&v341);
        sub_1D3D6D834(&v342);
        sub_1D3D6D834(&v343);
        sub_1D3D6D834(&v344);
        sub_1D3D6D10C(&v345);
        v282 = (unsigned int *)operator new();
        v283 = (unsigned int *)v381;
        if (v381)
        {
          v284 = (unsigned int *)((char *)v381 + 8);
          do
            v285 = __ldxr(v284);
          while (__stxr(v285 + 1, v284));
        }
        v340 = v283;
        memset(v339, 0, sizeof(v339));
        sub_1D3D6D6A8((unsigned int *)v339, v347, v348, v348 - v347);
        sub_1D3D6D8D4((uint64_t)v282, v340, v339, SHIBYTE(v338), v335, SHIDWORD(v336), v336);
        v286 = v282 + 2;
        do
          v287 = __ldxr(v286);
        while (__stxr(v287 + 1, v286));
        v329 = (unsigned int ***)v282;
        *(double *)&v386 = COERCE_DOUBLE(v339);
        sub_1D3D6D79C((void ***)&v386);
        sub_1D3D6D10C(&v340);
        sub_1D3D6D10C((unsigned int **)&v381);
        *(double *)&v386 = COERCE_DOUBLE(&v347);
        sub_1D3D6D79C((void ***)&v386);
        for (k = 3; k != -1; --k)
          sub_1D3D81D1C((unsigned int **)&(&v357)[k]);
        sub_1D3D6F2E0(&v365);
      }
      else
      {
        v329 = 0;
      }
      operator delete(v106);
      *(double *)&v386 = COERCE_DOUBLE(&v354);
      sub_1D3D6D3BC((void ***)&v386);
      sub_1D3D7F2A8(&v328);
      if (v329)
      {
        *(double *)&v386 = 0.0;
        v387 = 0;
        *(_QWORD *)&v388 = 0;
        sub_1D3D6D6A8((unsigned int *)&v386, v329[2], v329[3], v329[3] - v329[2]);
        v289 = (unsigned int *)v329;
        if (v329)
        {
          v290 = (unsigned int *)(v329 + 1);
          do
            v291 = __ldxr(v290);
          while (__stxr(v291 + 1, v290));
        }
        v327 = v289;
        sub_1D3D7FD5C((uint64_t *)&v354, (uint64_t)&v327);
        sub_1D3D7F2D8(&v327);
        v292 = *((unsigned __int8 *)v329 + 12);
        *((_DWORD *)sub_1D3D7F308((uint64_t **)v354 + 12, 9, (unsigned int *)&unk_1D3E80D00) + 8) = v292;
        v293 = (unsigned int **)operator new();
        v325 = 0;
        v326 = 0;
        v324 = 0;
        v323 = &off_1E95AF9B0;
        v294 = (unsigned int *)*((_QWORD *)v354 + 4);
        if (v294)
        {
          v295 = v294 + 2;
          do
            v296 = __ldxr(v295);
          while (__stxr(v296 + 1, v295));
          if (v325)
            sub_1D3D6D13C(v325);
        }
        v325 = v294;
        memset(v322, 0, sizeof(v322));
        sub_1D3D6D6A8((unsigned int *)v322, v386, v387, v387 - v386);
        sub_1D3D7F3AC((uint64_t)v321, (_QWORD *)v354 + 12);
        sub_1D3E17B10((uint64_t)v293, (uint64_t *)&v326, (uint64_t)&v323, v322, 10, v321);
        v297 = (unsigned int *)(v293 + 1);
        do
          v298 = __ldxr(v297);
        while (__stxr(v298 + 1, v297));
        v339[0] = v293;
        sub_1D3D7F520((_QWORD *)v321[1]);
        v357 = (unsigned int **)v322;
        sub_1D3D6D79C((void ***)&v357);
        sub_1D3D7F558(&v323);
        sub_1D3D7F598(&v326);
        v299 = *(_QWORD *)(a3 + 8);
        if (v299 >= *(_QWORD *)(a3 + 16))
        {
          v300 = sub_1D3D7F62C((unsigned int ***)a3, (unsigned int **)v339);
        }
        else
        {
          sub_1D3D7F5C8((unsigned int *)a3, (unsigned int **)v339);
          v300 = (unsigned int **)(v299 + 8);
        }
        *(_QWORD *)(a3 + 8) = v300;
        sub_1D3D7F7E4((unsigned int **)v339);
        sub_1D3D7F814(&v354);
        v357 = (unsigned int **)&v386;
        sub_1D3D6D79C((void ***)&v357);
      }
      sub_1D3D7F2D8((unsigned int **)&v329);
      sub_1D3D7F2A8(&v330);
      v7 = v320 + 1;
    }
    while (v320 + 1 != v303);
  }
  v332 = &off_1E95AF650;
  return sub_1D3D6D10C(&v334);
}

void sub_1D3D7F25C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,unsigned int *a56,uint64_t a57,uint64_t (**a58)())
{
  uint64_t v58;

  sub_1D3D7F2A8(&a56);
  a58 = &off_1E95AF650;
  sub_1D3D6D10C(a13);
  *(_QWORD *)(v58 - 256) = a18;
  sub_1D3D7F844((void ***)(v58 - 256));
  JUMPOUT(0x1D3D7F2A0);
}

unsigned int **sub_1D3D7F2A8(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

unsigned int **sub_1D3D7F2D8(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

uint64_t *sub_1D3D7F308(uint64_t **a1, int a2, unsigned int *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v9 + 28) = *a3;
    sub_1D3D7F928(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

uint64_t sub_1D3D7F3AC(uint64_t a1, _QWORD *a2)
{
  uint64_t **v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t **v9;
  BOOL v10;
  int v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  _QWORD *v15;
  _QWORD *v16;
  int v17;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (uint64_t **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = *(uint64_t **)(a1 + 8);
      v7 = v3;
      if (*(uint64_t ***)a1 == v3)
        goto LABEL_8;
      v8 = *(_QWORD *)(a1 + 8);
      v9 = v3;
      if (v6)
      {
        do
        {
          v7 = (uint64_t **)v8;
          v8 = *(_QWORD *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          v7 = (uint64_t **)v9[2];
          v10 = *v7 == (uint64_t *)v9;
          v9 = v7;
        }
        while (v10);
      }
      v11 = *((_DWORD *)v5 + 7);
      if (*((_DWORD *)v7 + 7) < v11)
      {
LABEL_8:
        if (v6)
          v12 = v7;
        else
          v12 = v3;
        if (v6)
          v13 = v7 + 1;
        else
          v13 = v3;
      }
      else
      {
        v12 = v3;
        v13 = v3;
        if (v6)
        {
          v13 = v3;
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v6;
              v17 = *((_DWORD *)v6 + 7);
              if (v11 >= v17)
                break;
              v6 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_15;
            }
            if (v17 >= v11)
              break;
            v13 = v12 + 1;
            v6 = v12[1];
            if (!v6)
              goto LABEL_15;
          }
        }
      }
      if (!*v13)
      {
LABEL_15:
        v14 = (uint64_t *)operator new(0x28uLL);
        *(uint64_t *)((char *)v14 + 28) = *(_QWORD *)((char *)v5 + 28);
        sub_1D3D7F928((uint64_t **)a1, (uint64_t)v12, v13, v14);
      }
      v15 = (_QWORD *)v5[1];
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = (_QWORD *)v5[2];
          v10 = *v16 == (_QWORD)v5;
          v5 = v16;
        }
        while (!v10);
      }
      v5 = v16;
    }
    while (v16 != v4);
  }
  return a1;
}

void sub_1D3D7F50C(_Unwind_Exception *a1)
{
  _QWORD **v1;

  sub_1D3D7F520(*v1);
  _Unwind_Resume(a1);
}

void sub_1D3D7F520(_QWORD *a1)
{
  if (a1)
  {
    sub_1D3D7F520(*a1);
    sub_1D3D7F520(a1[1]);
    operator delete(a1);
  }
}

_QWORD *sub_1D3D7F558(_QWORD *a1)
{
  unsigned int *v2;

  *a1 = &off_1E95AF9B0;
  v2 = (unsigned int *)a1[2];
  if (v2)
    sub_1D3D6D13C(v2);
  a1[2] = 0;
  return a1;
}

unsigned int **sub_1D3D7F598(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

unsigned int *sub_1D3D7F5C8(unsigned int *result, unsigned int **a2)
{
  unsigned int *v2;
  unsigned int **v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;

  v2 = result;
  v3 = (unsigned int **)*((_QWORD *)result + 1);
  *v3 = 0;
  v4 = *a2;
  if (*a2)
  {
    v5 = v4 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    result = *v3;
    if (*v3)
      result = sub_1D3D6D13C(result);
  }
  *v3 = v4;
  *((_QWORD *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1D3D7F624(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3D7F62C(unsigned int ***a1, unsigned int **a2)
{
  uint64_t v2;
  unint64_t v3;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int **v10;
  unsigned int *v11;
  unsigned int **v12;
  unsigned int **v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int **v16;
  unint64_t v17;
  unsigned int **v18;
  uint64_t v19;
  unsigned int **v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int *v23;
  unsigned int v24;
  int64x2_t v25;
  unint64_t v26;
  unint64_t v28;
  int64x2_t v29;
  unint64_t v30;
  _QWORD *v31;

  v2 = a1[1] - *a1;
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61)
    sub_1D3D6D4F8();
  v6 = a1 + 2;
  v7 = (char *)a1[2] - (char *)*a1;
  if (v7 >> 2 > v3)
    v3 = v7 >> 2;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8)
    v8 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v8 = v3;
  v31 = v6;
  if (v8)
    v8 = (unint64_t)sub_1D3D6D8A0(v8);
  else
    v9 = 0;
  v10 = (unsigned int **)(v8 + 8 * v2);
  v28 = v8;
  v29.i64[0] = (uint64_t)v10;
  v29.i64[1] = (uint64_t)v10;
  v30 = v8 + 8 * v9;
  *v10 = 0;
  v11 = *a2;
  v12 = v10;
  v13 = v10;
  if (v11)
  {
    v14 = v11 + 2;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v12 = v10;
    v13 = v10;
    if (*v10)
    {
      sub_1D3D6D13C(*v10);
      v13 = (unsigned int **)v29.i64[1];
      v12 = (unsigned int **)v29.i64[0];
    }
  }
  *v10 = v11;
  v16 = v13 + 1;
  v29.i64[1] = (uint64_t)(v13 + 1);
  v18 = *a1;
  v17 = (unint64_t)a1[1];
  if ((unsigned int **)v17 == *a1)
  {
    v25 = vdupq_n_s64(v17);
  }
  else
  {
    v19 = 0;
    v20 = v12;
    do
    {
      *--v20 = 0;
      v22 = *(unsigned int **)(v17 - 8);
      v17 -= 8;
      v21 = v22;
      if (v22)
      {
        v23 = v21 + 2;
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
        if (*v20)
          sub_1D3D6D13C(*v20);
      }
      *v20 = v21;
      v19 -= 8;
    }
    while ((unsigned int **)v17 != v18);
    v25 = *(int64x2_t *)a1;
    v16 = (unsigned int **)v29.i64[1];
    v12 = v20;
  }
  *a1 = v12;
  a1[1] = v16;
  v29 = v25;
  v26 = (unint64_t)a1[2];
  a1[2] = (unsigned int **)v30;
  v30 = v26;
  v28 = v25.i64[0];
  sub_1D3D7F8B4((uint64_t)&v28);
  return v16;
}

void sub_1D3D7F7B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D7F8B4((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3D7F7E4(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

unsigned int **sub_1D3D7F814(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

void sub_1D3D7F844(void ***a1)
{
  void **v1;
  unsigned int **v2;
  unsigned int **v4;
  void *v5;

  v1 = *a1;
  v2 = (unsigned int **)**a1;
  if (v2)
  {
    v4 = (unsigned int **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3D7F7E4(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1D3D7F8B4(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    sub_1D3D7F7E4((unsigned int **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1D3D7F904(_QWORD *a1)
{
  sub_1D3D7F558(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t *sub_1D3D7F928(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = sub_1D3D7F97C(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1D3D7F97C(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t sub_1D3D7FB14(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF650;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  return a1;
}

void sub_1D3D7FB44(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF650;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  JUMPOUT(0x1D8254C54);
}

void sub_1D3D7FB84(void ***a1)
{
  void **v1;
  unsigned int **v2;
  unsigned int **v4;
  void *v5;

  v1 = *a1;
  v2 = (unsigned int **)**a1;
  if (v2)
  {
    v4 = (unsigned int **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3D7F2A8(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned int **sub_1D3D7FBF4(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

unsigned int **sub_1D3D7FC24(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

_QWORD *sub_1D3D7FC54(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  __int128 v4;

  *a1 = &off_1E95AFA80;
  v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1D3D7FCC0(v3, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(_QWORD *)(a2 + 24);
    *(_OWORD *)v3 = v4;
  }
  return a1;
}

void sub_1D3D7FCAC(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1D3D7FCC0(_BYTE *__dst, void *__src, unint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8)
      sub_1D3D7FD48();
    v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v6 = a3 | 7;
    v7 = v6 + 1;
    v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *v5 = v8;
    v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

void sub_1D3D7FD48()
{
  sub_1D3D6D534("basic_string");
}

unsigned int **sub_1D3D7FD5C(uint64_t *a1, uint64_t a2)
{
  int v2;
  int v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int *v28;
  unint64_t v29;
  unsigned int v30;
  unsigned int *v31;
  unsigned int v32;
  uint64_t *v33;
  int v34;
  unsigned int v35;
  unsigned int *v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int *v72;
  unsigned int v73;
  unint64_t v74;
  unsigned int *v75;
  unsigned int *v76;
  unsigned int v77;
  unsigned int *v78;
  unsigned int *v79;
  unsigned int v80;
  unsigned int *v81;
  unsigned int *v82;
  unsigned int v83;
  unsigned int v84;
  uint64_t *v85;
  unsigned int *v86;
  unsigned int *v87;
  unsigned int v88;
  unsigned int v89;
  uint64_t *v90;
  unsigned int *v91;
  unsigned int *v92;
  unsigned int v93;
  unsigned int v94;
  uint64_t *v95;
  unsigned int v96;
  unsigned int *v97;
  unsigned int *v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t *v101;
  int *v102;
  int *v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  signed int v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unsigned int *v114;
  unsigned int *v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int *v118;
  unsigned int *v119;
  unsigned int v120;
  unsigned int **v121;
  int v122;
  unsigned int v123;
  uint64_t i;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  uint64_t v128;
  unsigned int *v129;
  unsigned int v130;
  int v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  unsigned int *v135;
  unsigned int v136;
  uint64_t v137;
  unsigned int *v138;
  _BYTE *v139;
  unsigned int v140;
  unsigned int *v141;
  unsigned int v142;
  _QWORD *v144;
  _QWORD *exception;
  uint64_t v147;
  _QWORD *v148;
  uint64_t v149;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  uint64_t v159;
  int v160;
  int v161;
  int v162;
  int v163;
  unint64_t v164;
  unint64_t v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  _QWORD v169[3];
  unsigned int *v170;
  uint64_t (**v171)(_QWORD);
  int v172;
  uint64_t v173;
  unsigned int *v174;
  uint64_t (**v175)(_QWORD);
  int v176;
  uint64_t v177;
  int v178;
  unsigned int *v179;
  unsigned int *v180;
  unsigned int *v181;
  unsigned int *v182;
  uint64_t *v183;
  _QWORD *v184;
  uint64_t v185;
  uint64_t (**v186)(_QWORD);
  int v187;
  unsigned int *v188;
  unsigned int *v189;
  __int128 v190;
  uint64_t v191;
  unsigned int *v192;

  v2 = *(unsigned __int8 *)(*(_QWORD *)a2 + 88);
  v3 = *(_DWORD *)(*(_QWORD *)a2 + 96);
  v149 = *(unsigned int *)(*(_QWORD *)a2 + 92);
  v4 = *(unsigned int **)(*(_QWORD *)a2 + 64);
  if (v4)
  {
    v5 = v4 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v182 = v4;
  v151 = v2;
  v152 = v3;
  if (!v2)
  {
    v7 = *(_QWORD *)(*(_QWORD *)a2 + 64);
    if (v7)
    {
      v8 = (unsigned int *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    v181 = (unsigned int *)v7;
    v10 = *(_QWORD *)(v7 + 56);
    v11 = *(_QWORD *)(v7 + 32);
    v12 = *(_QWORD *)(v7 + 16);
    v13 = (uint64_t *)operator new();
    v14 = ((((v12 & (v10 - 1) | v11 & -v10) << 28) - 0x10000000) >> 32) | 1;
    sub_1D3D938C4((uint64_t)v13, (*((_QWORD *)v181 + 2) & (*((_QWORD *)v181 + 7) - 1) | *((_QWORD *)v181 + 4) & -*((_QWORD *)v181 + 7)) - v14, (*((_QWORD *)v181 + 4) & (*((_QWORD *)v181 + 7) - 1) | *((_QWORD *)v181 + 2) & -*((_QWORD *)v181 + 7)) - v14);
    v15 = (unsigned int *)(v13 + 1);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
    v17 = 0;
    v18 = 0;
    v19 = *((_QWORD *)v181 + 7);
    v20 = *((_QWORD *)v181 + 4);
    v21 = v20 & -v19;
    v22 = *((_QWORD *)v181 + 2);
    v183 = v13;
    v164 = (v22 & (v19 + 31) | (unint64_t)v21) >> 1;
    v165 = (int)(v22 & (v19 - 1) | v21) & (unint64_t)~((uint64_t)(int)(v22 & (v19 - 1) | v21) >> 63);
    v23 = (int)(v20 & (v19 - 1) | v22 & -(int)v19) & (unint64_t)~((uint64_t)(int)(v20 & (v19 - 1) | v22 & -(int)v19) >> 63);
    while (v17 != v165)
    {
      if ((((_BYTE)v164 - (_BYTE)v17) & 0xF) != 0)
      {
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v167 = v18;
        v27 = v18;
        v28 = v181;
        while (v23 != v25)
        {
          if (((v24 + ((v28[4] & (v28[14] + 31) | v28[8] & -v28[14]) >> 1)) & 0xFLL) != 0)
          {
            if (sub_1D3D6D4A0(v28, v17, v25))
            {
              v29 = v27 + v13[3] * v26;
              *(_DWORD *)(v13[6] + ((v29 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v29;
            }
            ++v26;
          }
          ++v25;
          --v24;
        }
        v18 = v167 + 1;
      }
      ++v17;
    }
    do
      v30 = __ldxr(v15);
    while (__stxr(v30 + 1, v15));
    v2 = 0;
    v3 = v152;
    if (v182)
      sub_1D3D6D13C(v182);
    v182 = (unsigned int *)v13;
    sub_1D3D6D10C((unsigned int **)&v183);
    sub_1D3D6D10C(&v181);
    v4 = v182;
  }
  if (v4)
  {
    v31 = v4 + 2;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  v179 = v4;
  v147 = v3;
  if (v2)
  {
    if (v3 < 6)
    {
      sub_1D3D82334(&v183, dword_1D3E6027C[v3]);
      goto LABEL_34;
    }
LABEL_162:
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(exception, "data is too long");
    *exception = &off_1E95AF330;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  if (v3 >= 34)
    goto LABEL_162;
  sub_1D3D82334(&v183, dword_1D3E60290[v3]);
LABEL_34:
  v33 = v183;
  v148 = v184;
  if (v3)
  {
    v34 = 0;
    v35 = 0;
    v36 = v179;
    v37 = *((_QWORD *)v36 + 4) & (*((_QWORD *)v36 + 7) - 1) | *((_QWORD *)v36 + 2) & -(int)*((_QWORD *)v36 + 7);
    v162 = (2 * v37) | 1;
    v38 = v37;
    v39 = 2 * v37 - 4;
    v40 = 8 * v37 - 24;
    v41 = 8 * v37 - 16;
    v161 = 6 * v37 - 12;
    v42 = 8 * v37 - 40;
    v160 = 4 * v37 - 8;
    v43 = 8 * v37 - 32;
    v44 = v39;
    v45 = v152;
    do
    {
      v153 = v45;
      v154 = v44;
      v155 = v40;
      v156 = v41;
      v157 = v42;
      v158 = v43;
      v166 = v39;
      v168 = v34;
      if (v44 <= 1)
        v46 = 1;
      else
        v46 = v44;
      if (v38 >= 3)
      {
        v47 = 0;
        v48 = 0;
        do
        {
          v49 = sub_1D3D6D4A0(v36, v48 | v35, v35 + (v47 >> 1));
          v50 = (unint64_t)(v168 + v47) >> 6;
          v51 = 1 << (v168 + v47);
          if (v49)
            v52 = v33[v50] | v51;
          else
            v52 = v33[v50] & ~v51;
          v33[v50] = v52;
          v53 = sub_1D3D6D4A0(v36, v35 + (v47 >> 1), (int)(v35 + v38 + ~v48));
          v54 = (unint64_t)(v166 + v47) >> 6;
          v55 = 1 << (v166 + v47);
          if (v53)
            v56 = v33[v54] | v55;
          else
            v56 = v33[v54] & ~v55;
          v33[v54] = v56;
          v48 = (v48 & 1) == 0;
          ++v47;
        }
        while (v46 != v47);
      }
      v159 = v38;
      if ((int)((2 * v38) | 1) >= 6)
      {
        v57 = 0;
        v58 = v162 + 1;
        v163 = v35 + v38;
        v59 = v162;
        v61 = v160;
        v60 = v161;
        do
        {
          v62 = (int)(v35 - 1 + (v59 >> 1));
          v63 = sub_1D3D6D4A0(v36, v163 + ~v57, v62);
          v64 = (unint64_t)v61 >> 6;
          v65 = 1 << v61;
          if (v63)
            v66 = v33[v64] | v65;
          else
            v66 = v33[v64] & ~v65;
          v33[v64] = v66;
          v67 = sub_1D3D6D4A0(v36, v62, v57 | v35);
          v68 = (unint64_t)v60 >> 6;
          v69 = 1 << v60;
          if (v67)
            v70 = v33[v68] | v69;
          else
            v70 = v33[v68] & ~v69;
          v33[v68] = v70;
          v57 = (v57 & 1) == 0;
          --v58;
          ++v60;
          ++v61;
          --v59;
        }
        while (v58 > 6);
      }
      v35 += 2;
      v38 = v159 - 4;
      v162 -= 8;
      v44 = v154 - 8;
      v39 = v166 + v155;
      v40 = v155 - 32;
      v34 = v168 + v156;
      v161 += v157;
      v42 = v157 - 32;
      v160 += v158;
      v43 = v158 - 32;
      v41 = v156 - 32;
      v45 = v153 - 1;
    }
    while (v153 != 1);
  }
  v71 = operator new();
  sub_1D3D935D8(v71, (uint64_t)v148);
  v72 = (unsigned int *)(v71 + 8);
  do
    v73 = __ldxr(v72);
  while (__stxr(v73 + 1, v72));
  v180 = (unsigned int *)v71;
  if ((int)v148 < 1)
  {
    if (!v33)
      goto LABEL_68;
  }
  else
  {
    v74 = 0;
    do
    {
      if (((*(unint64_t *)((char *)v33 + ((v74 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v74) & 1) != 0)
        *(_DWORD *)(*(_QWORD *)(v71 + 48) + ((v74 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v74;
      ++v74;
    }
    while (v148 != v74);
  }
  operator delete(v33);
LABEL_68:
  sub_1D3D6D10C(&v179);
  v75 = v180;
  if (v180)
  {
    v76 = v180 + 2;
    do
      v77 = __ldxr(v76);
    while (__stxr(v77 + 1, v76));
  }
  v174 = v75;
  sub_1D3DBAE60();
  v78 = *(unsigned int **)qword_1EDB89EE8;
  if (*(_QWORD *)qword_1EDB89EE8)
  {
    v79 = v78 + 2;
    do
      v80 = __ldxr(v79);
    while (__stxr(v80 + 1, v79));
  }
  v192 = v78;
  if (v152 >= 3)
  {
    if (v152 >= 9)
    {
      if (v152 > 0x16)
      {
        sub_1D3DBAE60();
        v97 = *(unsigned int **)qword_1EDB89F00;
        if (*(_QWORD *)qword_1EDB89F00)
        {
          v98 = v97 + 2;
          do
            v99 = __ldxr(v98);
          while (__stxr(v99 + 1, v98));
          do
            v100 = __ldxr(v98);
          while (__stxr(v100 + 1, v98));
          v101 = (uint64_t *)v97;
        }
        else
        {
          v101 = 0;
        }
        v183 = v101;
        if (v192)
          sub_1D3D6D13C(v192);
        v192 = v97;
        sub_1D3D81F38((unsigned int **)&v183);
        v96 = 12;
      }
      else
      {
        sub_1D3DBAE60();
        v91 = *(unsigned int **)qword_1EDB89EF8;
        if (*(_QWORD *)qword_1EDB89EF8)
        {
          v92 = v91 + 2;
          do
            v93 = __ldxr(v92);
          while (__stxr(v93 + 1, v92));
          do
            v94 = __ldxr(v92);
          while (__stxr(v94 + 1, v92));
          v95 = (uint64_t *)v91;
        }
        else
        {
          v95 = 0;
        }
        v183 = v95;
        if (v192)
          sub_1D3D6D13C(v192);
        v192 = v91;
        sub_1D3D81F38((unsigned int **)&v183);
        v96 = 10;
      }
    }
    else
    {
      sub_1D3DBAE60();
      v86 = *(unsigned int **)qword_1EDB89EF0;
      if (*(_QWORD *)qword_1EDB89EF0)
      {
        v87 = v86 + 2;
        do
          v88 = __ldxr(v87);
        while (__stxr(v88 + 1, v87));
        do
          v89 = __ldxr(v87);
        while (__stxr(v89 + 1, v87));
        v90 = (uint64_t *)v86;
      }
      else
      {
        v90 = 0;
      }
      v183 = v90;
      if (v192)
        sub_1D3D6D13C(v192);
      v192 = v86;
      sub_1D3D81F38((unsigned int **)&v183);
      v96 = 8;
    }
  }
  else
  {
    sub_1D3DBAE60();
    v81 = *(unsigned int **)qword_1EDB89EE8;
    if (*(_QWORD *)qword_1EDB89EE8)
    {
      v82 = v81 + 2;
      do
        v83 = __ldxr(v82);
      while (__stxr(v83 + 1, v82));
      do
        v84 = __ldxr(v82);
      while (__stxr(v84 + 1, v82));
      v85 = (uint64_t *)v81;
    }
    else
    {
      v85 = 0;
    }
    v183 = v85;
    if (v192)
      sub_1D3D6D13C(v192);
    v192 = v81;
    sub_1D3D81F38((unsigned int **)&v183);
    v96 = 6;
  }
  v102 = dword_1D3E6027C;
  if (!v151)
    v102 = dword_1D3E60290;
  v103 = (int *)&unk_1D3E601E4;
  if (!v151)
    v103 = (int *)&unk_1D3E601F8;
  v104 = v103[v147];
  if (*((_QWORD *)v174 + 2) < (unint64_t)(int)(v104 * v96))
  {
    v144 = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(v144, "invalid input data: not enough bits");
    *v144 = &off_1E95AF330;
    __cxa_throw(v144, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  v105 = v102[v147];
  sub_1D3D81F68((uint64_t)&v190, v104);
  if ((int)v104 >= 1)
  {
    v106 = 0;
    v107 = *((_QWORD *)v174 + 6);
    v108 = v96;
    do
    {
      v109 = v106 + 1;
      v110 = 1;
      v111 = v191;
      v112 = v96;
      v113 = ~(uint64_t)(int)(v104 * v96) + v105 + v108;
      do
      {
        if (((*(_DWORD *)(v107 + ((v113 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v113) & 1) != 0)
          *(_DWORD *)(*(_QWORD *)(v111 + 16) + 4 * v106) += v110;
        v110 *= 2;
        --v113;
        --v112;
      }
      while (v112);
      v108 += v96;
      ++v106;
    }
    while (v109 != v104);
  }
  v114 = v192;
  if (v192)
  {
    v115 = v192 + 2;
    do
      v116 = __ldxr(v115);
    while (__stxr(v116 + 1, v115));
    v189 = v114;
    v183 = 0;
    do
      v117 = __ldxr(v115);
    while (__stxr(v117 + 1, v115));
  }
  else
  {
    v189 = 0;
  }
  v183 = (uint64_t *)v114;
  sub_1D3D82034(&v189);
  v187 = 0;
  v186 = &off_1E95AF9D0;
  v188 = 0;
  v118 = (unsigned int *)v191;
  if (v191)
  {
    v119 = (unsigned int *)(v191 + 8);
    do
      v120 = __ldxr(v119);
    while (__stxr(v120 + 1, v119));
    if (v188)
      sub_1D3D6D13C(v188);
  }
  v188 = v118;
  sub_1D3DBC050((uint64_t *)&v183, (uint64_t)&v186, v104 - v149);
  sub_1D3D82064(&v186);
  v121 = sub_1D3D82034((unsigned int **)&v183);
  v122 = v96 * v149 + 31;
  if ((int)(v96 * v149) < -31)
    v122 = v96 * v149 + 62;
  sub_1D3D81C50((uint64_t)v121, 4 * (v122 >> 5));
  if ((int)v149 >= 1)
  {
    v123 = 0;
    for (i = 0; i != v149; ++i)
    {
      v125 = v123;
      v126 = v96;
      v127 = 1 << (v96 - 1);
      do
      {
        if ((*(_DWORD *)(*(_QWORD *)(v191 + 16) + 4 * i) & v127) != 0)
          *(_BYTE *)(*(_QWORD *)(v185 + 16) + ((unint64_t)v125 >> 3)) |= 1 << (~(_BYTE)v125 & 7);
        v127 >>= 1;
        ++v125;
        --v126;
      }
      while (v126);
      v123 += v96;
    }
  }
  v176 = 0;
  v175 = &off_1E95AF9B0;
  v128 = v185;
  if (v185)
  {
    v129 = (unsigned int *)(v185 + 8);
    do
      v130 = __ldxr(v129);
    while (__stxr(v130 + 1, v129));
  }
  v177 = v128;
  v178 = v96 * v149;
  sub_1D3D7F558(&v183);
  sub_1D3D82064(&v190);
  sub_1D3D81F38(&v192);
  sub_1D3D81D1C(&v174);
  v184 = 0;
  v185 = 0;
  v183 = (uint64_t *)&v184;
  v131 = *(unsigned __int8 *)(*(_QWORD *)a2 + 12);
  *((_DWORD *)sub_1D3D7F308(&v183, 9, (unsigned int *)&unk_1D3E80D00) + 8) = v131;
  *((_DWORD *)sub_1D3D7F308(&v183, 16, &dword_1D3E75668) + 8) = v152;
  *((_DWORD *)sub_1D3D7F308(&v183, 17, &dword_1D3E7566C) + 8) = v149;
  *((_DWORD *)sub_1D3D7F308(&v183, 18, &dword_1D3E75670) + 8) = v151;
  v132 = v178;
  *((_DWORD *)sub_1D3D7F308(&v183, 19, &dword_1D3E75674) + 8) = v132;
  v133 = operator new();
  v172 = 0;
  v171 = &off_1E95AF9B0;
  v134 = v177;
  if (v177)
  {
    v135 = (unsigned int *)(v177 + 8);
    do
      v136 = __ldxr(v135);
    while (__stxr(v136 + 1, v135));
  }
  v173 = v134;
  v137 = operator new();
  sub_1D3D81D4C(&v190, "");
  *(_DWORD *)(v137 + 8) = 0;
  v138 = (unsigned int *)(v137 + 8);
  *(_QWORD *)v137 = off_1E95AF718;
  v139 = (_BYTE *)(v137 + 16);
  if (SHIBYTE(v191) < 0)
  {
    sub_1D3D7FCC0(v139, (void *)v190, *((unint64_t *)&v190 + 1));
  }
  else
  {
    *(_OWORD *)v139 = v190;
    *(_QWORD *)(v137 + 32) = v191;
  }
  do
    v140 = __ldxr(v138);
  while (__stxr(v140 + 1, v138));
  v170 = (unsigned int *)v137;
  sub_1D3D7F3AC((uint64_t)v169, &v183);
  sub_1D3DAFA54(v133, (uint64_t)&v171, (uint64_t *)&v170, v169);
  v141 = (unsigned int *)(v133 + 8);
  do
    v142 = __ldxr(v141);
  while (__stxr(v142 + 1, v141));
  *a1 = v133;
  sub_1D3D7F520((_QWORD *)v169[1]);
  sub_1D3D7F598(&v170);
  if (SHIBYTE(v191) < 0)
    operator delete((void *)v190);
  sub_1D3D7F558(&v171);
  sub_1D3D7F520(v184);
  sub_1D3D7F558(&v175);
  sub_1D3D81D1C(&v180);
  return sub_1D3D6D10C(&v182);
}

void sub_1D3D80AAC()
{
  uint64_t v0;

  sub_1D3D81F38((unsigned int **)(v0 - 184));
  JUMPOUT(0x1D3D80D28);
}

void sub_1D3D80AF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  if (*(char *)(v36 - 97) < 0)
    operator delete(*(void **)(v36 - 120));
  MEMORY[0x1D8254C54](v35, 0x1093C40E92185C3);
  sub_1D3D7F558(&a30);
  MEMORY[0x1D8254C54](v34, 0x10B3C40E71DBE67);
  sub_1D3D7F520(*(_QWORD **)(v36 - 176));
  sub_1D3D7F558(&a34);
  JUMPOUT(0x1D3D80D9CLL);
}

void sub_1D3D80B10()
{
  uint64_t v0;
  uint64_t v1;

  MEMORY[0x1D8254C54](v0, 0x1091C409401DBA8);
  sub_1D3D6D10C((unsigned int **)(v1 - 200));
  JUMPOUT(0x1D3D80DA4);
}

void sub_1D3D80B3C(void *a1, int a2)
{
  uint64_t v2;
  void *exception_ptr;
  _QWORD *exception;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  char *v10;

  sub_1D3D82034((unsigned int **)(v2 - 184));
  if (a2 == 2)
  {
    exception_ptr = __cxa_get_exception_ptr(a1);
    sub_1D3D820A4((_QWORD *)(v2 - 184), (uint64_t)exception_ptr);
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(exception, "rs decoding failed");
    *exception = &off_1E95AF330;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  if (a2 == 1)
  {
    v7 = __cxa_get_exception_ptr(a1);
    sub_1D3D8211C((_QWORD *)(v2 - 184), (uint64_t)v7);
    __cxa_begin_catch(a1);
    v8 = __cxa_allocate_exception(0x20uLL);
    v9 = v8;
    if (*(char *)(v2 - 153) >= 0)
      v10 = (char *)(v2 - 176);
    else
      v10 = *(char **)(v2 - 176);
    sub_1D3DDE1A0(v8, v10);
    *v9 = &off_1E95AF330;
    __cxa_throw(v9, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  sub_1D3D82064((_QWORD *)(v2 - 120));
  JUMPOUT(0x1D3D80D28);
}

void sub_1D3D80B4C()
{
  void *v0;

  __cxa_free_exception(v0);
  JUMPOUT(0x1D3D80D28);
}

void sub_1D3D80B60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,_QWORD *a27,uint64_t a28,unsigned int *a29,uint64_t a30)
{
  uint64_t v30;
  uint64_t v31;

  sub_1D3D7F520(a27);
  sub_1D3D7F598(&a29);
  if (*(char *)(v31 - 97) < 0)
    operator delete(*(void **)(v31 - 120));
  sub_1D3D7F558(&a30);
  MEMORY[0x1D8254C54](v30, 0x10B3C40E71DBE67);
  JUMPOUT(0x1D3D80D8CLL);
}

void sub_1D3D80BD8()
{
  uint64_t v0;

  sub_1D3D82064(v0 - 120);
  JUMPOUT(0x1D3D80D28);
}

void sub_1D3D80BE0()
{
  uint64_t v0;

  sub_1D3D82064((_QWORD *)(v0 - 152));
  JUMPOUT(0x1D3D80BF0);
}

void sub_1D3D80CD0()
{
  uint64_t v0;

  sub_1D3DDE164((std::exception *)(v0 - 184));
  __cxa_end_catch();
  sub_1D3D82064((_QWORD *)(v0 - 120));
  JUMPOUT(0x1D3D80D28);
}

void sub_1D3D80CF4()
{
  uint64_t v0;

  sub_1D3DDE164((std::exception *)(v0 - 184));
  __cxa_end_catch();
  JUMPOUT(0x1D3D80D14);
}

void sub_1D3D80D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,unsigned int *a33)
{
  uint64_t v33;

  sub_1D3D81F38((unsigned int **)(v33 - 96));
  sub_1D3D81D1C(&a33);
  sub_1D3D81D1C((unsigned int **)(v33 - 208));
  sub_1D3D6D10C((unsigned int **)(v33 - 192));
  _Unwind_Resume(a1);
}

void sub_1D3D80D3C()
{
  JUMPOUT(0x1D3D80D30);
}

void sub_1D3D80D44()
{
  void *v0;
  uint64_t v1;

  MEMORY[0x1D8254C54](v1, 0x1091C40C7871EBFLL);
  if (v0)
    operator delete(v0);
  JUMPOUT(0x1D3D80D80);
}

_QWORD *sub_1D3D80DB4(uint64_t *a1, uint64_t a2, uint64_t **a3, const char *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  BOOL v11;
  _DWORD *v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  unint64_t v30;
  int v31;
  char v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unsigned int *v39;
  unsigned int *v40;
  unsigned int v41;
  uint64_t *v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  const char *v47;
  unint64_t v48;
  unsigned int *v49;
  unsigned int v50;
  int v51;
  int v52;
  _BOOL4 v53;
  int v54;
  unsigned int *v55;
  unsigned int v56;
  int v57;
  int v58;
  unint64_t v59;
  unsigned int *v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  uint64_t v66;
  char **v68;
  int v69;
  int v70;
  int v71;
  unsigned int *v72;
  unsigned int v73;
  uint64_t v74;
  int v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int32x2_t v80;
  unsigned int v81;
  int32x4_t v82;
  int32x4_t v83;
  int8x16_t v84;
  int8x16_t v85;
  char *v86;
  unsigned __int8 v87;
  int64_t v88;
  void **v89;
  char *v90;
  int64_t v91;
  void **v92;
  char *v93;
  int v95;
  int v96;
  BOOL v97;
  int v98;
  int v99;
  int v100;
  int v101;
  unsigned int *v102;
  unsigned int v103;
  int v104;
  unint64_t v105;
  unsigned int *v106;
  unsigned int v107;
  int v108;
  int v109;
  int v110;
  uint64_t v111;
  char v112;
  unsigned int *v113;
  unsigned int v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  unsigned int *v120;
  _BYTE *v121;
  unsigned int v122;
  uint64_t v123;
  uint64_t v124;
  unsigned int *v125;
  unsigned int v126;
  unsigned int *v127;
  unsigned int *v128;
  unsigned int v129;
  unsigned int *v130;
  unsigned int v131;
  _QWORD *v133;
  _QWORD *exception;
  uint64_t v135;
  uint64_t v136;
  uint64_t *v137;
  uint64_t **v138;
  uint64_t *v139;
  uint64_t v140;
  uint64_t v142;
  int v143;
  int v144;
  int v145;
  int v146;
  _QWORD v147[3];
  unsigned int *v148;
  uint64_t (**v149)(_QWORD);
  int v150;
  uint64_t v151;
  unsigned int *v152;
  unsigned int *v153;
  unsigned int *v154;
  void *v155[3];
  void *__p[2];
  unsigned __int8 v157;
  unsigned int *v158;
  unsigned int *v159;
  unsigned int *v160;
  unsigned int *v161;
  unsigned int *v162;
  unsigned int *v163;
  unsigned int *v164;
  std::string v165;
  std::string v166;

  v7 = *((unsigned int *)sub_1D3D7F308(a3, 17, &dword_1D3E7566C) + 8);
  v8 = *((unsigned int *)sub_1D3D7F308(a3, 16, &dword_1D3E75668) + 8);
  v138 = a3;
  v9 = sub_1D3D7F308(a3, 18, &dword_1D3E75670);
  if ((v8 & 0x80000000) != 0
    || (v10 = *((_DWORD *)v9 + 8)) == 0 && v8 > 0x20
    || (v10 ? (v11 = v8 >= 5) : (v11 = 0), v11))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE20C(exception, "invalid layer count");
    goto LABEL_214;
  }
  if (v10)
    v12 = &unk_1D3E601E4;
  else
    v12 = &unk_1D3E601F8;
  if ((int)v7 > v12[v8])
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE20C(exception, "invalid data codeword count for layer count");
    goto LABEL_214;
  }
  if (v8 >= 0x17)
    v13 = 12;
  else
    v13 = 10;
  if (v8 >= 9)
    v14 = v13;
  else
    v14 = 8;
  if (v8 >= 3)
    v15 = v14;
  else
    v15 = 6;
  v16 = (int)v15 * (int)v7;
  if (v16 > 8 * (*(_QWORD *)(*(_QWORD *)(a2 + 16) + 24) - *(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE20C(exception, "invalid input data");
LABEL_214:
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  v17 = v16 + 31;
  if ((int)v16 < -31)
    v17 = v16 + 62;
  sub_1D3D81C50((uint64_t)v155, 4 * (v17 >> 5));
  v18 = operator new();
  v19 = v18;
  v137 = a1;
  if ((int)v16 < 1)
    v20 = 0;
  else
    v20 = *((_QWORD *)v155[2] + 2);
  *(_DWORD *)(v18 + 8) = 0;
  v21 = (unsigned int *)(v18 + 8);
  *(_QWORD *)v18 = &off_1E95AF9F0;
  *(_QWORD *)(v18 + 16) = v16;
  *(_QWORD *)(v18 + 24) = 0;
  *(_QWORD *)(v18 + 32) = 0;
  *(_QWORD *)(v18 + 40) = 0;
  *(_QWORD *)(v18 + 48) = v20;
  do
    v22 = __ldxr(v21);
  while (__stxr(v22 + 1, v21));
  v154 = (unsigned int *)v18;
  if ((int)v7 <= 0)
  {
    *(_QWORD *)(v18 + 16) = v16;
LABEL_50:
    v40 = (unsigned int *)(v19 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    goto LABEL_52;
  }
  v23 = 0;
  v24 = 0;
  v25 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 16);
  v26 = 6;
  v27 = 1;
  v28 = v15 - 2;
  do
  {
    v29 = (1 << ((7 - v23 * v15) & 7)) & *(unsigned __int8 *)(v25 + ((v23 * v15) >> 3));
    if (v29)
      *(_DWORD *)(v20 + (((v23 * v15 - v24) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v23 * v15 - v24);
    v30 = v27 - v24;
    LOBYTE(v31) = 1;
    v32 = v26;
    v33 = v27;
    v34 = (v15 - 2);
    do
    {
      v35 = (1 << (v32 & 7)) & *(unsigned __int8 *)(v25 + ((unint64_t)v33 >> 3));
      if (v35)
        *(_DWORD *)(v20 + ((v30 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v33 - v24);
      v31 = v31 & ((v29 != 0) == (v35 != 0));
      ++v30;
      ++v33;
      --v32;
      --v34;
    }
    while (v34);
    v36 = (1 << ((6 - v28) & 6)) & *(unsigned __int8 *)(v25 + ((unint64_t)v28 >> 3));
    if (v31)
    {
      if ((v29 != 0) == (v36 != 0))
      {
        v133 = __cxa_allocate_exception(0x20uLL);
        sub_1D3DDE1A0(v133, "bit was not inverted");
        *v133 = &off_1E95AF330;
        __cxa_throw(v133, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
      }
      ++v24;
    }
    else if (v36)
    {
      *(_DWORD *)(v20 + (((v15 + v15 * v23 + ~v24) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v15 + v15 * v23 + ~(_BYTE)v24);
    }
    ++v23;
    v28 += v15;
    v27 += v15;
    v26 -= v15;
  }
  while (v23 != v7);
  v37 = v16 - v24;
  if (v16 < v24)
  {
    LODWORD(v166.__r_.__value_.__l.__data_) = 0;
    sub_1D3D93680((char **)(v19 + 24), (v37 + 31) >> 5, &v166);
    memcpy(*(void **)(v19 + 24), *(const void **)(v19 + 48), ((unint64_t)(*(_QWORD *)(v19 + 16) + 31) >> 3) & 0x1FFFFFFFFFFFFFFCLL);
    v16 = *(_QWORD *)(v19 + 16);
  }
  if (v16 < v37)
  {
    v38 = *(_QWORD *)(v19 + 24) + 4 * ((v16 + 31) >> 5);
    *(_DWORD *)(v38 - 4) &= -1 << v16;
  }
  v39 = v154;
  *(_QWORD *)(v19 + 16) = v37;
  v19 = (uint64_t)v39;
  if (v39)
    goto LABEL_50;
LABEL_52:
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v152 = (unsigned int *)v19;
  v46 = *(_QWORD *)(v19 + 16);
  v47 = "ISO-8859-1";
  if (a4)
    v47 = a4;
  v140 = (uint64_t)v47;
  memset(&v166, 0, sizeof(v166));
  v142 = (int)v46 - 4;
  v136 = (int)v46 - 8;
  memset(&v165, 0, sizeof(v165));
LABEL_55:
  v139 = v42;
  v145 = v44;
  v146 = 0;
  v144 = v45;
  LODWORD(v48) = v43;
  do
  {
    while (1)
    {
      if (v44 == 5)
      {
        v45 = v145;
        if ((int)v46 - (int)v48 < 8)
          goto LABEL_193;
        if (v152)
        {
          v49 = v152 + 2;
          do
            v50 = __ldxr(v49);
          while (__stxr(v50 + 1, v49));
        }
        v51 = 0;
        v161 = v152;
        v43 = v48 + 8;
        v48 = (int)v48;
        do
        {
          v52 = (*(_DWORD *)(*((_QWORD *)v152 + 6) + ((v48 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v48) & 1 | (2 * v51);
          ++v48;
          v51 = v52;
        }
        while ((uint64_t)v48 < v43);
        sub_1D3D81D1C(&v161);
        std::string::append(&v165, 1uLL, v52);
        v53 = 0;
        v44 = 5;
        goto LABEL_170;
      }
      if (v44 == 3)
        v54 = 4;
      else
        v54 = 5;
      if ((int)v46 - (int)v48 < v54)
        goto LABEL_193;
      if (v152)
      {
        v55 = v152 + 2;
        do
          v56 = __ldxr(v55);
        while (__stxr(v56 + 1, v55));
      }
      v57 = 0;
      v160 = v152;
      v58 = v54 + v48;
      v48 = (int)v48;
      v59 = v54 + (int)v48;
      do
      {
        v57 = (*(_DWORD *)(*((_QWORD *)v152 + 6) + ((v48 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v48) & 1 | (2 * v57);
        ++v48;
      }
      while ((uint64_t)v48 < v58);
      sub_1D3D81D1C(&v160);
      if (v44 != 4 || v57)
        break;
      if ((int)v46 - v58 < 3)
        goto LABEL_193;
      if (v152)
      {
        v60 = v152 + 2;
        do
          v61 = __ldxr(v60);
        while (__stxr(v61 + 1, v60));
      }
      v62 = 0;
      v159 = v152;
      v43 = v58 + 3;
      v63 = v58 + 3;
      do
      {
        v64 = 2 * v62;
        v65 = *(_DWORD *)(*((_QWORD *)v152 + 6) + ((v59 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v59;
        v62 = (2 * v62) | v65 & 1;
        ++v59;
      }
      while ((uint64_t)v59 < v43);
      sub_1D3D81D1C(&v159);
      if (!v62)
      {
        v53 = 0;
        v44 = 4;
LABEL_169:
        v45 = v145;
        goto LABEL_170;
      }
      if (v62 == 7)
        goto LABEL_193;
      v66 = (v62 - 1);
      if (v62 < 1 || (int)v46 - v43 < 4)
      {
        v70 = 0;
        v53 = 0;
      }
      else
      {
        v135 = v46;
        v69 = 0;
        v70 = 0;
        v71 = (v64 + 2) | v65 & 1;
        do
        {
          if (v152)
          {
            v72 = v152 + 2;
            do
              v73 = __ldxr(v72);
            while (__stxr(v73 + 1, v72));
          }
          v74 = 0;
          v75 = 0;
          v76 = v71 & 0xFFFFFFFC;
          v77 = v63 + 4;
          v78 = v66;
          v143 = v66 - v69;
          v158 = v152;
          do
          {
            v79 = (*(_DWORD *)(*((_QWORD *)v152 + 6) + (((unint64_t)(v63 + v74) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> (v43 + v74)) & 1 | (2 * v75);
            ++v74;
            v75 = v79;
          }
          while (v74 != 4);
          sub_1D3D81D1C(&v158);
          v81 = v79 - 2;
          v53 = (v79 - 2) > 9;
          if (v81 > 9)
            break;
          v66 = v78;
          if ((int)v78 > v69)
          {
            v82.i64[1] = 0x100000001;
            v82.i64[0] = v81 | 0x100000000;
            v83.i64[0] = 0xA0000000ALL;
            v83.i64[1] = 0xA0000000ALL;
            do
            {
              v84 = (int8x16_t)v82;
              v82 = vmulq_s32(v82, v83);
              v76 -= 4;
            }
            while (v76);
            v80.i32[0] = v143 - 1;
            v85 = vbslq_s8((int8x16_t)vcgtq_u32((uint32x4_t)vorrq_s8((int8x16_t)vdupq_n_s32((v71 & 0xFFFFFFFC) - 4), (int8x16_t)xmmword_1D3E82000), (uint32x4_t)vdupq_lane_s32(v80, 0)), v84, (int8x16_t)v82);
            *(int32x2_t *)v85.i8 = vmul_s32(*(int32x2_t *)v85.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
            v81 = v85.i32[0] * v85.i32[1];
          }
          v70 += v81;
          if (++v69 >= v62)
            break;
          --v71;
          LOBYTE(v43) = v43 + 4;
          v63 += 4;
        }
        while (v77 <= v142);
        v43 = v77;
        v46 = v135;
      }
      v45 = v145;
      if (!v139 || v70 != *(_DWORD *)*v139)
      {
        sub_1D3DBFAC0(&v166, (const std::string::value_type *)&v165, v140);
        if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0)
        {
          *v165.__r_.__value_.__l.__data_ = 0;
          v165.__r_.__value_.__l.__size_ = 0;
        }
        else
        {
          v165.__r_.__value_.__s.__data_[0] = 0;
          *((_BYTE *)&v165.__r_.__value_.__s + 23) = 0;
        }
        v42 = sub_1D3DA51B4(v70);
        v140 = *(_QWORD *)v42[1];
        if ((v146 & 1) != 0)
          v44 = v144;
        else
          v44 = 4;
        if (v53)
          goto LABEL_193;
        goto LABEL_55;
      }
      v44 = 4;
LABEL_170:
      if ((v146 & 1) != 0)
        v44 = v144;
      v144 = v45;
      v145 = v44;
      LODWORD(v48) = v43;
      v146 = 0;
      if (v53)
        goto LABEL_193;
    }
    switch(v44)
    {
      case 0:
        v68 = off_1E95B05B8;
        goto LABEL_112;
      case 1:
        v68 = off_1E95B06B8;
        goto LABEL_112;
      case 2:
        v68 = off_1E95B07B8;
        goto LABEL_112;
      case 3:
        v68 = off_1E95B09B8;
        goto LABEL_112;
      case 4:
        v68 = (char **)&off_1E95B08B8;
LABEL_112:
        v86 = v68[v57];
        break;
      default:
        v86 = "";
        break;
    }
    sub_1D3D81D4C(__p, v86);
    v87 = v157;
    if ((v157 & 0x80u) == 0)
      v88 = v157;
    else
      v88 = (int64_t)__p[1];
    if ((v157 & 0x80u) == 0)
      v89 = __p;
    else
      v89 = (void **)__p[0];
    if (v88 >= 5)
    {
      v90 = (char *)v89 + v88;
      v91 = v88;
      v92 = v89;
      while (1)
      {
        v93 = (char *)memchr(v92, 67, v91 - 4);
        if (!v93)
          goto LABEL_136;
        if (*(_DWORD *)v93 == 1280463939 && v93[4] == 95)
          break;
        v92 = (void **)(v93 + 1);
        v91 = v90 - (char *)v92;
        if (v90 - (char *)v92 < 5)
          goto LABEL_136;
      }
      if (v93 == v90 || (_DWORD)v93 - (_DWORD)v89 == 0xFFFFFFFFLL)
        goto LABEL_136;
      v95 = v86[5];
      if (v95 <= 75)
      {
        if (v95 == 66)
        {
          v96 = 5;
          goto LABEL_181;
        }
        if (v95 == 68)
        {
          v96 = 3;
          goto LABEL_181;
        }
      }
      else
      {
        switch(v95)
        {
          case 'L':
            v96 = 1;
            goto LABEL_181;
          case 'M':
            v96 = 2;
            goto LABEL_181;
          case 'P':
            v96 = 4;
            goto LABEL_181;
        }
      }
      v96 = 0;
LABEL_181:
      v98 = (v86[6] == 83) | v146;
      v97 = v86[5] == 66 && v86[6] == 83;
      v99 = v44;
      v44 = v96;
      if ((v87 & 0x80) == 0)
        goto LABEL_138;
      goto LABEL_137;
    }
LABEL_136:
    std::string::append(&v165, (const std::string::value_type *)v89, v88);
    v97 = 0;
    v99 = v145;
    v98 = v146;
    if ((v157 & 0x80) != 0)
LABEL_137:
      operator delete(__p[0]);
LABEL_138:
    v100 = v146;
    if ((v146 & 1) != 0)
      v44 = v99;
    v146 ^= v98;
    if (((v100 ^ v98) & 1) != 0)
      v101 = v99;
    else
      v101 = v44;
    v144 = v99;
    v145 = v101;
    LODWORD(v48) = v58;
  }
  while (!v97);
  if ((int)v46 - v58 < 5)
    goto LABEL_193;
  if (v152)
  {
    v102 = v152 + 2;
    do
      v103 = __ldxr(v102);
    while (__stxr(v103 + 1, v102));
  }
  v104 = 0;
  v164 = v152;
  v43 = v58 + 5;
  v105 = v58 + 5;
  do
  {
    v104 = (*(_DWORD *)(*((_QWORD *)v152 + 6) + ((v59 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v59) & 1 | (2 * v104);
    ++v59;
  }
  while ((uint64_t)v59 < v43);
  sub_1D3D81D1C(&v164);
  if (!v104)
  {
    if ((int)v46 - v43 < 11)
      goto LABEL_193;
    if (v152)
    {
      v106 = v152 + 2;
      do
        v107 = __ldxr(v106);
      while (__stxr(v107 + 1, v106));
    }
    v108 = 0;
    v163 = v152;
    v43 = v58 + 16;
    do
    {
      v109 = (*(_DWORD *)(*((_QWORD *)v152 + 6) + ((v105 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v105) & 1 | (2 * v108);
      ++v105;
      v108 = v109;
    }
    while ((uint64_t)v105 < v43);
    v104 = v109 + 31;
    sub_1D3D81D1C(&v163);
  }
  if (v104 < 1)
  {
    v53 = 0;
    goto LABEL_169;
  }
  v110 = 0;
  v111 = v43;
  v112 = v43;
  while (v111 <= v136)
  {
    if (v152)
    {
      v113 = v152 + 2;
      do
        v114 = __ldxr(v113);
      while (__stxr(v114 + 1, v113));
    }
    v115 = 0;
    v116 = 0;
    v117 = v111 + 8;
    v162 = v152;
    do
    {
      v118 = (*(_DWORD *)(*((_QWORD *)v152 + 6) + (((unint64_t)(v111 + v115) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> (v112 + v115)) & 1 | (2 * v116);
      ++v115;
      v116 = v118;
    }
    while (v115 != 8);
    sub_1D3D81D1C(&v162);
    std::string::append(&v165, 1uLL, v118);
    ++v110;
    v112 += 8;
    v111 = v117;
    if (v110 == v104)
    {
      v53 = 0;
      v43 += 8 * v104;
      goto LABEL_169;
    }
  }
LABEL_193:
  sub_1D3DBFAC0(&v166, (const std::string::value_type *)&v165, v140);
  v119 = operator new();
  *(_DWORD *)(v119 + 8) = 0;
  v120 = (unsigned int *)(v119 + 8);
  *(_QWORD *)v119 = off_1E95AF718;
  v121 = (_BYTE *)(v119 + 16);
  if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_1D3D7FCC0(v121, v166.__r_.__value_.__l.__data_, v166.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)v121 = *(_OWORD *)&v166.__r_.__value_.__l.__data_;
    *(_QWORD *)(v119 + 32) = *((_QWORD *)&v166.__r_.__value_.__l + 2);
  }
  do
    v122 = __ldxr(v120);
  while (__stxr(v122 + 1, v120));
  v153 = (unsigned int *)v119;
  if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v165.__r_.__value_.__l.__data_);
  if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v166.__r_.__value_.__l.__data_);
  sub_1D3D81D1C(&v152);
  v123 = operator new();
  v150 = 0;
  v149 = &off_1E95AF9B0;
  v124 = *(_QWORD *)(a2 + 16);
  if (v124)
  {
    v125 = (unsigned int *)(v124 + 8);
    do
      v126 = __ldxr(v125);
    while (__stxr(v126 + 1, v125));
  }
  v151 = v124;
  v127 = v153;
  if (v153)
  {
    v128 = v153 + 2;
    do
      v129 = __ldxr(v128);
    while (__stxr(v129 + 1, v128));
  }
  v148 = v127;
  sub_1D3D7F3AC((uint64_t)v147, v138);
  sub_1D3DAFA54(v123, (uint64_t)&v149, (uint64_t *)&v148, v147);
  v130 = (unsigned int *)(v123 + 8);
  do
    v131 = __ldxr(v130);
  while (__stxr(v131 + 1, v130));
  *v137 = v123;
  sub_1D3D7F520((_QWORD *)v147[1]);
  sub_1D3D7F598(&v148);
  sub_1D3D7F558(&v149);
  sub_1D3D7F598(&v153);
  sub_1D3D81D1C(&v154);
  return sub_1D3D7F558(v155);
}

void sub_1D3D81B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,unsigned int *a33,__int16 a34,char a35,char a36,int a37,unsigned int *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  uint64_t v47;

  if (*(char *)(v47 - 113) < 0)
    operator delete(*(void **)(v47 - 136));
  if (*(char *)(v47 - 89) < 0)
    operator delete(*(void **)(v47 - 112));
  sub_1D3D81D1C(&a33);
  sub_1D3D81D1C(&a38);
  sub_1D3D7F558(&a39);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D81C50(uint64_t a1, size_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  char v9;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AF9B0;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 0;
  v5 = (unsigned int *)(v4 + 8);
  *(_QWORD *)v4 = &off_1E95AF5C0;
  v9 = 0;
  sub_1D3D81DF8((_QWORD *)(v4 + 16), a2, &v9);
  do
    v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  v7 = *(unsigned int **)(a1 + 16);
  if (v7)
    sub_1D3D6D13C(v7);
  *(_QWORD *)(a1 + 16) = v4;
  return a1;
}

void sub_1D3D81CF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D8254C54](v1, 0x1091C403A844E10);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3D81D1C(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

_QWORD *sub_1D3D81D4C(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    sub_1D3D7FD48();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

_QWORD *sub_1D3D81DF8(_QWORD *a1, size_t a2, _BYTE *a3)
{
  size_t v5;
  _BYTE *v6;
  _BYTE *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    v5 = a2;
    sub_1D3D81E74(a1, a2);
    v6 = (_BYTE *)a1[1];
    v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }
    while (v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_1D3D81E58(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1D3D81E74(_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    sub_1D3D6D4F8();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

_QWORD *sub_1D3D81EB0(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E95AF5C0;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1D3D81EEC(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E95AF5C0;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3D81F38(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

uint64_t sub_1D3D81F68(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  int v9;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AF9D0;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 0;
  v5 = (unsigned int *)(v4 + 8);
  *(_QWORD *)v4 = &off_1E95AF5E0;
  v9 = 0;
  sub_1D3D821BC((_QWORD *)(v4 + 16), a2, &v9);
  do
    v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  v7 = *(unsigned int **)(a1 + 16);
  if (v7)
    sub_1D3D6D13C(v7);
  *(_QWORD *)(a1 + 16) = v4;
  return a1;
}

void sub_1D3D82010(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D8254C54](v1, 0x1091C403A844E10);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3D82034(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

_QWORD *sub_1D3D82064(_QWORD *a1)
{
  unsigned int *v2;

  *a1 = &off_1E95AF9D0;
  v2 = (unsigned int *)a1[2];
  if (v2)
    sub_1D3D6D13C(v2);
  a1[2] = 0;
  return a1;
}

_QWORD *sub_1D3D820A4(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  __int128 v4;

  *a1 = &off_1E95AFA80;
  v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1D3D7FCC0(v3, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(_QWORD *)(a2 + 24);
    *(_OWORD *)v3 = v4;
  }
  *a1 = &off_1E95AF450;
  return a1;
}

void sub_1D3D82108(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D8211C(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  __int128 v4;

  *a1 = &off_1E95AFA80;
  v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1D3D7FCC0(v3, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(_QWORD *)(a2 + 24);
    *(_OWORD *)v3 = v4;
  }
  *a1 = &off_1E95AF510;
  return a1;
}

void sub_1D3D82180(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_1D3D82198(_QWORD *a1)
{
  sub_1D3D82064(a1);
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D821BC(_QWORD *a1, unint64_t a2, _DWORD *a3)
{
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1D3D8223C(a1, a2);
    v6 = (_DWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1D3D82220(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1D3D8223C(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    sub_1D3D6D4F8();
  result = (char *)sub_1D3D82278(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *sub_1D3D82278(unint64_t a1)
{
  if (a1 >> 62)
    sub_1D3D6D50C();
  return operator new(4 * a1);
}

_QWORD *sub_1D3D822AC(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E95AF5E0;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1D3D822E8(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E95AF5E0;
  v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D82334(_QWORD *a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if ((a2 & 0x8000000000000000) != 0)
      sub_1D3D6D4F8();
    v4 = sub_1D3D6D8A0(((a2 - 1) >> 6) + 1);
    v5 = v4;
    a1[1] = a2;
    a1[2] = v6;
    *a1 = v4;
    if (a2 >= 0x41)
      v7 = (a2 - 1) >> 6;
    else
      v7 = 0;
    v4[v7] = 0;
    v8 = a2 >> 6;
    if (a2 >= 0x40)
      bzero(v4, 8 * v8);
    if ((a2 & 0x3F) != 0)
      v5[v8] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(a2 & 0x3F));
  }
  return a1;
}

uint64_t sub_1D3D823D4(_QWORD *a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD *v10;
  const __CFString *v11;
  _BYTE buf[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = a1[1];
  v6 = *(_QWORD *)(v5 + 48);
  v7 = 5;
  if (v6 == -1)
    v6 = 5;
  if (*(_QWORD *)(a2 + 32) != -1)
    v7 = *(_QWORD *)(a2 + 32);
  if (v6 == v7 && !memcmp((const void *)(v5 + 56), (const void *)(a2 + 40), 8 * v6))
    return 1;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v8 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
  {
    v10 = (_QWORD *)*a1;
    if (*(char *)(*a1 + 23) < 0)
      v10 = (_QWORD *)*v10;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v10;
    _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "E5RTNetwork: failed to validate tensor shape for I/O port: %{public}s", buf, 0xCu);
  }
  v11 = CFSTR("Failed to validate tensor shape for I/O port.");
  *(_QWORD *)buf = -6004;
  sub_1D3D73E0C(a3, (uint64_t *)buf, (CFTypeRef *)&v11);
  return 0;
}

uint64_t sub_1D3D82524(_QWORD *a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD *v10;
  const __CFString *v11;
  _BYTE buf[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = a1[1];
  v6 = *(_QWORD *)(v5 + 48);
  v7 = 5;
  if (v6 == -1)
    v6 = 5;
  if (*(_QWORD *)(a2 + 32) != -1)
    v7 = *(_QWORD *)(a2 + 32);
  if (v6 == v7 && !memcmp((const void *)(v5 + 56), (const void *)(a2 + 40), 8 * v6))
    return 1;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v8 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
  {
    v10 = (_QWORD *)*a1;
    if (*(char *)(*a1 + 23) < 0)
      v10 = (_QWORD *)*v10;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v10;
    _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "E5RTNetwork: failed to validate tensor shape for I/O port: %{public}s", buf, 0xCu);
  }
  v11 = CFSTR("Failed to validate tensor shape for I/O port.");
  *(_QWORD *)buf = -6004;
  sub_1D3D73E0C(a3, (uint64_t *)buf, (CFTypeRef *)&v11);
  return 0;
}

void sub_1D3D82674(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  const void *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (*(unsigned __int8 *)(a1 + 16) == *((unsigned __int8 *)a2 + 16))
  {
    if (*(_BYTE *)(a1 + 16))
    {
      sub_1D3D82B8C((_QWORD *)a1);
      v4 = *a2;
      *a2 = 0;
      v5 = (unint64_t *)(a2 + 1);
      *(_QWORD *)a1 = v4;
      v6 = (unint64_t *)(a1 + 8);
      do
        v7 = __ldaxr(v5);
      while (__stlxr(0, v5));
      do
        v8 = (const void *)__ldaxr(v6);
      while (__stlxr(v7, v6));
      if (v8)
        CFRelease(v8);
    }
  }
  else if (*(_BYTE *)(a1 + 16))
  {
    sub_1D3D82E7C((_QWORD *)a1);
  }
  else
  {
    v9 = *a2;
    *a2 = 0;
    v10 = (unint64_t *)(a2 + 1);
    *(_QWORD *)a1 = v9;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(0, v10));
    *(_QWORD *)(a1 + 8) = v11;
    *(_BYTE *)(a1 + 16) = 1;
  }
}

uint64_t sub_1D3D82720(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
  {
    sub_1D3D82B54((unint64_t *)(a1 + 8));
    sub_1D3D82B8C((_QWORD *)a1);
  }
  return a1;
}

BOOL sub_1D3D8275C(_QWORD *a1, uint64_t **a2, unsigned int *a3)
{
  uint64_t v6;
  unsigned int v7;
  NSObject *v8;
  _DWORD v10[2];
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  if (*((_BYTE *)a2 + 8))
    v6 = **a2;
  else
    v6 = 0;
  v7 = off_1EDB89490(*a1, v6);
  *a3 = v7;
  if (v7)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v8 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v10[0] = 67240450;
      v10[1] = v7;
      v11 = 2082;
      v12 = sub_1D3D82AEC(a3);
      _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "e5rt_io_port_bind_buffer_object failed: (%{public}d): %{public}s", (uint8_t *)v10, 0x12u);
    }
  }
  return v7 == 0;
}

void sub_1D3D828B0()
{
  off_1EDB893F0 = (_UNKNOWN *)MEMORY[0x1E0D1FA60];
  *(_QWORD *)algn_1EDB893F8 = MEMORY[0x1E0D1FE38];
  off_1EDB89400 = (_UNKNOWN *)MEMORY[0x1E0D1FE28];
  off_1EDB89408 = (_UNKNOWN *)MEMORY[0x1E0D1FE20];
  off_1EDB89410 = (_UNKNOWN *)MEMORY[0x1E0D1FE18];
  off_1EDB89418 = (_UNKNOWN *)MEMORY[0x1E0D1FE08];
  off_1EDB89420 = (_UNKNOWN *)MEMORY[0x1E0D1FDF8];
  unk_1EDB89428 = MEMORY[0x1E0D1FE70];
  off_1EDB89430 = (_UNKNOWN *)MEMORY[0x1E0D1FDC8];
  off_1EDB89438 = (_UNKNOWN *)MEMORY[0x1E0D1FE80];
  off_1EDB89440 = (_UNKNOWN *)MEMORY[0x1E0D1FE48];
  off_1EDB89448 = (_UNKNOWN *)MEMORY[0x1E0D1FE50];
  off_1EDB89450 = (_UNKNOWN *)MEMORY[0x1E0D1FE68];
  off_1EDB89458 = (_UNKNOWN *)MEMORY[0x1E0D1F908];
  qword_1EDB89460 = MEMORY[0x1E0D1F938];
  off_1EDB89468 = (_UNKNOWN *)MEMORY[0x1E0D1F920];
  off_1EDB89470 = (_UNKNOWN *)MEMORY[0x1E0D1F930];
  unk_1EDB89478 = MEMORY[0x1E0D1FC48];
  off_1EDB89480 = (_UNKNOWN *)MEMORY[0x1E0D1FC38];
  off_1EDB89488 = (_UNKNOWN *)MEMORY[0x1E0D1FC68];
  off_1EDB89490 = (_UNKNOWN *)MEMORY[0x1E0D1FC08];
  unk_1EDB89498 = MEMORY[0x1E0D1F948];
  qword_1EDB894A0 = MEMORY[0x1E0D1FCE8];
  off_1EDB894A8 = (_UNKNOWN *)MEMORY[0x1E0D1FD30];
  qword_1EDB894B0 = MEMORY[0x1E0D1FD60];
  off_1EDB894B8 = (_UNKNOWN *)MEMORY[0x1E0D1FD38];
  off_1EDB894C0 = (_UNKNOWN *)MEMORY[0x1E0D1FD68];
  off_1EDB894C8 = (_UNKNOWN *)MEMORY[0x1E0D1F990];
  qword_1EDB894D0 = MEMORY[0x1E0D1F9B0];
  off_1EDB894D8 = (_UNKNOWN *)MEMORY[0x1E0D1F9C0];
  off_1EDB894E0 = (_UNKNOWN *)MEMORY[0x1E0D1FA28];
  off_1EDB894E8 = (_UNKNOWN *)MEMORY[0x1E0D1FA38];
  off_1EDB894F0 = (_UNKNOWN *)MEMORY[0x1E0D1FA08];
  unk_1EDB894F8 = MEMORY[0x1E0D1F9D0];
  off_1EDB89500 = (_UNKNOWN *)MEMORY[0x1E0D1F978];
  unk_1EDB89508 = MEMORY[0x1E0D1FA50];
  off_1EDB89510 = (_UNKNOWN *)MEMORY[0x1E0D1F960];
  off_1EDB89518 = (_UNKNOWN *)MEMORY[0x1E0D1F988];
  qword_1EDB89520 = MEMORY[0x1E0D1FA40];
  off_1EDB89528 = (_UNKNOWN *)MEMORY[0x1E0D1FC90];
  qword_1EDB89530 = MEMORY[0x1E0D1FCA0];
  off_1EDB89538 = (_UNKNOWN *)MEMORY[0x1E0D1FCD0];
  off_1EDB89540 = (_UNKNOWN *)MEMORY[0x1E0D1FCB0];
  off_1EDB89548 = (_UNKNOWN *)MEMORY[0x1E0D1FCD8];
  off_1EDB89550 = (_UNKNOWN *)MEMORY[0x1E0D1FB98];
  off_1EDB89558 = (_UNKNOWN *)MEMORY[0x1E0D1FBA8];
  off_1EDB89560 = (_UNKNOWN *)MEMORY[0x1E0D1FAE8];
  unk_1EDB89568 = MEMORY[0x1E0D1FB60];
  off_1EDB89570 = (_UNKNOWN *)MEMORY[0x1E0D1FA80];
  unk_1EDB89578 = MEMORY[0x1E0D1FBB8];
  off_1EDB89580 = (_UNKNOWN *)MEMORY[0x1E0D1FA98];
  off_1EDB89588 = (_UNKNOWN *)MEMORY[0x1E0D1FAA0];
  qword_1EDB89590 = MEMORY[0x1E0D1FBE8];
  off_1EDB89598 = (_UNKNOWN *)MEMORY[0x1E0D1FBD0];
  off_1EDB895A0 = (_UNKNOWN *)MEMORY[0x1E0D1FBD8];
  qword_1EDB895B8 = (uint64_t)&off_1EDB893F0;
}

const char *sub_1D3D82AEC(unsigned int *a1)
{
  const char *result;

  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  result = (const char *)off_1EDB893F0(*a1);
  if (!result)
    return "";
  return result;
}

unint64_t *sub_1D3D82B54(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

_QWORD *sub_1D3D82B8C(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC300;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B38A0);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D82C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D82C6C(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const char *v11;
  unsigned int v12;
  uint8_t buf[4];
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  unsigned int v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v4 = *(_QWORD *)(a1 + 24);
  if (!v4)
    sub_1D3D75A24();
  v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 48))(v4, qword_1EDB895B8);
  v12 = v5;
  if (v5)
  {
    v6 = v5;
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v10 = a2;
      v8 = *a2;
      v9 = v10[1];
      v11 = sub_1D3D82AEC(&v12);
      *(_DWORD *)buf = 68158466;
      v14 = v9;
      v15 = 2082;
      v16 = v8;
      v17 = 1026;
      v18 = v6;
      v19 = 2082;
      v20 = v11;
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "e5rt_%{public}.*s_release failed: (%{public}d): %{public}s", buf, 0x22u);
    }
  }
}

void sub_1D3D82DC8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D82DDC(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC300;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D82E10(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC300;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D82E2C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 112))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D82E38(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP18e5rt_buffer_objectEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D82E70()
{
  return &unk_1E95ABCB8;
}

_QWORD *sub_1D3D82E7C(_QWORD *result)
{
  _QWORD *v1;

  if (*((_BYTE *)result + 16))
  {
    v1 = result;
    sub_1D3D82B54(result + 1);
    result = sub_1D3D82B8C(v1);
    *((_BYTE *)v1 + 16) = 0;
  }
  return result;
}

void sub_1D3D82EB8(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  CFTypeRef v16;
  unint64_t v17;
  const char *v18;
  CFTypeRef cf;
  int v20;
  uint8_t buf[8];
  _BYTE v22[10];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v20 = 0;
  v6 = off_1EDB89470(*a2, &v20);
  *a3 = v6;
  if (v6)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
    v8 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v6;
    *(_WORD *)v22 = 2082;
    *(_QWORD *)&v22[2] = v8;
    v9 = "e5rt_buffer_object_get_type failed: (%{public}d): %{public}s";
    goto LABEL_8;
  }
  v12 = v20;
  if (v20)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v13 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&buf[4] = v12;
    v9 = "E5RTBufferObject: unexpected buffer object type: %{public}d";
    v10 = v13;
    v11 = 8;
    goto LABEL_14;
  }
  cf = 0;
  v14 = off_1EDB89468(*a2, &cf);
  *a3 = v14;
  if (v14)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
    v18 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v14;
    *(_WORD *)v22 = 2082;
    *(_QWORD *)&v22[2] = v18;
    v9 = "e5rt_buffer_object_get_iosurface failed: (%{public}d): %{public}s";
LABEL_8:
    v10 = v7;
    v11 = 18;
LABEL_14:
    _os_log_error_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
LABEL_19:
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 16) = 0;
    return;
  }
  v15 = *a2;
  *a2 = 0;
  *(_QWORD *)buf = v15;
  if (cf)
  {
    v16 = CFRetain(cf);
    v15 = *(_QWORD *)buf;
  }
  else
  {
    v16 = 0;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)v22 = v16;
  *(_QWORD *)a1 = v15;
  do
    v17 = __ldaxr((unint64_t *)v22);
  while (__stlxr(0, (unint64_t *)v22));
  *(_QWORD *)(a1 + 8) = v17;
  *(_BYTE *)(a1 + 16) = 1;
  sub_1D3D82B54((unint64_t *)v22);
  sub_1D3D82B8C(buf);
}

void sub_1D3D83174(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D831A4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  _QWORD *v9;
  uint64_t result;
  unsigned int v11;
  const char *v12;
  uint64_t v13;
  __IOSurface *v14;
  IOSurfaceID ID;
  __IOSurface *v16;
  size_t AllocSize;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  unsigned int v24;
  uint64_t v25;
  _BYTE v26[12];
  __int16 v27;
  _BYTE v28[14];
  __int16 v29;
  _QWORD *v30;
  uint8_t buf[8];
  __int16 v32;
  const char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v25 = 0;
  v5 = off_1EDB89430(*(_QWORD *)(v4 + 8), 0, 1, &v25);
  v24 = v5;
  if (v5)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v6 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v12 = sub_1D3D82AEC(&v24);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v5;
      v32 = 2082;
      v33 = v12;
      _os_log_error_impl(&dword_1D3D6B000, v6, OS_LOG_TYPE_ERROR, "e5rt_tensor_desc_alloc_buffer_object failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    v26[0] = 0;
    v28[2] = 0;
  }
  else
  {
    *(_QWORD *)buf = v25;
    sub_1D3D82EB8((uint64_t)v26, buf, &v24);
    sub_1D3D82B8C(buf);
  }
  sub_1D3D82674(a1 + 16, (uint64_t *)v26);
  sub_1D3D82720((uint64_t)v26);
  v7 = *(unsigned __int8 *)(a1 + 32);
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v8 = qword_1EDB89F98;
  if (v7)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      v13 = *(_QWORD *)(a1 + 16);
      v14 = (__IOSurface *)atomic_load((unint64_t *)(a1 + 24));
      ID = IOSurfaceGetID(v14);
      v16 = (__IOSurface *)atomic_load((unint64_t *)(a1 + 24));
      AllocSize = IOSurfaceGetAllocSize(v16);
      v18 = *(_QWORD **)a1;
      if (*(char *)(*(_QWORD *)a1 + 23) < 0)
        v18 = (_QWORD *)*v18;
      *(_DWORD *)v26 = 134284291;
      *(_QWORD *)&v26[4] = v13;
      v27 = 1025;
      *(_DWORD *)v28 = ID;
      *(_WORD *)&v28[4] = 2050;
      *(_QWORD *)&v28[6] = AllocSize;
      v29 = 2082;
      v30 = v18;
      _os_log_debug_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_DEBUG, "E5RTNetwork: allocated buffer object %{private}p surface id #%{private}x of %{public, iec-bytes}zu with tensor descriptor of port: %{public}s", v26, 0x26u);
    }
    v9 = *(_QWORD **)(a1 + 8);
    *(_QWORD *)v26 = a1 + 16;
    v26[8] = 1;
    if (sub_1D3D8275C(v9, (uint64_t **)v26, &v24))
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v20 = *(_QWORD *)(a1 + 16);
        v21 = *(_QWORD **)a1;
        if (*(char *)(*(_QWORD *)a1 + 23) < 0)
          v21 = (_QWORD *)*v21;
        *(_DWORD *)v26 = 134283779;
        *(_QWORD *)&v26[4] = v20;
        v27 = 2082;
        *(_QWORD *)v28 = v21;
        _os_log_debug_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_DEBUG, "E5RTNetwork: bound buffer object %{private}p to port: %{public}s", v26, 0x16u);
      }
      return 1;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v22 = *(_QWORD *)(a1 + 16);
      v23 = *(_QWORD **)a1;
      if (*(char *)(*(_QWORD *)a1 + 23) < 0)
        v23 = (_QWORD *)*v23;
      *(_DWORD *)v26 = 134283779;
      *(_QWORD *)&v26[4] = v22;
      v27 = 2082;
      *(_QWORD *)v28 = v23;
      _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to bind buffer object %{private}p to port: %{public}s", v26, 0x16u);
    }
    *(_QWORD *)v26 = -6004;
    *(_QWORD *)buf = CFSTR("Unable to bind buffer object to port.");
    sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)v26, (CFTypeRef *)buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v19 = *(_QWORD **)a1;
      if (*(char *)(*(_QWORD *)a1 + 23) < 0)
        v19 = (_QWORD *)*v19;
      *(_DWORD *)v26 = 136446210;
      *(_QWORD *)&v26[4] = v19;
      _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable allocate buffer object with tensor descriptor of port: %{public}s", v26, 0xCu);
    }
    *(_QWORD *)v26 = -2003;
    *(_QWORD *)buf = CFSTR("Unable allocate buffer object with tensor descriptor of port.");
    sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)v26, (CFTypeRef *)buf);
  }
  v11 = v24;
  if (!*(_BYTE *)(a2 + 52))
    *(_BYTE *)(a2 + 52) = 1;
  result = 0;
  *(_DWORD *)(a2 + 48) = v11;
  return result;
}

void sub_1D3D835B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D835F8(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t (*v6)(uint64_t *, unint64_t);
  unint64_t v7;
  unsigned int v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  _QWORD *v12;
  uint64_t result;
  unsigned int v14;
  const char *v15;
  uint64_t v16;
  __IOSurface *v17;
  IOSurfaceID ID;
  __IOSurface *v19;
  size_t AllocSize;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  unsigned int v27;
  uint64_t v28;
  _BYTE v29[12];
  __int16 v30;
  _BYTE v31[14];
  __int16 v32;
  unint64_t v33;
  uint8_t buf[8];
  __int16 v35;
  const char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v27 = 0;
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v28 = 0;
  v6 = (uint64_t (*)(uint64_t *, unint64_t))off_1EDB89458;
  v7 = atomic_load(a2);
  v8 = v6(&v28, v7);
  v27 = v8;
  if (v8)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v9 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v15 = sub_1D3D82AEC(&v27);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v8;
      v35 = 2082;
      v36 = v15;
      _os_log_error_impl(&dword_1D3D6B000, v9, OS_LOG_TYPE_ERROR, "e5rt_buffer_object_create_from_iosurface failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    v29[0] = 0;
    v31[2] = 0;
  }
  else
  {
    *(_QWORD *)buf = v28;
    sub_1D3D82EB8((uint64_t)v29, buf, &v27);
    sub_1D3D82B8C(buf);
  }
  sub_1D3D82674(a1 + 16, (uint64_t *)v29);
  sub_1D3D82720((uint64_t)v29);
  v10 = *(unsigned __int8 *)(a1 + 32);
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v11 = qword_1EDB89F98;
  if (v10)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      v16 = *(_QWORD *)(a1 + 16);
      v17 = (__IOSurface *)atomic_load((unint64_t *)(a1 + 24));
      ID = IOSurfaceGetID(v17);
      v19 = (__IOSurface *)atomic_load((unint64_t *)(a1 + 24));
      AllocSize = IOSurfaceGetAllocSize(v19);
      v21 = atomic_load(a2);
      *(_DWORD *)v29 = 134284289;
      *(_QWORD *)&v29[4] = v16;
      v30 = 1025;
      *(_DWORD *)v31 = ID;
      *(_WORD *)&v31[4] = 2050;
      *(_QWORD *)&v31[6] = AllocSize;
      v32 = 2050;
      v33 = v21;
      _os_log_debug_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_DEBUG, "E5RTNetwork: created buffer object %{private}p surface id #%{private}x of %{public, iec-bytes}zu from surface: %{public}p", v29, 0x26u);
    }
    v12 = *(_QWORD **)(a1 + 8);
    *(_QWORD *)v29 = a1 + 16;
    v29[8] = 1;
    if (sub_1D3D8275C(v12, (uint64_t **)v29, &v27))
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v23 = *(_QWORD *)(a1 + 16);
        v24 = *(_QWORD **)a1;
        if (*(char *)(*(_QWORD *)a1 + 23) < 0)
          v24 = (_QWORD *)*v24;
        *(_DWORD *)v29 = 134283779;
        *(_QWORD *)&v29[4] = v23;
        v30 = 2082;
        *(_QWORD *)v31 = v24;
        _os_log_debug_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_DEBUG, "E5RTNetwork: bound buffer object %{private}p to port: %{public}s", v29, 0x16u);
      }
      return 1;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v25 = *(_QWORD *)(a1 + 16);
      v26 = *(_QWORD **)a1;
      if (*(char *)(*(_QWORD *)a1 + 23) < 0)
        v26 = (_QWORD *)*v26;
      *(_DWORD *)v29 = 134283779;
      *(_QWORD *)&v29[4] = v25;
      v30 = 2082;
      *(_QWORD *)v31 = v26;
      _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to bind buffer object %{private}p to port: %{public}s", v29, 0x16u);
    }
    *(_QWORD *)v29 = -6004;
    *(_QWORD *)buf = CFSTR("Unable to bind buffer object to port.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v29, (CFTypeRef *)buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v22 = atomic_load(a2);
      *(_DWORD *)v29 = 134283521;
      *(_QWORD *)&v29[4] = v22;
      _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable create buffer object from surface: %{private}p", v29, 0xCu);
    }
    *(_QWORD *)v29 = -2003;
    *(_QWORD *)buf = CFSTR("Unable create buffer object from surface.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v29, (CFTypeRef *)buf);
  }
  v14 = v27;
  if (!*(_BYTE *)(a3 + 52))
    *(_BYTE *)(a3 + 52) = 1;
  result = 0;
  *(_DWORD *)(a3 + 48) = v14;
  return result;
}

void sub_1D3D839EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

BOOL sub_1D3D83A2C(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  _BOOL8 v5;
  NSObject *v6;
  unsigned int v7;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  const __CFString *v13;
  unsigned int v14;
  _BYTE buf[12];
  __int16 v16;
  _QWORD *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v4 = (_QWORD *)a1[1];
  buf[0] = 0;
  buf[8] = 0;
  v5 = sub_1D3D8275C(v4, (uint64_t **)buf, &v14);
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v6 = qword_1EDB89F98;
  if (v5)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      v9 = a1[2];
      v10 = (_QWORD *)*a1;
      if (*(char *)(*a1 + 23) < 0)
        v10 = (_QWORD *)*v10;
      *(_DWORD *)buf = 134283779;
      *(_QWORD *)&buf[4] = v9;
      v16 = 2082;
      v17 = v10;
      _os_log_debug_impl(&dword_1D3D6B000, v6, OS_LOG_TYPE_DEBUG, "E5RTNetwork: unbound buffer object %{private}p from port: %{public}s", buf, 0x16u);
    }
    sub_1D3D82E7C(a1 + 2);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v11 = a1[2];
      v12 = (_QWORD *)*a1;
      if (*(char *)(*a1 + 23) < 0)
        v12 = (_QWORD *)*v12;
      *(_DWORD *)buf = 134283779;
      *(_QWORD *)&buf[4] = v11;
      v16 = 2082;
      v17 = v12;
      _os_log_error_impl(&dword_1D3D6B000, v6, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to unbind buffer object %{private}p from port: %{public}s", buf, 0x16u);
    }
    *(_QWORD *)buf = -6004;
    v13 = CFSTR("Unable to unbind buffer object from port.");
    sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)buf, (CFTypeRef *)&v13);
    v7 = v14;
    if (!*(_BYTE *)(a2 + 52))
      *(_BYTE *)(a2 + 52) = 1;
    *(_DWORD *)(a2 + 48) = v7;
  }
  return v5;
}

_QWORD *sub_1D3D83BF4(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC460;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0AA8);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D83C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D83CD8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D83CEC(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC460;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D83D20(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC460;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D83D3C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 8))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D83D48(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP22e5rt_tensor_desc_dtypeEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D83D80()
{
  return &unk_1E95ABCF8;
}

void sub_1D3D83D8C(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  NSObject *v12;
  uint32_t v13;
  unsigned int v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  const char *v20;
  unsigned int v21;
  NSObject *v22;
  const char *v23;
  const char *v24;
  unsigned int v25;
  const char *v26;
  unsigned int v27;
  const char *v28;
  unsigned int v29;
  const char *v30;
  unsigned int v31;
  const char *v32;
  char v33;
  unsigned int v34;
  const char *v35;
  size_t v36;
  uint64_t v37;
  unsigned int v38;
  const char *v39;
  uint64_t v40;
  size_t v41;
  uint64_t v42;
  unsigned int v43;
  const char *v44;
  uint64_t v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  size_t __len[2];
  __int128 v60;
  __int128 v61;
  _OWORD v62[2];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *__src;
  void *v71;
  _BYTE buf[32];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v66 = 0;
  v6 = off_1EDB89480(*a2, &v66);
  *a3 = v6;
  if (v6)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    v20 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v6;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v20;
    v10 = "e5rt_io_port_is_tensor failed: (%{public}d): %{public}s";
    goto LABEL_28;
  }
  if (!v66)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v11 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    *(_WORD *)buf = 0;
    v10 = "E5RTTensorIOPort: port is not a tensor";
    v12 = v11;
    v13 = 2;
    goto LABEL_29;
  }
  v65 = 0;
  v8 = off_1EDB89488(*a2, &v65);
  *a3 = v8;
  if (v8)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    v9 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v8;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v9;
    v10 = "e5rt_io_port_retain_tensor_desc failed: (%{public}d): %{public}s";
LABEL_28:
    v12 = v7;
    v13 = 18;
LABEL_29:
    _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, v10, buf, v13);
LABEL_7:
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 144) = 0;
    return;
  }
  v64 = v65;
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v71 = 0;
  v14 = off_1EDB89438(v64, &v71);
  *a3 = v14;
  if (v14)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v15 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_88;
    v16 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v14;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v16;
    v17 = "e5rt_tensor_desc_retain_dtype failed: (%{public}d): %{public}s";
    goto LABEL_25;
  }
  __src = v71;
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  LOBYTE(v69) = 0;
  v21 = off_1EDB89400(__src, &v69);
  *a3 = v21;
  if (v21)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v22 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_58;
    v23 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v21;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v23;
    v24 = "e5rt_tensor_desc_dtype_get_num_components failed: (%{public}d): %{public}s";
LABEL_57:
    _os_log_error_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_ERROR, v24, buf, 0x12u);
LABEL_58:
    v33 = 0;
    goto LABEL_59;
  }
  *((_QWORD *)&v57 + 1) = v69;
  v25 = off_1EDB89408(__src, &v58);
  *a3 = v25;
  if (v25)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v22 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_58;
    v26 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v25;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v26;
    v24 = "e5rt_tensor_desc_dtype_get_element_size failed: (%{public}d): %{public}s";
    goto LABEL_57;
  }
  v27 = off_1EDB89410(__src, (char *)&v58 + 8);
  *a3 = v27;
  if (v27)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v22 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_58;
    v28 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v27;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v28;
    v24 = "e5rt_tensor_desc_dtype_get_component_size failed: (%{public}d): %{public}s";
    goto LABEL_57;
  }
  v29 = off_1EDB89418(__src, (char *)&v57 + 4);
  *a3 = v29;
  if (v29)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v22 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_58;
    v30 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v29;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v30;
    v24 = "e5rt_tensor_desc_dtype_get_component_pack failed: (%{public}d): %{public}s";
    goto LABEL_57;
  }
  v31 = off_1EDB89420(__src, &v57);
  *a3 = v31;
  if (v31)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v22 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_58;
    v32 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v31;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v32;
    v24 = "e5rt_tensor_desc_dtype_get_component_dtype failed: (%{public}d): %{public}s";
    goto LABEL_57;
  }
  v33 = 1;
LABEL_59:
  sub_1D3D83BF4(&__src);
  if ((v33 & 1) == 0)
    goto LABEL_88;
  v34 = off_1EDB89440(v64, __len);
  *a3 = v34;
  if (v34)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v15 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_88;
    v35 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v34;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v35;
    v17 = "e5rt_tensor_desc_get_rank failed: (%{public}d): %{public}s";
    goto LABEL_25;
  }
  v36 = __len[0];
  if (__len[0] >= 6)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v37 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_88;
    *(_DWORD *)buf = 134349312;
    *(_QWORD *)&buf[4] = v36;
    *(_WORD *)&buf[12] = 2050;
    *(_QWORD *)&buf[14] = 5;
    v17 = "E5RTTensorDescriptor: rank %{public}zu exceeds max rank %{public}zu";
    goto LABEL_70;
  }
  v69 = 0;
  __src = 0;
  v38 = off_1EDB89448(v64, &v69, &__src);
  *a3 = v38;
  if (v38)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v15 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_88;
    v39 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v38;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v39;
    v17 = "e5rt_tensor_desc_get_shape failed: (%{public}d): %{public}s";
    goto LABEL_25;
  }
  v40 = v69;
  v41 = __len[0];
  if (v69 != __len[0])
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v37 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_88;
    *(_DWORD *)buf = 134349312;
    *(_QWORD *)&buf[4] = v40;
    *(_WORD *)&buf[12] = 2050;
    *(_QWORD *)&buf[14] = v41;
    v17 = "E5RTTensorDescriptor: shape rank %{public}zu differs from rank %{public}zu";
LABEL_70:
    v18 = v37;
    v19 = 22;
    goto LABEL_26;
  }
  v42 = 8 * v69;
  if (!v69 || (memmove(&__len[1], __src, 8 * v69), v40 != 5))
    bzero((char *)&v57 + v42 + 40, 40 - v42);
  v67 = 0;
  v68 = 0;
  v43 = off_1EDB89450(v64, &v67, &v68);
  *a3 = v43;
  if (v43)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v15 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_88;
    v44 = sub_1D3D82AEC(a3);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v43;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v44;
    v17 = "e5rt_tensor_desc_get_strides failed: (%{public}d): %{public}s";
LABEL_25:
    v18 = v15;
    v19 = 18;
LABEL_26:
    _os_log_error_impl(&dword_1D3D6B000, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    goto LABEL_88;
  }
  v45 = v67;
  v46 = __len[0];
  if (v67 != __len[0])
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v37 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      goto LABEL_88;
    *(_DWORD *)buf = 134349312;
    *(_QWORD *)&buf[4] = v45;
    *(_WORD *)&buf[12] = 2050;
    *(_QWORD *)&buf[14] = v46;
    v17 = "E5RTTensorDescriptor: strides rank %{public}zu differs from rank %{public}zu";
    goto LABEL_70;
  }
  if (!v67)
  {
LABEL_97:
    bzero((char *)v62 + 8 * v45, 40 - 8 * v45);
LABEL_98:
    v50 = *a2;
    *a2 = 0;
    v51 = v64;
    v64 = 0;
    v76 = v61;
    v77 = v62[0];
    v78 = v62[1];
    *(_QWORD *)&v79 = v63;
    *(_OWORD *)&buf[16] = v57;
    v73 = v58;
    v74 = *(_OWORD *)__len;
    v75 = v60;
    BYTE8(v79) = 1;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)a1 = v50;
    *(_QWORD *)(a1 + 8) = v51;
    v52 = v73;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)&buf[16];
    *(_OWORD *)(a1 + 32) = v52;
    v53 = v77;
    *(_OWORD *)(a1 + 80) = v76;
    *(_OWORD *)(a1 + 96) = v53;
    v54 = v75;
    *(_OWORD *)(a1 + 48) = v74;
    *(_OWORD *)(a1 + 64) = v54;
    v55 = v79;
    *(_OWORD *)(a1 + 112) = v78;
    *(_OWORD *)(a1 + 128) = v55;
    *(_BYTE *)(a1 + 144) = 1;
    sub_1D3D84990(&buf[8]);
    sub_1D3D84A70(buf);
    goto LABEL_89;
  }
  v47 = 0;
  v48 = v68;
  while (1)
  {
    v49 = *(_QWORD *)(v48 + 8 * v47);
    if (v49 < 0)
      break;
    *((_QWORD *)v62 + v47++) = v49;
    if (v45 == v47)
    {
      if (v45 == 5)
        goto LABEL_98;
      goto LABEL_97;
    }
  }
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v56 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134349056;
    *(_QWORD *)&buf[4] = v49;
    v17 = "E5RTTensorDescriptor: unexpected negative stride %{public}zd";
    v18 = v56;
    v19 = 12;
    goto LABEL_26;
  }
LABEL_88:
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 144) = 0;
LABEL_89:
  sub_1D3D84990(&v64);
}

void sub_1D3D84940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3D84990(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC2A8;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0AC8);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D84A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3D84A70(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC1F8;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0AB8);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D84B14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D84B54()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D84B68(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC1F8;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D84B9C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC1F8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D84BB8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 136))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D84BC4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP12e5rt_io_portEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D84BFC()
{
  return &unk_1E95ABC88;
}

void sub_1D3D84C0C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D84C20(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC2A8;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D84C54(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC2A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D84C70(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 56))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D84C7C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP16e5rt_tensor_descEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D84CB4()
{
  return &unk_1E95ABCA8;
}

_QWORD *sub_1D3D84CC0(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC408;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0A38);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D84D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D84DA4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D84DB8(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC408;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D84DEC(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC408;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D84E08(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 176))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D84E14(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP21e5rt_program_functionEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D84E4C()
{
  return &unk_1E95ABCE8;
}

_QWORD *sub_1D3D84E58(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC358;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0A48);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D84EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D84F3C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D84F50(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC358;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D84F84(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC358;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D84FA0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 192))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D84FAC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP20e5rt_program_libraryEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D84FE4()
{
  return &unk_1E95ABCC8;
}

BOOL sub_1D3D84FF0(_QWORD *a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v6;
  NSObject *v7;
  _DWORD v9[2];
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v6 = off_1EDB894E8(*a1, *a2, a2[1]);
  *a3 = v6;
  if (v6)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v9[0] = 67240450;
      v9[1] = v6;
      v10 = 2082;
      v11 = sub_1D3D82AEC(a3);
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_preferred_cpu_backends failed: (%{public}d): %{public}s", (uint8_t *)v9, 0x12u);
    }
  }
  return v6 == 0;
}

_QWORD *sub_1D3D85130(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC510;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0A58);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D851D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D85214()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D85228(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC510;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D8525C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC510;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D85278(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 224))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D85284(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP24e5rt_e5_compiler_optionsEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D852BC()
{
  return &unk_1E95ABD18;
}

_QWORD *sub_1D3D852C8(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC250;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0A68);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D8536C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D853AC()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D853C0(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC250;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D853F4(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC250;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D85410(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 280))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D8541C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP16e5rt_e5_compilerEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D85454()
{
  return &unk_1E95ABC98;
}

BOOL sub_1D3D85460(_QWORD *a1, uint64_t a2, unsigned int *a3)
{
  unsigned int v6;
  NSObject *v7;
  _DWORD v9[2];
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v6 = off_1EDB89538(*a1, a2);
  *a3 = v6;
  if (v6)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v9[0] = 67240450;
      v9[1] = v6;
      v10 = 2082;
      v11 = sub_1D3D82AEC(a3);
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_set_operation_name failed: (%{public}d): %{public}s", (uint8_t *)v9, 0x12u);
    }
  }
  return v6 == 0;
}

BOOL sub_1D3D855A0(_QWORD *a1, unsigned int *a2)
{
  unsigned int v4;
  NSObject *v5;
  _DWORD v7[2];
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v4 = off_1EDB89540(*a1, 1);
  *a2 = v4;
  if (v4)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v5 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v7[0] = 67240450;
      v7[1] = v4;
      v8 = 2082;
      v9 = sub_1D3D82AEC(a2);
      _os_log_error_impl(&dword_1D3D6B000, v5, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_set_allocate_intermediate_buffers failed: (%{public}d): %{public}s", (uint8_t *)v7, 0x12u);
    }
  }
  return v4 == 0;
}

BOOL sub_1D3D856DC(_QWORD *a1, uint64_t **a2, unsigned int *a3)
{
  uint64_t v6;
  unsigned int v7;
  NSObject *v8;
  _DWORD v10[2];
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  if (*((_BYTE *)a2 + 8))
    v6 = **a2;
  else
    v6 = 0;
  v7 = off_1EDB89548(*a1, v6);
  *a3 = v7;
  if (v7)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v8 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v10[0] = 67240450;
      v10[1] = v7;
      v11 = 2082;
      v12 = sub_1D3D82AEC(a3);
      _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_set_override_compute_gpu_device failed: (%{public}d): %{public}s", (uint8_t *)v10, 0x12u);
    }
  }
  return v7 == 0;
}

void sub_1D3D85830(_BYTE *a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint8_t buf[8];
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v9 = 0;
  v6 = off_1EDB89528(&v9, *a2);
  *a3 = v6;
  if (v6)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v8 = sub_1D3D82AEC(a3);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v6;
      v11 = 2082;
      v12 = v8;
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_create_with_program_function failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    *a1 = 0;
    a1[8] = 0;
  }
  else
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)a1 = v9;
    a1[8] = 1;
    sub_1D3D859A0(buf);
  }
}

void sub_1D3D85994(_Unwind_Exception *a1, int a2)
{
  if (a2)
    sub_1D3D6D5A8(a1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D859A0(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC5C0;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0A78);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D85A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D85A84()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D85A98(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC5C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D85ACC(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC5C0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D85AE8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 320))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D85AF4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP42e5rt_precompiled_compute_op_create_optionsEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D85B2C()
{
  return &unk_1E95ABD38;
}

void sub_1D3D85B38(_BYTE *a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint8_t buf[8];
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v9 = 0;
  v6 = off_1EDB89560(&v9, *a2);
  *a3 = v6;
  if (v6)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v7 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v8 = sub_1D3D82AEC(a3);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v6;
      v11 = 2082;
      v12 = v8;
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_operation_create_precompiled_compute_operation_with_options failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    *a1 = 0;
    a1[8] = 0;
  }
  else
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)a1 = v9;
    a1[8] = 1;
    sub_1D3D85CA8(buf);
  }
}

void sub_1D3D85C9C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    sub_1D3D6D5A8(a1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D85CA8(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC568;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0A88);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D85D4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D85D8C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D85DA0(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC568;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D85DD4(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC568;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D85DF0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 376))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D85DFC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP31e5rt_execution_stream_operationEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D85E34()
{
  return &unk_1E95ABD28;
}

_QWORD *sub_1D3D85E40(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC3B0;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B0A98);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D85EE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D85F24()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D85F38(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC3B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D85F6C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC3B0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D85F88(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 392))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D85F94(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP21e5rt_execution_streamEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D85FCC()
{
  return &unk_1E95ABCD8;
}

uint64_t sub_1D3D85FD8(uint64_t a1)
{
  sub_1D3D86030(a1 + 88);
  sub_1D3D86030(a1 + 48);
  sub_1D3D85CA8((_QWORD *)(a1 + 40));
  sub_1D3D85E40((_QWORD *)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1D3D86030(uint64_t a1)
{
  void *v2;

  sub_1D3D86068(*(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void sub_1D3D86068(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = (_QWORD *)*v1;
      sub_1D3D860A4((uint64_t)(v1 + 2));
      operator delete(v1);
      v1 = v2;
    }
    while (v2);
  }
}

void sub_1D3D860A4(uint64_t a1)
{
  sub_1D3D84990((_QWORD *)(a1 + 32));
  sub_1D3D84A70((_QWORD *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t sub_1D3D860F0(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v5 = *((_QWORD *)a2 + 3);
  v6 = *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 4) = 0;
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 32) = v6;
  v7 = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 5) = 0;
  *(_QWORD *)(a1 + 40) = v7;
  sub_1D3D8615C(a1 + 48, (uint64_t *)a2 + 6);
  sub_1D3D8615C(a1 + 88, (uint64_t *)a2 + 11);
  return a1;
}

uint64_t sub_1D3D8615C(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)result = v2;
  *(_QWORD *)(result + 8) = a2[1];
  a2[1] = 0;
  v5 = a2[2];
  v3 = a2 + 2;
  v4 = v5;
  *(_QWORD *)(result + 16) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 16;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void sub_1D3D861CC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;

  if (*(_QWORD *)(a1 + 24))
  {
    sub_1D3D86068(*(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v4 = *(_QWORD *)(a1 + 8);
    if (v4)
    {
      for (i = 0; i != v4; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
  v6 = *a2;
  *a2 = 0;
  v7 = *(void **)a1;
  *(_QWORD *)a1 = v6;
  if (v7)
    operator delete(v7);
  v10 = a2[2];
  v9 = a2 + 2;
  v8 = v10;
  v11 = *(v9 - 1);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(a1 + 8) = v11;
  *(v9 - 1) = 0;
  v12 = v9[1];
  *(_QWORD *)(a1 + 24) = v12;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v9 + 4);
  if (v12)
  {
    v13 = *(_QWORD *)(v8 + 8);
    v14 = *(_QWORD *)(a1 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v13 >= v14)
        v13 %= v14;
    }
    else
    {
      v13 &= v14 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v13) = a1 + 16;
    *v9 = 0;
    v9[1] = 0;
  }
}

uint64_t sub_1D3D862A0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unsigned int v9;
  NSObject *v10;
  _BOOL4 v11;
  NSObject *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t *v15;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[18];
  char v21;
  unsigned int v22;
  const __CFString *v23;
  _BYTE buf[22];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*(char *)(a3 + 23) >= 0)
    v8 = a3;
  else
    v8 = *(_QWORD *)a3;
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v23 = 0;
  v9 = off_1EDB89550(*(_QWORD *)(a2 + 40), v8, &v23);
  v22 = v9;
  if (v9)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v10 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v17 = sub_1D3D82AEC(&v22);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v9;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v17;
      _os_log_error_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_operation_retain_input_port failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    LOBYTE(v20[0]) = 0;
    v21 = 0;
    v11 = 1;
  }
  else
  {
    *(_QWORD *)buf = v23;
    sub_1D3D83D8C((uint64_t)v20, buf, &v22);
    sub_1D3D84A70(buf);
    v11 = v21 == 0;
  }
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v12 = qword_1EDB89F98;
  if (v11)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0)
        v18 = a3;
      else
        v18 = *(_QWORD *)a3;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = v18;
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to get input port: %{public}s", buf, 0xCu);
    }
    v23 = CFSTR("Unable to get an input port.");
    *(_QWORD *)buf = -6004;
    sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)&v23);
    v13 = v22;
    if (!*(_BYTE *)(a4 + 52))
      *(_BYTE *)(a4 + 52) = 1;
    v14 = 0;
    *(_DWORD *)(a4 + 48) = v13;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a3 + 23) >= 0)
        v19 = a3;
      else
        v19 = *(_QWORD *)a3;
      *(_DWORD *)buf = 134283779;
      *(_QWORD *)&buf[4] = v20[0];
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v19;
      _os_log_debug_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_DEBUG, "E5RTNetwork: retrieved input port %{private}p: %{public}s", buf, 0x16u);
    }
    v15 = sub_1D3D8660C(a2 + 48, a3, a3, (uint64_t)v20);
    v14 = operator new();
    *(_QWORD *)v14 = v15 + 2;
    *(_QWORD *)(v14 + 8) = v15 + 5;
    *(_BYTE *)(v14 + 16) = 0;
    *(_BYTE *)(v14 + 32) = 0;
  }
  *a1 = v14;
  return sub_1D3D86F44((uint64_t)v20);
}

void sub_1D3D865C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1D3D8660C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  int v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint8x8_t v74;
  unint64_t v75;
  uint64_t **v76;
  uint64_t *i;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const void **v81;
  uint64_t v82;
  unsigned __int8 *v83;
  int v84;
  int v85;
  int v86;
  int v87;
  BOOL v89;
  _QWORD *v90;
  char *v91;
  _BYTE *v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  float v97;
  float v98;
  _BOOL8 v99;
  unint64_t v100;
  unint64_t v101;
  int8x8_t prime;
  void *v103;
  void *v104;
  uint64_t v105;
  _QWORD *v106;
  unint64_t v107;
  uint8x8_t v108;
  unint64_t v109;
  uint8x8_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  _QWORD *v114;
  unint64_t v115;
  _QWORD *v116;
  unint64_t v117;
  unint64_t v119;
  void *v120;
  _QWORD v121[2];
  char v122;

  v8 = *(char *)(a2 + 23);
  if (v8 >= 0)
    v9 = (_QWORD *)a2;
  else
    v9 = *(_QWORD **)a2;
  if (v8 >= 0)
    v10 = *(unsigned __int8 *)(a2 + 23);
  else
    v10 = *(_QWORD *)(a2 + 8);
  if (v10 > 0x20)
  {
    if (v10 > 0x40)
    {
      v37 = *(_QWORD *)((char *)v9 + v10 - 48);
      v38 = *(_QWORD *)((char *)v9 + v10 - 40);
      v39 = *(_QWORD *)((char *)v9 + v10 - 24);
      v40 = *(_QWORD *)((char *)v9 + v10 - 56);
      v41 = *(_QWORD *)((char *)v9 + v10 - 16);
      v42 = *(_QWORD *)((char *)v9 + v10 - 8);
      v43 = v40 + v41;
      v44 = 0x9DDFEA08EB382D69
          * (v39 ^ ((0x9DDFEA08EB382D69 * (v39 ^ (v37 + v10))) >> 47) ^ (0x9DDFEA08EB382D69 * (v39 ^ (v37 + v10))));
      v45 = 0x9DDFEA08EB382D69 * (v44 ^ (v44 >> 47));
      v46 = *(_QWORD *)((char *)v9 + v10 - 64) + v10;
      v47 = v46 + v40 + v37;
      v48 = v47 + v38;
      v49 = __ROR8__(v47, 44) + v46 + __ROR8__(v38 + v46 + v45, 21);
      v50 = v40 + v41 + *(_QWORD *)((char *)v9 + v10 - 32) - 0x4B6D499041670D8DLL;
      v51 = v50 + v39 + v41;
      v52 = v51 + v42;
      v53 = __ROR8__(v51, 44) + v50 + __ROR8__(v50 + v38 + v42, 21);
      v54 = v9 + 4;
      v55 = *v9 - 0x4B6D499041670D8DLL * v38;
      v56 = -(uint64_t)((v10 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        v57 = *(v54 - 3);
        v58 = v55 + v48 + v43 + v57;
        v59 = v54[2];
        v60 = v54[3];
        v61 = v54[1];
        v43 = v61 + v48 - 0x4B6D499041670D8DLL * __ROR8__(v43 + v49 + v59, 42);
        v62 = v45 + v52;
        v63 = *(v54 - 2);
        v64 = *(v54 - 1);
        v65 = *(v54 - 4) - 0x4B6D499041670D8DLL * v49;
        v66 = v65 + v52 + v64;
        v67 = v65 + v57 + v63;
        v48 = v67 + v64;
        v68 = __ROR8__(v67, 44) + v65;
        v69 = (0xB492B66FBE98F273 * __ROR8__(v58, 37)) ^ v53;
        v55 = 0xB492B66FBE98F273 * __ROR8__(v62, 33);
        v49 = v68 + __ROR8__(v66 + v69, 21);
        v70 = v55 + v53 + *v54;
        v52 = v70 + v61 + v59 + v60;
        v53 = __ROR8__(v70 + v61 + v59, 44) + v70 + __ROR8__(v43 + v63 + v70 + v60, 21);
        v54 += 8;
        v45 = v69;
        v56 += 64;
      }
      while (v56);
      v71 = v55
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v53 ^ ((0x9DDFEA08EB382D69 * (v53 ^ v49)) >> 47) ^ (0x9DDFEA08EB382D69 * (v53 ^ v49)))) ^ ((0x9DDFEA08EB382D69 * (v53 ^ ((0x9DDFEA08EB382D69 * (v53 ^ v49)) >> 47) ^ (0x9DDFEA08EB382D69 * (v53 ^ v49)))) >> 47));
      v72 = 0x9DDFEA08EB382D69
          * (v71 ^ (v69
                  - 0x4B6D499041670D8DLL * (v43 ^ (v43 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v48)))) ^ ((0x9DDFEA08EB382D69 * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v48)))) >> 47))));
      v13 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69 * (v71 ^ (v72 >> 47) ^ v72)) ^ ((0x9DDFEA08EB382D69 * (v71 ^ (v72 >> 47) ^ v72)) >> 47));
      goto LABEL_19;
    }
    v14 = *(_QWORD *)((char *)v9 + v10 - 16);
    v15 = *v9 - 0x3C5A37A36834CED9 * (v14 + v10);
    v17 = v9[2];
    v16 = v9[3];
    v18 = __ROR8__(v15 + v16, 52);
    v19 = v15 + v9[1];
    v20 = __ROR8__(v19, 7);
    v21 = v19 + v17;
    v22 = *(_QWORD *)((char *)v9 + v10 - 32) + v17;
    v23 = *(_QWORD *)((char *)v9 + v10 - 8) + v16;
    v24 = __ROR8__(v23 + v22, 52);
    v25 = v20 + __ROR8__(*v9 - 0x3C5A37A36834CED9 * (v14 + v10), 37) + v18 + __ROR8__(v21, 31);
    v26 = *(_QWORD *)((char *)v9 + v10 - 24) + v22 + v14;
    v27 = v26 + v23;
    v28 = 0x9AE16A3B2F90404FLL;
    v29 = 0xC3A5C85C97CB3127 * (v27 + v25)
        - 0x651E95C4D06FBFB1
        * (v21
         + v16
         + __ROR8__(v22, 37)
         + __ROR8__(*(_QWORD *)((char *)v9 + v10 - 24) + v22, 7)
         + v24
         + __ROR8__(v26, 31));
    v30 = v25 - 0x3C5A37A36834CED9 * (v29 ^ (v29 >> 47));
    goto LABEL_15;
  }
  if (v10 > 0x10)
  {
    v31 = v9[1];
    v32 = 0xB492B66FBE98F273 * *v9;
    v33 = __ROR8__(0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)v9 + v10 - 8), 30) + __ROR8__(v32 - v31, 43);
    v34 = v32
        + v10
        + __ROR8__(v31 ^ 0xC949D7C7509E6557, 20)
        - 0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)v9 + v10 - 8);
    v28 = 0x9DDFEA08EB382D69;
    v35 = 0x9DDFEA08EB382D69 * (v34 ^ (v33 - 0x3C5A37A36834CED9 * *(_QWORD *)((char *)v9 + v10 - 16)));
    v36 = v34 ^ (v35 >> 47) ^ v35;
LABEL_14:
    v30 = 0x9DDFEA08EB382D69 * v36;
LABEL_15:
    v13 = (v30 ^ (v30 >> 47)) * v28;
    goto LABEL_19;
  }
  if (v10 >= 9)
  {
    v11 = *(_QWORD *)((char *)v9 + v10 - 8);
    v12 = __ROR8__(v11 + v10, v10);
    v13 = (0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v12 ^ ((0x9DDFEA08EB382D69 * (v12 ^ *v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ *v9)))) ^ ((0x9DDFEA08EB382D69 * (v12 ^ ((0x9DDFEA08EB382D69 * (v12 ^ *v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ *v9)))) >> 47))) ^ v11;
    goto LABEL_19;
  }
  if (v10 >= 4)
  {
    v112 = *(unsigned int *)((char *)v9 + v10 - 4);
    v28 = 0x9DDFEA08EB382D69;
    v113 = 0x9DDFEA08EB382D69 * ((v10 + (8 * *(_DWORD *)v9)) ^ v112);
    v36 = v112 ^ (v113 >> 47) ^ v113;
    goto LABEL_14;
  }
  v13 = 0x9AE16A3B2F90404FLL;
  if (v10)
  {
    v119 = (0xC949D7C7509E6557 * (v10 + 4 * *((unsigned __int8 *)v9 + v10 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)v9 | ((unint64_t)*((unsigned __int8 *)v9 + (v10 >> 1)) << 8)));
    v13 = 0x9AE16A3B2F90404FLL * (v119 ^ (v119 >> 47));
  }
LABEL_19:
  v73 = *(_QWORD *)(a1 + 8);
  if (v73)
  {
    v74 = (uint8x8_t)vcnt_s8((int8x8_t)v73);
    v74.i16[0] = vaddlv_u8(v74);
    v75 = v74.u32[0];
    if (v74.u32[0] > 1uLL)
    {
      v4 = v13;
      if (v13 >= v73)
        v4 = v13 % v73;
    }
    else
    {
      v4 = (v73 - 1) & v13;
    }
    v76 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v4);
    if (v76)
    {
      for (i = *v76; i; i = (uint64_t *)*i)
      {
        v78 = i[1];
        if (v78 == v13)
        {
          v79 = *((unsigned __int8 *)i + 39);
          if ((v79 & 0x80u) == 0)
            v80 = *((unsigned __int8 *)i + 39);
          else
            v80 = i[3];
          if (v80 == v10)
          {
            v81 = (const void **)(i + 2);
            if ((v79 & 0x80) != 0)
            {
              if (!memcmp(*v81, v9, i[3]))
                return i;
            }
            else
            {
              if (!*((_BYTE *)i + 39))
                return i;
              v82 = v79 - 1;
              v83 = (unsigned __int8 *)v9;
              do
              {
                v85 = *(unsigned __int8 *)v81;
                v81 = (const void **)((char *)v81 + 1);
                v84 = v85;
                v87 = *v83++;
                v86 = v87;
                v89 = v82-- != 0;
              }
              while (v84 == v86 && v89);
              if (v84 == v86)
                return i;
            }
          }
        }
        else
        {
          if (v75 > 1)
          {
            if (v78 >= v73)
              v78 %= v73;
          }
          else
          {
            v78 &= v73 - 1;
          }
          if (v78 != v4)
            break;
        }
      }
    }
  }
  v90 = (_QWORD *)(a1 + 16);
  v91 = (char *)operator new(0xB8uLL);
  v121[0] = v91;
  v121[1] = a1 + 16;
  v122 = 0;
  *(_QWORD *)v91 = 0;
  *((_QWORD *)v91 + 1) = v13;
  v92 = v91 + 16;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1D3D7FCC0(v92, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)v92 = *(_OWORD *)a3;
    *((_QWORD *)v91 + 4) = *(_QWORD *)(a3 + 16);
  }
  v93 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)(v91 + 40) = *(_OWORD *)a4;
  v94 = *(_OWORD *)(a4 + 64);
  *(_OWORD *)(v91 + 120) = *(_OWORD *)(a4 + 80);
  v95 = *(_OWORD *)(a4 + 112);
  *(_OWORD *)(v91 + 136) = *(_OWORD *)(a4 + 96);
  *(_OWORD *)(v91 + 152) = v95;
  *(_OWORD *)(v91 + 168) = *(_OWORD *)(a4 + 128);
  *(_OWORD *)(v91 + 56) = v93;
  v96 = *(_OWORD *)(a4 + 48);
  *(_OWORD *)(v91 + 72) = *(_OWORD *)(a4 + 32);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_OWORD *)(v91 + 88) = v96;
  *(_OWORD *)(v91 + 104) = v94;
  v122 = 1;
  v97 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v98 = *(float *)(a1 + 32);
  if (!v73 || (float)(v98 * (float)v73) < v97)
  {
    v99 = v73 < 3 || (v73 & (v73 - 1)) != 0;
    v100 = v99 | (2 * v73);
    v101 = vcvtps_u32_f32(v97 / v98);
    if (v100 <= v101)
      prime = (int8x8_t)v101;
    else
      prime = (int8x8_t)v100;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v73 = *(_QWORD *)(a1 + 8);
    if (*(_QWORD *)&prime > v73)
      goto LABEL_67;
    if (*(_QWORD *)&prime < v73)
    {
      v109 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v73 < 3 || (v110 = (uint8x8_t)vcnt_s8((int8x8_t)v73), v110.i16[0] = vaddlv_u8(v110), v110.u32[0] > 1uLL))
      {
        v109 = std::__next_prime(v109);
      }
      else
      {
        v111 = 1 << -(char)__clz(v109 - 1);
        if (v109 >= 2)
          v109 = v111;
      }
      if (*(_QWORD *)&prime <= v109)
        prime = (int8x8_t)v109;
      if (*(_QWORD *)&prime >= v73)
      {
        v73 = *(_QWORD *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_67:
          if (*(_QWORD *)&prime >> 61)
            sub_1D3D6D50C();
          v103 = operator new(8 * *(_QWORD *)&prime);
          v104 = *(void **)a1;
          *(_QWORD *)a1 = v103;
          if (v104)
            operator delete(v104);
          v105 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v105++) = 0;
          while (*(_QWORD *)&prime != v105);
          v106 = (_QWORD *)*v90;
          if (*v90)
          {
            v107 = v106[1];
            v108 = (uint8x8_t)vcnt_s8(prime);
            v108.i16[0] = vaddlv_u8(v108);
            if (v108.u32[0] > 1uLL)
            {
              if (v107 >= *(_QWORD *)&prime)
                v107 %= *(_QWORD *)&prime;
            }
            else
            {
              v107 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v107) = v90;
            v114 = (_QWORD *)*v106;
            if (*v106)
            {
              do
              {
                v115 = v114[1];
                if (v108.u32[0] > 1uLL)
                {
                  if (v115 >= *(_QWORD *)&prime)
                    v115 %= *(_QWORD *)&prime;
                }
                else
                {
                  v115 &= *(_QWORD *)&prime - 1;
                }
                if (v115 != v107)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v115))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v115) = v106;
                    goto LABEL_94;
                  }
                  *v106 = *v114;
                  *v114 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v115);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v115) = v114;
                  v114 = v106;
                }
                v115 = v107;
LABEL_94:
                v106 = v114;
                v114 = (_QWORD *)*v114;
                v107 = v115;
              }
              while (v114);
            }
          }
          v73 = (unint64_t)prime;
          goto LABEL_98;
        }
        v120 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v120)
          operator delete(v120);
        v73 = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
LABEL_98:
    if ((v73 & (v73 - 1)) != 0)
    {
      if (v13 >= v73)
        v4 = v13 % v73;
      else
        v4 = v13;
    }
    else
    {
      v4 = (v73 - 1) & v13;
    }
  }
  v116 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  i = (uint64_t *)v121[0];
  if (v116)
  {
    *(_QWORD *)v121[0] = *v116;
LABEL_111:
    *v116 = i;
    goto LABEL_112;
  }
  *(_QWORD *)v121[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v90;
  if (*i)
  {
    v117 = *(_QWORD *)(*i + 8);
    if ((v73 & (v73 - 1)) != 0)
    {
      if (v117 >= v73)
        v117 %= v73;
    }
    else
    {
      v117 &= v73 - 1;
    }
    v116 = (_QWORD *)(*(_QWORD *)a1 + 8 * v117);
    goto LABEL_111;
  }
LABEL_112:
  v121[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  sub_1D3D86F84((uint64_t)v121);
  return i;
}

void sub_1D3D86F2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D86F84((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D86F44(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 144))
  {
    sub_1D3D84990((_QWORD *)(a1 + 8));
    sub_1D3D84A70((_QWORD *)a1);
  }
  return a1;
}

void sub_1D3D86F84(uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1D3D860A4((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

uint64_t sub_1D3D86FC8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unsigned int v9;
  NSObject *v10;
  _BOOL4 v11;
  NSObject *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t *v15;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[18];
  char v21;
  unsigned int v22;
  const __CFString *v23;
  _BYTE buf[22];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*(char *)(a3 + 23) >= 0)
    v8 = a3;
  else
    v8 = *(_QWORD *)a3;
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v23 = 0;
  v9 = off_1EDB89558(*(_QWORD *)(a2 + 40), v8, &v23);
  v22 = v9;
  if (v9)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v10 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v17 = sub_1D3D82AEC(&v22);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v9;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v17;
      _os_log_error_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_operation_retain_output_port failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    LOBYTE(v20[0]) = 0;
    v21 = 0;
    v11 = 1;
  }
  else
  {
    *(_QWORD *)buf = v23;
    sub_1D3D83D8C((uint64_t)v20, buf, &v22);
    sub_1D3D84A70(buf);
    v11 = v21 == 0;
  }
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v12 = qword_1EDB89F98;
  if (v11)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0)
        v18 = a3;
      else
        v18 = *(_QWORD *)a3;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = v18;
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to get output port: %{public}s", buf, 0xCu);
    }
    v23 = CFSTR("Unable to get an output port.");
    *(_QWORD *)buf = -6004;
    sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)&v23);
    v13 = v22;
    if (!*(_BYTE *)(a4 + 52))
      *(_BYTE *)(a4 + 52) = 1;
    v14 = 0;
    *(_DWORD *)(a4 + 48) = v13;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a3 + 23) >= 0)
        v19 = a3;
      else
        v19 = *(_QWORD *)a3;
      *(_DWORD *)buf = 134283779;
      *(_QWORD *)&buf[4] = v20[0];
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v19;
      _os_log_debug_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_DEBUG, "E5RTNetwork: retrieved output port %{private}p: %{public}s", buf, 0x16u);
    }
    v15 = sub_1D3D8660C(a2 + 88, a3, a3, (uint64_t)v20);
    v14 = operator new();
    *(_QWORD *)v14 = v15 + 2;
    *(_QWORD *)(v14 + 8) = v15 + 5;
    *(_BYTE *)(v14 + 16) = 0;
    *(_BYTE *)(v14 + 32) = 0;
  }
  *a1 = v14;
  return sub_1D3D86F44((uint64_t)v20);
}

void sub_1D3D872EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D87334(uint64_t a1, qos_class_t *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  NSObject *v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  NSObject *v17;
  unsigned int v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  NSObject *v22;
  uint64_t v23;
  unsigned int v24;
  NSObject *v25;
  _QWORD *v26;
  uint64_t v27;
  qos_class_t v29;
  unsigned int v30;
  unint64_t v31;
  const char *v32;
  const char *v33;
  const __CFString *v34;
  unsigned int v35;
  _QWORD v36[3];
  _QWORD *v37;
  _QWORD v38[3];
  _QWORD *v39;
  uint64_t v40;
  _QWORD v41[3];
  _QWORD *v42;
  uint8_t buf[8];
  __int16 v44;
  const char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v38[0] = &off_1E95AC148;
  v38[1] = a1;
  v39 = v38;
  v40 = a4;
  v36[0] = &off_1E95AC1A0;
  v36[1] = a1;
  v37 = v36;
  v41[0] = &off_1E95AC1A0;
  v41[1] = a1;
  v42 = v41;
  if (!*(_BYTE *)(a4 + 8)
    || (*(_QWORD *)buf = *(_QWORD *)a4, sub_1D3D87B4C((uint64_t)v38, (os_signpost_id_t *)buf), v7 = v37, v37 == v36))
  {
    v8 = 4;
    v7 = v36;
  }
  else
  {
    if (!v37)
      goto LABEL_7;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_7:
  v9 = v39;
  if (v39 == v38)
  {
    v10 = 4;
    v9 = v38;
    goto LABEL_11;
  }
  if (v39)
  {
    v10 = 5;
LABEL_11:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  if ((*(_BYTE *)(a1 + 27) & 1) == 0)
  {
    if (qword_1EDB89FB8[0] != -1)
      dispatch_once_f(qword_1EDB89FB8, 0, (dispatch_function_t)sub_1D3E0ECD4);
    if (byte_1EDB89F50)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v11 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_DEBUG, "E5RTNetwork: may execute on ANE, setting ANE execution priority from QoS", buf, 2u);
      }
      HIDWORD(v13) = *a2 - 9;
      LODWORD(v13) = HIDWORD(v13);
      v12 = v13 >> 2;
      v14 = 5;
      if (v12 <= 6 && ((0x22u >> v12) & 1) == 0)
      {
        if (((0x5Du >> v12) & 1) != 0)
        {
          v15 = dword_1D3E81384[v12];
        }
        else
        {
          HIDWORD(v16) = qos_class_self() - 9;
          LODWORD(v16) = HIDWORD(v16);
          v15 = v16 >> 2;
        }
        v14 = *(unsigned int *)&asc_1D3E61AE8[4 * v15];
      }
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v17 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
      {
        v29 = *a2;
        HIDWORD(v31) = *a2 - 9;
        LODWORD(v31) = HIDWORD(v31);
        v30 = v31 >> 2;
        if (v30 > 6 || ((1 << v30) & 0x5D) == 0)
          v29 = qos_class_self();
        *(_DWORD *)buf = 67240448;
        *(_DWORD *)&buf[4] = v29;
        v44 = 1026;
        LODWORD(v45) = v14;
        _os_log_debug_impl(&dword_1D3D6B000, v17, OS_LOG_TYPE_DEBUG, "E5RTExecutionStream: QoS %{public}x mapped to E5RT ANE execution priority %{public}d", buf, 0xEu);
      }
      if (qword_1EDB895B0 != -1)
        dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
      v18 = off_1EDB895A0(*(_QWORD *)(a1 + 32), v14);
      v35 = v18;
      if (v18)
      {
        if (qword_1EDB89F90 != -1)
          dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
        v19 = qword_1EDB89F98;
        if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
        {
          v32 = sub_1D3D82AEC(&v35);
          *(_DWORD *)buf = 67240450;
          *(_DWORD *)&buf[4] = v18;
          v44 = 2082;
          v45 = v32;
          _os_log_error_impl(&dword_1D3D6B000, v19, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_set_ane_execution_priority failed: (%{public}d): %{public}s", buf, 0x12u);
        }
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = v14;
          _os_log_error_impl(&dword_1D3D6B000, v19, OS_LOG_TYPE_ERROR, "E5RTExecutionStream: failed to set ANE execution priority %{public}d", buf, 8u);
        }
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set ANE execution priority from QoS", buf, 2u);
        }
        *(_QWORD *)buf = -6005;
        v34 = CFSTR("Unable to set ANE execution priority from QoS.");
        sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v34);
LABEL_54:
        if (!*(_BYTE *)(a3 + 52))
          *(_BYTE *)(a3 + 52) = 1;
        v23 = 0;
        *(_DWORD *)(a3 + 48) = v18;
        goto LABEL_74;
      }
    }
  }
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v18 = off_1EDB89580(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  v35 = v18;
  if (!v18)
    goto LABEL_48;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v20 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
  {
    v21 = sub_1D3D82AEC(&v35);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v18;
    v44 = 2082;
    v45 = v21;
    _os_log_error_impl(&dword_1D3D6B000, v20, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_encode_operation failed: (%{public}d): %{public}s", buf, 0x12u);
LABEL_48:
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  }
  v22 = qword_1EDB89F98;
  if (v18)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to encode execution stream operation", buf, 2u);
    }
    *(_QWORD *)buf = -6005;
    v34 = CFSTR("Unable to encode execution stream operation.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v34);
    goto LABEL_54;
  }
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_DEBUG, "E5RTNetwork: done encoding execution stream operation", buf, 2u);
  }
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v24 = off_1EDB89588(*(_QWORD *)(a1 + 32));
  v35 = v24;
  if (v24)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v25 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v33 = sub_1D3D82AEC(&v35);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v24;
      v44 = 2082;
      v45 = v33;
      _os_log_error_impl(&dword_1D3D6B000, v25, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_execute_sync failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to execute excution stream", buf, 2u);
    }
    *(_QWORD *)buf = -6005;
    v34 = CFSTR("Unable to execute excution stream.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v34);
    if (!*(_BYTE *)(a3 + 52))
      *(_BYTE *)(a3 + 52) = 1;
    v23 = 0;
    *(_DWORD *)(a3 + 48) = v24;
  }
  else
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_DEBUG, "E5RTNetwork: done executing execution stream", buf, 2u);
    }
    v23 = 1;
  }
LABEL_74:
  v26 = v42;
  if (*(_BYTE *)(v40 + 8))
  {
    if (!v42)
      return v23;
    *(_QWORD *)buf = *(_QWORD *)v40;
    (*(void (**)(void))(*v42 + 48))();
    v26 = v42;
  }
  if (v26 == v41)
  {
    v27 = 4;
    v26 = v41;
    goto LABEL_81;
  }
  if (v26)
  {
    v27 = 5;
LABEL_81:
    (*(void (**)(void))(*v26 + 8 * v27))();
  }
  return v23;
}

void sub_1D3D87B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  sub_1D3D87C3C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D3D87B4C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  uint64_t *v3;
  NSObject *v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = *(uint64_t **)(a1 + 8);
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      if (*((char *)v3 + 23) < 0)
        v3 = (uint64_t *)*v3;
      v5 = 136446210;
      v6 = v3;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v2, "E5RTNetwork::execute", "name=%{public, signpost.description:attribute}s", (uint8_t *)&v5, 0xCu);
    }
  }
}

_QWORD *sub_1D3D87C3C(_QWORD *a1)
{
  uint64_t *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v7;

  v2 = (uint64_t *)*a1;
  if (*(_BYTE *)(*a1 + 8))
  {
    v3 = a1[4];
    if (v3)
    {
      v7 = *v2;
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v7);
    }
  }
  v4 = (_QWORD *)a1[4];
  if (v4 == a1 + 1)
  {
    v5 = 4;
    v4 = a1 + 1;
    goto LABEL_8;
  }
  if (v4)
  {
    v5 = 5;
LABEL_8:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  return a1;
}

void sub_1D3D87CC8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D87CDC(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC1A0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D87D10(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC1A0;
  a2[1] = v2;
  return result;
}

void sub_1D3D87D2C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  uint64_t *v3;
  NSObject *v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = *(uint64_t **)(a1 + 8);
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      if (*((char *)v3 + 23) < 0)
        v3 = (uint64_t *)*v3;
      v5 = 136446210;
      v6 = v3;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v2, "E5RTNetwork::execute", "name=%{public, signpost.description:attribute}s", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t sub_1D3D87E1C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork7executeERKNS_7Context3QoSERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D87E54()
{
  return &unk_1E95ABC78;
}

void sub_1D3D87E64()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D87E78(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC148;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D87EAC(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC148;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D87EC8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork7executeERKNS_7Context3QoSERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D87F00()
{
  return &unk_1E95ABC68;
}

BOOL sub_1D3D87F0C(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  const __CFString *v9;
  unsigned int v10;
  uint8_t buf[8];
  __int16 v12;
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v4 = off_1EDB89598(*(_QWORD *)(a1 + 32));
  v10 = v4;
  if (!v4)
    goto LABEL_8;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v5 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
  {
    v6 = sub_1D3D82AEC(&v10);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v4;
    v12 = 2082;
    v13 = v6;
    _os_log_error_impl(&dword_1D3D6B000, v5, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_reset failed: (%{public}d): %{public}s", buf, 0x12u);
LABEL_8:
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  }
  v7 = qword_1EDB89F98;
  if (v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to reset excution stream", buf, 2u);
    }
    *(_QWORD *)buf = -6005;
    v9 = CFSTR("Unable to reset excution stream.");
    sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)buf, (CFTypeRef *)&v9);
    if (!*(_BYTE *)(a2 + 52))
      *(_BYTE *)(a2 + 52) = 1;
    *(_DWORD *)(a2 + 48) = v4;
  }
  else if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_DEBUG, "E5RTNetwork: done resetting execution stream", buf, 2u);
  }
  return v4 == 0;
}

void sub_1D3D88124(_BYTE *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, unint64_t *a7, uint64_t a8, uint64_t a9)
{
  const std::string::value_type *v16;
  std::string::size_type v17;
  NSObject *v18;
  std::string *p_dst;
  NSObject *v21;
  void *v22;
  const char *v23;
  CFURLRef v24;
  void *v25;
  NSObject *v26;
  NSObject *v27;
  id v28;
  id v29;
  const char *v30;
  id v31;
  NSObject *v32;
  const char *v33;
  __CFString *v34;
  const char *v35;
  uint64_t v36;
  void *v37;
  const char *v38;
  char v39;
  const __CFString *v41;
  CFIndex v42;
  char *v43;
  const __CFString *v44;
  std::string::size_type size;
  char v46;
  int v47;
  NSObject *v48;
  NSObject *v49;
  unint64_t v50;
  std::string::size_type v51;
  unint64_t v52;
  std::string *v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  std::string::size_type v57;
  std::string::size_type v58;
  std::string::size_type v59;
  const char *v60;
  std::string::size_type v61;
  std::string *v62;
  std::string::size_type v63;
  std::string::size_type v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t *v67;
  _BYTE *v68;
  void *context;
  __CFBundle *bundle;
  std::__fs::filesystem::path v72;
  const __CFString *v73;
  std::string __p;
  const __CFString *v75;
  std::string __dst;
  unint64_t v77;
  std::string::size_type v78;
  std::string::size_type v79;
  __int128 v80;
  __int128 v81;
  int v82;
  __int128 v83;
  __int128 v84;
  int v85;
  std::__fs::filesystem::path buf;
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  memset(&__dst, 0, sizeof(__dst));
  sub_1D3D8C744(&__dst, *(std::string **)a2, (std::string *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8)));
  if (a4)
  {
    if (a4 != 1)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v18 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 67240192;
        HIDWORD(buf.__pn_.__r_.__value_.__r.__words[0]) = a4;
        _os_log_error_impl(&dword_1D3D6B000, v18, OS_LOG_TYPE_ERROR, "E5RTNetwork: unrecognized compilation flavor: %{public}d", (uint8_t *)&buf, 8u);
      }
      buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFSTR("Unrecognized compilation flavor.");
      sub_1D3D73E0C((unint64_t *)a8, (uint64_t *)&buf, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
      goto LABEL_40;
    }
    if (a3)
    {
      if (a3 == 1)
      {
        v16 = ".mil";
        v17 = 4;
        goto LABEL_13;
      }
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v27 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 67240192;
        HIDWORD(buf.__pn_.__r_.__value_.__r.__words[0]) = a3;
        _os_log_error_impl(&dword_1D3D6B000, v27, OS_LOG_TYPE_ERROR, "E5RTNetwork: unrecognized network kind: %{public}d", (uint8_t *)&buf, 8u);
      }
      buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFSTR("Unrecognized network kind.");
      sub_1D3D73E0C((unint64_t *)a8, (uint64_t *)&buf, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
LABEL_40:
      memset(&v72, 0, sizeof(v72));
      goto LABEL_71;
    }
    v16 = ".espresso.net";
    v17 = 13;
  }
  else
  {
    v16 = ".bundle";
    v17 = 7;
  }
LABEL_13:
  std::string::append(&__dst, v16, v17);
  memset(&__p, 0, sizeof(__p));
  sub_1D3D8C744(&__p, (std::string *)"Networks", (std::string *)"");
  sub_1D3D8C650(&buf, (uint64_t)&__p, (std::__fs::filesystem::path *)&__dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  __dst = buf.__pn_;
  *((_BYTE *)&buf.__pn_.__r_.__value_.__s + 23) = 0;
  buf.__pn_.__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_dst = &__dst;
  else
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)p_dst, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (!atomic_load((unint64_t *)&__p))
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v26 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v62 = &__dst;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v62 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v62;
      _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: CFStringCreateWithCStringNoCopy failed with: %{public}s", (uint8_t *)&buf, 0xCu);
    }
    buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
    v75 = CFSTR("CFStringCreateWithCStringNoCopy failed.");
    sub_1D3D73E0C((unint64_t *)a8, (uint64_t *)&buf, (CFTypeRef *)&v75);
    memset(&v72, 0, sizeof(v72));
    goto LABEL_70;
  }
  if (qword_1EDB89F60 != -1)
    dispatch_once(&qword_1EDB89F60, &unk_1E95B3A48);
  bundle = (__CFBundle *)qword_1EDB89F18;
  v67 = a7;
  v68 = a1;
  v65 = a5;
  v66 = a6;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v21 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
  {
    v59 = atomic_load((unint64_t *)&__p);
    LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543618;
    *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = v59;
    WORD2(buf.__pn_.__r_.__value_.__r.__words[1]) = 2114;
    *(std::string::size_type *)((char *)&buf.__pn_.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)bundle;
    _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to locate %{public}@ from within: %{public}@", (uint8_t *)&buf, 0x16u);
  }
  v22 = (void *)atomic_load((unint64_t *)&__p);
  context = (void *)MEMORY[0x1D8255128]();
  if (bundle)
  {
    v24 = CFBundleCopyBundleURL(bundle);
    if (v24)
    {
      objc_msgSend_bundleWithURL_(MEMORY[0x1E0CB34D0], v23, (uint64_t)v24);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v25 = 0;
    }

  }
  else
  {
    v25 = 0;
  }
  v28 = v22;
  v29 = v25;
  if (qword_1EDB893D0 != -1)
    dispatch_once(&qword_1EDB893D0, &unk_1E95B0530);
  v31 = (id)qword_1EDB895C8;
  if (v31)
  {
    if (qword_1EDB89E30 != -1)
      dispatch_once(&qword_1EDB89E30, &unk_1E95B32A8);
    v32 = (id)qword_1EDB89E38;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
      _os_log_impl(&dword_1D3D6B000, v32, OS_LOG_TYPE_INFO, "_MRCResourcePath: overriddenBasePath=\"%{public}@\"", (uint8_t *)&buf, 0xCu);
    }

    objc_msgSend_stringByAppendingPathComponent_(v31, v33, (uint64_t)v28);
    v34 = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], v35, v36);
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    v39 = objc_msgSend_fileExistsAtPath_(v37, v38, (uint64_t)v34);

    if ((v39 & 1) != 0)
      goto LABEL_57;

  }
  if (!v29
    || (objc_msgSend_pathForResource_ofType_(v29, v30, (uint64_t)v28, 0),
        (v34 = (__CFString *)objc_claimAutoreleasedReturnValue()) == 0))
  {
    if (qword_1EFE31998 != -1)
      dispatch_once(&qword_1EFE31998, &unk_1E95B3A68);
    v34 = 0;
  }
LABEL_57:

  objc_autoreleasePoolPop(context);
  v75 = v34;
  if (atomic_load((unint64_t *)&v75))
  {
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      v61 = atomic_load((unint64_t *)&v75);
      LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543618;
      *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = v61;
      WORD2(buf.__pn_.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__pn_.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)bundle;
      _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, "E5RTNetwork: located %{public}@ from within: %{public}@", (uint8_t *)&buf, 0x16u);
    }
    v41 = (const __CFString *)atomic_load((unint64_t *)&v75);
    v42 = CFStringGetMaximumSizeOfFileSystemRepresentation(v41) + 1;
    v43 = (char *)operator new[]();
    v44 = (const __CFString *)atomic_load((unint64_t *)&v75);
    if (CFStringGetFileSystemRepresentation(v44, v43, v42))
    {
      sub_1D3D81D4C(&buf, v43);
      v72 = buf;
    }
    else
    {
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        v64 = atomic_load((unint64_t *)&v75);
        LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = v64;
        _os_log_error_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_ERROR, "E5RTNetwork: CFStringGetFileSystemRepresentation failed with: %{public}@", (uint8_t *)&buf, 0xCu);
      }
      buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
      v73 = CFSTR("CFStringGetFileSystemRepresentation failed.");
      sub_1D3D73E0C((unint64_t *)a8, (uint64_t *)&buf, (CFTypeRef *)&v73);
      memset(&v72, 0, sizeof(v72));
    }
    a7 = v67;
    a1 = v68;
    a5 = v65;
    a6 = v66;
    MEMORY[0x1D8254C3C](v43, 0x1000C8077774924);
  }
  else
  {
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v63 = atomic_load((unint64_t *)&__p);
      LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543618;
      *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = v63;
      WORD2(buf.__pn_.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__pn_.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)bundle;
      _os_log_error_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_ERROR, "E5RTNetwork: Unable to locate %{public}@ from within: %{public}@", (uint8_t *)&buf, 0x16u);
    }
    buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
    v73 = CFSTR("Unable to locate network file.");
    sub_1D3D73E0C((unint64_t *)a8, (uint64_t *)&buf, (CFTypeRef *)&v73);
    memset(&v72, 0, sizeof(v72));
    a7 = v67;
    a1 = v68;
    a5 = v65;
    a6 = v66;
  }
  sub_1D3D8C70C((unint64_t *)&v75);
LABEL_70:
  sub_1D3D8C70C((unint64_t *)&__p);
LABEL_71:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  size = HIBYTE(v72.__pn_.__r_.__value_.__r.__words[2]);
  v46 = HIBYTE(v72.__pn_.__r_.__value_.__r.__words[2]);
  if ((v72.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v72.__pn_.__r_.__value_.__l.__size_;
  if (size)
  {
    sub_1D3D88D90(&buf, (uint64_t)&v72, a3, a4, a5, a6, a7, a8, a9);
    if (!buf.__pn_.__r_.__value_.__s.__data_[8])
    {
      *a1 = 0;
      a1[128] = 0;
      goto LABEL_102;
    }
    if (qword_1EDB895B0 != -1)
      dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
    v75 = 0;
    v47 = off_1EDB89570(&v75);
    LODWORD(v73) = v47;
    if (v47)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v48 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        v60 = sub_1D3D82AEC((unsigned int *)&v73);
        LODWORD(__dst.__r_.__value_.__l.__data_) = 67240450;
        HIDWORD(__dst.__r_.__value_.__r.__words[0]) = v47;
        LOWORD(__dst.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v60;
        _os_log_error_impl(&dword_1D3D6B000, v48, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_create failed: (%{public}d): %{public}s", (uint8_t *)&__dst, 0x12u);
        __p.__r_.__value_.__s.__data_[0] = 0;
        __p.__r_.__value_.__s.__data_[8] = 0;
        if (qword_1EDB89F90 != -1)
          dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      }
      else
      {
        __p.__r_.__value_.__s.__data_[0] = 0;
        __p.__r_.__value_.__s.__data_[8] = 0;
      }
      v49 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl(&dword_1D3D6B000, v49, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT execution stream", (uint8_t *)&__dst, 2u);
      }
      v75 = CFSTR("Unable to create E5RT execution stream.");
      __dst.__r_.__value_.__r.__words[0] = -6003;
      sub_1D3D73E0C((unint64_t *)a8, (uint64_t *)&__dst, (CFTypeRef *)&v75);
      if (!*(_BYTE *)(a8 + 52))
        *(_BYTE *)(a8 + 52) = 1;
      *(_DWORD *)(a8 + 48) = v47;
      *a1 = 0;
      a1[128] = 0;
      goto LABEL_101;
    }
    __dst.__r_.__value_.__r.__words[0] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v75;
    __p.__r_.__value_.__s.__data_[8] = 1;
    sub_1D3D85E40(&__dst);
    v50 = sub_1D3E181F0(a7);
    v51 = *(_QWORD *)(a2 + 8);
    if (v51 >= 0x7FFFFFFFFFFFFFF8)
      sub_1D3D7FD48();
    v52 = v50;
    v53 = *(std::string **)a2;
    if (v51 >= 0x17)
    {
      v55 = (v51 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v51 | 7) != 0x17)
        v55 = v51 | 7;
      v56 = v55 + 1;
      v54 = operator new(v55 + 1);
      __dst.__r_.__value_.__l.__size_ = v51;
      __dst.__r_.__value_.__r.__words[2] = v56 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v51;
      v54 = &__dst;
      if (!v51)
        goto LABEL_100;
    }
    memmove(v54, v53, v51);
LABEL_100:
    *((_BYTE *)v54 + v51) = 0;
    v57 = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[0] = 0;
    v77 = v52;
    v78 = v57;
    v58 = buf.__pn_.__r_.__value_.__r.__words[0];
    buf.__pn_.__r_.__value_.__r.__words[0] = 0;
    v79 = v58;
    v80 = 0u;
    v81 = 0u;
    v83 = 0u;
    v84 = 0u;
    v82 = 1065353216;
    v85 = 1065353216;
    sub_1D3D860F0((uint64_t)a1, (__int128 *)&__dst);
    a1[128] = 1;
    sub_1D3D85FD8((uint64_t)&__dst);
LABEL_101:
    sub_1D3D8B794((uint64_t)&__p);
LABEL_102:
    sub_1D3D8B7C8((uint64_t)&buf);
    if ((*((_BYTE *)&v72.__pn_.__r_.__value_.__s + 23) & 0x80) == 0)
      return;
    goto LABEL_103;
  }
  *a1 = 0;
  a1[128] = 0;
  if ((v46 & 0x80) == 0)
    return;
LABEL_103:
  operator delete(v72.__pn_.__r_.__value_.__l.__data_);
}

void sub_1D3D88CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,unint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  uint64_t v36;

  MEMORY[0x1D8254C3C](v36, 0x1000C8077774924);
  sub_1D3D8C70C(&a30);
  sub_1D3D8C70C((unint64_t *)&a24);
  if (a36 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_BYTE *sub_1D3D88D90(_BYTE *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, unint64_t *a7, uint64_t a8, uint64_t a9)
{
  _QWORD *v11;
  _QWORD *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  int v19;
  int v20;
  NSObject *v21;
  _BOOL4 v22;
  _BOOL4 v23;
  uint64_t v24;
  const char *v25;
  NSObject *v26;
  const char *v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  const __CFString **v33;
  uint64_t v34;
  const __CFString **v35;
  uint64_t v36;
  NSObject *v37;
  const char *v38;
  int v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  NSObject *v43;
  unsigned int v44;
  NSObject *v45;
  _BYTE *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t *v49;
  const __CFString *v50;
  _BYTE *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  NSObject *v55;
  const __CFString *v56;
  const void *v58;
  CFTypeID v59;
  const __CFDictionary *v60;
  const __CFArray *Value;
  const __CFArray *v62;
  CFTypeID v63;
  CFIndex Count;
  CFIndex v65;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v67;
  CFTypeID v68;
  const __CFString *v69;
  const __CFString *v70;
  CFTypeID v71;
  const __CFString *v72;
  const __CFString *v73;
  CFTypeID v74;
  int v75;
  _BYTE *result;
  uint64_t v77;
  NSObject *v78;
  uint64_t v79;
  uint64_t v80;
  const char *v81;
  unsigned int v82;
  NSObject *v83;
  uint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  NSObject *v88;
  unint64_t v89;
  const char *v90;
  uint64_t v91;
  int v92;
  NSObject *v93;
  uint64_t v94;
  const char *v95;
  const char *v96;
  unsigned int v97;
  uint64_t v98;
  const char *v100;
  const char *v102;
  uint64_t v103;
  int v104;
  NSObject *v105;
  int v106;
  uint64_t v108;
  const char *v109;
  int v110;
  unint64_t v111;
  unint64_t v112;
  int v113;
  _BOOL4 v114;
  uint64_t v115;
  int v116;
  const char *v117;
  unint64_t v118;
  uint64_t v119;
  const char *v120;
  int v121;
  uint64_t v122;
  unsigned int v123;
  NSObject *v124;
  const __CFString *v125;
  uint64_t v126;
  int v127;
  const char *v128;
  uint64_t v129;
  const char *v130;
  uint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  BOOL v136;
  uint64_t v140;
  const __CFString *v142;
  char v143;
  uint64_t v144;
  char v145;
  unint64_t v146;
  uint64_t v147;
  int v148;
  const __CFString *v149;
  char v150;
  const __CFString *v151;
  const char *v152;
  const __CFString *v153;
  char v154;
  unsigned int v155;
  unint64_t v156;
  const __CFString *v157;
  _BYTE v158[24];
  _BYTE *v159;
  _BYTE v160[24];
  _BYTE *v161;
  uint64_t v162;
  _BYTE v163[24];
  _BYTE *v164;
  _BYTE v165[22];
  _BYTE v166[24];
  _BYTE *v167;
  const __CFString *v168;
  uint64_t v169;
  unint64_t *v170;
  CFTypeRef *v171;
  _BYTE buf[32];
  _BYTE *v173;
  uint64_t v174;

  v174 = *MEMORY[0x1E0C80C00];
  v148 = a4;
  v147 = a6;
  v146 = sub_1D3E181F0(a7);
  v11 = operator new(0x28uLL);
  *v11 = &off_1E95AB7E0;
  v11[1] = a2;
  v11[2] = &v148;
  v11[3] = &v147;
  v11[4] = &v146;
  v161 = v11;
  v159 = 0;
  v12 = operator new(0x28uLL);
  v12[1] = a2;
  *v12 = &off_1E95AB838;
  v12[2] = &v148;
  v12[3] = &v147;
  v12[4] = &v146;
  v159 = v12;
  v162 = a9;
  v13 = (char *)operator new(0x28uLL);
  *(_QWORD *)v13 = &off_1E95AB838;
  v14 = *(_OWORD *)(v12 + 3);
  *(_OWORD *)(v13 + 8) = *(_OWORD *)(v12 + 1);
  *(_OWORD *)(v13 + 24) = v14;
  v164 = v13;
  if (*(_BYTE *)(a9 + 8))
  {
    *(_QWORD *)buf = *(_QWORD *)a9;
    sub_1D3D8B7FC((uint64_t)v11, (os_signpost_id_t *)buf);
    v12 = v159;
    v15 = a8;
    if (v159 == v158)
    {
      v16 = 4;
      v12 = v158;
    }
    else
    {
      if (!v159)
        goto LABEL_8;
      v16 = 5;
    }
  }
  else
  {
    v16 = 5;
    v15 = a8;
  }
  (*(void (**)(_QWORD *))(*v12 + 8 * v16))(v12);
LABEL_8:
  v17 = v161;
  if (v161 == v160)
  {
    v18 = 4;
    v17 = v160;
  }
  else
  {
    if (!v161)
      goto LABEL_13;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_13:
  v19 = v146;
  if ((v146 & 0x1000000) != 0)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v21 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
      goto LABEL_27;
    *(_WORD *)buf = 0;
    v25 = "_ProhibitsANE is explicitly specified, skipping...";
    goto LABEL_242;
  }
  if (qword_1EDB89FB8[0] != -1)
    dispatch_once_f(qword_1EDB89FB8, 0, (dispatch_function_t)sub_1D3E0ECD4);
  v20 = byte_1EDB89F50;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v21 = qword_1EDB89F98;
  v22 = os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG);
  if (!v20)
  {
    if (!v22)
    {
LABEL_27:
      v24 = 0;
      v23 = 1;
      goto LABEL_28;
    }
    *(_WORD *)buf = 0;
    v25 = "Device does not have ANE, skipping...";
LABEL_242:
    _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, v25, buf, 2u);
    goto LABEL_27;
  }
  if (v22)
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, "Device has ANE.", buf, 2u);
  }
  v23 = 0;
  v24 = 4;
LABEL_28:
  if ((v19 & 1) != 0)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v26 = qword_1EDB89F98;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_INFO))
      goto LABEL_51;
    *(_WORD *)buf = 0;
    v27 = "UsesANEOnly is explicitly specified, skipping all other engines.";
    goto LABEL_49;
  }
  if ((v19 & 0x2000000) != 0)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v26 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_DEBUG, "_ProhibitsGPU is explicitly specified, skipping...", buf, 2u);
    }
  }
  else
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v26 = qword_1EDB89F98;
    if ((v19 & 2) != 0 && os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_INFO, "MRCContextInferenceProhibitsIntegratedGPU is obsolete, please use MRCContextOptionPreferredMetalDevice instead.", buf, 2u);
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_DEBUG, "_ProhibitsGPU is not explicitly specified.", buf, 2u);
    }
    v24 |= 2uLL;
  }
  if ((v19 & 4) != 0)
  {
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_DEBUG, "AllowsCPU is explicitly specified.", buf, 2u);
    }
    v24 |= 1uLL;
    goto LABEL_58;
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    v27 = "AllowsCPU is not explicitly specified, skipping...";
LABEL_49:
    _os_log_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_INFO, v27, buf, 2u);
  }
  v23 = v24 == 0;
  if (qword_1EDB89F90 != -1)
  {
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v26 = qword_1EDB89F98;
    if (!v24)
      goto LABEL_52;
    goto LABEL_58;
  }
LABEL_51:
  v26 = qword_1EDB89F98;
  if (v23)
  {
LABEL_52:
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: none allowed compute device types", buf, 2u);
    }
    *(_QWORD *)buf = -6003;
    v168 = CFSTR("None allowed compute device typess.");
    sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)buf, (CFTypeRef *)&v168);
    *a1 = 0;
    a1[8] = 0;
    goto LABEL_213;
  }
LABEL_58:
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134349312;
    *(_QWORD *)&buf[4] = v146;
    *(_WORD *)&buf[12] = 2050;
    *(_QWORD *)&buf[14] = v24;
    _os_log_debug_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_DEBUG, "E5RTNetwork: inference flags %{public}lx mapped to E5RT compute device types %{public}llx", buf, 0x16u);
  }
  LOBYTE(v144) = 0;
  v145 = 0;
  v28 = v148;
  if (v148 == 1)
  {
    v156 = v146;
    v168 = (const __CFString *)&off_1E95AB730;
    v169 = a2;
    v170 = &v156;
    v171 = (CFTypeRef *)&v168;
    *(_QWORD *)v166 = &off_1E95AB788;
    *(_QWORD *)&v166[8] = a2;
    *(_QWORD *)&v166[16] = &v156;
    v167 = v166;
    v173 = &buf[8];
    *(_QWORD *)buf = a9;
    *(_QWORD *)&buf[8] = &off_1E95AB788;
    *(_OWORD *)&buf[16] = *(_OWORD *)&v166[8];
    if (!*(_BYTE *)(a9 + 8)
      || (*(_QWORD *)v165 = *(_QWORD *)a9,
          sub_1D3D8BC7C((uint64_t)&v168, (os_signpost_id_t *)v165),
          v31 = v167,
          v167 == v166))
    {
      v32 = 4;
      v31 = v166;
    }
    else
    {
      if (!v167)
        goto LABEL_80;
      v32 = 5;
    }
    (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_80:
    v35 = (const __CFString **)v171;
    if (v171 == (CFTypeRef *)&v168)
    {
      v36 = 4;
      v35 = &v168;
    }
    else
    {
      if (!v171)
        goto LABEL_113;
      v36 = 5;
    }
    (*((void (**)(void))&(*v35)->isa + v36))();
LABEL_113:
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v43 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0)
        v80 = a2;
      else
        v80 = *(_QWORD *)a2;
      *(_DWORD *)v165 = 136446210;
      *(_QWORD *)&v165[4] = v80;
      _os_log_debug_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to perform on-demand compilation for: %{public}s", v165, 0xCu);
    }
    if (qword_1EDB895B0 != -1)
      dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
    v151 = 0;
    v44 = off_1EDB894C8(&v151);
    v155 = v44;
    if (v44)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v45 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        v85 = sub_1D3D82AEC(&v155);
        *(_DWORD *)v165 = 67240450;
        *(_DWORD *)&v165[4] = v44;
        *(_WORD *)&v165[8] = 2082;
        *(_QWORD *)&v165[10] = v85;
        _os_log_error_impl(&dword_1D3D6B000, v45, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_create failed: (%{public}d): %{public}s", v165, 0x12u);
      }
      LOBYTE(v153) = 0;
      v154 = 0;
      goto LABEL_124;
    }
    *(_QWORD *)v165 = 0;
    v153 = v151;
    v154 = 1;
    sub_1D3D85130(v165);
    if (!v154)
    {
LABEL_124:
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v165 = 0;
        _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT compiler options", v165, 2u);
      }
      *(_QWORD *)v165 = -6003;
      v151 = CFSTR("Unable to create E5RT compiler options.");
      sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v151);
LABEL_127:
      if (!*(_BYTE *)(v15 + 52))
        *(_BYTE *)(v15 + 52) = 1;
      *(_DWORD *)(v15 + 48) = v44;
LABEL_130:
      LOBYTE(v142) = 0;
      v143 = 0;
      goto LABEL_131;
    }
    if (qword_1EDB895B0 != -1)
      dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
    v44 = off_1EDB894D8(v153, v24);
    v155 = v44;
    if (v44)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v48 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        v96 = sub_1D3D82AEC(&v155);
        *(_DWORD *)v165 = 67240450;
        *(_DWORD *)&v165[4] = v44;
        *(_WORD *)&v165[8] = 2082;
        *(_QWORD *)&v165[10] = v96;
        _os_log_error_impl(&dword_1D3D6B000, v48, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_compute_device_types_mask failed: (%{public}d): %{public}s", v165, 0x12u);
      }
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v165 = 134349056;
        *(_QWORD *)&v165[4] = v24;
        _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set compute device types %{public}llx", v165, 0xCu);
      }
      *(_QWORD *)v165 = -6003;
      v151 = CFSTR("Unable to set compute device types.");
      sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v151);
      goto LABEL_127;
    }
    if (a3 == 1)
    {
      v151 = (const __CFString *)"*";
      if (qword_1EDB895B0 != -1)
        dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
      v44 = off_1EDB894E0(v153, &v151, 1);
      v155 = v44;
      if (v44)
      {
        if (qword_1EDB89F90 != -1)
          dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
        v78 = qword_1EDB89F98;
        if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
        {
          v102 = sub_1D3D82AEC(&v155);
          *(_DWORD *)v165 = 67240450;
          *(_DWORD *)&v165[4] = v44;
          *(_WORD *)&v165[8] = 2082;
          *(_QWORD *)&v165[10] = v102;
          _os_log_error_impl(&dword_1D3D6B000, v78, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_mil_entry_points failed: (%{public}d): %{public}s", v165, 0x12u);
        }
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v165 = 0;
          _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set MIL entry points", v165, 2u);
        }
        *(_QWORD *)v165 = -6003;
        v151 = CFSTR("Unable to set MIL entry points.");
        sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v151);
        goto LABEL_127;
      }
      v151 = (const __CFString *)"bnns";
      v152 = "classic_cpu";
      *(_QWORD *)v165 = &v151;
      *(_QWORD *)&v165[8] = 2;
      if (sub_1D3D84FF0(&v153, v165, &v155))
      {
        if (qword_1EDB895B0 != -1)
          dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
        v44 = off_1EDB894F0(v153, 1);
        v155 = v44;
        if (v44)
        {
          if (qword_1EDB89F90 != -1)
            dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
          v88 = qword_1EDB89F98;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
          {
            v128 = sub_1D3D82AEC(&v155);
            *(_DWORD *)v165 = 67240450;
            *(_DWORD *)&v165[4] = v44;
            *(_WORD *)&v165[8] = 2082;
            *(_QWORD *)&v165[10] = v128;
            _os_log_error_impl(&dword_1D3D6B000, v88, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_force_classic_aot_old_hw failed: (%{public}d): %{public}s", v165, 0x12u);
          }
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v165 = 0;
            _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set the forceClassicAotOldHw flag.", v165, 2u);
          }
          *(_QWORD *)v165 = -6003;
          v151 = CFSTR("Unable to set the forceClassicAotOldHw flag.");
          sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v151);
          goto LABEL_127;
        }
LABEL_244:
        if (qword_1EDB895B0 != -1)
          dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
        v149 = 0;
        v82 = off_1EDB89500(&v149);
        v155 = v82;
        if (v82)
        {
          if (qword_1EDB89F90 != -1)
            dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
          v83 = qword_1EDB89F98;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
          {
            v117 = sub_1D3D82AEC(&v155);
            *(_DWORD *)v165 = 67240450;
            *(_DWORD *)&v165[4] = v82;
            *(_WORD *)&v165[8] = 2082;
            *(_QWORD *)&v165[10] = v117;
            _os_log_error_impl(&dword_1D3D6B000, v83, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_create failed: (%{public}d): %{public}s", v165, 0x12u);
          }
          LOBYTE(v151) = 0;
          LOBYTE(v152) = 0;
          goto LABEL_252;
        }
        *(_QWORD *)v165 = 0;
        v151 = v149;
        LOBYTE(v152) = 1;
        sub_1D3D852C8(v165);
        if (!(_BYTE)v152)
        {
LABEL_252:
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v165 = 0;
            _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT compiler", v165, 2u);
          }
          *(_QWORD *)v165 = -6003;
          v149 = CFSTR("Unable to create E5RT compiler.");
          sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v149);
          if (!*(_BYTE *)(v15 + 52))
            *(_BYTE *)(v15 + 52) = 1;
          *(_DWORD *)(v15 + 48) = v82;
LABEL_257:
          LOBYTE(v142) = 0;
          v143 = 0;
LABEL_258:
          sub_1D3D8BD84((uint64_t)&v151);
LABEL_131:
          sub_1D3D8BDB8((uint64_t)&v153);
          v46 = v173;
          if (*(_BYTE *)(*(_QWORD *)buf + 8))
          {
            if (!v173)
              goto LABEL_150;
            *(_QWORD *)v165 = **(_QWORD **)buf;
            (*(void (**)(void))(*(_QWORD *)v173 + 48))();
            v46 = v173;
          }
          if (v46 == &buf[8])
          {
            v47 = 4;
            v46 = &buf[8];
            goto LABEL_149;
          }
          if (v46)
          {
            v47 = 5;
LABEL_149:
            (*(void (**)(void))(*(_QWORD *)v46 + 8 * v47))();
          }
LABEL_150:
          sub_1D3D8B928(&v144, (uint64_t *)&v142);
          v49 = (uint64_t *)&v142;
          goto LABEL_165;
        }
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          if (qword_1EDB895B0 != -1)
            dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
          LOBYTE(v157) = 0;
          if (*(char *)(a2 + 23) >= 0)
            v91 = a2;
          else
            v91 = *(_QWORD *)a2;
          v92 = off_1EDB89518(v151, v91, v153, &v157);
          LODWORD(v149) = v92;
          if (!v92)
          {
            v113 = v157;
            v114 = os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG);
            if (v113)
            {
              if (!v114)
                goto LABEL_391;
              if (*(char *)(a2 + 23) >= 0)
                v115 = a2;
              else
                v115 = *(_QWORD *)a2;
              *(_DWORD *)v165 = 136446210;
              *(_QWORD *)&v165[4] = v115;
              v95 = "E5RTNetwork: a new compilation is required for network: %{public}s";
            }
            else
            {
              if (!v114)
                goto LABEL_391;
              if (*(char *)(a2 + 23) >= 0)
                v119 = a2;
              else
                v119 = *(_QWORD *)a2;
              *(_DWORD *)v165 = 136446210;
              *(_QWORD *)&v165[4] = v119;
              v95 = "E5RTNetwork: a new compilation is not required for network: %{public}s";
            }
            goto LABEL_390;
          }
          if (qword_1EDB89F90 != -1)
            dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
          v93 = qword_1EDB89F98;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
          {
            v130 = sub_1D3D82AEC((unsigned int *)&v149);
            *(_DWORD *)v165 = 67240450;
            *(_DWORD *)&v165[4] = v92;
            *(_WORD *)&v165[8] = 2082;
            *(_QWORD *)&v165[10] = v130;
            _os_log_error_impl(&dword_1D3D6B000, v93, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_is_new_compile_required failed: (%{public}d): %{public}s", v165, 0x12u);
          }
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            if (*(char *)(a2 + 23) >= 0)
              v94 = a2;
            else
              v94 = *(_QWORD *)a2;
            *(_DWORD *)v165 = 136446210;
            *(_QWORD *)&v165[4] = v94;
            v95 = "E5RTNetwork: unable to determine whether a new compilation is required for network: %{public}s";
LABEL_390:
            _os_log_debug_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_DEBUG, v95, v165, 0xCu);
          }
        }
LABEL_391:
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          if (*(char *)(a2 + 23) >= 0)
            v126 = a2;
          else
            v126 = *(_QWORD *)a2;
          *(_DWORD *)v165 = 136446210;
          *(_QWORD *)&v165[4] = v126;
          _os_log_debug_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to compile network: %{public}s", v165, 0xCu);
        }
        if (*(char *)(a2 + 23) >= 0)
          v120 = (const char *)a2;
        else
          v120 = *(const char **)a2;
        if (access(v120, 4))
        {
          v121 = *__error();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            if (*(char *)(a2 + 23) >= 0)
              v129 = a2;
            else
              v129 = *(_QWORD *)a2;
            *(_DWORD *)v165 = 136446466;
            *(_QWORD *)&v165[4] = v129;
            *(_WORD *)&v165[12] = 1026;
            *(_DWORD *)&v165[14] = v121;
            _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: %{public}s is not readable, reason: %{public, errno}d", v165, 0x12u);
          }
          *(_QWORD *)v165 = -6003;
          v149 = CFSTR("Unable to compile network.");
          sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v149);
          sub_1D3DF5198(v15, v121);
          sub_1D3DF5310(v15, (uint64_t *)a2);
          goto LABEL_257;
        }
        if (qword_1EDB895B0 != -1)
          dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
        v157 = 0;
        if (*(char *)(a2 + 23) >= 0)
          v122 = a2;
        else
          v122 = *(_QWORD *)a2;
        v123 = off_1EDB89510(v151, v122, v153, &v157);
        v155 = v123;
        if (v123)
        {
          if (qword_1EDB89F90 != -1)
            dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
          v124 = qword_1EDB89F98;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
          {
            v132 = sub_1D3D82AEC(&v155);
            *(_DWORD *)v165 = 67240450;
            *(_DWORD *)&v165[4] = v123;
            *(_WORD *)&v165[8] = 2082;
            *(_QWORD *)&v165[10] = v132;
            _os_log_error_impl(&dword_1D3D6B000, v124, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_compile failed: (%{public}d): %{public}s", v165, 0x12u);
          }
          LOBYTE(v149) = 0;
          v150 = 0;
          goto LABEL_409;
        }
        *(_QWORD *)v165 = 0;
        v149 = v157;
        v150 = 1;
        sub_1D3D84E58(v165);
        if (!v150)
        {
LABEL_409:
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            if (*(char *)(a2 + 23) >= 0)
              v131 = a2;
            else
              v131 = *(_QWORD *)a2;
            *(_DWORD *)v165 = 136446210;
            *(_QWORD *)&v165[4] = v131;
            _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to compile network: %{public}s", v165, 0xCu);
          }
          *(_QWORD *)v165 = -6003;
          v157 = CFSTR("Unable to compile network.");
          sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v157);
          if (!*(_BYTE *)(v15 + 52))
            *(_BYTE *)(v15 + 52) = 1;
          *(_DWORD *)(v15 + 48) = v123;
          if (v123 == 11)
            *(_QWORD *)v15 = -6001;
          LOBYTE(v142) = 0;
          v143 = 0;
          goto LABEL_419;
        }
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          if (*(char *)(a2 + 23) >= 0)
            v134 = a2;
          else
            v134 = *(_QWORD *)a2;
          *(_DWORD *)v165 = 134349314;
          *(_QWORD *)&v165[4] = v149;
          *(_WORD *)&v165[12] = 2082;
          *(_QWORD *)&v165[14] = v134;
          _os_log_debug_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_DEBUG, "E5RTNetwork: compiled as library %{public}p: %{public}s", v165, 0x16u);
          LOBYTE(v142) = 0;
          v143 = 0;
          if (!v150)
            goto LABEL_419;
        }
        else
        {
          v143 = 0;
        }
        v125 = v149;
        v149 = 0;
        v142 = v125;
        v143 = 1;
LABEL_419:
        sub_1D3D8B9A4((uint64_t)&v149);
        goto LABEL_258;
      }
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v165 = 0;
        _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set preferred CPU backends", v165, 2u);
      }
    }
    else
    {
      v151 = (const __CFString *)"classic_cpu";
      *(_QWORD *)v165 = &v151;
      *(_QWORD *)&v165[8] = 1;
      if (sub_1D3D84FF0(&v153, v165, &v155))
        goto LABEL_244;
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v165 = 0;
        _os_log_error_impl(&dword_1D3D6B000, v43, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set preferred CPU backends", v165, 2u);
      }
    }
    *(_QWORD *)v165 = -6003;
    v151 = CFSTR("Unable to set preferred CPU backends.");
    sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v151);
    v97 = v155;
    if (!*(_BYTE *)(v15 + 52))
      *(_BYTE *)(v15 + 52) = 1;
    *(_DWORD *)(v15 + 48) = v97;
    goto LABEL_130;
  }
  if (v148)
  {
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&buf[4] = v28;
      _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unrecognized compilation flavor: %{public}d", buf, 8u);
    }
    *(_QWORD *)buf = -6003;
    v168 = CFSTR("Unrecognized compilation flavor.");
    sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)buf, (CFTypeRef *)&v168);
    goto LABEL_174;
  }
  v168 = (const __CFString *)&off_1E95AC098;
  v169 = a2;
  v171 = (CFTypeRef *)&v168;
  *(_QWORD *)buf = a9;
  *(_QWORD *)v166 = &off_1E95AC0F0;
  *(_QWORD *)&v166[8] = a2;
  v167 = v166;
  *(_QWORD *)&buf[8] = &off_1E95AC0F0;
  *(_QWORD *)&buf[16] = a2;
  v173 = &buf[8];
  if (!*(_BYTE *)(a9 + 8)
    || (*(_QWORD *)v165 = *(_QWORD *)a9,
        sub_1D3D8C05C((uint64_t)&v168, (os_signpost_id_t *)v165),
        v29 = v167,
        v167 == v166))
  {
    v30 = 4;
    v29 = v166;
  }
  else
  {
    if (!v167)
      goto LABEL_75;
    v30 = 5;
  }
  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_75:
  v33 = (const __CFString **)v171;
  if (v171 == (CFTypeRef *)&v168)
  {
    v34 = 4;
    v33 = &v168;
  }
  else
  {
    if (!v171)
      goto LABEL_85;
    v34 = 5;
  }
  (*((void (**)(void))&(*v33)->isa + v34))();
LABEL_85:
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v37 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
  {
    if (*(char *)(a2 + 23) >= 0)
      v79 = a2;
    else
      v79 = *(_QWORD *)a2;
    *(_DWORD *)v165 = 136446210;
    *(_QWORD *)&v165[4] = v79;
    _os_log_debug_impl(&dword_1D3D6B000, v37, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to load precompiled library: %{public}s", v165, 0xCu);
  }
  if (*(char *)(a2 + 23) >= 0)
    v38 = (const char *)a2;
  else
    v38 = *(const char **)a2;
  if (!access(v38, 4))
  {
    if (qword_1EDB895B0 != -1)
      dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
    v149 = 0;
    if (*(char *)(a2 + 23) >= 0)
      v40 = a2;
    else
      v40 = *(_QWORD *)a2;
    v41 = off_1EDB894A8(&v149, v40);
    LODWORD(v142) = v41;
    if (v41)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v42 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        v90 = sub_1D3D82AEC((unsigned int *)&v142);
        *(_DWORD *)v165 = 67240450;
        *(_DWORD *)&v165[4] = v41;
        *(_WORD *)&v165[8] = 2082;
        *(_QWORD *)&v165[10] = v90;
        _os_log_error_impl(&dword_1D3D6B000, v42, OS_LOG_TYPE_ERROR, "e5rt_program_library_create failed: (%{public}d): %{public}s", v165, 0x12u);
      }
      LOBYTE(v153) = 0;
      v154 = 0;
      goto LABEL_105;
    }
    *(_QWORD *)v165 = 0;
    v153 = v149;
    v154 = 1;
    sub_1D3D84E58(v165);
    if (!v154)
    {
LABEL_105:
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0)
          v87 = a2;
        else
          v87 = *(_QWORD *)a2;
        *(_DWORD *)v165 = 136446210;
        *(_QWORD *)&v165[4] = v87;
        _os_log_error_impl(&dword_1D3D6B000, v37, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to load precompiled library: %{public}s", v165, 0xCu);
      }
      *(_QWORD *)v165 = -6003;
      v149 = CFSTR("Unable to load precompiled library.");
      sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v149);
      if (!*(_BYTE *)(v15 + 52))
        *(_BYTE *)(v15 + 52) = 1;
      *(_DWORD *)(v15 + 48) = v41;
      if (v41 == 8)
        *(_QWORD *)v15 = -6001;
      LOBYTE(v151) = 0;
      LOBYTE(v152) = 0;
      goto LABEL_155;
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0)
        v98 = a2;
      else
        v98 = *(_QWORD *)a2;
      *(_DWORD *)v165 = 134349314;
      *(_QWORD *)&v165[4] = v153;
      *(_WORD *)&v165[12] = 2082;
      *(_QWORD *)&v165[14] = v98;
      _os_log_debug_impl(&dword_1D3D6B000, v37, OS_LOG_TYPE_DEBUG, "E5RTNetwork: loaded precompiled library %{public}p: %{public}s", v165, 0x16u);
      LOBYTE(v151) = 0;
      LOBYTE(v152) = 0;
      if (!v154)
        goto LABEL_155;
    }
    else
    {
      LOBYTE(v152) = 0;
    }
    v50 = v153;
    v153 = 0;
    v151 = v50;
    LOBYTE(v152) = 1;
LABEL_155:
    sub_1D3D8B9A4((uint64_t)&v153);
    goto LABEL_156;
  }
  v39 = *__error();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0)
      v84 = a2;
    else
      v84 = *(_QWORD *)a2;
    *(_DWORD *)v165 = 136446466;
    *(_QWORD *)&v165[4] = v84;
    *(_WORD *)&v165[12] = 1026;
    *(_DWORD *)&v165[14] = v39;
    _os_log_error_impl(&dword_1D3D6B000, v37, OS_LOG_TYPE_ERROR, "E5RTNetwork: %{public}s is not readable, reason: %{public, errno}d", v165, 0x12u);
  }
  *(_QWORD *)v165 = -6003;
  v153 = CFSTR("Unable to load precompiled library.");
  sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v153);
  sub_1D3DF5198(v15, v39);
  sub_1D3DF5310(v15, (uint64_t *)a2);
  LOBYTE(v151) = 0;
  LOBYTE(v152) = 0;
LABEL_156:
  v51 = v173;
  if (*(_BYTE *)(*(_QWORD *)buf + 8))
  {
    if (!v173)
      goto LABEL_164;
    *(_QWORD *)v165 = **(_QWORD **)buf;
    (*(void (**)(void))(*(_QWORD *)v173 + 48))();
    v51 = v173;
  }
  if (v51 == &buf[8])
  {
    v52 = 4;
    v51 = &buf[8];
    goto LABEL_163;
  }
  if (v51)
  {
    v52 = 5;
LABEL_163:
    (*(void (**)(void))(*(_QWORD *)v51 + 8 * v52))();
  }
LABEL_164:
  sub_1D3D8B928(&v144, (uint64_t *)&v151);
  v49 = (uint64_t *)&v151;
LABEL_165:
  sub_1D3D8B9A4((uint64_t)v49);
  if (!v145)
  {
LABEL_174:
    *a1 = 0;
    a1[8] = 0;
    goto LABEL_212;
  }
  v53 = v147;
  v168 = 0;
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  v54 = off_1EDB894B8(v144, v53, &v168);
  LODWORD(v142) = v54;
  if (v54)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v55 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      v81 = sub_1D3D82AEC((unsigned int *)&v142);
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v54;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v81;
      _os_log_error_impl(&dword_1D3D6B000, v55, OS_LOG_TYPE_ERROR, "e5rt_program_library_get_function_metadata failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    v56 = 0;
  }
  else
  {
    v56 = v168;
  }
  v153 = v56;
  if (!atomic_load((unint64_t *)&v153))
  {
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = v147;
      _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to get metadata for function: %{public}s", buf, 0xCu);
    }
    *(_QWORD *)buf = -6003;
    v168 = CFSTR("Unable to get function metadata.");
    sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)buf, (CFTypeRef *)&v168);
    v75 = (int)v142;
    if (!*(_BYTE *)(v15 + 52))
      *(_BYTE *)(v15 + 52) = 1;
    *(_DWORD *)(v15 + 48) = v75;
    goto LABEL_210;
  }
  v140 = v147;
  v58 = (const void *)atomic_load((unint64_t *)&v153);
  v59 = CFGetTypeID(v58);
  if (v59 != CFDictionaryGetTypeID())
  {
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v86 = atomic_load((unint64_t *)&v153);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = v140;
      *(_WORD *)&buf[12] = 2114;
      *(_QWORD *)&buf[14] = v86;
      _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
    }
    goto LABEL_209;
  }
  v60 = (const __CFDictionary *)atomic_load((unint64_t *)&v153);
  Value = (const __CFArray *)CFDictionaryGetValue(v60, CFSTR("Ops"));
  v62 = Value;
  if (!Value || (v63 = CFGetTypeID(Value), v63 != CFArrayGetTypeID()))
  {
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v89 = atomic_load((unint64_t *)&v153);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = v140;
      *(_WORD *)&buf[12] = 2114;
      *(_QWORD *)&buf[14] = v89;
      _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
    }
LABEL_209:
    *(_QWORD *)buf = -6003;
    v168 = CFSTR("Invalid E5RT function metadata.");
    sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)buf, (CFTypeRef *)&v168);
LABEL_210:
    *a1 = 0;
    a1[8] = 0;
    goto LABEL_211;
  }
  Count = CFArrayGetCount(v62);
  if (Count < 1)
    goto LABEL_330;
  v136 = 0;
  v65 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v62, v65);
    v67 = ValueAtIndex;
    if (!ValueAtIndex || (v68 = CFGetTypeID(ValueAtIndex), v68 != CFDictionaryGetTypeID()))
    {
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v111 = atomic_load((unint64_t *)&v153);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = v140;
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v111;
        _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
      }
      goto LABEL_289;
    }
    v69 = (const __CFString *)CFDictionaryGetValue(v67, CFSTR("OpCode"));
    v70 = v69;
    if (!v69 || (v71 = CFGetTypeID(v69), v71 != CFStringGetTypeID()))
    {
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v112 = atomic_load((unint64_t *)&v153);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = v140;
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v112;
        _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
      }
      goto LABEL_289;
    }
    if (CFStringCompare(v70, CFSTR("Cast"), 0) == kCFCompareEqualTo)
      goto LABEL_197;
    v72 = (const __CFString *)CFDictionaryGetValue(v67, CFSTR("ComputeBackend"));
    v73 = v72;
    if (!v72 || (v74 = CFGetTypeID(v72), v74 != CFStringGetTypeID()))
    {
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v118 = atomic_load((unint64_t *)&v153);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = v140;
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v118;
        _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
      }
LABEL_289:
      *(_QWORD *)buf = -6003;
      v168 = CFSTR("Invalid E5RT function metadata.");
      sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)buf, (CFTypeRef *)&v168);
      goto LABEL_329;
    }
    if (CFStringCompare(v73, CFSTR("ANE"), 0) == kCFCompareEqualTo)
    {
      if ((v24 & 4) != 0)
        goto LABEL_197;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        goto LABEL_326;
      *(_WORD *)buf = 0;
      v100 = "E5RT compute device type ANE is not allowed.";
LABEL_325:
      _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, v100, buf, 2u);
      goto LABEL_326;
    }
    if (CFStringCompare(v73, CFSTR("GPU"), 0) == kCFCompareEqualTo)
    {
      if ((v24 & 2) != 0)
        goto LABEL_197;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        goto LABEL_326;
      *(_WORD *)buf = 0;
      v100 = "E5RT compute device type GPU is not allowed.";
      goto LABEL_325;
    }
    if (CFStringCompare(v73, CFSTR("CPU"), 0))
      goto LABEL_326;
    if ((v24 & 1) == 0)
      break;
LABEL_197:
    v136 = ++v65 >= Count;
    if (Count == v65)
      goto LABEL_330;
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    v100 = "E5RT compute device type CPU is not allowed.";
    goto LABEL_325;
  }
LABEL_326:
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = v73;
    _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "Unexpected, unsupported, or disallowed E5RT compute backend: %{public}@", buf, 0xCu);
  }
  *(_QWORD *)buf = -6001;
  v168 = CFSTR("Unexpected, unsupported, or disallowed E5RT compute backend.");
  sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)buf, (CFTypeRef *)&v168);
LABEL_329:
  if (!v136)
    goto LABEL_210;
LABEL_330:
  v103 = v147;
  if (qword_1EDB895B0 != -1)
    dispatch_once_f(&qword_1EDB895B0, 0, (dispatch_function_t)sub_1D3D828B0);
  *(_QWORD *)v166 = 0;
  v104 = off_1EDB894C0(v144, v103, v166);
  LODWORD(v142) = v104;
  if (!v104)
  {
    *(_QWORD *)buf = 0;
    v168 = *(const __CFString **)v166;
    LOBYTE(v169) = 1;
    sub_1D3D84CC0(buf);
    if (!(_BYTE)v169)
      goto LABEL_338;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134349314;
      *(_QWORD *)&buf[4] = v168;
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v147;
      _os_log_debug_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_DEBUG, "E5RTNetwork: found function %{public}p: %{public}s", buf, 0x16u);
    }
    sub_1D3D85830(buf, &v168, (unsigned int *)&v142);
    if (buf[8])
    {
      if (sub_1D3D85460(buf, a5, (unsigned int *)&v142))
      {
        if (sub_1D3D855A0(buf, (unsigned int *)&v142))
        {
          if ((v146 & 0x2000000) != 0)
          {
LABEL_357:
            sub_1D3D85B38(v166, buf, (unsigned int *)&v142);
            if (v166[8])
            {
              v108 = *(_QWORD *)v166;
              *(_QWORD *)v166 = 0;
              *(_QWORD *)a1 = v108;
              a1[8] = 1;
            }
            else
            {
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v165 = 0;
                _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT execution stream operation", v165, 2u);
              }
              *(_QWORD *)v165 = -6003;
              v151 = CFSTR("Unable to create E5RT execution stream operation.");
              sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v151);
              v116 = (int)v142;
              if (!*(_BYTE *)(v15 + 52))
                *(_BYTE *)(v15 + 52) = 1;
              *(_DWORD *)(v15 + 48) = v116;
              *a1 = 0;
              a1[8] = 0;
            }
            sub_1D3D8B7C8((uint64_t)v166);
LABEL_371:
            sub_1D3D8BA44((uint64_t)buf);
            goto LABEL_372;
          }
          sub_1D3E18620((uint64_t *)&v151, (uint64_t)a7);
          if (atomic_load((unint64_t *)&v151))
          {
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              v133 = atomic_load((unint64_t *)&v151);
              *(_DWORD *)v166 = 138543362;
              *(_QWORD *)&v166[4] = v133;
              _os_log_debug_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_DEBUG, "E5RTNetwork: effectively preferred Metal device: %{public}@", v166, 0xCu);
            }
            sub_1D3E17E2C(v166, (unint64_t *)&v151, (unsigned int *)&v142);
            if (v166[8])
            {
              *(_QWORD *)v165 = v166;
              v165[8] = 1;
              if (sub_1D3D856DC(buf, (uint64_t **)v165, (unsigned int *)&v142))
              {
                sub_1D3D8B9D8((uint64_t)v166);
                goto LABEL_356;
              }
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v165 = 0;
                _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set overridden-compute-GPU-device", v165, 2u);
              }
              *(_QWORD *)v165 = -6003;
              v149 = CFSTR("Unable to set overridden-compute-GPU-device.");
              sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v149);
            }
            else
            {
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                v135 = atomic_load((unint64_t *)&v151);
                *(_DWORD *)v165 = 138543362;
                *(_QWORD *)&v165[4] = v135;
                _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT compute GPU device: %{public}@", v165, 0xCu);
              }
              *(_QWORD *)v165 = -6003;
              v149 = CFSTR("Unable to create E5RT compute GPU device.");
              sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v165, (CFTypeRef *)&v149);
            }
            v127 = (int)v142;
            if (!*(_BYTE *)(v15 + 52))
              *(_BYTE *)(v15 + 52) = 1;
            *(_DWORD *)(v15 + 48) = v127;
            *a1 = 0;
            a1[8] = 0;
            sub_1D3D8B9D8((uint64_t)v166);
            sub_1D3D8BA0C((unint64_t *)&v151);
            goto LABEL_371;
          }
LABEL_356:
          sub_1D3D8BA0C((unint64_t *)&v151);
          goto LABEL_357;
        }
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v166 = 0;
          _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set allocates-intermediate-buffers", v166, 2u);
        }
        *(_QWORD *)v166 = -6003;
        *(_QWORD *)v165 = CFSTR("Unable to set allocates-intermediate-buffers.");
        sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v166, (CFTypeRef *)v165);
      }
      else
      {
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v166 = 0;
          _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set operation name", v166, 2u);
        }
        *(_QWORD *)v166 = -6003;
        *(_QWORD *)v165 = CFSTR("Unable to set operation name.");
        sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v166, (CFTypeRef *)v165);
      }
    }
    else
    {
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v166 = 0;
        _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT precompiled-compute-op-create options", v166, 2u);
      }
      *(_QWORD *)v166 = -6003;
      *(_QWORD *)v165 = CFSTR("Unable to create E5RT precompiled-compute-op-create options.");
      sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)v166, (CFTypeRef *)v165);
    }
    v110 = (int)v142;
    if (!*(_BYTE *)(v15 + 52))
      *(_BYTE *)(v15 + 52) = 1;
    *(_DWORD *)(v15 + 48) = v110;
    *a1 = 0;
    a1[8] = 0;
    goto LABEL_371;
  }
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  v105 = qword_1EDB89F98;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
  {
    v109 = sub_1D3D82AEC((unsigned int *)&v142);
    *(_DWORD *)buf = 67240450;
    *(_DWORD *)&buf[4] = v104;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v109;
    _os_log_error_impl(&dword_1D3D6B000, v105, OS_LOG_TYPE_ERROR, "e5rt_program_library_retain_program_function failed: (%{public}d): %{public}s", buf, 0x12u);
  }
  LOBYTE(v168) = 0;
  LOBYTE(v169) = 0;
LABEL_338:
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v147;
    _os_log_error_impl(&dword_1D3D6B000, v26, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to find function: %{public}s", buf, 0xCu);
  }
  *(_QWORD *)buf = -6003;
  *(_QWORD *)v166 = CFSTR("Unable to find function.");
  sub_1D3D73E0C((unint64_t *)v15, (uint64_t *)buf, (CFTypeRef *)v166);
  v106 = (int)v142;
  if (!*(_BYTE *)(v15 + 52))
    *(_BYTE *)(v15 + 52) = 1;
  *(_DWORD *)(v15 + 48) = v106;
  *a1 = 0;
  a1[8] = 0;
LABEL_372:
  sub_1D3D8BA78((uint64_t)&v168);
LABEL_211:
  sub_1D3D8BAAC((unint64_t *)&v153);
LABEL_212:
  sub_1D3D8B9A4((uint64_t)&v144);
LABEL_213:
  result = v164;
  if (*(_BYTE *)(v162 + 8))
  {
    if (v164)
    {
      *(_QWORD *)buf = *(_QWORD *)v162;
      (*(void (**)(void))(*(_QWORD *)v164 + 48))();
      result = v164;
      goto LABEL_216;
    }
  }
  else
  {
LABEL_216:
    if (result == v163)
    {
      v77 = 4;
      result = v163;
    }
    else
    {
      if (!result)
        return result;
      v77 = 5;
    }
    return (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v77))();
  }
  return result;
}

void sub_1D3D8B5D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,unint64_t a23,uint64_t a24,unint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  uint64_t v38;

  sub_1D3D8B9D8(v38 - 208);
  sub_1D3D8BA0C(&a23);
  sub_1D3D8BA44(v38 - 144);
  sub_1D3D8BA78(v38 - 176);
  sub_1D3D8BAAC(&a25);
  sub_1D3D8B9A4((uint64_t)&a16);
  sub_1D3D87C3C(&a38);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D8B794(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D85E40((_QWORD *)a1);
  return a1;
}

uint64_t sub_1D3D8B7C8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D85CA8((_QWORD *)a1);
  return a1;
}

void sub_1D3D8B7FC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0)
        v5 = (uint64_t *)*v5;
      v6 = **(_DWORD **)(a1 + 16);
      v7 = **(_QWORD **)(a1 + 24);
      v8 = **(_QWORD **)(a1 + 32);
      v9 = 136446978;
      v10 = v5;
      v11 = 1026;
      v12 = v6;
      v13 = 2082;
      v14 = v7;
      v15 = 2050;
      v16 = v8;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "E5RTNetwork::load_", "path=%{public, signpost.description:attribute}s, compilationFlavor=%{public, signpost.description:attribute}d, function=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v9, 0x26u);
    }
  }
}

_QWORD *sub_1D3D8B928(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*((unsigned __int8 *)result + 8) == *((unsigned __int8 *)a2 + 8))
  {
    if (*((_BYTE *)result + 8))
    {
      result = sub_1D3D84E58(result);
      v4 = *a2;
      *a2 = 0;
      *v3 = v4;
    }
  }
  else if (*((_BYTE *)result + 8))
  {
    result = sub_1D3D84E58(result);
    *((_BYTE *)v3 + 8) = 0;
  }
  else
  {
    v5 = *a2;
    *a2 = 0;
    *result = v5;
    *((_BYTE *)result + 8) = 1;
  }
  return result;
}

uint64_t sub_1D3D8B9A4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D84E58((_QWORD *)a1);
  return a1;
}

uint64_t sub_1D3D8B9D8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D8BAE4((_QWORD *)a1);
  return a1;
}

unint64_t *sub_1D3D8BA0C(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1D3D8BA44(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D859A0((_QWORD *)a1);
  return a1;
}

uint64_t sub_1D3D8BA78(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D84CC0((_QWORD *)a1);
  return a1;
}

unint64_t *sub_1D3D8BAAC(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

_QWORD *sub_1D3D8BAE4(_QWORD *result)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v2[0] = &off_1E95AC4B8;
    v2[1] = result;
    v3 = v2;
    sub_1D3D82C6C((uint64_t)v2, &off_1E95B39C0);
    result = v3;
    if (v3 == v2)
    {
      v1 = 4;
      result = v2;
    }
    else
    {
      if (!v3)
        return result;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
  }
  return result;
}

void sub_1D3D8BB88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3D8BBC8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D8BBDC(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC4B8;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D8BC10(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC4B8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D8BC2C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD))(a2 + 168))(*(_QWORD *)(a1 + 8));
}

uint64_t sub_1D3D8BC38(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP23e5rt_compute_gpu_deviceEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D8BC70()
{
  return &unk_1E95ABD08;
}

void sub_1D3D8BC7C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;
  uint64_t *v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0)
        v5 = (uint64_t *)*v5;
      v6 = **(_QWORD **)(a1 + 16);
      v7 = 136446466;
      v8 = v5;
      v9 = 2050;
      v10 = v6;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "E5RTNetwork::performOnDemandCompilation_", "path=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v7, 0x16u);
    }
  }
}

uint64_t sub_1D3D8BD84(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D852C8((_QWORD *)a1);
  return a1;
}

uint64_t sub_1D3D8BDB8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D85130((_QWORD *)a1);
  return a1;
}

void sub_1D3D8BDF0()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D8BE04(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95AB788;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3D8BE3C(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AB788;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1D3D8BE5C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;
  uint64_t *v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0)
        v5 = (uint64_t *)*v5;
      v6 = **(_QWORD **)(a1 + 16);
      v7 = 136446466;
      v8 = v5;
      v9 = 2050;
      v10 = v6;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v3, "E5RTNetwork::performOnDemandCompilation_", "path=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v7, 0x16u);
    }
  }
}

uint64_t sub_1D3D8BF64(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork27performOnDemandCompilation_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindEmyRNS3_8optionalINS_5ErrorEEERKNSA_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D8BF9C()
{
  return &unk_1E95AB6F0;
}

void sub_1D3D8BFAC()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D8BFC0(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95AB730;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3D8BFF8(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AB730;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1D3D8C018(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork27performOnDemandCompilation_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindEmyRNS3_8optionalINS_5ErrorEEERKNSA_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D8C050()
{
  return &unk_1E95AB6E0;
}

void sub_1D3D8C05C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t *v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0)
        v5 = (uint64_t *)*v5;
      v6 = 136446210;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "E5RTNetwork::loadPrecompiledLibrary_", "path=%{public, signpost.description:attribute}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

void sub_1D3D8C154()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D8C168(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC0F0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D8C19C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC0F0;
  a2[1] = v2;
  return result;
}

void sub_1D3D8C1B8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t *v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0)
        v5 = (uint64_t *)*v5;
      v6 = 136446210;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v3, "E5RTNetwork::loadPrecompiledLibrary_", "path=%{public, signpost.description:attribute}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1D3D8C2AC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork23loadPrecompiledLibrary_ERKNSt3__14__fs10filesystem4pathERNS3_8optionalINS_5ErrorEEERKNS9_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D8C2E4()
{
  return &unk_1E95ABC58;
}

void sub_1D3D8C2F4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D8C308(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AC098;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D8C33C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AC098;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D8C358(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork23loadPrecompiledLibrary_ERKNSt3__14__fs10filesystem4pathERNS3_8optionalINS_5ErrorEEERKNS9_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D8C390()
{
  return &unk_1E95ABC48;
}

void sub_1D3D8C3A0()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D8C3B4(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E95AB838;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1D3D8C3F4(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AB838;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1D3D8C41C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F90 != -1)
    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F98;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F98))
    {
      v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0)
        v5 = (uint64_t *)*v5;
      v6 = **(_DWORD **)(a1 + 16);
      v7 = **(_QWORD **)(a1 + 24);
      v8 = **(_QWORD **)(a1 + 32);
      v9 = 136446978;
      v10 = v5;
      v11 = 1026;
      v12 = v6;
      v13 = 2082;
      v14 = v7;
      v15 = 2050;
      v16 = v8;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v3, "E5RTNetwork::load_", "path=%{public, signpost.description:attribute}s, compilationFlavor=%{public, signpost.description:attribute}d, function=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v9, 0x26u);
    }
  }
}

uint64_t sub_1D3D8C548(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork5load_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindENS2_17CompilationFlavorEPKcSC_RKNS_7Context7OptionsERNS3_8optionalINS_5ErrorEEERKNSH_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D8C580()
{
  return &unk_1E95AB710;
}

void sub_1D3D8C590()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D8C5A4(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E95AB7E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1D3D8C5E4(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AB7E0;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1D3D8C60C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork5load_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindENS2_17CompilationFlavorEPKcSC_RKNS_7Context7OptionsERNS3_8optionalINS_5ErrorEEERKNSH_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D8C644()
{
  return &unk_1E95AB700;
}

std::string *sub_1D3D8C650(std::__fs::filesystem::path *__dst, uint64_t a2, std::__fs::filesystem::path *this)
{
  int v6;
  std::__fs::filesystem::path *v7;
  std::string::size_type size;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_1D3D7FCC0(__dst, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&__dst->__pn_.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    __dst->__pn_.__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
  if (std::__fs::filesystem::path::__root_directory(this).__size_)
    return std::string::operator=(&__dst->__pn_, &this->__pn_);
  if (std::__fs::filesystem::path::__filename(__dst).__size_)
    std::string::push_back(&__dst->__pn_, 47);
  v6 = SHIBYTE(this->__pn_.__r_.__value_.__r.__words[2]);
  if (v6 >= 0)
    v7 = this;
  else
    v7 = (std::__fs::filesystem::path *)this->__pn_.__r_.__value_.__r.__words[0];
  if (v6 >= 0)
    size = HIBYTE(this->__pn_.__r_.__value_.__r.__words[2]);
  else
    size = this->__pn_.__r_.__value_.__l.__size_;
  return std::string::append(&__dst->__pn_, (const std::string::value_type *)v7, size);
}

void sub_1D3D8C6F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

unint64_t *sub_1D3D8C70C(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

std::string *sub_1D3D8C744(std::string *this, std::string *a2, std::string *a3)
{
  std::string *v4;
  unint64_t v6;
  unint64_t v7;
  std::string::size_type size;
  std::string::size_type v9;
  std::string *v10;
  unint64_t v11;
  std::string::value_type *p_p;
  std::string *v13;
  std::string::value_type *v14;
  std::string::value_type v15;
  std::string::size_type v16;
  uint64_t v17;
  uint64_t v18;
  std::string::value_type v19;
  const std::string::value_type *v20;
  std::string::size_type v21;
  void *__p;
  std::string::size_type v24;
  int64_t v25;

  v4 = a2;
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  v7 = (char *)a3 - (char *)a2;
  if ((v6 & 0x80000000) != 0)
  {
    if (a3 == a2)
      return this;
    size = this->__r_.__value_.__l.__size_;
    v11 = this->__r_.__value_.__r.__words[2];
    v9 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    v10 = (std::string *)this->__r_.__value_.__r.__words[0];
    v6 = HIBYTE(v11);
  }
  else
  {
    if (a3 == a2)
      return this;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v9 = 22;
    v10 = this;
  }
  if (v10 > v4 || (std::string *)((char *)&v10->__r_.__value_.__l.__data_ + size + 1) <= v4)
  {
    if (v9 - size < v7)
    {
      std::string::__grow_by(this, v9, size - v9 + v7, size, size, 0, 0);
      this->__r_.__value_.__l.__size_ = size;
      LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
    }
    v13 = this;
    if ((v6 & 0x80) != 0)
      v13 = (std::string *)this->__r_.__value_.__r.__words[0];
    v14 = (char *)v13 + size;
    do
    {
      v15 = v4->__r_.__value_.__s.__data_[0];
      v4 = (std::string *)((char *)v4 + 1);
      *v14++ = v15;
    }
    while (v4 != a3);
    *v14 = 0;
    v16 = v7 + size;
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
      this->__r_.__value_.__l.__size_ = v16;
    else
      *((_BYTE *)&this->__r_.__value_.__s + 23) = v16 & 0x7F;
  }
  else
  {
    if (v7 >= 0x7FFFFFFFFFFFFFF8)
      sub_1D3D7FD48();
    if (v7 > 0x16)
    {
      v17 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17)
        v17 = v7 | 7;
      v18 = v17 + 1;
      p_p = (std::string::value_type *)operator new(v17 + 1);
      v24 = v7;
      v25 = v18 | 0x8000000000000000;
      __p = p_p;
    }
    else
    {
      HIBYTE(v25) = v7;
      p_p = (std::string::value_type *)&__p;
    }
    do
    {
      v19 = v4->__r_.__value_.__s.__data_[0];
      v4 = (std::string *)((char *)v4 + 1);
      *p_p++ = v19;
    }
    while (v4 != a3);
    *p_p = 0;
    if (v25 >= 0)
      v20 = (const std::string::value_type *)&__p;
    else
      v20 = (const std::string::value_type *)__p;
    if (v25 >= 0)
      v21 = HIBYTE(v25);
    else
      v21 = v24;
    std::string::append(this, v20, v21);
    if (SHIBYTE(v25) < 0)
      operator delete(__p);
  }
  return this;
}

void sub_1D3D8C8E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3D8C900(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  size_t v16;
  std::locale::__imp *p_b;
  uint64_t v18;
  uint64_t v19;
  std::locale *v20;
  uint64_t v21;
  _BYTE v23[16];
  std::locale __b;
  size_t v25;
  int64_t v26;

  MEMORY[0x1D8254AB0](v23, a1);
  if (v23[0])
  {
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *((_QWORD *)v6 + 5);
    v8 = *((_DWORD *)v6 + 2);
    v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20)
      v12 = a2 + a3;
    else
      v12 = a2;
    if (!v7)
      goto LABEL_29;
    v13 = *((_QWORD *)v6 + 3);
    v14 = v13 <= a3;
    v15 = v13 - a3;
    v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_29;
    }
    if ((uint64_t)v16 >= 1)
    {
      if (v16 >= 0x7FFFFFFFFFFFFFF8)
        sub_1D3D7FD48();
      if (v16 >= 0x17)
      {
        v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17)
          v18 = v16 | 7;
        v19 = v18 + 1;
        p_b = (std::locale::__imp *)operator new(v18 + 1);
        v25 = v16;
        v26 = v19 | 0x8000000000000000;
        __b.__locale_ = p_b;
      }
      else
      {
        HIBYTE(v26) = v16;
        p_b = (std::locale::__imp *)&__b;
      }
      memset(p_b, v9, v16);
      *((_BYTE *)p_b + v16) = 0;
      v20 = v26 >= 0 ? &__b : (std::locale *)__b.__locale_;
      v21 = (*(uint64_t (**)(uint64_t, std::locale *, size_t))(*(_QWORD *)v7 + 96))(v7, v20, v16);
      if (SHIBYTE(v26) < 0)
        operator delete(__b.__locale_);
      if (v21 != v16)
        goto LABEL_29;
    }
    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((_QWORD *)v6 + 3) = 0;
    }
    else
    {
LABEL_29:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1D8254ABC](v23);
  return a1;
}

void sub_1D3D8CB20(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _QWORD *v17;

  if (a17 < 0)
    operator delete(__p);
  MEMORY[0x1D8254ABC](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1D3D8CAF4);
}

void sub_1D3D8CB80(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D8CB94(int a1, int a2)
{
  unsigned int *v2;
  _QWORD *exception;

  if (!a1)
  {
    if ((a2 - 33) > 0xFFFFFFDF)
    {
      v2 = (unsigned int *)&unk_1D3E61B18;
      return v2[a2];
    }
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "number of data layers is out of bounds for full Aztec symbol");
LABEL_9:
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  if ((a2 - 5) <= 0xFFFFFFFB)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "number of data layers is out of bounds for compact Aztec symbol");
    goto LABEL_9;
  }
  v2 = (unsigned int *)&unk_1D3E61B04;
  return v2[a2];
}

void sub_1D3D8CC30(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1D3D8CC48(uint64_t a1, signed int a2, int a3)
{
  int v6;
  _QWORD *exception;

  if (!sub_1D3D8F250(a1, a2, a3))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3E17508(exception, "Sample point is out of image bounds");
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
  }
  v6 = *(unsigned __int8 *)(a1 + 45);
  return v6 != sub_1D3D6D4A0(*(_QWORD **)(a1 + 16), a2, a3);
}

void sub_1D3D8CCC8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D8CCDC(uint64_t a1, _QWORD *a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  uint64_t v12;
  __int128 v13;
  int v14;
  _BOOL4 v15;
  int32x2_t v17;
  __int128 v18;
  int v19;
  void *__p[3];

  v19 = 0;
  sub_1D3D8CDDC(__p, 2uLL, &v19);
  LODWORD(v12) = 0;
  *(_QWORD *)&v13 = __PAIR64__(a4, a3);
  v17 = (int32x2_t)__PAIR64__(a6, a5);
  v14 = 10;
  do
  {
    v18 = v13;
    *(float32x2_t *)__p[0] = vcvt_f32_s32(*(int32x2_t *)&v13);
    (*(void (**)(_QWORD, void **))(*(_QWORD *)*a2 + 16))(*a2, __p);
    v15 = sub_1D3D8CC48(a1, (int)*(float *)__p[0], (int)*((float *)__p[0] + 1));
    *((_QWORD *)&v13 + 1) = *((_QWORD *)&v18 + 1);
    *(int32x2_t *)&v13 = vadd_s32(v17, *(int32x2_t *)&v18);
    v12 = (v12 + v15);
    --v14;
  }
  while (v14);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v12;
}

void sub_1D3D8CDC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3D8CDDC(_QWORD *a1, unint64_t a2, _DWORD *a3)
{
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1D3D8223C(a1, a2);
    v6 = (_DWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1D3D8CE40(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D3D8CE5C(uint64_t *a1, uint64_t a2, _QWORD *a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8)
{
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  __int128 v19;
  unsigned int v20;
  __int128 v21;
  int v22;
  void *__p[3];

  v16 = operator new();
  sub_1D3D935D8(v16, a8);
  v17 = (unsigned int *)(v16 + 8);
  do
    v18 = __ldxr(v17);
  while (__stxr(v18 + 1, v17));
  *a1 = v16;
  v22 = 0;
  sub_1D3D8CDDC(__p, 2uLL, &v22);
  if (a8 >= 1)
  {
    v20 = 0;
    *(_QWORD *)&v19 = __PAIR64__(a5, a4);
    do
    {
      v21 = v19;
      *(float32x2_t *)__p[0] = vcvt_f32_s32(*(int32x2_t *)&v19);
      (*(void (**)(_QWORD, void **))(*(_QWORD *)*a3 + 16))(*a3, __p);
      if (sub_1D3D8CC48(a2, (int)*(float *)__p[0], (int)*((float *)__p[0] + 1)))
        *(_DWORD *)(*(_QWORD *)(v16 + 48) + 4 * (v20 >> 5)) |= 1 << v20;
      *((_QWORD *)&v19 + 1) = *((_QWORD *)&v21 + 1);
      *(int32x2_t *)&v19 = vadd_s32((int32x2_t)__PAIR64__(a7, a6), *(int32x2_t *)&v21);
      ++v20;
    }
    while (a8 != v20);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1D3D8CFAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  unsigned int **v15;

  sub_1D3D81D1C(v15);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3D8CFF8(unsigned int **a1, unsigned int **a2, unsigned int **a3)
{
  unsigned int **v4;
  uint64_t v5;
  unsigned int **v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;

  if (a1 == a2)
    return a3;
  v4 = a1;
  v5 = 0;
  v6 = a3;
  do
  {
    *v6 = 0;
    v7 = *v4;
    if (*v4)
    {
      v8 = v7 + 2;
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
      if (*v6)
        sub_1D3D6D13C(*v6);
    }
    *v6++ = v7;
    ++v4;
    v5 += 8;
  }
  while (v4 != a2);
  return v6;
}

uint64_t sub_1D3D8D0B0(uint64_t a1, unsigned int **a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int **v10;
  unsigned int *v11;
  unsigned int **v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD v17[2];
  unsigned int **v18;
  unint64_t v19;
  uint64_t v20;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61)
    sub_1D3D6D4F8();
  v6 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
  if (v7 >> 2 > v3)
    v3 = v7 >> 2;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8)
    v8 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v8 = v3;
  v20 = v6;
  if (v8)
    v8 = (unint64_t)sub_1D3D6D8A0(v8);
  else
    v9 = 0;
  v10 = (unsigned int **)(v8 + 8 * v2);
  v17[0] = v8;
  v17[1] = v10;
  v18 = v10;
  v19 = v8 + 8 * v9;
  *v10 = 0;
  v11 = *a2;
  v12 = v10;
  if (v11)
  {
    v13 = v11 + 2;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    v12 = v10;
    if (*v10)
    {
      sub_1D3D6D13C(*v10);
      v12 = v18;
    }
  }
  *v10 = v11;
  v18 = v12 + 1;
  sub_1D3D8D220((unsigned int *)a1, v17);
  v15 = *(_QWORD *)(a1 + 8);
  sub_1D3D8D31C((uint64_t)v17);
  return v15;
}

void sub_1D3D8D1A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D8D31C((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned int *sub_1D3D8D1BC(unsigned int *result, unsigned int **a2)
{
  unsigned int *v2;
  unsigned int **v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;

  v2 = result;
  v3 = (unsigned int **)*((_QWORD *)result + 1);
  *v3 = 0;
  v4 = *a2;
  if (*a2)
  {
    v5 = v4 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    result = *v3;
    if (*v3)
      result = sub_1D3D6D13C(result);
  }
  *v3 = v4;
  *((_QWORD *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1D3D8D218(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unsigned int *sub_1D3D8D220(unsigned int *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int **v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = (uint64_t *)result;
  v5 = *(_QWORD *)result;
  v4 = *((_QWORD *)result + 1);
  if (v4 == *(_QWORD *)result)
  {
    v7 = (unsigned int **)a2[1];
  }
  else
  {
    v6 = 0;
    v7 = (unsigned int **)a2[1];
    do
    {
      *--v7 = 0;
      v9 = *(unsigned int **)(v4 - 8);
      v4 -= 8;
      v8 = v9;
      if (v9)
      {
        v10 = v8 + 2;
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
        result = *v7;
        if (*v7)
          result = sub_1D3D6D13C(result);
      }
      *v7 = v8;
      v6 -= 8;
    }
    while (v4 != v5);
  }
  a2[1] = v7;
  v12 = *v3;
  *v3 = (uint64_t)v7;
  a2[1] = v12;
  v13 = v3[1];
  v3[1] = a2[2];
  a2[2] = v13;
  v14 = v3[2];
  v3[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1D3D8D31C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    sub_1D3D6D834((unsigned int **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1D3D8D368(float **a1, int a2, int a3, _DWORD *a4)
{
  int v4;
  int v6;
  float v7;
  float v8;
  unint64_t v9;
  float *v10;
  float *v11;
  float *v12;
  unint64_t v13;
  float *v14;
  uint64_t v15;
  float v16;
  float *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  float *v22;
  int v23;
  _QWORD *exception;

  if (a2 <= 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "dimension <= 0");
    goto LABEL_38;
  }
  if (a3 > a2 || !a3 || (v4 = -a2, -a2 > a3))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "invalid init_center");
LABEL_38:
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  v6 = a3 + 8;
  if (a3 + 8 >= a2)
    v6 = a2;
  v7 = (float)v6;
  if (a3 - 8 > v4)
    v4 = a3 - 8;
  v8 = (float)v4;
  *a4 = (int)(float)((float)((float)a3 - (float)v4) + (float)((float)a3 - (float)v4));
  v9 = (unint64_t)(float)((float)((float)(v7 - (float)v4) * 2.0) + 1.0);
  if (v9 == 2)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    v11 = (float *)operator new(8uLL);
    a1[1] = v11 + 2;
    a1[2] = v11 + 2;
    *v11 = v8;
    v11[1] = v7;
    *a1 = v11;
  }
  else if (v9 == 1)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    v10 = (float *)operator new(4uLL);
    *a1 = v10;
    *v10++ = v8;
    a1[1] = v10;
    a1[2] = v10;
  }
  else if (v9)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    v16 = (float)(v7 - (float)v4) / (float)(v9 - 1);
    do
    {
      if ((unint64_t)v14 >= v13)
      {
        v18 = v14 - v12;
        v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 62)
          sub_1D3D6D4F8();
        if ((uint64_t)(v13 - (_QWORD)v12) >> 1 > v19)
          v19 = (uint64_t)(v13 - (_QWORD)v12) >> 1;
        if (v13 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
          v20 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v20 = v19;
        if (v20)
          v20 = (unint64_t)sub_1D3D82278(v20);
        else
          v21 = 0;
        v22 = (float *)(v20 + 4 * v18);
        *v22 = v8;
        v17 = v22 + 1;
        while (v14 != v12)
        {
          v23 = *((_DWORD *)v14-- - 1);
          *((_DWORD *)v22-- - 1) = v23;
        }
        v13 = v20 + 4 * v21;
        *a1 = v22;
        a1[1] = v17;
        a1[2] = (float *)v13;
        if (v12)
          operator delete(v12);
        v12 = v22;
      }
      else
      {
        *v14 = v8;
        v17 = v14 + 1;
      }
      a1[1] = v17;
      v8 = v16 + v8;
      ++v15;
      v14 = v17;
    }
    while (v15 != v9);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1D3D8D598(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D8D5CC(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1D3D8223C(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1D3D8D624(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D8D640(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6;
  unsigned __int8 v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 v17;

  if (a6 < 2)
    return 0;
  v13 = sub_1D3D6D4A0(a1, a2, a3);
  LODWORD(v6) = 0;
  v14 = a6 - 1;
  v15 = a4 + a2;
  v16 = a5 + a3;
  do
  {
    v17 = sub_1D3D6D4A0(a1, v15, v16);
    v6 = v6 + ((v13 ^ v17) & 1);
    if (((v13 ^ v17) & 1) != 0)
      v13 = v17;
    v15 += a4;
    v16 += a5;
    --v14;
  }
  while (v14);
  return v6;
}

_QWORD *sub_1D3D8D6EC(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1D3D8223C(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1D3D8D744(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3D8D760(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_1D3D8223C(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1D3D8D7BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1D3D8D7D8(unsigned int **a1, int32x2_t *a2, int32x2_t *a3, int32x2_t *a4)
{
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  int32x2_t v18;
  int32x2_t v19;
  int8x8_t v20;
  __int32 v21;
  __int32 v22;
  __int32 v23;
  __int32 v24;
  unsigned int *v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int v28;
  int32x2_t v29;
  int32x2_t v30;
  int8x8_t v31;
  __int32 v32;
  __int32 v33;
  __int32 v34;
  __int32 v35;
  __int128 v36;
  __int128 v38;
  _QWORD v39[2];
  unint64_t v40;
  __int32 v41;
  __int32 v42;
  __int32 v43;
  __int32 v44;
  uint64_t v45;
  unsigned int *v46;
  char v47[8];
  unsigned int *v48[12];
  _QWORD v49[2];
  unint64_t v50;
  __int32 v51;
  __int32 v52;
  __int32 v53;
  __int32 v54;
  uint64_t v55;
  unsigned int *v56;
  char v57[8];
  unsigned int *v58[12];

  v7 = *a1;
  v8 = *((_QWORD *)*a1 + 7);
  v9 = -v8;
  v10 = *((_QWORD *)*a1 + 4);
  v11 = v10 & -v8--;
  v12 = *((_QWORD *)*a1 + 2);
  v13 = v12 & v8 | v11;
  v14 = v10 & v8 | v12 & v9;
  if (v13 <= v14)
    v15 = v14;
  else
    v15 = v13;
  v16 = v7 + 2;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  v56 = v7;
  v18 = *a3;
  v19 = vadd_s32(*a3, *a2);
  v49[0] = *a2;
  v49[1] = v19;
  v55 = 0;
  v20 = vorr_s8((int8x8_t)vcltz_s32(v18), vbic_s8((int8x8_t)0x100000001, (int8x8_t)vceqz_s32(v18)));
  v21 = v20.i32[1];
  v22 = v20.i32[0];
  v50 = (unint64_t)vabs_s32(v18);
  if (v50 >= HIDWORD(v50))
  {
    v24 = 0;
    v23 = v20.i32[0];
    v22 = 0;
  }
  else
  {
    v23 = 0;
    v50 = __PAIR64__(v50, HIDWORD(v50));
    v24 = v20.i32[1];
    v21 = 0;
  }
  v51 = v23;
  v52 = v24;
  v53 = v22;
  v54 = v21;
  sub_1D3D8DA04((uint64_t)v57, v7, (uint64_t)v49, v15);
  sub_1D3D6D10C(&v56);
  v25 = v58[7];
  v26 = *a1;
  if (*a1)
  {
    v27 = v26 + 2;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  v45 = 0;
  v46 = v26;
  v29 = *a4;
  v30 = vadd_s32(*a4, *a2);
  v39[0] = *a2;
  v39[1] = v30;
  v31 = vorr_s8((int8x8_t)vcltz_s32(v29), vbic_s8((int8x8_t)0x100000001, (int8x8_t)vceqz_s32(v29)));
  v32 = v31.i32[1];
  v33 = v31.i32[0];
  v40 = (unint64_t)vabs_s32(v29);
  if (v40 >= HIDWORD(v40))
  {
    v35 = 0;
    v34 = v31.i32[0];
    v33 = 0;
  }
  else
  {
    v34 = 0;
    v40 = __PAIR64__(v40, HIDWORD(v40));
    v35 = v31.i32[1];
    v32 = 0;
  }
  v41 = v34;
  v42 = v35;
  v43 = v33;
  v44 = v32;
  sub_1D3D8DA04((uint64_t)v47, v26, (uint64_t)v39, v15);
  sub_1D3D6D10C(&v46);
  *(float32x2_t *)&v36 = vmul_f32(vcvt_f32_s32(vadd_s32((int32x2_t)v48[7], (int32x2_t)v25)), (float32x2_t)0x3F0000003F000000);
  v38 = v36;
  sub_1D3D6D10C(v48);
  sub_1D3D6D10C(v58);
  return (__n128)v38;
}

void sub_1D3D8D9D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  sub_1D3D6D10C((unsigned int **)va);
  sub_1D3D6D10C((unsigned int **)(v9 - 160));
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3D8DA04(uint64_t a1, unsigned int *a2, uint64_t a3, unsigned int a4)
{
  unsigned int *v7;
  unsigned int v8;
  int64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t v13;
  int32x2_t v14;
  int v15;
  int v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  int v20;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  unsigned int *v31;

  if (a2)
  {
    v7 = a2 + 2;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v9 = *(_QWORD *)a3;
    v28 = *(_OWORD *)(a3 + 8);
    v29 = *(_OWORD *)(a3 + 24);
    v30 = *(_QWORD *)(a3 + 40);
    v31 = a2;
    *(_BYTE *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    do
      v10 = __ldxr(v7);
    while (__stxr(v10 + 1, v7));
  }
  else
  {
    v9 = *(_QWORD *)a3;
    v28 = *(_OWORD *)(a3 + 8);
    v29 = *(_OWORD *)(a3 + 24);
    v30 = *(_QWORD *)(a3 + 40);
    v31 = 0;
    *(_BYTE *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  *(_OWORD *)(a1 + 24) = v28;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = v9;
  *(_OWORD *)(a1 + 40) = v29;
  *(_QWORD *)(a1 + 56) = v30;
  *(_QWORD *)(a1 + 64) = v9;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0x100000000;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = a4;
  v26 = a4;
  if (sub_1D3D8DC78(a2, v9))
  {
    v11 = sub_1D3D6D4A0(a2, (int)v9, v9 >> 32);
    v12 = 0;
    v13 = 0;
    *(_BYTE *)a1 = v11;
    v14 = *(int32x2_t *)(a1 + 40);
    v15 = *(_DWORD *)(a1 + 32);
    v25 = *(_DWORD *)(a1 + 36);
    v16 = *(_DWORD *)(a1 + 56);
    v22 = *(_DWORD *)(a1 + 60);
    v23 = v22 + 1 + a4;
    v24 = v11;
    while (1)
    {
      v17 = (unint64_t)vadd_s32(v14, (int32x2_t)v9);
      v16 += v25;
      if (v15 < 2 * v16)
      {
        v17 = (unint64_t)vadd_s32(*(int32x2_t *)(a1 + 48), (int32x2_t)v17);
        v16 -= v15;
      }
      v18 = HIDWORD(v17);
      if (v26 == v13)
        break;
      if (v15 - v22 == v13)
      {
        v20 = v15 + 1;
        goto LABEL_27;
      }
      v27 = v17;
      v19 = v17;
      if (!sub_1D3D8DC78(a2, v17))
      {
        v20 = v22 + v13 + 1;
        v17 = v27;
        goto LABEL_27;
      }
      *(_QWORD *)(a1 + 88) = v13 + 1;
      if (v24 == sub_1D3D6D4A0(a2, (int)v19, v18))
      {
        v12 = 0;
      }
      else
      {
        if (v12)
        {
          *(_QWORD *)(a1 + 72) = v9;
          *(_QWORD *)(a1 + 16) = v27;
          *(_DWORD *)(a1 + 56) = v16;
          *(_DWORD *)(a1 + 60) = v22 + 1 + v13;
          *(_BYTE *)a1 = v24 ^ 1;
          *(_DWORD *)(a1 + 80) = 0;
          return sub_1D3D6D10C(&v31);
        }
        *(_QWORD *)(a1 + 64) = v27;
        if ((int)v9 > (int)v19)
          *(_DWORD *)(a1 + 64) = v9;
        if (SHIDWORD(v27) < SHIDWORD(v9))
          *(_DWORD *)(a1 + 68) = HIDWORD(v9);
        v12 = 1;
      }
      *(_DWORD *)(a1 + 80) = v12;
      v9 = v19;
      ++v13;
    }
    v20 = v23;
LABEL_27:
    *(_QWORD *)(a1 + 72) = v9;
    *(_QWORD *)(a1 + 16) = v17;
    *(_DWORD *)(a1 + 56) = v16;
    *(_DWORD *)(a1 + 60) = v20;
  }
  return sub_1D3D6D10C(&v31);
}

BOOL sub_1D3D8DC78(_QWORD *a1, unint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((a2 & 0x80000000) != 0)
    return 0;
  result = 0;
  if ((a2 & 0x8000000000000000) == 0)
  {
    v4 = a1[7];
    v5 = -v4;
    v6 = a1[4];
    v7 = v6 & -v4;
    v8 = v4 - 1;
    v9 = a1[2];
    if ((v9 & v8 | (unint64_t)v7) > a2)
      return (v6 & v8 | v9 & (unint64_t)v5) > HIDWORD(a2);
  }
  return result;
}

float sub_1D3D8DCD8(uint64_t a1, unsigned int **a2, unint64_t a3)
{
  int v3;
  unint64_t v5;
  int v6;
  int v7;
  int v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  float *v13;
  float *v14;
  float *v15;
  float *v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  float *v20;
  uint64_t v21;
  int v22;
  float *v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int32x2_t v41;
  unint64_t v42;
  unint64_t v43;
  _DWORD *v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  BOOL v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  BOOL v71;
  char v72;
  int v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  char v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float *v82;
  float v83;
  float v84;
  void *v85;
  int32x2_t v86;
  int32x2_t v87;
  int32x2_t v88;
  float v89;
  float v90;
  float *v92;
  float *v93;
  unsigned int **v94;
  int v95;
  int v96;
  _DWORD *v97;
  uint64_t v98;
  unint64_t v99;
  _DWORD *v100;
  unsigned int *v101;
  int v102;
  int v103;
  uint64_t v104;
  int v106;
  _QWORD v107[3];
  void *__p;
  _BYTE *v109;
  uint64_t v110;
  _DWORD *v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int *v114;
  unsigned int *v115;
  float *v116;
  float *v117;
  float *v118;
  float *v119;
  uint64_t v120;
  int32x2_t v121;
  uint64_t v122;
  float *v123;
  float *v124;
  float *v125;
  int32x2_t v126;
  int32x2_t v127;
  int32x2_t v128;
  int32x2_t v129;
  int32x2_t v130[2];

  v3 = a3;
  v5 = HIDWORD(a3);
  v6 = sub_1D3D8CB94(*(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 28));
  if (v6 >= 0)
    v7 = v6;
  else
    v7 = v6 + 1;
  v8 = v7 >> 1;
  v120 = 0;
  sub_1D3D8D368(&v118, v7 >> 1, v3, (_DWORD *)&v120 + 1);
  sub_1D3D8D368(&v116, v8, v5, &v120);
  v9 = *a2;
  if (*a2)
  {
    v10 = v9 + 2;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v114 = v9;
  v12 = operator new();
  v14 = v118;
  v13 = v119;
  v16 = v116;
  v15 = v117;
  sub_1D3D938C4(v12, v119 - v118, v117 - v116);
  v17 = (unsigned int *)(v12 + 8);
  do
    v18 = __ldxr(v17);
  while (__stxr(v18 + 1, v17));
  v94 = a2;
  v115 = (unsigned int *)v12;
  sub_1D3D8D5CC(&__p, 2uLL);
  if (v16 != v15)
  {
    v19 = 0;
    v20 = v16;
    do
    {
      if (v14 != v13)
      {
        v21 = 0;
        v22 = *(_DWORD *)v20;
        v23 = v14;
        do
        {
          v24 = __p;
          *(float *)__p = *v23;
          v24[1] = v22;
          (*(void (**)(unsigned int *, void **))(*(_QWORD *)v114 + 16))(v114, &__p);
          if (sub_1D3D8CC48(a1, (int)*(float *)__p, (int)*((float *)__p + 1)))
            *(_DWORD *)(*(_QWORD *)(v12 + 48)
                      + (((unint64_t)(v21 + v19 * *(_QWORD *)(v12 + 24)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v21 + v19 * *(_QWORD *)(v12 + 24));
          ++v21;
          ++v23;
        }
        while (v23 != v13);
      }
      ++v19;
      ++v20;
    }
    while (v20 != v15);
  }
  if (__p)
  {
    v109 = __p;
    operator delete(__p);
  }
  sub_1D3D6F2E0(&v114);
  v93 = v16;
  sub_1D3D8D6EC(&v123, *((_QWORD *)v115 + 4) & (*((_QWORD *)v115 + 7) - 1) | *((_QWORD *)v115 + 2) & -*((_QWORD *)v115 + 7));
  sub_1D3D8D6EC(&v121, *((_QWORD *)v115 + 2) & (*((_QWORD *)v115 + 7) - 1) | *((_QWORD *)v115 + 4) & -*((_QWORD *)v115 + 7));
  v25 = 0;
  v26 = *((_QWORD *)v115 + 7);
  v27 = -v26;
  v28 = *((_QWORD *)v115 + 2);
  v29 = v28 & -v26--;
  v30 = *((_QWORD *)v115 + 4);
  v31 = v30 & v26 | v29;
  v32 = v123;
  v33 = v28 & v26 | v30 & v27;
  while (v31 != v25)
  {
    LODWORD(v32[v25]) = sub_1D3D8D640(v115, 0, v25, 1, 0, v33);
    ++v25;
  }
  v34 = 0;
  v35 = *((_QWORD *)v115 + 7);
  v36 = -v35;
  v37 = *((_QWORD *)v115 + 4);
  v38 = v37 & -v35--;
  v39 = *((_QWORD *)v115 + 2);
  v40 = v39 & v35 | v38;
  v41 = v121;
  v42 = v37 & v35 | v39 & v36;
  while (v40 != v34)
  {
    *(_DWORD *)(*(_QWORD *)&v41 + 4 * v34) = sub_1D3D8D640(v115, v34, 0, 0, 1, v42);
    ++v34;
  }
  __p = 0;
  v109 = 0;
  v110 = 0;
  sub_1D3D8D760(&__p, *(const void **)&v121, v122, (v122 - *(_QWORD *)&v121) >> 2);
  v111 = 0;
  v112 = 0;
  v113 = 0;
  sub_1D3D8D760(&v111, v123, (uint64_t)v124, v124 - v123);
  if (v121)
  {
    v122 = (uint64_t)v121;
    operator delete(*(void **)&v121);
  }
  if (v123)
  {
    v124 = v123;
    operator delete(v123);
  }
  v92 = v14;
  v97 = v111;
  v43 = (unint64_t)(v112 - (_QWORD)v111) >> 2;
  v44 = __p;
  if ((v43 & 0x80000000) == 0)
    v45 = (unint64_t)(v112 - (_QWORD)v111) >> 2;
  else
    v45 = v43 + 1;
  v99 = (unint64_t)(v109 - (_BYTE *)__p) >> 2;
  v100 = __p;
  v101 = v115;
  v106 = HIDWORD(v120);
  if ((_DWORD)v43)
  {
    v46 = 0;
    v47 = 0;
    v95 = v45 >> 1;
    v96 = v120;
    v48 = (int)((unint64_t)(v109 - (_BYTE *)__p) >> 2) / 2;
    v102 = -HIDWORD(v120);
    v104 = ((unint64_t)(v109 - (_BYTE *)__p) >> 2);
    v98 = ((unint64_t)(v112 - (_QWORD)v111) >> 2);
    v49 = 0x7FFFFFFF;
    v50 = v120;
    do
    {
      if ((_DWORD)v99)
      {
        v51 = 0;
        if (v97[v46] >= v95)
          v53 = v95;
        else
          v53 = v97[v46];
        do
        {
          v52 = (v46 - v96) * (v46 - v96);
          v54 = v44[v51];
          if (v54 >= v48)
            v54 = v48;
          v55 = v53 + v54;
          if (v53 + v54 > v47
            || (v55 == v47 ? (v56 = v52 + (v102 + (int)v51) * (v102 + (int)v51) < v49) : (v56 = 0), v56))
          {
            v57 = sub_1D3D6D4A0(v101, v51, v46);
            v44 = v100;
            if (v57)
            {
              v50 = v51;
              v58 = v46;
            }
            else
            {
              v58 = v106;
            }
            v106 = v58;
            if (v57)
            {
              v47 = v55;
              v49 = v52 + (v102 + v51) * (v102 + v51);
            }
          }
          ++v51;
        }
        while (v104 != v51);
      }
      ++v46;
    }
    while (v46 != v98);
  }
  else
  {
    v50 = v120;
  }
  v59 = v106;
  v60 = v50;
  v61 = *((_QWORD *)v101 + 7);
  v62 = -v61;
  v63 = *((_QWORD *)v101 + 4);
  v64 = v61 - 1;
  v65 = *((_QWORD *)v101 + 2);
  v66 = (v65 & (v61 - 1) | v63 & -v61) - 1;
  v67 = v106;
  if (v66 <= v50)
    v68 = v50;
  else
    v68 = v66;
  v69 = v50;
  while (v68 != v69)
  {
    if ((sub_1D3D6D4A0(v101, ++v69, v106) & 1) == 0)
    {
      LODWORD(v68) = v69 - 1;
      break;
    }
  }
  v103 = v50 & (v50 >> 31);
  v70 = v50 - 1;
  while (1)
  {
    v71 = __OFSUB__(v50--, 1);
    if (v50 < 0 != v71)
      break;
    v72 = sub_1D3D6D4A0(v101, v70--, v106);
    if ((v72 & 1) == 0)
    {
      v73 = v50 + 1;
      goto LABEL_67;
    }
  }
  v73 = v103;
LABEL_67:
  if ((v63 & v64 | v65 & (unint64_t)v62) - 1 <= v106)
    v74 = v106;
  else
    v74 = (v63 & v64 | v65 & v62) - 1;
  while (v74 != v67)
  {
    if ((sub_1D3D6D4A0(v101, v60, ++v67) & 1) == 0)
    {
      LODWORD(v74) = v67 - 1;
      break;
    }
  }
  v75 = v106 & (v106 >> 31);
  v76 = v106 - 1;
  while (1)
  {
    v71 = __OFSUB__(v59--, 1);
    if (v59 < 0 != v71)
      break;
    v77 = sub_1D3D6D4A0(v101, v60, v76--);
    if ((v77 & 1) == 0)
    {
      v75 = v59 + 1;
      break;
    }
  }
  v78 = v92[v73];
  v79 = v92[(int)v68];
  v80 = v93[v75];
  v81 = v93[(int)v74];
  v82 = (float *)operator new(0x28uLL);
  v83 = (float)(v78 + v79) * 0.5;
  v84 = (float)(v80 + v81) * 0.5;
  v124 = v82 + 10;
  v125 = v82 + 10;
  *v82 = v83;
  v82[1] = v84;
  v82[2] = v83;
  v82[3] = v84 + -1.5;
  v82[4] = v83;
  v82[5] = v84 + 1.5;
  v82[6] = v83 + -1.5;
  v82[7] = v84;
  v82[8] = v83 + 1.5;
  v82[9] = v84;
  v123 = v82;
  (*(void (**)(unsigned int *, float **))(*(_QWORD *)*v94 + 16))(*v94, &v123);
  memset(v107, 0, sizeof(v107));
  sub_1D3D8E528(v107, v123, (uint64_t)v124, v124 - v123);
  v85 = (void *)v107[0];
  v121.i32[0] = (int)*(float *)v107[0];
  v121.i32[1] = (int)*(float *)(v107[0] + 4);
  v86 = vcvt_s32_f32(*(float32x2_t *)(v107[0] + 24));
  v87 = vcvt_s32_f32(*(float32x2_t *)(v107[0] + 32));
  v88 = vsub_s32(vcvt_s32_f32(*(float32x2_t *)(v107[0] + 8)), v121);
  v129 = vsub_s32(vcvt_s32_f32(*(float32x2_t *)(v107[0] + 16)), v121);
  v130[0] = v88;
  v127 = vsub_s32(v87, v121);
  v128 = vsub_s32(v86, v121);
  v126.i32[0] = (int)sub_1D3D8D7D8((unsigned int **)(a1 + 16), &v121, v130, &v129).n128_f32[0];
  v126.i32[1] = (int)v89;
  LODWORD(v90) = sub_1D3D8D7D8((unsigned int **)(a1 + 16), &v126, &v128, &v127).n128_u32[0];
  operator delete(v85);
  if (v123)
  {
    v124 = v123;
    operator delete(v123);
  }
  if (v97)
    operator delete(v97);
  if (v100)
    operator delete(v100);
  sub_1D3D6D10C(&v115);
  operator delete(v93);
  operator delete(v92);
  return v90;
}

void sub_1D3D8E40C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,int a33,unsigned int *a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38)
{
  sub_1D3D8E5A0((uint64_t)&a26);
  sub_1D3D6D10C(&a34);
  if (__p)
  {
    a36 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a38)
    operator delete(a38);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D8E528(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_1D3D8223C(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1D3D8E584(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D8E5A0(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  v3 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

BOOL sub_1D3D8E5E0(char a1)
{
  return (a1 & 1) == 0;
}

BOOL sub_1D3D8E5EC(int a1, int a2)
{
  unsigned int v2;

  if (a1 >= 0)
    v2 = a1;
  else
    v2 = a1 + 1;
  return ((a2 / 3 + (v2 >> 1)) & 1) == 0;
}

BOOL sub_1D3D8E61C(int a1, int a2)
{
  return a2 * a1 % 6 < 3;
}

BOOL sub_1D3D8E64C(int a1, int a2)
{
  return ((a2 + a1 + a2 * a1 - a2 * a1 / 3) & 1) == 0;
}

unsigned int **sub_1D3D8E680(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  _DWORD *v5;
  unint64_t v6;
  _QWORD *exception;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  int v29;
  uint64_t v30;
  int v31;
  unsigned int *v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  int v45;
  unsigned int *v46;
  int v47;
  unsigned int *v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unsigned int *v54;
  _QWORD *v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t i;
  unsigned int *v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  unsigned int *v68;
  unsigned int v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  unsigned int *v76;
  uint64_t j;
  unsigned int *v78;
  unsigned int *v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  int v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  unsigned int v87;
  unsigned int *v89;
  unsigned int *v90;
  unsigned int *v91;
  unsigned int *v92;
  unsigned int *v93[4];
  unsigned int *v94;
  int v95;
  uint64_t v96;
  unsigned int *v97;
  uint64_t (**v98)(_QWORD);
  int v99;
  uint64_t v100;

  v4 = 0;
  *(_BYTE *)(a1 + 44) = 0;
  while (1)
  {
    v5 = *(_DWORD **)(a2[v4] + 48);
    if ((*v5 & 1) != 0)
    {
      v6 = *(int *)(a1 + 36);
      if (((*(_DWORD *)((char *)v5 + ((v6 >> 2) & 0x1FFFFFFFFFFFFFFCLL)) >> ((2 * v6) & 0x1E)) & 1) != 0)
        break;
    }
    if (++v4 == 4)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_1D3E17508(exception, "could not determine orientation");
      __cxa_throw(exception, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
    }
  }
  if ((*v5 & 2) == 0
    && ((*(_DWORD *)((char *)v5 + (((unint64_t)(2 * (int)v6 - 1) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> (2 * v6 - 1)) & 1) != 0)
  {
    *(_BYTE *)(a1 + 44) = 1;
  }
  *(_DWORD *)(a1 + 40) = v4;
  v8 = operator new();
  v9 = (unsigned int *)v8;
  if (*(_BYTE *)(a1 + 24))
    v10 = 28;
  else
    v10 = 40;
  sub_1D3D935D8(v8, v10);
  v11 = v9 + 2;
  do
    v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  v92 = v9;
  v13 = operator new();
  v14 = v13;
  if (*(_BYTE *)(a1 + 24))
    v15 = 28;
  else
    v15 = 40;
  sub_1D3D935D8(v13, v15);
  v16 = (unsigned int *)(v14 + 8);
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  v91 = (unsigned int *)v14;
  v18 = *(unsigned __int8 *)(a1 + 24);
  v19 = *a2;
  v20 = a2[1];
  v21 = 0;
  if (*(_BYTE *)(a1 + 24))
  {
    v22 = *(_QWORD *)(v19 + 48);
    v23 = *(_QWORD *)(v20 + 48);
    v24 = *(_QWORD *)(a2[2] + 48);
    v25 = *(_QWORD *)(a2[3] + 48);
    do
    {
      v26 = (v21 + 2) >> 5;
      v27 = 4 << v21;
      if ((*(_DWORD *)(v22 + 4 * v26) & (4 << v21)) != 0)
        *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * (v21 >> 5)) |= 1 << v21;
      if ((*(_DWORD *)(v23 + 4 * v26) & v27) != 0)
        *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * ((v21 + 7) >> 5)) |= 128 << v21;
      if ((*(_DWORD *)(v24 + 4 * v26) & v27) != 0)
        *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * ((v21 + 14) >> 5)) |= 0x4000 << v21;
      if ((*(_DWORD *)(v25 + 4 * v26) & v27) != 0)
        *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * ((v21 + 21) >> 5)) |= 0x200000 << v21;
      ++v21;
    }
    while (v21 != 7);
    v28 = 0;
    v29 = *(unsigned __int8 *)(a1 + 44);
    v30 = *(_QWORD *)(v14 + 48);
    v31 = 34;
    v32 = v92;
    do
    {
      v33 = 7 * *(_DWORD *)(a1 + 40);
      v34 = v28 + v33;
      v35 = v31 + v33;
      if (!v29)
        v35 = v34;
      if (((*(_DWORD *)(v30 + (((unint64_t)(v35 % 28) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> (v35 % 28)) & 1) != 0)
        *(_DWORD *)(*((_QWORD *)v32 + 6) + 4 * (v28 >> 5)) |= 1 << v28;
      ++v28;
      --v31;
    }
    while (v28 != 28);
    goto LABEL_64;
  }
  v36 = a2[2];
  v37 = a2[3];
  do
  {
    if (v21 > 4)
    {
      if (v21 != 5)
      {
        v40 = (v21 + 2) >> 5;
        v41 = 4 << v21;
        if ((*(_DWORD *)(*(_QWORD *)(v19 + 48) + 4 * v40) & (4 << v21)) != 0)
          *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * ((v21 - 1) >> 5)) |= 1 << (v21 - 1);
        if ((*(_DWORD *)(*(_QWORD *)(v20 + 48) + 4 * v40) & v41) != 0)
          *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * ((v21 + 9) >> 5)) |= 512 << v21;
        if ((*(_DWORD *)(*(_QWORD *)(v36 + 48) + 4 * v40) & v41) != 0)
          *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * ((v21 + 19) >> 5)) |= 0x80000 << v21;
        if ((*(_DWORD *)(*(_QWORD *)(v37 + 48) + 4 * v40) & v41) != 0)
        {
          v39 = 29;
          goto LABEL_56;
        }
      }
    }
    else
    {
      v38 = 4 << v21;
      if ((**(_DWORD **)(v19 + 48) & (4 << v21)) != 0)
        **(_DWORD **)(v14 + 48) |= 1 << v21;
      if ((**(_DWORD **)(v20 + 48) & v38) != 0)
        **(_DWORD **)(v14 + 48) |= 1024 << v21;
      if ((**(_DWORD **)(v36 + 48) & v38) != 0)
        **(_DWORD **)(v14 + 48) |= 0x100000 << v21;
      if ((**(_DWORD **)(v37 + 48) & v38) != 0)
      {
        v39 = 30;
LABEL_56:
        *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4 * ((v21 + v39) >> 5)) |= 1 << (v21 + v39);
      }
    }
    ++v21;
  }
  while (v21 != 11);
  v42 = 0;
  v43 = *(unsigned __int8 *)(a1 + 44);
  v44 = *(_QWORD *)(v14 + 48);
  v45 = 49;
  v46 = v92;
  do
  {
    v47 = v45 + 10 * *(_DWORD *)(a1 + 40);
    if (!v43)
      v47 = v42 + 10 * *(_DWORD *)(a1 + 40);
    if (((*(_DWORD *)(v44 + (((unint64_t)(v47 % 40) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> (v47 % 40)) & 1) != 0)
      *(_DWORD *)(*((_QWORD *)v46 + 6) + 4 * (v42 >> 5)) |= 1 << v42;
    ++v42;
    --v45;
  }
  while (v42 != 40);
LABEL_64:
  if (v92)
  {
    v48 = v92 + 2;
    do
      v49 = __ldxr(v48);
    while (__stxr(v49 + 1, v48));
    v18 = *(unsigned __int8 *)(a1 + 24);
  }
  v90 = v92;
  if (v18)
    v50 = 5;
  else
    v50 = 6;
  v51 = operator new();
  v52 = v51;
  if (v18)
    v53 = 7;
  else
    v53 = 10;
  *(_DWORD *)(v51 + 8) = 0;
  v54 = (unsigned int *)(v51 + 8);
  *(_QWORD *)v51 = &off_1E95AF5E0;
  LODWORD(v93[0]) = 0;
  v55 = sub_1D3D821BC((_QWORD *)(v51 + 16), v53, v93);
  v99 = 0;
  v98 = &off_1E95AF9D0;
  do
    v56 = __ldxr(v54);
  while (__stxr(v56 + 1, v54));
  v57 = 0;
  v58 = 0;
  v100 = v52;
  v59 = *((_QWORD *)v90 + 6);
  do
  {
    v60 = 1;
    for (i = 3; i != -1; --i)
    {
      if (((*(_DWORD *)(v59 + (((unint64_t)(v57 + i) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> ((v57 & 0x1F) + i)) & 1) != 0)
        *(_DWORD *)(*v55 + 4 * v58) += v60;
      v60 *= 2;
    }
    ++v58;
    v57 += 4;
  }
  while (v58 != v53);
  sub_1D3DBAE60();
  v62 = *(unsigned int **)qword_1EDB89EE0;
  if (*(_QWORD *)qword_1EDB89EE0)
  {
    v63 = v62 + 2;
    do
      v64 = __ldxr(v63);
    while (__stxr(v64 + 1, v63));
    v94 = v62;
    do
      v65 = __ldxr(v63);
    while (__stxr(v65 + 1, v63));
    v97 = v62;
    do
      v66 = __ldxr(v63);
    while (__stxr(v66 + 1, v63));
  }
  else
  {
    v94 = 0;
    v97 = 0;
  }
  v93[0] = v62;
  sub_1D3D82034(&v97);
  sub_1D3D81F38(&v94);
  v95 = 0;
  v94 = (unsigned int *)&off_1E95AF9D0;
  v67 = v100;
  if (v100)
  {
    v68 = (unsigned int *)(v100 + 8);
    do
      v69 = __ldxr(v68);
    while (__stxr(v69 + 1, v68));
  }
  v96 = v67;
  sub_1D3DBC050((uint64_t *)v93, (uint64_t)&v94, v50);
  sub_1D3D82064(&v94);
  sub_1D3D82034(v93);
  v70 = *((_QWORD *)v90 + 2) + 31;
  if (v70 >= 0x20)
    bzero(*((void **)v90 + 6), (v70 >> 3) & 0x1FFFFFFFFFFFFFFCLL);
  v71 = 0;
  v72 = 0;
  v73 = *(_QWORD *)(v100 + 16);
  v74 = 2;
  if (!v18)
    v74 = 4;
  do
  {
    v75 = 1;
    v76 = v90;
    for (j = 3; j != -1; --j)
    {
      if ((v75 & ~*(_DWORD *)(v73 + 4 * v72)) == 0)
        *(_DWORD *)(*((_QWORD *)v76 + 6) + (((unint64_t)(v71 + j) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v71 + j);
      v75 *= 2;
    }
    ++v72;
    v71 += 4;
  }
  while (v72 != v74);
  sub_1D3D82064(&v98);
  sub_1D3D81D1C(&v90);
  v78 = v92;
  if (v92)
  {
    v79 = v92 + 2;
    do
      v80 = __ldxr(v79);
    while (__stxr(v80 + 1, v79));
  }
  v81 = 0;
  v82 = 0;
  v89 = v78;
  *(_DWORD *)(a1 + 32) = 0;
  v83 = *(unsigned __int8 *)(a1 + 24);
  if (*(_BYTE *)(a1 + 24))
    v84 = 2;
  else
    v84 = 5;
  v85 = *((_QWORD *)v78 + 6);
  do
  {
    v82 *= 2;
    *(_DWORD *)(a1 + 28) = v82;
    if (((*(_DWORD *)(v85 + 4 * (v81 >> 5)) >> v81) & 1) != 0)
    {
      v82 |= 1u;
      *(_DWORD *)(a1 + 28) = v82;
    }
    ++v81;
  }
  while (v84 != v81);
  v86 = 0;
  if (v83)
    v87 = 8;
  else
    v87 = 16;
  do
  {
    v86 *= 2;
    *(_DWORD *)(a1 + 32) = v86;
    if (((*(_DWORD *)(v85 + 4 * (v84 >> 5)) >> v84) & 1) != 0)
    {
      v86 |= 1u;
      *(_DWORD *)(a1 + 32) = v86;
    }
    ++v84;
  }
  while (v84 < v87);
  *(_DWORD *)(a1 + 28) = v82 + 1;
  *(_DWORD *)(a1 + 32) = v86 + 1;
  sub_1D3D81D1C(&v89);
  sub_1D3D81D1C(&v91);
  return sub_1D3D81D1C(&v92);
}

void sub_1D3D8EED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, unsigned int *a11, unsigned int *a12, unsigned int *a13, std::exception a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  uint64_t v18;
  void *exception_ptr;
  _QWORD *exception;

  sub_1D3D82064(&a18);
  sub_1D3D82034((unsigned int **)&a14);
  if (a2 == 1)
  {
    exception_ptr = __cxa_get_exception_ptr(a1);
    sub_1D3D820A4(&a14, (uint64_t)exception_ptr);
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(exception, "failed to decode parameter data");
    *exception = &off_1E95AF388;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
  }
  sub_1D3D82064((_QWORD *)(v18 - 88));
  sub_1D3D81D1C(&a11);
  sub_1D3D81D1C(&a12);
  sub_1D3D81D1C(&a13);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3D8F02C(uint64_t *a1, char a2, int a3, unsigned int **a4, _QWORD *a5, _QWORD *a6, _QWORD *a7, _QWORD *a8, unsigned __int8 a9)
{
  int v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int *v35;
  unsigned int *v36;

  v15 = sub_1D3D8CB94(a2 != 0, a3);
  sub_1D3DB5FF8();
  v16 = *a4;
  if (*a4)
  {
    v17 = v16 + 2;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v33 = v16;
  v19 = (*(float (**)(_QWORD))(*(_QWORD *)*a5 + 16))(*a5);
  v20 = (*(float (**)(_QWORD))(*(_QWORD *)*a5 + 24))(*a5);
  v21 = (*(float (**)(_QWORD))(*(_QWORD *)*a8 + 16))(*a8);
  v22 = (*(float (**)(_QWORD))(*(_QWORD *)*a8 + 24))(*a8);
  v23 = (*(float (**)(_QWORD))(*(_QWORD *)*a7 + 16))(*a7);
  v24 = (*(float (**)(_QWORD))(*(_QWORD *)*a7 + 24))(*a7);
  v25 = (*(float (**)(_QWORD))(*(_QWORD *)*a6 + 16))(*a6);
  v26 = (*(float (**)(_QWORD))(*(_QWORD *)*a6 + 24))(*a6);
  sub_1D3DB93EC((uint64_t *)&v36, 0.0, 0.0, (float)v15, 0.0, (float)v15, (float)v15, 0.0, (float)v15, v19, v20, v21, v22, v23, v24, v25, v26);
  if (v33)
  {
    v27 = v33 + 2;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  v35 = v33;
  v29 = v36;
  if (v36)
  {
    v30 = v36 + 2;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v34 = v29;
  sub_1D3DB5B40(a1, v33, v15, &v34, a9);
  sub_1D3DB45E8(&v34);
  sub_1D3D6D10C(&v35);
  sub_1D3D6F2E0(&v36);
  return sub_1D3D6D10C(&v33);
}

void sub_1D3D8F21C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  unsigned int *v6;
  va_list va;
  unsigned int *v8;
  va_list va1;
  unsigned int *v10;
  va_list va2;
  va_list va3;

  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, unsigned int *);
  va_copy(va2, va1);
  v8 = va_arg(va2, unsigned int *);
  va_copy(va3, va2);
  v10 = va_arg(va3, unsigned int *);
  sub_1D3DB45E8((unsigned int **)va1);
  sub_1D3D6D10C((unsigned int **)va2);
  sub_1D3D6F2E0((unsigned int **)va3);
  sub_1D3D6D10C((unsigned int **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1D3D8F250(uint64_t a1, signed int a2, int a3)
{
  _BOOL8 result;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;

  if (a2 < 0)
    return 0;
  result = 0;
  if ((a3 & 0x80000000) == 0)
  {
    v5 = *(_QWORD **)(a1 + 16);
    v6 = v5[7];
    v7 = -v6;
    v8 = v5[4];
    v9 = v8 & -(int)v6;
    v10 = v6 - 1;
    v11 = v5[2];
    if ((v11 & v10 | v9) > a2)
      return (v8 & v10 | v11 & v7) > a3;
  }
  return result;
}

uint64_t MRCSegmentationMaskCreateForSampleUsingNeuralNetwork(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  NSObject *v4;
  unint64_t v5;
  unint64_t v7[13];
  CFErrorRef v8;

  if (qword_1EFE31830 != -1)
    dispatch_once(&qword_1EFE31830, &unk_1E95B33E8);
  v4 = qword_1EFE31828;
  if (os_log_type_enabled((os_log_t)qword_1EFE31828, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v7[0]) = 0;
    _os_log_error_impl(&dword_1D3D6B000, v4, OS_LOG_TYPE_ERROR, "MRCSegmentationMaskCreateForSampleUsingNeuralNetwork is obsolete", (uint8_t *)v7, 2u);
    if (!a3)
      return 0;
  }
  else if (!a3)
  {
    return 0;
  }
  sub_1D3DF4E68((uint64_t)v7, -4001, CFSTR("MRCSegmentationMaskCreateForSampleUsingNeuralNetwork is obsolete"));
  sub_1D3DF53CC(&v8, (uint64_t)v7);
  do
    v5 = __ldaxr((unint64_t *)&v8);
  while (__stlxr(0, (unint64_t *)&v8));
  *a3 = v5;
  sub_1D3D7448C((unint64_t *)&v8);
  sub_1D3DF4F24(v7);
  return 0;
}

void sub_1D3D8F390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  sub_1D3DF4F24(&a9);
  _Unwind_Resume(a1);
}

uint64_t MRCRegionGetTypeID()
{
  if (qword_1EDB89308 != -1)
    dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
  return qword_1EDB89320;
}

unint64_t MRCRegionCreate(__int128 *a1, __int128 *a2, const void *a3, double a4, float a5)
{
  __int128 *v10;
  const void *Instance;
  unint64_t v12;
  CFTypeID v13;
  __int128 v14;
  __int128 v15;
  CFTypeRef v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  CFTypeID v20;
  unint64_t v21;
  const void *v22;
  unint64_t v24;

  if (!a1)
    _os_assumes_log();
  if (a2)
    v10 = a2;
  else
    v10 = (__int128 *)MEMORY[0x1E0C9BAA8];
  if (qword_1EDB89308 != -1)
    dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
  Instance = (const void *)_CFRuntimeCreateInstance();
  v12 = (unint64_t)Instance;
  if (Instance)
  {
    v13 = CFGetTypeID(Instance);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v13 != qword_1EDB89320)
      _os_assumes_log();
    v14 = *v10;
    v15 = v10[2];
    *(_OWORD *)(v12 + 96) = v10[1];
    *(_OWORD *)(v12 + 112) = v15;
    *(_OWORD *)(v12 + 80) = v14;
    *(double *)(v12 + 128) = a4;
    if (a3)
    {
      v16 = CFRetain(a3);
    }
    else
    {
      _os_assumes_log();
      v16 = 0;
    }
    *(_QWORD *)(v12 + 136) = v16;
    *(float *)(v12 + 144) = a5;
    if (a5 < 0.0 || a5 > 1.0)
      _os_assumes_log();
    v17 = *a1;
    v18 = a1[1];
    v19 = a1[3];
    *(_OWORD *)(v12 + 48) = a1[2];
    *(_OWORD *)(v12 + 64) = v19;
    *(_OWORD *)(v12 + 16) = v17;
    *(_OWORD *)(v12 + 32) = v18;
    v20 = CFGetTypeID((CFTypeRef)v12);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v20 != qword_1EDB89320)
      _os_assumes_log();
  }
  v24 = v12;
  do
    v21 = __ldaxr(&v24);
  while (__stlxr(0, &v24));
  do
    v22 = (const void *)__ldaxr(&v24);
  while (__stlxr(0, &v24));
  if (v22)
    CFRelease(v22);
  return v21;
}

void sub_1D3D8F5FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1D3D8C70C((unint64_t *)(v1 + 136));
  _Unwind_Resume(a1);
}

__n128 MRCRegionGetCornerPoints(__n128 *cf, __n128 *a2)
{
  CFTypeID v4;
  __n128 result;
  __n128 v6;
  __n128 v7;

  if (a2)
  {
    if (!cf)
      goto LABEL_7;
  }
  else
  {
    _os_assumes_log();
    if (!cf)
      goto LABEL_7;
  }
  v4 = CFGetTypeID(cf);
  if (qword_1EDB89308 != -1)
    dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
  if (v4 != qword_1EDB89320)
    _os_assumes_log();
LABEL_7:
  result = cf[1];
  v6 = cf[2];
  v7 = cf[4];
  a2[2] = cf[3];
  a2[3] = v7;
  *a2 = result;
  a2[1] = v6;
  return result;
}

__n128 MRCRegionGetTransform@<Q0>(__n128 *cf@<X0>, __n128 *a2@<X8>)
{
  CFTypeID v4;
  __n128 v5;
  __n128 result;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v4 != qword_1EDB89320)
      _os_assumes_log();
  }
  v5 = cf[6];
  *a2 = cf[5];
  a2[1] = v5;
  result = cf[7];
  a2[2] = result;
  return result;
}

double MRCRegionGetOrientation(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v2 != qword_1EDB89320)
      _os_assumes_log();
  }
  return *((double *)cf + 16);
}

unint64_t MRCRegionGetSymbology(unint64_t *cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v2 != qword_1EDB89320)
      _os_assumes_log();
  }
  return atomic_load(cf + 17);
}

float MRCRegionGetConfidence(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EDB89308 != -1)
      dispatch_once_f(&qword_1EDB89308, 0, (dispatch_function_t)sub_1D3D741E0);
    if (v2 != qword_1EDB89320)
      _os_assumes_log();
  }
  return *((float *)cf + 36);
}

CGAffineTransform *sub_1D3D8F8B8(CGAffineTransform *result, _OWORD *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, char a6, uint64_t a7, char a8)
{
  CGAffineTransform *v9;
  uint64_t v12;
  uint64_t v13;
  double Width;
  CGFloat v15;
  double Height;
  CGFloat v17;
  __int128 v18;
  __int128 v19;
  CGAffineTransform v20;
  CGAffineTransform t1;
  CGAffineTransform v22;

  v9 = result;
  if (a8)
  {
    if (a6)
      a4 = a5;
    v12 = *a4;
    memset(&v22, 0, sizeof(v22));
    v13 = v12 + 216 * a7;
    Width = CGRectGetWidth(*(CGRect *)(v13 + 16));
    v15 = Width / CGRectGetWidth(*(CGRect *)(a3 + 8));
    Height = CGRectGetHeight(*(CGRect *)(v13 + 16));
    v17 = CGRectGetHeight(*(CGRect *)(a3 + 8));
    CGAffineTransformMakeScale(&v22, v15, Height / v17);
    v18 = a2[5];
    *(_OWORD *)&t1.a = a2[4];
    *(_OWORD *)&t1.c = v18;
    *(_OWORD *)&t1.tx = a2[6];
    v20 = v22;
    return CGAffineTransformConcat(v9, &t1, &v20);
  }
  else
  {
    v19 = a2[5];
    *(_OWORD *)&result->a = a2[4];
    *(_OWORD *)&result->c = v19;
    *(_OWORD *)&result->tx = a2[6];
  }
  return result;
}

double sub_1D3D8F9B0(uint64_t a1, float a2)
{
  uint64_t v2;
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  double result;

  v2 = 0;
  v3 = (float64x2_t)vdupq_n_s64(0x41DFFFFFFFC00000uLL);
  v4 = (float64x2_t)vdupq_n_s64(0xC1E0000000000000);
  do
  {
    v5 = *(float64x2_t *)(a1 + v2);
    v3 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v3, v5), (int8x16_t)v5, (int8x16_t)v3);
    v4 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v5, v4), (int8x16_t)v5, (int8x16_t)v4);
    v2 += 16;
  }
  while (v2 != 64);
  *(_QWORD *)&result = *(_OWORD *)&vsubq_f64(v3, vmulq_n_f64(vsubq_f64(v4, v3), a2));
  __asm { FMOV            V1.2D, #2.0 }
  return result;
}

unint64_t *sub_1D3D8FA0C(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

CFArrayRef MRCSymbologyCopySupportedSymbologies()
{
  const __CFAllocator *v0;
  const __CFArray *v1;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (qword_1EDB89FF0 != -1)
    dispatch_once_f(&qword_1EDB89FF0, 0, (dispatch_function_t)sub_1D3D8FAA4);
  v1 = (const __CFArray *)atomic_load((unint64_t *)qword_1EDB89FE8);
  return CFArrayCreateCopy(v0, v1);
}

unint64_t *sub_1D3D8FAA4()
{
  const __CFAllocator *v0;
  __CFArray *v1;
  __CFArray *v2;
  __CFArray *v3;
  __CFArray *v4;
  __CFArray *v5;
  __CFArray *v6;
  __CFArray *v7;
  __CFArray *v8;
  __CFArray *v9;
  __CFArray *v10;
  __CFArray *v11;
  __CFArray *v12;
  __CFArray *v13;
  __CFArray *v14;
  __CFArray *v15;
  __CFArray *v16;
  __CFArray *v17;
  __CFArray *v18;
  __CFArray *v19;
  __CFArray *v20;
  __CFArray *v21;
  __CFArray *v22;
  __CFArray *v23;
  __CFArray *v24;
  __CFArray *v25;
  const __CFArray *v26;
  const __CFArray *v27;
  CFIndex FirstIndexOfValue;
  __CFArray *v29;
  _QWORD *v30;
  const __CFArray *v31;
  CFMutableArrayRef Mutable;
  CFRange v34;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v1 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v1, CFSTR("Aztec"));
  v2 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v2, CFSTR("Code39"));
  v3 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v3, CFSTR("Code39_checksum"));
  v4 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v4, CFSTR("Code39_fullAscii"));
  v5 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v5, CFSTR("Code39_fullAscii_checksum"));
  v6 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v6, CFSTR("Code93"));
  v7 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v7, CFSTR("Code93i"));
  v8 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v8, CFSTR("Code128"));
  v9 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v9, CFSTR("DataMatrix"));
  v10 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v10, CFSTR("EAN8"));
  v11 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v11, CFSTR("EAN13"));
  v12 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v12, CFSTR("I2of5"));
  v13 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v13, CFSTR("I2of5_checksum"));
  v14 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v14, CFSTR("ITF14"));
  v15 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v15, CFSTR("PDF417"));
  v16 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v16, CFSTR("QR"));
  v17 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v17, CFSTR("UPCE"));
  v18 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v18, CFSTR("MSIPlessey"));
  v19 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v19, CFSTR("Codabar"));
  v20 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v20, CFSTR("GS1DataBar"));
  v21 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v21, CFSTR("GS1DataBarExpanded"));
  v22 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v22, CFSTR("GS1DataBarLimited"));
  v23 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v23, CFSTR("MicroQR"));
  v24 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v24, CFSTR("MicroPDF417"));
  v25 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
  CFArrayAppendValue(v25, CFSTR("AppClipCode"));
  while (1)
  {
    v26 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
    v27 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
    v34.length = CFArrayGetCount(v27);
    v34.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v26, v34, CFSTR("AppClipCode"));
    if (FirstIndexOfValue == -1)
      break;
    v29 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
    CFArrayRemoveValueAtIndex(v29, FirstIndexOfValue);
  }
  v30 = (_QWORD *)operator new();
  v31 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
  *v30 = CFArrayCreateCopy(v0, v31);
  qword_1EDB89FE8 = (uint64_t)v30;
  return sub_1D3D74C60((unint64_t *)&Mutable);
}

void sub_1D3D8FD34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x1D8254C54](v2, 0x60C4044C4A2DFLL);
  sub_1D3D74C60((unint64_t *)va);
  _Unwind_Resume(a1);
}

CFArrayRef MRCSymbologyCopySupported1DSymbologies()
{
  const __CFAllocator *v0;
  const __CFArray *v1;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v1 = (const __CFArray *)atomic_load((unint64_t *)sub_1D3D8FDA4(0));
  return CFArrayCreateCopy(v0, v1);
}

char *sub_1D3D8FDA4(int a1)
{
  uint64_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  void **v6;
  _QWORD *v7;
  unint64_t v8;
  const __CFAllocator *v9;
  __CFArray *v10;
  __CFArray *v11;
  __CFArray *v12;
  __CFArray *v13;
  const __CFString *v14;
  __CFArray *v15;
  __CFArray *v16;
  __CFArray *v17;
  __CFArray *v18;
  __CFArray *v19;
  __CFArray *v20;
  __CFArray *v21;
  __CFArray *v22;
  __CFArray *v23;
  __CFArray *v24;
  __CFArray *v25;
  __CFArray *v26;
  __CFArray *v27;
  __CFArray *v28;
  __CFArray *v29;
  __CFArray *v30;
  __CFArray *v31;
  __CFArray *v32;
  __CFArray *v33;
  uint64_t v34;
  const __CFArray *v35;
  CFArrayRef Copy;
  _QWORD *v37;
  unint64_t v38;
  uint8x8_t v39;
  unint64_t v40;
  _QWORD *v41;
  _DWORD *i;
  unint64_t v43;
  float v44;
  float v45;
  _BOOL8 v46;
  unint64_t v47;
  unint64_t v48;
  int8x8_t prime;
  void *v50;
  void *v51;
  uint64_t v52;
  _QWORD *v53;
  unint64_t v54;
  uint8x8_t v55;
  unint64_t v56;
  uint8x8_t v57;
  uint64_t v58;
  _QWORD *v59;
  unint64_t v60;
  unint64_t v61;
  uint8x8_t v62;
  _QWORD *v63;
  unint64_t v64;
  void *v66;
  CFMutableArrayRef Mutable;
  _QWORD v68[2];
  char v69;

  os_unfair_lock_lock_with_options();
  v2 = qword_1EFE31728;
  if (!qword_1EFE31728)
  {
    v2 = operator new();
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 32) = 1065353216;
    qword_1EFE31728 = v2;
  }
  v3 = *(_QWORD *)(v2 + 8);
  if (v3)
  {
    v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      v5 = a1;
      if (v3 <= a1)
        v5 = a1 % v3;
    }
    else
    {
      v5 = (v3 - 1) & a1;
    }
    v6 = *(void ***)(*(_QWORD *)v2 + 8 * v5);
    if (v6)
    {
      v7 = *v6;
      if (*v6)
      {
        do
        {
          v8 = v7[1];
          if (v8 == a1)
          {
            if (*((_DWORD *)v7 + 4) == a1)
              goto LABEL_100;
          }
          else
          {
            if (v4.u32[0] > 1uLL)
            {
              if (v8 >= v3)
                v8 %= v3;
            }
            else
            {
              v8 &= v3 - 1;
            }
            if (v8 != v5)
              break;
          }
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
    }
  }
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  switch(a1)
  {
    case 1:
      v10 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v10, CFSTR("Aztec"));
      v11 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v11, CFSTR("DataMatrix"));
      v12 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v12, CFSTR("QR"));
      v13 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      v14 = CFSTR("MicroQR");
LABEL_27:
      CFArrayAppendValue(v13, v14);
      goto LABEL_28;
    case 0:
      v15 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v15, CFSTR("Code39"));
      v17 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v17, CFSTR("Code39_checksum"));
      v18 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v18, CFSTR("Code39_fullAscii"));
      v19 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v19, CFSTR("Code39_fullAscii_checksum"));
      v20 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v20, CFSTR("Code93"));
      v21 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v21, CFSTR("Code93i"));
      v22 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v22, CFSTR("Code128"));
      v23 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v23, CFSTR("EAN8"));
      v24 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v24, CFSTR("EAN13"));
      v25 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v25, CFSTR("I2of5"));
      v26 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v26, CFSTR("I2of5_checksum"));
      v27 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v27, CFSTR("ITF14"));
      v28 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v28, CFSTR("UPCE"));
      v30 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v30, CFSTR("MSIPlessey"));
      v31 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v31, CFSTR("Codabar"));
      v32 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v32, CFSTR("GS1DataBar"));
      v33 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v33, CFSTR("GS1DataBarExpanded"));
      v13 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      v14 = CFSTR("GS1DataBarLimited");
      goto LABEL_27;
    case 2:
      v16 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v16, CFSTR("PDF417"));
      v29 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
      CFArrayAppendValue(v29, CFSTR("MicroPDF417"));
      break;
  }
  if (a1 == 3)
  {
    v13 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
    v14 = CFSTR("AppClipCode");
    goto LABEL_27;
  }
LABEL_28:
  v34 = qword_1EFE31728;
  v35 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
  Copy = CFArrayCreateCopy(v9, v35);
  v7 = operator new(0x20uLL);
  v37 = (_QWORD *)(v34 + 16);
  v68[0] = v7;
  v68[1] = v34 + 16;
  *((_DWORD *)v7 + 4) = a1;
  v7[3] = Copy;
  v69 = 1;
  *v7 = 0;
  v7[1] = a1;
  v38 = *(_QWORD *)(v34 + 8);
  if (v38)
  {
    v39 = (uint8x8_t)vcnt_s8((int8x8_t)v38);
    v39.i16[0] = vaddlv_u8(v39);
    if (v39.u32[0] > 1uLL)
    {
      v40 = a1;
      if (v38 <= a1)
        v40 = a1 % v38;
    }
    else
    {
      v40 = (v38 - 1) & a1;
    }
    v41 = *(_QWORD **)(*(_QWORD *)v34 + 8 * v40);
    if (v41)
    {
      for (i = (_DWORD *)*v41; i; i = *(_DWORD **)i)
      {
        v43 = *((_QWORD *)i + 1);
        if (v43 == a1)
        {
          if (i[4] == a1)
          {
            v7 = i;
            goto LABEL_99;
          }
        }
        else
        {
          if (v39.u32[0] > 1uLL)
          {
            if (v43 >= v38)
              v43 %= v38;
          }
          else
          {
            v43 &= v38 - 1;
          }
          if (v43 != v40)
            break;
        }
      }
    }
  }
  v44 = (float)(unint64_t)(*(_QWORD *)(v34 + 24) + 1);
  v45 = *(float *)(v34 + 32);
  if (!v38 || (float)(v45 * (float)v38) < v44)
  {
    v46 = 1;
    if (v38 >= 3)
      v46 = (v38 & (v38 - 1)) != 0;
    v47 = v46 | (2 * v38);
    v48 = vcvtps_u32_f32(v44 / v45);
    if (v47 <= v48)
      prime = (int8x8_t)v48;
    else
      prime = (int8x8_t)v47;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v38 = *(_QWORD *)(v34 + 8);
    }
    if (*(_QWORD *)&prime > v38)
      goto LABEL_113;
    if (*(_QWORD *)&prime >= v38)
      goto LABEL_85;
    v56 = vcvtps_u32_f32((float)*(unint64_t *)(v34 + 24) / *(float *)(v34 + 32));
    if (v38 < 3 || (v57 = (uint8x8_t)vcnt_s8((int8x8_t)v38), v57.i16[0] = vaddlv_u8(v57), v57.u32[0] > 1uLL))
    {
      v56 = std::__next_prime(v56);
    }
    else
    {
      v58 = 1 << -(char)__clz(v56 - 1);
      if (v56 >= 2)
        v56 = v58;
    }
    if (*(_QWORD *)&prime <= v56)
      prime = (int8x8_t)v56;
    if (*(_QWORD *)&prime >= v38)
    {
      v38 = *(_QWORD *)(v34 + 8);
      goto LABEL_85;
    }
    if (prime)
    {
LABEL_113:
      if (*(_QWORD *)&prime >> 61)
        sub_1D3D6D50C();
      v50 = operator new(8 * *(_QWORD *)&prime);
      v51 = *(void **)v34;
      *(_QWORD *)v34 = v50;
      if (v51)
        operator delete(v51);
      v52 = 0;
      *(int8x8_t *)(v34 + 8) = prime;
      do
        *(_QWORD *)(*(_QWORD *)v34 + 8 * v52++) = 0;
      while (*(_QWORD *)&prime != v52);
      v53 = (_QWORD *)*v37;
      if (*v37)
      {
        v54 = v53[1];
        v55 = (uint8x8_t)vcnt_s8(prime);
        v55.i16[0] = vaddlv_u8(v55);
        if (v55.u32[0] > 1uLL)
        {
          if (v54 >= *(_QWORD *)&prime)
            v54 %= *(_QWORD *)&prime;
        }
        else
        {
          v54 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)v34 + 8 * v54) = v37;
        v59 = (_QWORD *)*v53;
        if (*v53)
        {
          do
          {
            v60 = v59[1];
            if (v55.u32[0] > 1uLL)
            {
              if (v60 >= *(_QWORD *)&prime)
                v60 %= *(_QWORD *)&prime;
            }
            else
            {
              v60 &= *(_QWORD *)&prime - 1;
            }
            if (v60 != v54)
            {
              if (!*(_QWORD *)(*(_QWORD *)v34 + 8 * v60))
              {
                *(_QWORD *)(*(_QWORD *)v34 + 8 * v60) = v53;
                goto LABEL_81;
              }
              *v53 = *v59;
              *v59 = **(_QWORD **)(*(_QWORD *)v34 + 8 * v60);
              **(_QWORD **)(*(_QWORD *)v34 + 8 * v60) = v59;
              v59 = v53;
            }
            v60 = v54;
LABEL_81:
            v53 = v59;
            v59 = (_QWORD *)*v59;
            v54 = v60;
          }
          while (v59);
        }
      }
      v38 = (unint64_t)prime;
    }
    else
    {
      v66 = *(void **)v34;
      *(_QWORD *)v34 = 0;
      if (v66)
        operator delete(v66);
      v38 = 0;
      *(_QWORD *)(v34 + 8) = 0;
    }
  }
LABEL_85:
  v61 = v7[1];
  v62 = (uint8x8_t)vcnt_s8((int8x8_t)v38);
  v62.i16[0] = vaddlv_u8(v62);
  if (v62.u32[0] > 1uLL)
  {
    if (v61 >= v38)
      v61 %= v38;
  }
  else
  {
    v61 &= v38 - 1;
  }
  v63 = *(_QWORD **)(*(_QWORD *)v34 + 8 * v61);
  if (v63)
  {
    *v7 = *v63;
  }
  else
  {
    *v7 = *(_QWORD *)(v34 + 16);
    *(_QWORD *)(v34 + 16) = v7;
    *(_QWORD *)(*(_QWORD *)v34 + 8 * v61) = v37;
    if (!*v7)
      goto LABEL_98;
    v64 = *(_QWORD *)(*v7 + 8);
    if (v62.u32[0] > 1uLL)
    {
      if (v64 >= v38)
        v64 %= v38;
    }
    else
    {
      v64 &= v38 - 1;
    }
    v63 = (_QWORD *)(*(_QWORD *)v34 + 8 * v64);
  }
  *v63 = v7;
LABEL_98:
  ++*(_QWORD *)(v34 + 24);
  v68[0] = 0;
LABEL_99:
  sub_1D3D90528((uint64_t)v68);
  sub_1D3D74C60((unint64_t *)&Mutable);
LABEL_100:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EFE31730);
  return (char *)(v7 + 3);
}

void sub_1D3D904E8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EFE31730);
  _Unwind_Resume(a1);
}

void sub_1D3D90528(uint64_t a1)
{
  unint64_t *v1;

  v1 = *(unint64_t **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1D3D74138(v1 + 3);
    operator delete(v1);
  }
}

CFArrayRef MRCSymbologyCopySupported2DSymbologies()
{
  const __CFAllocator *v0;
  const __CFArray *v1;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v1 = (const __CFArray *)atomic_load((unint64_t *)sub_1D3D8FDA4(1));
  return CFArrayCreateCopy(v0, v1);
}

CFStringRef MRCSymbologyCopyDisplayName(CFTypeRef cf)
{
  _QWORD *v2;
  CFTypeRef v3;
  const void *v4;
  CFHashCode v5;
  int8x8_t v6;
  uint8x8_t v7;
  unint64_t v8;
  CFHashCode v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  const void *v13;
  const void *v14;
  BOOL v15;
  const __CFAllocator *v17;
  const __CFString *v18;
  CFTypeRef v19;

  if (qword_1EFE31720 != -1)
    dispatch_once_f(&qword_1EFE31720, 0, (dispatch_function_t)sub_1D3D90754);
  v2 = (_QWORD *)qword_1EFE31718;
  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  v19 = v3;
  v4 = (const void *)atomic_load((unint64_t *)&v19);
  if (v4)
    v5 = CFHash(v4);
  else
    v5 = 662607004;
  v6 = (int8x8_t)v2[1];
  if (!*(_QWORD *)&v6)
    goto LABEL_28;
  v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v5;
    if (v5 >= *(_QWORD *)&v6)
      v9 = v5 % *(_QWORD *)&v6;
  }
  else
  {
    v9 = (*(_QWORD *)&v6 - 1) & v5;
  }
  v10 = *(_QWORD **)(*v2 + 8 * v9);
  if (!v10 || (v11 = (_QWORD *)*v10) == 0)
  {
LABEL_28:
    sub_1D3D8C70C((unint64_t *)&v19);
    return 0;
  }
  while (1)
  {
    v12 = v11[1];
    if (v12 == v5)
      break;
    if (v8 > 1)
    {
      if (v12 >= *(_QWORD *)&v6)
        v12 %= *(_QWORD *)&v6;
    }
    else
    {
      v12 &= *(_QWORD *)&v6 - 1;
    }
    if (v12 != v9)
      goto LABEL_28;
LABEL_27:
    v11 = (_QWORD *)*v11;
    if (!v11)
      goto LABEL_28;
  }
  v13 = (const void *)atomic_load((unint64_t *)&v19);
  v14 = (const void *)atomic_load(v11 + 2);
  if (v14 != v13)
  {
    v15 = !v13 || v14 == 0;
    if (v15 || !CFEqual(v14, v13))
      goto LABEL_27;
  }
  sub_1D3D8C70C((unint64_t *)&v19);
  v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v18 = (const __CFString *)atomic_load(v11 + 3);
  return CFStringCreateCopy(v17, v18);
}

void sub_1D3D9073C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D8C70C((unint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D3D90754()
{
  uint64_t v0;
  const __CFString *v1;

  v0 = operator new();
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_DWORD *)(v0 + 32) = 1065353216;
  qword_1EFE31718 = v0;
  v1 = CFSTR("Aztec");
  sub_1D3D90AC0((uint64_t *)v0, (CFTypeRef *)kBarcodeTypeAztec, (CFTypeRef *)&v1);
  v1 = CFSTR("Code39");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeCODE39, (CFTypeRef *)&v1);
  v1 = CFSTR("Code39Checksum");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeCODE39checksum, (CFTypeRef *)&v1);
  v1 = CFSTR("Code39FullASCII");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeCODE39fullAscii, (CFTypeRef *)&v1);
  v1 = CFSTR("Code39FullASCIIChecksum");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeCODE39fullAsciiChecksum, (CFTypeRef *)&v1);
  v1 = CFSTR("Code93");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeCODE93, (CFTypeRef *)&v1);
  v1 = CFSTR("Code93i");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeCODE93i, (CFTypeRef *)&v1);
  v1 = CFSTR("Code128");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeCODE128, (CFTypeRef *)&v1);
  v1 = CFSTR("DataMatrix");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)&kBarcodeTypeDataMatrix, (CFTypeRef *)&v1);
  v1 = CFSTR("EAN8");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeEAN8, (CFTypeRef *)&v1);
  v1 = CFSTR("EAN13");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeEAN13, (CFTypeRef *)&v1);
  v1 = CFSTR("I2of5");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeI2OF5, (CFTypeRef *)&v1);
  v1 = CFSTR("I2of5Checksum");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeI2OF5CHECKSUM, (CFTypeRef *)&v1);
  v1 = CFSTR("ITF14");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeITF14, (CFTypeRef *)&v1);
  v1 = CFSTR("PDF417");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypePDF417, (CFTypeRef *)&v1);
  v1 = CFSTR("QR");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeQR, (CFTypeRef *)&v1);
  v1 = CFSTR("UPCE");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)kBarcodeTypeUPCE, (CFTypeRef *)&v1);
  v1 = CFSTR("MSIPlessey");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)MRCSymbologyMSIPlessey, (CFTypeRef *)&v1);
  v1 = CFSTR("Codabar");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)MRCSymbologyCodabar, (CFTypeRef *)&v1);
  v1 = CFSTR("GS1DataBar");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)MRCSymbologyGS1DataBar, (CFTypeRef *)&v1);
  v1 = CFSTR("GS1DataBarExpanded");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)&MRCSymbologyGS1DataBarExpanded, (CFTypeRef *)&v1);
  v1 = CFSTR("GS1DataBarLimited");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)MRCSymbologyGS1DataBarLimited, (CFTypeRef *)&v1);
  v1 = CFSTR("MicroQR");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)MRCSymbologyMicroQR, (CFTypeRef *)&v1);
  v1 = CFSTR("MicroPDF417");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)MRCSymbologyMicroPDF417, (CFTypeRef *)&v1);
  v1 = CFSTR("AppClipCode");
  sub_1D3D90AC0((uint64_t *)qword_1EFE31718, (CFTypeRef *)&MRCSymbologyAppClipCode, (CFTypeRef *)&v1);
}

void sub_1D3D90AC0(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  unint64_t *v6;
  CFTypeRef v7;
  CFTypeRef v8;
  CFHashCode v9;
  const void *v10;
  CFHashCode v11;
  const void *v12;
  unint64_t v13;
  uint8x8_t v14;
  unint64_t v15;
  CFHashCode v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  const void *v20;
  const void *v21;
  BOOL v22;
  unint64_t *v23;
  float v24;
  float v25;
  int8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  _BOOL8 v29;
  unint64_t v30;
  unint64_t v31;
  int8x8_t prime;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  int8x8_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  uint8x8_t v42;
  unint64_t v43;
  uint8x8_t v44;
  uint64_t v45;
  _QWORD *v46;
  unint64_t v47;
  void *v48;

  v6 = (unint64_t *)operator new(0x20uLL);
  *v6 = 0;
  v6[1] = 0;
  v7 = *a2;
  if (*a2)
    v7 = CFRetain(v7);
  v6[2] = (unint64_t)v7;
  v8 = *a3;
  if (*a3)
    v8 = CFRetain(v8);
  v9 = 662607004;
  v6[3] = (unint64_t)v8;
  v10 = (const void *)atomic_load(v6 + 2);
  v11 = 662607004;
  if (v10)
    v11 = CFHash(v10);
  v6[1] = v11;
  v12 = (const void *)atomic_load(v6 + 2);
  if (v12)
    v9 = CFHash(v12);
  v6[1] = v9;
  v13 = a1[1];
  if (!v13)
    goto LABEL_30;
  v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
  v14.i16[0] = vaddlv_u8(v14);
  v15 = v14.u32[0];
  if (v14.u32[0] > 1uLL)
  {
    v16 = v9;
    if (v13 <= v9)
      v16 = v9 % v13;
  }
  else
  {
    v16 = (v13 - 1) & v9;
  }
  v17 = *(_QWORD **)(*a1 + 8 * v16);
  if (!v17 || (v18 = (_QWORD *)*v17) == 0)
  {
LABEL_30:
    v23 = (unint64_t *)(a1 + 2);
    v24 = (float)(unint64_t)(a1[3] + 1);
    v25 = *((float *)a1 + 8);
    if (v13 && (float)(v25 * (float)v13) >= v24)
      goto LABEL_32;
    v29 = 1;
    if (v13 >= 3)
      v29 = (v13 & (v13 - 1)) != 0;
    v30 = v29 | (2 * v13);
    v31 = vcvtps_u32_f32(v24 / v25);
    if (v30 <= v31)
      prime = (int8x8_t)v31;
    else
      prime = (int8x8_t)v30;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v36 = (int8x8_t)a1[1];
    if (*(_QWORD *)&prime <= *(_QWORD *)&v36)
    {
      if (*(_QWORD *)&prime >= *(_QWORD *)&v36)
        goto LABEL_32;
      v43 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (*(_QWORD *)&v36 < 3uLL || (v44 = (uint8x8_t)vcnt_s8(v36), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
      {
        v43 = std::__next_prime(v43);
      }
      else
      {
        v45 = 1 << -(char)__clz(v43 - 1);
        if (v43 >= 2)
          v43 = v45;
      }
      if (*(_QWORD *)&prime <= v43)
        prime = (int8x8_t)v43;
      if (*(_QWORD *)&prime >= *(_QWORD *)&v36)
        goto LABEL_32;
      if (!*(_QWORD *)&prime)
      {
        v48 = (void *)*a1;
        *a1 = 0;
        if (v48)
          operator delete(v48);
        a1[1] = 0;
        goto LABEL_32;
      }
    }
    if (*(_QWORD *)&prime >> 61)
      sub_1D3D6D50C();
    v37 = operator new(8 * *(_QWORD *)&prime);
    v38 = (void *)*a1;
    *a1 = (uint64_t)v37;
    if (v38)
      operator delete(v38);
    v39 = 0;
    a1[1] = (uint64_t)prime;
    do
      *(_QWORD *)(*a1 + 8 * v39++) = 0;
    while (*(_QWORD *)&prime != v39);
    v40 = (_QWORD *)*v23;
    if (*v23)
    {
      v41 = v40[1];
      v42 = (uint8x8_t)vcnt_s8(prime);
      v42.i16[0] = vaddlv_u8(v42);
      if (v42.u32[0] > 1uLL)
      {
        if (v41 >= *(_QWORD *)&prime)
          v41 %= *(_QWORD *)&prime;
      }
      else
      {
        v41 &= *(_QWORD *)&prime - 1;
      }
      *(_QWORD *)(*a1 + 8 * v41) = v23;
      v46 = (_QWORD *)*v40;
      if (*v40)
      {
        do
        {
          v47 = v46[1];
          if (v42.u32[0] > 1uLL)
          {
            if (v47 >= *(_QWORD *)&prime)
              v47 %= *(_QWORD *)&prime;
          }
          else
          {
            v47 &= *(_QWORD *)&prime - 1;
          }
          if (v47 != v41)
          {
            if (!*(_QWORD *)(*a1 + 8 * v47))
            {
              *(_QWORD *)(*a1 + 8 * v47) = v40;
              goto LABEL_81;
            }
            *v40 = *v46;
            *v46 = **(_QWORD **)(*a1 + 8 * v47);
            **(_QWORD **)(*a1 + 8 * v47) = v46;
            v46 = v40;
          }
          v47 = v41;
LABEL_81:
          v40 = v46;
          v46 = (_QWORD *)*v46;
          v41 = v47;
        }
        while (v46);
      }
    }
LABEL_32:
    v26 = (int8x8_t)a1[1];
    v27 = v6[1];
    v28 = (uint8x8_t)vcnt_s8(v26);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      if (v27 >= *(_QWORD *)&v26)
        v27 %= *(_QWORD *)&v26;
    }
    else
    {
      v27 &= *(_QWORD *)&v26 - 1;
    }
    v33 = *a1;
    v34 = *(unint64_t **)(*a1 + 8 * v27);
    if (v34)
    {
      *v6 = *v34;
    }
    else
    {
      *v6 = *v23;
      *v23 = (unint64_t)v6;
      *(_QWORD *)(v33 + 8 * v27) = v23;
      if (!*v6)
      {
LABEL_69:
        ++a1[3];
        return;
      }
      v35 = *(_QWORD *)(*v6 + 8);
      if (v28.u32[0] > 1uLL)
      {
        if (v35 >= *(_QWORD *)&v26)
          v35 %= *(_QWORD *)&v26;
      }
      else
      {
        v35 &= *(_QWORD *)&v26 - 1;
      }
      v34 = (unint64_t *)(*a1 + 8 * v35);
    }
    *v34 = (unint64_t)v6;
    goto LABEL_69;
  }
  while (1)
  {
    v19 = v18[1];
    if (v19 == v9)
      break;
    if (v15 > 1)
    {
      if (v19 >= v13)
        v19 %= v13;
    }
    else
    {
      v19 &= v13 - 1;
    }
    if (v19 != v16)
      goto LABEL_30;
LABEL_29:
    v18 = (_QWORD *)*v18;
    if (!v18)
      goto LABEL_30;
  }
  v20 = (const void *)atomic_load(v6 + 2);
  v21 = (const void *)atomic_load(v18 + 2);
  if (v21 != v20)
  {
    v22 = !v20 || v21 == 0;
    if (v22 || !CFEqual(v21, v20))
      goto LABEL_29;
  }
  sub_1D3D90F74(1, v6);
}

void sub_1D3D90F38(_Unwind_Exception *a1)
{
  unint64_t *v1;

  sub_1D3D90F74(1, v1);
  _Unwind_Resume(a1);
}

void sub_1D3D90F74(char a1, unint64_t *__p)
{
  if (a1)
  {
    sub_1D3D8C70C(__p + 3);
    sub_1D3D8C70C(__p + 2);
  }
  operator delete(__p);
}

CFSetRef sub_1D3D90FB0()
{
  CFSetRef result;
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1E95B0AE0;
  v1[1] = *(_OWORD *)&off_1E95B0AF0;
  result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)v1, 4, MEMORY[0x1E0C9B3B0]);
  qword_1EDB89FF8 = (uint64_t)result;
  return result;
}

unint64_t sub_1D3D9102C(unint64_t *a1)
{
  unint64_t v2;
  const __CFDictionary *v3;
  const void *v4;
  unint64_t Value;
  int v6;
  unsigned int v7;

  if (qword_1EDB89FD0 != -1)
    dispatch_once_f(&qword_1EDB89FD0, 0, (dispatch_function_t)sub_1D3D910BC);
  v2 = atomic_load(a1);
  if (!v2)
    goto LABEL_7;
  v3 = (const __CFDictionary *)qword_1EDB89FC8;
  v4 = (const void *)atomic_load(a1);
  Value = (unint64_t)CFDictionaryGetValue(v3, v4);
  if (!Value)
  {
    v2 = 0;
LABEL_7:
    v7 = 0;
    v6 = 0;
    return v2 | v6 | v7;
  }
  v6 = ((Value >> 4) - 1) & 0xFFFFFF00;
  v7 = ((Value >> 4) - 1);
  v2 = 0x100000000;
  return v2 | v6 | v7;
}

CFDictionaryRef sub_1D3D910BC()
{
  CFDictionaryRef result;
  CFDictionaryValueCallBacks v1;
  void *values[2];
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  void *keys[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  const __CFString *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v29 = xmmword_1E95B0BC0;
  v30 = *(_OWORD *)&off_1E95B0BD0;
  v31 = CFSTR("PseudoExternal");
  v25 = xmmword_1E95B0B80;
  v26 = *(_OWORD *)&off_1E95B0B90;
  v27 = xmmword_1E95B0BA0;
  v28 = *(_OWORD *)&off_1E95B0BB0;
  v21 = xmmword_1E95B0B40;
  v22 = *(_OWORD *)&off_1E95B0B50;
  v23 = xmmword_1E95B0B60;
  v24 = *(_OWORD *)&off_1E95B0B70;
  *(_OWORD *)keys = xmmword_1E95B0B00;
  v18 = *(_OWORD *)&off_1E95B0B10;
  v19 = xmmword_1E95B0B20;
  v20 = *(_OWORD *)&off_1E95B0B30;
  v12 = xmmword_1D3E61C40;
  v13 = unk_1D3E61C50;
  v14 = xmmword_1D3E61C60;
  v15 = unk_1D3E61C70;
  v8 = xmmword_1D3E61C00;
  v9 = unk_1D3E61C10;
  v10 = xmmword_1D3E61C20;
  v11 = unk_1D3E61C30;
  v4 = xmmword_1D3E61BC0;
  v5 = unk_1D3E61BD0;
  v6 = xmmword_1D3E61BE0;
  v7 = unk_1D3E61BF0;
  *(_OWORD *)values = xmmword_1D3E61BA0;
  v3 = unk_1D3E61BB0;
  v16 = 64;
  memset(&v1, 0, sizeof(v1));
  result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 29, MEMORY[0x1E0C9B390], &v1);
  qword_1EDB89FC8 = (uint64_t)result;
  return result;
}

unint64_t sub_1D3D911D4(unint64_t *a1)
{
  unint64_t v2;
  const __CFDictionary *v3;
  const void *v4;
  unint64_t Value;
  int v6;
  unsigned int v7;

  if (qword_1EDB893C0 != -1)
    dispatch_once_f(&qword_1EDB893C0, 0, (dispatch_function_t)sub_1D3D91264);
  v2 = atomic_load(a1);
  if (!v2)
    goto LABEL_7;
  v3 = (const __CFDictionary *)qword_1EDB893B8;
  v4 = (const void *)atomic_load(a1);
  Value = (unint64_t)CFDictionaryGetValue(v3, v4);
  if (!Value)
  {
    v2 = 0;
LABEL_7:
    v7 = 0;
    v6 = 0;
    return v2 | v6 | v7;
  }
  v6 = ((Value >> 4) - 1) & 0xFFFFFF00;
  v7 = ((Value >> 4) - 1);
  v2 = 0x100000000;
  return v2 | v6 | v7;
}

CFDictionaryRef sub_1D3D91264()
{
  CFDictionaryRef result;
  CFDictionaryValueCallBacks v1;
  void *values[2];
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  void *keys[2];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  const __CFString *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v25 = xmmword_1E95B0C88;
  v26 = *(_OWORD *)off_1E95B0C98;
  v27 = CFSTR("AppClipCode");
  v21 = xmmword_1E95B0C48;
  v22 = *(_OWORD *)&off_1E95B0C58;
  v23 = xmmword_1E95B0C68;
  v24 = *(_OWORD *)&off_1E95B0C78;
  v17 = xmmword_1E95B0C08;
  v18 = *(_OWORD *)&off_1E95B0C18;
  v19 = xmmword_1E95B0C28;
  v20 = *(_OWORD *)&off_1E95B0C38;
  *(_OWORD *)keys = xmmword_1E95B0BE8;
  v16 = *(_OWORD *)&off_1E95B0BF8;
  v10 = xmmword_1D3E61D08;
  v11 = unk_1D3E61D18;
  v12 = xmmword_1D3E61D28;
  v13 = unk_1D3E61D38;
  v6 = xmmword_1D3E61CC8;
  v7 = unk_1D3E61CD8;
  v8 = xmmword_1D3E61CE8;
  v9 = unk_1D3E61CF8;
  *(_OWORD *)values = xmmword_1D3E61C88;
  v3 = unk_1D3E61C98;
  v4 = xmmword_1D3E61CA8;
  v5 = unk_1D3E61CB8;
  v14 = 80;
  memset(&v1, 0, sizeof(v1));
  result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 25, MEMORY[0x1E0C9B390], &v1);
  qword_1EDB893B8 = (uint64_t)result;
  return result;
}

void sub_1D3D9136C()
{
  uint64_t v0;

  v0 = operator new();
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_DWORD *)(v0 + 32) = 1065353216;
  qword_1EDB89FD8 = v0;
  sub_1D3D9153C((float *)v0, 1, 1);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 1, 1);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 2, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 1, 1);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 2);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 2);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 3);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 0, 2);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 1, 1);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 2, 0);
  sub_1D3D9153C((float *)qword_1EDB89FD8, 3, 4);
}

void sub_1D3D9153C(float *a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t *i;
  unint64_t v14;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  int8x8_t prime;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  uint8x8_t v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t v33;
  uint8x8_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  _QWORD *v38;

  v6 = operator new(0x18uLL);
  v7 = v6;
  *((_DWORD *)v6 + 4) = a2;
  *((_DWORD *)v6 + 5) = a3;
  v8 = a3 ^ a2;
  *v6 = 0;
  v6[1] = v8;
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v11 = a3 ^ a2;
      if (v9 <= v8)
        v11 = v8 % v9;
    }
    else
    {
      v11 = (v9 - 1) & v8;
    }
    v12 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v11);
    if (v12)
    {
      for (i = *v12; i; i = (uint64_t *)*i)
      {
        v14 = i[1];
        if (v14 == v8)
        {
          if (*((_DWORD *)i + 4) == a2 && *((_DWORD *)i + 5) == a3)
          {
            operator delete(v6);
            return;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v11)
            break;
        }
      }
    }
  }
  v16 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v17 = a1[8];
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      prime = (int8x8_t)v20;
    else
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v9 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v9)
      goto LABEL_88;
    if (*(_QWORD *)&prime >= v9)
      goto LABEL_62;
    v28 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v9 < 3 || (v29 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
    {
      v28 = std::__next_prime(v28);
    }
    else
    {
      v30 = 1 << -(char)__clz(v28 - 1);
      if (v28 >= 2)
        v28 = v30;
    }
    if (*(_QWORD *)&prime <= v28)
      prime = (int8x8_t)v28;
    if (*(_QWORD *)&prime >= v9)
    {
      v9 = *((_QWORD *)a1 + 1);
      goto LABEL_62;
    }
    if (prime)
    {
LABEL_88:
      if (*(_QWORD *)&prime >> 61)
        sub_1D3D6D50C();
      v22 = operator new(8 * *(_QWORD *)&prime);
      v23 = *(_QWORD **)a1;
      *(_QWORD *)a1 = v22;
      if (v23)
        operator delete(v23);
      v24 = 0;
      *((int8x8_t *)a1 + 1) = prime;
      do
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v24++) = 0;
      while (*(_QWORD *)&prime != v24);
      v25 = (_QWORD *)*((_QWORD *)a1 + 2);
      if (v25)
      {
        v26 = v25[1];
        v27 = (uint8x8_t)vcnt_s8(prime);
        v27.i16[0] = vaddlv_u8(v27);
        if (v27.u32[0] > 1uLL)
        {
          if (v26 >= *(_QWORD *)&prime)
            v26 %= *(_QWORD *)&prime;
        }
        else
        {
          v26 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v26) = a1 + 4;
        v31 = (_QWORD *)*v25;
        if (*v25)
        {
          do
          {
            v32 = v31[1];
            if (v27.u32[0] > 1uLL)
            {
              if (v32 >= *(_QWORD *)&prime)
                v32 %= *(_QWORD *)&prime;
            }
            else
            {
              v32 &= *(_QWORD *)&prime - 1;
            }
            if (v32 != v26)
            {
              if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v32))
              {
                *(_QWORD *)(*(_QWORD *)a1 + 8 * v32) = v25;
                goto LABEL_58;
              }
              *v25 = *v31;
              *v31 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v32);
              **(_QWORD **)(*(_QWORD *)a1 + 8 * v32) = v31;
              v31 = v25;
            }
            v32 = v26;
LABEL_58:
            v25 = v31;
            v31 = (_QWORD *)*v31;
            v26 = v32;
          }
          while (v31);
        }
      }
      v9 = (unint64_t)prime;
    }
    else
    {
      v38 = *(_QWORD **)a1;
      *(_QWORD *)a1 = 0;
      if (v38)
        operator delete(v38);
      v9 = 0;
      *((_QWORD *)a1 + 1) = 0;
    }
  }
LABEL_62:
  v33 = v7[1];
  v34 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v34.i16[0] = vaddlv_u8(v34);
  if (v34.u32[0] > 1uLL)
  {
    if (v33 >= v9)
      v33 %= v9;
  }
  else
  {
    v33 &= v9 - 1;
  }
  v35 = *(_QWORD **)a1;
  v36 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v33);
  if (v36)
  {
    *v7 = *v36;
LABEL_74:
    *v36 = v7;
    goto LABEL_75;
  }
  *v7 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v7;
  v35[v33] = a1 + 4;
  if (*v7)
  {
    v37 = *(_QWORD *)(*v7 + 8);
    if (v34.u32[0] > 1uLL)
    {
      if (v37 >= v9)
        v37 %= v9;
    }
    else
    {
      v37 &= v9 - 1;
    }
    v36 = (_QWORD *)(*(_QWORD *)a1 + 8 * v37);
    goto LABEL_74;
  }
LABEL_75:
  ++*((_QWORD *)a1 + 3);
}

void sub_1D3D91934(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1D3D91948(unint64_t *a1, int a2)
{
  unint64_t v4;
  const __CFSet *v5;
  const void *v6;
  int v7;
  int8x8_t v8;
  unint64_t v9;
  uint8x8_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *i;
  unint64_t v16;

  if (qword_1EDB8A000 != -1)
    dispatch_once_f(&qword_1EDB8A000, 0, (dispatch_function_t)sub_1D3D90FB0);
  v4 = atomic_load(a1);
  if (v4 && (v5 = (const __CFSet *)qword_1EDB89FF8, v6 = (const void *)atomic_load(a1), CFSetContainsValue(v5, v6)))
  {
    v7 = sub_1D3D9102C(a1);
    if (qword_1EDB89FE0 != -1)
      dispatch_once_f(&qword_1EDB89FE0, 0, (dispatch_function_t)sub_1D3D9136C);
    v8 = *(int8x8_t *)(qword_1EDB89FD8 + 8);
    if (v8)
    {
      v9 = v7 ^ a2;
      v10 = (uint8x8_t)vcnt_s8(v8);
      v10.i16[0] = vaddlv_u8(v10);
      if (v10.u32[0] > 1uLL)
      {
        v11 = v7 ^ a2;
        if (*(_QWORD *)&v8 <= v9)
          v11 = v9 % *(_QWORD *)&v8;
      }
      else
      {
        v11 = (*(_QWORD *)&v8 - 1) & v9;
      }
      i = *(uint64_t **)(*(_QWORD *)qword_1EDB89FD8 + 8 * v11);
      if (i)
      {
        for (i = (uint64_t *)*i; i; i = (uint64_t *)*i)
        {
          v16 = i[1];
          if (v16 == v9)
          {
            if (*((_DWORD *)i + 4) == v7 && *((_DWORD *)i + 5) == a2)
              return i != 0;
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v16 >= *(_QWORD *)&v8)
                v16 %= *(_QWORD *)&v8;
            }
            else
            {
              v16 &= *(_QWORD *)&v8 - 1;
            }
            if (v16 != v11)
              goto LABEL_34;
          }
        }
      }
    }
    else
    {
LABEL_34:
      i = 0;
    }
    return i != 0;
  }
  else
  {
    v12 = sub_1D3D911D4(a1);
    return HIDWORD(v12) && (_DWORD)v12 == a2;
  }
}

unsigned int **sub_1D3D91AD4(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

double sub_1D3D91B04@<D0>(uint64_t a1@<X8>)
{
  double result;

  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_QWORD *)(a1 + 84) = 0;
  *(_QWORD *)(a1 + 96) = a1 + 104;
  *(_BYTE *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  return result;
}

uint64_t sub_1D3D91B44(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF280;
  sub_1D3D91BB4((unsigned int **)(a1 + 16));
  return a1;
}

void sub_1D3D91B74(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF280;
  sub_1D3D91BB4((unsigned int **)(a1 + 16));
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3D91BB4(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

void sub_1D3D91BE8()
{
  JUMPOUT(0x1D8254C54);
}

void sub_1D3D91BFC(uint64_t a1@<X1>, unsigned __int8 **a2@<X2>, uint64_t a3@<X8>)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned int i;
  int v10;
  unint64_t v11;
  _BYTE *v12;
  unsigned __int8 *v13;
  int v14;
  unsigned __int8 *v15;
  char *v16;
  int v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  int v24;
  int *v25;
  int v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t (***v35)();
  _BYTE *v36;
  uint64_t (***v37)();
  _BYTE *v38;
  std::wstring::value_type *v39;
  int *v40;
  int v41;
  int v42;
  int v43;
  float v44;
  int v45;
  float v47;
  int v48;
  uint64_t j;
  int v50;
  uint64_t k;
  int v52;
  uint64_t m;
  float v54;
  float v55;
  float v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t n;
  int v61;
  float v62;
  int v63;
  float v64;
  BOOL v65;
  uint64_t v67;
  int v68;
  uint64_t v69;
  int v70;
  std::wstring::value_type *v71;
  std::wstring::value_type v72;
  int v73;
  uint64_t v74;
  int v75;
  std::wstring::value_type *v76;
  std::wstring::value_type v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  int v87;
  int v88;
  unint64_t v89;
  uint64_t ii;
  unint64_t v91;
  std::wstring::size_type size;
  uint64_t v93;
  int v94;
  std::wstring *v95;
  int v96;
  int v97;
  std::wstring::value_type v98;
  uint64_t v99;
  char v100;
  int *v101;
  unsigned int v102;
  int *v103;
  int v104;
  int *v105;
  int v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  float v110;
  int v111;
  int v112;
  _BYTE *v113;
  _QWORD *v114;
  uint64_t v115;
  uint64_t (***v116)();
  std::wstring::value_type *v117;
  BOOL v118;
  uint64_t v119;
  uint64_t v120;
  void *__p;
  char *v122;
  unint64_t v123;
  uint64_t v124;
  _BYTE v125[16];
  _QWORD v126[2];
  int v127[4];
  uint64_t (**v128)();
  uint64_t (**v129)();
  _BYTE v130[12];
  int v131;
  void *v132;
  char v133;
  uint64_t (**v134)();
  _BYTE __dst[52];
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  _DWORD v142[14];
  std::wstring v143;
  uint64_t v144;

  v144 = *MEMORY[0x1E0C80C00];
  __p = 0;
  v122 = 0;
  v123 = 0;
  sub_1D3D92760(&__p, 0x2FuLL);
  v7 = *a2;
  v6 = a2[1];
  if (v6 == *a2)
    goto LABEL_34;
  v8 = *a2;
  while (*v8)
  {
    if (++v8 == v6)
    {
      v8 = a2[1];
      break;
    }
  }
  if (v8 == v6)
  {
LABEL_34:
    *(_DWORD *)a3 = 1;
    *(_QWORD *)(a3 + 112) = 0;
    *(_QWORD *)(a3 + 104) = 0;
    *(_OWORD *)(a3 + 4) = 0u;
    *(_OWORD *)(a3 + 20) = 0u;
    *(_OWORD *)(a3 + 36) = 0u;
    *(_OWORD *)(a3 + 52) = 0u;
    *(_OWORD *)(a3 + 68) = 0u;
    *(_QWORD *)(a3 + 84) = 0;
    *(_QWORD *)(a3 + 96) = a3 + 104;
    *(_BYTE *)(a3 + 120) = 0;
    *(_DWORD *)(a3 + 124) = 0;
    *(_DWORD *)(a3 + 128) = 0;
    v25 = (int *)__p;
    if (!__p)
      return;
    goto LABEL_35;
  }
  v119 = a1;
  v120 = a3;
  for (i = 0; v7 != v8; i += v10)
    v10 = *v7++;
  v11 = v123;
  v12 = __p;
  v13 = v8;
  while (1)
  {
    v14 = *v8 == 0;
    v15 = &v8[v6 - v13];
    while (*v8 != v14)
    {
      if (++v8 == v6)
      {
        v8 = v15;
        break;
      }
    }
    v16 = v122;
    if (v8 == v6)
      break;
    v17 = (_DWORD)v8 - (_DWORD)v13;
    if ((unint64_t)v122 >= v11)
    {
      v19 = (v122 - v12) >> 2;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 62)
        goto LABEL_128;
      if ((uint64_t)(v11 - (_QWORD)v12) >> 1 > v20)
        v20 = (uint64_t)(v11 - (_QWORD)v12) >> 1;
      if (v11 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
        v21 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v21 = v20;
      if (v21)
        v21 = (unint64_t)sub_1D3D82278(v21);
      else
        v22 = 0;
      v23 = (char *)(v21 + 4 * v19);
      *(_DWORD *)v23 = v17;
      v18 = v23 + 4;
      while (v16 != v12)
      {
        v24 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v23 - 1) = v24;
        v23 -= 4;
      }
      v11 = v21 + 4 * v22;
      __p = v23;
      v123 = v11;
      if (v12)
        operator delete(v12);
      v12 = v23;
    }
    else
    {
      *(_DWORD *)v122 = v17;
      v18 = v16 + 4;
    }
    v122 = v18;
    v6 = a2[1];
    v13 = v8;
    if (v6 == v8)
      goto LABEL_38;
  }
  v18 = v122;
LABEL_38:
  v26 = (_DWORD)v8 - (_DWORD)v13;
  if ((unint64_t)v18 >= v11)
  {
    v28 = (v18 - v12) >> 2;
    v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 62)
LABEL_128:
      sub_1D3D6D4F8();
    if ((uint64_t)(v11 - (_QWORD)v12) >> 1 > v29)
      v29 = (uint64_t)(v11 - (_QWORD)v12) >> 1;
    if (v11 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v30 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v30 = v29;
    if (v30)
      v30 = (unint64_t)sub_1D3D82278(v30);
    else
      v31 = 0;
    v25 = (int *)(v30 + 4 * v28);
    *v25 = v26;
    v27 = (char *)(v25 + 1);
    while (v18 != v12)
    {
      v32 = *((_DWORD *)v18 - 1);
      v18 -= 4;
      *--v25 = v32;
    }
    __p = v25;
    v123 = v30 + 4 * v31;
    if (v12)
      operator delete(v12);
  }
  else
  {
    *(_DWORD *)v18 = v26;
    v25 = (int *)__p;
    v27 = v18 + 4;
  }
  v122 = v27;
  if ((unint64_t)(v27 - (char *)v25) < 0xBC)
  {
LABEL_115:
    *(_DWORD *)v120 = 1;
    *(_QWORD *)(v120 + 104) = 0;
    *(_QWORD *)(v120 + 112) = 0;
    *(_OWORD *)(v120 + 4) = 0u;
    *(_OWORD *)(v120 + 20) = 0u;
    *(_OWORD *)(v120 + 36) = 0u;
    *(_OWORD *)(v120 + 52) = 0u;
    *(_OWORD *)(v120 + 68) = 0u;
    *(_QWORD *)(v120 + 84) = 0;
    *(_QWORD *)(v120 + 96) = v120 + 104;
    *(_BYTE *)(v120 + 120) = 0;
    *(_DWORD *)(v120 + 124) = 0;
    *(_DWORD *)(v120 + 128) = 0;
    if (!v25)
      return;
    goto LABEL_35;
  }
  v33 = 0;
  v34 = 0;
  v35 = &v128;
  v36 = v130;
  v37 = &v129;
  v38 = v125;
  v39 = &v127[1];
  while (1)
  {
    v40 = &v25[v34];
    v41 = v40[1];
    v43 = v40[44];
    v42 = v40[45];
    v44 = (float)v41;
    if (*v40 < v41 && (float)(vabds_f32((float)*v40, v44) / (float)(v41 + *v40)) >= 0.3)
      goto LABEL_114;
    v45 = v40[46];
    if ((float)(vabds_f32((float)v45, (float)v42) / (float)(v45 + v42)) >= 0.3 && v45 < v42)
      goto LABEL_114;
    v47 = (float)v43;
    if ((float)(vabds_f32((float)v42, (float)v43) / (float)(v43 + v42)) >= 0.3)
      goto LABEL_114;
    v48 = 0;
    for (j = 2; j != 16; ++j)
      v48 += v25[v33 + j];
    v50 = 0;
    for (k = 16; k != 30; ++k)
      v50 += v25[v33 + k];
    v52 = 0;
    for (m = 30; m != 44; ++m)
      v52 += v25[v33 + m];
    v54 = (float)v48 / 26.0;
    if ((float)(vabds_f32(v44, v54) / (float)(v54 + v44)) >= 0.3)
      goto LABEL_114;
    v55 = (float)v50 / 18.0;
    if ((float)(vabds_f32(v54, v55) / (float)(v54 + v55)) >= 0.3)
      goto LABEL_114;
    v56 = (float)v52 / 26.0;
    if ((float)(vabds_f32(v55, v56) / (float)(v55 + v56)) >= 0.3
      || (float)(vabds_f32(v56, v47) / (float)(v56 + v47)) >= 0.3)
    {
      goto LABEL_114;
    }
    v117 = v39;
    v113 = v36;
    v114 = v38;
    v115 = (uint64_t)v37;
    memmove(__dst, v40 + 2, 0xA8uLL);
    v57 = 0;
    v58 = 0;
    do
    {
      v58 += *(_DWORD *)&__dst[v57];
      v57 += 4;
    }
    while (v57 != 56);
    v116 = v35;
    v59 = 0;
    for (n = 56; n != 112; n += 4)
      v59 += *(_DWORD *)&__dst[n];
    v61 = 0;
    do
    {
      v61 += *(_DWORD *)&__dst[n];
      n += 4;
    }
    while (n != 168);
    v62 = (float)v59 / 18.0;
    v63 = v141;
    v64 = (float)(v141 + v140);
    v65 = (float)(v62 * 2.5) >= v64 && (float)(v62 * 1.5) <= v64;
    if (v65 && (float)(v62 * 2.5) <= (float)(v139 + v138))
    {
      v67 = 0;
      v68 = 1;
      v131 = 1;
      while (v67 != -13)
      {
        v68 = (int)(float)(roundf((float)(*(int *)((char *)&v140 + v67 * 4) + v142[v67 - 1]) / v62) - (float)v68);
        *(_DWORD *)&v130[v67 * 4 + 8] = v68;
        --v67;
        if (v68 < 1)
          goto LABEL_113;
      }
      v69 = 0;
      v70 = 0;
      v71 = v127;
      do
      {
        v72 = *v71;
        v71 += 2;
        v143.__r_.__value_.__s.__data_[v69] = v72;
        v70 += v72;
        ++v69;
      }
      while (v69 != 6);
      if (v70 == 8)
      {
        v112 = v63;
        v73 = sub_1D3DFDC3C((int *)&v143, 6u, 3, 1);
        v74 = 0;
        v75 = 0;
        v76 = v117;
        do
        {
          v77 = *v76;
          v76 += 2;
          v143.__r_.__value_.__s.__data_[v74] = v77;
          v75 += v77;
          ++v74;
        }
        while (v74 != 6);
        if (v75 == 8)
        {
          v78 = dword_1D3E61DE4[(int)(sub_1D3DFDC3C((int *)&v143, 6u, 3, 0) + 21 * v73)];
          if ((v78 & 0x80000000) == 0)
          {
            v111 = v78;
            v79 = v136;
            v80 = (int)(float)(roundf((float)(v137 + v136) / v62) - (float)v127[0]);
            v131 = v80;
            v81 = 12;
            while (v81 != -1)
            {
              v82 = *(_DWORD *)&__dst[v81 * 4];
              v80 = (int)(float)(roundf((float)(v82 + v79) / (float)((float)v58 / 26.0)) - (float)v80);
              v127[v81--] = v80;
              v79 = v82;
              if (v80 < 1)
                goto LABEL_113;
            }
            v83 = sub_1D3D927E8(v127);
            if (HIDWORD(v83))
            {
              v84 = 0;
              v85 = 0;
              do
              {
                v85 = (v85 + v127[v84] * byte_1D3E61DC6[v84]) % 89;
                ++v84;
              }
              while (v84 != 14);
              v86 = 0;
              v87 = (int)(float)(roundf((float)(v142[0] + v112) / v62) + -1.0);
              v127[0] = v87;
              while (v86 != 13)
              {
                v87 = (int)(float)(roundf((float)(v142[v86 + 1] + v142[v86]) / (float)((float)v61 / 26.0)) - (float)v87);
                v127[++v86] = v87;
                if (v87 <= 0)
                  goto LABEL_113;
              }
              v88 = v83;
              v89 = sub_1D3D927E8(v127);
              if (HIDWORD(v89))
              {
                for (ii = 0; ii != 14; ++ii)
                  v85 = (v85 + v127[ii] * byte_1D3E61DD4[ii]) % 89;
                if (v111 == v85)
                  break;
              }
            }
          }
        }
      }
    }
LABEL_113:
    v37 = (uint64_t (***)())v115;
    v35 = v116;
    v36 = v113;
    v38 = v114;
    v39 = v117;
LABEL_114:
    v91 = v34 + 49;
    v34 += 2;
    v33 += 2;
    if (v91 > (v27 - (char *)v25) >> 2)
      goto LABEL_115;
  }
  v118 = (int)v89 + 2013571 * v88 > 0x1D52F517BD7;
  sub_1D3D92968((uint64_t)v127);
  *(_QWORD *)((char *)*(v128 - 3) + (_QWORD)v113) = 13;
  sub_1D3D92A5C(v116, 48);
  std::wostream::operator<<();
  sub_1D3D92AFC(&v143, v115);
  size = v143.__r_.__value_.__l.__size_;
  if ((v143.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v143.__r_.__value_.__r.__words[2]);
  if (size)
  {
    v93 = 0;
    v94 = 0;
    v95 = &v143;
    if ((v143.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v95 = (std::wstring *)v143.__r_.__value_.__r.__words[0];
    do
    {
      v96 = v95->__r_.__value_.__s.__data_[v93] - 48;
      if ((v93 & 1) == 0)
        v96 *= 3;
      v94 += v96;
      ++v93;
    }
    while (size != v93);
    v97 = v94 % 10;
    if (v97 > 0)
      v97 = 10 - v97;
    v98 = v97 + 48;
  }
  else
  {
    v98 = 48;
  }
  std::wstring::append(&v143, 1uLL, v98);
  sub_1D3D92BD4(&v124, (const void **)&v143.__r_.__value_.__l.__data_);
  v99 = v124;
  v126[0] = *v114;
  *(_QWORD *)((char *)v126 + 7) = *(_QWORD *)((char *)v114 + 7);
  v100 = v125[15];
  if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v143.__r_.__value_.__l.__data_);
  *(_QWORD *)v127 = off_1E95B0270;
  v134 = off_1E95B02C0;
  v128 = off_1E95B0298;
  v129 = off_1E95B01C0;
  if (v133 < 0)
    operator delete(v132);
  v101 = v40 + 46;
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1D8254C00](&v134);
  v102 = i;
  if (v40 + 1 != v25)
  {
    v103 = v25 - 1;
    v102 = i;
    do
    {
      v104 = v103[1];
      ++v103;
      v102 += v104;
    }
    while (v103 != v40);
  }
  if (v101 != v25)
  {
    v105 = v25;
    do
    {
      v106 = *v105++;
      i += v106;
    }
    while (v105 != v101);
  }
  v107 = v102 | ((unint64_t)v119 << 32);
  v108 = i | (unint64_t)(v119 << 32);
  *(_QWORD *)v120 = 0x2000000000000;
  v109 = v126[0];
  *(_QWORD *)(v120 + 8) = v99;
  *(_QWORD *)(v120 + 16) = v109;
  *(_QWORD *)(v120 + 23) = *(_QWORD *)((char *)v126 + 7);
  *(_BYTE *)(v120 + 31) = v100;
  v126[0] = 0;
  *(_QWORD *)((char *)v126 + 7) = 0;
  *(_QWORD *)(v120 + 32) = v107;
  *(_QWORD *)(v120 + 40) = v108;
  *(_QWORD *)(v120 + 48) = v108;
  *(_QWORD *)(v120 + 56) = v107;
  *(_QWORD *)(v120 + 104) = 0;
  *(_QWORD *)(v120 + 112) = 0;
  *(_QWORD *)(v120 + 64) = 0;
  *(_QWORD *)(v120 + 72) = 0;
  *(_QWORD *)(v120 + 80) = 0;
  *(_QWORD *)(v120 + 96) = v120 + 104;
  *(_BYTE *)(v120 + 120) = 0;
  *(_DWORD *)(v120 + 124) = 0;
  *(_DWORD *)(v120 + 128) = 0;
  *(_DWORD *)(v120 + 88) = 0;
  v110 = (float)(int)(i - v102) / 73.0;
  *(float *)(v120 + 124) = v110;
  *(float *)(v120 + 128) = v110;
  *(_BYTE *)(v120 + 120) = v118;
  if (v25)
  {
LABEL_35:
    v122 = (char *)v25;
    operator delete(v25);
  }
}

void sub_1D3D926F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  void *v26;
  uint64_t v27;

  if (*(char *)(v27 - 161) < 0)
    operator delete(*(void **)(v27 - 184));
  sub_1D3D92CD0((uint64_t)&a26);
  if (v26)
    operator delete(v26);
  _Unwind_Resume(a1);
}

void sub_1D3D92760(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  int v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 2)
  {
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)sub_1D3D82278(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    v7 = &v4[4 * v6];
    v8 = (char *)*a1;
    v9 = (char *)a1[1];
    v10 = v5;
    if (v9 != *a1)
    {
      v10 = v5;
      do
      {
        v11 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v10 - 1) = v11;
        v10 -= 4;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

uint64_t sub_1D3D927E8(int *a1)
{
  uint64_t v2;
  int v3;
  int *v4;
  int v5;
  uint64_t v7;
  const char *v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int *v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  int v22;
  int v23[7];
  uint64_t v24;

  v2 = 0;
  v3 = 0;
  v24 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  do
  {
    v5 = *v4;
    v4 += 2;
    v23[v2] = v5;
    v3 += v5;
    ++v2;
  }
  while (v2 != 7);
  if ((v3 - 20) < 0xFFFFFFF3 || (v3 & 1) == 0)
    goto LABEL_18;
  v7 = 0;
  while (1)
  {
    v8 = (char *)&unk_1D3E624C8 + v7;
    if (*(_DWORD *)((char *)&unk_1D3E624C8 + v7 + 4) == v3)
      break;
    v7 += 28;
    if (v7 == 196)
      goto LABEL_18;
  }
  if (v8 == "N5zxing8BitArrayE")
    goto LABEL_18;
  v9 = sub_1D3DFDC3C(v23, 7u, *((_DWORD *)v8 + 3), 1);
  v10 = 0;
  v11 = 0;
  v12 = *((_DWORD *)v8 + 6);
  v13 = *(_DWORD *)v8;
  v14 = a1 + 1;
  do
  {
    v15 = *v14;
    v14 += 2;
    v23[v10] = v15;
    v11 += v15;
    ++v10;
  }
  while (v10 != 7);
  if (v11 != *((_DWORD *)v8 + 2))
  {
LABEL_18:
    v18 = 0;
    v19 = 0;
    v20 = 0;
  }
  else
  {
    v16 = 0;
    v17 = v13 + v12 * v9;
    while (v23[v16] != 1)
    {
      if (++v16 == 7)
        goto LABEL_18;
    }
    v22 = sub_1D3DFDC3C(v23, 7u, *((_DWORD *)v8 + 4), 0);
    v19 = (v17 + v22) & 0xFFFFFF00;
    v18 = (v17 + v22);
    v20 = 0x100000000;
  }
  return v20 | v19 | v18;
}

uint64_t sub_1D3D92968(uint64_t a1)
{
  *(_QWORD *)(a1 + 128) = &unk_1E95ADCF0;
  *(_QWORD *)(a1 + 16) = off_1E95B0298;
  *(_QWORD *)a1 = &unk_1E95ADCC8;
  *(_QWORD *)(a1 + 8) = 0;
  std::ios_base::init((std::ios_base *)(a1 + 128), (void *)(a1 + 24));
  *(_QWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = -1;
  *(_QWORD *)a1 = off_1E95B0270;
  *(_QWORD *)(a1 + 128) = off_1E95B02C0;
  *(_QWORD *)(a1 + 16) = off_1E95B0298;
  std::wstreambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = off_1E95B01C0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1D3D92A20(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1D8254C00](v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D92A5C(_QWORD *a1, int a2)
{
  char *v4;
  const std::locale::facet *v5;
  int v6;
  std::locale v8;

  v4 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  if (*((_DWORD *)v4 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
    v5 = std::locale::use_facet(&v8, MEMORY[0x1E0DE4A98]);
    v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[3].__on_zero_shared)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v4 + 36) = v6;
  }
  *((_DWORD *)v4 + 36) = a2;
  return a1;
}

void sub_1D3D92AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D92AFC(_QWORD *__dst, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  const void **v7;
  _BYTE *v8;
  int64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v2 = __dst;
  v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    v5 = *(_BYTE **)(a2 + 88);
    v6 = *(_BYTE **)(a2 + 48);
    if (v5 < v6)
    {
      *(_QWORD *)(a2 + 88) = v6;
      v5 = v6;
    }
    v7 = (const void **)(a2 + 40);
LABEL_8:
    v8 = *v7;
    v9 = v5 - (_BYTE *)*v7;
    if (v9 < 0)
      sub_1D3D7FD48();
    v4 = v9 >> 2;
    if ((unint64_t)v9 >= 0x14)
    {
      v10 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 2;
      if ((v4 | 1) != 5)
        v10 = v4 | 1;
      v11 = sub_1D3D82278(v10 + 1);
      v2[1] = v4;
      v2[2] = v12 | 0x8000000000000000;
      *v2 = v11;
      v2 = v11;
    }
    else
    {
      *((_BYTE *)__dst + 23) = (unint64_t)v9 >> 2;
      if (v5 == v8)
      {
        v4 = 0;
        goto LABEL_16;
      }
    }
    __dst = memmove(v2, v8, v9);
    goto LABEL_16;
  }
  if ((v3 & 8) != 0)
  {
    v7 = (const void **)(a2 + 16);
    v5 = *(_BYTE **)(a2 + 32);
    goto LABEL_8;
  }
  v4 = 0;
  *((_BYTE *)__dst + 23) = 0;
LABEL_16:
  *((_DWORD *)v2 + v4) = 0;
  return __dst;
}

_QWORD *sub_1D3D92BD4(_QWORD *result, const void **a2)
{
  int v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  const void *v12;

  v2 = *((char *)a2 + 23);
  if (v2 >= 0)
    v3 = *((unsigned __int8 *)a2 + 23);
  else
    v3 = (unint64_t)a2[1];
  v4 = v3 + 2;
  if (v3 + 2 >= 0x3FFFFFFFFFFFFFF8)
    sub_1D3D7FD48();
  v6 = result;
  if (v4 >= 5)
  {
    v9 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 2;
    if ((v4 | 1) != 5)
      v9 = v4 | 1;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      sub_1D3D6D50C();
    v10 = v9 + 1;
    v11 = operator new(4 * (v9 + 1));
    v6[1] = v4;
    v6[2] = v10 | 0x8000000000000000;
    *v6 = v11;
    *v11 = 0x3100000030;
    v8 = v11 + 1;
    goto LABEL_15;
  }
  result[1] = 0;
  result[2] = 0;
  *result = 0;
  *((_BYTE *)result + 23) = v4;
  if ((v4 & 0x80u) == 0)
    v7 = result;
  else
    v7 = 0;
  *v7 = 0x3100000030;
  v8 = v7 + 1;
  if (v3)
  {
LABEL_15:
    if (v2 >= 0)
      v12 = a2;
    else
      v12 = *a2;
    result = memmove(v8, v12, 4 * v3);
  }
  *((_DWORD *)v8 + v3) = 0;
  return result;
}

uint64_t sub_1D3D92CD0(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_1E95B0270;
  *(_QWORD *)(a1 + 128) = off_1E95B02C0;
  v2 = a1 + 128;
  *(_QWORD *)(a1 + 16) = off_1E95B0298;
  *(_QWORD *)(a1 + 24) = off_1E95B01C0;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1D8254C00](v2);
  return a1;
}

uint64_t sub_1D3D92D6C(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E95B01C0;
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  return std::wstreambuf::~wstreambuf();
}

void sub_1D3D92DA8(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E95B01C0;
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  std::wstreambuf::~wstreambuf();
  JUMPOUT(0x1D8254C54);
}

double sub_1D3D92DF8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double result;
  uint64_t v12;
  uint64_t v13;

  v5 = *(_QWORD *)(a1 + 88);
  v6 = *(_QWORD *)(a1 + 48);
  if (v5 < v6)
  {
    *(_QWORD *)(a1 + 88) = v6;
    v5 = v6;
  }
  if ((a4 & 0x18) == 0 || a3 == 1 && (a4 & 0x18) == 0x18)
    goto LABEL_14;
  if (!v5)
  {
    v8 = 0;
    if (a3)
      goto LABEL_10;
LABEL_17:
    v12 = a3;
    goto LABEL_21;
  }
  v7 = (_QWORD *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0)
    v7 = (_QWORD *)*v7;
  v8 = (uint64_t)(v5 - (_QWORD)v7) >> 2;
  if (!a3)
    goto LABEL_17;
LABEL_10:
  if (a3 == 2)
  {
    v12 = v8;
    goto LABEL_21;
  }
  if (a3 != 1)
  {
LABEL_14:
    v10 = -1;
    goto LABEL_15;
  }
  if ((a4 & 8) != 0)
    v9 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
  else
    v9 = v6 - *(_QWORD *)(a1 + 40);
  v12 = v9 >> 2;
LABEL_21:
  v10 = -1;
  v13 = v12 + a2;
  if (v13 >= 0 && v8 >= v13 && (!v13 || ((a4 & 8) == 0 || *(_QWORD *)(a1 + 24)) && ((a4 & 0x10) == 0 || v6)))
  {
    if ((a4 & 8) != 0)
    {
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 4 * v13;
      *(_QWORD *)(a1 + 32) = v5;
    }
    if ((a4 & 0x10) != 0)
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40) + 4 * v13;
    v10 = v13;
  }
LABEL_15:
  result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_QWORD *)(a5 + 128) = v10;
  return result;
}

uint64_t sub_1D3D92F00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a1 + 32))(a1, *(_QWORD *)(a2 + 128), 0, a3);
}

uint64_t sub_1D3D92F18(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unsigned int *v4;

  v1 = *(_QWORD *)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 48);
  if (v1 < v2)
  {
    *(_QWORD *)(a1 + 88) = v2;
    v1 = v2;
  }
  if ((*(_BYTE *)(a1 + 96) & 8) == 0)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 < v1)
  {
    *(_QWORD *)(a1 + 32) = v1;
    v3 = v1;
  }
  v4 = *(unsigned int **)(a1 + 24);
  if ((unint64_t)v4 < v3)
    return *v4;
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_1D3D92F68(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v2 = *(_QWORD *)(a1 + 88);
  v3 = *(_QWORD *)(a1 + 48);
  if (v2 < v3)
  {
    *(_QWORD *)(a1 + 88) = v3;
    v2 = v3;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 16) < v4)
  {
    if ((_DWORD)a2 == -1)
    {
      a2 = 0;
      v5 = v4 - 4;
      goto LABEL_10;
    }
    if ((*(_BYTE *)(a1 + 96) & 0x10) != 0 || *(_DWORD *)(v4 - 4) == (_DWORD)a2)
    {
      *(_DWORD *)(v4 - 4) = a2;
      v5 = v4 - 4;
LABEL_10:
      *(_QWORD *)(a1 + 24) = v5;
      *(_QWORD *)(a1 + 32) = v2;
      return a2;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1D3D92FCC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::wstring::size_type v12;
  uint64_t v13;
  _QWORD *v14;

  if ((_DWORD)a2 == -1)
    return 0;
  v2 = a2;
  v5 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v7 = *(_DWORD **)(a1 + 48);
  v6 = *(_DWORD **)(a1 + 56);
  if (v7 != v6)
  {
    v8 = *(_QWORD *)(a1 + 88);
    goto LABEL_14;
  }
  if ((*(_BYTE *)(a1 + 96) & 0x10) == 0)
    return 0xFFFFFFFFLL;
  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 88);
  v11 = a1 + 64;
  std::wstring::push_back((std::wstring *)(a1 + 64), 0);
  if (*(char *)(a1 + 87) < 0)
    v12 = (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1;
  else
    v12 = 4;
  std::wstring::resize((std::wstring *)(a1 + 64), v12, 0);
  if (*(char *)(a1 + 87) < 0)
  {
    v11 = *(_QWORD *)(a1 + 64);
    v13 = *(_QWORD *)(a1 + 72);
  }
  else
  {
    v13 = *(unsigned __int8 *)(a1 + 87);
  }
  v6 = (_DWORD *)(v11 + 4 * v13);
  v7 = (_DWORD *)(v11 + 4 * (((uint64_t)v7 - v9) >> 2));
  *(_QWORD *)(a1 + 40) = v11;
  *(_QWORD *)(a1 + 48) = v7;
  *(_QWORD *)(a1 + 56) = v6;
  v8 = v11 + 4 * ((v10 - v9) >> 2);
LABEL_14:
  if ((unint64_t)(v7 + 1) >= v8)
    v8 = (unint64_t)(v7 + 1);
  *(_QWORD *)(a1 + 88) = v8;
  if ((*(_BYTE *)(a1 + 96) & 8) != 0)
  {
    v14 = (_QWORD *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0)
      v14 = (_QWORD *)*v14;
    *(_QWORD *)(a1 + 16) = v14;
    *(_QWORD *)(a1 + 24) = (char *)v14 + 4 * ((v4 - v5) >> 2);
    *(_QWORD *)(a1 + 32) = v8;
  }
  if (v7 != v6)
  {
    *(_QWORD *)(a1 + 48) = v7 + 1;
    *v7 = v2;
    return v2;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 104))(a1, v2);
}

void sub_1D3D9312C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D3D9301CLL);
}

void sub_1D3D93138(uint64_t a1)
{
  uint64_t v1;

  *(_QWORD *)a1 = off_1E95B0270;
  *(_QWORD *)(a1 + 128) = off_1E95B02C0;
  v1 = a1 + 128;
  *(_QWORD *)(a1 + 16) = off_1E95B0298;
  *(_QWORD *)(a1 + 24) = off_1E95B01C0;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1D8254C00](v1);
  JUMPOUT(0x1D8254C54);
}

void sub_1D3D931E4(uint64_t a1)
{
  *(_QWORD *)(a1 - 16) = off_1E95B0270;
  *(_QWORD *)(a1 + 112) = off_1E95B02C0;
  *(_QWORD *)a1 = off_1E95B0298;
  *(_QWORD *)(a1 + 8) = off_1E95B01C0;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  JUMPOUT(0x1D8254C00);
}

void sub_1D3D93278(uint64_t a1)
{
  uint64_t v1;

  *(_QWORD *)(a1 - 16) = off_1E95B0270;
  *(_QWORD *)(a1 + 112) = off_1E95B02C0;
  v1 = a1 + 112;
  *(_QWORD *)a1 = off_1E95B0298;
  *(_QWORD *)(a1 + 8) = off_1E95B01C0;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1D8254C00](v1);
  JUMPOUT(0x1D8254C54);
}

void sub_1D3D93324(_QWORD *a1)
{
  char *v1;

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  *(_QWORD *)v1 = off_1E95B0270;
  *((_QWORD *)v1 + 16) = off_1E95B02C0;
  *((_QWORD *)v1 + 2) = off_1E95B0298;
  *((_QWORD *)v1 + 3) = off_1E95B01C0;
  if (v1[111] < 0)
    operator delete(*((void **)v1 + 11));
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  JUMPOUT(0x1D8254C00);
}

void sub_1D3D933C0(_QWORD *a1)
{
  char *v1;

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  *(_QWORD *)v1 = off_1E95B0270;
  *((_QWORD *)v1 + 16) = off_1E95B02C0;
  *((_QWORD *)v1 + 2) = off_1E95B0298;
  *((_QWORD *)v1 + 3) = off_1E95B01C0;
  if (v1[111] < 0)
    operator delete(*((void **)v1 + 11));
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1D8254C00](v1 + 128);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D93474(uint64_t a1)
{
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1D8254C00](a1 + 24);
  return a1;
}

void sub_1D3D934BC(uint64_t a1)
{
  sub_1D3D93474(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D934E0(uint64_t a1)
{
  return sub_1D3D93474(a1 - 16);
}

void sub_1D3D934E8(uint64_t a1)
{
  sub_1D3D93474(a1 - 16);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D93510(_QWORD *a1)
{
  return sub_1D3D93474((uint64_t)a1 + *(_QWORD *)(*a1 - 24));
}

void sub_1D3D93520(_QWORD *a1)
{
  sub_1D3D93474((uint64_t)a1 + *(_QWORD *)(*a1 - 24));
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D93550(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E95AF9F0;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1D3D9358C(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E95AF9F0;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D935D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;

  v3 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AF9F0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = a2 + 31;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  if ((unint64_t)(a2 + 31) >= 0x20)
  {
    v5 = v4 >> 5;
    sub_1D3D8223C((_QWORD *)(a1 + 24), v4 >> 5);
    v6 = *(_DWORD **)(a1 + 32);
    v7 = &v6[v5];
    v8 = 4 * v5;
    do
    {
      *v6++ = 0;
      v8 -= 4;
    }
    while (v8);
    *(_QWORD *)(a1 + 32) = v7;
    v3 = *(_QWORD *)(a1 + 24);
  }
  *(_QWORD *)(a1 + 48) = v3;
  return a1;
}

void sub_1D3D93664(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D3D93680(char **a1, unint64_t a2, _DWORD *a3)
{
  char *v5;
  char *v6;
  unint64_t v7;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *i;
  int v22;
  char *v23;
  uint64_t v24;

  v6 = *a1;
  v5 = a1[1];
  v7 = (v5 - *a1) >> 2;
  if (a2 <= v7)
  {
    if (a2 < v7)
      a1[1] = &v6[4 * a2];
  }
  else
  {
    v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 2)
    {
      v23 = &v5[4 * (a2 - v7)];
      v24 = 4 * a2 - 4 * v7;
      do
      {
        *(_DWORD *)v5 = *a3;
        v5 += 4;
        v24 -= 4;
      }
      while (v24);
      a1[1] = v23;
    }
    else
    {
      if (a2 >> 62)
        sub_1D3D6D4F8();
      v10 = v9 - v6;
      v11 = (v9 - v6) >> 1;
      if (v11 <= a2)
        v11 = a2;
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
        v12 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      v13 = (char *)sub_1D3D82278(v12);
      v15 = &v13[4 * v7];
      v16 = &v13[4 * a2];
      v17 = 4 * a2 - 4 * v7;
      v18 = v15;
      do
      {
        *(_DWORD *)v18 = *a3;
        v18 += 4;
        v17 -= 4;
      }
      while (v17);
      v19 = &v13[4 * v14];
      v20 = *a1;
      for (i = a1[1]; i != v20; i -= 4)
      {
        v22 = *((_DWORD *)i - 1);
        *((_DWORD *)v15 - 1) = v22;
        v15 -= 4;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20)
        operator delete(v20);
    }
  }
}

_QWORD *sub_1D3D93798(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E95AFA40;
  v2 = a1[6];
  if (v2)
    MEMORY[0x1D8254C3C](v2, 0x1000C8052888210);
  return a1;
}

void sub_1D3D937E0(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_1E95AFA40;
  v1 = a1[6];
  if (v1)
    MEMORY[0x1D8254C3C](v1, 0x1000C8052888210);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D93838(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  void *v4;
  uint64_t v5;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AFA40;
  v3 = (a2 + 31) & 0xFFFFFFFFFFFFFFE0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = v3;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 40) = (v3 * a2) >> 5;
  v4 = (void *)operator new[]();
  *(_QWORD *)(a1 + 48) = v4;
  v5 = *(_QWORD *)(a1 + 40);
  if (v5 >= 1)
    bzero(v4, 4 * (v5 - ((v5 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
  return a1;
}

uint64_t sub_1D3D938C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AFA40;
  v4 = (a2 + 31) & 0xFFFFFFFFFFFFFFE0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = v4;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = (v4 * a3) >> 5;
  v5 = (void *)operator new[]();
  *(_QWORD *)(a1 + 48) = v5;
  v6 = *(_QWORD *)(a1 + 40);
  if (v6 >= 1)
    bzero(v5, 4 * (v6 - ((v6 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
  return a1;
}

_QWORD *sub_1D3D93950(_QWORD *result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *exception;

  if (((a3 | a2) & 0x8000000000000000) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "topI and leftJ must be nonnegative");
    goto LABEL_16;
  }
  if (!a4 || !a5)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "height and width must be at least 1");
LABEL_16:
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  if (a4 + a2 > result[2] || (v5 = a5 + a3, a5 + a3 > result[4]))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "top + height and left + width must be <= matrix dimension");
    goto LABEL_16;
  }
  if (v5 > a3)
  {
    v6 = result[3];
    v7 = a2 + v6 * a3;
    do
    {
      if (a4 + a2 > a2)
      {
        v8 = result[6];
        v9 = v7;
        v10 = a4;
        do
        {
          *(_DWORD *)(v8 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v9;
          ++v9;
          --v10;
        }
        while (v10);
      }
      ++a3;
      v7 += v6;
    }
    while (a3 != v5);
  }
  return result;
}

void sub_1D3D93A5C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D93A78(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x1E0DE4FE0] + 64;
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1D3D93B3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1D8254BF4](v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D93B64(_QWORD *__dst, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  size_t v4;
  unint64_t v5;
  unint64_t v6;
  const void **v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v2 = __dst;
  v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    v5 = *(_QWORD *)(a2 + 88);
    v6 = *(_QWORD *)(a2 + 48);
    if (v5 < v6)
    {
      *(_QWORD *)(a2 + 88) = v6;
      v5 = v6;
    }
    v7 = (const void **)(a2 + 40);
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      v4 = 0;
      *((_BYTE *)__dst + 23) = 0;
      goto LABEL_16;
    }
    v7 = (const void **)(a2 + 16);
    v5 = *(_QWORD *)(a2 + 32);
  }
  v8 = *v7;
  v4 = v5 - (_QWORD)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    sub_1D3D7FD48();
  if (v4 >= 0x17)
  {
    v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v9 = v4 | 7;
    v10 = v9 + 1;
    v11 = operator new(v9 + 1);
    v2[1] = v4;
    v2[2] = v10 | 0x8000000000000000;
    *v2 = v11;
    v2 = v11;
  }
  else
  {
    *((_BYTE *)__dst + 23) = v4;
    if (!v4)
      goto LABEL_16;
  }
  __dst = memmove(v2, v8, v4);
LABEL_16:
  *((_BYTE *)v2 + v4) = 0;
  return __dst;
}

uint64_t sub_1D3D93C38(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1D8254BF4](a1 + 112);
  return a1;
}

void sub_1D3D93CBC(const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1D3D93D0C(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E95AAC08, MEMORY[0x1E0DE42E0]);
}

void sub_1D3D93CF8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1D3D93D0C(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

uint64_t MRCSegmentationMaskGetTypeID()
{
  if (qword_1EFE317E8 != -1)
    dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
  return qword_1EFE317F0;
}

_QWORD *sub_1D3D93D74()
{
  _QWORD *result;
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB890A8)
    _os_assumes_log();
  if (qword_1EFE317F0)
    _os_assumes_log();
  qword_1EDB890A8 = (uint64_t)"MRCSegmentationMask";
  qword_1EFE317F0 = _CFRuntimeRegisterClass();
  v3 = 0;
  sub_1D3DAFDB4(qword_1EFE317F0, v2);
  result = v3;
  if (v3 == v2)
  {
    v1 = 4;
    result = v2;
  }
  else
  {
    if (!v3)
      return result;
    v1 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
}

void sub_1D3D93E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t *sub_1D3D93E84(unint64_t *cf)
{
  CFTypeID v2;
  CFTypeID v3;
  void (*v4)(unint64_t, unint64_t);

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
    v3 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v3 != qword_1EFE317F0)
      _os_assumes_log();
  }
  v4 = (void (*)(unint64_t, unint64_t))cf[4];
  if (v4)
    v4(cf[2], cf[3]);
  return sub_1D3D74138(cf + 10);
}

BOOL sub_1D3D93F64(CFTypeRef cf, CFTypeRef a2)
{
  CFTypeID v4;
  CFTypeID v5;

  if (!cf)
    goto LABEL_5;
  v4 = CFGetTypeID(cf);
  if (qword_1EFE317E8 != -1)
    dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
  if (v4 != qword_1EFE317F0)
  {
    _os_assumes_log();
    if (!a2)
      return cf == a2;
  }
  else
  {
LABEL_5:
    if (!a2)
      return cf == a2;
  }
  v5 = CFGetTypeID(a2);
  if (qword_1EFE317E8 != -1)
    dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
  if (v5 != qword_1EFE317F0)
    _os_assumes_log();
  return cf == a2;
}

unint64_t sub_1D3D94048(CFTypeRef cf)
{
  CFTypeID v2;
  unint64_t v3;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  v3 = 0x9DDFEA08EB382D69
     * (((((((unint64_t)cf + 16) >> 3) & 0x3FFFFFF) << 6) | 8) ^ (((unint64_t)cf + 16) >> 32));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * ((((unint64_t)cf + 16) >> 32) ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69
                                                                                             * ((((unint64_t)cf
                                                                                                + 16) >> 32) ^ (v3 >> 47) ^ v3)) >> 47));
}

CFStringRef sub_1D3D94100(unint64_t *cf)
{
  CFTypeID v2;
  const __CFAllocator *v3;
  __CFString *v5;
  __CFString *v6;
  __CFString *v7;
  __CFString *v8;
  __CFString *v9;
  __CFString *v10;
  __CFString *v11;
  __CFString *v12;
  __CFString *v13;
  __CFString *v14;
  unint64_t v15;
  __CFString *v16;
  const __CFString *v17;
  CFStringRef Copy;
  CFMutableStringRef Mutable;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (atomic_load((unint64_t *)&Mutable))
  {
    v5 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v5, 0, CFSTR("<%s %p> {\n"), "MRCSegmentationMask", cf);
    v6 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v6, 0, CFSTR("    data %p\n"), cf[2]);
    v7 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v7, 0, CFSTR("    dataDeallocatorContext %p\n"), cf[3]);
    v8 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v8, 0, CFSTR("    dataDeallocator %p\n"), cf[4]);
    v9 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v9, 0, CFSTR("    dataType %ld\n"), cf[5]);
    v10 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v10, 0, CFSTR("    width %zu\n"), cf[6]);
    v11 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v11, 0, CFSTR("    height %zu\n"), cf[7]);
    v12 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v12, 0, CFSTR("    bytesPerRow %zu\n"), cf[8]);
    v13 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppendFormat(v13, 0, CFSTR("    scalingMode %ld\n"), cf[9]);
    v14 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    v15 = atomic_load(cf + 10);
    CFStringAppendFormat(v14, 0, CFSTR("    symbologies %@\n"), v15);
    v16 = (__CFString *)atomic_load((unint64_t *)&Mutable);
    CFStringAppend(v16, CFSTR("}"));
    v17 = (const __CFString *)atomic_load((unint64_t *)&Mutable);
    Copy = CFStringCreateCopy(v3, v17);
    sub_1D3D8FA0C((unint64_t *)&Mutable);
    if (Copy)
      return Copy;
  }
  else
  {
    sub_1D3D8FA0C((unint64_t *)&Mutable);
  }
  return CFStringCreateWithFormat(v3, 0, CFSTR("<%s %p>"), "MRCSegmentationMask", cf);
}

void sub_1D3D94348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  sub_1D3D8FA0C((unint64_t *)va);
  _Unwind_Resume(a1);
}

unint64_t MRCSegmentationMaskCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CFTypeRef cf)
{
  _QWORD *Instance;
  _QWORD *v18;
  CFTypeID v19;
  CFTypeRef v20;
  unint64_t v21;
  CFTypeID v22;
  unint64_t v23;
  const void *v24;
  uint64_t v26;
  _QWORD *v27;

  if (qword_1EFE317E8 != -1)
    dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v18 = Instance;
  if (Instance)
  {
    v26 = a8;
    v19 = CFGetTypeID(Instance);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v19 != qword_1EFE317F0)
      _os_assumes_log();
    v18[2] = a1;
    v18[3] = a2;
    v18[4] = a3;
    v18[5] = a4;
    v18[6] = a5;
    v18[7] = a6;
    v18[8] = a7;
    v18[9] = v26;
    if (cf)
    {
      v20 = CFRetain(cf);
    }
    else
    {
      _os_assumes_log();
      v20 = 0;
    }
    v18[10] = v20;
    if (!v18[2])
      _os_assumes_log();
    v21 = v18[6];
    if (!v21 || !v18[7])
    {
      _os_assumes_log();
      v21 = v18[6];
    }
    if (v18[8] < v21)
      _os_assumes_log();
    v22 = CFGetTypeID(v18);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v22 != qword_1EFE317F0)
      _os_assumes_log();
  }
  v27 = v18;
  do
    v23 = __ldaxr((unint64_t *)&v27);
  while (__stlxr(0, (unint64_t *)&v27));
  do
    v24 = (const void *)__ldaxr((unint64_t *)&v27);
  while (__stlxr(0, (unint64_t *)&v27));
  if (v24)
    CFRelease(v24);
  return v23;
}

void sub_1D3D94564(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1D3D74138((unint64_t *)(v1 + 80));
  _Unwind_Resume(a1);
}

uint64_t MRCSegmentationMaskGetData(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  return *((_QWORD *)cf + 2);
}

uint64_t MRCSegmentationMaskGetDataType(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  return *((_QWORD *)cf + 5);
}

uint64_t MRCSegmentationMaskGetWidth(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  return *((_QWORD *)cf + 6);
}

uint64_t MRCSegmentationMaskGetHeight(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  return *((_QWORD *)cf + 7);
}

uint64_t MRCSegmentationMaskGetBytesPerRow(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  return *((_QWORD *)cf + 8);
}

uint64_t MRCSegmentationMaskGetScalingMode(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  return *((_QWORD *)cf + 9);
}

unint64_t MRCSegmentationMaskGetSymbologies(unint64_t *cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  return atomic_load(cf + 10);
}

void sub_1D3D948D0(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t i;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;
  CGRect v25;

  if (a1[3] == 1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = a1[4];
      if (v3)
      {
        v4 = a1[5];
        if (v4)
        {
          v5 = 0;
          v6 = 0;
          v7 = 0;
          v8 = v3 - 1;
          v9 = v4 - 1;
          do
          {
            for (i = 0; i != v3; ++i)
            {
              if (i >= v8)
                v11 = v8;
              else
                v11 = i;
              if (i <= v5)
                v12 = v5;
              else
                v12 = i;
              if (v7 >= v9)
                v13 = v9;
              else
                v13 = v7;
              if (v7 <= v6)
                v14 = v6;
              else
                v14 = v7;
              if (*(float *)(v2 + 4 * i) >= 0.1)
              {
                v6 = v14;
                v9 = v13;
                v5 = v12;
                v8 = v11;
              }
            }
            ++v7;
            v2 += a1[6];
          }
          while (v7 != v4);
          if (v8 <= v5 && v9 <= v6)
          {
            v15 = (double)(v6 - v9 + 1);
            v16 = (double)(v5 - v8 + 1);
            v17 = (double)v9;
            v18 = (double)v8;
            v21.origin.x = (double)v8;
            v21.origin.y = (double)v9;
            v21.size.width = v16;
            v21.size.height = v15;
            v19 = CGRectGetWidth(v21) * -0.25;
            v22.origin.x = v18;
            v22.origin.y = v17;
            v22.size.width = v16;
            v22.size.height = v15;
            v20 = CGRectGetHeight(v22) * -0.25;
            v23.origin.x = v18;
            v23.origin.y = v17;
            v23.size.width = v16;
            v23.size.height = v15;
            v24 = CGRectInset(v23, v19, v20);
            v25.size.width = (double)(unint64_t)a1[4];
            v25.size.height = (double)(unint64_t)a1[5];
            v25.origin.x = 0.0;
            v25.origin.y = 0.0;
            CGRectIntersection(v24, v25);
          }
        }
      }
    }
  }
}

void sub_1D3D94A48(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D94AA0((unint64_t *)a1);
  JUMPOUT(0x1D8254C54);
}

unint64_t *sub_1D3D94AA0(unint64_t *a1)
{
  OpaqueVTPixelTransferSession *v3;

  if (atomic_load(a1))
  {
    v3 = (OpaqueVTPixelTransferSession *)atomic_load(a1);
    VTPixelTransferSessionInvalidate(v3);
  }
  return sub_1D3D94AD4(a1);
}

unint64_t *sub_1D3D94AD4(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

void sub_1D3D94B0C(uint64_t a1, os_signpost_id_t a2)
{
  NSObject *v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  __int16 v8;
  unint64_t v9;
  uint64_t v10;
  CGRect v11;

  v10 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (a2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v5 = vcvtpd_u64_f64(CGRectGetWidth(*(CGRect *)(**(_QWORD **)a1 + 8)));
      v11 = *(CGRect *)(**(_QWORD **)a1 + 8);
      v6 = 134349312;
      v7 = v5;
      v8 = 2050;
      v9 = vcvtpd_u64_f64(CGRectGetHeight(v11));
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, a2, "PyramidGenerationSession::generatePyramid", "masterPixelBufferWidth=%{public, signpost.description:attribute}zu, masterPixelBufferHeight=%{public, signpost.description:attribute}zu", (uint8_t *)&v6, 0x16u);
    }
  }
}

unint64_t sub_1D3D94C2C(unint64_t *a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;
  NSObject *v8;
  unint64_t result;
  __CVBuffer *v11;
  OSType PixelFormatType;
  __CVBuffer *v13;
  IOSurfaceRef IOSurface;
  CFAllocatorRef *v15;
  __CVBuffer *v16;
  const void *v17;
  __IOSurface *v19;
  __IOSurface *v20;
  __IOSurface *v21;
  __IOSurface *v22;
  __IOSurface *v23;
  __IOSurface *v24;
  _BYTE *BaseAddressOfPlane;
  __IOSurface *v26;
  uint64_t ChildSurface;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  const __CFAllocator *v37;
  __IOSurface *v38;
  CVReturn v39;
  NSObject *v40;
  NSObject *v41;
  __CVBuffer *v42;
  size_t WidthOfPlane;
  __CVBuffer *v44;
  size_t v45;
  __CVBuffer *v46;
  void *v47;
  __CVBuffer *v48;
  size_t v49;
  int v50;
  NSObject *v51;
  __CVBuffer *v52;
  int v53;
  __CVBuffer *v54;
  int v55;
  __CVBuffer *v56;
  int v57;
  __CVBuffer *v58;
  unint64_t v59;
  uint64_t v60;
  const void *v61;
  unint64_t v62;
  unint64_t v63;
  CFDictionaryRef v64;
  const __CFString *v65;
  _BYTE v66[12];
  uint8_t buf[8];
  uint64_t v68;
  _BYTE v69[10];
  char v70;
  size_t HeightOfPlane;
  char v72;
  size_t BytesPerRowOfPlane;
  char v74;
  char v75;
  __int128 v76;
  __int128 v77;
  char v78;
  char v79;
  __int16 v80;
  int v81;
  char v82;
  unint64_t v83[3];

  v83[2] = *MEMORY[0x1E0C80C00];
  if (atomic_load(a2))
    v7 = *(_BYTE *)(a3 + 16) == 0;
  else
    v7 = 1;
  if (v7)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v8 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "Invalid pixel buffer state.", buf, 2u);
    }
    *(_QWORD *)buf = -2004;
    *(_QWORD *)v66 = CFSTR("Invalid pixel buffer state.");
    result = sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)v66);
    goto LABEL_79;
  }
  v62 = 0;
  v11 = (__CVBuffer *)atomic_load(a2);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v11);
  if (PixelFormatType != 875704422)
  {
    if (PixelFormatType == 1278226488)
    {
      result = atomic_load(a2);
      if (result)
        result = (unint64_t)CFRetain((CFTypeRef)result);
      *a1 = result;
      return result;
    }
    if (PixelFormatType != 875704438)
    {
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v31 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        v52 = (__CVBuffer *)atomic_load(a2);
        v53 = (int)CVPixelBufferGetPixelFormatType(v52) >> 24;
        v54 = (__CVBuffer *)atomic_load(a2);
        v55 = (int)(CVPixelBufferGetPixelFormatType(v54) << 8) >> 24;
        v56 = (__CVBuffer *)atomic_load(a2);
        v57 = (__int16)CVPixelBufferGetPixelFormatType(v56) >> 8;
        v58 = (__CVBuffer *)atomic_load(a2);
        *(_DWORD *)buf = 67240960;
        *(_DWORD *)&buf[4] = v53;
        LOWORD(v68) = 1026;
        *(_DWORD *)((char *)&v68 + 2) = v55;
        HIWORD(v68) = 1026;
        *(_DWORD *)v69 = v57;
        *(_WORD *)&v69[4] = 1026;
        *(_DWORD *)&v69[6] = (char)CVPixelBufferGetPixelFormatType(v58);
        _os_log_error_impl(&dword_1D3D6B000, v31, OS_LOG_TYPE_ERROR, "Unsupported pixel format type: %{public}c%{public}c%{public}c%{public}c", buf, 0x1Au);
      }
      *(_QWORD *)buf = -2004;
      *(_QWORD *)v66 = CFSTR("Unsupported pixel format type.");
      result = sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)v66);
      goto LABEL_79;
    }
  }
  v13 = (__CVBuffer *)atomic_load(a2);
  IOSurface = CVPixelBufferGetIOSurface(v13);
  v15 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (IOSurface)
  {
    v16 = (__CVBuffer *)atomic_load(a2);
    v17 = CVPixelBufferGetIOSurface(v16);
    if (v17)
      v17 = CFRetain(v17);
    v61 = v17;
    if (atomic_load((unint64_t *)&v61))
    {
      v19 = (__IOSurface *)atomic_load((unint64_t *)&v61);
      if (IOSurfaceGetPlaneCount(v19))
      {
        buf[0] = 0;
        LOBYTE(v68) = 0;
        v69[0] = 0;
        v69[8] = 0;
        LOBYTE(HeightOfPlane) = 0;
        v72 = 0;
        LOBYTE(BytesPerRowOfPlane) = 0;
        v74 = 0;
        LOBYTE(v76) = 0;
        BYTE8(v76) = 0;
        LOBYTE(v77) = 0;
        BYTE8(v77) = 0;
        v78 = 0;
        v79 = 0;
        v80 = 0;
        LOBYTE(v81) = 0;
        v82 = 0;
        v83[0] = 0;
        v20 = (__IOSurface *)atomic_load((unint64_t *)&v61);
        *(_QWORD *)v69 = IOSurfaceGetWidthOfPlane(v20, 0);
        v69[8] = 1;
        v21 = (__IOSurface *)atomic_load((unint64_t *)&v61);
        HeightOfPlane = IOSurfaceGetHeightOfPlane(v21, 0);
        v72 = 1;
        v22 = (__IOSurface *)atomic_load((unint64_t *)&v61);
        BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v22, 0);
        v74 = 1;
        *(_QWORD *)buf = HeightOfPlane * BytesPerRowOfPlane;
        LOBYTE(v68) = 1;
        v23 = (__IOSurface *)atomic_load((unint64_t *)&v61);
        *(_QWORD *)&v76 = IOSurfaceGetBytesPerElementOfPlane(v23, 0);
        BYTE8(v76) = 1;
        v24 = (__IOSurface *)atomic_load((unint64_t *)&v61);
        BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(v24, 0);
        v26 = (__IOSurface *)atomic_load((unint64_t *)&v61);
        *(_QWORD *)&v77 = BaseAddressOfPlane - (_BYTE *)IOSurfaceGetBaseAddress(v26);
        BYTE8(v77) = 1;
        v81 = 1278226488;
        v82 = 1;
        v63 = 0;
        sub_1D3DD50E8(&v64, (uint64_t *)buf, &v63);
        if (atomic_load((unint64_t *)&v61))
        {
          if (atomic_load((unint64_t *)&v64))
          {
            atomic_load((unint64_t *)&v61);
            atomic_load((unint64_t *)&v64);
            ChildSurface = IOSurfaceCreateChildSurface();
            if (ChildSurface)
            {
LABEL_57:
              v60 = ChildSurface;
              sub_1D3D8BAAC((unint64_t *)&v64);
              sub_1D3D8BAAC(&v63);
              sub_1D3D8C70C(v83);
              goto LABEL_58;
            }
            if (qword_1EFE31850 != -1)
              dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
            v30 = qword_1EFE31848;
            if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v66 = 0;
              _os_log_error_impl(&dword_1D3D6B000, v30, OS_LOG_TYPE_ERROR, "IOSurfaceCreateChildSurface failed", v66, 2u);
            }
            v65 = CFSTR("IOSurfaceCreateChildSurface failed.");
            *(_QWORD *)v66 = -2003;
            sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)v66, (CFTypeRef *)&v65);
          }
          else
          {
            if (qword_1EFE31850 != -1)
              dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
            v35 = qword_1EFE31848;
            if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v66 = 0;
              _os_log_error_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_ERROR, "Invalid surface properties", v66, 2u);
            }
            v65 = CFSTR("Invalid surface properties.");
            *(_QWORD *)v66 = -2006;
            sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)v66, (CFTypeRef *)&v65);
          }
        }
        else
        {
          if (qword_1EFE31850 != -1)
            dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
          v34 = qword_1EFE31848;
          if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v66 = 0;
            _os_log_error_impl(&dword_1D3D6B000, v34, OS_LOG_TYPE_ERROR, "Invalid parent surface", v66, 2u);
          }
          v65 = CFSTR("Invalid parent surface.");
          *(_QWORD *)v66 = -2006;
          sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)v66, (CFTypeRef *)&v65);
        }
        ChildSurface = 0;
        goto LABEL_57;
      }
      if (qword_1EFE31850 != -1)
        dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
      v33 = qword_1EFE31848;
      if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_ERROR, "Invalid non-planar parent surface", buf, 2u);
      }
      *(_QWORD *)buf = -2006;
      *(_QWORD *)v66 = CFSTR("Invalid non-planar parent surface.");
      sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)v66);
    }
    else
    {
      if (qword_1EFE31850 != -1)
        dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
      v32 = qword_1EFE31848;
      if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D3D6B000, v32, OS_LOG_TYPE_ERROR, "Invalid parent surface", buf, 2u);
      }
      *(_QWORD *)buf = -2006;
      *(_QWORD *)v66 = CFSTR("Invalid parent surface.");
      sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)v66);
    }
    v60 = 0;
LABEL_58:
    if (atomic_load((unint64_t *)&v60))
    {
      *(_QWORD *)buf = 0;
      v37 = *v15;
      v38 = (__IOSurface *)atomic_load((unint64_t *)&v60);
      v39 = CVPixelBufferCreateWithIOSurface(v37, v38, 0, (CVPixelBufferRef *)buf);
      if (!v39)
      {
        *a1 = *(_QWORD *)buf;
        sub_1D3D82B54((unint64_t *)&v60);
        return (unint64_t)sub_1D3D82B54((unint64_t *)&v61);
      }
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v40 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v66 = 67240192;
        *(_DWORD *)&v66[4] = v39;
        _os_log_error_impl(&dword_1D3D6B000, v40, OS_LOG_TYPE_ERROR, "CVPixelBufferCreateWithIOSurface failed when creating child Yp8: %{public}d", v66, 8u);
      }
    }
    else
    {
      *(_QWORD *)buf = -1;
      v68 = 0;
      v69[0] = 0;
      v69[4] = 0;
      v69[8] = 0;
      v70 = 0;
      LOBYTE(HeightOfPlane) = 0;
      v72 = 0;
      LOBYTE(BytesPerRowOfPlane) = 0;
      BYTE4(BytesPerRowOfPlane) = 0;
      v74 = 0;
      v75 = 0;
      v76 = 0u;
      v77 = 0u;
      if (*(_BYTE *)(a4 + 96))
      {
        sub_1D3DF4F24((unint64_t *)buf);
        sub_1D3DF50BC(buf, (uint64_t *)a4);
        if (*(_BYTE *)(a4 + 96))
        {
          sub_1D3DF4F24((unint64_t *)a4);
          *(_BYTE *)(a4 + 96) = 0;
        }
      }
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v41 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        sub_1D3DF53CC((CFErrorRef *)&v65, (uint64_t)buf);
        v59 = atomic_load((unint64_t *)&v65);
        *(_DWORD *)v66 = 138543362;
        *(_QWORD *)&v66[4] = v59;
        _os_log_error_impl(&dword_1D3D6B000, v41, OS_LOG_TYPE_ERROR, "Failed to create child Yp8 surface: %{public}@", v66, 0xCu);
        sub_1D3D7448C((unint64_t *)&v65);
      }
      sub_1D3DF4F24((unint64_t *)buf);
    }
    sub_1D3D82B54((unint64_t *)&v60);
    sub_1D3D82B54((unint64_t *)&v61);
  }
  v42 = (__CVBuffer *)atomic_load(a2);
  WidthOfPlane = CVPixelBufferGetWidthOfPlane(v42, 0);
  v44 = (__CVBuffer *)atomic_load(a2);
  v45 = CVPixelBufferGetHeightOfPlane(v44, 0);
  v46 = (__CVBuffer *)atomic_load(a2);
  v47 = CVPixelBufferGetBaseAddressOfPlane(v46, 0);
  v48 = (__CVBuffer *)atomic_load(a2);
  v49 = CVPixelBufferGetBytesPerRowOfPlane(v48, 0);
  result = CVPixelBufferCreateWithBytes(*v15, WidthOfPlane, v45, 0x4C303038u, v47, v49, 0, 0, 0, (CVPixelBufferRef *)&v62);
  v50 = result;
  if ((_DWORD)result)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v51 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&buf[4] = v50;
      _os_log_error_impl(&dword_1D3D6B000, v51, OS_LOG_TYPE_ERROR, "CVPixelBufferCreate failed when creating shallow Yp8: %{public}d", buf, 8u);
    }
    *(_QWORD *)buf = -2003;
    *(_QWORD *)v66 = CFSTR("CVPixelBufferCreate failed when creating shallow Yp8.");
    result = sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)v66);
    *(_DWORD *)(a4 + 24) = v50;
    *(_BYTE *)(a4 + 28) = 1;
LABEL_79:
    *a1 = 0;
    return result;
  }
  *a1 = v62;
  return result;
}

void sub_1D3D955F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  unint64_t v4;
  va_list va;
  unint64_t v6;
  va_list va1;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  sub_1D3DF4F24((unint64_t *)va2);
  sub_1D3D82B54((unint64_t *)va);
  sub_1D3D82B54((unint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D95674(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
    *(_BYTE *)(a1 + 16) = sub_1D3DE793C(*(unint64_t **)a1, *(_QWORD *)(a1 + 8)) ^ 1;
  return a1;
}

size_t sub_1D3D956B0(unint64_t *a1)
{
  __CVBuffer *v3;
  int IsPlanar;
  __CVBuffer *v5;
  size_t PlaneCount;
  size_t v7;
  __CVBuffer *v8;
  size_t result;
  size_t v10;
  size_t i;
  __CVBuffer *v12;
  size_t BytesPerRowOfPlane;
  size_t v14;

  if (!atomic_load(a1))
    return -1;
  v3 = (__CVBuffer *)atomic_load(a1);
  IsPlanar = CVPixelBufferIsPlanar(v3);
  v5 = (__CVBuffer *)atomic_load(a1);
  if (!IsPlanar)
    return CVPixelBufferGetBytesPerRow(v5);
  PlaneCount = CVPixelBufferGetPlaneCount(v5);
  if (!PlaneCount)
    return -1;
  v7 = PlaneCount;
  v8 = (__CVBuffer *)atomic_load(a1);
  result = CVPixelBufferGetBytesPerRowOfPlane(v8, 0);
  v10 = result;
  if (v7 != 1)
  {
    for (i = 1; i != v7; ++i)
    {
      v12 = (__CVBuffer *)atomic_load(a1);
      BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v12, i);
      if (BytesPerRowOfPlane)
      {
        v14 = BytesPerRowOfPlane;
        do
        {
          result = v14;
          v14 = v10 % v14;
          v10 = result;
        }
        while (v14);
      }
      else
      {
        result = v10;
      }
      v10 = result;
    }
  }
  return result;
}

double sub_1D3D95778(CGRect *a1, unint64_t a2, char a3, OSType a4)
{
  double v8;
  double v9;
  double v10;
  double v11;
  const __CFDictionary *v13;
  const __CFArray *Value;
  const __CFArray *v15;
  unint64_t Count;
  unint64_t v17;
  char *v18;
  CFIndex v19;
  uint64_t v20;
  char *v21;
  const void *v22;
  char *v23;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v25;
  CFTypeID v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  CFTypeID v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t i;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  const __CFDictionary *v46;
  const __CFNumber *v47;
  const __CFNumber *v48;
  CFTypeID v49;
  int v50;
  _BOOL4 v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t MinX;
  unint64_t v56;
  unint64_t v58;
  int valuePtr;
  CFDictionaryRef v60;
  CGRect v61;
  CGRect v62;

  v8 = floor(CGRectGetMinX(*a1) * 0.5);
  v9 = floor(CGRectGetMinY(*a1) * 0.5);
  v10 = ceil(CGRectGetMaxX(*a1) * 0.5) - v8;
  v11 = ceil(CGRectGetMaxY(*a1) * 0.5) - v9;
  if ((a3 & 0xF) != 0)
    return v8;
  v60 = CVPixelFormatDescriptionCreateWithPixelFormatType((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a4);
  if (!atomic_load((unint64_t *)&v60))
    goto LABEL_50;
  v13 = (const __CFDictionary *)atomic_load((unint64_t *)&v60);
  Value = (const __CFArray *)CFDictionaryGetValue(v13, (const void *)*MEMORY[0x1E0CA91B0]);
  v15 = Value;
  if (Value)
  {
    Count = CFArrayGetCount(Value);
    v17 = Count;
    if (Count)
    {
      if (Count >> 61)
        sub_1D3D6D4F8();
      v18 = (char *)sub_1D3D6D8A0(Count);
      v19 = 0;
      v21 = &v18[8 * v20];
      v22 = (const void *)*MEMORY[0x1E0CA90E8];
      v23 = v18;
      v58 = a2;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v19);
        v25 = ValueAtIndex;
        if (!ValueAtIndex)
          goto LABEL_51;
        v26 = CFGetTypeID(ValueAtIndex);
        if (v26 != CFDictionaryGetTypeID())
          goto LABEL_51;
        v27 = (const __CFNumber *)CFDictionaryGetValue(v25, v22);
        v28 = v27;
        if (!v27)
          goto LABEL_51;
        v29 = CFGetTypeID(v27);
        if (v29 != CFNumberGetTypeID())
          goto LABEL_51;
        valuePtr = 0;
        if (!CFNumberGetValue(v28, kCFNumberIntType, &valuePtr))
          goto LABEL_51;
        v30 = valuePtr;
        if (v23 >= v21)
        {
          v31 = (v23 - v18) >> 3;
          v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 61)
            sub_1D3D6D4F8();
          if ((v21 - v18) >> 2 > v32)
            v32 = (v21 - v18) >> 2;
          if ((unint64_t)(v21 - v18) >= 0x7FFFFFFFFFFFFFF8)
            v33 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v33 = v32;
          if (v33)
            v33 = (unint64_t)sub_1D3D6D8A0(v33);
          else
            v34 = 0;
          v35 = (char *)(v33 + 8 * v31);
          *(_QWORD *)v35 = v30;
          v36 = v35 + 8;
          while (v23 != v18)
          {
            v37 = *((_QWORD *)v23 - 1);
            v23 -= 8;
            *((_QWORD *)v35 - 1) = v37;
            v35 -= 8;
          }
          v21 = (char *)(v33 + 8 * v34);
          if (v18)
            operator delete(v18);
          v18 = v35;
          v23 = v36;
          a2 = v58;
        }
        else
        {
          *(_QWORD *)v23 = valuePtr;
          v23 += 8;
        }
        ++v19;
      }
      while (v19 != v17);
      if (v18 == v23)
      {
LABEL_51:
        LOBYTE(v41) = 0;
        v51 = 0;
        v52 = 0;
        if (!v18)
          goto LABEL_53;
      }
      else
      {
        v38 = *(_QWORD *)v18;
        if ((unint64_t)(v23 - v18) < 9)
        {
          v41 = *(_QWORD *)v18;
        }
        else
        {
          v39 = (v23 - v18) >> 3;
          if (v39 <= 2)
            v39 = 2;
          for (i = 1; i != v39; ++i)
          {
            v41 = 0;
            if (v38)
            {
              v42 = *(_QWORD *)&v18[8 * i];
              if (v42)
              {
                v43 = *(_QWORD *)&v18[8 * i];
                v44 = v38;
                do
                {
                  v45 = v44;
                  v44 = v43;
                  v43 = v45 % v43;
                }
                while (v43);
                v41 = v38 / v44 * v42;
              }
            }
            v38 = v41;
          }
        }
        v52 = v41 & 0xFFFFFFFFFFFFFF00;
        v51 = 1;
        if (!v18)
          goto LABEL_53;
      }
      operator delete(v18);
      goto LABEL_53;
    }
LABEL_50:
    sub_1D3D8BAAC((unint64_t *)&v60);
    return v8;
  }
  v46 = (const __CFDictionary *)atomic_load((unint64_t *)&v60);
  v47 = (const __CFNumber *)CFDictionaryGetValue(v46, (const void *)*MEMORY[0x1E0CA90E8]);
  v48 = v47;
  if (!v47)
    goto LABEL_50;
  v49 = CFGetTypeID(v47);
  if (v49 != CFNumberGetTypeID())
    goto LABEL_50;
  valuePtr = 0;
  v50 = CFNumberGetValue(v48, kCFNumberIntType, &valuePtr);
  v51 = v50 != 0;
  if (v50)
    LOBYTE(v41) = valuePtr;
  else
    LOBYTE(v41) = 0;
  if (v50)
    v52 = valuePtr & 0xFFFFFFFFFFFFFF00;
  else
    v52 = 0;
LABEL_53:
  sub_1D3D8BAAC((unint64_t *)&v60);
  if (v51)
  {
    v53 = a2;
    v54 = ((v52 & 0xFFFFFFFFFFFFFF00 | v41) + 7) >> 3;
    v61.origin.x = v8;
    v61.origin.y = v9;
    v61.size.width = v10;
    v61.size.height = v11;
    MinX = (unint64_t)CGRectGetMinX(v61);
    v62.origin.x = v8;
    v62.origin.y = v9;
    v62.size.width = v10;
    v62.size.height = v11;
    CGRectGetMaxX(v62);
    v56 = ((v54 * MinX) & 0xFFFFFFFFFFFFFFF0) / v54;
    if (v56 >= v53)
      return (double)v53;
    return (double)v56;
  }
  return v8;
}

void sub_1D3D95B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  sub_1D3D8BAAC((unint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D3D95BCC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::transferImage", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3D95C6C(unint64_t *a1, CFTypeRef cf)
{
  CFTypeRef v3;
  const void *v4;

  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  do
    v4 = (const void *)__ldaxr(a1);
  while (__stlxr((unint64_t)v3, a1));
  if (v4)
    CFRelease(v4);
}

void sub_1D3D95CC0()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D95CD4()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B0D40;
  return result;
}

void sub_1D3D95CF8(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B0D40;
}

void sub_1D3D95D10(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::transferImage", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3D95DB0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D95DE8()
{
  return &unk_1E95B0DA0;
}

void sub_1D3D95DF8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D95E0C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B0CC0;
  return result;
}

void sub_1D3D95E30(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B0CC0;
}

uint64_t sub_1D3D95E48(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D95E80()
{
  return &unk_1E95B0D20;
}

void sub_1D3D95E90()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D95EA4(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B0F40;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D95ED8(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B0F40;
  a2[1] = v2;
  return result;
}

void sub_1D3D95EF4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  __int16 v8;
  unint64_t v9;
  uint64_t v10;
  CGRect v11;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v5 = vcvtpd_u64_f64(CGRectGetWidth(*(CGRect *)(**(_QWORD **)(a1 + 8) + 8)));
      v11 = *(CGRect *)(**(_QWORD **)(a1 + 8) + 8);
      v6 = 134349312;
      v7 = v5;
      v8 = 2050;
      v9 = vcvtpd_u64_f64(CGRectGetHeight(v11));
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v3, "PyramidGenerationSession::generatePyramid", "masterPixelBufferWidth=%{public, signpost.description:attribute}zu, masterPixelBufferHeight=%{public, signpost.description:attribute}zu", (uint8_t *)&v6, 0x16u);
    }
  }
}

uint64_t sub_1D3D96014(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9604C()
{
  return &unk_1E95B0FA0;
}

void sub_1D3D9605C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D96070(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B0EC0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D960A4(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B0EC0;
  a2[1] = v2;
  return result;
}

void sub_1D3D960C0(uint64_t a1, os_signpost_id_t *a2)
{
  sub_1D3D94B0C(a1 + 8, *a2);
}

uint64_t sub_1D3D960CC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D96104()
{
  return &unk_1E95B0F20;
}

_QWORD *sub_1D3D96110(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v12;
  _QWORD *result;
  uint64_t v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  *a1 = 0;
  v12 = operator new(0x30uLL);
  *v12 = &off_1E95B0FC0;
  v12[1] = a5;
  v12[2] = a1;
  v12[3] = a3;
  v12[4] = a4;
  v12[5] = a6;
  v16 = v12;
  sub_1D3D96230(a2, v15);
  result = v16;
  if (v16 == v15)
  {
    v14 = 4;
    result = v15;
  }
  else
  {
    if (!v16)
      return result;
    v14 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void sub_1D3D961E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  unint64_t *v13;
  char *v14;
  char *v16;
  uint64_t v17;

  v16 = a13;
  if (a13 == v14)
  {
    v17 = 4;
    v16 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:
  sub_1D3D74138(v13);
  _Unwind_Resume(a1);
}

void sub_1D3D96230(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  std::__shared_weak_count *v4;
  os_unfair_lock_s *v5;
  _QWORD *v6;
  uint64_t v7;
  NSObject *shared_weak_owners;
  _QWORD *v9;
  uint64_t v10;
  NSObject *v11;
  dispatch_queue_t v12;
  uint64_t (*v13)(_QWORD);
  CFTypeRef v14;
  CFTypeRef v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  uint64_t (***v19)();
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  NSObject *v25;
  uint64_t *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  void *v32;
  __int128 v33;
  _BYTE v34[24];
  _BYTE *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t context[3];
  uint64_t *v39;
  char v40;
  uint64_t (**v41)();
  char v42;
  uint64_t (***v43)();
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v2 = a2 + 3;
  if (!a2[3])
    return;
  v4 = (std::__shared_weak_count *)a1;
  v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  v6 = sub_1D3D967F4(&v4[1].__vftable, (unint64_t)&unk_1D3E64368);
  if (!v6)
  {
    v7 = (uint64_t)v4->__vftable;
    shared_weak_owners = v4->__shared_weak_owners_;
    v32 = &unk_1D3E64368;
    *(_QWORD *)&v33 = "PyramidGenerationSessionContext";
    *((_QWORD *)&v33 + 1) = 31;
    v9 = (_QWORD *)operator new();
    v10 = operator new();
    v11 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v12 = dispatch_queue_create_with_target_V2("mrc::Context::ConcreteBase<mrc::(anonymous namespace)::PyramidGenerationSessionContext<mrc::PyramidGenerationBehavior::Default>>::ConcreteBase(const Options &, dispatch_queue_t _Nonnull) [_Derived = mrc::(anonymous namespace)::PyramidGenerationSessionContext<mrc::PyramidGenerationBehavior::Default>]", v11, shared_weak_owners);
    v13 = MEMORY[0x1E0C82E98];
    *(_QWORD *)(v10 + 8) = v12;
    *(_QWORD *)(v10 + 16) = v13;
    *(_QWORD *)v10 = &off_1E95B17A8;
    *(_QWORD *)(v10 + 24) = *(_QWORD *)v7;
    v14 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 8));
    if (v14)
      v14 = CFRetain(v14);
    *(_QWORD *)(v10 + 32) = v14;
    v15 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 16));
    if (v15)
      v15 = CFRetain(v15);
    *(_QWORD *)(v10 + 40) = v15;
    v16 = *(_OWORD *)(v7 + 24);
    v17 = *(_OWORD *)(v7 + 40);
    *(_WORD *)(v10 + 80) = *(_WORD *)(v7 + 56);
    *(_OWORD *)(v10 + 48) = v16;
    *(_OWORD *)(v10 + 64) = v17;
    *(_BYTE *)(v10 + 88) = 0;
    *(_BYTE *)(v10 + 96) = 0;
    *(_BYTE *)(v10 + 104) = 0;
    *(_BYTE *)(v10 + 200) = 0;
    *v9 = v10;
    v18 = (_QWORD *)operator new();
    *v18 = &off_1E95B1810;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = v10;
    v9[1] = v18;
    v41 = &off_1E95B1860;
    v43 = &v41;
    v36 = v9;
    sub_1D3D96968((uint64_t)&v37, (uint64_t)&v41);
    sub_1D3E23E40((uint64_t)context, (uint64_t)&unk_1D3E64368, &v33, (uint64_t *)&v36);
    sub_1D3D969CC((uint64_t *)&v36);
    v19 = v43;
    if (v43 == &v41)
    {
      v20 = 4;
      v19 = &v41;
    }
    else
    {
      if (!v43)
      {
LABEL_12:
        v6 = sub_1D3D96A58((uint64_t *)&v4[1], &v32, context);
        sub_1D3D969CC((uint64_t *)&v39);
        sub_1D3E23B04((uint64_t *)v4);
        goto LABEL_13;
      }
      v20 = 5;
    }
    (*v19)[v20]();
    goto LABEL_12;
  }
LABEL_13:
  if ((_UNKNOWN *)v6[3] != &unk_1D3E64368)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_50;
  }
  v21 = (uint64_t *)v6[6];
  if (!v21)
  {
LABEL_50:
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_51;
  }
  v22 = *v21;
  v4 = (std::__shared_weak_count *)v21[1];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v5);
  if (!v22)
  {
    if (qword_1EDB89F40 == -1)
    {
LABEL_23:
      v25 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        LOWORD(context[0]) = 0;
        _os_log_error_impl(&dword_1D3D6B000, v25, OS_LOG_TYPE_ERROR, "Unable to retrieve or instantiate concrete PyramidGenerationSession context.", (uint8_t *)context, 2u);
      }
      LOBYTE(v41) = 0;
      v42 = 0;
      sub_1D3DF4E68((uint64_t)&v36, -1, 0);
      sub_1D3DF50BC(context, (uint64_t *)&v36);
      v40 = 1;
      if (!*v2)
        sub_1D3D75A24();
      (*(void (**)(_QWORD, uint64_t (***)(), uint64_t *))(*(_QWORD *)*v2 + 48))(*v2, &v41, context);
      if (v40)
        sub_1D3DF4F24((unint64_t *)context);
      sub_1D3DF4F24((unint64_t *)&v36);
      goto LABEL_43;
    }
LABEL_51:
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    goto LABEL_23;
  }
  if (!*v2)
  {
    v2 = &v35;
    goto LABEL_30;
  }
  if ((_QWORD *)*v2 != a2)
  {
    v35 = (_BYTE *)*v2;
LABEL_30:
    *v2 = 0;
    goto LABEL_32;
  }
  v35 = v34;
  (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v34);
LABEL_32:
  if (!v35)
    goto LABEL_43;
  context[0] = (uint64_t)&off_1E95B18E0;
  context[1] = v22;
  context[2] = (uint64_t)v34;
  v39 = context;
  dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v22 + 8), context, (dispatch_function_t)sub_1D3D96F68);
  v26 = v39;
  if (v39 == context)
  {
    v27 = 4;
    v26 = context;
  }
  else
  {
    if (!v39)
      goto LABEL_38;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_38:
  v28 = v35;
  if (v35 == v34)
  {
    v29 = 4;
    v28 = v34;
  }
  else
  {
    if (!v35)
      goto LABEL_43;
    v29 = 5;
  }
  (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_43:
  if (v4)
  {
    v30 = (unint64_t *)&v4->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1D3D966D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3D967F4(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1D3D968DC(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 200))
      sub_1D3DF4F24((unint64_t *)(result + 104));
    if (*(_BYTE *)(v1 + 96))
    {
      v2 = *(_QWORD *)(v1 + 88);
      *(_QWORD *)(v1 + 88) = 0;
      if (v2)
        sub_1D3D94A48(v2);
    }
    sub_1D3D8BA0C((unint64_t *)(v1 + 40));
    sub_1D3D8BA0C((unint64_t *)(v1 + 32));
    v3 = *(_QWORD *)(v1 + 8);
    *(_QWORD *)v1 = &off_1E95B17F0;
    *(_QWORD *)(v1 + 8) = 0;
    if (v3)
      (*(void (**)(void))(v1 + 16))();
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3D96968(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t *sub_1D3D969CC(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v7 = v2;
    v3 = a1[4];
    if (!v3)
      sub_1D3D75A24();
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v7);
  }
  v4 = (uint64_t *)a1[4];
  if (v4 == a1 + 1)
  {
    v5 = 4;
    v4 = a1 + 1;
    goto LABEL_8;
  }
  if (v4)
  {
    v5 = 5;
LABEL_8:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  return a1;
}

_QWORD *sub_1D3D96A58(uint64_t *a1, _QWORD *a2, uint64_t *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint8x8_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  int8x8_t prime;
  void *v26;
  void *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint8x8_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t v37;
  uint8x8_t v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  void *v43;
  _QWORD v44[2];
  char v45;

  v6 = a1 + 2;
  v7 = operator new(0x58uLL);
  v44[0] = v7;
  v44[1] = v6;
  v45 = 0;
  *v7 = 0;
  v7[1] = 0;
  v8 = *a3;
  v7[2] = *a2;
  v7[3] = v8;
  v9 = *(_OWORD *)(a3 + 1);
  v7[6] = a3[3];
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  *((_OWORD *)v7 + 2) = v9;
  sub_1D3D96968((uint64_t)(v7 + 7), (uint64_t)(a3 + 4));
  if (!v7[3])
    _os_assumes_log();
  if (!v7[6])
    _os_assumes_log();
  v45 = 1;
  v10 = v7[2];
  v11 = 0x9DDFEA08EB382D69 * (((8 * v10) + 8) ^ HIDWORD(v10));
  v12 = 0x9DDFEA08EB382D69 * (HIDWORD(v10) ^ (v11 >> 47) ^ v11);
  v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
  v7[1] = v13;
  v14 = a1[1];
  if (!v14)
    goto LABEL_21;
  v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    v16 = v13;
    if (v14 <= v13)
      v16 = v13 % v14;
  }
  else
  {
    v16 = (v14 - 1) & v13;
  }
  v17 = *(_QWORD **)(*a1 + 8 * v16);
  if (!v17 || (v18 = (_QWORD *)*v17) == 0)
  {
LABEL_21:
    v20 = (float)(unint64_t)(a1[3] + 1);
    v21 = *((float *)a1 + 8);
    if (!v14 || (float)(v21 * (float)v14) < v20)
    {
      v22 = 1;
      if (v14 >= 3)
        v22 = (v14 & (v14 - 1)) != 0;
      v23 = v22 | (2 * v14);
      v24 = vcvtps_u32_f32(v20 / v21);
      if (v23 <= v24)
        prime = (int8x8_t)v24;
      else
        prime = (int8x8_t)v23;
      if (*(_QWORD *)&prime == 1)
      {
        prime = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
      {
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
        v14 = a1[1];
      }
      if (*(_QWORD *)&prime > v14)
        goto LABEL_89;
      if (*(_QWORD *)&prime >= v14)
        goto LABEL_62;
      v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v14 < 3 || (v33 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }
      else
      {
        v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2)
          v32 = v34;
      }
      if (*(_QWORD *)&prime <= v32)
        prime = (int8x8_t)v32;
      if (*(_QWORD *)&prime >= v14)
      {
        v14 = a1[1];
        goto LABEL_62;
      }
      if (prime)
      {
LABEL_89:
        if (*(_QWORD *)&prime >> 61)
          sub_1D3D6D50C();
        v26 = operator new(8 * *(_QWORD *)&prime);
        v27 = (void *)*a1;
        *a1 = (uint64_t)v26;
        if (v27)
          operator delete(v27);
        v28 = 0;
        a1[1] = (uint64_t)prime;
        do
          *(_QWORD *)(*a1 + 8 * v28++) = 0;
        while (*(_QWORD *)&prime != v28);
        v29 = (_QWORD *)*v6;
        if (*v6)
        {
          v30 = v29[1];
          v31 = (uint8x8_t)vcnt_s8(prime);
          v31.i16[0] = vaddlv_u8(v31);
          if (v31.u32[0] > 1uLL)
          {
            if (v30 >= *(_QWORD *)&prime)
              v30 %= *(_QWORD *)&prime;
          }
          else
          {
            v30 &= *(_QWORD *)&prime - 1;
          }
          *(_QWORD *)(*a1 + 8 * v30) = v6;
          v35 = (_QWORD *)*v29;
          if (*v29)
          {
            do
            {
              v36 = v35[1];
              if (v31.u32[0] > 1uLL)
              {
                if (v36 >= *(_QWORD *)&prime)
                  v36 %= *(_QWORD *)&prime;
              }
              else
              {
                v36 &= *(_QWORD *)&prime - 1;
              }
              if (v36 != v30)
              {
                if (!*(_QWORD *)(*a1 + 8 * v36))
                {
                  *(_QWORD *)(*a1 + 8 * v36) = v29;
                  goto LABEL_58;
                }
                *v29 = *v35;
                *v35 = **(_QWORD **)(*a1 + 8 * v36);
                **(_QWORD **)(*a1 + 8 * v36) = v35;
                v35 = v29;
              }
              v36 = v30;
LABEL_58:
              v29 = v35;
              v35 = (_QWORD *)*v35;
              v30 = v36;
            }
            while (v35);
          }
        }
        v14 = (unint64_t)prime;
      }
      else
      {
        v43 = (void *)*a1;
        *a1 = 0;
        if (v43)
          operator delete(v43);
        v14 = 0;
        a1[1] = 0;
      }
    }
LABEL_62:
    v37 = v7[1];
    v38 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v38.i16[0] = vaddlv_u8(v38);
    if (v38.u32[0] > 1uLL)
    {
      if (v37 >= v14)
        v37 %= v14;
    }
    else
    {
      v37 &= v14 - 1;
    }
    v39 = *a1;
    v40 = *(_QWORD **)(*a1 + 8 * v37);
    if (v40)
    {
      *v7 = *v40;
    }
    else
    {
      *v7 = *v6;
      *v6 = v7;
      *(_QWORD *)(v39 + 8 * v37) = v6;
      if (!*v7)
      {
LABEL_75:
        ++a1[3];
        v44[0] = 0;
        goto LABEL_76;
      }
      v41 = *(_QWORD *)(*v7 + 8);
      if (v38.u32[0] > 1uLL)
      {
        if (v41 >= v14)
          v41 %= v14;
      }
      else
      {
        v41 &= v14 - 1;
      }
      v40 = (_QWORD *)(*a1 + 8 * v41);
    }
    *v40 = v7;
    goto LABEL_75;
  }
  while (1)
  {
    v19 = v18[1];
    if (v19 == v13)
      break;
    if (v15.u32[0] > 1uLL)
    {
      if (v19 >= v14)
        v19 %= v14;
    }
    else
    {
      v19 &= v14 - 1;
    }
    if (v19 != v16)
      goto LABEL_21;
LABEL_20:
    v18 = (_QWORD *)*v18;
    if (!v18)
      goto LABEL_21;
  }
  if (v18[2] != v10)
    goto LABEL_20;
  v7 = v18;
LABEL_76:
  sub_1D3D9B58C((uint64_t)v44);
  return v7;
}

void sub_1D3D96EE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t *v2;
  va_list va;

  va_start(va, a2);
  sub_1D3D969CC(v2);
  sub_1D3D9B58C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D96F10(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

uint64_t sub_1D3D96F68(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (!v1)
    sub_1D3D75A24();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void sub_1D3D96F90()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D96FA4(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95B18E0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3D96FDC(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95B18E0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unint64_t *sub_1D3D96FFC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *result;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t (***v13)();
  uint64_t v14;
  const __CFAllocator *v15;
  OSStatus v16;
  NSObject *v17;
  unint64_t *v18;
  unint64_t v19;
  const void *v20;
  int v21;
  unint64_t v22;
  const void *v24;
  const void *v25;
  qos_class_t v26;
  unsigned int v27;
  unint64_t v28;
  unsigned int v29;
  BOOL v30;
  CFTypeRef *v31;
  const void *v32;
  const void *v33;
  CFTypeRef v34;
  const void *v35;
  const void *v36;
  int v37;
  const void *v38;
  const __CFString *v39;
  unint64_t v40;
  _BYTE *v41;
  uint64_t v42;
  uint64_t v43;
  CFTypeRef v44;
  CFTypeRef v45;
  __int128 v46;
  __int128 v47;
  NSObject *v48;
  _BYTE *v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  uint64_t v62;
  OpaqueVTPixelTransferSession *v63;
  char v64;
  unint64_t v65;
  unsigned __int8 v66;
  VTPixelTransferSessionRef v67;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  OpaqueVTPixelTransferSession **v69;
  _QWORD v70[3];
  _QWORD *v71;
  _BYTE v72[22];
  _BYTE *v73;
  char v74;
  _QWORD v75[3];
  _QWORD *v76;
  _QWORD v77[3];
  _QWORD *v78;
  uint8_t buf[8];
  _QWORD v80[3];
  _QWORD *v81;
  uint64_t (**v82)();
  char v83;
  uint64_t *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v2 + 200))
  {
    v3 = *(_QWORD *)(a1 + 16);
    LOBYTE(v69) = 0;
    LOBYTE(v70[0]) = 0;
    sub_1D3DF4F6C((uint64_t)v72, v2 + 104);
    v74 = 1;
    v4 = *(_QWORD *)(v3 + 24);
    if (!v4)
      sub_1D3D75A24();
    result = (unint64_t *)(*(uint64_t (**)(uint64_t, OpaqueVTPixelTransferSession ***, _BYTE *))(*(_QWORD *)v4 + 48))(v4, &v69, v72);
LABEL_105:
    if (!v74)
      return result;
    v61 = (unint64_t *)v72;
    return sub_1D3DF4F24(v61);
  }
  v6 = (uint64_t *)(v2 + 88);
  if (*(_BYTE *)(v2 + 96))
  {
LABEL_103:
    v59 = *(_QWORD *)(a1 + 16);
    v69 = (OpaqueVTPixelTransferSession **)(v2 + 88);
    LOBYTE(v70[0]) = 1;
    v72[0] = 0;
    v74 = 0;
    v60 = *(_QWORD *)(v59 + 24);
    if (!v60)
      sub_1D3D75A24();
    result = (unint64_t *)(*(uint64_t (**)(uint64_t, OpaqueVTPixelTransferSession ***, _BYTE *))(*(_QWORD *)v60 + 48))(v60, &v69, v72);
    goto LABEL_105;
  }
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v63 = (OpaqueVTPixelTransferSession *)os_signpost_id_make_with_pointer((os_log_t)qword_1EDB89F48, (const void *)v2);
  v64 = 1;
  v78 = v77;
  v75[0] = &off_1E95B10D0;
  v76 = v75;
  v77[0] = &off_1E95B1050;
  v71 = v70;
  v69 = &v63;
  v70[0] = &off_1E95B10D0;
  sub_1D3D979E0((os_signpost_id_t)v63);
  v7 = v76;
  if (v76 == v75)
  {
    v8 = 4;
    v7 = v75;
  }
  else
  {
    if (!v76)
      goto LABEL_12;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_12:
  v9 = v78;
  if (v78 == v77)
  {
    v10 = 4;
    v9 = v77;
    goto LABEL_16;
  }
  if (v78)
  {
    v10 = 5;
LABEL_16:
    v9 = (_QWORD *)(*(uint64_t (**)(void))(*v9 + 8 * v10))();
  }
  v84 = (uint64_t *)&v82;
  v80[0] = &off_1E95B11D0;
  v81 = v80;
  v82 = &off_1E95B1150;
  v73 = &v72[8];
  *(_QWORD *)v72 = &v63;
  *(_QWORD *)&v72[8] = &off_1E95B11D0;
  if (!v64
    || (pixelTransferSessionOut = v63,
        sub_1D3D97A80((uint64_t)v9, (os_signpost_id_t *)&pixelTransferSessionOut),
        v11 = v81,
        v81 == v80))
  {
    v12 = 4;
    v11 = v80;
  }
  else
  {
    if (!v81)
      goto LABEL_23;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_23:
  v13 = (uint64_t (***)())v84;
  if (v84 == (uint64_t *)&v82)
  {
    v14 = 4;
    v13 = &v82;
  }
  else
  {
    if (!v84)
      goto LABEL_28;
    v14 = 5;
  }
  (*v13)[v14]();
LABEL_28:
  pixelTransferSessionOut = 0;
  v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v16 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
  if (v16)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v17 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&buf[4] = v16;
      _os_log_error_impl(&dword_1D3D6B000, v17, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate failed: %{public}d", buf, 8u);
    }
    *(_QWORD *)buf = -2003;
    v67 = (VTPixelTransferSessionRef)CFSTR("VTPixelTransferSessionCreate failed.");
    sub_1D3D73E0C((unint64_t *)(v2 + 104), (uint64_t *)buf, (CFTypeRef *)&v67);
    *(_QWORD *)buf = CFErrorCreate(v15, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v16, 0);
    v18 = (unint64_t *)(v2 + 168);
    do
      v19 = __ldaxr((unint64_t *)buf);
    while (__stlxr(0, (unint64_t *)buf));
    do
      v20 = (const void *)__ldaxr(v18);
    while (__stlxr(v19, v18));
    if (v20)
      CFRelease(v20);
    sub_1D3D7448C((unint64_t *)buf);
    v21 = 0;
    LOBYTE(v65) = 0;
    v66 = 0;
  }
  else
  {
    v67 = pixelTransferSessionOut;
    do
      v22 = __ldaxr((unint64_t *)&v67);
    while (__stlxr(0, (unint64_t *)&v67));
    *(_QWORD *)buf = v22;
    if (atomic_load((unint64_t *)buf))
    {
      v24 = (const void *)atomic_load((unint64_t *)buf);
      VTSessionSetProperty(v24, (CFStringRef)*MEMORY[0x1E0CED848], (CFTypeRef)*MEMORY[0x1E0CEDB40]);
      v25 = (const void *)atomic_load((unint64_t *)buf);
      VTSessionSetProperty(v25, (CFStringRef)*MEMORY[0x1E0CED7F0], (CFTypeRef)*MEMORY[0x1E0CED490]);
      v26 = *(_DWORD *)(v2 + 48);
      HIDWORD(v28) = v26 - 9;
      LODWORD(v28) = v26 - 9;
      v27 = v28 >> 2;
      v29 = (0x22u >> (v28 >> 2)) & 1;
      v30 = v27 <= 6 && v29 == 0;
      v31 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      if (v30)
      {
        if (v27 > 6 || ((1 << v27) & 0x5D) == 0)
          v26 = qos_class_self();
        if (v26 == QOS_CLASS_USER_INTERACTIVE)
        {
          v32 = (const void *)atomic_load((unint64_t *)buf);
          VTSessionSetProperty(v32, (CFStringRef)*MEMORY[0x1E0CED838], *v31);
        }
      }
      v33 = (const void *)atomic_load((unint64_t *)buf);
      v34 = *v31;
      VTSessionSetProperty(v33, (CFStringRef)*MEMORY[0x1E0CED808], v34);
      v35 = (const void *)atomic_load((unint64_t *)buf);
      v36 = (const void *)*MEMORY[0x1E0C9AE40];
      VTSessionSetProperty(v35, (CFStringRef)*MEMORY[0x1E0CED868], (CFTypeRef)*MEMORY[0x1E0C9AE40]);
      v37 = _os_feature_enabled_impl();
      v38 = (const void *)atomic_load((unint64_t *)buf);
      v39 = (const __CFString *)*MEMORY[0x1E0CED800];
      if (v37)
      {
        VTSessionSetProperty(v38, v39, v34);
        v38 = (const void *)atomic_load((unint64_t *)buf);
        v39 = (const __CFString *)*MEMORY[0x1E0CED860];
      }
      else
      {
        v34 = v36;
      }
      VTSessionSetProperty(v38, v39, v34);
    }
    do
      v40 = __ldaxr((unint64_t *)buf);
    while (__stlxr(0, (unint64_t *)buf));
    v65 = v40;
    v21 = 1;
    v66 = 1;
    sub_1D3D94AA0((unint64_t *)buf);
    sub_1D3D94AD4((unint64_t *)&v67);
  }
  v41 = v73;
  if (*(_BYTE *)(*(_QWORD *)v72 + 8))
  {
    if (!v73)
      goto LABEL_65;
    pixelTransferSessionOut = **(VTPixelTransferSessionRef **)v72;
    (*(void (**)(void))(*(_QWORD *)v73 + 48))();
    v41 = v73;
  }
  if (v41 == &v72[8])
  {
    v42 = 4;
    v41 = &v72[8];
  }
  else
  {
    if (!v41)
      goto LABEL_65;
    v42 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v41 + 8 * v42))();
  v21 = v66;
LABEL_65:
  if (v21)
  {
    v43 = operator new();
    *(_QWORD *)(v43 + 8) = -1;
    *(_QWORD *)(v43 + 16) = -1;
    *(_DWORD *)(v43 + 24) = 1061109567;
    *(_QWORD *)v43 = &off_1E95B1250;
    *(_QWORD *)(v43 + 32) = *(_QWORD *)(v2 + 24);
    v44 = (CFTypeRef)atomic_load((unint64_t *)(v2 + 32));
    if (v44)
      v44 = CFRetain(v44);
    *(_QWORD *)(v43 + 40) = v44;
    v45 = (CFTypeRef)atomic_load((unint64_t *)(v2 + 40));
    if (v45)
      v45 = CFRetain(v45);
    *(_QWORD *)(v43 + 48) = v45;
    v46 = *(_OWORD *)(v2 + 48);
    v47 = *(_OWORD *)(v2 + 64);
    *(_WORD *)(v43 + 88) = *(_WORD *)(v2 + 80);
    *(_OWORD *)(v43 + 72) = v47;
    *(_OWORD *)(v43 + 56) = v46;
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v48 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v72 = 136446466;
      *(_QWORD *)&v72[4] = "PlaceholderPyramidAllocator";
      *(_WORD *)&v72[12] = 2050;
      *(_QWORD *)&v72[14] = v43;
      _os_log_debug_impl(&dword_1D3D6B000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", v72, 0x16u);
    }
    v82 = 0;
    *(_QWORD *)v72 = 0;
    sub_1D3D97B20((uint64_t *)v72);
    sub_1D3D97B20((uint64_t *)&v82);
    v49 = (_BYTE *)operator new();
    v50 = (uint64_t)v49;
    *v49 = 0;
    v49[8] = 0;
    if (v66)
    {
      do
        v51 = __ldaxr(&v65);
      while (__stlxr(0, &v65));
      *(_QWORD *)v49 = v51;
      v49[8] = 1;
      if (v66)
        sub_1D3D94AA0(&v65);
    }
    *(_QWORD *)(v50 + 16) = v43;
    v52 = 1;
  }
  else
  {
    v50 = 0;
    v52 = 0;
  }
  v53 = v71;
  if (*((_BYTE *)v69 + 8))
  {
    if (!v71)
      goto LABEL_88;
    *(_QWORD *)v72 = *v69;
    (*(void (**)(void))(*v71 + 48))();
    v53 = v71;
  }
  if (v53 == v70)
  {
    v54 = 4;
    v53 = v70;
  }
  else
  {
    if (!v53)
      goto LABEL_88;
    v54 = 5;
  }
  (*(void (**)(void))(*v53 + 8 * v54))();
LABEL_88:
  if (*(unsigned __int8 *)(v2 + 96) == v52)
  {
    if (*(_BYTE *)(v2 + 96))
    {
      v55 = *v6;
      *v6 = v50;
      v50 = v55;
      if (!v55)
        goto LABEL_99;
LABEL_98:
      sub_1D3D94A48(v50);
    }
  }
  else
  {
    if (!*(_BYTE *)(v2 + 96))
    {
      *(_QWORD *)(v2 + 88) = v50;
      *(_BYTE *)(v2 + 96) = 1;
      goto LABEL_103;
    }
    v56 = *v6;
    *v6 = 0;
    if (v56)
      sub_1D3D94A48(v56);
    *(_BYTE *)(v2 + 96) = 0;
  }
  if (v21 && v50)
    goto LABEL_98;
LABEL_99:
  if (*(_BYTE *)(v2 + 96))
    goto LABEL_103;
  v57 = *(_QWORD *)(a1 + 16);
  LOBYTE(v82) = 0;
  v83 = 0;
  v58 = *(unsigned __int8 *)(v2 + 200);
  if (*(_BYTE *)(v2 + 200))
  {
    sub_1D3DF4F6C((uint64_t)v72, v2 + 104);
  }
  else
  {
    sub_1D3DF4E68((uint64_t)&v69, -1, 0);
    sub_1D3DF50BC(v72, (uint64_t *)&v69);
  }
  v74 = 1;
  v62 = *(_QWORD *)(v57 + 24);
  if (!v62)
    sub_1D3D75A24();
  result = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t (***)(), _BYTE *))(*(_QWORD *)v62 + 48))(v62, &v82, v72);
  if (v74)
    result = sub_1D3DF4F24((unint64_t *)v72);
  if (!v58)
  {
    v61 = (unint64_t *)&v69;
    return sub_1D3DF4F24(v61);
  }
  return result;
}

void sub_1D3D97894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D9799C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE0EE7performENSt3__18functionIFvONS4_8optionalINS4_17reference_wrapperINS_24PyramidGenerationSessionILS2_0EEEEEEEONS6_INS_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D979D4()
{
  return &unk_1E95B1940;
}

void sub_1D3D979E0(os_signpost_id_t a1)
{
  NSObject *v2;
  uint8_t v3[16];

  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (a1 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v2 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v3 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v2, OS_SIGNPOST_INTERVAL_BEGIN, a1, "PyramidGenerationSession::create", (const char *)&unk_1D3E89A2B, v3, 2u);
    }
  }
}

void sub_1D3D97A80(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t *sub_1D3D97B20(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1D3D8BA0C((unint64_t *)(v2 + 48));
    sub_1D3D8BA0C((unint64_t *)(v2 + 40));
    MEMORY[0x1D8254C54](v2, 0x10C1C40764D44F6);
  }
  return a1;
}

uint64_t sub_1D3D97B74(uint64_t a1)
{
  sub_1D3D8BA0C((unint64_t *)(a1 + 48));
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  return a1;
}

void sub_1D3D97BA4(uint64_t a1)
{
  sub_1D3D8BA0C((unint64_t *)(a1 + 48));
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D97BE4()
{
  return 1;
}

uint64_t *sub_1D3D97BEC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, unint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  BOOL v12;
  uint64_t v13;
  char v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *result;
  uint64_t *v21;
  uint64_t v22;

  if (*(_BYTE *)(a1 + 89))
    v12 = *(_BYTE *)(a1 + 88) == 0;
  else
    v12 = 1;
  if (v12)
  {
    v13 = operator new();
    *(_QWORD *)(v13 + 8) = a2;
    *(_QWORD *)(v13 + 16) = a3;
    *(_DWORD *)(v13 + 24) = a4;
    *(_QWORD *)v13 = &off_1E95B12C8;
    v21 = (uint64_t *)v13;
    sub_1D3D97EA8(&v22, (uint64_t *)&v21, a5);
    result = v21;
    *a7 = v22;
    if (result)
      return (uint64_t *)MEMORY[0x1D8254C54](result, 0x1081C40DCAC275BLL);
  }
  else
  {
    v16 = _os_feature_enabled_impl();
    v17 = operator new();
    *(_QWORD *)(v17 + 8) = a2;
    *(_QWORD *)(v17 + 16) = a3;
    *(_DWORD *)(v17 + 24) = a4;
    *(_QWORD *)v17 = &off_1E95B1640;
    *(_BYTE *)(v17 + 28) = v16;
    *(_BYTE *)(v17 + 29) = 1;
    v18 = *(_OWORD *)(a1 + 72);
    *(_BYTE *)(v17 + 96) = 0;
    *(_OWORD *)(v17 + 32) = v18;
    *(_OWORD *)(v17 + 48) = 0u;
    *(_OWORD *)(v17 + 64) = 0u;
    *(_BYTE *)(v17 + 80) = 0;
    v21 = (uint64_t *)v17;
    sub_1D3D98028(&v22, (uint64_t *)&v21, a5, a6);
    v19 = v22;
    v22 = 0;
    *a7 = v19;
    sub_1D3D98268(&v22);
    return sub_1D3D98268((uint64_t *)&v21);
  }
  return result;
}

void sub_1D3D97D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1D3D98268(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D97D8C@<X0>(unint64_t *a1@<X1>, _QWORD *a2@<X8>)
{
  NSObject *v4;
  uint64_t result;
  const __CFString *v6;
  _BYTE buf[24];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v4 = qword_1EDB89F48;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "virtual CFRef<CFArrayRef> mrc::(anonymous namespace)::PlaceholderPyramidAllocator<mrc::PyramidG"
                         "enerationBehavior::Default>::allocate(std::optional<Error> &, const std::optional<os_signpost_i"
                         "d_t> &) const [_Behavior = mrc::PyramidGenerationBehavior::Default]";
    _os_log_fault_impl(&dword_1D3D6B000, v4, OS_LOG_TYPE_FAULT, "Unexpected invocation: %{public}s", buf, 0xCu);
  }
  v6 = CFSTR("PlaceholderPyramidAllocator::allocate should never be invoked.");
  *(_QWORD *)buf = -2011;
  result = sub_1D3D73E0C(a1, (uint64_t *)buf, (CFTypeRef *)&v6);
  *a2 = 0;
  return result;
}

const char *sub_1D3D97E8C()
{
  return "PlaceholderPyramidAllocator";
}

uint64_t sub_1D3D97E98()
{
  return 1;
}

uint64_t sub_1D3D97EA0()
{
  return 1;
}

void sub_1D3D97EA8(_QWORD *a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v6;
  NSObject *v7;
  const __CFString *v8;
  _BYTE buf[12];
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v7 = qword_1EDB89F48;
  if (v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
      v10 = 2050;
      v11 = v6;
      _os_log_debug_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
      v6 = *a2;
    }
    *a2 = 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    v8 = CFSTR("Failed to allocate pyramid allocator.");
    *(_QWORD *)buf = -2003;
    sub_1D3D73E0C(a3, (uint64_t *)buf, (CFTypeRef *)&v8);
    v6 = 0;
  }
  *a1 = v6;
}

void sub_1D3D98028(uint64_t *a1, uint64_t *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v6;
  int v9;
  NSObject *v10;
  __n128 v11;
  NSObject *v12;
  const __CFString *v13;
  _BYTE buf[12];
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  if (!*a2)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v12 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    v13 = CFSTR("Failed to allocate pyramid allocator.");
    *(_QWORD *)buf = -2003;
    sub_1D3D73E0C(a3, (uint64_t *)buf, (CFTypeRef *)&v13);
    goto LABEL_17;
  }
  v9 = *(unsigned __int8 *)(v6 + 96);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v10 = qword_1EDB89F48;
  if (v9)
    goto LABEL_9;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v15 = 2050;
    v16 = v6;
    _os_log_debug_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is being prepared", buf, 0x16u);
    v6 = *a2;
  }
  if (!sub_1D3D98304(v6, (uint64_t)a3, a4, v11))
  {
LABEL_17:
    v6 = 0;
    goto LABEL_18;
  }
  v6 = *a2;
LABEL_9:
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v15 = 2050;
    v16 = v6;
    _os_log_debug_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
    v6 = *a2;
  }
  *a2 = 0;
LABEL_18:
  *a1 = v6;
}

uint64_t *sub_1D3D98268(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    for (i = 72; i != 40; i -= 8)
      sub_1D3D982CC((unint64_t *)(v2 + i));
    MEMORY[0x1D8254C54](v2, 0x10E3C4081D78B51);
  }
  return a1;
}

unint64_t *sub_1D3D982CC(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1D3D98304(uint64_t a1, uint64_t a2, uint64_t a3, __n128 a4)
{
  uint64_t v4;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  _DWORD v34[2];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  os_signpost_id_t v38;
  char v39;
  char v40;
  char v41;
  int v42;
  char v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  char v47;
  int v48;
  __int16 v49;
  _BYTE v50[120];
  unint64_t v51;
  char v52;
  __int16 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  char v62;
  uint8_t buf[4];
  const char *v64;
  _BYTE v65[24];
  _BYTE *v66;
  _QWORD v67[3];
  _QWORD *v68;
  _QWORD v69[3];
  _QWORD *v70;
  uint64_t v71;
  _QWORD v72[3];
  _QWORD *v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 96))
  {
    v69[0] = &off_1E95B14C0;
    v69[1] = a1;
    v70 = v69;
    v71 = a3;
    v67[0] = &off_1E95B1540;
    v67[1] = a1;
    v68 = v67;
    v72[0] = &off_1E95B1540;
    v72[1] = a1;
    v73 = v72;
    if (!*(_BYTE *)(a3 + 8) || (v38 = *(_QWORD *)a3, a4 = sub_1D3D98780((uint64_t)v69, &v38, a4), v7 = v68, v68 == v67))
    {
      v8 = 4;
      v7 = v67;
    }
    else
    {
      if (!v68)
        goto LABEL_9;
      v8 = 5;
    }
    (*(void (**)(__n128))(*v7 + 8 * v8))(a4);
LABEL_9:
    v9 = v70;
    if (v70 == v69)
    {
      v10 = 4;
      v9 = v69;
    }
    else
    {
      if (!v70)
        goto LABEL_14;
      v10 = 5;
    }
    (*(void (**)(__n128))(*v9 + 8 * v10))(a4);
LABEL_14:
    LOBYTE(v54) = 0;
    v62 = 0;
    v11 = *(unsigned __int8 *)(a1 + 28);
    if (*(_BYTE *)(a1 + 28))
    {
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v62 = 1;
      BYTE4(v60) = 1;
      LODWORD(v60) = 1024;
      WORD4(v60) = 257;
      v12 = *(_BYTE *)(a1 + 29) == 0;
      v54 = 0u;
      v55 = 0u;
    }
    else
    {
      v12 = 1;
      if (*(_BYTE *)(a1 + 29))
      {
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v62 = 1;
        v12 = 0;
      }
    }
    LOBYTE(v38) = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    LOBYTE(v44) = 0;
    v45 = 0;
    LOBYTE(v46) = 0;
    v47 = 0;
    v50[0] = 0;
    v52 = 0;
    v53 = 0;
    v48 = 0;
    v49 = 0;
    v42 = *(_DWORD *)(a1 + 24);
    v43 = 1;
    if (v11)
    {
      v45 = 1;
      v44 = 64;
      v47 = 1;
      v46 = 64;
    }
    if (!v12)
      v49 = 257;
    sub_1D3D98924((uint64_t)v50, &v54);
    LOBYTE(v34[0]) = 0;
    LOBYTE(v35) = 0;
    v36 = *(_QWORD *)(a1 + 32);
    LOBYTE(v37) = *(_BYTE *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 8);
    v14 = *(_QWORD *)(a1 + 16);
    v66 = 0;
    v15 = operator new(0x28uLL);
    *v15 = &off_1E95B15C0;
    v15[1] = &v38;
    v15[2] = v34;
    v15[3] = a1;
    v15[4] = a2;
    v66 = v15;
    v4 = sub_1D3D989EC(v13, v14, (uint64_t)v65);
    v23 = v66;
    if (v66 == v65)
    {
      v24 = 4;
      v23 = v65;
    }
    else
    {
      if (!v66)
        goto LABEL_27;
      v24 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _DWORD, _DWORD, uint64_t, _DWORD, uint64_t, _DWORD, _DWORD))(*v23 + 8 * v24))(v23, v16, v17, v18, v19, v20, v21, v22, v34[0], v34[1], v35, v36, v37, v38, HIDWORD(v38));
LABEL_27:
    if ((v4 & 1) != 0)
    {
      v25 = 0;
      v26 = a1 + 48;
      v27 = a1 + 80;
      while (atomic_load((unint64_t *)(v26 + v25)))
      {
        v25 += 8;
        if (v25 == 32)
          goto LABEL_37;
      }
      v27 = v26 + v25;
LABEL_37:
      v30 = *(unsigned __int8 *)(a1 + 96);
      *(_QWORD *)(a1 + 80) = v26;
      *(_QWORD *)(a1 + 88) = (v27 - v26) >> 3;
      if (!v30)
        *(_BYTE *)(a1 + 96) = 1;
    }
    else
    {
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v29 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "CachedPyramidAllocator";
        _os_log_error_impl(&dword_1D3D6B000, v29, OS_LOG_TYPE_ERROR, "%{public}s: failed to prepare", buf, 0xCu);
      }
    }
    if (v52)
      sub_1D3D8C70C(&v51);
    if (v62)
      sub_1D3D8C70C((unint64_t *)&v61 + 1);
    v31 = v73;
    if (*(_BYTE *)(v71 + 8))
    {
      if (!v73)
        return v4;
      v38 = *(_QWORD *)v71;
      (*(void (**)(void))(*v73 + 48))();
      v31 = v73;
    }
    if (v31 == v72)
    {
      v32 = 4;
      v31 = v72;
    }
    else
    {
      if (!v31)
        return v4;
      v32 = 5;
    }
    (*(void (**)(void))(*v31 + 8 * v32))();
    return v4;
  }
  return 1;
}

void sub_1D3D986FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

__n128 sub_1D3D98780(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

void sub_1D3D98924(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  const void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CFTypeRef v16;

  if (*(unsigned __int8 *)(a1 + 128) == *((unsigned __int8 *)a2 + 128))
  {
    if (*(_BYTE *)(a1 + 128))
    {
      v3 = *a2;
      v4 = a2[1];
      v5 = a2[3];
      *(_OWORD *)(a1 + 32) = a2[2];
      *(_OWORD *)(a1 + 48) = v5;
      *(_OWORD *)a1 = v3;
      *(_OWORD *)(a1 + 16) = v4;
      v6 = a2[4];
      v7 = a2[5];
      v8 = a2[6];
      *(_BYTE *)(a1 + 112) = *((_BYTE *)a2 + 112);
      *(_OWORD *)(a1 + 80) = v7;
      *(_OWORD *)(a1 + 96) = v8;
      *(_OWORD *)(a1 + 64) = v6;
      v9 = (const void *)atomic_load((unint64_t *)a2 + 15);
      sub_1D3D95C6C((unint64_t *)(a1 + 120), v9);
    }
  }
  else if (*(_BYTE *)(a1 + 128))
  {
    sub_1D3D8C70C((unint64_t *)(a1 + 120));
    *(_BYTE *)(a1 + 128) = 0;
  }
  else
  {
    v10 = *a2;
    v11 = a2[1];
    v12 = a2[3];
    *(_OWORD *)(a1 + 32) = a2[2];
    *(_OWORD *)(a1 + 48) = v12;
    *(_OWORD *)a1 = v10;
    *(_OWORD *)(a1 + 16) = v11;
    v13 = a2[4];
    v14 = a2[5];
    v15 = a2[6];
    *(_BYTE *)(a1 + 112) = *((_BYTE *)a2 + 112);
    *(_OWORD *)(a1 + 80) = v14;
    *(_OWORD *)(a1 + 96) = v15;
    *(_OWORD *)(a1 + 64) = v13;
    v16 = (CFTypeRef)atomic_load((unint64_t *)a2 + 15);
    if (v16)
      v16 = CFRetain(v16);
    *(_QWORD *)(a1 + 120) = v16;
    *(_BYTE *)(a1 + 128) = 1;
  }
}

uint64_t sub_1D3D989EC(unint64_t a1, unint64_t a2, uint64_t a3)
{
  double v3;
  unint64_t v4;
  unint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  unint64_t v13;
  double v14;
  BOOL v15;
  unint64_t v17;
  uint64_t v19;
  uint64_t result;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;

  v3 = (double)a1;
  v4 = vcvtpd_u64_f64((double)a1 * 0.5);
  if (v4)
  {
    v6 = 0;
    v7 = (double)a2;
    v8 = ceil((double)a2 * 0.5);
    v9 = 0.5;
    v10 = (double)a2;
    v11 = (double)a1;
    do
    {
      v12 = v11;
      v13 = (unint64_t)v8;
      v11 = (double)v4;
      v14 = v10;
      v10 = (double)(unint64_t)v8;
      v15 = v12 <= (double)v4 || v13 == 0;
      if (v15 || v14 <= v10)
        break;
      v17 = v13 >= v4 ? v4 : (unint64_t)v8;
      if (v17 < 0x40 || v6 > 3)
        break;
      v22 = v4;
      v23 = v6;
      v21 = (unint64_t)v8;
      v19 = *(_QWORD *)(a3 + 24);
      if (!v19)
        sub_1D3D75A24();
      result = (*(uint64_t (**)(uint64_t, unint64_t *, unint64_t *, unint64_t *))(*(_QWORD *)v19 + 48))(v19, &v23, &v22, &v21);
      if (!(_DWORD)result)
        return result;
      ++v6;
      v9 = v9 * 0.5;
      v8 = ceil(v9 * v7);
      v4 = vcvtpd_u64_f64(v9 * v3);
    }
    while (v4);
  }
  return 1;
}

void sub_1D3D98AE8()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D98AFC(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E95B15C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1D3D98B3C(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95B15C0;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1D3D98B64(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  const void *v12;
  NSObject *v13;
  unint64_t *v14;
  unint64_t v15;
  const void *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t *v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  CFDictionaryRef v26;
  _BYTE buf[12];
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  unint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = *a4;
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v8 = *a3;
  *(_BYTE *)(v8 + 8) = 1;
  v9 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v9 + 16) = v6;
  *(_BYTE *)(v9 + 24) = 1;
  if (*(_BYTE *)(*(_QWORD *)(a1 + 8) + 208))
  {
    *(_QWORD *)buf = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("MRC: Cached Pyramid Level #%zu"), v5);
    v10 = (unint64_t *)(*(_QWORD *)(a1 + 8) + 200);
    do
      v11 = __ldaxr((unint64_t *)buf);
    while (__stlxr(0, (unint64_t *)buf));
    do
      v12 = (const void *)__ldaxr(v10);
    while (__stlxr(v11, v10));
    if (v12)
      CFRelease(v12);
    sub_1D3D8C70C((unint64_t *)buf);
  }
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v13 = qword_1EDB89F48;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBufferPool at level #%{public}zu", buf, 0x16u);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    v20 = *(uint64_t **)(a1 + 8);
    v24 = 0;
    v25 = 0;
    sub_1D3DD55CC(&v26, v20, &v25, &v24);
    v21 = atomic_load((unint64_t *)&v26);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    v30 = 2114;
    v31 = v21;
    _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferAttributes: %{public}@", buf, 0x20u);
    sub_1D3D8BAAC((unint64_t *)&v26);
    sub_1D3D8BAAC(&v24);
    sub_1D3D8BAAC(&v25);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    v22 = *(uint64_t **)(a1 + 16);
    v25 = 0;
    sub_1D3DD5AD8(&v26, v22, &v25);
    v23 = atomic_load((unint64_t *)&v26);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    v30 = 2114;
    v31 = v23;
    _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferPoolAttributes: %{public}@", buf, 0x20u);
    sub_1D3D8BAAC((unint64_t *)&v26);
    sub_1D3D8BAAC(&v25);
  }
  sub_1D3DD5E18((CVPixelBufferPoolRef *)buf, *(uint64_t **)(a1 + 16), *(uint64_t **)(a1 + 8), *(_QWORD *)(a1 + 32));
  v14 = (unint64_t *)(v7 + 8 * v5 + 48);
  do
    v15 = __ldaxr((unint64_t *)buf);
  while (__stlxr(0, (unint64_t *)buf));
  do
    v16 = (const void *)__ldaxr(v14);
  while (__stlxr(v15, v14));
  if (v16)
    CFRelease(v16);
  sub_1D3D982CC((unint64_t *)buf);
  v17 = atomic_load(v14);
  if (v17)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v18 = atomic_load(v14);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
      v28 = 2050;
      v29 = v5;
      v30 = 2114;
      v31 = v18;
      _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, allocated pixel buffer pool: %{public}@", buf, 0x20u);
    }
  }
  else if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    _os_log_error_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer pool at level #%{public}zu", buf, 0x16u);
  }
  return v17 != 0;
}

void sub_1D3D98F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_1D3D8C70C((unint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D98F7C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D98FB4()
{
  return &unk_1E95B1620;
}

void sub_1D3D98FC4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D98FD8(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1540;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9900C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1540;
  a2[1] = v2;
  return result;
}

__n128 sub_1D3D99028(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1D3D991CC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D99204()
{
  return &unk_1E95B15A0;
}

void sub_1D3D99214()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D99228(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B14C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9925C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B14C0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D99278(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D992B0()
{
  return &unk_1E95B1520;
}

uint64_t sub_1D3D992BC(uint64_t a1)
{
  uint64_t i;

  for (i = 72; i != 40; i -= 8)
    sub_1D3D982CC((unint64_t *)(a1 + i));
  return a1;
}

void sub_1D3D992F4(uint64_t a1)
{
  uint64_t i;

  for (i = 72; i != 40; i -= 8)
    sub_1D3D982CC((unint64_t *)(a1 + i));
  JUMPOUT(0x1D8254C54);
}

BOOL sub_1D3D9933C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return *(_QWORD *)(a1 + 8) != a2 || *(_QWORD *)(a1 + 16) != a3 || *(_DWORD *)(a1 + 24) != a4;
}

uint64_t *sub_1D3D9936C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, unint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  __int16 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;

  v14 = operator new();
  v15 = *(_WORD *)(a1 + 28);
  *(_QWORD *)(v14 + 8) = a2;
  *(_QWORD *)(v14 + 16) = a3;
  *(_DWORD *)(v14 + 24) = a4;
  *(_QWORD *)v14 = &off_1E95B1640;
  *(_WORD *)(v14 + 28) = v15;
  v16 = *(_OWORD *)(a1 + 32);
  *(_BYTE *)(v14 + 96) = 0;
  *(_OWORD *)(v14 + 32) = v16;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_OWORD *)(v14 + 64) = 0u;
  *(_BYTE *)(v14 + 80) = 0;
  v19 = v14;
  sub_1D3D98028(&v20, &v19, a5, a6);
  v17 = v20;
  v20 = 0;
  *a7 = v17;
  sub_1D3D98268(&v20);
  return sub_1D3D98268(&v19);
}

void sub_1D3D99440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1D3D98268(&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D99454@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>, __n128 a5@<Q0>)
{
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  __CFArray *v20;
  const void *v21;
  unint64_t v22;
  NSObject *v23;
  const __CFArray *v24;
  NSObject *v25;
  _QWORD *result;
  uint64_t v27;
  unint64_t v28;
  const __CFArray *v29;
  CFIndex Count;
  const __CFArray *v31;
  CFIndex v32;
  CFIndex i;
  const __CFArray *v34;
  const void *ValueAtIndex;
  __CFString *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  CFArrayRef *v40;
  CFMutableStringRef v41;
  CFMutableArrayRef Mutable;
  _BYTE buf[12];
  __int16 v44;
  unint64_t v45;
  __int16 v46;
  unint64_t v47;
  __int16 v48;
  unint64_t v49;
  _QWORD v50[3];
  _QWORD *v51;
  _QWORD v52[3];
  _QWORD *v53;
  uint64_t v54;
  _QWORD v55[3];
  _QWORD *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v52[0] = &off_1E95B16A8;
  v52[1] = a1;
  v53 = v52;
  v50[0] = &off_1E95B1728;
  v50[1] = a1;
  v51 = v50;
  v54 = a3;
  v55[0] = &off_1E95B1728;
  v56 = v55;
  v55[1] = a1;
  if (!*(_BYTE *)(a3 + 8)
    || (*(_QWORD *)buf = *(_QWORD *)a3,
        a5 = sub_1D3D99AFC((uint64_t)v52, (os_signpost_id_t *)buf, a5),
        v8 = v51,
        v51 == v50))
  {
    v9 = 4;
    v8 = v50;
  }
  else
  {
    if (!v51)
      goto LABEL_7;
    v9 = 5;
  }
  (*(void (**)(__n128))(*v8 + 8 * v9))(a5);
LABEL_7:
  v10 = v53;
  if (v53 == v52)
  {
    v11 = 4;
    v10 = v52;
  }
  else
  {
    if (!v53)
      goto LABEL_12;
    v11 = 5;
  }
  (*(void (**)(__n128))(*v10 + 8 * v11))(a5);
LABEL_12:
  if (*(_BYTE *)(a1 + 96))
  {
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 88), MEMORY[0x1E0C9B378]);
    if (atomic_load((unint64_t *)&Mutable))
    {
      v14 = *(_QWORD *)(a1 + 88);
      v40 = a4;
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v15 = qword_1EDB89F48;
      if (v14)
      {
        v16 = 0;
        v17 = 0;
        while (1)
        {
          v18 = (unint64_t *)(*(_QWORD *)(a1 + 80) + v16);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v22 = atomic_load(v18);
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
            v44 = 2050;
            v45 = v17;
            v46 = 2050;
            v47 = v22;
            _os_log_debug_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBuffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
          }
          sub_1D3DD5F9C((CVPixelBufferRef *)&v41, v18, (uint64_t)a2);
          if (!atomic_load((unint64_t *)&v41))
            break;
          v20 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
          v21 = (const void *)atomic_load((unint64_t *)&v41);
          CFArrayAppendValue(v20, v21);
          sub_1D3D74EDC((unint64_t *)&v41);
          ++v17;
          v16 += 8;
          if (v17 >= *(_QWORD *)(a1 + 88))
            goto LABEL_28;
        }
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v39 = atomic_load(v18);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
          v44 = 2050;
          v45 = v17;
          v46 = 2050;
          v47 = v39;
          _os_log_error_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
        }
        *v40 = 0;
        sub_1D3D74EDC((unint64_t *)&v41);
      }
      else
      {
LABEL_28:
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          v28 = atomic_load((unint64_t *)&Mutable);
          v29 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
          Count = CFArrayGetCount(v29);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
          v44 = 2050;
          v45 = v28;
          v46 = 2050;
          v47 = Count;
          _os_log_debug_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
          v41 = CFStringCreateMutable(v12, 0);
          v31 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
          v32 = CFArrayGetCount(v31);
          if (v32 >= 1)
          {
            for (i = 0; i != v32; ++i)
            {
              v34 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
              ValueAtIndex = CFArrayGetValueAtIndex(v34, i);
              if (ValueAtIndex)
                ValueAtIndex = CFRetain(ValueAtIndex);
              *(_QWORD *)buf = ValueAtIndex;
              sub_1D3E2D270((unint64_t *)&v41, (unint64_t *)buf);
              sub_1D3D74EDC((unint64_t *)buf);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                v37 = atomic_load((unint64_t *)&Mutable);
                v38 = atomic_load((unint64_t *)&v41);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
                v44 = 2050;
                v45 = i;
                v46 = 2050;
                v47 = v37;
                v48 = 2114;
                v49 = v38;
                _os_log_debug_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
              }
              v36 = (__CFString *)atomic_load((unint64_t *)&v41);
              CFStringReplaceAll(v36, &stru_1E95B5208);
            }
          }
          sub_1D3D8FA0C((unint64_t *)&v41);
        }
        v24 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
        *v40 = CFArrayCreateCopy(v12, v24);
      }
    }
    else
    {
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v25 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D3D6B000, v25, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
      }
      *(_QWORD *)buf = -2003;
      v41 = CFSTR("CFArrayCreateMutable failed.");
      sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&v41);
      *a4 = 0;
    }
    sub_1D3D74C60((unint64_t *)&Mutable);
  }
  else
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v23 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v23, OS_LOG_TYPE_ERROR, "%{public}s: effective pixel buffer pools are not yet ready", buf, 0xCu);
    }
    Mutable = (CFMutableArrayRef)CFSTR("Effective pixel buffer pools are not yet ready.");
    *(_QWORD *)buf = -2011;
    sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&Mutable);
    *a4 = 0;
  }
  result = v56;
  if (*(_BYTE *)(v54 + 8))
  {
    if (!v56)
      return result;
    *(_QWORD *)buf = *(_QWORD *)v54;
    (*(void (**)(_QWORD *, _BYTE *))(*v56 + 48))(v56, buf);
    result = v56;
  }
  if (result == v55)
  {
    v27 = 4;
    result = v55;
  }
  else
  {
    if (!result)
      return result;
    v27 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v27))();
}

void sub_1D3D99A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  unint64_t v7;
  va_list va;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, _QWORD);
  sub_1D3D8FA0C((unint64_t *)va);
  sub_1D3D74C60((unint64_t *)va1);
  sub_1D3D87C3C((_QWORD *)(v5 - 136));
  _Unwind_Resume(a1);
}

const char *sub_1D3D99AE8()
{
  return "CachedPyramidAllocator";
}

uint64_t sub_1D3D99AF4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96);
}

__n128 sub_1D3D99AFC(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

void sub_1D3D99CA4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D99CB8(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1728;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D99CEC(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1728;
  a2[1] = v2;
  return result;
}

__n128 sub_1D3D99D08(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1D3D99EAC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D99EE4()
{
  return &unk_1E95B1788;
}

void sub_1D3D99EF4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D99F08(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B16A8;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D99F3C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B16A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D99F58(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D99F90()
{
  return &unk_1E95B1708;
}

void sub_1D3D99FA0()
{
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D99FB4@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, int a3@<W3>, unint64_t *a4@<X4>, _QWORD *a5@<X8>)
{
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;

  v10 = operator new();
  *(_QWORD *)(v10 + 8) = a1;
  *(_QWORD *)(v10 + 16) = a2;
  *(_DWORD *)(v10 + 24) = a3;
  *(_QWORD *)v10 = &off_1E95B12C8;
  v12 = v10;
  sub_1D3D97EA8(&v13, &v12, a4);
  result = v12;
  *a5 = v13;
  if (result)
    JUMPOUT(0x1D8254C54);
  return result;
}

void sub_1D3D9A06C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D8254C54](a9, 0x1081C40DCAC275BLL);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3D9A094@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>, __n128 a5@<Q0>)
{
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  const __CFArray *v22;
  CFArrayRef Copy;
  _QWORD *result;
  uint64_t v25;
  unint64_t v26;
  const __CFArray *v27;
  CFIndex Count;
  const __CFArray *v29;
  CFIndex v30;
  CFIndex i;
  const __CFArray *v32;
  const void *ValueAtIndex;
  __CFString *v34;
  unint64_t v35;
  unint64_t v36;
  CFMutableStringRef v37;
  CFMutableArrayRef Mutable;
  _BYTE buf[12];
  __int16 v40;
  unint64_t v41;
  __int16 v42;
  unint64_t v43;
  __int16 v44;
  unint64_t v45;
  _BYTE v46[24];
  _BYTE *v47;
  _QWORD v48[3];
  _QWORD *v49;
  _QWORD v50[3];
  _QWORD *v51;
  uint64_t v52;
  _QWORD v53[3];
  _QWORD *v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v50[0] = &off_1E95B1330;
  v50[1] = a1;
  v51 = v50;
  v48[0] = &off_1E95B13B0;
  v48[1] = a1;
  v49 = v48;
  v52 = a3;
  v53[0] = &off_1E95B13B0;
  v54 = v53;
  v53[1] = a1;
  if (!*(_BYTE *)(a3 + 8)
    || (*(_QWORD *)buf = *(_QWORD *)a3,
        a5 = sub_1D3D9A614((uint64_t)v50, (os_signpost_id_t *)buf, a5),
        v8 = v49,
        v49 == v48))
  {
    v9 = 4;
    v8 = v48;
  }
  else
  {
    if (!v49)
      goto LABEL_7;
    v9 = 5;
  }
  (*(void (**)(__n128))(*v8 + 8 * v9))(a5);
LABEL_7:
  v10 = v51;
  if (v51 == v50)
  {
    v11 = 4;
    v10 = v50;
  }
  else
  {
    if (!v51)
      goto LABEL_12;
    v11 = 5;
  }
  (*(void (**)(__n128))(*v10 + 8 * v11))(a5);
LABEL_12:
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
  if (!atomic_load((unint64_t *)&Mutable))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v20 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v20, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
    }
    *(_QWORD *)buf = -2003;
    v37 = CFSTR("CFArrayCreateMutable failed.");
    sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&v37);
    goto LABEL_30;
  }
  v14 = *(_QWORD *)(a1 + 8);
  v15 = *(_QWORD *)(a1 + 16);
  v47 = 0;
  v16 = operator new(0x20uLL);
  *v16 = &off_1E95B1430;
  v16[1] = a1;
  v16[2] = a2;
  v16[3] = &Mutable;
  v47 = v16;
  v17 = sub_1D3D989EC(v14, v15, (uint64_t)v46);
  v18 = v47;
  if (v47 == v46)
  {
    v19 = 4;
    v18 = v46;
  }
  else
  {
    if (!v47)
      goto LABEL_23;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_23:
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v21 = qword_1EDB89F48;
  if ((v17 & 1) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_ERROR, "%{public}s: failed to allocate pyramid", buf, 0xCu);
    }
LABEL_30:
    Copy = 0;
    goto LABEL_31;
  }
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
  {
    v26 = atomic_load((unint64_t *)&Mutable);
    v27 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
    Count = CFArrayGetCount(v27);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
    v40 = 2050;
    v41 = v26;
    v42 = 2050;
    v43 = Count;
    _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
    v37 = CFStringCreateMutable(v12, 0);
    v29 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
    v30 = CFArrayGetCount(v29);
    if (v30 >= 1)
    {
      for (i = 0; i != v30; ++i)
      {
        v32 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
        ValueAtIndex = CFArrayGetValueAtIndex(v32, i);
        if (ValueAtIndex)
          ValueAtIndex = CFRetain(ValueAtIndex);
        *(_QWORD *)buf = ValueAtIndex;
        sub_1D3E2D270((unint64_t *)&v37, (unint64_t *)buf);
        sub_1D3D74EDC((unint64_t *)buf);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          v35 = atomic_load((unint64_t *)&Mutable);
          v36 = atomic_load((unint64_t *)&v37);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
          v40 = 2050;
          v41 = i;
          v42 = 2050;
          v43 = v35;
          v44 = 2114;
          v45 = v36;
          _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
        }
        v34 = (__CFString *)atomic_load((unint64_t *)&v37);
        CFStringReplaceAll(v34, &stru_1E95B5208);
      }
    }
    sub_1D3D8FA0C((unint64_t *)&v37);
  }
  v22 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
  Copy = CFArrayCreateCopy(v12, v22);
LABEL_31:
  *a4 = Copy;
  sub_1D3D74C60((unint64_t *)&Mutable);
  result = v54;
  if (*(_BYTE *)(v52 + 8))
  {
    if (!v54)
      return result;
    *(_QWORD *)buf = *(_QWORD *)v52;
    (*(void (**)(_QWORD *, _BYTE *))(*v54 + 48))(v54, buf);
    result = v54;
  }
  if (result == v53)
  {
    v25 = 4;
    result = v53;
  }
  else
  {
    if (!result)
      return result;
    v25 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v25))();
}

void sub_1D3D9A56C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  unint64_t v5;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  sub_1D3D8FA0C((unint64_t *)va);
  sub_1D3D74C60((unint64_t *)va1);
  sub_1D3D87C3C((_QWORD *)(v3 - 136));
  _Unwind_Resume(a1);
}

const char *sub_1D3D9A608()
{
  return "EphemeralPyramidAllocator";
}

__n128 sub_1D3D9A614(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

void sub_1D3D9A7BC()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D9A7D0(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E95B1430;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 sub_1D3D9A810(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95B1430;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1D3D9A838(uint64_t a1, _QWORD *a2, size_t *a3, size_t *a4)
{
  uint64_t v5;
  size_t v6;
  size_t v7;
  uint64_t v8;
  unint64_t v9;
  __CFArray *v10;
  const void *v11;
  NSObject *v12;
  CVPixelBufferRef v14;
  CFStringRef v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = *a3;
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("MRC: Ephemeral Pyramid Level #%zu"), *a2);
  sub_1D3D9AA1C(&v14, v6, v7, *(_DWORD *)(v8 + 24), (unint64_t *)&v15, *(_QWORD *)(a1 + 16));
  v9 = atomic_load((unint64_t *)&v14);
  if (v9)
  {
    v10 = (__CFArray *)atomic_load(*(unint64_t **)(a1 + 24));
    v11 = (const void *)atomic_load((unint64_t *)&v14);
    CFArrayAppendValue(v10, v11);
  }
  else
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v12 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v17 = "EphemeralPyramidAllocator";
      v18 = 2050;
      v19 = v5;
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "%{public}s: failed to create IOSurface-backed pixel buffer at level #%{public}zu", buf, 0x16u);
    }
  }
  sub_1D3D74EDC((unint64_t *)&v14);
  sub_1D3D8C70C((unint64_t *)&v15);
  return v9 != 0;
}

void sub_1D3D9A9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  unint64_t v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  sub_1D3D74EDC((unint64_t *)va);
  sub_1D3D8C70C((unint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D9A9D8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9AA10()
{
  return &unk_1E95B14A0;
}

unint64_t *sub_1D3D9AA1C(CVPixelBufferRef *a1, size_t a2, size_t a3, unsigned int a4, unint64_t *a5, uint64_t a6)
{
  NSObject *v12;
  unint64_t v13;
  const void *v14;
  const void *v15;
  const __CFAllocator *v16;
  const __CFDictionary *v17;
  CVReturn v18;
  NSObject *v19;
  CVPixelBufferRef v20;
  int v22;
  int32x2_t v23;
  int8x8_t v24;
  int8x16_t v25;
  int8x16_t v26;
  uint64x2_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  CFDictionaryRef v31;
  __int128 v32;
  char v33;
  char v34;
  char v35;
  char v36;
  char v37;
  char v38;
  char v39;
  char v40;
  char v41;
  char v42;
  int v43;
  char v44;
  __int16 v45;
  char v46;
  char v47;
  unint64_t v48;
  unint64_t v49;
  const __CFString *v50;
  CVPixelBufferRef pixelBufferOut;
  _BYTE buf[12];
  __int16 v53;
  size_t v54;
  __int16 v55;
  int v56;
  __int16 v57;
  __int128 *v58;
  char v59;
  char v60;
  char v61;
  char v62;
  int v63;
  __int16 v64;
  _BYTE v65[120];
  unint64_t v66;
  char v67;
  __int16 v68;
  uint8_t v69[8];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v12 = qword_1EDB89F48;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
  {
    v22 = HIBYTE(a4);
    v23 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(a4), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
    if (HIBYTE(a4) - 32 >= 0x5Fu)
      v22 = 46;
    v24 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v23, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v23, (int8x8_t)0x2E0000002ELL);
    v25.i64[0] = v24.u32[0];
    v25.i64[1] = v24.u32[1];
    v26.i64[0] = 255;
    v26.i64[1] = 255;
    v27 = vshlq_u64((uint64x2_t)vandq_s8(v25, v26), (uint64x2_t)xmmword_1D3E82010);
    if (a4 - 32 >= 0x5F)
      v28 = 46;
    else
      v28 = a4;
    v29 = v27.i64[0] | (v28 << 24) | v27.i64[1];
    BYTE4(v32) = BYTE4(v29);
    LODWORD(v32) = v29 | v22;
    *(_DWORD *)buf = 134349826;
    *(_QWORD *)&buf[4] = a2;
    v53 = 2050;
    v54 = a3;
    v55 = 1042;
    v56 = 4;
    v57 = 2082;
    v58 = &v32;
    _os_log_debug_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_DEBUG, "Attempting to create an IOSurface-backed CVPixelBuffer: width=%{public}zu, height=%{public}zu, pixelFormatType=%{public}.4s", buf, 0x26u);
  }
  v49 = 0;
  *(_QWORD *)buf = FigCreateIOSurfacePropertiesDictionary();
  do
    v13 = __ldaxr((unint64_t *)buf);
  while (__stlxr(0, (unint64_t *)buf));
  do
    v14 = (const void *)__ldaxr(&v49);
  while (__stlxr(v13, &v49));
  if (v14)
    CFRelease(v14);
  sub_1D3D8BAAC((unint64_t *)buf);
  LOBYTE(v32) = 0;
  BYTE8(v32) = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v44 = 1;
  v43 = 1280;
  v15 = (const void *)atomic_load(a5);
  sub_1D3D95C6C(&v48, v15);
  buf[0] = 0;
  buf[8] = 0;
  BYTE2(v54) = 0;
  LOBYTE(v56) = 0;
  BYTE2(v58) = 0;
  BYTE6(v58) = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v65[0] = 0;
  v67 = 0;
  v68 = 0;
  v63 = 0;
  v64 = 0;
  sub_1D3D9AE68((uint64_t)v65, &v32);
  v30 = 0;
  sub_1D3DD55CC(&v31, (uint64_t *)buf, &v30, &v49);
  pixelBufferOut = 0;
  v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v17 = (const __CFDictionary *)atomic_load((unint64_t *)&v31);
  v18 = CVPixelBufferCreate(v16, a2, a3, a4, v17, &pixelBufferOut);
  if (v18)
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v19 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v69 = 67240192;
      *(_DWORD *)&v69[4] = v18;
      _os_log_error_impl(&dword_1D3D6B000, v19, OS_LOG_TYPE_ERROR, "CVPixelBufferCreate failed: %{public}d", v69, 8u);
    }
    *(_QWORD *)v69 = -2003;
    v50 = CFSTR("CVPixelBufferCreate failed.");
    sub_1D3D73E0C((unint64_t *)a6, (uint64_t *)v69, (CFTypeRef *)&v50);
    v20 = 0;
    *(_DWORD *)(a6 + 24) = v18;
    *(_BYTE *)(a6 + 28) = 1;
  }
  else
  {
    v20 = pixelBufferOut;
  }
  *a1 = v20;
  sub_1D3D8BAAC((unint64_t *)&v31);
  sub_1D3D8BAAC(&v30);
  if (v67)
    sub_1D3D8C70C(&v66);
  sub_1D3D8C70C(&v48);
  return sub_1D3D8BAAC(&v49);
}

void sub_1D3D9ADF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,unint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,unint64_t a56,char a57)
{
  unint64_t *v57;

  sub_1D3D8BAAC(&a10);
  if (a57)
    sub_1D3D8C70C(&a56);
  sub_1D3D8C70C(v57);
  sub_1D3D8BAAC(&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D9AE68(uint64_t a1, __int128 *a2)
{
  int v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  const void *v10;
  CFTypeRef v11;

  v3 = *(unsigned __int8 *)(a1 + 128);
  v4 = a2[3];
  v6 = *a2;
  v5 = a2[1];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v6;
  *(_OWORD *)(a1 + 16) = v5;
  v8 = a2[5];
  v7 = a2[6];
  v9 = a2[4];
  *(_BYTE *)(a1 + 112) = *((_BYTE *)a2 + 112);
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 64) = v9;
  if (v3)
  {
    v10 = (const void *)atomic_load((unint64_t *)a2 + 15);
    sub_1D3D95C6C((unint64_t *)(a1 + 120), v10);
  }
  else
  {
    v11 = (CFTypeRef)atomic_load((unint64_t *)a2 + 15);
    if (v11)
      v11 = CFRetain(v11);
    *(_QWORD *)(a1 + 120) = v11;
    *(_BYTE *)(a1 + 128) = 1;
  }
  return a1;
}

void sub_1D3D9AEEC()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9AF00(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B13B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9AF34(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B13B0;
  a2[1] = v2;
  return result;
}

__n128 sub_1D3D9AF50(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_END, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1D3D9B0F4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9B12C()
{
  return &unk_1E95B1410;
}

void sub_1D3D9B13C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9B150(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1330;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9B184(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1330;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D9B1A0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9B1D8()
{
  return &unk_1E95B1390;
}

void sub_1D3D9B1E8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9B1FC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B11D0;
  return result;
}

void sub_1D3D9B220(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B11D0;
}

void sub_1D3D9B238(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3D9B2D8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9B310()
{
  return &unk_1E95B1230;
}

void sub_1D3D9B320()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9B334()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B1150;
  return result;
}

void sub_1D3D9B358(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B1150;
}

uint64_t sub_1D3D9B370(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9B3A8()
{
  return &unk_1E95B11B0;
}

void sub_1D3D9B3B8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9B3CC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B10D0;
  return result;
}

void sub_1D3D9B3F0(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B10D0;
}

void sub_1D3D9B408(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PyramidGenerationSession::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3D9B4A8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9B4E0()
{
  return &unk_1E95B1130;
}

void sub_1D3D9B4F0()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9B504()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B1050;
  return result;
}

void sub_1D3D9B528(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B1050;
}

void sub_1D3D9B540(uint64_t a1, os_signpost_id_t *a2)
{
  sub_1D3D979E0(*a2);
}

uint64_t sub_1D3D9B548(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9B580()
{
  return &unk_1E95B10B0;
}

void sub_1D3D9B58C(uint64_t a1)
{
  uint64_t *v1;

  v1 = *(uint64_t **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1D3D969CC(v1 + 6);
    operator delete(v1);
  }
}

void sub_1D3D9B5D4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9B5E8()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B1860;
  return result;
}

void sub_1D3D9B60C(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B1860;
}

uint64_t sub_1D3D9B624(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
  {
    sub_1D3D96F10(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3D9B658(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE0EEEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9B690()
{
  return &unk_1E95B18C0;
}

void sub_1D3D9B6A0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D9B6C4(uint64_t a1)
{
  return sub_1D3D968DC(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1D3D9B6CC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS1_25PyramidGenerationBehaviorE0EEEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1D3D9B708(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B17F0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3D9B744(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B17F0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D9B790(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (*(_BYTE *)(a1 + 200))
    sub_1D3DF4F24((unint64_t *)(a1 + 104));
  if (*(_BYTE *)(a1 + 96))
  {
    v2 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = 0;
    if (v2)
      sub_1D3D94A48(v2);
  }
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B17F0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v3)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3D9B804(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (*(_BYTE *)(a1 + 200))
    sub_1D3DF4F24((unint64_t *)(a1 + 104));
  if (*(_BYTE *)(a1 + 96))
  {
    v2 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = 0;
    if (v2)
      sub_1D3D94A48(v2);
  }
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B17F0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v3)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

void sub_1D3D9B88C()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D9B8A0(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E95B0FC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 sub_1D3D9B8E8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E95B0FC0;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unint64_t *sub_1D3D9B918(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v4;
  NSObject *v5;
  unint64_t *result;
  uint64_t v7;
  unint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGFloat v12;
  NSObject *v14;
  CFTypeRef v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t (***v19)();
  uint64_t v20;
  __CVBuffer *v22;
  size_t Width;
  __CVBuffer *v24;
  size_t Height;
  __CVBuffer *v26;
  uint64_t PixelFormatType;
  unint64_t v28;
  double v29;
  double v30;
  unint64_t v31;
  int v32;
  NSObject *v33;
  _BOOL4 v34;
  CFTypeRef v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  CFTypeRef v47;
  CGFloat v49;
  CGFloat v50;
  CGFloat v51;
  CGFloat v52;
  CGFloat x;
  CGFloat y;
  const void *v55;
  int v56;
  CFTypeRef v57;
  const __CFArray *v58;
  CFIndex Count;
  BOOL v60;
  CFIndex v61;
  unint64_t *v62;
  const __CFArray *v63;
  const void *ValueAtIndex;
  __CVBuffer *v65;
  size_t v66;
  char v67;
  __CVBuffer *v68;
  OSType v69;
  double v70;
  double v71;
  CGFloat v72;
  double v73;
  CGFloat v74;
  double v75;
  CGFloat v76;
  uint64_t v77;
  unint64_t v79;
  unint64_t v80;
  CGFloat v81;
  CGFloat v82;
  CGFloat v83;
  CGFloat v84;
  _QWORD *v85;
  uint64_t v86;
  CFTypeRef *v87;
  uint64_t v88;
  unint64_t v89;
  const void *v90;
  unint64_t v91;
  const void *v92;
  unint64_t *v93;
  const void *v94;
  const void *v95;
  const void *v96;
  const void *v97;
  OpaqueVTPixelTransferSession *v98;
  __CVBuffer *v99;
  __CVBuffer *v100;
  OSStatus v101;
  NSObject *v102;
  unint64_t v103;
  const void *v104;
  const void *v105;
  const __CFString *v106;
  const void *v107;
  const void *v108;
  CGFloat tx;
  uint64_t v110;
  const void *v111;
  _OWORD *v112;
  uint64_t v113;
  unint64_t *v114;
  unint64_t v115;
  const void *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  const __CFString *v126;
  const __CFString *v127;
  const __CFString *domain;
  CFIndex v129;
  const __CFAllocator *allocator;
  const __CFString *v131;
  const __CFString *propertyKey;
  BOOL v133;
  unint64_t *v134;
  uint64_t v135;
  CFTypeRef v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t *v139;
  uint64_t v140;
  char v141;
  const void *v142;
  CGRect v143;
  CFTypeRef v144;
  unint64_t v145;
  unint64_t v146;
  const void *v147;
  const __CFString *propertyValueOut;
  CGAffineTransform buf;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  _QWORD v153[3];
  _QWORD *v154;
  uint64_t (**v155)();
  uint64_t v156;
  uint64_t (***v157)();
  __int128 v158;
  uint64_t v159;
  char *v160;
  _QWORD v161[3];
  _QWORD *v162;
  CFTypeRef v163[3];
  CFTypeRef *v164;
  _BYTE v165[24];
  uint64_t v166;
  CGRect v167;
  CGRect v168;
  CGRect v169;
  CGRect v170;
  CGRect v171;
  CGRect v172;
  CGRect v173;
  CGRect v174;
  CGRect v175;
  CGRect v176;
  CGRect v177;
  CGRect v178;

  v166 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 8))
    v4 = *(_BYTE *)(a3 + 96) == 0;
  else
    v4 = 0;
  if (!v4)
  {
    sub_1D3D74C98(*(unint64_t **)(a1 + 8), a3);
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v5 = qword_1EDB89F48;
    result = (unint64_t *)os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v7 = *(_QWORD *)(a1 + 8);
    if (*(_BYTE *)(v7 + 96))
    {
      sub_1D3DF4F6C((uint64_t)&buf, v7);
    }
    else
    {
      buf.a = NAN;
      memset(&buf.b, 0, 40);
      BYTE4(buf.d) = 0;
      v150 = 0u;
      v151 = 0u;
      BYTE4(v150) = 0;
      v152 = 0u;
    }
    sub_1D3DF53CC((CFErrorRef *)v163, (uint64_t)&buf);
    v45 = atomic_load((unint64_t *)v163);
    LODWORD(v158) = 138543362;
    *(_QWORD *)((char *)&v158 + 4) = v45;
    v46 = "Cannot retrieve or instantiate pyramid generation session: %{public}@";
LABEL_190:
    _os_log_error_impl(&dword_1D3D6B000, v5, OS_LOG_TYPE_ERROR, v46, (uint8_t *)&v158, 0xCu);
    sub_1D3D7448C((unint64_t *)v163);
    return sub_1D3DF4F24((unint64_t *)&buf);
  }
  v8 = *(unint64_t ***)a2;
  v9 = *(_QWORD *)(a1 + 24);
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(_QWORD *)(a1 + 8);
  v12 = *(double *)(a1 + 40);
  if (atomic_load((unint64_t *)(v9 + 48)))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v14 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v14, OS_LOG_TYPE_DEBUG, "Sample has existing pyramid, skipping...", (uint8_t *)&buf, 2u);
    }
    v15 = (CFTypeRef)atomic_load((unint64_t *)(v9 + 48));
    if (v15)
      v15 = CFRetain(v15);
    v136 = v15;
    goto LABEL_175;
  }
  v155 = &off_1E95B0EC0;
  v156 = v9;
  v157 = &v155;
  *(CGFloat *)&v158 = v12;
  v153[0] = &off_1E95B0F40;
  v153[1] = v9;
  v16 = v153;
  v154 = v153;
  v17 = (_QWORD *)&v158 + 1;
  *((_QWORD *)&v158 + 1) = &off_1E95B0F40;
  v159 = v9;
  v160 = (char *)&v158 + 8;
  v135 = v11;
  if (*(_BYTE *)(*(_QWORD *)&v12 + 8))
  {
    sub_1D3D94B0C((uint64_t)&v156, **(_QWORD **)&v12);
    v16 = v154;
    if (v154 == v153)
    {
      v18 = 4;
      v16 = v153;
    }
    else
    {
      if (!v154)
        goto LABEL_25;
      v18 = 5;
    }
  }
  else
  {
    v18 = 4;
  }
  (*(void (**)(void))(*v16 + 8 * v18))();
LABEL_25:
  v19 = v157;
  if (v157 == &v155)
  {
    v20 = 4;
    v19 = &v155;
  }
  else
  {
    if (!v157)
      goto LABEL_30;
    v20 = 5;
  }
  (*v19)[v20]();
LABEL_30:
  v139 = *(unint64_t **)v9;
  v140 = v135;
  v141 = sub_1D3DE79DC(v139, v135);
  if ((v141 & 1) == 0)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v40 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      v56 = *(_DWORD *)(v135 + 24);
      LODWORD(buf.a) = 67240192;
      HIDWORD(buf.a) = v56;
      _os_log_error_impl(&dword_1D3D6B000, v40, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&buf, 8u);
    }
    v136 = 0;
    goto LABEL_167;
  }
  sub_1D3D94C2C(&v138, *(unint64_t **)v9, (uint64_t)&v139, v135);
  if (!atomic_load(&v138))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v41 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v41, OS_LOG_TYPE_ERROR, "Failed to get or create shallow Yp8 pixel buffer.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_57;
  }
  v22 = (__CVBuffer *)atomic_load(&v138);
  Width = CVPixelBufferGetWidth(v22);
  v24 = (__CVBuffer *)atomic_load(&v138);
  Height = CVPixelBufferGetHeight(v24);
  v26 = (__CVBuffer *)atomic_load(&v138);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v26);
  v28 = (*v8)[2];
  if (!v28)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v17 = (_QWORD *)&v158 + 1;
    v42 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v42, OS_LOG_TYPE_ERROR, "Invalid pyramid allocator", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    v163[0] = CFSTR("Invalid pyramid allocator.");
    sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)&buf, v163);
LABEL_57:
    v136 = 0;
    goto LABEL_165;
  }
  v29 = (double)Width;
  v30 = (double)Height;
  v31 = (unint64_t)(double)Width;
  v32 = (*(uint64_t (**)(unint64_t, unint64_t, unint64_t, uint64_t))(*(_QWORD *)v28 + 16))(v28, v31, (unint64_t)v30, PixelFormatType);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v33 = qword_1EDB89F48;
  v34 = os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG);
  if (v32)
  {
    if (v34)
    {
      v120 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
      v121 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(_QWORD *)((char *)&buf.a + 4) = v120;
      WORD2(buf.b) = 2050;
      *(_QWORD *)((char *)&buf.b + 6) = v121;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Resetting pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
    }
    (*(void (**)(CFTypeRef *__return_ptr, unint64_t, unint64_t, unint64_t, uint64_t, uint64_t, CGFloat))(*(_QWORD *)(*v8)[2] + 24))(v163, (*v8)[2], v31, (unint64_t)v30, PixelFormatType, v135, COERCE_CGFLOAT(*(_QWORD *)&v12));
    v35 = v163[0];
    v17 = (_QWORD *)&v158 + 1;
    if (v163[0])
    {
      v36 = *v8;
      v163[0] = 0;
      v37 = v36[2];
      v36[2] = (unint64_t)v35;
      if (v37)
        (*(void (**)(unint64_t))(*(_QWORD *)v37 + 8))(v37);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        v38 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
        v39 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(_QWORD *)((char *)&buf.a + 4) = v38;
        WORD2(buf.b) = 2050;
        *(_QWORD *)((char *)&buf.b + 6) = v39;
        _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "New pyramid allocator: <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        v124 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
        v125 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(_QWORD *)((char *)&buf.a + 4) = v124;
        WORD2(buf.b) = 2050;
        *(_QWORD *)((char *)&buf.b + 6) = v125;
        _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Unable to reset pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
      v136 = 0;
    }
    v47 = v163[0];
    v163[0] = 0;
    if (v47)
      (*(void (**)(CFTypeRef))(*(_QWORD *)v47 + 8))(v47);
    if (!v35)
      goto LABEL_165;
  }
  else
  {
    v17 = (_QWORD *)&v158 + 1;
    if (v34)
    {
      v43 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
      v44 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(_QWORD *)((char *)&buf.a + 4) = v43;
      WORD2(buf.b) = 2050;
      *(_QWORD *)((char *)&buf.b + 6) = v44;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p> can be reused", (uint8_t *)&buf, 0x16u);
    }
  }
  (*(void (**)(unint64_t *__return_ptr, unint64_t, uint64_t, CGFloat))(*(_QWORD *)(*v8)[2] + 32))(&v137, (*v8)[2], v135, COERCE_CGFLOAT(*(_QWORD *)&v12));
  if (!atomic_load(&v137))
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      v122 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
      v123 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(_QWORD *)((char *)&buf.a + 4) = v122;
      WORD2(buf.b) = 2050;
      *(_QWORD *)((char *)&buf.b + 6) = v123;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p>: unable to allocate pyramid", (uint8_t *)&buf, 0x16u);
    }
    goto LABEL_73;
  }
  v49 = *(double *)(v9 + 16);
  v50 = *(double *)(v9 + 24);
  v51 = *(double *)(v9 + 32);
  v52 = *(double *)(v9 + 40);
  v167.origin.x = v49;
  v167.origin.y = v50;
  v167.size.width = v51;
  v167.size.height = v52;
  if (CGRectIsNull(v167))
    goto LABEL_70;
  v168.origin.x = v49;
  v168.origin.y = v50;
  v168.size.width = v51;
  v168.size.height = v52;
  if (CGRectIsInfinite(v168))
  {
    x = *MEMORY[0x1E0C9D538];
    y = *(double *)(MEMORY[0x1E0C9D538] + 8);
  }
  else
  {
    v178.origin.x = 0.0;
    v178.origin.y = 0.0;
    v169.origin.x = v49;
    v169.origin.y = v50;
    v169.size.width = v51;
    v169.size.height = v52;
    v178.size.width = v29;
    v178.size.height = v30;
    v170 = CGRectIntersection(v169, v178);
    x = v170.origin.x;
    y = v170.origin.y;
    v29 = v170.size.width;
    v30 = v170.size.height;
    if (CGRectIsNull(v170))
    {
LABEL_70:
      x = *MEMORY[0x1E0C9D648];
      y = *(double *)(MEMORY[0x1E0C9D648] + 8);
      v29 = *(double *)(MEMORY[0x1E0C9D648] + 16);
      v30 = *(double *)(MEMORY[0x1E0C9D648] + 24);
    }
  }
  if (*(_BYTE *)(v10 + 32))
  {
    if (!CGRectIsNull(*(CGRect *)v10) && !CGRectIsInfinite(*(CGRect *)v10))
    {
      v171.origin.x = x;
      v171.origin.y = y;
      v171.size.width = v29;
      v171.size.height = v30;
      v172 = CGRectIntersection(v171, *(CGRect *)v10);
      x = v172.origin.x;
      y = v172.origin.y;
      v29 = v172.size.width;
      v30 = v172.size.height;
      if (CGRectIsNull(v172))
      {
        x = *MEMORY[0x1E0C9D648];
        y = *(double *)(MEMORY[0x1E0C9D648] + 8);
        v29 = *(double *)(MEMORY[0x1E0C9D648] + 16);
        v30 = *(double *)(MEMORY[0x1E0C9D648] + 24);
      }
    }
  }
  v173.origin.x = x;
  v173.origin.y = y;
  v173.size.width = v29;
  v173.size.height = v30;
  if (CGRectIsEmpty(v173))
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Empty effective region-of-interest.", (uint8_t *)&buf, 2u);
    }
    v55 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
    goto LABEL_164;
  }
  v134 = *v8;
  v57 = (CFTypeRef)atomic_load(&v138);
  if (v57)
    v57 = CFRetain(v57);
  v144 = v57;
  v143.origin.x = x;
  v143.origin.y = y;
  v143.size.width = v29;
  v143.size.height = v30;
  v58 = (const __CFArray *)atomic_load(&v137);
  Count = CFArrayGetCount(v58);
  if (Count <= 0)
  {
LABEL_148:
    sub_1D3D74EDC((unint64_t *)&v144);
    v17 = (_QWORD *)&v158 + 1;
    goto LABEL_162;
  }
  v60 = 0;
  v61 = 0;
  v62 = (unint64_t *)(v135 + 64);
  propertyKey = (const __CFString *)*MEMORY[0x1E0CED850];
  v131 = (const __CFString *)*MEMORY[0x1E0CED7D0];
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v127 = (const __CFString *)*MEMORY[0x1E0CED830];
  domain = (const __CFString *)*MEMORY[0x1E0C9AFC8];
  v126 = (const __CFString *)*MEMORY[0x1E0CED828];
  v129 = Count;
  while (1)
  {
    v133 = v60;
    v63 = (const __CFArray *)atomic_load(&v137);
    ValueAtIndex = CFArrayGetValueAtIndex(v63, v61);
    if (ValueAtIndex)
      ValueAtIndex = CFRetain(ValueAtIndex);
    v142 = ValueAtIndex;
    v65 = (__CVBuffer *)atomic_load((unint64_t *)&v142);
    v66 = CVPixelBufferGetWidth(v65);
    v67 = sub_1D3D956B0((unint64_t *)&v142);
    v68 = (__CVBuffer *)atomic_load((unint64_t *)&v142);
    v69 = CVPixelBufferGetPixelFormatType(v68);
    v70 = sub_1D3D95778(&v143, v66, v67, v69);
    v72 = v71;
    v74 = v73;
    v76 = v75;
    CGAffineTransformMakeScale(&buf, 2.0, 2.0);
    v174.origin.x = v70;
    v174.origin.y = v72;
    v174.size.width = v74;
    v174.size.height = v76;
    v175 = CGRectApplyAffineTransform(v174, &buf);
    v143 = v175;
    if (!atomic_load(v134))
      break;
    v79 = atomic_load((unint64_t *)&v144);
    if (!v79 || (v80 = atomic_load((unint64_t *)&v142)) == 0)
    {
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v102 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.a) = 0;
        _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", (uint8_t *)&buf, 2u);
      }
      buf.a = NAN;
      *(_QWORD *)v165 = CFSTR("Invalid source and/or destination buffer.");
      sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)&buf, (CFTypeRef *)v165);
      goto LABEL_159;
    }
    v81 = v175.origin.x;
    v82 = v175.origin.y;
    v83 = v175.size.width;
    v84 = v175.size.height;
    v164 = v163;
    v161[0] = &off_1E95B0D40;
    v162 = v161;
    v163[0] = &off_1E95B0CC0;
    *(_QWORD *)&buf.tx = &buf.b;
    buf.a = v12;
    *(_QWORD *)&buf.b = &off_1E95B0D40;
    if (!*(_BYTE *)(*(_QWORD *)&v12 + 8)
      || (*(_QWORD *)v165 = **(_QWORD **)&v12, sub_1D3D95BCC(v77, (os_signpost_id_t *)v165), v85 = v162, v162 == v161))
    {
      v85 = v161;
      v86 = 4;
    }
    else
    {
      if (!v162)
        goto LABEL_101;
      v86 = 5;
    }
    (*(void (**)(void))(*v85 + 8 * v86))();
LABEL_101:
    v87 = v164;
    if (v164 == v163)
    {
      v87 = v163;
      v88 = 4;
      goto LABEL_105;
    }
    if (v164)
    {
      v88 = 5;
LABEL_105:
      (*((void (**)(void))*v87 + v88))();
    }
    v146 = 0;
    v176.origin.x = v81;
    v176.origin.y = v82;
    v176.size.width = v83;
    v176.size.height = v84;
    *(_QWORD *)v165 = CGRectCreateDictionaryRepresentation(v176);
    do
      v89 = __ldaxr((unint64_t *)v165);
    while (__stlxr(0, (unint64_t *)v165));
    do
      v90 = (const void *)__ldaxr(&v146);
    while (__stlxr(v89, &v146));
    if (v90)
      CFRelease(v90);
    sub_1D3D8BAAC((unint64_t *)v165);
    v145 = 0;
    v177.origin.x = v70;
    v177.origin.y = v72;
    v177.size.width = v74;
    v177.size.height = v76;
    *(_QWORD *)v165 = CGRectCreateDictionaryRepresentation(v177);
    do
      v91 = __ldaxr((unint64_t *)v165);
    while (__stlxr(0, (unint64_t *)v165));
    do
      v92 = (const void *)__ldaxr(&v145);
    while (__stlxr(v91, &v145));
    if (v92)
      CFRelease(v92);
    sub_1D3D8BAAC((unint64_t *)v165);
    v93 = v134;
    v94 = (const void *)atomic_load(v134);
    v95 = (const void *)atomic_load(&v146);
    VTSessionSetProperty(v94, propertyKey, v95);
    v96 = (const void *)atomic_load(v93);
    v97 = (const void *)atomic_load(&v145);
    VTSessionSetProperty(v96, v131, v97);
    v98 = (OpaqueVTPixelTransferSession *)atomic_load(v93);
    v99 = (__CVBuffer *)atomic_load((unint64_t *)&v144);
    v100 = (__CVBuffer *)atomic_load((unint64_t *)&v142);
    v101 = VTPixelTransferSessionTransferImage(v98, v99, v100);
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v102 = qword_1EDB89F48;
    if (v101)
    {
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v165 = 67240192;
        *(_DWORD *)&v165[4] = v101;
        _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionTransferImage failed: %{public}d", v165, 8u);
      }
      *(_QWORD *)v165 = -2004;
      propertyValueOut = CFSTR("VTPixelTransferSessionTransferImage failed.");
      sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)v165, (CFTypeRef *)&propertyValueOut);
      *(_QWORD *)v165 = CFErrorCreate(allocator, domain, v101, 0);
      do
        v103 = __ldaxr((unint64_t *)v165);
      while (__stlxr(0, (unint64_t *)v165));
      do
        v104 = (const void *)__ldaxr(v62);
      while (__stlxr(v103, v62));
      if (v104)
        CFRelease(v104);
      sub_1D3D7448C((unint64_t *)v165);
    }
    else if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      propertyValueOut = 0;
      v105 = (const void *)atomic_load(v134);
      if (!VTSessionCopyProperty(v105, v127, allocator, &propertyValueOut))
      {
        v106 = propertyValueOut;
        if (propertyValueOut)
        {
          if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v165 = 138543362;
            *(_QWORD *)&v165[4] = v106;
            _os_log_debug_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentConversionType: %{public}@", v165, 0xCu);
            v106 = propertyValueOut;
          }
          CFRelease(v106);
        }
      }
      v147 = 0;
      v107 = (const void *)atomic_load(v134);
      if (!VTSessionCopyProperty(v107, v126, allocator, &v147))
      {
        v108 = v147;
        if (v147)
        {
          if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v165 = 138543362;
            *(_QWORD *)&v165[4] = v108;
            _os_log_debug_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentChainDescription: %{public}@", v165, 0xCu);
            v108 = v147;
          }
          CFRelease(v108);
        }
      }
    }
    sub_1D3D8BAAC(&v145);
    sub_1D3D8BAAC(&v146);
    tx = buf.tx;
    if (*(_BYTE *)(*(_QWORD *)&buf.a + 8))
    {
      if (!*(_QWORD *)&buf.tx)
        goto LABEL_146;
      *(_QWORD *)v165 = **(_QWORD **)&buf.a;
      (*(void (**)(void))(**(_QWORD **)&buf.tx + 48))();
      tx = buf.tx;
    }
    if (*(CGAffineTransform **)&tx == (CGAffineTransform *)&buf.b)
    {
      tx = COERCE_DOUBLE((CGAffineTransform *)&buf.b);
      v110 = 4;
    }
    else
    {
      if (tx == 0.0)
        goto LABEL_146;
      v110 = 5;
    }
    (*(void (**)(void))(**(_QWORD **)&tx + 8 * v110))();
LABEL_146:
    if (v101)
      goto LABEL_159;
    v111 = (const void *)atomic_load((unint64_t *)&v142);
    sub_1D3D95C6C((unint64_t *)&v144, v111);
    v143.origin.x = v70;
    v143.origin.y = v72;
    v143.size.width = v74;
    v143.size.height = v76;
    sub_1D3D74EDC((unint64_t *)&v142);
    v60 = ++v61 >= v129;
    if (v61 == v129)
      goto LABEL_148;
  }
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v102 = qword_1EDB89F48;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.a) = 0;
    _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "Invalid pixel transfer session.", (uint8_t *)&buf, 2u);
  }
  buf.a = NAN;
  *(_QWORD *)v165 = CFSTR("Invalid pixel transfer session.");
  sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)&buf, (CFTypeRef *)v165);
LABEL_159:
  if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.a) = 134349056;
    *(_QWORD *)((char *)&buf.a + 4) = v61;
    _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "Failed to transfer image at level #%{public}ld.", (uint8_t *)&buf, 0xCu);
  }
  sub_1D3D74EDC((unint64_t *)&v142);
  sub_1D3D74EDC((unint64_t *)&v144);
  v17 = (_QWORD *)&v158 + 1;
  if (!v133)
  {
LABEL_73:
    v55 = 0;
    goto LABEL_164;
  }
LABEL_162:
  v55 = (const void *)atomic_load(&v137);
  if (v55)
    v55 = CFRetain(v55);
LABEL_164:
  v136 = v55;
  sub_1D3D74138(&v137);
LABEL_165:
  sub_1D3D74EDC(&v138);
  if (v141)
    sub_1D3DE793C(v139, v140);
LABEL_167:
  v112 = v160;
  if (!*(_BYTE *)(v158 + 8))
  {
LABEL_170:
    if (v112 == (__int128 *)((char *)&v158 + 8))
    {
      v113 = 4;
    }
    else
    {
      if (!v112)
        goto LABEL_175;
      v113 = 5;
      v17 = v112;
    }
    (*(void (**)(_QWORD *))(*v17 + 8 * v113))(v17);
    goto LABEL_175;
  }
  if (v160)
  {
    buf.a = *(CGFloat *)v158;
    (*(void (**)(void))(*(_QWORD *)v160 + 48))();
    v112 = v160;
    goto LABEL_170;
  }
LABEL_175:
  v114 = *(unint64_t **)(a1 + 16);
  do
    v115 = __ldaxr((unint64_t *)&v136);
  while (__stlxr(0, (unint64_t *)&v136));
  do
    v116 = (const void *)__ldaxr(v114);
  while (__stlxr(v115, v114));
  if (v116)
    CFRelease(v116);
  result = sub_1D3D74138((unint64_t *)&v136);
  v117 = atomic_load(*(unint64_t **)(a1 + 16));
  if (!v117 || *(_BYTE *)(*(_QWORD *)(a1 + 8) + 96))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v5 = qword_1EDB89F48;
    result = (unint64_t *)os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      v118 = *(_QWORD *)(a1 + 8);
      if (*(_BYTE *)(v118 + 96))
      {
        sub_1D3DF4F6C((uint64_t)&buf, v118);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        BYTE4(buf.d) = 0;
        v150 = 0u;
        v151 = 0u;
        BYTE4(v150) = 0;
        v152 = 0u;
      }
      sub_1D3DF53CC((CFErrorRef *)v163, (uint64_t)&buf);
      v119 = atomic_load((unint64_t *)v163);
      LODWORD(v158) = 138543362;
      *(_QWORD *)((char *)&v158 + 4) = v119;
      v46 = "Cannot generate pyramid: %{public}@";
      goto LABEL_190;
    }
  }
  return result;
}

void sub_1D3D9CB88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,_QWORD *a23,uint64_t a24,uint64_t a25,unint64_t a26,unint64_t a27,unint64_t *a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t *a61,uint64_t a62,uint64_t a63)
{
  _QWORD *a65;
  _QWORD *v66;
  uint64_t v67;

  sub_1D3D74138(&a26);
  sub_1D3D74EDC(&a27);
  if (a30)
    sub_1D3DE793C(a28, a29);
  v66 = a65;
  if (*((_BYTE *)a61 + 8))
  {
    if (!a65)
      goto LABEL_11;
    a32 = *a61;
    (*(void (**)(void))(*a65 + 48))();
    v66 = a65;
  }
  if (v66 == a23)
  {
    v67 = 4;
  }
  else
  {
    if (!v66)
      goto LABEL_11;
    v67 = 5;
    a23 = v66;
  }
  (*(void (**)(void))(*a23 + 8 * v67))();
LABEL_11:
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D9CE60(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE26generatePyramidWithContextERNS_7ContextERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS9_INS_5ErrorEEERKNS9_IyEEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9CE98()
{
  return &unk_1E95B1030;
}

unint64_t *sub_1D3D9CEA4@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  unint64_t *result;
  uint64_t v4;
  unint64_t v5[12];
  char v6;
  _QWORD v7[3];
  unint64_t *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  LOBYTE(v5[0]) = 0;
  v6 = 0;
  v7[0] = &off_1E95B1960;
  v7[1] = v5;
  v8 = v7;
  sub_1D3D96230(a1, v7);
  result = v8;
  if (v8 == v7)
  {
    v4 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      goto LABEL_6;
    v4 = 5;
  }
  result = (unint64_t *)(*(uint64_t (**)(void))(*result + 8 * v4))();
LABEL_6:
  if (v6)
  {
    result = sub_1D3DF53CC(a2, (uint64_t)v5);
    if (v6)
      return sub_1D3DF4F24(v5);
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1D3D9CF74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21)
    sub_1D3DF4F24((unint64_t *)&a9);
  _Unwind_Resume(exception_object);
}

void sub_1D3D9CFC8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9CFDC(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1960;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9D010(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1960;
  a2[1] = v2;
  return result;
}

unint64_t *sub_1D3D9D02C(unint64_t *result, uint64_t a2, uint64_t a3)
{
  if (!*(_BYTE *)(a2 + 8))
    return sub_1D3D74C98((unint64_t *)result[1], a3);
  return result;
}

uint64_t sub_1D3D9D044(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE19preflightForContextERNS_7ContextEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9D07C()
{
  return &unk_1E95B19C0;
}

void sub_1D3D9D088(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*(_BYTE *)(a1 + 8))
    sub_1D3D9D0E0((unint64_t *)a1);
  JUMPOUT(0x1D8254C54);
}

unint64_t *sub_1D3D9D0E0(unint64_t *a1)
{
  OpaqueVTPixelTransferSession *v3;

  if (atomic_load(a1))
  {
    v3 = (OpaqueVTPixelTransferSession *)atomic_load(a1);
    VTPixelTransferSessionInvalidate(v3);
  }
  return sub_1D3D94AD4(a1);
}

void sub_1D3D9D114(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::transferImage", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3D9D1B8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9D1CC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B0E40;
  return result;
}

void sub_1D3D9D1F0(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B0E40;
}

void sub_1D3D9D208(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::transferImage", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3D9D2A8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9D2E0()
{
  return &unk_1E95B0EA0;
}

void sub_1D3D9D2F0()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9D304()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B0DC0;
  return result;
}

void sub_1D3D9D328(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B0DC0;
}

uint64_t sub_1D3D9D340(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9D378()
{
  return &unk_1E95B0E20;
}

void sub_1D3D9D388()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9D39C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1A60;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9D3D0(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1A60;
  a2[1] = v2;
  return result;
}

void sub_1D3D9D3EC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  __int16 v8;
  unint64_t v9;
  uint64_t v10;
  CGRect v11;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v5 = vcvtpd_u64_f64(CGRectGetWidth(*(CGRect *)(**(_QWORD **)(a1 + 8) + 8)));
      v11 = *(CGRect *)(**(_QWORD **)(a1 + 8) + 8);
      v6 = 134349312;
      v7 = v5;
      v8 = 2050;
      v9 = vcvtpd_u64_f64(CGRectGetHeight(v11));
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v3, "PyramidGenerationSession::generatePyramid", "masterPixelBufferWidth=%{public, signpost.description:attribute}zu, masterPixelBufferHeight=%{public, signpost.description:attribute}zu", (uint8_t *)&v6, 0x16u);
    }
  }
}

uint64_t sub_1D3D9D50C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9D544()
{
  return &unk_1E95B1AC0;
}

void sub_1D3D9D554()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9D568(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B19E0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9D59C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B19E0;
  a2[1] = v2;
  return result;
}

void sub_1D3D9D5B8(uint64_t a1, os_signpost_id_t *a2)
{
  sub_1D3D94B0C(a1 + 8, *a2);
}

uint64_t sub_1D3D9D5C4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9D5FC()
{
  return &unk_1E95B1A40;
}

void sub_1D3D9D608(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  std::__shared_weak_count *v4;
  os_unfair_lock_s *v5;
  _QWORD *v6;
  uint64_t v7;
  NSObject *shared_weak_owners;
  _QWORD *v9;
  uint64_t v10;
  NSObject *v11;
  dispatch_queue_t v12;
  uint64_t (*v13)(_QWORD);
  CFTypeRef v14;
  CFTypeRef v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  uint64_t (***v19)();
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  NSObject *v25;
  uint64_t *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  void *v32;
  __int128 v33;
  _BYTE v34[24];
  _BYTE *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t context[3];
  uint64_t *v39;
  char v40;
  uint64_t (**v41)();
  char v42;
  uint64_t (***v43)();
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v2 = a2 + 3;
  if (!a2[3])
    return;
  v4 = (std::__shared_weak_count *)a1;
  v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  v6 = sub_1D3D967F4(&v4[1].__vftable, (unint64_t)&unk_1D3E66158);
  if (!v6)
  {
    v7 = (uint64_t)v4->__vftable;
    shared_weak_owners = v4->__shared_weak_owners_;
    v32 = &unk_1D3E66158;
    *(_QWORD *)&v33 = "LegacyPyramidGenerationSessionContext";
    *((_QWORD *)&v33 + 1) = 37;
    v9 = (_QWORD *)operator new();
    v10 = operator new();
    v11 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v12 = dispatch_queue_create_with_target_V2("mrc::Context::ConcreteBase<mrc::(anonymous namespace)::PyramidGenerationSessionContext<mrc::PyramidGenerationBehavior::Legacy>>::ConcreteBase(const Options &, dispatch_queue_t _Nonnull) [_Derived = mrc::(anonymous namespace)::PyramidGenerationSessionContext<mrc::PyramidGenerationBehavior::Legacy>]", v11, shared_weak_owners);
    v13 = MEMORY[0x1E0C82E98];
    *(_QWORD *)(v10 + 8) = v12;
    *(_QWORD *)(v10 + 16) = v13;
    *(_QWORD *)v10 = &off_1E95B22B8;
    *(_QWORD *)(v10 + 24) = *(_QWORD *)v7;
    v14 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 8));
    if (v14)
      v14 = CFRetain(v14);
    *(_QWORD *)(v10 + 32) = v14;
    v15 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 16));
    if (v15)
      v15 = CFRetain(v15);
    *(_QWORD *)(v10 + 40) = v15;
    v16 = *(_OWORD *)(v7 + 24);
    v17 = *(_OWORD *)(v7 + 40);
    *(_WORD *)(v10 + 80) = *(_WORD *)(v7 + 56);
    *(_OWORD *)(v10 + 48) = v16;
    *(_OWORD *)(v10 + 64) = v17;
    *(_BYTE *)(v10 + 88) = 0;
    *(_BYTE *)(v10 + 96) = 0;
    *(_BYTE *)(v10 + 104) = 0;
    *(_BYTE *)(v10 + 200) = 0;
    *v9 = v10;
    v18 = (_QWORD *)operator new();
    *v18 = &off_1E95B2320;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = v10;
    v9[1] = v18;
    v41 = &off_1E95B2370;
    v43 = &v41;
    v36 = v9;
    sub_1D3D96968((uint64_t)&v37, (uint64_t)&v41);
    sub_1D3E23E40((uint64_t)context, (uint64_t)&unk_1D3E66158, &v33, (uint64_t *)&v36);
    sub_1D3D969CC((uint64_t *)&v36);
    v19 = v43;
    if (v43 == &v41)
    {
      v20 = 4;
      v19 = &v41;
    }
    else
    {
      if (!v43)
      {
LABEL_12:
        v6 = sub_1D3D96A58((uint64_t *)&v4[1], &v32, context);
        sub_1D3D969CC((uint64_t *)&v39);
        sub_1D3E23B04((uint64_t *)v4);
        goto LABEL_13;
      }
      v20 = 5;
    }
    (*v19)[v20]();
    goto LABEL_12;
  }
LABEL_13:
  if ((_UNKNOWN *)v6[3] != &unk_1D3E66158)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_50;
  }
  v21 = (uint64_t *)v6[6];
  if (!v21)
  {
LABEL_50:
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_51;
  }
  v22 = *v21;
  v4 = (std::__shared_weak_count *)v21[1];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v5);
  if (!v22)
  {
    if (qword_1EDB89F40 == -1)
    {
LABEL_23:
      v25 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        LOWORD(context[0]) = 0;
        _os_log_error_impl(&dword_1D3D6B000, v25, OS_LOG_TYPE_ERROR, "Unable to retrieve or instantiate concrete PyramidGenerationSession context.", (uint8_t *)context, 2u);
      }
      LOBYTE(v41) = 0;
      v42 = 0;
      sub_1D3DF4E68((uint64_t)&v36, -1, 0);
      sub_1D3DF50BC(context, (uint64_t *)&v36);
      v40 = 1;
      if (!*v2)
        sub_1D3D75A24();
      (*(void (**)(_QWORD, uint64_t (***)(), uint64_t *))(*(_QWORD *)*v2 + 48))(*v2, &v41, context);
      if (v40)
        sub_1D3DF4F24((unint64_t *)context);
      sub_1D3DF4F24((unint64_t *)&v36);
      goto LABEL_43;
    }
LABEL_51:
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    goto LABEL_23;
  }
  if (!*v2)
  {
    v2 = &v35;
    goto LABEL_30;
  }
  if ((_QWORD *)*v2 != a2)
  {
    v35 = (_BYTE *)*v2;
LABEL_30:
    *v2 = 0;
    goto LABEL_32;
  }
  v35 = v34;
  (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v34);
LABEL_32:
  if (!v35)
    goto LABEL_43;
  context[0] = (uint64_t)&off_1E95B23F0;
  context[1] = v22;
  context[2] = (uint64_t)v34;
  v39 = context;
  dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v22 + 8), context, (dispatch_function_t)sub_1D3D9DC58);
  v26 = v39;
  if (v39 == context)
  {
    v27 = 4;
    v26 = context;
  }
  else
  {
    if (!v39)
      goto LABEL_38;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_38:
  v28 = v35;
  if (v35 == v34)
  {
    v29 = 4;
    v28 = v34;
  }
  else
  {
    if (!v35)
      goto LABEL_43;
    v29 = 5;
  }
  (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_43:
  if (v4)
  {
    v30 = (unint64_t *)&v4->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1D3D9DAAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D9DBCC(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 200))
      sub_1D3DF4F24((unint64_t *)(result + 104));
    if (*(_BYTE *)(v1 + 96))
    {
      v2 = *(_QWORD *)(v1 + 88);
      *(_QWORD *)(v1 + 88) = 0;
      if (v2)
        sub_1D3D9D088(v2);
    }
    sub_1D3D8BA0C((unint64_t *)(v1 + 40));
    sub_1D3D8BA0C((unint64_t *)(v1 + 32));
    v3 = *(_QWORD *)(v1 + 8);
    *(_QWORD *)v1 = &off_1E95B2300;
    *(_QWORD *)(v1 + 8) = 0;
    if (v3)
      (*(void (**)(void))(v1 + 16))();
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3D9DC58(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (!v1)
    sub_1D3D75A24();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void sub_1D3D9DC80()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D9DC94(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95B23F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3D9DCCC(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95B23F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unint64_t *sub_1D3D9DCEC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *result;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t (***v13)();
  uint64_t v14;
  const __CFAllocator *v15;
  OSStatus v16;
  NSObject *v17;
  unint64_t *v18;
  unint64_t v19;
  const void *v20;
  int v21;
  unint64_t v22;
  const void *v24;
  const void *v25;
  qos_class_t v26;
  unsigned int v27;
  unint64_t v28;
  unsigned int v29;
  BOOL v30;
  CFTypeRef *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  unint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  uint64_t v41;
  CFTypeRef v42;
  CFTypeRef v43;
  __int128 v44;
  __int128 v45;
  NSObject *v46;
  _BYTE *v47;
  uint64_t v48;
  unint64_t v49;
  int v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t *v59;
  uint64_t v60;
  OpaqueVTPixelTransferSession *v61;
  char v62;
  unint64_t v63;
  unsigned __int8 v64;
  VTPixelTransferSessionRef v65;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  OpaqueVTPixelTransferSession **v67;
  _QWORD v68[3];
  _QWORD *v69;
  _BYTE v70[22];
  _BYTE *v71;
  char v72;
  _QWORD v73[3];
  _QWORD *v74;
  _QWORD v75[3];
  _QWORD *v76;
  uint8_t buf[8];
  _QWORD v78[3];
  _QWORD *v79;
  uint64_t (**v80)();
  char v81;
  uint64_t *v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v2 + 200))
  {
    v3 = *(_QWORD *)(a1 + 16);
    LOBYTE(v67) = 0;
    LOBYTE(v68[0]) = 0;
    sub_1D3DF4F6C((uint64_t)v70, v2 + 104);
    v72 = 1;
    v4 = *(_QWORD *)(v3 + 24);
    if (!v4)
      sub_1D3D75A24();
    result = (unint64_t *)(*(uint64_t (**)(uint64_t, OpaqueVTPixelTransferSession ***, _BYTE *))(*(_QWORD *)v4 + 48))(v4, &v67, v70);
LABEL_102:
    if (!v72)
      return result;
    v59 = (unint64_t *)v70;
    return sub_1D3DF4F24(v59);
  }
  v6 = (uint64_t *)(v2 + 88);
  if (*(_BYTE *)(v2 + 96))
  {
LABEL_100:
    v57 = *(_QWORD *)(a1 + 16);
    v67 = (OpaqueVTPixelTransferSession **)(v2 + 88);
    LOBYTE(v68[0]) = 1;
    v70[0] = 0;
    v72 = 0;
    v58 = *(_QWORD *)(v57 + 24);
    if (!v58)
      sub_1D3D75A24();
    result = (unint64_t *)(*(uint64_t (**)(uint64_t, OpaqueVTPixelTransferSession ***, _BYTE *))(*(_QWORD *)v58 + 48))(v58, &v67, v70);
    goto LABEL_102;
  }
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v61 = (OpaqueVTPixelTransferSession *)os_signpost_id_make_with_pointer((os_log_t)qword_1EDB89F48, (const void *)v2);
  v62 = 1;
  v76 = v75;
  v73[0] = &off_1E95B1BF0;
  v74 = v73;
  v75[0] = &off_1E95B1B70;
  v69 = v68;
  v67 = &v61;
  v68[0] = &off_1E95B1BF0;
  sub_1D3D979E0((os_signpost_id_t)v61);
  v7 = v74;
  if (v74 == v73)
  {
    v8 = 4;
    v7 = v73;
  }
  else
  {
    if (!v74)
      goto LABEL_12;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_12:
  v9 = v76;
  if (v76 == v75)
  {
    v10 = 4;
    v9 = v75;
    goto LABEL_16;
  }
  if (v76)
  {
    v10 = 5;
LABEL_16:
    v9 = (_QWORD *)(*(uint64_t (**)(void))(*v9 + 8 * v10))();
  }
  v82 = (uint64_t *)&v80;
  v78[0] = &off_1E95B1CF0;
  v79 = v78;
  v80 = &off_1E95B1C70;
  v71 = &v70[8];
  *(_QWORD *)v70 = &v61;
  *(_QWORD *)&v70[8] = &off_1E95B1CF0;
  if (!v62
    || (pixelTransferSessionOut = v61,
        sub_1D3D9E6A0((uint64_t)v9, (os_signpost_id_t *)&pixelTransferSessionOut),
        v11 = v79,
        v79 == v78))
  {
    v12 = 4;
    v11 = v78;
  }
  else
  {
    if (!v79)
      goto LABEL_23;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_23:
  v13 = (uint64_t (***)())v82;
  if (v82 == (uint64_t *)&v80)
  {
    v14 = 4;
    v13 = &v80;
  }
  else
  {
    if (!v82)
      goto LABEL_28;
    v14 = 5;
  }
  (*v13)[v14]();
LABEL_28:
  pixelTransferSessionOut = 0;
  v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v16 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
  if (v16)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v17 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&buf[4] = v16;
      _os_log_error_impl(&dword_1D3D6B000, v17, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate failed: %{public}d", buf, 8u);
    }
    *(_QWORD *)buf = -2003;
    v65 = (VTPixelTransferSessionRef)CFSTR("VTPixelTransferSessionCreate failed.");
    sub_1D3D73E0C((unint64_t *)(v2 + 104), (uint64_t *)buf, (CFTypeRef *)&v65);
    *(_QWORD *)buf = CFErrorCreate(v15, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v16, 0);
    v18 = (unint64_t *)(v2 + 168);
    do
      v19 = __ldaxr((unint64_t *)buf);
    while (__stlxr(0, (unint64_t *)buf));
    do
      v20 = (const void *)__ldaxr(v18);
    while (__stlxr(v19, v18));
    if (v20)
      CFRelease(v20);
    sub_1D3D7448C((unint64_t *)buf);
    v21 = 0;
    LOBYTE(v63) = 0;
    v64 = 0;
  }
  else
  {
    v65 = pixelTransferSessionOut;
    do
      v22 = __ldaxr((unint64_t *)&v65);
    while (__stlxr(0, (unint64_t *)&v65));
    *(_QWORD *)buf = v22;
    if (atomic_load((unint64_t *)buf))
    {
      v24 = (const void *)atomic_load((unint64_t *)buf);
      VTSessionSetProperty(v24, (CFStringRef)*MEMORY[0x1E0CED848], (CFTypeRef)*MEMORY[0x1E0CEDB40]);
      v25 = (const void *)atomic_load((unint64_t *)buf);
      VTSessionSetProperty(v25, (CFStringRef)*MEMORY[0x1E0CED7F0], (CFTypeRef)*MEMORY[0x1E0CED490]);
      v26 = *(_DWORD *)(v2 + 48);
      HIDWORD(v28) = v26 - 9;
      LODWORD(v28) = v26 - 9;
      v27 = v28 >> 2;
      v29 = (0x22u >> (v28 >> 2)) & 1;
      v30 = v27 <= 6 && v29 == 0;
      v31 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      if (v30)
      {
        if (v27 > 6 || ((1 << v27) & 0x5D) == 0)
          v26 = qos_class_self();
        if (v26 == QOS_CLASS_USER_INTERACTIVE)
        {
          v32 = (const void *)atomic_load((unint64_t *)buf);
          VTSessionSetProperty(v32, (CFStringRef)*MEMORY[0x1E0CED838], *v31);
        }
      }
      v33 = (const void *)atomic_load((unint64_t *)buf);
      VTSessionSetProperty(v33, (CFStringRef)*MEMORY[0x1E0CED808], *v31);
      v34 = (const void *)atomic_load((unint64_t *)buf);
      v35 = (const void *)*MEMORY[0x1E0C9AE40];
      VTSessionSetProperty(v34, (CFStringRef)*MEMORY[0x1E0CED868], (CFTypeRef)*MEMORY[0x1E0C9AE40]);
      v36 = (const void *)atomic_load((unint64_t *)buf);
      VTSessionSetProperty(v36, (CFStringRef)*MEMORY[0x1E0CED800], v35);
      v37 = (const void *)atomic_load((unint64_t *)buf);
      VTSessionSetProperty(v37, (CFStringRef)*MEMORY[0x1E0CED7F8], v35);
    }
    do
      v38 = __ldaxr((unint64_t *)buf);
    while (__stlxr(0, (unint64_t *)buf));
    v63 = v38;
    v21 = 1;
    v64 = 1;
    sub_1D3D9D0E0((unint64_t *)buf);
    sub_1D3D94AD4((unint64_t *)&v65);
  }
  v39 = v71;
  if (*(_BYTE *)(*(_QWORD *)v70 + 8))
  {
    if (!v71)
      goto LABEL_62;
    pixelTransferSessionOut = **(VTPixelTransferSessionRef **)v70;
    (*(void (**)(void))(*(_QWORD *)v71 + 48))();
    v39 = v71;
  }
  if (v39 == &v70[8])
  {
    v40 = 4;
    v39 = &v70[8];
  }
  else
  {
    if (!v39)
      goto LABEL_62;
    v40 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v39 + 8 * v40))();
  v21 = v64;
LABEL_62:
  if (v21)
  {
    v41 = operator new();
    *(_QWORD *)(v41 + 8) = -1;
    *(_QWORD *)(v41 + 16) = -1;
    *(_DWORD *)(v41 + 24) = 1061109567;
    *(_QWORD *)v41 = &off_1E95B1D70;
    *(_QWORD *)(v41 + 32) = *(_QWORD *)(v2 + 24);
    v42 = (CFTypeRef)atomic_load((unint64_t *)(v2 + 32));
    if (v42)
      v42 = CFRetain(v42);
    *(_QWORD *)(v41 + 40) = v42;
    v43 = (CFTypeRef)atomic_load((unint64_t *)(v2 + 40));
    if (v43)
      v43 = CFRetain(v43);
    *(_QWORD *)(v41 + 48) = v43;
    v44 = *(_OWORD *)(v2 + 48);
    v45 = *(_OWORD *)(v2 + 64);
    *(_WORD *)(v41 + 88) = *(_WORD *)(v2 + 80);
    *(_OWORD *)(v41 + 72) = v45;
    *(_OWORD *)(v41 + 56) = v44;
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v46 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v70 = 136446466;
      *(_QWORD *)&v70[4] = "PlaceholderPyramidAllocator";
      *(_WORD *)&v70[12] = 2050;
      *(_QWORD *)&v70[14] = v41;
      _os_log_debug_impl(&dword_1D3D6B000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", v70, 0x16u);
    }
    v80 = 0;
    *(_QWORD *)v70 = 0;
    sub_1D3D97B20((uint64_t *)v70);
    sub_1D3D97B20((uint64_t *)&v80);
    v47 = (_BYTE *)operator new();
    v48 = (uint64_t)v47;
    *v47 = 0;
    v47[8] = 0;
    if (v64)
    {
      do
        v49 = __ldaxr(&v63);
      while (__stlxr(0, &v63));
      *(_QWORD *)v47 = v49;
      v47[8] = 1;
      if (v64)
        sub_1D3D9D0E0(&v63);
    }
    *(_QWORD *)(v48 + 16) = v41;
    v50 = 1;
  }
  else
  {
    v48 = 0;
    v50 = 0;
  }
  v51 = v69;
  if (*((_BYTE *)v67 + 8))
  {
    if (!v69)
      goto LABEL_85;
    *(_QWORD *)v70 = *v67;
    (*(void (**)(void))(*v69 + 48))();
    v51 = v69;
  }
  if (v51 == v68)
  {
    v52 = 4;
    v51 = v68;
  }
  else
  {
    if (!v51)
      goto LABEL_85;
    v52 = 5;
  }
  (*(void (**)(void))(*v51 + 8 * v52))();
LABEL_85:
  if (*(unsigned __int8 *)(v2 + 96) == v50)
  {
    if (*(_BYTE *)(v2 + 96))
    {
      v53 = *v6;
      *v6 = v48;
      v48 = v53;
      if (!v53)
        goto LABEL_96;
LABEL_95:
      sub_1D3D9D088(v48);
    }
  }
  else
  {
    if (!*(_BYTE *)(v2 + 96))
    {
      *(_QWORD *)(v2 + 88) = v48;
      *(_BYTE *)(v2 + 96) = 1;
      goto LABEL_100;
    }
    v54 = *v6;
    *v6 = 0;
    if (v54)
      sub_1D3D9D088(v54);
    *(_BYTE *)(v2 + 96) = 0;
  }
  if (v21 && v48)
    goto LABEL_95;
LABEL_96:
  if (*(_BYTE *)(v2 + 96))
    goto LABEL_100;
  v55 = *(_QWORD *)(a1 + 16);
  LOBYTE(v80) = 0;
  v81 = 0;
  v56 = *(unsigned __int8 *)(v2 + 200);
  if (*(_BYTE *)(v2 + 200))
  {
    sub_1D3DF4F6C((uint64_t)v70, v2 + 104);
  }
  else
  {
    sub_1D3DF4E68((uint64_t)&v67, -1, 0);
    sub_1D3DF50BC(v70, (uint64_t *)&v67);
  }
  v72 = 1;
  v60 = *(_QWORD *)(v55 + 24);
  if (!v60)
    sub_1D3D75A24();
  result = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t (***)(), _BYTE *))(*(_QWORD *)v60 + 48))(v60, &v80, v70);
  if (v72)
    result = sub_1D3DF4F24((unint64_t *)v70);
  if (!v56)
  {
    v59 = (unint64_t *)&v67;
    return sub_1D3DF4F24(v59);
  }
  return result;
}

void sub_1D3D9E554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3D9E65C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE1EE7performENSt3__18functionIFvONS4_8optionalINS4_17reference_wrapperINS_24PyramidGenerationSessionILS2_1EEEEEEEONS6_INS_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9E694()
{
  return &unk_1E95B2450;
}

void sub_1D3D9E6A0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3D9E740(uint64_t a1)
{
  sub_1D3D8BA0C((unint64_t *)(a1 + 48));
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  return a1;
}

void sub_1D3D9E770(uint64_t a1)
{
  sub_1D3D8BA0C((unint64_t *)(a1 + 48));
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3D9E7B0()
{
  return 1;
}

uint64_t *sub_1D3D9E7B8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, unint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  BOOL v12;
  uint64_t v13;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t *result;
  uint64_t *v20;
  uint64_t v21;

  if (*(_BYTE *)(a1 + 89))
    v12 = *(_BYTE *)(a1 + 88) == 0;
  else
    v12 = 1;
  if (v12)
  {
    v13 = operator new();
    *(_QWORD *)(v13 + 8) = a2;
    *(_QWORD *)(v13 + 16) = a3;
    *(_DWORD *)(v13 + 24) = a4;
    *(_QWORD *)v13 = &off_1E95B1DE8;
    v20 = (uint64_t *)v13;
    sub_1D3D9EA54(&v21, (uint64_t *)&v20, a5);
    result = v20;
    *a7 = v21;
    if (result)
      return (uint64_t *)MEMORY[0x1D8254C54](result, 0x1081C40DCAC275BLL);
  }
  else
  {
    v16 = operator new();
    *(_QWORD *)(v16 + 8) = a2;
    *(_QWORD *)(v16 + 16) = a3;
    *(_DWORD *)(v16 + 24) = a4;
    *(_QWORD *)v16 = &off_1E95B2150;
    *(_WORD *)(v16 + 28) = 0;
    v17 = *(_OWORD *)(a1 + 72);
    *(_BYTE *)(v16 + 96) = 0;
    *(_OWORD *)(v16 + 32) = v17;
    *(_OWORD *)(v16 + 48) = 0u;
    *(_OWORD *)(v16 + 64) = 0u;
    *(_BYTE *)(v16 + 80) = 0;
    v20 = (uint64_t *)v16;
    sub_1D3D9EBD4(&v21, (uint64_t *)&v20, a5, a6);
    v18 = v21;
    v21 = 0;
    *a7 = v18;
    sub_1D3D98268(&v21);
    return sub_1D3D98268((uint64_t *)&v20);
  }
  return result;
}

void sub_1D3D9E900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1D3D98268(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D9E938@<X0>(unint64_t *a1@<X1>, _QWORD *a2@<X8>)
{
  NSObject *v4;
  uint64_t result;
  const __CFString *v6;
  _BYTE buf[24];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v4 = qword_1EDB89F48;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "virtual CFRef<CFArrayRef> mrc::(anonymous namespace)::PlaceholderPyramidAllocator<mrc::PyramidG"
                         "enerationBehavior::Legacy>::allocate(std::optional<Error> &, const std::optional<os_signpost_id"
                         "_t> &) const [_Behavior = mrc::PyramidGenerationBehavior::Legacy]";
    _os_log_fault_impl(&dword_1D3D6B000, v4, OS_LOG_TYPE_FAULT, "Unexpected invocation: %{public}s", buf, 0xCu);
  }
  v6 = CFSTR("PlaceholderPyramidAllocator::allocate should never be invoked.");
  *(_QWORD *)buf = -2011;
  result = sub_1D3D73E0C(a1, (uint64_t *)buf, (CFTypeRef *)&v6);
  *a2 = 0;
  return result;
}

const char *sub_1D3D9EA38()
{
  return "PlaceholderPyramidAllocator";
}

uint64_t sub_1D3D9EA44()
{
  return 1;
}

uint64_t sub_1D3D9EA4C()
{
  return 1;
}

void sub_1D3D9EA54(_QWORD *a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v6;
  NSObject *v7;
  const __CFString *v8;
  _BYTE buf[12];
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v7 = qword_1EDB89F48;
  if (v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
      v10 = 2050;
      v11 = v6;
      _os_log_debug_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
      v6 = *a2;
    }
    *a2 = 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v7, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    v8 = CFSTR("Failed to allocate pyramid allocator.");
    *(_QWORD *)buf = -2003;
    sub_1D3D73E0C(a3, (uint64_t *)buf, (CFTypeRef *)&v8);
    v6 = 0;
  }
  *a1 = v6;
}

void sub_1D3D9EBD4(uint64_t *a1, uint64_t *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v6;
  int v9;
  NSObject *v10;
  __n128 v11;
  NSObject *v12;
  const __CFString *v13;
  _BYTE buf[12];
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  if (!*a2)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v12 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    v13 = CFSTR("Failed to allocate pyramid allocator.");
    *(_QWORD *)buf = -2003;
    sub_1D3D73E0C(a3, (uint64_t *)buf, (CFTypeRef *)&v13);
    goto LABEL_17;
  }
  v9 = *(unsigned __int8 *)(v6 + 96);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v10 = qword_1EDB89F48;
  if (v9)
    goto LABEL_9;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v15 = 2050;
    v16 = v6;
    _os_log_debug_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is being prepared", buf, 0x16u);
    v6 = *a2;
  }
  if (!sub_1D3D9EE14(v6, (uint64_t)a3, a4, v11))
  {
LABEL_17:
    v6 = 0;
    goto LABEL_18;
  }
  v6 = *a2;
LABEL_9:
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v15 = 2050;
    v16 = v6;
    _os_log_debug_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
    v6 = *a2;
  }
  *a2 = 0;
LABEL_18:
  *a1 = v6;
}

uint64_t sub_1D3D9EE14(uint64_t a1, uint64_t a2, uint64_t a3, __n128 a4)
{
  uint64_t v4;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  _DWORD v34[2];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  os_signpost_id_t v38;
  char v39;
  char v40;
  char v41;
  int v42;
  char v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  char v47;
  int v48;
  __int16 v49;
  _BYTE v50[120];
  unint64_t v51;
  char v52;
  __int16 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  char v62;
  uint8_t buf[4];
  const char *v64;
  _BYTE v65[24];
  _BYTE *v66;
  _QWORD v67[3];
  _QWORD *v68;
  _QWORD v69[3];
  _QWORD *v70;
  uint64_t v71;
  _QWORD v72[3];
  _QWORD *v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 96))
  {
    v69[0] = &off_1E95B1FD0;
    v69[1] = a1;
    v70 = v69;
    v71 = a3;
    v67[0] = &off_1E95B2050;
    v67[1] = a1;
    v68 = v67;
    v72[0] = &off_1E95B2050;
    v72[1] = a1;
    v73 = v72;
    if (!*(_BYTE *)(a3 + 8) || (v38 = *(_QWORD *)a3, a4 = sub_1D3D9F290((uint64_t)v69, &v38, a4), v7 = v68, v68 == v67))
    {
      v8 = 4;
      v7 = v67;
    }
    else
    {
      if (!v68)
        goto LABEL_9;
      v8 = 5;
    }
    (*(void (**)(__n128))(*v7 + 8 * v8))(a4);
LABEL_9:
    v9 = v70;
    if (v70 == v69)
    {
      v10 = 4;
      v9 = v69;
    }
    else
    {
      if (!v70)
        goto LABEL_14;
      v10 = 5;
    }
    (*(void (**)(__n128))(*v9 + 8 * v10))(a4);
LABEL_14:
    LOBYTE(v54) = 0;
    v62 = 0;
    v11 = *(unsigned __int8 *)(a1 + 28);
    if (*(_BYTE *)(a1 + 28))
    {
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v62 = 1;
      BYTE4(v60) = 1;
      LODWORD(v60) = 1024;
      WORD4(v60) = 257;
      v12 = *(_BYTE *)(a1 + 29) == 0;
      v54 = 0u;
      v55 = 0u;
    }
    else
    {
      v12 = 1;
      if (*(_BYTE *)(a1 + 29))
      {
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v62 = 1;
        v12 = 0;
      }
    }
    LOBYTE(v38) = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    LOBYTE(v44) = 0;
    v45 = 0;
    LOBYTE(v46) = 0;
    v47 = 0;
    v50[0] = 0;
    v52 = 0;
    v53 = 0;
    v48 = 0;
    v49 = 0;
    v42 = *(_DWORD *)(a1 + 24);
    v43 = 1;
    if (v11)
    {
      v45 = 1;
      v44 = 64;
      v47 = 1;
      v46 = 64;
    }
    if (!v12)
      v49 = 257;
    sub_1D3D98924((uint64_t)v50, &v54);
    LOBYTE(v34[0]) = 0;
    LOBYTE(v35) = 0;
    v36 = *(_QWORD *)(a1 + 32);
    LOBYTE(v37) = *(_BYTE *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 8);
    v14 = *(_QWORD *)(a1 + 16);
    v66 = 0;
    v15 = operator new(0x28uLL);
    *v15 = &off_1E95B20D0;
    v15[1] = &v38;
    v15[2] = v34;
    v15[3] = a1;
    v15[4] = a2;
    v66 = v15;
    v4 = sub_1D3D989EC(v13, v14, (uint64_t)v65);
    v23 = v66;
    if (v66 == v65)
    {
      v24 = 4;
      v23 = v65;
    }
    else
    {
      if (!v66)
        goto LABEL_27;
      v24 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _DWORD, _DWORD, uint64_t, _DWORD, uint64_t, _DWORD, _DWORD))(*v23 + 8 * v24))(v23, v16, v17, v18, v19, v20, v21, v22, v34[0], v34[1], v35, v36, v37, v38, HIDWORD(v38));
LABEL_27:
    if ((v4 & 1) != 0)
    {
      v25 = 0;
      v26 = a1 + 48;
      v27 = a1 + 80;
      while (atomic_load((unint64_t *)(v26 + v25)))
      {
        v25 += 8;
        if (v25 == 32)
          goto LABEL_37;
      }
      v27 = v26 + v25;
LABEL_37:
      v30 = *(unsigned __int8 *)(a1 + 96);
      *(_QWORD *)(a1 + 80) = v26;
      *(_QWORD *)(a1 + 88) = (v27 - v26) >> 3;
      if (!v30)
        *(_BYTE *)(a1 + 96) = 1;
    }
    else
    {
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v29 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "CachedPyramidAllocator";
        _os_log_error_impl(&dword_1D3D6B000, v29, OS_LOG_TYPE_ERROR, "%{public}s: failed to prepare", buf, 0xCu);
      }
    }
    if (v52)
      sub_1D3D8C70C(&v51);
    if (v62)
      sub_1D3D8C70C((unint64_t *)&v61 + 1);
    v31 = v73;
    if (*(_BYTE *)(v71 + 8))
    {
      if (!v73)
        return v4;
      v38 = *(_QWORD *)v71;
      (*(void (**)(void))(*v73 + 48))();
      v31 = v73;
    }
    if (v31 == v72)
    {
      v32 = 4;
      v31 = v72;
    }
    else
    {
      if (!v31)
        return v4;
      v32 = 5;
    }
    (*(void (**)(void))(*v31 + 8 * v32))();
    return v4;
  }
  return 1;
}

void sub_1D3D9F20C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

__n128 sub_1D3D9F290(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

void sub_1D3D9F438()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3D9F44C(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E95B20D0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1D3D9F48C(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95B20D0;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1D3D9F4B4(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  const void *v12;
  NSObject *v13;
  unint64_t *v14;
  unint64_t v15;
  const void *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t *v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  CFDictionaryRef v26;
  _BYTE buf[12];
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  unint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = *a4;
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v8 = *a3;
  *(_BYTE *)(v8 + 8) = 1;
  v9 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v9 + 16) = v6;
  *(_BYTE *)(v9 + 24) = 1;
  if (*(_BYTE *)(*(_QWORD *)(a1 + 8) + 208))
  {
    *(_QWORD *)buf = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("MRC: Cached Pyramid Level #%zu"), v5);
    v10 = (unint64_t *)(*(_QWORD *)(a1 + 8) + 200);
    do
      v11 = __ldaxr((unint64_t *)buf);
    while (__stlxr(0, (unint64_t *)buf));
    do
      v12 = (const void *)__ldaxr(v10);
    while (__stlxr(v11, v10));
    if (v12)
      CFRelease(v12);
    sub_1D3D8C70C((unint64_t *)buf);
  }
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v13 = qword_1EDB89F48;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBufferPool at level #%{public}zu", buf, 0x16u);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    v20 = *(uint64_t **)(a1 + 8);
    v24 = 0;
    v25 = 0;
    sub_1D3DD55CC(&v26, v20, &v25, &v24);
    v21 = atomic_load((unint64_t *)&v26);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    v30 = 2114;
    v31 = v21;
    _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferAttributes: %{public}@", buf, 0x20u);
    sub_1D3D8BAAC((unint64_t *)&v26);
    sub_1D3D8BAAC(&v24);
    sub_1D3D8BAAC(&v25);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    v22 = *(uint64_t **)(a1 + 16);
    v25 = 0;
    sub_1D3DD5AD8(&v26, v22, &v25);
    v23 = atomic_load((unint64_t *)&v26);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    v30 = 2114;
    v31 = v23;
    _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferPoolAttributes: %{public}@", buf, 0x20u);
    sub_1D3D8BAAC((unint64_t *)&v26);
    sub_1D3D8BAAC(&v25);
  }
  sub_1D3DD5E18((CVPixelBufferPoolRef *)buf, *(uint64_t **)(a1 + 16), *(uint64_t **)(a1 + 8), *(_QWORD *)(a1 + 32));
  v14 = (unint64_t *)(v7 + 8 * v5 + 48);
  do
    v15 = __ldaxr((unint64_t *)buf);
  while (__stlxr(0, (unint64_t *)buf));
  do
    v16 = (const void *)__ldaxr(v14);
  while (__stlxr(v15, v14));
  if (v16)
    CFRelease(v16);
  sub_1D3D982CC((unint64_t *)buf);
  v17 = atomic_load(v14);
  if (v17)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v18 = atomic_load(v14);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
      v28 = 2050;
      v29 = v5;
      v30 = 2114;
      v31 = v18;
      _os_log_debug_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, allocated pixel buffer pool: %{public}@", buf, 0x20u);
    }
  }
  else if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
    v28 = 2050;
    v29 = v5;
    _os_log_error_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer pool at level #%{public}zu", buf, 0x16u);
  }
  return v17 != 0;
}

void sub_1D3D9F880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_1D3D8C70C((unint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3D9F8CC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9F904()
{
  return &unk_1E95B2130;
}

void sub_1D3D9F914()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9F928(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B2050;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9F95C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B2050;
  a2[1] = v2;
  return result;
}

__n128 sub_1D3D9F978(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1D3D9FB1C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9FB54()
{
  return &unk_1E95B20B0;
}

void sub_1D3D9FB64()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3D9FB78(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1FD0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3D9FBAC(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1FD0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3D9FBC8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3D9FC00()
{
  return &unk_1E95B2030;
}

uint64_t sub_1D3D9FC0C(uint64_t a1)
{
  uint64_t i;

  for (i = 72; i != 40; i -= 8)
    sub_1D3D982CC((unint64_t *)(a1 + i));
  return a1;
}

void sub_1D3D9FC44(uint64_t a1)
{
  uint64_t i;

  for (i = 72; i != 40; i -= 8)
    sub_1D3D982CC((unint64_t *)(a1 + i));
  JUMPOUT(0x1D8254C54);
}

BOOL sub_1D3D9FC8C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return *(_QWORD *)(a1 + 8) != a2 || *(_QWORD *)(a1 + 16) != a3 || *(_DWORD *)(a1 + 24) != a4;
}

uint64_t *sub_1D3D9FCBC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, unint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  __int16 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;

  v14 = operator new();
  v15 = *(_WORD *)(a1 + 28);
  *(_QWORD *)(v14 + 8) = a2;
  *(_QWORD *)(v14 + 16) = a3;
  *(_DWORD *)(v14 + 24) = a4;
  *(_QWORD *)v14 = &off_1E95B2150;
  *(_WORD *)(v14 + 28) = v15;
  v16 = *(_OWORD *)(a1 + 32);
  *(_BYTE *)(v14 + 96) = 0;
  *(_OWORD *)(v14 + 32) = v16;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_OWORD *)(v14 + 64) = 0u;
  *(_BYTE *)(v14 + 80) = 0;
  v19 = v14;
  sub_1D3D9EBD4(&v20, &v19, a5, a6);
  v17 = v20;
  v20 = 0;
  *a7 = v17;
  sub_1D3D98268(&v20);
  return sub_1D3D98268(&v19);
}

void sub_1D3D9FD90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1D3D98268(&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3D9FDA4@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>, __n128 a5@<Q0>)
{
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  __CFArray *v20;
  const void *v21;
  unint64_t v22;
  NSObject *v23;
  const __CFArray *v24;
  NSObject *v25;
  _QWORD *result;
  uint64_t v27;
  unint64_t v28;
  const __CFArray *v29;
  CFIndex Count;
  const __CFArray *v31;
  CFIndex v32;
  CFIndex i;
  const __CFArray *v34;
  const void *ValueAtIndex;
  __CFString *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  CFArrayRef *v40;
  CFMutableStringRef v41;
  CFMutableArrayRef Mutable;
  _BYTE buf[12];
  __int16 v44;
  unint64_t v45;
  __int16 v46;
  unint64_t v47;
  __int16 v48;
  unint64_t v49;
  _QWORD v50[3];
  _QWORD *v51;
  _QWORD v52[3];
  _QWORD *v53;
  uint64_t v54;
  _QWORD v55[3];
  _QWORD *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v52[0] = &off_1E95B21B8;
  v52[1] = a1;
  v53 = v52;
  v50[0] = &off_1E95B2238;
  v50[1] = a1;
  v51 = v50;
  v54 = a3;
  v55[0] = &off_1E95B2238;
  v56 = v55;
  v55[1] = a1;
  if (!*(_BYTE *)(a3 + 8)
    || (*(_QWORD *)buf = *(_QWORD *)a3,
        a5 = sub_1D3DA044C((uint64_t)v52, (os_signpost_id_t *)buf, a5),
        v8 = v51,
        v51 == v50))
  {
    v9 = 4;
    v8 = v50;
  }
  else
  {
    if (!v51)
      goto LABEL_7;
    v9 = 5;
  }
  (*(void (**)(__n128))(*v8 + 8 * v9))(a5);
LABEL_7:
  v10 = v53;
  if (v53 == v52)
  {
    v11 = 4;
    v10 = v52;
  }
  else
  {
    if (!v53)
      goto LABEL_12;
    v11 = 5;
  }
  (*(void (**)(__n128))(*v10 + 8 * v11))(a5);
LABEL_12:
  if (*(_BYTE *)(a1 + 96))
  {
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 88), MEMORY[0x1E0C9B378]);
    if (atomic_load((unint64_t *)&Mutable))
    {
      v14 = *(_QWORD *)(a1 + 88);
      v40 = a4;
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v15 = qword_1EDB89F48;
      if (v14)
      {
        v16 = 0;
        v17 = 0;
        while (1)
        {
          v18 = (unint64_t *)(*(_QWORD *)(a1 + 80) + v16);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v22 = atomic_load(v18);
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
            v44 = 2050;
            v45 = v17;
            v46 = 2050;
            v47 = v22;
            _os_log_debug_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBuffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
          }
          sub_1D3DD5F9C((CVPixelBufferRef *)&v41, v18, (uint64_t)a2);
          if (!atomic_load((unint64_t *)&v41))
            break;
          v20 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
          v21 = (const void *)atomic_load((unint64_t *)&v41);
          CFArrayAppendValue(v20, v21);
          sub_1D3D74EDC((unint64_t *)&v41);
          ++v17;
          v16 += 8;
          if (v17 >= *(_QWORD *)(a1 + 88))
            goto LABEL_28;
        }
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v39 = atomic_load(v18);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
          v44 = 2050;
          v45 = v17;
          v46 = 2050;
          v47 = v39;
          _os_log_error_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
        }
        *v40 = 0;
        sub_1D3D74EDC((unint64_t *)&v41);
      }
      else
      {
LABEL_28:
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          v28 = atomic_load((unint64_t *)&Mutable);
          v29 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
          Count = CFArrayGetCount(v29);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
          v44 = 2050;
          v45 = v28;
          v46 = 2050;
          v47 = Count;
          _os_log_debug_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
          v41 = CFStringCreateMutable(v12, 0);
          v31 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
          v32 = CFArrayGetCount(v31);
          if (v32 >= 1)
          {
            for (i = 0; i != v32; ++i)
            {
              v34 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
              ValueAtIndex = CFArrayGetValueAtIndex(v34, i);
              if (ValueAtIndex)
                ValueAtIndex = CFRetain(ValueAtIndex);
              *(_QWORD *)buf = ValueAtIndex;
              sub_1D3E2D270((unint64_t *)&v41, (unint64_t *)buf);
              sub_1D3D74EDC((unint64_t *)buf);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                v37 = atomic_load((unint64_t *)&Mutable);
                v38 = atomic_load((unint64_t *)&v41);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
                v44 = 2050;
                v45 = i;
                v46 = 2050;
                v47 = v37;
                v48 = 2114;
                v49 = v38;
                _os_log_debug_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
              }
              v36 = (__CFString *)atomic_load((unint64_t *)&v41);
              CFStringReplaceAll(v36, &stru_1E95B5208);
            }
          }
          sub_1D3D8FA0C((unint64_t *)&v41);
        }
        v24 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
        *v40 = CFArrayCreateCopy(v12, v24);
      }
    }
    else
    {
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v25 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D3D6B000, v25, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
      }
      *(_QWORD *)buf = -2003;
      v41 = CFSTR("CFArrayCreateMutable failed.");
      sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&v41);
      *a4 = 0;
    }
    sub_1D3D74C60((unint64_t *)&Mutable);
  }
  else
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v23 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v23, OS_LOG_TYPE_ERROR, "%{public}s: effective pixel buffer pools are not yet ready", buf, 0xCu);
    }
    Mutable = (CFMutableArrayRef)CFSTR("Effective pixel buffer pools are not yet ready.");
    *(_QWORD *)buf = -2011;
    sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&Mutable);
    *a4 = 0;
  }
  result = v56;
  if (*(_BYTE *)(v54 + 8))
  {
    if (!v56)
      return result;
    *(_QWORD *)buf = *(_QWORD *)v54;
    (*(void (**)(_QWORD *, _BYTE *))(*v56 + 48))(v56, buf);
    result = v56;
  }
  if (result == v55)
  {
    v27 = 4;
    result = v55;
  }
  else
  {
    if (!result)
      return result;
    v27 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v27))();
}

void sub_1D3DA03B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  unint64_t v7;
  va_list va;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, _QWORD);
  sub_1D3D8FA0C((unint64_t *)va);
  sub_1D3D74C60((unint64_t *)va1);
  sub_1D3D87C3C((_QWORD *)(v5 - 136));
  _Unwind_Resume(a1);
}

const char *sub_1D3DA0438()
{
  return "CachedPyramidAllocator";
}

uint64_t sub_1D3DA0444(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96);
}

__n128 sub_1D3DA044C(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

void sub_1D3DA05F4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA0608(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B2238;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DA063C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B2238;
  a2[1] = v2;
  return result;
}

__n128 sub_1D3DA0658(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1D3DA07FC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA0834()
{
  return &unk_1E95B2298;
}

void sub_1D3DA0844()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA0858(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B21B8;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DA088C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B21B8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3DA08A8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA08E0()
{
  return &unk_1E95B2218;
}

void sub_1D3DA08F0()
{
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DA0904@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, int a3@<W3>, unint64_t *a4@<X4>, _QWORD *a5@<X8>)
{
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;

  v10 = operator new();
  *(_QWORD *)(v10 + 8) = a1;
  *(_QWORD *)(v10 + 16) = a2;
  *(_DWORD *)(v10 + 24) = a3;
  *(_QWORD *)v10 = &off_1E95B1DE8;
  v12 = v10;
  sub_1D3D9EA54(&v13, &v12, a4);
  result = v12;
  *a5 = v13;
  if (result)
    JUMPOUT(0x1D8254C54);
  return result;
}

void sub_1D3DA09BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D8254C54](a9, 0x1081C40DCAC275BLL);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1D3DA09E4@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>, __n128 a5@<Q0>)
{
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  const __CFArray *v22;
  CFArrayRef Copy;
  _QWORD *result;
  uint64_t v25;
  unint64_t v26;
  const __CFArray *v27;
  CFIndex Count;
  const __CFArray *v29;
  CFIndex v30;
  CFIndex i;
  const __CFArray *v32;
  const void *ValueAtIndex;
  __CFString *v34;
  unint64_t v35;
  unint64_t v36;
  CFMutableStringRef v37;
  CFMutableArrayRef Mutable;
  _BYTE buf[12];
  __int16 v40;
  unint64_t v41;
  __int16 v42;
  unint64_t v43;
  __int16 v44;
  unint64_t v45;
  _BYTE v46[24];
  _BYTE *v47;
  _QWORD v48[3];
  _QWORD *v49;
  _QWORD v50[3];
  _QWORD *v51;
  uint64_t v52;
  _QWORD v53[3];
  _QWORD *v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v50[0] = &off_1E95B1E50;
  v50[1] = a1;
  v51 = v50;
  v48[0] = &off_1E95B1ED0;
  v48[1] = a1;
  v49 = v48;
  v52 = a3;
  v53[0] = &off_1E95B1ED0;
  v54 = v53;
  v53[1] = a1;
  if (!*(_BYTE *)(a3 + 8)
    || (*(_QWORD *)buf = *(_QWORD *)a3,
        a5 = sub_1D3DA0F64((uint64_t)v50, (os_signpost_id_t *)buf, a5),
        v8 = v49,
        v49 == v48))
  {
    v9 = 4;
    v8 = v48;
  }
  else
  {
    if (!v49)
      goto LABEL_7;
    v9 = 5;
  }
  (*(void (**)(__n128))(*v8 + 8 * v9))(a5);
LABEL_7:
  v10 = v51;
  if (v51 == v50)
  {
    v11 = 4;
    v10 = v50;
  }
  else
  {
    if (!v51)
      goto LABEL_12;
    v11 = 5;
  }
  (*(void (**)(__n128))(*v10 + 8 * v11))(a5);
LABEL_12:
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
  if (!atomic_load((unint64_t *)&Mutable))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v20 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v20, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
    }
    *(_QWORD *)buf = -2003;
    v37 = CFSTR("CFArrayCreateMutable failed.");
    sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&v37);
    goto LABEL_30;
  }
  v14 = *(_QWORD *)(a1 + 8);
  v15 = *(_QWORD *)(a1 + 16);
  v47 = 0;
  v16 = operator new(0x20uLL);
  *v16 = &off_1E95B1F50;
  v16[1] = a1;
  v16[2] = a2;
  v16[3] = &Mutable;
  v47 = v16;
  v17 = sub_1D3D989EC(v14, v15, (uint64_t)v46);
  v18 = v47;
  if (v47 == v46)
  {
    v19 = 4;
    v18 = v46;
  }
  else
  {
    if (!v47)
      goto LABEL_23;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_23:
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v21 = qword_1EDB89F48;
  if ((v17 & 1) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_ERROR, "%{public}s: failed to allocate pyramid", buf, 0xCu);
    }
LABEL_30:
    Copy = 0;
    goto LABEL_31;
  }
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
  {
    v26 = atomic_load((unint64_t *)&Mutable);
    v27 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
    Count = CFArrayGetCount(v27);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
    v40 = 2050;
    v41 = v26;
    v42 = 2050;
    v43 = Count;
    _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
    v37 = CFStringCreateMutable(v12, 0);
    v29 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
    v30 = CFArrayGetCount(v29);
    if (v30 >= 1)
    {
      for (i = 0; i != v30; ++i)
      {
        v32 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
        ValueAtIndex = CFArrayGetValueAtIndex(v32, i);
        if (ValueAtIndex)
          ValueAtIndex = CFRetain(ValueAtIndex);
        *(_QWORD *)buf = ValueAtIndex;
        sub_1D3E2D270((unint64_t *)&v37, (unint64_t *)buf);
        sub_1D3D74EDC((unint64_t *)buf);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          v35 = atomic_load((unint64_t *)&Mutable);
          v36 = atomic_load((unint64_t *)&v37);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "EphemeralPyramidAllocator";
          v40 = 2050;
          v41 = i;
          v42 = 2050;
          v43 = v35;
          v44 = 2114;
          v45 = v36;
          _os_log_debug_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
        }
        v34 = (__CFString *)atomic_load((unint64_t *)&v37);
        CFStringReplaceAll(v34, &stru_1E95B5208);
      }
    }
    sub_1D3D8FA0C((unint64_t *)&v37);
  }
  v22 = (const __CFArray *)atomic_load((unint64_t *)&Mutable);
  Copy = CFArrayCreateCopy(v12, v22);
LABEL_31:
  *a4 = Copy;
  sub_1D3D74C60((unint64_t *)&Mutable);
  result = v54;
  if (*(_BYTE *)(v52 + 8))
  {
    if (!v54)
      return result;
    *(_QWORD *)buf = *(_QWORD *)v52;
    (*(void (**)(_QWORD *, _BYTE *))(*v54 + 48))(v54, buf);
    result = v54;
  }
  if (result == v53)
  {
    v25 = 4;
    result = v53;
  }
  else
  {
    if (!result)
      return result;
    v25 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v25))();
}

void sub_1D3DA0EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  unint64_t v5;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  sub_1D3D8FA0C((unint64_t *)va);
  sub_1D3D74C60((unint64_t *)va1);
  sub_1D3D87C3C((_QWORD *)(v3 - 136));
  _Unwind_Resume(a1);
}

const char *sub_1D3DA0F58()
{
  return "EphemeralPyramidAllocator";
}

__n128 sub_1D3DA0F64(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

void sub_1D3DA110C()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3DA1120(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E95B1F50;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 sub_1D3DA1160(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95B1F50;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1D3DA1188(uint64_t a1, _QWORD *a2, size_t *a3, size_t *a4)
{
  uint64_t v5;
  size_t v6;
  size_t v7;
  uint64_t v8;
  unint64_t v9;
  __CFArray *v10;
  const void *v11;
  NSObject *v12;
  CVPixelBufferRef v14;
  CFStringRef v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = *a3;
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("MRC: Ephemeral Pyramid Level #%zu"), *a2);
  sub_1D3D9AA1C(&v14, v6, v7, *(_DWORD *)(v8 + 24), (unint64_t *)&v15, *(_QWORD *)(a1 + 16));
  v9 = atomic_load((unint64_t *)&v14);
  if (v9)
  {
    v10 = (__CFArray *)atomic_load(*(unint64_t **)(a1 + 24));
    v11 = (const void *)atomic_load((unint64_t *)&v14);
    CFArrayAppendValue(v10, v11);
  }
  else
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v12 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v17 = "EphemeralPyramidAllocator";
      v18 = 2050;
      v19 = v5;
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "%{public}s: failed to create IOSurface-backed pixel buffer at level #%{public}zu", buf, 0x16u);
    }
  }
  sub_1D3D74EDC((unint64_t *)&v14);
  sub_1D3D8C70C((unint64_t *)&v15);
  return v9 != 0;
}

void sub_1D3DA1304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  unint64_t v4;
  va_list va;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  sub_1D3D74EDC((unint64_t *)va);
  sub_1D3D8C70C((unint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DA1328(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA1360()
{
  return &unk_1E95B1FB0;
}

void sub_1D3DA1370()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA1384(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1ED0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DA13B8(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1ED0;
  a2[1] = v2;
  return result;
}

__n128 sub_1D3DA13D4(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  os_signpost_id_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint32x2_t v10;
  uint64_t v11;
  int32x2_t v12;
  int8x8_t v13;
  int8x16_t v14;
  int8x16_t v15;
  uint64x2_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v5 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      v6 = *(_QWORD *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 24);
      v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu)
        v9 = 46;
      v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F)
        v11 = 46;
      else
        v11 = *(_DWORD *)(v4 + 24);
      v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1D3E82010);
      v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      v19 = BYTE4(v17);
      v18 = v17 | v9;
      *(_DWORD *)buf = 134349826;
      v21 = v6;
      v22 = 2050;
      v23 = v7;
      v24 = 1042;
      v25 = 4;
      v26 = 2082;
      v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v5, OS_SIGNPOST_INTERVAL_END, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1D3DA1578(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA15B0()
{
  return &unk_1E95B1F30;
}

void sub_1D3DA15C0()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA15D4(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B1E50;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DA1608(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B1E50;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3DA1624(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA165C()
{
  return &unk_1E95B1EB0;
}

void sub_1D3DA166C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA1680()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B1CF0;
  return result;
}

void sub_1D3DA16A4(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B1CF0;
}

void sub_1D3DA16BC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DA175C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA1794()
{
  return &unk_1E95B1D50;
}

void sub_1D3DA17A4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA17B8()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B1C70;
  return result;
}

void sub_1D3DA17DC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B1C70;
}

uint64_t sub_1D3DA17F4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA182C()
{
  return &unk_1E95B1CD0;
}

void sub_1D3DA183C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA1850()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B1BF0;
  return result;
}

void sub_1D3DA1874(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B1BF0;
}

void sub_1D3DA188C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F48;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F48))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PyramidGenerationSession::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DA192C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA1964()
{
  return &unk_1E95B1C50;
}

void sub_1D3DA1974()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA1988()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B1B70;
  return result;
}

void sub_1D3DA19AC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B1B70;
}

void sub_1D3DA19C4(uint64_t a1, os_signpost_id_t *a2)
{
  sub_1D3D979E0(*a2);
}

uint64_t sub_1D3DA19CC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA1A04()
{
  return &unk_1E95B1BD0;
}

void sub_1D3DA1A14()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA1A28()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2370;
  return result;
}

void sub_1D3DA1A4C(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2370;
}

uint64_t sub_1D3DA1A64(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
  {
    sub_1D3D96F10(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3DA1A98(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE1EEEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA1AD0()
{
  return &unk_1E95B23D0;
}

void sub_1D3DA1AE0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DA1B04(uint64_t a1)
{
  return sub_1D3D9DBCC(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1D3DA1B0C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS1_25PyramidGenerationBehaviorE1EEEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1D3DA1B48(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B2300;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DA1B84(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B2300;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DA1BD0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (*(_BYTE *)(a1 + 200))
    sub_1D3DF4F24((unint64_t *)(a1 + 104));
  if (*(_BYTE *)(a1 + 96))
  {
    v2 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = 0;
    if (v2)
      sub_1D3D9D088(v2);
  }
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B2300;
  *(_QWORD *)(a1 + 8) = 0;
  if (v3)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DA1C44(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (*(_BYTE *)(a1 + 200))
    sub_1D3DF4F24((unint64_t *)(a1 + 104));
  if (*(_BYTE *)(a1 + 96))
  {
    v2 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = 0;
    if (v2)
      sub_1D3D9D088(v2);
  }
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95B2300;
  *(_QWORD *)(a1 + 8) = 0;
  if (v3)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DA1CCC()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3DA1CE0(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E95B1AE0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 sub_1D3DA1D28(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E95B1AE0;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unint64_t *sub_1D3DA1D58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v4;
  NSObject *v5;
  unint64_t *result;
  uint64_t v7;
  unint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGFloat v12;
  NSObject *v14;
  CFTypeRef v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t (***v19)();
  uint64_t v20;
  __CVBuffer *v22;
  size_t Width;
  __CVBuffer *v24;
  size_t Height;
  __CVBuffer *v26;
  uint64_t PixelFormatType;
  unint64_t v28;
  double v29;
  double v30;
  unint64_t v31;
  int v32;
  NSObject *v33;
  _BOOL4 v34;
  CFTypeRef v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  CFTypeRef v47;
  CGFloat v49;
  CGFloat v50;
  CGFloat v51;
  CGFloat v52;
  CGFloat x;
  CGFloat y;
  const void *v55;
  int v56;
  CFTypeRef v57;
  const __CFArray *v58;
  CFIndex Count;
  BOOL v60;
  CFIndex v61;
  unint64_t *v62;
  const __CFArray *v63;
  const void *ValueAtIndex;
  __CVBuffer *v65;
  size_t v66;
  char v67;
  __CVBuffer *v68;
  OSType v69;
  double v70;
  double v71;
  CGFloat v72;
  double v73;
  CGFloat v74;
  double v75;
  CGFloat v76;
  uint64_t v77;
  unint64_t v79;
  unint64_t v80;
  CGFloat v81;
  CGFloat v82;
  CGFloat v83;
  CGFloat v84;
  _QWORD *v85;
  uint64_t v86;
  CFTypeRef *v87;
  uint64_t v88;
  unint64_t v89;
  const void *v90;
  unint64_t v91;
  const void *v92;
  unint64_t *v93;
  const void *v94;
  const void *v95;
  const void *v96;
  const void *v97;
  OpaqueVTPixelTransferSession *v98;
  __CVBuffer *v99;
  __CVBuffer *v100;
  OSStatus v101;
  NSObject *v102;
  unint64_t v103;
  const void *v104;
  const void *v105;
  const __CFString *v106;
  const void *v107;
  const void *v108;
  CGFloat tx;
  uint64_t v110;
  const void *v111;
  _OWORD *v112;
  uint64_t v113;
  unint64_t *v114;
  unint64_t v115;
  const void *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  const __CFString *v126;
  const __CFString *v127;
  const __CFString *domain;
  CFIndex v129;
  const __CFAllocator *allocator;
  const __CFString *v131;
  const __CFString *propertyKey;
  BOOL v133;
  unint64_t *v134;
  uint64_t v135;
  CFTypeRef v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t *v139;
  uint64_t v140;
  char v141;
  const void *v142;
  CGRect v143;
  CFTypeRef v144;
  unint64_t v145;
  unint64_t v146;
  const void *v147;
  const __CFString *propertyValueOut;
  CGAffineTransform buf;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  _QWORD v153[3];
  _QWORD *v154;
  uint64_t (**v155)();
  uint64_t v156;
  uint64_t (***v157)();
  __int128 v158;
  uint64_t v159;
  char *v160;
  _QWORD v161[3];
  _QWORD *v162;
  CFTypeRef v163[3];
  CFTypeRef *v164;
  _BYTE v165[24];
  uint64_t v166;
  CGRect v167;
  CGRect v168;
  CGRect v169;
  CGRect v170;
  CGRect v171;
  CGRect v172;
  CGRect v173;
  CGRect v174;
  CGRect v175;
  CGRect v176;
  CGRect v177;
  CGRect v178;

  v166 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 8))
    v4 = *(_BYTE *)(a3 + 96) == 0;
  else
    v4 = 0;
  if (!v4)
  {
    sub_1D3D74C98(*(unint64_t **)(a1 + 8), a3);
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v5 = qword_1EDB89F48;
    result = (unint64_t *)os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v7 = *(_QWORD *)(a1 + 8);
    if (*(_BYTE *)(v7 + 96))
    {
      sub_1D3DF4F6C((uint64_t)&buf, v7);
    }
    else
    {
      buf.a = NAN;
      memset(&buf.b, 0, 40);
      BYTE4(buf.d) = 0;
      v150 = 0u;
      v151 = 0u;
      BYTE4(v150) = 0;
      v152 = 0u;
    }
    sub_1D3DF53CC((CFErrorRef *)v163, (uint64_t)&buf);
    v45 = atomic_load((unint64_t *)v163);
    LODWORD(v158) = 138543362;
    *(_QWORD *)((char *)&v158 + 4) = v45;
    v46 = "Cannot retrieve or instantiate pyramid generation session: %{public}@";
LABEL_190:
    _os_log_error_impl(&dword_1D3D6B000, v5, OS_LOG_TYPE_ERROR, v46, (uint8_t *)&v158, 0xCu);
    sub_1D3D7448C((unint64_t *)v163);
    return sub_1D3DF4F24((unint64_t *)&buf);
  }
  v8 = *(unint64_t ***)a2;
  v9 = *(_QWORD *)(a1 + 24);
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(_QWORD *)(a1 + 8);
  v12 = *(double *)(a1 + 40);
  if (atomic_load((unint64_t *)(v9 + 48)))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v14 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v14, OS_LOG_TYPE_DEBUG, "Sample has existing pyramid, skipping...", (uint8_t *)&buf, 2u);
    }
    v15 = (CFTypeRef)atomic_load((unint64_t *)(v9 + 48));
    if (v15)
      v15 = CFRetain(v15);
    v136 = v15;
    goto LABEL_175;
  }
  v155 = &off_1E95B19E0;
  v156 = v9;
  v157 = &v155;
  *(CGFloat *)&v158 = v12;
  v153[0] = &off_1E95B1A60;
  v153[1] = v9;
  v16 = v153;
  v154 = v153;
  v17 = (_QWORD *)&v158 + 1;
  *((_QWORD *)&v158 + 1) = &off_1E95B1A60;
  v159 = v9;
  v160 = (char *)&v158 + 8;
  v135 = v11;
  if (*(_BYTE *)(*(_QWORD *)&v12 + 8))
  {
    sub_1D3D94B0C((uint64_t)&v156, **(_QWORD **)&v12);
    v16 = v154;
    if (v154 == v153)
    {
      v18 = 4;
      v16 = v153;
    }
    else
    {
      if (!v154)
        goto LABEL_25;
      v18 = 5;
    }
  }
  else
  {
    v18 = 4;
  }
  (*(void (**)(void))(*v16 + 8 * v18))();
LABEL_25:
  v19 = v157;
  if (v157 == &v155)
  {
    v20 = 4;
    v19 = &v155;
  }
  else
  {
    if (!v157)
      goto LABEL_30;
    v20 = 5;
  }
  (*v19)[v20]();
LABEL_30:
  v139 = *(unint64_t **)v9;
  v140 = v135;
  v141 = sub_1D3DE79DC(v139, v135);
  if ((v141 & 1) == 0)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v40 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      v56 = *(_DWORD *)(v135 + 24);
      LODWORD(buf.a) = 67240192;
      HIDWORD(buf.a) = v56;
      _os_log_error_impl(&dword_1D3D6B000, v40, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&buf, 8u);
    }
    v136 = 0;
    goto LABEL_167;
  }
  sub_1D3D94C2C(&v138, *(unint64_t **)v9, (uint64_t)&v139, v135);
  if (!atomic_load(&v138))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v41 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v41, OS_LOG_TYPE_ERROR, "Failed to get or create shallow Yp8 pixel buffer.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_57;
  }
  v22 = (__CVBuffer *)atomic_load(&v138);
  Width = CVPixelBufferGetWidth(v22);
  v24 = (__CVBuffer *)atomic_load(&v138);
  Height = CVPixelBufferGetHeight(v24);
  v26 = (__CVBuffer *)atomic_load(&v138);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v26);
  v28 = (*v8)[2];
  if (!v28)
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v17 = (_QWORD *)&v158 + 1;
    v42 = qword_1EDB89F48;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v42, OS_LOG_TYPE_ERROR, "Invalid pyramid allocator", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    v163[0] = CFSTR("Invalid pyramid allocator.");
    sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)&buf, v163);
LABEL_57:
    v136 = 0;
    goto LABEL_165;
  }
  v29 = (double)Width;
  v30 = (double)Height;
  v31 = (unint64_t)(double)Width;
  v32 = (*(uint64_t (**)(unint64_t, unint64_t, unint64_t, uint64_t))(*(_QWORD *)v28 + 16))(v28, v31, (unint64_t)v30, PixelFormatType);
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v33 = qword_1EDB89F48;
  v34 = os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG);
  if (v32)
  {
    if (v34)
    {
      v120 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
      v121 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(_QWORD *)((char *)&buf.a + 4) = v120;
      WORD2(buf.b) = 2050;
      *(_QWORD *)((char *)&buf.b + 6) = v121;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Resetting pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
    }
    (*(void (**)(CFTypeRef *__return_ptr, unint64_t, unint64_t, unint64_t, uint64_t, uint64_t, CGFloat))(*(_QWORD *)(*v8)[2] + 24))(v163, (*v8)[2], v31, (unint64_t)v30, PixelFormatType, v135, COERCE_CGFLOAT(*(_QWORD *)&v12));
    v35 = v163[0];
    v17 = (_QWORD *)&v158 + 1;
    if (v163[0])
    {
      v36 = *v8;
      v163[0] = 0;
      v37 = v36[2];
      v36[2] = (unint64_t)v35;
      if (v37)
        (*(void (**)(unint64_t))(*(_QWORD *)v37 + 8))(v37);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        v38 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
        v39 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(_QWORD *)((char *)&buf.a + 4) = v38;
        WORD2(buf.b) = 2050;
        *(_QWORD *)((char *)&buf.b + 6) = v39;
        _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "New pyramid allocator: <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        v124 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
        v125 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(_QWORD *)((char *)&buf.a + 4) = v124;
        WORD2(buf.b) = 2050;
        *(_QWORD *)((char *)&buf.b + 6) = v125;
        _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Unable to reset pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
      v136 = 0;
    }
    v47 = v163[0];
    v163[0] = 0;
    if (v47)
      (*(void (**)(CFTypeRef))(*(_QWORD *)v47 + 8))(v47);
    if (!v35)
      goto LABEL_165;
  }
  else
  {
    v17 = (_QWORD *)&v158 + 1;
    if (v34)
    {
      v43 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
      v44 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(_QWORD *)((char *)&buf.a + 4) = v43;
      WORD2(buf.b) = 2050;
      *(_QWORD *)((char *)&buf.b + 6) = v44;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p> can be reused", (uint8_t *)&buf, 0x16u);
    }
  }
  (*(void (**)(unint64_t *__return_ptr, unint64_t, uint64_t, CGFloat))(*(_QWORD *)(*v8)[2] + 32))(&v137, (*v8)[2], v135, COERCE_CGFLOAT(*(_QWORD *)&v12));
  if (!atomic_load(&v137))
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      v122 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*v8)[2] + 40))((*v8)[2]);
      v123 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(_QWORD *)((char *)&buf.a + 4) = v122;
      WORD2(buf.b) = 2050;
      *(_QWORD *)((char *)&buf.b + 6) = v123;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p>: unable to allocate pyramid", (uint8_t *)&buf, 0x16u);
    }
    goto LABEL_73;
  }
  v49 = *(double *)(v9 + 16);
  v50 = *(double *)(v9 + 24);
  v51 = *(double *)(v9 + 32);
  v52 = *(double *)(v9 + 40);
  v167.origin.x = v49;
  v167.origin.y = v50;
  v167.size.width = v51;
  v167.size.height = v52;
  if (CGRectIsNull(v167))
    goto LABEL_70;
  v168.origin.x = v49;
  v168.origin.y = v50;
  v168.size.width = v51;
  v168.size.height = v52;
  if (CGRectIsInfinite(v168))
  {
    x = *MEMORY[0x1E0C9D538];
    y = *(double *)(MEMORY[0x1E0C9D538] + 8);
  }
  else
  {
    v178.origin.x = 0.0;
    v178.origin.y = 0.0;
    v169.origin.x = v49;
    v169.origin.y = v50;
    v169.size.width = v51;
    v169.size.height = v52;
    v178.size.width = v29;
    v178.size.height = v30;
    v170 = CGRectIntersection(v169, v178);
    x = v170.origin.x;
    y = v170.origin.y;
    v29 = v170.size.width;
    v30 = v170.size.height;
    if (CGRectIsNull(v170))
    {
LABEL_70:
      x = *MEMORY[0x1E0C9D648];
      y = *(double *)(MEMORY[0x1E0C9D648] + 8);
      v29 = *(double *)(MEMORY[0x1E0C9D648] + 16);
      v30 = *(double *)(MEMORY[0x1E0C9D648] + 24);
    }
  }
  if (*(_BYTE *)(v10 + 32))
  {
    if (!CGRectIsNull(*(CGRect *)v10) && !CGRectIsInfinite(*(CGRect *)v10))
    {
      v171.origin.x = x;
      v171.origin.y = y;
      v171.size.width = v29;
      v171.size.height = v30;
      v172 = CGRectIntersection(v171, *(CGRect *)v10);
      x = v172.origin.x;
      y = v172.origin.y;
      v29 = v172.size.width;
      v30 = v172.size.height;
      if (CGRectIsNull(v172))
      {
        x = *MEMORY[0x1E0C9D648];
        y = *(double *)(MEMORY[0x1E0C9D648] + 8);
        v29 = *(double *)(MEMORY[0x1E0C9D648] + 16);
        v30 = *(double *)(MEMORY[0x1E0C9D648] + 24);
      }
    }
  }
  v173.origin.x = x;
  v173.origin.y = y;
  v173.size.width = v29;
  v173.size.height = v30;
  if (CGRectIsEmpty(v173))
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v33, OS_LOG_TYPE_DEBUG, "Empty effective region-of-interest.", (uint8_t *)&buf, 2u);
    }
    v55 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
    goto LABEL_164;
  }
  v134 = *v8;
  v57 = (CFTypeRef)atomic_load(&v138);
  if (v57)
    v57 = CFRetain(v57);
  v144 = v57;
  v143.origin.x = x;
  v143.origin.y = y;
  v143.size.width = v29;
  v143.size.height = v30;
  v58 = (const __CFArray *)atomic_load(&v137);
  Count = CFArrayGetCount(v58);
  if (Count <= 0)
  {
LABEL_148:
    sub_1D3D74EDC((unint64_t *)&v144);
    v17 = (_QWORD *)&v158 + 1;
    goto LABEL_162;
  }
  v60 = 0;
  v61 = 0;
  v62 = (unint64_t *)(v135 + 64);
  propertyKey = (const __CFString *)*MEMORY[0x1E0CED850];
  v131 = (const __CFString *)*MEMORY[0x1E0CED7D0];
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v127 = (const __CFString *)*MEMORY[0x1E0CED830];
  domain = (const __CFString *)*MEMORY[0x1E0C9AFC8];
  v126 = (const __CFString *)*MEMORY[0x1E0CED828];
  v129 = Count;
  while (1)
  {
    v133 = v60;
    v63 = (const __CFArray *)atomic_load(&v137);
    ValueAtIndex = CFArrayGetValueAtIndex(v63, v61);
    if (ValueAtIndex)
      ValueAtIndex = CFRetain(ValueAtIndex);
    v142 = ValueAtIndex;
    v65 = (__CVBuffer *)atomic_load((unint64_t *)&v142);
    v66 = CVPixelBufferGetWidth(v65);
    v67 = sub_1D3D956B0((unint64_t *)&v142);
    v68 = (__CVBuffer *)atomic_load((unint64_t *)&v142);
    v69 = CVPixelBufferGetPixelFormatType(v68);
    v70 = sub_1D3D95778(&v143, v66, v67, v69);
    v72 = v71;
    v74 = v73;
    v76 = v75;
    CGAffineTransformMakeScale(&buf, 2.0, 2.0);
    v174.origin.x = v70;
    v174.origin.y = v72;
    v174.size.width = v74;
    v174.size.height = v76;
    v175 = CGRectApplyAffineTransform(v174, &buf);
    v143 = v175;
    if (!atomic_load(v134))
      break;
    v79 = atomic_load((unint64_t *)&v144);
    if (!v79 || (v80 = atomic_load((unint64_t *)&v142)) == 0)
    {
      if (qword_1EDB89F40 != -1)
        dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
      v102 = qword_1EDB89F48;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.a) = 0;
        _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", (uint8_t *)&buf, 2u);
      }
      buf.a = NAN;
      *(_QWORD *)v165 = CFSTR("Invalid source and/or destination buffer.");
      sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)&buf, (CFTypeRef *)v165);
      goto LABEL_159;
    }
    v81 = v175.origin.x;
    v82 = v175.origin.y;
    v83 = v175.size.width;
    v84 = v175.size.height;
    v164 = v163;
    v161[0] = &off_1E95B0E40;
    v162 = v161;
    v163[0] = &off_1E95B0DC0;
    *(_QWORD *)&buf.tx = &buf.b;
    buf.a = v12;
    *(_QWORD *)&buf.b = &off_1E95B0E40;
    if (!*(_BYTE *)(*(_QWORD *)&v12 + 8)
      || (*(_QWORD *)v165 = **(_QWORD **)&v12, sub_1D3D9D114(v77, (os_signpost_id_t *)v165), v85 = v162, v162 == v161))
    {
      v85 = v161;
      v86 = 4;
    }
    else
    {
      if (!v162)
        goto LABEL_101;
      v86 = 5;
    }
    (*(void (**)(void))(*v85 + 8 * v86))();
LABEL_101:
    v87 = v164;
    if (v164 == v163)
    {
      v87 = v163;
      v88 = 4;
      goto LABEL_105;
    }
    if (v164)
    {
      v88 = 5;
LABEL_105:
      (*((void (**)(void))*v87 + v88))();
    }
    v146 = 0;
    v176.origin.x = v81;
    v176.origin.y = v82;
    v176.size.width = v83;
    v176.size.height = v84;
    *(_QWORD *)v165 = CGRectCreateDictionaryRepresentation(v176);
    do
      v89 = __ldaxr((unint64_t *)v165);
    while (__stlxr(0, (unint64_t *)v165));
    do
      v90 = (const void *)__ldaxr(&v146);
    while (__stlxr(v89, &v146));
    if (v90)
      CFRelease(v90);
    sub_1D3D8BAAC((unint64_t *)v165);
    v145 = 0;
    v177.origin.x = v70;
    v177.origin.y = v72;
    v177.size.width = v74;
    v177.size.height = v76;
    *(_QWORD *)v165 = CGRectCreateDictionaryRepresentation(v177);
    do
      v91 = __ldaxr((unint64_t *)v165);
    while (__stlxr(0, (unint64_t *)v165));
    do
      v92 = (const void *)__ldaxr(&v145);
    while (__stlxr(v91, &v145));
    if (v92)
      CFRelease(v92);
    sub_1D3D8BAAC((unint64_t *)v165);
    v93 = v134;
    v94 = (const void *)atomic_load(v134);
    v95 = (const void *)atomic_load(&v146);
    VTSessionSetProperty(v94, propertyKey, v95);
    v96 = (const void *)atomic_load(v93);
    v97 = (const void *)atomic_load(&v145);
    VTSessionSetProperty(v96, v131, v97);
    v98 = (OpaqueVTPixelTransferSession *)atomic_load(v93);
    v99 = (__CVBuffer *)atomic_load((unint64_t *)&v144);
    v100 = (__CVBuffer *)atomic_load((unint64_t *)&v142);
    v101 = VTPixelTransferSessionTransferImage(v98, v99, v100);
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v102 = qword_1EDB89F48;
    if (v101)
    {
      if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v165 = 67240192;
        *(_DWORD *)&v165[4] = v101;
        _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionTransferImage failed: %{public}d", v165, 8u);
      }
      *(_QWORD *)v165 = -2004;
      propertyValueOut = CFSTR("VTPixelTransferSessionTransferImage failed.");
      sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)v165, (CFTypeRef *)&propertyValueOut);
      *(_QWORD *)v165 = CFErrorCreate(allocator, domain, v101, 0);
      do
        v103 = __ldaxr((unint64_t *)v165);
      while (__stlxr(0, (unint64_t *)v165));
      do
        v104 = (const void *)__ldaxr(v62);
      while (__stlxr(v103, v62));
      if (v104)
        CFRelease(v104);
      sub_1D3D7448C((unint64_t *)v165);
    }
    else if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_DEBUG))
    {
      propertyValueOut = 0;
      v105 = (const void *)atomic_load(v134);
      if (!VTSessionCopyProperty(v105, v127, allocator, &propertyValueOut))
      {
        v106 = propertyValueOut;
        if (propertyValueOut)
        {
          if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v165 = 138543362;
            *(_QWORD *)&v165[4] = v106;
            _os_log_debug_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentConversionType: %{public}@", v165, 0xCu);
            v106 = propertyValueOut;
          }
          CFRelease(v106);
        }
      }
      v147 = 0;
      v107 = (const void *)atomic_load(v134);
      if (!VTSessionCopyProperty(v107, v126, allocator, &v147))
      {
        v108 = v147;
        if (v147)
        {
          if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v165 = 138543362;
            *(_QWORD *)&v165[4] = v108;
            _os_log_debug_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentChainDescription: %{public}@", v165, 0xCu);
            v108 = v147;
          }
          CFRelease(v108);
        }
      }
    }
    sub_1D3D8BAAC(&v145);
    sub_1D3D8BAAC(&v146);
    tx = buf.tx;
    if (*(_BYTE *)(*(_QWORD *)&buf.a + 8))
    {
      if (!*(_QWORD *)&buf.tx)
        goto LABEL_146;
      *(_QWORD *)v165 = **(_QWORD **)&buf.a;
      (*(void (**)(void))(**(_QWORD **)&buf.tx + 48))();
      tx = buf.tx;
    }
    if (*(CGAffineTransform **)&tx == (CGAffineTransform *)&buf.b)
    {
      tx = COERCE_DOUBLE((CGAffineTransform *)&buf.b);
      v110 = 4;
    }
    else
    {
      if (tx == 0.0)
        goto LABEL_146;
      v110 = 5;
    }
    (*(void (**)(void))(**(_QWORD **)&tx + 8 * v110))();
LABEL_146:
    if (v101)
      goto LABEL_159;
    v111 = (const void *)atomic_load((unint64_t *)&v142);
    sub_1D3D95C6C((unint64_t *)&v144, v111);
    v143.origin.x = v70;
    v143.origin.y = v72;
    v143.size.width = v74;
    v143.size.height = v76;
    sub_1D3D74EDC((unint64_t *)&v142);
    v60 = ++v61 >= v129;
    if (v61 == v129)
      goto LABEL_148;
  }
  if (qword_1EDB89F40 != -1)
    dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
  v102 = qword_1EDB89F48;
  if (os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.a) = 0;
    _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "Invalid pixel transfer session.", (uint8_t *)&buf, 2u);
  }
  buf.a = NAN;
  *(_QWORD *)v165 = CFSTR("Invalid pixel transfer session.");
  sub_1D3D73E0C((unint64_t *)v135, (uint64_t *)&buf, (CFTypeRef *)v165);
LABEL_159:
  if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.a) = 134349056;
    *(_QWORD *)((char *)&buf.a + 4) = v61;
    _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "Failed to transfer image at level #%{public}ld.", (uint8_t *)&buf, 0xCu);
  }
  sub_1D3D74EDC((unint64_t *)&v142);
  sub_1D3D74EDC((unint64_t *)&v144);
  v17 = (_QWORD *)&v158 + 1;
  if (!v133)
  {
LABEL_73:
    v55 = 0;
    goto LABEL_164;
  }
LABEL_162:
  v55 = (const void *)atomic_load(&v137);
  if (v55)
    v55 = CFRetain(v55);
LABEL_164:
  v136 = v55;
  sub_1D3D74138(&v137);
LABEL_165:
  sub_1D3D74EDC(&v138);
  if (v141)
    sub_1D3DE793C(v139, v140);
LABEL_167:
  v112 = v160;
  if (!*(_BYTE *)(v158 + 8))
  {
LABEL_170:
    if (v112 == (__int128 *)((char *)&v158 + 8))
    {
      v113 = 4;
    }
    else
    {
      if (!v112)
        goto LABEL_175;
      v113 = 5;
      v17 = v112;
    }
    (*(void (**)(_QWORD *))(*v17 + 8 * v113))(v17);
    goto LABEL_175;
  }
  if (v160)
  {
    buf.a = *(CGFloat *)v158;
    (*(void (**)(void))(*(_QWORD *)v160 + 48))();
    v112 = v160;
    goto LABEL_170;
  }
LABEL_175:
  v114 = *(unint64_t **)(a1 + 16);
  do
    v115 = __ldaxr((unint64_t *)&v136);
  while (__stlxr(0, (unint64_t *)&v136));
  do
    v116 = (const void *)__ldaxr(v114);
  while (__stlxr(v115, v114));
  if (v116)
    CFRelease(v116);
  result = sub_1D3D74138((unint64_t *)&v136);
  v117 = atomic_load(*(unint64_t **)(a1 + 16));
  if (!v117 || *(_BYTE *)(*(_QWORD *)(a1 + 8) + 96))
  {
    if (qword_1EDB89F40 != -1)
      dispatch_once(&qword_1EDB89F40, &unk_1E95B3488);
    v5 = qword_1EDB89F48;
    result = (unint64_t *)os_log_type_enabled((os_log_t)qword_1EDB89F48, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      v118 = *(_QWORD *)(a1 + 8);
      if (*(_BYTE *)(v118 + 96))
      {
        sub_1D3DF4F6C((uint64_t)&buf, v118);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        BYTE4(buf.d) = 0;
        v150 = 0u;
        v151 = 0u;
        BYTE4(v150) = 0;
        v152 = 0u;
      }
      sub_1D3DF53CC((CFErrorRef *)v163, (uint64_t)&buf);
      v119 = atomic_load((unint64_t *)v163);
      LODWORD(v158) = 138543362;
      *(_QWORD *)((char *)&v158 + 4) = v119;
      v46 = "Cannot generate pyramid: %{public}@";
      goto LABEL_190;
    }
  }
  return result;
}

void sub_1D3DA2FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,_QWORD *a23,uint64_t a24,uint64_t a25,unint64_t a26,unint64_t a27,unint64_t *a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t *a61,uint64_t a62,uint64_t a63)
{
  _QWORD *a65;
  _QWORD *v66;
  uint64_t v67;

  sub_1D3D74138(&a26);
  sub_1D3D74EDC(&a27);
  if (a30)
    sub_1D3DE793C(a28, a29);
  v66 = a65;
  if (*((_BYTE *)a61 + 8))
  {
    if (!a65)
      goto LABEL_11;
    a32 = *a61;
    (*(void (**)(void))(*a65 + 48))();
    v66 = a65;
  }
  if (v66 == a23)
  {
    v67 = 4;
  }
  else
  {
    if (!v66)
      goto LABEL_11;
    v67 = 5;
    a23 = v66;
  }
  (*(void (**)(void))(*a23 + 8 * v67))();
LABEL_11:
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DA32A0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE26generatePyramidWithContextERNS_7ContextERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS9_INS_5ErrorEEERKNS9_IyEEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA32D8()
{
  return &unk_1E95B1B50;
}

unint64_t *sub_1D3DA32E4@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  unint64_t *result;
  uint64_t v4;
  unint64_t v5[12];
  char v6;
  _QWORD v7[3];
  unint64_t *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  LOBYTE(v5[0]) = 0;
  v6 = 0;
  v7[0] = &off_1E95B2470;
  v7[1] = v5;
  v8 = v7;
  sub_1D3D9D608(a1, v7);
  result = v8;
  if (v8 == v7)
  {
    v4 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      goto LABEL_6;
    v4 = 5;
  }
  result = (unint64_t *)(*(uint64_t (**)(void))(*result + 8 * v4))();
LABEL_6:
  if (v6)
  {
    result = sub_1D3DF53CC(a2, (uint64_t)v5);
    if (v6)
      return sub_1D3DF4F24(v5);
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1D3DA33B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21)
    sub_1D3DF4F24((unint64_t *)&a9);
  _Unwind_Resume(exception_object);
}

void sub_1D3DA3408()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA341C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B2470;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DA3450(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B2470;
  a2[1] = v2;
  return result;
}

unint64_t *sub_1D3DA346C(unint64_t *result, uint64_t a2, uint64_t a3)
{
  if (!*(_BYTE *)(a2 + 8))
    return sub_1D3D74C98((unint64_t *)result[1], a3);
  return result;
}

uint64_t sub_1D3DA3484(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE19preflightForContextERNS_7ContextEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA34BC()
{
  return &unk_1E95B24D0;
}

uint64_t sub_1D3DA34C8(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned int v9;
  _QWORD *exception;

  if (a2 >= 0x21)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "cannot read <1 or >32 bits");
    goto LABEL_19;
  }
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 16);
  v5 = *(_DWORD *)(a1 + 40);
  v4 = *(_DWORD *)(a1 + 44);
  if (8 * (*(_DWORD *)(v2 + 24) - (int)v3 - v5) - v4 < a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "reading more bits than are available");
LABEL_19:
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  if (v4 < 1)
  {
    v7 = 0;
  }
  else
  {
    if (8 - v4 >= a2)
      v6 = a2;
    else
      v6 = 8 - v4;
    v7 = ((0xFFu >> (8 - v6) << (8 - v4 - v6)) & *(unsigned __int8 *)(v3 + v5)) >> (8 - v4 - v6);
    a2 -= v6;
    v4 += v6;
    *(_DWORD *)(a1 + 44) = v4;
    if (v4 == 8)
    {
      v4 = 0;
      *(_QWORD *)(a1 + 40) = ++v5;
    }
  }
  if (a2 >= 1)
  {
    if (a2 < 8)
      goto LABEL_15;
    v8 = (unsigned __int8 *)(v3 + v5);
    do
    {
      v9 = *v8++;
      v7 = v9 | ((_DWORD)v7 << 8);
      *(_DWORD *)(a1 + 40) = ++v5;
      a2 -= 8;
    }
    while (a2 > 7);
    if (a2)
    {
LABEL_15:
      v7 = (((-1 << (8 - a2)) & *(unsigned __int8 *)(v3 + v5)) >> (8 - a2)) | ((_DWORD)v7 << a2);
      *(_DWORD *)(a1 + 44) = v4 + a2;
    }
  }
  return v7;
}

void sub_1D3DA3624(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1D3DA3640()
{
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DA3654(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, _QWORD **a4@<X5>, uint64_t a5@<X8>)
{
  _QWORD *v9;
  _QWORD *v11;
  _BYTE *v12;
  _BYTE *v13;
  unint64_t v14;
  _BYTE *v15;
  _BYTE *v16;
  int v17;
  _BYTE *v18;
  char *v19;
  int v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  int v27;
  int v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  int v39;
  void *v40;
  int v41;
  uint64_t i;
  unsigned int v43;
  _DWORD *v44;
  unint64_t v45;
  int v46;
  int v47;
  _DWORD *v48;
  int v49;
  int v50;
  char *v51;
  int *v52;
  int *v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  int v59;
  void *v60;
  int v61;
  int v62;
  uint64_t j;
  int v64;
  int *v65;
  char *v66;
  int v67;
  uint64_t k;
  unsigned int v69;
  uint64_t v70;
  char v71;
  char v72;
  uint64_t v73;
  float v74;
  float v75;
  float v76;
  int *v77;
  char *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  float v82;
  std::string::size_type v83;
  int v84;
  std::string *p_str;
  void *v86;
  std::string::size_type size;
  std::string::size_type v88;
  void *v89;
  int v90;
  unsigned int v91;
  int *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  std::string *v100;
  int v101;
  std::string::size_type v102;
  const void *v103;
  size_t v104;
  int v106;
  int v107;
  unsigned int v108;
  uint64_t v109;
  int *v110;
  int v111;
  uint64_t v112;
  _QWORD *v113;
  unsigned int v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unsigned int v118;
  std::string v119;
  std::string __str;
  void *v121;
  char *v122;
  unint64_t v123;
  uint64_t v124;
  void *__p;
  char *v126;
  unint64_t v127;
  _QWORD v128[2];
  float v129[4];
  uint64_t v130;

  v130 = *MEMORY[0x1E0C80C00];
  v9 = *a4;
  if (!*a4)
  {
    v9 = (_QWORD *)operator new();
    *v9 = &off_1E95AF170;
    v9[1] = 0;
    v9[2] = 0;
    v9[3] = 0;
    v11 = *a4;
    *a4 = v9;
    if (v11)
    {
      (*(void (**)(_QWORD *))(*v11 + 8))(v11);
      v9 = *a4;
    }
  }
  __p = 0;
  v126 = 0;
  v127 = 0;
  sub_1D3D92760(&__p, 0x50uLL);
  v13 = *(_BYTE **)a3;
  v12 = *(_BYTE **)(a3 + 8);
  if (v12 == *(_BYTE **)a3)
    goto LABEL_61;
  while (*v13)
  {
    if (++v13 == v12)
    {
      v13 = *(_BYTE **)(a3 + 8);
      break;
    }
  }
  if (v13 == v12)
    goto LABEL_61;
  v115 = a1;
  v113 = v9;
  v114 = a2;
  v14 = v127;
  v15 = __p;
  v16 = v13;
  while (1)
  {
    v17 = *v13 == 0;
    v18 = &v13[v12 - v16];
    while (*v13 != v17)
    {
      if (++v13 == v12)
      {
        v13 = v18;
        break;
      }
    }
    v19 = v126;
    if (v13 == v12)
      break;
    v20 = (_DWORD)v13 - (_DWORD)v16;
    if ((unint64_t)v126 >= v14)
    {
      v22 = (v126 - v15) >> 2;
      v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 62)
        goto LABEL_165;
      if ((uint64_t)(v14 - (_QWORD)v15) >> 1 > v23)
        v23 = (uint64_t)(v14 - (_QWORD)v15) >> 1;
      if (v14 - (unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
        v24 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v24 = v23;
      if (v24)
        v24 = (unint64_t)sub_1D3D82278(v24);
      else
        v25 = 0;
      v26 = (char *)(v24 + 4 * v22);
      *(_DWORD *)v26 = v20;
      v21 = v26 + 4;
      while (v19 != v15)
      {
        v27 = *((_DWORD *)v19 - 1);
        v19 -= 4;
        *((_DWORD *)v26 - 1) = v27;
        v26 -= 4;
      }
      v14 = v24 + 4 * v25;
      __p = v26;
      v127 = v14;
      if (v15)
        operator delete(v15);
      v15 = v26;
    }
    else
    {
      *(_DWORD *)v126 = v20;
      v21 = v19 + 4;
    }
    v126 = v21;
    v12 = *(_BYTE **)(a3 + 8);
    v16 = v13;
    if (v12 == v13)
      goto LABEL_35;
  }
  v21 = v126;
LABEL_35:
  v28 = (_DWORD)v13 - (_DWORD)v16;
  if ((unint64_t)v21 >= v14)
  {
    v31 = (v21 - v15) >> 2;
    v32 = v31 + 1;
    if ((unint64_t)(v31 + 1) >> 62)
LABEL_165:
      sub_1D3D6D4F8();
    if ((uint64_t)(v14 - (_QWORD)v15) >> 1 > v32)
      v32 = (uint64_t)(v14 - (_QWORD)v15) >> 1;
    if (v14 - (unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
      v33 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v33 = v32;
    if (v33)
      v33 = (unint64_t)sub_1D3D82278(v33);
    else
      v34 = 0;
    v29 = (_DWORD *)(v33 + 4 * v31);
    *v29 = v28;
    v30 = (uint64_t)(v29 + 1);
    while (v21 != v15)
    {
      v35 = *((_DWORD *)v21 - 1);
      v21 -= 4;
      *--v29 = v35;
    }
    __p = v29;
    v127 = v33 + 4 * v34;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *(_DWORD *)v21 = v28;
    v29 = __p;
    v30 = (uint64_t)(v21 + 4);
  }
  v126 = (char *)v30;
  v124 = 0;
  if ((int)((unint64_t)(v30 - (_QWORD)v29) >> 2) < 2)
    goto LABEL_61;
  v36 = 1;
  v37 = v29;
  v38 = 1;
  while (1)
  {
    v39 = sub_1D3DA46D8((uint64_t)v29, v30, v38, (float *)&v124 + 1);
    if ((v39 & 0x80000000) == 0)
    {
      v40 = memchr("ABCD", a0123456789Abcd[v39], 5uLL);
      if (v40)
      {
        if ((((_DWORD)v40 - "ABCD") & 0x80000000) == 0)
        {
          v41 = 0;
          for (i = 1; i != 8; ++i)
            v41 += v37[i];
          if (v38 == 1)
            goto LABEL_66;
          if (v29[v38 - 1] >= v41 / 2)
            break;
        }
      }
    }
    v38 += 2;
    v37 += 2;
    if (v38 >= (int)((v30 - (uint64_t)v29) >> 2))
      goto LABEL_61;
  }
  v36 = v38;
  if ((v38 & 0x80000000) != 0)
  {
LABEL_61:
    *(_DWORD *)a5 = 1;
    *(_QWORD *)(a5 + 104) = 0;
    *(_QWORD *)(a5 + 112) = 0;
    *(_OWORD *)(a5 + 4) = 0u;
    *(_OWORD *)(a5 + 20) = 0u;
    *(_OWORD *)(a5 + 36) = 0u;
    *(_OWORD *)(a5 + 52) = 0u;
    *(_OWORD *)(a5 + 68) = 0u;
    *(_QWORD *)(a5 + 84) = 0;
    *(_QWORD *)(a5 + 96) = a5 + 104;
    *(_BYTE *)(a5 + 120) = 0;
    *(_DWORD *)(a5 + 124) = 0;
    *(_DWORD *)(a5 + 128) = 0;
    goto LABEL_62;
  }
LABEL_66:
  v112 = v36;
  v121 = 0;
  v122 = 0;
  v123 = 0;
  sub_1D3D92760(&v121, 0x14uLL);
  v43 = v38 + 7;
  v44 = __p;
  v117 = (uint64_t)v126;
  v116 = (unint64_t)(v126 - (_BYTE *)__p) >> 2;
  v45 = v123;
  v46 = v38;
  while (1)
  {
    v47 = v46;
    v118 = v43;
    v48 = v44;
    v49 = sub_1D3DA46D8((uint64_t)v44, v117, v46, (float *)&v124);
    if (v49 < 0)
      goto LABEL_94;
    v50 = v49;
    v51 = v122;
    if ((unint64_t)v122 >= v45)
    {
      v54 = (char *)v121;
      v55 = (v122 - (_BYTE *)v121) >> 2;
      v56 = v55 + 1;
      if ((unint64_t)(v55 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((uint64_t)(v45 - (_QWORD)v121) >> 1 > v56)
        v56 = (uint64_t)(v45 - (_QWORD)v121) >> 1;
      if (v45 - (unint64_t)v121 >= 0x7FFFFFFFFFFFFFFCLL)
        v57 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v57 = v56;
      if (v57)
        v57 = (unint64_t)sub_1D3D82278(v57);
      else
        v58 = 0;
      v52 = (int *)(v57 + 4 * v55);
      *v52 = v50;
      v53 = v52 + 1;
      while (v51 != v54)
      {
        v59 = *((_DWORD *)v51 - 1);
        v51 -= 4;
        *--v52 = v59;
      }
      v45 = v57 + 4 * v58;
      v121 = v52;
      if (v54)
        operator delete(v54);
    }
    else
    {
      *(_DWORD *)v122 = v49;
      v52 = (int *)v121;
      v53 = (int *)(v51 + 4);
    }
    v122 = (char *)v53;
    v46 = v47 + 8;
    if ((unint64_t)((char *)v53 - (char *)v52) >= 5)
    {
      v60 = memchr("ABCD", a0123456789Abcd[v50], 5uLL);
      if (v60)
      {
        if ((((_DWORD)v60 - "ABCD") & 0x80000000) == 0)
          break;
      }
    }
    v43 = v118 + 8;
    v44 = v48;
    if (v46 >= (int)v116)
    {
      v123 = v45;
      goto LABEL_90;
    }
  }
  v123 = v45;
  v44 = __p;
LABEL_90:
  v61 = 0;
  v62 = v47 + 7;
  for (j = 0x3FFFFFFFFFFFFFF8; j != -1; ++j)
    v61 += v44[v46 + j];
  v64 = v61 + (v61 < 0);
  if (v46 < (int)((unint64_t)(v117 - (_QWORD)v44) >> 2) && v44[v62] < v64 >> 1)
  {
LABEL_94:
    *(_DWORD *)a5 = 1;
    *(_QWORD *)(a5 + 104) = 0;
    *(_QWORD *)(a5 + 112) = 0;
    *(_OWORD *)(a5 + 4) = 0u;
    *(_OWORD *)(a5 + 20) = 0u;
    *(_OWORD *)(a5 + 36) = 0u;
    *(_OWORD *)(a5 + 52) = 0u;
    *(_OWORD *)(a5 + 68) = 0u;
    *(_QWORD *)(a5 + 84) = 0;
    *(_QWORD *)(a5 + 96) = a5 + 104;
    *(_BYTE *)(a5 + 120) = 0;
    *(_DWORD *)(a5 + 124) = 0;
    *(_DWORD *)(a5 + 128) = 0;
    goto LABEL_95;
  }
  *(_OWORD *)&__str.__r_.__value_.__l.__data_ = 0uLL;
  *(_OWORD *)&v119.__r_.__value_.__l.__data_ = 0uLL;
  if (v52 != v53)
  {
    v65 = v52;
    v66 = (char *)&v44[v112];
    do
    {
      v67 = dword_1D3E6687C[*v65];
      for (k = 6; k != -1; --k)
      {
        v69 = k & 1 | (2 * (v67 & 1));
        *((_DWORD *)&__str.__r_.__value_.__l.__data_ + v69) += *(_DWORD *)&v66[4 * k];
        ++*((_DWORD *)&v119.__r_.__value_.__l.__data_ + v69);
        v67 >>= 1;
      }
      ++v65;
      v66 += 32;
    }
    while (v65 != v53);
  }
  v70 = 0;
  v128[0] = 0;
  v71 = 1;
  do
  {
    v72 = v71;
    v73 = (4 * v70) | 8;
    v74 = (float)*(int *)((char *)&__str.__r_.__value_.__l.__data_ + v73);
    v75 = (float)*(int *)((char *)&v119.__r_.__value_.__l.__data_ + v73);
    v76 = (float)((float)((float)*((int *)&__str.__r_.__value_.__l.__data_ + v70)
                        / (float)*((int *)&v119.__r_.__value_.__l.__data_ + v70))
                + (float)(v74 / v75))
        * 0.5;
    *(float *)((char *)v128 + v73) = v76;
    v129[v70] = v76;
    *(float *)((char *)v129 + v73) = (float)((float)(v74 * 2.0) + 1.5) / v75;
    v70 = 1;
    v71 = 0;
  }
  while ((v72 & 1) != 0);
  if (v52 != v53)
  {
    v77 = v52;
    v78 = (char *)&v44[v112];
LABEL_106:
    v79 = dword_1D3E6687C[*v77];
    v80 = 6;
    while (1)
    {
      v81 = v80 & 1 | (2 * (v79 & 1u));
      v82 = (float)*(int *)&v78[4 * v80];
      if (*((float *)v128 + v81) > v82 || v129[v81] < v82)
        goto LABEL_94;
      v79 >>= 1;
      if (--v80 == -1)
      {
        ++v77;
        v78 += 32;
        if (v77 != v53)
          goto LABEL_106;
        break;
      }
    }
  }
  memset(&__str, 0, sizeof(__str));
  std::string::reserve(&__str, v53 - v52);
  while (v52 != v53)
    std::string::push_back(&__str, a0123456789Abcd[*v52++]);
  v83 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  v84 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_str = &__str;
  else
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  v86 = memchr("ABCD", p_str->__r_.__value_.__s.__data_[0], 5uLL);
  if (!v86 || (((_DWORD)v86 - "ABCD") & 0x80000000) != 0)
    goto LABEL_155;
  size = __str.__r_.__value_.__l.__size_;
  v88 = v84 >= 0 ? v83 : __str.__r_.__value_.__l.__size_;
  v89 = memchr("ABCD", p_str->__r_.__value_.__s.__data_[v88 - 1], 5uLL);
  if (!v89 || (((_DWORD)v89 - "ABCD") & 0x80000000) != 0 || (int)v88 <= 3)
    goto LABEL_155;
  if (!*(_BYTE *)(v115 + 8))
  {
    std::string::basic_string(&v119, &__str, 1uLL, v88 - 2, (std::allocator<char> *)v129);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    __str = v119;
    v83 = HIBYTE(v119.__r_.__value_.__r.__words[2]);
    size = v119.__r_.__value_.__l.__size_;
    LOBYTE(v84) = *((_BYTE *)&v119.__r_.__value_.__s + 23);
  }
  v90 = (char)v84;
  if ((v84 & 0x80u) != 0)
    v83 = size;
  if (v83 <= 7)
  {
    v98 = v113[1];
    v99 = v113[2];
    if (v98 != v99)
    {
      if (v90 >= 0)
        v100 = &__str;
      else
        v100 = (std::string *)__str.__r_.__value_.__r.__words[0];
      do
      {
        v101 = *(char *)(v98 + 23);
        v102 = v101 >= 0 ? *(unsigned __int8 *)(v98 + 23) : *(_QWORD *)(v98 + 8);
        v103 = v101 >= 0 ? (const void *)v98 : *(const void **)v98;
        v104 = v102 >= v83 ? v83 : v102;
        if (!memcmp(v100, v103, v104) && v102 == v83)
          goto LABEL_132;
        v98 += 24;
      }
      while (v98 != v99);
    }
    sub_1D3DA4860(v113 + 1, (__int128 *)&__str);
LABEL_155:
    *(_DWORD *)a5 = 1;
    *(_QWORD *)(a5 + 104) = 0;
    *(_QWORD *)(a5 + 112) = 0;
    *(_OWORD *)(a5 + 4) = 0u;
    *(_OWORD *)(a5 + 20) = 0u;
    *(_OWORD *)(a5 + 36) = 0u;
    *(_OWORD *)(a5 + 52) = 0u;
    *(_OWORD *)(a5 + 68) = 0u;
    *(_QWORD *)(a5 + 84) = 0;
    *(_QWORD *)(a5 + 96) = a5 + 104;
    v106 = 0;
    v107 = 0;
    *(_BYTE *)(a5 + 120) = 0;
    goto LABEL_156;
  }
LABEL_132:
  if ((int)v38 < 1)
  {
    v91 = 0;
    v95 = v114;
    v93 = v112;
    v96 = v118;
  }
  else
  {
    v91 = 0;
    v92 = (int *)__p;
    v93 = v112;
    v94 = v112;
    v95 = v114;
    v96 = v118;
    do
    {
      v97 = *v92++;
      v91 += v97;
      --v94;
    }
    while (v94);
  }
  v108 = v91;
  if (v62 > (int)v38)
  {
    v109 = v96 - v93;
    v110 = (int *)((char *)__p + 4 * v93);
    v108 = v91;
    do
    {
      v111 = *v110++;
      v108 += v111;
      --v109;
    }
    while (v109);
  }
  memset(&v119, 0, sizeof(v119));
  sub_1D3E2BD3C(a5, (unsigned __int8 *)&__str, v95, v91, v108, (uint64_t)&v119);
  if (v119.__r_.__value_.__r.__words[0])
    operator delete(v119.__r_.__value_.__l.__data_);
  v106 = HIDWORD(v124);
  v107 = v124;
LABEL_156:
  *(_DWORD *)(a5 + 124) = v106;
  *(_DWORD *)(a5 + 128) = v107;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
LABEL_95:
  if (v121)
    operator delete(v121);
LABEL_62:
  if (__p)
    operator delete(__p);
}

void sub_1D3DA4000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29)
{
  if (a24 < 0)
    operator delete(__p);
  if (a25)
    operator delete(a25);
  if (a29)
    operator delete(a29);
  _Unwind_Resume(exception_object);
}

void sub_1D3DA4070(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  unsigned __int16 *v8;
  unint64_t v9;
  __int32 v10;
  __int32 *v11;
  __int32 *v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  __int32 v17;
  __int32 *v18;
  std::string::size_type *v19;
  unsigned int v20;
  unsigned __int16 *v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  __int32 v25;
  std::string::value_type v26;
  std::string::size_type size;
  char v28;
  std::string *p_s;
  unsigned __int16 *v30;
  __int32 v31;
  std::string::value_type v32;
  unsigned int v33;
  std::string::size_type v34;
  int v35;
  unsigned __int16 *v36;
  uint64_t v37;
  int v38;
  float v39;
  int v40;
  unsigned __int16 *v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  std::string v47;
  char v48;
  std::string __s;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v7 = *a3;
  v8 = (unsigned __int16 *)a3[2];
  v9 = a3[3];
  if ((unsigned __int16 *)*a3 != v8 + 1
    || ((*(_OWORD *)&__s.__r_.__value_.__l.__data_ = xmmword_1D3E82020,
         v10 = sub_1D3DA4514(v7, 7),
         (v11 = wmemchr((__int32 *)&__s, v10, 4uLL)) != 0)
      ? (v12 = v11)
      : (v12 = (__int32 *)&__s.__r_.__value_.__r.__words[2]),
        (char *)v12 - (char *)&__s == 16))
  {
    v13 = v7 + 4;
    if (v7 + 4 >= v9)
      goto LABEL_17;
    while (1)
    {
      v14 = 0;
      v15 = 0;
      v16 = *(unsigned __int16 *)(v7 + 2);
      v7 = v13;
      do
      {
        v15 += *(unsigned __int16 *)(v13 + v14);
        v14 += 2;
      }
      while (v14 != 14);
      if ((float)((float)v15 * 0.5) <= (float)v16)
      {
        *(_OWORD *)&__s.__r_.__value_.__l.__data_ = xmmword_1D3E82020;
        v17 = sub_1D3DA4514(v13, 7);
        v18 = wmemchr((__int32 *)&__s, v17, 4uLL);
        v19 = v18 ? (std::string::size_type *)v18 : &__s.__r_.__value_.__r.__words[2];
        if ((char *)v19 - (char *)&__s != 16)
          break;
      }
      v13 += 4;
      if (v7 + 4 >= v9)
        goto LABEL_17;
    }
  }
  v13 = v7;
LABEL_17:
  if (v13 >= v9)
  {
    *(_DWORD *)a4 = 1;
    *(_QWORD *)(a4 + 104) = 0;
    *(_QWORD *)(a4 + 112) = 0;
    *(_OWORD *)(a4 + 4) = 0u;
    *(_OWORD *)(a4 + 20) = 0u;
    *(_OWORD *)(a4 + 36) = 0u;
    *(_OWORD *)(a4 + 52) = 0u;
    *(_OWORD *)(a4 + 68) = 0u;
    *(_QWORD *)(a4 + 84) = 0;
    *(_QWORD *)(a4 + 96) = a4 + 104;
    *(_BYTE *)(a4 + 120) = 0;
    *(_DWORD *)(a4 + 124) = 0;
    *(_DWORD *)(a4 + 128) = 0;
  }
  else
  {
    if (v8 == (unsigned __int16 *)v13)
    {
      v20 = 0;
    }
    else
    {
      v20 = 0;
      v21 = v8;
      do
      {
        v22 = *v21++;
        v20 += v22;
      }
      while (v21 != (unsigned __int16 *)v13);
    }
    v23 = 0;
    v24 = 0;
    do
    {
      v24 += *(unsigned __int16 *)(v13 + v23);
      v23 += 2;
    }
    while (v23 != 14);
    memset(&__s, 0, sizeof(__s));
    std::string::reserve(&__s, 0x14uLL);
    v25 = sub_1D3DA4514(v13, 7);
    v26 = sub_1D3DA4668(v25);
    std::string::push_back(&__s, v26);
    size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
    v28 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __s.__r_.__value_.__l.__size_;
    else
      p_s = &__s;
    if (p_s->__r_.__value_.__s.__data_[size - 1] - 65 <= 3 && v13 + 14 < v9)
    {
      v30 = (unsigned __int16 *)(v13 + 16);
      while ((unint64_t)v30 <= v9 && v24 >> 1 > *(v30 - 1))
      {
        v31 = sub_1D3DA4514((uint64_t)v30, 7);
        v32 = sub_1D3DA4668(v31);
        std::string::push_back(&__s, v32);
        v28 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        v34 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
        {
          v35 = *(char *)(__s.__r_.__value_.__r.__words[0] + __s.__r_.__value_.__l.__size_ - 1);
          if (v35 < 0)
            break;
        }
        else
        {
          v35 = *(&v48 + HIBYTE(__s.__r_.__value_.__r.__words[2]));
          if (v35 < 0)
            break;
        }
        if (v35 - 65 <= 3)
        {
          if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v34 = __s.__r_.__value_.__l.__size_;
          if ((int)v34 < 4)
            break;
          if (v30 + 7 != (unsigned __int16 *)(v9 - 2))
          {
            v37 = 0;
            v38 = 0;
            LOWORD(v33) = v30[7];
            v39 = (float)v33;
            do
              v38 += v30[v37++];
            while (v37 != 7);
            if ((float)((float)v38 * 0.5) > v39)
              break;
          }
          if (!*(_BYTE *)(a1 + 8))
          {
            std::string::basic_string(&v47, &__s, 1uLL, v34 - 2, (std::allocator<char> *)&v48);
            if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__s.__r_.__value_.__l.__data_);
            __s = v47;
          }
          if (v8 == v30)
          {
            v43 = -1;
          }
          else
          {
            v40 = 0;
            v41 = v8 - 1;
            do
            {
              v42 = v41[1];
              ++v41;
              v40 += v42;
            }
            while (v41 != v30 - 1);
            v43 = v40 - 1;
          }
          v44 = 0;
          v45 = 7;
          do
          {
            v46 = *v30++;
            v44 += v46;
            --v45;
          }
          while (v45);
          memset(&v47, 0, sizeof(v47));
          sub_1D3E2BD3C(a4, (unsigned __int8 *)&__s, a2, v20, v43 + v44, (uint64_t)&v47);
          if (v47.__r_.__value_.__r.__words[0])
            operator delete(v47.__r_.__value_.__l.__data_);
          if ((*((_BYTE *)&__s.__r_.__value_.__s + 23) & 0x80) == 0)
            return;
          goto LABEL_49;
        }
        v36 = v30 + 7;
        v30 += 8;
        if ((unint64_t)v36 >= v9)
          break;
      }
    }
    *(_DWORD *)a4 = 1;
    *(_QWORD *)(a4 + 104) = 0;
    *(_QWORD *)(a4 + 112) = 0;
    *(_OWORD *)(a4 + 4) = 0u;
    *(_OWORD *)(a4 + 20) = 0u;
    *(_OWORD *)(a4 + 36) = 0u;
    *(_OWORD *)(a4 + 52) = 0u;
    *(_OWORD *)(a4 + 68) = 0u;
    *(_QWORD *)(a4 + 84) = 0;
    *(_QWORD *)(a4 + 96) = a4 + 104;
    *(_BYTE *)(a4 + 120) = 0;
    *(_DWORD *)(a4 + 124) = 0;
    *(_DWORD *)(a4 + 128) = 0;
    if (v28 < 0)
LABEL_49:
      operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_1D3DA44DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DA4514(uint64_t a1, int a2)
{
  uint64_t i;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  char v6;
  unsigned int v7;
  char v8;
  unsigned int v9;
  unsigned int v10;
  __int16 v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v19;
  int v20;
  int v21;

  v20 = 0;
  v21 = -1;
  if (a2 >= 1)
  {
    for (i = 0; i != a2; *((_WORD *)&v20 + (i++ & 1)) = v3)
    {
      v3 = *(unsigned __int16 *)(a1 + 2 * i);
      v4 = *((unsigned __int16 *)&v21 + (i & 1));
      if (v3 < v4)
        LOWORD(v4) = *(_WORD *)(a1 + 2 * i);
      *((_WORD *)&v21 + (i & 1)) = v4;
      if (*((unsigned __int16 *)&v20 + (i & 1)) > v3)
        LOWORD(v3) = *((_WORD *)&v20 + (i & 1));
    }
  }
  v5 = 0;
  v19 = 0;
  v6 = 1;
  do
  {
    v7 = *((unsigned __int16 *)&v20 + v5);
    v8 = v6;
    v9 = *((unsigned __int16 *)&v21 + v5);
    if (4 * v9 + 4 < v7
      || 3 * *((unsigned __int16 *)&v20 + (v5 ^ 1)) < v7
      || 2 * *((unsigned __int16 *)&v21 + (v5 ^ 1)) + 2 < v9)
    {
      return 0xFFFFFFFFLL;
    }
    v6 = 0;
    v10 = (v9 + v7) >> 1;
    if (v10 <= (3 * v9) >> 1)
      v11 = (3 * v9) >> 1;
    else
      v11 = v10;
    *((_WORD *)&v19 + v5) = v11;
    v5 = 1;
  }
  while ((v8 & 1) != 0);
  v21 = v19;
  if ((_WORD)v19)
    v12 = v19 >= 0x10000;
  else
    v12 = 0;
  v13 = !v12;
  v14 = (v13 << 31 >> 31);
  if (v12 && a2 >= 1)
  {
    v15 = 0;
    LODWORD(v14) = 0;
    while (1)
    {
      v16 = *(unsigned __int16 *)(a1 + 2 * v15);
      v17 = *(unsigned __int16 *)((unint64_t)&v21 & 0xFFFFFFFFFFFFFFFDLL | (2 * (v15 & 1)));
      if (v16 > 2 * v17)
        break;
      v14 = (v16 > v17) | (2 * v14);
      if (a2 == ++v15)
        return v14;
    }
    return 0xFFFFFFFFLL;
  }
  return v14;
}

uint64_t sub_1D3DA4668(__int32 __c)
{
  __int32 *v1;
  __int32 *v2;
  unint64_t v3;

  v1 = wmemchr(dword_1D3E6687C, __c, 0x14uLL);
  v2 = &dword_1D3E6687C[20];
  if (v1)
    v2 = v1;
  v3 = (char *)v2 - (char *)dword_1D3E6687C;
  if (v3 == 80 || (v3 & 0x3FFFFFFFCLL) == 0x3FFFFFFFCLL)
    return -1;
  else
    return a0123456789Abcd[(int)(v3 >> 2)];
}

uint64_t sub_1D3DA46D8(uint64_t a1, uint64_t a2, int a3, float *a4)
{
  int v4;
  __int32 *v5;
  int32x4_t v6;
  int32x4_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  __int32 v15;
  int v16;
  int v17;
  float v18;
  int v19;
  float v20;
  BOOL v21;
  int v22;
  int v23;
  float v24;
  float v25;
  float v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  int v31;
  char v32;
  unsigned int v33;
  int v34;
  float v35;
  __int32 *v37;
  __int32 *v38;
  unint64_t v39;

  if (a3 + 7 >= (int)((unint64_t)(a2 - a1) >> 2))
    return 0xFFFFFFFFLL;
  v4 = 0;
  v5 = (__int32 *)(a1 + 4 * a3);
  v6.i32[0] = *v5;
  v6.i32[1] = v5[2];
  v6.i32[2] = v5[4];
  v6.i32[3] = v5[6];
  v7 = vmaxq_s32(v6, (int32x4_t)0);
  v8 = vminvq_s32(v6);
  v9 = a3 + 1;
  v10 = 0x7FFFFFFF;
  do
  {
    v11 = *(_DWORD *)(a1 + 4 * v9);
    if (v11 < v10)
      v10 = *(_DWORD *)(a1 + 4 * v9);
    if (v11 > v4)
      v4 = *(_DWORD *)(a1 + 4 * v9);
    v9 += 2;
  }
  while (v9 < a3 + 7);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = vmaxvq_s32(v7);
  v17 = v8 + v16;
  v32 = (v8 + v16 < 0) ^ __OFADD__(v8, v16);
  v18 = (float)v8;
  if (v32)
    v19 = v17 + 1;
  else
    v19 = v17;
  v20 = (float)v10;
  v21 = __OFADD__(v10, v4);
  v22 = v10 + v4;
  if (v22 < 0 != v21)
    ++v22;
  v23 = v22 >> 1;
  v24 = v18 / 3.0;
  v25 = v20 + 1.5;
  v26 = v20 * 1.5;
  if (v25 >= v26)
    v26 = v25;
  if (v24 < v26)
    v24 = v26;
  if (v24 < (float)v4)
    v4 = v23;
  v27 = v19 >> 1;
  v29 = 128;
  do
  {
    if ((v12 & 1) != 0)
      v30 = v4;
    else
      v30 = v27;
    v29 >>= 1;
    v28 = a1 + 4 * a3;
    v31 = *(_DWORD *)(v28 + 4 * v12);
    v32 = v31 <= v30;
    if (v31 > v30)
      v33 = v29;
    else
      v33 = 0;
    v15 |= v33;
    if (v32)
      v34 = *(_DWORD *)(v28 + 4 * v12);
    else
      v34 = 0;
    v14 += v34;
    if (v32)
      ++v13;
    ++v12;
  }
  while (v12 != 7);
  if (v13)
    v35 = (float)v14 / (float)v13;
  else
    v35 = 0.0;
  *a4 = v35;
  v37 = wmemchr(dword_1D3E6687C, v15, 0x14uLL);
  v38 = &dword_1D3E6687C[20];
  if (v37)
    v38 = v37;
  v39 = (char *)v38 - (char *)dword_1D3E6687C;
  if (v39 == 80)
    return 0xFFFFFFFFLL;
  else
    return (v39 >> 2);
}

unint64_t *sub_1D3DA4860(unint64_t *result, __int128 *a2)
{
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  __int128 v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  __int128 v16;
  int64x2_t v17;
  unint64_t v18;
  char *v19;
  int64x2_t v20;
  char *v21;
  unint64_t *v22;

  v3 = result;
  v4 = result[2];
  v5 = result[1];
  if (v5 >= v4)
  {
    v7 = *result;
    v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *result) >> 3);
    v9 = v8 + 1;
    if (v8 + 1 > 0xAAAAAAAAAAAAAAALL)
      sub_1D3D6D4F8();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v7) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v22 = result + 2;
    if (v11)
    {
      if (v11 > 0xAAAAAAAAAAAAAAALL)
        sub_1D3D6D50C();
      v12 = (char *)operator new(24 * v11);
    }
    else
    {
      v12 = 0;
    }
    v14 = &v12[24 * v8];
    v19 = v12;
    v20.i64[0] = (uint64_t)v14;
    v20.i64[1] = (uint64_t)v14;
    v21 = &v12[24 * v11];
    if (*((char *)a2 + 23) < 0)
    {
      sub_1D3D7FCC0(v14, *(void **)a2, *((_QWORD *)a2 + 1));
      v7 = *v3;
      v5 = v3[1];
      v15 = (char *)v20.i64[1];
      v14 = (char *)v20.i64[0];
    }
    else
    {
      *(_OWORD *)v14 = *a2;
      *((_QWORD *)v14 + 2) = *((_QWORD *)a2 + 2);
      v15 = &v12[24 * v8];
    }
    v13 = (unint64_t)(v15 + 24);
    if (v5 == v7)
    {
      v17 = vdupq_n_s64(v7);
    }
    else
    {
      do
      {
        v16 = *(_OWORD *)(v5 - 24);
        *((_QWORD *)v14 - 1) = *(_QWORD *)(v5 - 8);
        *(_OWORD *)(v14 - 24) = v16;
        v14 -= 24;
        *(_QWORD *)(v5 - 16) = 0;
        *(_QWORD *)(v5 - 8) = 0;
        *(_QWORD *)(v5 - 24) = 0;
        v5 -= 24;
      }
      while (v5 != v7);
      v17 = *(int64x2_t *)v3;
    }
    *v3 = (unint64_t)v14;
    v3[1] = v13;
    v20 = v17;
    v18 = v3[2];
    v3[2] = (unint64_t)v21;
    v21 = (char *)v18;
    v19 = (char *)v17.i64[0];
    result = (unint64_t *)sub_1D3DA4A34((uint64_t)&v19);
  }
  else
  {
    if (*((char *)a2 + 23) < 0)
    {
      result = (unint64_t *)sub_1D3D7FCC0((_BYTE *)result[1], *(void **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v6 = *a2;
      *(_QWORD *)(v5 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v5 = v6;
    }
    v13 = v5 + 24;
    v3[1] = v5 + 24;
  }
  v3[1] = v13;
  return result;
}

void sub_1D3DA4A14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3DA4A34((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DA4A34(uint64_t a1)
{
  void **v2;
  void **v3;
  void **v4;

  v3 = *(void ***)(a1 + 8);
  v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      v4 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v4);
        v4 = *(void ***)(a1 + 16);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1D3DA4A94(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = &off_1E95AF170;
  v3 = (void **)(a1 + 8);
  sub_1D3DA4B2C(&v3);
  return a1;
}

void sub_1D3DA4AD8(uint64_t a1)
{
  void **v1;

  *(_QWORD *)a1 = &off_1E95AF170;
  v1 = (void **)(a1 + 8);
  sub_1D3DA4B2C(&v1);
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DA4B2C(void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0)
          operator delete(*(v4 - 3));
        v4 -= 3;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1D3DA4BA4(int *a1, char **a2)
{
  uint64_t *v4;
  int v5;
  int v6;
  char *v7;
  char **v8;
  uint64_t **v9;
  void **v10;
  _OWORD *v11;
  uint64_t **v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  void *__p[2];
  uint64_t v17;
  uint64_t v18;

  v4 = (uint64_t *)operator new();
  *v4 = (uint64_t)a1;
  v4[1] = (uint64_t)a2;
  v5 = *a1;
  if (*a1 != -1)
  {
    do
    {
      sub_1D3DA4CF4((uint64_t **)qword_1EFE31738, v5, a1)[5] = v4;
      v6 = a1[1];
      ++a1;
      v5 = v6;
    }
    while (v6 != -1);
    a2 = (char **)v4[1];
  }
  v7 = *a2;
  if (*a2)
  {
    v8 = a2 + 1;
    do
    {
      v9 = (uint64_t **)qword_1EFE31740;
      sub_1D3D81D4C(__p, v7);
      v10 = (void **)sub_1D3DA4DC0((uint64_t)v9, &v18, __p);
      v11 = *v10;
      if (!*v10)
      {
        v12 = (uint64_t **)v10;
        v11 = operator new(0x40uLL);
        v11[2] = *(_OWORD *)__p;
        v14 = v17;
        v13 = v18;
        __p[1] = 0;
        v17 = 0;
        __p[0] = 0;
        *((_QWORD *)v11 + 6) = v14;
        *((_QWORD *)v11 + 7) = 0;
        sub_1D3D7F928(v9, v13, v12, (uint64_t *)v11);
      }
      *((_QWORD *)v11 + 7) = v4;
      if (SHIBYTE(v17) < 0)
        operator delete(__p[0]);
      v15 = *v8++;
      v7 = v15;
    }
    while (v15);
  }
}

void sub_1D3DA4CB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;

  if (a14 < 0)
    operator delete(__p);
  MEMORY[0x1D8254C54](v14, 0xD0C40BFC0A3C0);
  _Unwind_Resume(a1);
}

uint64_t **sub_1D3DA4CF4(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    sub_1D3D7F97C(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

_QWORD *sub_1D3DA4DC0(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = v4 + 4;
        if ((sub_1D3DA4E50(a3, v4 + 4) & 0x80) == 0)
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((sub_1D3DA4E50(v8, a3) & 0x80) == 0)
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t sub_1D3DA4E50(_QWORD *a1, _QWORD *a2)
{
  size_t v2;
  size_t v3;
  size_t v4;
  size_t v5;
  size_t v6;
  int v7;

  v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (_QWORD *)*a1;
    v3 = v2;
  }
  v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (_QWORD *)*a2;
    v5 = v4;
  }
  if (v5 >= v3)
    v6 = v3;
  else
    v6 = v5;
  v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (v3 == v5)
      return 0;
    if (v3 >= v5)
      return 1;
  }
  return 255;
}

void sub_1D3DA4ECC()
{
  _QWORD *v0;
  _QWORD *v1;

  v0 = (_QWORD *)operator new();
  v0[2] = 0;
  v0[1] = 0;
  *v0 = v0 + 1;
  qword_1EFE31738 = (uint64_t)v0;
  v1 = (_QWORD *)operator new();
  v1[2] = 0;
  v1[1] = 0;
  *v1 = v1 + 1;
  qword_1EFE31740 = (uint64_t)v1;
  sub_1D3DA4BA4(dword_1EFE31280, &off_1EFE31290);
  sub_1D3DA4BA4(dword_1EFE312A0, off_1EFE312B0);
  sub_1D3DA4BA4((int *)&unk_1EFE312C8, off_1EFE312D0);
  sub_1D3DA4BA4((int *)&unk_1EFE312E8, off_1EFE312F0);
  sub_1D3DA4BA4((int *)&unk_1EFE31308, off_1EFE31310);
  sub_1D3DA4BA4((int *)&unk_1EFE31328, off_1EFE31330);
  sub_1D3DA4BA4((int *)&unk_1EFE31348, off_1EFE31350);
  sub_1D3DA4BA4((int *)&unk_1EFE31368, off_1EFE31370);
  sub_1D3DA4BA4((int *)&unk_1EFE31388, off_1EFE31390);
  sub_1D3DA4BA4((int *)&unk_1EFE313A8, off_1EFE313B0);
  sub_1D3DA4BA4((int *)&unk_1EFE313C8, off_1EFE313D0);
  sub_1D3DA4BA4((int *)&unk_1EFE313E8, off_1EFE313F0);
  sub_1D3DA4BA4((int *)&unk_1EFE31408, off_1EFE31410);
  sub_1D3DA4BA4((int *)&unk_1EFE31428, off_1EFE31430);
  sub_1D3DA4BA4((int *)&unk_1EFE31448, off_1EFE31450);
  sub_1D3DA4BA4((int *)&unk_1EFE31468, off_1EFE31470);
  sub_1D3DA4BA4((int *)&unk_1EFE31488, off_1EFE31490);
  sub_1D3DA4BA4((int *)&unk_1EFE314A8, off_1EFE314B0);
  sub_1D3DA4BA4((int *)&unk_1EFE314C8, off_1EFE314D0);
  sub_1D3DA4BA4((int *)&unk_1EFE314E8, off_1EFE314F0);
  sub_1D3DA4BA4((int *)&unk_1EFE31508, off_1EFE31510);
  sub_1D3DA4BA4((int *)&unk_1EFE31528, off_1EFE31530);
  sub_1D3DA4BA4((int *)&unk_1EFE31550, off_1EFE31558);
  sub_1D3DA4BA4(dword_1EFE31570, off_1EFE31580);
  sub_1D3DA4BA4((int *)&unk_1EFE31598, &off_1EFE315A0);
  sub_1D3DA4BA4((int *)&unk_1EFE315B0, off_1EFE315B8);
  sub_1D3DA4BA4((int *)&unk_1EFE315E0, off_1EFE315E8);
}

void sub_1D3DA5154()
{
  unint64_t v0;
  void (**v1)();
  void (*v2)();

  v0 = atomic_load(&qword_1EFE31748);
  if (v0 != -1)
  {
    v1 = &v2;
    v2 = sub_1D3DA4ECC;
    std::__call_once(&qword_1EFE31748, &v1, (void (__cdecl *)(void *))sub_1D3DA51A8);
  }
}

uint64_t sub_1D3DA51A8(uint64_t (***a1)(void))
{
  return (**a1)();
}

uint64_t *sub_1D3DA51B4(int a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  uint64_t *v6;
  _QWORD *exception;
  int v9;

  v9 = a1;
  sub_1D3DA5154();
  if (a1 > 0x383)
    goto LABEL_13;
  v2 = *(_QWORD *)(qword_1EFE31738 + 8);
  if (!v2)
    goto LABEL_13;
  v3 = qword_1EFE31738 + 8;
  do
  {
    v4 = *(_DWORD *)(v2 + 32);
    v5 = v4 < a1;
    if (v4 >= a1)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (!v5)
      v3 = v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 == qword_1EFE31738 + 8 || *(_DWORD *)(v3 + 32) > a1)
  {
LABEL_13:
    exception = __cxa_allocate_exception(0x20uLL);
    exception[2] = 0;
    exception[3] = 0;
    *exception = &off_1E95AF330;
    exception[1] = 0;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  return sub_1D3DA4CF4((uint64_t **)qword_1EFE31738, a1, &v9)[5];
}

uint64_t sub_1D3DA526C(uint64_t a1)
{
  uint64_t **v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  _QWORD *v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t **v10;
  _BYTE *v11;
  _QWORD *exception;
  uint64_t v14;

  sub_1D3DA5154();
  v2 = (uint64_t **)qword_1EFE31740;
  v3 = qword_1EFE31740 + 8;
  v4 = *(_QWORD **)(qword_1EFE31740 + 8);
  if (!v4)
    goto LABEL_17;
  v5 = qword_1EFE31740 + 8;
  do
  {
    v6 = sub_1D3DA4E50(v4 + 4, (_QWORD *)a1);
    if (v6 >= 0)
      v7 = v4;
    else
      v7 = v4 + 1;
    if (v6 >= 0)
      v5 = (uint64_t)v4;
    v4 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v3 || (sub_1D3DA4E50((_QWORD *)a1, (_QWORD *)(v5 + 32)) & 0x80) != 0)
  {
LABEL_17:
    exception = __cxa_allocate_exception(0x20uLL);
    exception[2] = 0;
    exception[3] = 0;
    *exception = &off_1E95AF330;
    exception[1] = 0;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  v8 = (uint64_t **)sub_1D3DA4DC0((uint64_t)v2, &v14, (_QWORD *)a1);
  v9 = *v8;
  if (!*v8)
  {
    v10 = v8;
    v9 = (uint64_t *)operator new(0x40uLL);
    v11 = v9 + 4;
    if (*(char *)(a1 + 23) < 0)
    {
      sub_1D3D7FCC0(v11, *(void **)a1, *(_QWORD *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)v11 = *(_OWORD *)a1;
      v9[6] = *(_QWORD *)(a1 + 16);
    }
    v9[7] = 0;
    sub_1D3D7F928(v2, v14, v10, v9);
  }
  return v9[7];
}

void sub_1D3DA5394(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1D3DA53A8(uint64_t a1, unint64_t *a2)
{
  __CVBuffer *v3;

  if (!atomic_load(a2))
    return 0;
  v3 = (__CVBuffer *)atomic_load(a2);
  return ((CVPixelBufferGetPixelFormatType(v3) - 875704422) & 0xFFFFFFEF) == 0;
}

void sub_1D3DA53E4()
{
  __cxa_pure_virtual();
}

void sub_1D3DA53F4(uint64_t a1)
{
  sub_1D3DA7D18(a1);
  JUMPOUT(0x1D8254C54);
}

BOOL sub_1D3DA5418(_BYTE *a1)
{
  return a1[192] && a1[336] && a1[384] && a1[424] && a1[464] != 0;
}

uint64_t sub_1D3DA5450(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  CFTypeRef *v14;
  uint64_t v15;
  const vImage_YpCbCrToARGBMatrix *v16;
  char v17;
  vImage_Error Conversion;
  NSObject *v19;
  NSObject *v20;
  _BYTE *v21;
  uint64_t v22;
  vImagePixelCount v23;
  vImagePixelCount v24;
  int v25;
  vImage_Error v26;
  NSObject *v27;
  NSObject *v28;
  _QWORD *v29;
  uint64_t v30;
  NSObject *v32;
  vImage_Error v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const __CFString *v51;
  _BYTE buf[22];
  __int16 v53;
  uint64_t v54;
  _BYTE v55[10];
  __int16 v56;
  uint64_t v57;
  _QWORD v58[3];
  _QWORD *v59;
  _QWORD v60[3];
  _QWORD *v61;
  uint64_t v62;
  _QWORD v63[3];
  _QWORD *v64;
  _BYTE v65[24];
  _QWORD v66[3];
  _QWORD *v67;
  CFTypeRef v68[3];
  CFTypeRef *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if ((v6 & 1) == 0)
  {
    v61 = v60;
    v62 = a3;
    v58[0] = &off_1E95B26C0;
    v59 = v58;
    v60[0] = &off_1E95B2640;
    v64 = v63;
    v63[0] = &off_1E95B26C0;
    if (!*(_BYTE *)(a3 + 8)
      || (*(_QWORD *)buf = *(_QWORD *)a3, sub_1D3DA7AA8(v6, (os_signpost_id_t *)buf), v8 = v59, v59 == v58))
    {
      v9 = 4;
      v8 = v58;
    }
    else
    {
      if (!v59)
        goto LABEL_9;
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_9:
    v10 = v61;
    if (v61 == v60)
    {
      v11 = 4;
      v10 = v60;
    }
    else
    {
      if (!v61)
      {
LABEL_14:
        if (*(_BYTE *)(a1 + 192) && *(_BYTE *)(a1 + 336))
        {
LABEL_54:
          v23 = *(_QWORD *)(a1 + 8);
          v24 = *(_QWORD *)(a1 + 16);
          if (!v23 || (v23 & 0xF) != 0 || !v24 || (v24 & 0xF) != 0)
          {
            if (qword_1EDB89F20 != -1)
              dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
            v28 = qword_1EDB89F78;
            if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134349312;
              *(_QWORD *)&buf[4] = v23;
              *(_WORD *)&buf[12] = 2050;
              *(_QWORD *)&buf[14] = v24;
              _os_log_error_impl(&dword_1D3D6B000, v28, OS_LOG_TYPE_ERROR, "Invalid image size: width=%{public}zu, height=%{public}zu", buf, 0x16u);
            }
            *(_QWORD *)buf = -6008;
            v68[0] = CFSTR("Invalid image size.");
            sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)buf, v68);
          }
          else
          {
            v25 = *(_DWORD *)(a1 + 24);
            if (v25 == 1111970369)
            {
              if (!*(_BYTE *)(a1 + 384))
              {
                *(_OWORD *)(a1 + 352) = 0u;
                *(_OWORD *)(a1 + 368) = 0u;
                *(_BYTE *)(a1 + 384) = 1;
                v33 = vImageBuffer_Init((vImage_Buffer *)(a1 + 352), v24, v23, 8u, 0);
                if (v33)
                {
                  if (*(_BYTE *)(a1 + 384))
                    *(_BYTE *)(a1 + 384) = 0;
                  if (qword_1EDB89F20 != -1)
                    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
                  v34 = qword_1EDB89F78;
                  if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 134349056;
                    *(_QWORD *)&buf[4] = v33;
                    _os_log_error_impl(&dword_1D3D6B000, v34, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
                  }
                  goto LABEL_105;
                }
                if (qword_1EDB89F20 != -1)
                  dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
                v36 = qword_1EDB89F78;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
                {
                  v37 = *(_QWORD *)(a1 + 352);
                  v38 = *(_QWORD *)(a1 + 360);
                  v39 = *(_QWORD *)(a1 + 368);
                  v40 = *(_QWORD *)(a1 + 376);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "420Yp8";
                  *(_WORD *)&buf[12] = 2050;
                  *(_QWORD *)&buf[14] = v37;
                  v53 = 2050;
                  v54 = v38;
                  *(_WORD *)v55 = 2050;
                  *(_QWORD *)&v55[2] = v39;
                  v56 = 2050;
                  v57 = v40;
                  _os_log_debug_impl(&dword_1D3D6B000, v36, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
                }
              }
              if (*(_BYTE *)(a1 + 424))
              {
LABEL_61:
                v7 = 1;
                if (*(_BYTE *)(a1 + 464))
                  goto LABEL_76;
                *(_OWORD *)(a1 + 432) = 0u;
                *(_OWORD *)(a1 + 448) = 0u;
                *(_BYTE *)(a1 + 464) = 1;
                v26 = vImageBuffer_Init((vImage_Buffer *)(a1 + 432), v24, v23, 0x20u, 0);
                if (!v26)
                {
                  if (qword_1EDB89F20 != -1)
                    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
                  v46 = qword_1EDB89F78;
                  if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
                  {
                    v47 = *(_QWORD *)(a1 + 432);
                    v48 = *(_QWORD *)(a1 + 440);
                    v49 = *(_QWORD *)(a1 + 448);
                    v50 = *(_QWORD *)(a1 + 456);
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "32BGRA";
                    *(_WORD *)&buf[12] = 2050;
                    *(_QWORD *)&buf[14] = v47;
                    v53 = 2050;
                    v54 = v48;
                    *(_WORD *)v55 = 2050;
                    *(_QWORD *)&v55[2] = v49;
                    v56 = 2050;
                    v57 = v50;
                    _os_log_debug_impl(&dword_1D3D6B000, v46, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
                  }
LABEL_76:
                  v29 = v64;
                  if (*(_BYTE *)(v62 + 8))
                  {
                    if (!v64)
                      return v7;
                    *(_QWORD *)buf = *(_QWORD *)v62;
                    (*(void (**)(void))(*v64 + 48))();
                    v29 = v64;
                  }
                  if (v29 == v63)
                  {
                    v30 = 4;
                    v29 = v63;
                  }
                  else
                  {
                    if (!v29)
                      return v7;
                    v30 = 5;
                  }
                  (*(void (**)(void))(*v29 + 8 * v30))();
                  return v7;
                }
                if (*(_BYTE *)(a1 + 464))
                  *(_BYTE *)(a1 + 464) = 0;
                if (qword_1EDB89F20 != -1)
                  dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
                v27 = qword_1EDB89F78;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 134349056;
                  *(_QWORD *)&buf[4] = v26;
                  _os_log_error_impl(&dword_1D3D6B000, v27, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
                }
                *(_QWORD *)buf = -2003;
                v68[0] = CFSTR("vImageBuffer_Init failed.");
                sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)buf, v68);
                v7 = 0;
                *(_QWORD *)(a2 + 32) = v26;
LABEL_106:
                *(_BYTE *)(a2 + 40) = 1;
                goto LABEL_76;
              }
              *(_OWORD *)(a1 + 392) = 0u;
              *(_OWORD *)(a1 + 408) = 0u;
              *(_BYTE *)(a1 + 424) = 1;
              v33 = vImageBuffer_Init((vImage_Buffer *)(a1 + 392), v24 >> 1, v23 >> 1, 0x10u, 0);
              if (!v33)
              {
                if (qword_1EDB89F20 != -1)
                  dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
                v41 = qword_1EDB89F78;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
                {
                  v42 = *(_QWORD *)(a1 + 392);
                  v43 = *(_QWORD *)(a1 + 400);
                  v44 = *(_QWORD *)(a1 + 408);
                  v45 = *(_QWORD *)(a1 + 416);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "420CbCr8";
                  *(_WORD *)&buf[12] = 2050;
                  *(_QWORD *)&buf[14] = v42;
                  v53 = 2050;
                  v54 = v43;
                  *(_WORD *)v55 = 2050;
                  *(_QWORD *)&v55[2] = v44;
                  v56 = 2050;
                  v57 = v45;
                  _os_log_debug_impl(&dword_1D3D6B000, v41, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
                }
                goto LABEL_61;
              }
              if (*(_BYTE *)(a1 + 424))
                *(_BYTE *)(a1 + 424) = 0;
              if (qword_1EDB89F20 != -1)
                dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
              v35 = qword_1EDB89F78;
              if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134349056;
                *(_QWORD *)&buf[4] = v33;
                _os_log_error_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
              }
LABEL_105:
              *(_QWORD *)buf = -2003;
              v68[0] = CFSTR("vImageBuffer_Init failed.");
              sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)buf, v68);
              v7 = 0;
              *(_QWORD *)(a2 + 32) = v33;
              goto LABEL_106;
            }
            if (qword_1EDB89F20 != -1)
              dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
            v32 = qword_1EDB89F78;
            if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67240192;
              *(_DWORD *)&buf[4] = v25;
              _os_log_error_impl(&dword_1D3D6B000, v32, OS_LOG_TYPE_ERROR, "Unsupported pixel format type: %{public}u", buf, 8u);
            }
            *(_QWORD *)buf = -6008;
            v68[0] = CFSTR("Unsupported pixel format type.");
            sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)buf, v68);
          }
LABEL_75:
          v7 = 0;
          goto LABEL_76;
        }
        v69 = v68;
        v66[0] = &off_1E95AD368;
        v67 = v66;
        v68[0] = &off_1E95AD310;
        *(_QWORD *)v55 = &buf[8];
        *(_QWORD *)buf = a3;
        *(_QWORD *)&buf[8] = &off_1E95AD368;
        if (!*(_BYTE *)(a3 + 8)
          || (*(_QWORD *)v65 = *(_QWORD *)a3, sub_1D3E0ED08((uint64_t)v10, (os_signpost_id_t *)v65),
                                              v12 = v67,
                                              v67 == v66))
        {
          v13 = 4;
          v12 = v66;
        }
        else
        {
          if (!v67)
            goto LABEL_22;
          v13 = 5;
        }
        (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_22:
        v14 = v69;
        if (v69 == v68)
        {
          v15 = 4;
          v14 = v68;
        }
        else
        {
          if (!v69)
          {
LABEL_27:
            v16 = (const vImage_YpCbCrToARGBMatrix *)*MEMORY[0x1E0C8BDB0];
            if (*(_BYTE *)(a1 + 192))
              goto LABEL_28;
            *(_OWORD *)(a1 + 160) = 0u;
            *(_OWORD *)(a1 + 176) = 0u;
            *(_OWORD *)(a1 + 128) = 0u;
            *(_OWORD *)(a1 + 144) = 0u;
            *(_OWORD *)(a1 + 96) = 0u;
            *(_OWORD *)(a1 + 112) = 0u;
            *(_OWORD *)(a1 + 64) = 0u;
            *(_OWORD *)(a1 + 80) = 0u;
            *(_BYTE *)(a1 + 192) = 1;
            Conversion = vImageConvert_YpCbCrToARGB_GenerateConversion(v16, (const vImage_YpCbCrPixelRange *)&unk_1D3E6EFC0, (vImage_YpCbCrToARGB *)(a1 + 64), kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
            if (!Conversion)
            {
LABEL_28:
              v17 = 1;
              if (*(_BYTE *)(a1 + 336))
                goto LABEL_45;
              *(_OWORD *)(a1 + 208) = 0u;
              *(_OWORD *)(a1 + 304) = 0u;
              *(_OWORD *)(a1 + 320) = 0u;
              *(_OWORD *)(a1 + 272) = 0u;
              *(_OWORD *)(a1 + 288) = 0u;
              *(_OWORD *)(a1 + 240) = 0u;
              *(_OWORD *)(a1 + 256) = 0u;
              *(_OWORD *)(a1 + 224) = 0u;
              *(_BYTE *)(a1 + 336) = 1;
              Conversion = vImageConvert_YpCbCrToARGB_GenerateConversion(v16, (const vImage_YpCbCrPixelRange *)&xmmword_1D3E756C8, (vImage_YpCbCrToARGB *)(a1 + 208), kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
              if (!Conversion)
              {
LABEL_45:
                v21 = *(_BYTE **)v55;
                if (*(_BYTE *)(*(_QWORD *)buf + 8))
                {
                  if (!*(_QWORD *)v55)
                    goto LABEL_53;
                  *(_QWORD *)v65 = **(_QWORD **)buf;
                  (*(void (**)(void))(**(_QWORD **)v55 + 48))();
                  v21 = *(_BYTE **)v55;
                }
                if (v21 == &buf[8])
                {
                  v22 = 4;
                  v21 = &buf[8];
                }
                else
                {
                  if (!v21)
                    goto LABEL_53;
                  v22 = 5;
                }
                (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_53:
                if ((v17 & 1) == 0)
                  goto LABEL_75;
                goto LABEL_54;
              }
              if (*(_BYTE *)(a1 + 336))
                *(_BYTE *)(a1 + 336) = 0;
              if (qword_1EDB89F90 != -1)
                dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
              v19 = qword_1EDB89F98;
              if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v65 = 134349056;
                *(_QWORD *)&v65[4] = Conversion;
                _os_log_error_impl(&dword_1D3D6B000, v19, OS_LOG_TYPE_ERROR, "vImageConvert_YpCbCrToARGB_GenerateConversion failed with vImage_Error: %{public}zd", v65, 0xCu);
              }
            }
            else
            {
              if (*(_BYTE *)(a1 + 192))
                *(_BYTE *)(a1 + 192) = 0;
              if (qword_1EDB89F90 != -1)
                dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
              v20 = qword_1EDB89F98;
              if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v65 = 134349056;
                *(_QWORD *)&v65[4] = Conversion;
                _os_log_error_impl(&dword_1D3D6B000, v20, OS_LOG_TYPE_ERROR, "vImageConvert_YpCbCrToARGB_GenerateConversion failed with vImage_Error: %{public}zd", v65, 0xCu);
              }
            }
            *(_QWORD *)v65 = -2003;
            v51 = CFSTR("vImageConvert_YpCbCrToARGB_GenerateConversion failed.");
            sub_1D3D73E0C((unint64_t *)a2, (uint64_t *)v65, (CFTypeRef *)&v51);
            v17 = 0;
            *(_QWORD *)(a2 + 32) = Conversion;
            *(_BYTE *)(a2 + 40) = 1;
            goto LABEL_45;
          }
          v15 = 5;
        }
        (*((void (**)(void))*v14 + v15))();
        goto LABEL_27;
      }
      v11 = 5;
    }
    v10 = (_QWORD *)(*(uint64_t (**)(void))(*v10 + 8 * v11))();
    goto LABEL_14;
  }
  return 1;
}

void sub_1D3DA5F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  sub_1D3D87C3C(&a26);
  _Unwind_Resume(a1);
}

BOOL sub_1D3DA5FA4(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL8 v12;
  _QWORD *v13;
  uint64_t v14;
  __CVBuffer *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v26;
  uint64_t v27;
  __CVBuffer *v28;
  OSType v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  __CVBuffer *v33;
  __CVBuffer *v34;
  __CVBuffer *v35;
  __CVBuffer *v36;
  __CVBuffer *v37;
  __CVBuffer *v38;
  __CVBuffer *v39;
  __CVBuffer *v40;
  __int128 v41;
  __int128 v42;
  double width;
  double height;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  _OWORD *v50;
  _OWORD *v51;
  __int128 v52;
  __int128 v53;
  double v54;
  double v55;
  vImagePixelCount *p_width;
  double v57;
  double v58;
  double v59;
  vImagePixelCount *p_height;
  double v61;
  void *v62;
  NSObject *v63;
  int v64;
  _QWORD *v65;
  uint64_t v66;
  __CVBuffer *v67;
  uint64_t v68;
  int v69;
  int v70;
  _QWORD *v71;
  uint64_t v72;
  const __CFString **v73;
  uint64_t v74;
  int v75;
  NSObject *v76;
  Pixel_8 *v77;
  int v78;
  Pixel_8 v79;
  int v80;
  void *v81;
  void *v82;
  size_t v83;
  NSObject *v84;
  void *v85;
  NSObject *v86;
  void *v87;
  NSObject *v88;
  NSObject *v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  NSObject *v93;
  __CVBuffer *v94;
  OSType PixelFormatType;
  int v96;
  NSObject *v97;
  vImagePixelCount v98;
  size_t v99;
  uint64_t v100;
  uint64_t v101;
  NSObject *v102;
  vImagePixelCount v103;
  size_t v104;
  uint64_t v105;
  uint64_t v106;
  NSObject *v107;
  vImage_Buffer *v108;
  uint64_t v109;
  BOOL v110;
  vImagePixelCount v111;
  vImagePixelCount v112;
  vImagePixelCount v113;
  vImagePixelCount v114;
  vImagePixelCount v115;
  uint64_t v116;
  uint64_t v117;
  size_t v118;
  vImagePixelCount v119;
  NSObject *v120;
  vImagePixelCount v121;
  vImagePixelCount i;
  vImagePixelCount v123;
  vImagePixelCount v124;
  size_t v125;
  NSObject *v126;
  NSObject *v127;
  const vImage_YpCbCrToARGB *v128;
  vImage_Buffer *p_dest;
  vImage_Error v130;
  NSObject *v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t *v134;
  char v135;
  uint8_t color[8];
  vImage_Buffer v137;
  vImage_Buffer dest;
  vImage_Buffer v139;
  vImage_Buffer src;
  _QWORD v141[3];
  _QWORD *v142;
  _QWORD v143[3];
  _QWORD *v144;
  uint64_t v145;
  _QWORD v146[3];
  _QWORD *v147;
  _BYTE v148[12];
  vImage_Buffer v149;
  vImage_Buffer buf;
  _BYTE v151[10];
  __int16 v152;
  uint64_t v153;
  _BYTE v154[24];
  _BYTE *v155;
  const __CFString *v156;
  _QWORD v157[2];
  CFTypeRef *v158;
  _QWORD *v159;
  _QWORD v160[3];
  _QWORD *v161;
  uint64_t v162;

  v162 = *MEMORY[0x1E0C80C00];
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if ((v8 & 1) == 0)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v11 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "ANMDImagePreprocessor_Accelerate_32BGRA is not ready.", (uint8_t *)&buf, 2u);
    }
    buf.data = (void *)-6008;
    v156 = CFSTR("ANMDImagePreprocessor_Accelerate_32BGRA is not ready.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&buf, (CFTypeRef *)&v156);
    return 0;
  }
  v144 = v143;
  v145 = a4;
  v141[0] = &off_1E95B27C0;
  v142 = v141;
  v143[0] = &off_1E95B2740;
  v147 = v146;
  v146[0] = &off_1E95B27C0;
  if (!*(_BYTE *)(a4 + 8)
    || (buf.data = *(void **)a4, sub_1D3DA75C8(v8, (os_signpost_id_t *)&buf), v9 = v142, v142 == v141))
  {
    v10 = 4;
    v9 = v141;
  }
  else
  {
    if (!v142)
      goto LABEL_13;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_13:
  v13 = v144;
  if (v144 == v143)
  {
    v14 = 4;
    v13 = v143;
  }
  else
  {
    if (!v144)
      goto LABEL_18;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_18:
  if (!atomic_load(a2))
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v20 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v20, OS_LOG_TYPE_ERROR, "Missing pixel buffer.", (uint8_t *)&buf, 2u);
    }
    buf.data = (void *)-6008;
    v156 = CFSTR("Missing pixel buffer.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&buf, (CFTypeRef *)&v156);
    goto LABEL_39;
  }
  v16 = (__CVBuffer *)atomic_load(a2);
  if ((CVPixelBufferGetPixelFormatType(v16) | 0x10) != 0x34323076)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v21 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      v94 = (__CVBuffer *)atomic_load(a2);
      PixelFormatType = CVPixelBufferGetPixelFormatType(v94);
      LODWORD(buf.data) = 67240192;
      HIDWORD(buf.data) = PixelFormatType;
      _os_log_error_impl(&dword_1D3D6B000, v21, OS_LOG_TYPE_ERROR, "Unsupported pixel format: %{public}u", (uint8_t *)&buf, 8u);
    }
    buf.data = (void *)-2001;
    v156 = CFSTR("Unsupported pixel format.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&buf, (CFTypeRef *)&v156);
    goto LABEL_39;
  }
  v134 = a2;
  v17 = sub_1D3DE79DC(a2, a3);
  v135 = v17;
  if ((v17 & 1) == 0)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v22 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      v96 = *(_DWORD *)(a3 + 24);
      LODWORD(buf.data) = 67240192;
      HIDWORD(buf.data) = v96;
      _os_log_error_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&buf, 8u);
    }
LABEL_39:
    v12 = 0;
    goto LABEL_40;
  }
  v161 = v160;
  *(_QWORD *)v154 = &off_1E95B28C0;
  v155 = v154;
  v156 = (const __CFString *)a4;
  v159 = v157;
  v160[0] = &off_1E95B2840;
  v157[0] = &off_1E95B28C0;
  if (!*(_BYTE *)(a4 + 8)
    || (buf.data = *(void **)a4, sub_1D3DA7668(v17, (os_signpost_id_t *)&buf), v18 = v155, v155 == v154))
  {
    v19 = 4;
    v18 = v154;
  }
  else
  {
    if (!v155)
      goto LABEL_51;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_51:
  v26 = v161;
  if (v161 == v160)
  {
    v27 = 4;
    v26 = v160;
  }
  else
  {
    if (!v161)
      goto LABEL_56;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_56:
  v28 = (__CVBuffer *)atomic_load(a2);
  v29 = CVPixelBufferGetPixelFormatType(v28);
  if (v29 == 875704438)
  {
    v30 = (unint64_t)&unk_1D3E6EFC0;
    goto LABEL_60;
  }
  if (v29 == 875704422)
  {
    v30 = (unint64_t)&xmmword_1D3E756C8;
LABEL_60:
    v31 = v30 & 0xFFFFFFFFFFFFFF00;
    v32 = v30;
    goto LABEL_62;
  }
  v32 = 0;
  v31 = 0;
LABEL_62:
  v33 = (__CVBuffer *)atomic_load(a2);
  src.data = CVPixelBufferGetBaseAddressOfPlane(v33, 0);
  v34 = (__CVBuffer *)atomic_load(a2);
  src.height = CVPixelBufferGetHeightOfPlane(v34, 0);
  v35 = (__CVBuffer *)atomic_load(a2);
  src.width = CVPixelBufferGetWidthOfPlane(v35, 0);
  v36 = (__CVBuffer *)atomic_load(a2);
  v133 = v32;
  src.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(v36, 0);
  v37 = (__CVBuffer *)atomic_load(a2);
  v139.data = CVPixelBufferGetBaseAddressOfPlane(v37, 1uLL);
  v38 = (__CVBuffer *)atomic_load(a2);
  v139.height = CVPixelBufferGetHeightOfPlane(v38, 1uLL);
  v39 = (__CVBuffer *)atomic_load(a2);
  v139.width = CVPixelBufferGetWidthOfPlane(v39, 1uLL);
  v40 = (__CVBuffer *)atomic_load(a2);
  v139.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(v40, 1uLL);
  v41 = *(_OWORD *)(a1 + 368);
  *(_OWORD *)&dest.data = *(_OWORD *)(a1 + 352);
  *(_OWORD *)&dest.width = v41;
  v42 = *(_OWORD *)(a1 + 408);
  *(_OWORD *)&v137.data = *(_OWORD *)(a1 + 392);
  *(_OWORD *)&v137.width = v42;
  *(_BYTE *)(a1 + 28) = 0;
  width = (double)dest.width;
  height = (double)dest.height;
  v45 = (double)dest.width / (double)dest.height;
  if (vabdd_f64(1.0, v45) >= 2.22044605e-16)
  {
    v46 = (double)src.width / (double)src.height;
    v47 = 1.0 / v46;
    if (v46 <= v45)
    {
      v49 = ceil(v46 * height);
      if (v46 >= v45)
        v49 = (double)dest.width;
      v48 = (double)dest.height;
    }
    else
    {
      v48 = ceil(width / v46);
      v49 = (double)dest.width;
    }
    if (v47 <= v45)
    {
      if (v47 < v45)
        width = ceil(v47 * height);
    }
    else
    {
      height = ceil(width / v47);
    }
    if (v49 * v48 < width * height)
    {
      v132 = v31;
      v50 = (_OWORD *)(a1 + 472);
      if (!*(_BYTE *)(a1 + 504))
      {
        *v50 = 0u;
        *(_OWORD *)(a1 + 488) = 0u;
        *(_BYTE *)(a1 + 504) = 1;
        v85 = (void *)vImageBuffer_Init((vImage_Buffer *)(a1 + 472), *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), 8u, 0);
        if (v85)
        {
          if (*(_BYTE *)(a1 + 504))
            *(_BYTE *)(a1 + 504) = 0;
          if (qword_1EDB89F20 != -1)
            dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
          v86 = qword_1EDB89F78;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_INFO))
          {
            LODWORD(buf.data) = 134349056;
            *(void **)((char *)&buf.data + 4) = v85;
            _os_log_impl(&dword_1D3D6B000, v86, OS_LOG_TYPE_INFO, "vImageBuffer_Init failed for 90CW_420Yp8: %{public}zd", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          if (qword_1EDB89F20 != -1)
            dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
          v97 = qword_1EDB89F78;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
          {
            v98 = *(_QWORD *)(a1 + 472);
            v99 = *(_QWORD *)(a1 + 480);
            v100 = *(_QWORD *)(a1 + 488);
            v101 = *(_QWORD *)(a1 + 496);
            LODWORD(buf.data) = 136447234;
            *(void **)((char *)&buf.data + 4) = "90CW_420Yp8";
            WORD2(buf.height) = 2050;
            *(vImagePixelCount *)((char *)&buf.height + 6) = v98;
            HIWORD(buf.width) = 2050;
            buf.rowBytes = v99;
            *(_WORD *)v151 = 2050;
            *(_QWORD *)&v151[2] = v100;
            v152 = 2050;
            v153 = v101;
            _os_log_debug_impl(&dword_1D3D6B000, v97, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", (uint8_t *)&buf, 0x34u);
          }
        }
      }
      v51 = (_OWORD *)(a1 + 512);
      if (!*(_BYTE *)(a1 + 544))
      {
        *v51 = 0u;
        *(_OWORD *)(a1 + 528) = 0u;
        *(_BYTE *)(a1 + 544) = 1;
        v87 = (void *)vImageBuffer_Init((vImage_Buffer *)(a1 + 512), *(_QWORD *)(a1 + 8) >> 1, *(_QWORD *)(a1 + 16) >> 1, 0x10u, 0);
        if (v87)
        {
          if (*(_BYTE *)(a1 + 544))
            *(_BYTE *)(a1 + 544) = 0;
          if (qword_1EDB89F20 != -1)
            dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
          v88 = qword_1EDB89F78;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_INFO))
          {
            LODWORD(buf.data) = 134349056;
            *(void **)((char *)&buf.data + 4) = v87;
            _os_log_impl(&dword_1D3D6B000, v88, OS_LOG_TYPE_INFO, "vImageBuffer_Init failed for 90CW_420CbCr8: %{public}zd", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          if (qword_1EDB89F20 != -1)
            dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
          v102 = qword_1EDB89F78;
          if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
          {
            v103 = *(_QWORD *)(a1 + 512);
            v104 = *(_QWORD *)(a1 + 520);
            v105 = *(_QWORD *)(a1 + 528);
            v106 = *(_QWORD *)(a1 + 536);
            LODWORD(buf.data) = 136447234;
            *(void **)((char *)&buf.data + 4) = "90CW_420CbCr8";
            WORD2(buf.height) = 2050;
            *(vImagePixelCount *)((char *)&buf.height + 6) = v103;
            HIWORD(buf.width) = 2050;
            buf.rowBytes = v104;
            *(_WORD *)v151 = 2050;
            *(_QWORD *)&v151[2] = v105;
            v152 = 2050;
            v153 = v106;
            _os_log_debug_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", (uint8_t *)&buf, 0x34u);
          }
        }
      }
      v31 = v132;
      if (*(_BYTE *)(a1 + 504) && *(_BYTE *)(a1 + 544))
      {
        *(_BYTE *)(a1 + 28) = 1;
        v52 = *(_OWORD *)(a1 + 488);
        *(_OWORD *)&dest.data = *v50;
        *(_OWORD *)&dest.width = v52;
        v53 = *(_OWORD *)(a1 + 528);
        *(_OWORD *)&v137.data = *v51;
        *(_OWORD *)&v137.width = v53;
      }
    }
  }
  v54 = (double)src.width / (double)src.height;
  v55 = (double)dest.width / (double)dest.height;
  if (v54 <= v55)
  {
    if (v54 >= v55)
      goto LABEL_83;
    p_width = &dest.width;
    v57 = v54 * (double)dest.height;
  }
  else
  {
    p_width = &dest.height;
    v57 = (double)dest.width / v54;
  }
  *p_width = vcvtpd_u64_f64(v57);
LABEL_83:
  v58 = (double)v139.width / (double)v139.height;
  v59 = (double)v137.width / (double)v137.height;
  if (v58 > v59)
  {
    p_height = &v137.height;
    v61 = (double)v137.width / v58;
LABEL_87:
    *p_height = vcvtpd_u64_f64(v61);
    goto LABEL_88;
  }
  if (v58 < v59)
  {
    p_height = &v137.width;
    v61 = v58 * (double)v137.height;
    goto LABEL_87;
  }
LABEL_88:
  v62 = (void *)vImageScale_Planar8(&src, &dest, 0, 0);
  if (v62 || (v62 = (void *)vImageScale_CbCr8(&v139, &v137, 0, 0)) != 0)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v63 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.data) = 134349056;
      *(void **)((char *)&buf.data + 4) = v62;
      _os_log_error_impl(&dword_1D3D6B000, v63, OS_LOG_TYPE_ERROR, "vImageScale_{Planar8,CbCr8} failed: %{public}zd", (uint8_t *)&buf, 0xCu);
    }
    buf.data = (void *)-2004;
    v149.data = CFSTR("vImageScale_{Planar8,CbCr8} failed.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&buf, (CFTypeRef *)&v149.data);
    goto LABEL_95;
  }
  v77 = (Pixel_8 *)(v31 | v133);
  v78 = *(unsigned __int8 *)(a1 + 28);
  if (*(_BYTE *)(a1 + 28))
  {
    v79 = *v77;
    v80 = *(_DWORD *)((v31 | v133) + 4);
    v81 = *(void **)(a1 + 352);
    *(int8x16_t *)&buf.height = vextq_s8(*(int8x16_t *)&dest.height, *(int8x16_t *)&dest.height, 8uLL);
    buf.rowBytes = *(_QWORD *)(a1 + 376);
    v82 = *(void **)(a1 + 392);
    *(int8x16_t *)&v149.height = vextq_s8(*(int8x16_t *)&v137.height, *(int8x16_t *)&v137.height, 8uLL);
    v83 = *(_QWORD *)(a1 + 416);
    v149.data = v82;
    v149.rowBytes = v83;
    buf.data = v81;
    v62 = (void *)vImageRotate90_Planar8(&dest, &buf, 3u, v79, 0);
    if (v62
      || (v62 = (void *)vImageRotate90_Planar16U(&v137, &v149, 3u, (unsigned __int16)v80 | (unsigned __int16)((_WORD)v80 << 8), 0)) != 0)
    {
      if (qword_1EDB89F20 != -1)
        dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
      v84 = qword_1EDB89F78;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v148 = 134349056;
        *(_QWORD *)&v148[4] = v62;
        _os_log_error_impl(&dword_1D3D6B000, v84, OS_LOG_TYPE_ERROR, "vImageRotate90_{Planar8,Planar16U} failed: %{public}zd", v148, 0xCu);
      }
      *(_QWORD *)v148 = -2004;
      *(_QWORD *)color = CFSTR("vImageRotate90_{Planar8,Planar16U} failed.");
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v148, (CFTypeRef *)color);
      goto LABEL_95;
    }
    v78 = *(unsigned __int8 *)(a1 + 28);
  }
  v110 = v78 == 0;
  if (v78)
    v111 = dest.height;
  else
    v111 = dest.width;
  if (v78)
    v112 = dest.width;
  else
    v112 = dest.height;
  *(_QWORD *)(a1 + 32) = v111;
  *(_QWORD *)(a1 + 40) = v112;
  v113 = v137.height;
  if (v110)
    v114 = v137.width;
  else
    v114 = v137.height;
  if (!v110)
    v113 = v137.width;
  *(_QWORD *)(a1 + 48) = v114;
  *(_QWORD *)(a1 + 56) = v113;
  v115 = *(_QWORD *)(a1 + 360);
  if (v112 >= v115)
  {
    v121 = *(_QWORD *)(a1 + 368);
    if (v111 < v121)
    {
      if (v115)
      {
        for (i = 0; i < v115; ++i)
        {
          v123 = *(_QWORD *)(a1 + 32);
          if (v123 < v121)
          {
            do
            {
              *(_BYTE *)(*(_QWORD *)(a1 + 352) + i * *(_QWORD *)(a1 + 376) + v123++) = *(_DWORD *)v77;
              v121 = *(_QWORD *)(a1 + 368);
            }
            while (v123 < v121);
            v115 = *(_QWORD *)(a1 + 360);
          }
        }
        v114 = *(_QWORD *)(a1 + 48);
      }
      v124 = *(_QWORD *)(a1 + 400);
      buf.data = (void *)(*(_QWORD *)(a1 + 392) + 2 * v114);
      buf.height = v124;
      v125 = *(_QWORD *)(a1 + 416);
      buf.width = *(_QWORD *)(a1 + 408) - v114;
      buf.rowBytes = v125;
      color[0] = v77[4];
      color[1] = color[0];
      v62 = (void *)vImageBufferFill_CbCr8(&buf, color, 0);
      if (v62)
      {
        if (qword_1EDB89F20 != -1)
          dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
        v126 = qword_1EDB89F78;
        if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v149.data) = 134349056;
          *(void **)((char *)&v149.data + 4) = v62;
          _os_log_error_impl(&dword_1D3D6B000, v126, OS_LOG_TYPE_ERROR, "vImageBufferFill_CbCr8 failed: %{public}zd", (uint8_t *)&v149, 0xCu);
        }
        goto LABEL_214;
      }
    }
  }
  else
  {
    do
      memset((void *)(*(_QWORD *)(a1 + 352) + *(_QWORD *)(a1 + 376) * v112++), *(_DWORD *)v77, *(_QWORD *)(a1 + 376));
    while (v112 < *(_QWORD *)(a1 + 360));
    v116 = *(_QWORD *)(a1 + 56);
    v117 = *(_QWORD *)(a1 + 400);
    v119 = *(_QWORD *)(a1 + 408);
    v118 = *(_QWORD *)(a1 + 416);
    buf.data = (void *)(*(_QWORD *)(a1 + 392) + v118 * v116);
    buf.height = v117 - v116;
    buf.width = v119;
    buf.rowBytes = v118;
    color[0] = v77[4];
    color[1] = color[0];
    v62 = (void *)vImageBufferFill_CbCr8(&buf, color, 0);
    if (v62)
    {
      if (qword_1EDB89F20 != -1)
        dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
      v120 = qword_1EDB89F78;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v149.data) = 134349056;
        *(void **)((char *)&v149.data + 4) = v62;
        _os_log_error_impl(&dword_1D3D6B000, v120, OS_LOG_TYPE_ERROR, "vImageBufferFill_CbCr8 failed: %{public}zd", (uint8_t *)&v149, 0xCu);
      }
LABEL_214:
      v149.data = (void *)-2004;
      *(_QWORD *)v148 = CFSTR("vImageBufferFill_CbCr8 failed.");
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&v149, (CFTypeRef *)v148);
LABEL_95:
      v64 = 0;
      *(_QWORD *)(a3 + 32) = v62;
      *(_BYTE *)(a3 + 40) = 1;
      goto LABEL_96;
    }
  }
  v64 = 1;
LABEL_96:
  v65 = v159;
  if (LOBYTE(v156->info))
  {
    if (!v159)
      goto LABEL_104;
    buf.data = v156->isa;
    (*(void (**)(void))(*v159 + 48))();
    v65 = v159;
  }
  if (v65 == v157)
  {
    v66 = 4;
    v65 = v157;
  }
  else
  {
    if (!v65)
      goto LABEL_104;
    v66 = 5;
  }
  (*(void (**)(void))(*v65 + 8 * v66))();
LABEL_104:
  if (!v64)
  {
    v12 = 0;
LABEL_194:
    sub_1D3DE793C(a2, a3);
    goto LABEL_40;
  }
  v67 = (__CVBuffer *)atomic_load(a2);
  v68 = CVPixelBufferGetPixelFormatType(v67);
  v69 = v68;
  v70 = *(_DWORD *)(a1 + 24);
  v156 = (const __CFString *)&off_1E95ADA48;
  v158 = (CFTypeRef *)&v156;
  v160[0] = &off_1E95ADAA0;
  v161 = v160;
  *(_QWORD *)v151 = &buf.height;
  buf.data = (void *)a4;
  buf.height = (vImagePixelCount)&off_1E95ADAA0;
  if (!*(_BYTE *)(a4 + 8)
    || (*(_QWORD *)v154 = *(_QWORD *)a4, sub_1D3E0EF78(v68, (os_signpost_id_t *)v154), v71 = v161, v161 == v160))
  {
    v72 = 4;
    v71 = v160;
  }
  else
  {
    if (!v161)
      goto LABEL_112;
    v72 = 5;
  }
  (*(void (**)(void))(*v71 + 8 * v72))();
LABEL_112:
  v73 = (const __CFString **)v158;
  if (v158 == (CFTypeRef *)&v156)
  {
    v74 = 4;
    v73 = &v156;
    goto LABEL_116;
  }
  if (v158)
  {
    v74 = 5;
LABEL_116:
    (*((void (**)(void))&(*v73)->isa + v74))();
  }
  if (!*(_BYTE *)(a1 + 192) || !*(_BYTE *)(a1 + 336))
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v76 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v154 = 0;
      _os_log_error_impl(&dword_1D3D6B000, v76, OS_LOG_TYPE_ERROR, "YpCbCrToRGBImageConverter is not ready.", v154, 2u);
    }
    *(_QWORD *)v154 = -2005;
    src.data = CFSTR("YpCbCrToRGBImageConverter is not ready.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v154, (CFTypeRef *)&src.data);
    goto LABEL_183;
  }
  if ((v69 | 0x10) != 0x34323076)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v89 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v154 = 67240192;
      *(_DWORD *)&v154[4] = v69;
      _os_log_error_impl(&dword_1D3D6B000, v89, OS_LOG_TYPE_ERROR, "Unsupported input pixel format type: %{public}u", v154, 8u);
    }
    *(_QWORD *)v154 = -2001;
    src.data = CFSTR("Unsupported input pixel format type.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v154, (CFTypeRef *)&src.data);
    goto LABEL_183;
  }
  if (v70 > 1111970368)
  {
    if (v70 == 1111970369)
      goto LABEL_158;
    v75 = 1380401729;
  }
  else
  {
    if (v70 == 32)
      goto LABEL_158;
    v75 = 1094862674;
  }
  if (v70 != v75)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v107 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v154 = 67240192;
      *(_DWORD *)&v154[4] = v70;
      _os_log_error_impl(&dword_1D3D6B000, v107, OS_LOG_TYPE_ERROR, "Unsupported output pixel format type: %{public}u", v154, 8u);
    }
    *(_QWORD *)v154 = -2001;
    src.data = CFSTR("Unsupported output pixel format type.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v154, (CFTypeRef *)&src.data);
    goto LABEL_183;
  }
LABEL_158:
  if (!*(_QWORD *)(a1 + 352)
    || (v90 = *(_QWORD *)(a1 + 360)) == 0
    || (v91 = *(_QWORD *)(a1 + 368), v91 - 1 >= *(_QWORD *)(a1 + 376))
    || !*(_QWORD *)(a1 + 392)
    || *(_QWORD *)(a1 + 400) != v90 >> 1
    || (v92 = *(_QWORD *)(a1 + 408), v92 != v91 >> 1)
    || *(_QWORD *)(a1 + 416) < (unint64_t)(2 * v92))
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v93 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v154 = 0;
      _os_log_error_impl(&dword_1D3D6B000, v93, OS_LOG_TYPE_ERROR, "Invalid input image buffer.", v154, 2u);
    }
    *(_QWORD *)v154 = -2005;
    src.data = CFSTR("Invalid input image buffer.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v154, (CFTypeRef *)&src.data);
LABEL_183:
    v12 = 0;
    goto LABEL_184;
  }
  if (!*(_QWORD *)(a1 + 432)
    || *(_QWORD *)(a1 + 440) != v90
    || *(_QWORD *)(a1 + 448) != v91
    || *(_QWORD *)(a1 + 456) < 4 * v91)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v127 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v154 = 0;
      _os_log_error_impl(&dword_1D3D6B000, v127, OS_LOG_TYPE_ERROR, "Invalid output image buffer.", v154, 2u);
    }
    *(_QWORD *)v154 = -2005;
    src.data = CFSTR("Invalid output image buffer.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v154, (CFTypeRef *)&src.data);
    goto LABEL_183;
  }
  if (v69 == 875704438)
    v128 = (const vImage_YpCbCrToARGB *)(a1 + 64);
  else
    v128 = (const vImage_YpCbCrToARGB *)(a1 + 208);
  LODWORD(v139.data) = 50462976;
  LODWORD(dest.data) = 66051;
  LODWORD(v137.data) = 16909056;
  LODWORD(v149.data) = 197121;
  if (v70 > 1111970368)
  {
    if (v70 == 1380401729)
      p_dest = &v149;
    else
      p_dest = &dest;
  }
  else if (v70 == 32)
  {
    p_dest = &v139;
  }
  else
  {
    p_dest = &v137;
  }
  v130 = vImageConvert_420Yp8_CbCr8ToARGB8888((const vImage_Buffer *)(a1 + 352), (const vImage_Buffer *)(a1 + 392), (const vImage_Buffer *)(a1 + 432), v128, (const uint8_t *)p_dest, 0xFFu, 0);
  v12 = v130 == 0;
  if (v130)
  {
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v131 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v154 = 134349056;
      *(_QWORD *)&v154[4] = v130;
      _os_log_error_impl(&dword_1D3D6B000, v131, OS_LOG_TYPE_ERROR, "vImageConvert_420Yp8_CbCr8ToARGB8888 failed: %{public}zd", v154, 0xCu);
    }
    *(_QWORD *)v154 = -2005;
    src.data = CFSTR("vImageConvert_420Yp8_CbCr8ToARGB8888 failed.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v154, (CFTypeRef *)&src.data);
    *(_QWORD *)(a3 + 32) = v130;
    *(_BYTE *)(a3 + 40) = 1;
  }
LABEL_184:
  v108 = *(vImage_Buffer **)v151;
  if (*((_BYTE *)buf.data + 8))
  {
    if (!*(_QWORD *)v151)
      goto LABEL_192;
    *(_QWORD *)v154 = *(_QWORD *)buf.data;
    (*(void (**)(void))(**(_QWORD **)v151 + 48))();
    v108 = *(vImage_Buffer **)v151;
  }
  if (v108 == (vImage_Buffer *)&buf.height)
  {
    v109 = 4;
    v108 = (vImage_Buffer *)&buf.height;
  }
  else
  {
    if (!v108)
      goto LABEL_192;
    v109 = 5;
  }
  (*((void (**)(void))v108->data + v109))();
LABEL_192:
  if (v135)
  {
    a2 = v134;
    goto LABEL_194;
  }
LABEL_40:
  v23 = v147;
  if (*(_BYTE *)(v145 + 8))
  {
    if (!v147)
      return v12;
    buf.data = *(void **)v145;
    (*(void (**)(void))(*v147 + 48))();
    v23 = v147;
  }
  if (v23 == v146)
  {
    v24 = 4;
    v23 = v146;
    goto LABEL_47;
  }
  if (v23)
  {
    v24 = 5;
LABEL_47:
    (*(void (**)(void))(*v23 + 8 * v24))();
  }
  return v12;
}

void sub_1D3DA7510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  sub_1D3D87C3C(&a53);
  sub_1D3D95674((uint64_t)&a13);
  sub_1D3D87C3C(&a42);
  _Unwind_Resume(a1);
}

void sub_1D3DA75C0()
{
  JUMPOUT(0x1D3DA75B8);
}

void sub_1D3DA75C8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DA7668(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::resampleAndRotateIfNeeded_", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DA770C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA7720()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B28C0;
  return result;
}

void sub_1D3DA7744(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B28C0;
}

void sub_1D3DA775C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::resampleAndRotateIfNeeded_", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DA77FC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA26resampleAndRotateIfNeeded_ERKNS_6Sample11PixelBufferERKNS3_21ScopedPixelBufferLockILb1EEERNSt3__18optionalINS_5ErrorEEERKNSC_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA7834()
{
  return &unk_1E95B2920;
}

void sub_1D3DA7844()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA7858()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2840;
  return result;
}

void sub_1D3DA787C(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2840;
}

uint64_t sub_1D3DA7894(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA26resampleAndRotateIfNeeded_ERKNS_6Sample11PixelBufferERKNS3_21ScopedPixelBufferLockILb1EEERNSt3__18optionalINS_5ErrorEEERKNSC_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA78CC()
{
  return &unk_1E95B28A0;
}

void sub_1D3DA78DC()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA78F0()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B27C0;
  return result;
}

void sub_1D3DA7914(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B27C0;
}

void sub_1D3DA792C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DA79CC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA7A04()
{
  return &unk_1E95B2820;
}

void sub_1D3DA7A14()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA7A28()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2740;
  return result;
}

void sub_1D3DA7A4C(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2740;
}

uint64_t sub_1D3DA7A64(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA7A9C()
{
  return &unk_1E95B27A0;
}

void sub_1D3DA7AA8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DA7B4C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA7B60()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B26C0;
  return result;
}

void sub_1D3DA7B84(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B26C0;
}

void sub_1D3DA7B9C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DA7C3C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA7C74()
{
  return &unk_1E95B2720;
}

void sub_1D3DA7C84()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA7C98()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2640;
  return result;
}

void sub_1D3DA7CBC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2640;
}

uint64_t sub_1D3DA7CD4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA7D0C()
{
  return &unk_1E95B26A0;
}

uint64_t sub_1D3DA7D18(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95B24F0;
  if (*(_BYTE *)(a1 + 384))
    free(*(void **)(a1 + 352));
  if (*(_BYTE *)(a1 + 424))
    free(*(void **)(a1 + 392));
  if (*(_BYTE *)(a1 + 464))
    free(*(void **)(a1 + 432));
  if (*(_BYTE *)(a1 + 504))
    free(*(void **)(a1 + 472));
  if (*(_BYTE *)(a1 + 544))
    free(*(void **)(a1 + 512));
  return a1;
}

uint64_t sub_1D3DA7D94(uint64_t a1)
{
  sub_1D3D74EDC((unint64_t *)(a1 + 680));
  sub_1D3D982CC((unint64_t *)(a1 + 672));
  return sub_1D3DA7D18(a1);
}

void sub_1D3DA7DC4(uint64_t a1)
{
  sub_1D3D74EDC((unint64_t *)(a1 + 680));
  sub_1D3D982CC((unint64_t *)(a1 + 672));
  sub_1D3DA7D18(a1);
  JUMPOUT(0x1D8254C54);
}

BOOL sub_1D3DA7E08(uint64_t a1)
{
  unint64_t v1;

  if (!*(_BYTE *)(a1 + 192)
    || !*(_BYTE *)(a1 + 336)
    || !*(_BYTE *)(a1 + 384)
    || !*(_BYTE *)(a1 + 424)
    || !*(_BYTE *)(a1 + 464))
  {
    return 0;
  }
  v1 = atomic_load((unint64_t *)(a1 + 672));
  return v1 != 0;
}

uint64_t sub_1D3DA7E4C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v14;
  const void *v15;
  _QWORD *v17;
  uint64_t v18;
  CVPixelBufferPoolRef v20;
  _QWORD v21[3];
  _QWORD *v22;
  _QWORD v23[3];
  _QWORD *v24;
  uint64_t v25;
  _QWORD v26[3];
  _QWORD *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 192)
    || !*(_BYTE *)(a1 + 336)
    || !*(_BYTE *)(a1 + 384)
    || !*(_BYTE *)(a1 + 424)
    || !*(_BYTE *)(a1 + 464)
    || (v6 = atomic_load((unint64_t *)(a1 + 672))) == 0)
  {
    v24 = v23;
    v25 = a3;
    v21[0] = &off_1E95B29C0;
    v22 = v21;
    v23[0] = &off_1E95B2940;
    v27 = v26;
    v26[0] = &off_1E95B29C0;
    if (!*(_BYTE *)(a3 + 8)
      || (v20 = *(CVPixelBufferPoolRef *)a3, sub_1D3DA91A4(a1, (os_signpost_id_t *)&v20), v8 = v22, v22 == v21))
    {
      v9 = 4;
      v8 = v21;
    }
    else
    {
      if (!v22)
        goto LABEL_14;
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_14:
    v10 = v24;
    if (v24 == v23)
    {
      v11 = 4;
      v10 = v23;
    }
    else
    {
      if (!v24)
      {
        if ((sub_1D3DA5450(a1, (uint64_t)a2, a3) & 1) == 0)
          goto LABEL_28;
LABEL_19:
        v12 = (unint64_t *)(a1 + 672);
        if (atomic_load((unint64_t *)(a1 + 672)))
          goto LABEL_27;
        sub_1D3DF3500(&v20, a1 + 552, a2);
        do
          v14 = __ldaxr((unint64_t *)&v20);
        while (__stlxr(0, (unint64_t *)&v20));
        do
          v15 = (const void *)__ldaxr(v12);
        while (__stlxr(v14, v12));
        if (v15)
          CFRelease(v15);
        sub_1D3D982CC((unint64_t *)&v20);
        if (atomic_load(v12))
LABEL_27:
          v7 = 1;
        else
LABEL_28:
          v7 = 0;
        v17 = v27;
        if (*(_BYTE *)(v25 + 8))
        {
          if (!v27)
            return v7;
          v20 = *(CVPixelBufferPoolRef *)v25;
          (*(void (**)(void))(*v27 + 48))();
          v17 = v27;
        }
        if (v17 == v26)
        {
          v18 = 4;
          v17 = v26;
        }
        else
        {
          if (!v17)
            return v7;
          v18 = 5;
        }
        (*(void (**)(void))(*v17 + 8 * v18))();
        return v7;
      }
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
    goto LABEL_19;
  }
  return 1;
}

void sub_1D3DA8064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  unint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  sub_1D3D982CC((unint64_t *)va);
  sub_1D3D87C3C((uint64_t *)va1);
  _Unwind_Resume(a1);
}

BOOL sub_1D3DA809C(uint64_t a1, unint64_t *a2, uint64_t a3, const __CFString *a4)
{
  unint64_t v6;
  _QWORD *v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL8 v12;
  _QWORD *v14;
  uint64_t v15;
  _BOOL8 v16;
  const vImage_Buffer *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  __CVBuffer *v23;
  NSObject *v24;
  NSObject *v25;
  __CVBuffer *v26;
  vImagePixelCount Width;
  __CVBuffer *v28;
  size_t Height;
  __CVBuffer *v30;
  OSType PixelFormatType;
  OSType v32;
  CFTypeRef v33;
  __CVBuffer *v34;
  char *BaseAddress;
  __CVBuffer *v36;
  size_t v37;
  vImage_Error v38;
  NSObject *v39;
  NSObject *v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  const void *v45;
  unint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  NSObject *v49;
  const vImage_Buffer *v50;
  void *data;
  NSObject *v52;
  vImage_Error v53;
  vImage_Error v54;
  int v55;
  void *v56;
  vImage_Error v57;
  unint64_t v58;
  void *v59;
  unint64_t v60;
  const __CFString *v61;
  vImage_Buffer red;
  vImage_Buffer green;
  vImage_Buffer blue;
  vImage_Buffer v65;
  vImage_Buffer v66;
  vImage_Buffer dest;
  CFTypeRef v68;
  uint64_t v69;
  char v70;
  CVPixelBufferRef v71;
  _QWORD v72[3];
  _QWORD *v73;
  _QWORD v74[3];
  _QWORD *v75;
  const __CFString *v76;
  _QWORD v77[3];
  _QWORD *v78;
  _BYTE buf[12];
  __int16 v80;
  void *v81;
  __int16 v82;
  vImagePixelCount v83;
  __int16 v84;
  vImagePixelCount v85;
  __int16 v86;
  size_t rowBytes;
  _QWORD v88[3];
  _QWORD *v89;
  _QWORD v90[3];
  _QWORD *v91;
  const __CFString *v92;
  _QWORD v93[3];
  _QWORD *v94;
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 192)
    || !*(_BYTE *)(a1 + 336)
    || !*(_BYTE *)(a1 + 384)
    || !*(_BYTE *)(a1 + 424)
    || !*(_BYTE *)(a1 + 464)
    || (v6 = atomic_load((unint64_t *)(a1 + 672))) == 0)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v11 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "ANMDImagePreprocessor_Accelerate is not ready.", buf, 2u);
    }
    *(_QWORD *)buf = -6008;
    v92 = CFSTR("ANMDImagePreprocessor_Accelerate is not ready.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v92);
    return 0;
  }
  v75 = v74;
  v76 = a4;
  v72[0] = &off_1E95B2AC0;
  v73 = v72;
  v74[0] = &off_1E95B2A40;
  v78 = v77;
  v77[0] = &off_1E95B2AC0;
  if (!LOBYTE(a4->info) || (*(_QWORD *)buf = a4->isa, sub_1D3DA8F34(a1, (os_signpost_id_t *)buf), v9 = v73, v73 == v72))
  {
    v10 = 4;
    v9 = v72;
  }
  else
  {
    if (!v73)
      goto LABEL_19;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_19:
  v14 = v75;
  if (v75 == v74)
  {
    v15 = 4;
    v14 = v74;
  }
  else
  {
    if (!v75)
      goto LABEL_24;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_24:
  v16 = sub_1D3DA5FA4(a1, a2, a3, (uint64_t)a4);
  if (v16)
  {
    if (*(_BYTE *)(a1 + 464))
      v17 = (const vImage_Buffer *)(a1 + 432);
    else
      v17 = 0;
    v91 = v90;
    v92 = a4;
    v88[0] = &off_1E95AC670;
    v89 = v88;
    v90[0] = &off_1E95AC618;
    v94 = v93;
    v93[0] = &off_1E95AC670;
    if (!LOBYTE(a4->info)
      || (*(_QWORD *)buf = a4->isa, sub_1D3DF3698(v16, (os_signpost_id_t *)buf), v18 = v89, v89 == v88))
    {
      v19 = 4;
      v18 = v88;
    }
    else
    {
      if (!v89)
        goto LABEL_35;
      v19 = 5;
    }
    (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_35:
    v20 = v91;
    if (v91 == v90)
    {
      v21 = 4;
      v20 = v90;
    }
    else
    {
      if (!v91)
        goto LABEL_40;
      v21 = 5;
    }
    (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_40:
    sub_1D3DD5F9C(&v71, (unint64_t *)(a1 + 672), a3);
    if (!atomic_load((unint64_t *)&v71))
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v25 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D3D6B000, v25, OS_LOG_TYPE_ERROR, "Failed to create input pixel buffer from pixel buffer pool", buf, 2u);
      }
      goto LABEL_69;
    }
    v23 = (__CVBuffer *)atomic_load((unint64_t *)&v71);
    if (CVPixelBufferIsPlanar(v23))
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v24 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D3D6B000, v24, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", buf, 2u);
      }
LABEL_68:
      *(_QWORD *)buf = -2001;
      dest.data = CFSTR("Invalid input pixel buffer.");
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&dest.data);
LABEL_69:
      v60 = 0;
      goto LABEL_70;
    }
    v26 = (__CVBuffer *)atomic_load((unint64_t *)&v71);
    Width = CVPixelBufferGetWidth(v26);
    v28 = (__CVBuffer *)atomic_load((unint64_t *)&v71);
    Height = CVPixelBufferGetHeight(v28);
    v30 = (__CVBuffer *)atomic_load((unint64_t *)&v71);
    PixelFormatType = CVPixelBufferGetPixelFormatType(v30);
    if (Width != *(_QWORD *)(a1 + 616)
      || Height != 3 * *(_QWORD *)(a1 + 608)
      || (v32 = PixelFormatType, PixelFormatType != 1278226534) && PixelFormatType != 1278226536)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v40 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D3D6B000, v40, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", buf, 2u);
      }
      goto LABEL_68;
    }
    v33 = (CFTypeRef)atomic_load((unint64_t *)&v71);
    if (v33)
      v33 = CFRetain(v33);
    v68 = v33;
    v69 = a3;
    v70 = sub_1D3DD48A0((unint64_t *)&v68, 0, a3);
    if ((v70 & 1) == 0)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v49 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        v55 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&buf[4] = v55;
        _os_log_error_impl(&dword_1D3D6B000, v49, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", buf, 8u);
      }
      goto LABEL_96;
    }
    v34 = (__CVBuffer *)atomic_load((unint64_t *)&v71);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(v34);
    v36 = (__CVBuffer *)atomic_load((unint64_t *)&v71);
    dest.data = BaseAddress;
    dest.height = Height / 3;
    dest.width = Width;
    dest.rowBytes = CVPixelBufferGetBytesPerRow(v36);
    v37 = dest.rowBytes * (Height / 3);
    v66.data = &BaseAddress[v37];
    v66.height = Height / 3;
    v66.width = Width;
    v66.rowBytes = dest.rowBytes;
    v65.data = &BaseAddress[2 * v37];
    v65.height = Height / 3;
    v65.width = Width;
    v65.rowBytes = dest.rowBytes;
    v38 = vImageBuffer_Init(&blue, Height / 3, Width, 8u, 0);
    if (v38)
    {
      if (qword_1EDB89F90 != -1)
        dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
      v39 = qword_1EDB89F98;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134349056;
        *(_QWORD *)&buf[4] = v38;
        _os_log_error_impl(&dword_1D3D6B000, v39, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
      *(_QWORD *)buf = -2003;
      green.data = CFSTR("vImageBuffer_Init failed.");
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&green.data);
      *(_QWORD *)(a3 + 32) = v38;
      *(_BYTE *)(a3 + 40) = 1;
LABEL_96:
      v60 = 0;
LABEL_97:
      if (v70)
        v70 = sub_1D3DD4A58((unint64_t *)&v68, 0, v69) ^ 1;
      sub_1D3D74EDC((unint64_t *)&v68);
LABEL_70:
      sub_1D3D74EDC((unint64_t *)&v71);
      v41 = v94;
      if (LOBYTE(v92->info))
      {
        if (!v94)
          goto LABEL_78;
        *(_QWORD *)buf = v92->isa;
        (*(void (**)(void))(*v94 + 48))();
        v41 = v94;
      }
      if (v41 == v93)
      {
        v42 = 4;
        v41 = v93;
      }
      else
      {
        if (!v41)
          goto LABEL_78;
        v42 = 5;
      }
      (*(void (**)(void))(*v41 + 8 * v42))();
LABEL_78:
      v43 = (unint64_t *)(a1 + 680);
      do
        v44 = __ldaxr(&v60);
      while (__stlxr(0, &v60));
      do
        v45 = (const void *)__ldaxr(v43);
      while (__stlxr(v44, v43));
      if (v45)
        CFRelease(v45);
      sub_1D3D74EDC(&v60);
      v46 = atomic_load(v43);
      v12 = v46 != 0;
      goto LABEL_84;
    }
    v50 = v17;
    data = blue.data;
    if (qword_1EDB89F90 != -1)
      dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
    v52 = qword_1EDB89F98;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "blueU8";
      v80 = 2050;
      v81 = data;
      v82 = 2050;
      v83 = blue.height;
      v84 = 2050;
      v85 = blue.width;
      v86 = 2050;
      rowBytes = blue.rowBytes;
      _os_log_debug_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
    v53 = vImageBuffer_Init(&green, v66.height, v66.width, 8u, 0);
    if (v53)
    {
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134349056;
        *(_QWORD *)&buf[4] = v53;
        _os_log_error_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
      *(_QWORD *)buf = -2003;
      red.data = CFSTR("vImageBuffer_Init failed.");
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&red.data);
      *(_QWORD *)(a3 + 32) = v53;
      *(_BYTE *)(a3 + 40) = 1;
      v60 = 0;
LABEL_138:
      if (data)
        free(data);
      goto LABEL_97;
    }
    v59 = green.data;
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "greenU8";
      v80 = 2050;
      v81 = v59;
      v82 = 2050;
      v83 = green.height;
      v84 = 2050;
      v85 = green.width;
      v86 = 2050;
      rowBytes = green.rowBytes;
      _os_log_debug_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
    v54 = vImageBuffer_Init(&red, v65.height, v65.width, 8u, 0);
    if (v54)
    {
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134349056;
        *(_QWORD *)&buf[4] = v54;
        _os_log_error_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
      *(_QWORD *)buf = -2003;
      v61 = CFSTR("vImageBuffer_Init failed.");
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v61);
      *(_QWORD *)(a3 + 32) = v54;
      *(_BYTE *)(a3 + 40) = 1;
      v60 = 0;
LABEL_136:
      if (v59)
        free(v59);
      goto LABEL_138;
    }
    v56 = red.data;
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "redU8";
      v80 = 2050;
      v81 = v56;
      v82 = 2050;
      v83 = red.height;
      v84 = 2050;
      v85 = red.width;
      v86 = 2050;
      rowBytes = red.rowBytes;
      _os_log_debug_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
    v57 = vImageConvert_BGRX8888ToPlanar8(v50, &blue, &green, &red, 0);
    if (v57)
    {
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134349056;
        *(_QWORD *)&buf[4] = v57;
        _os_log_error_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_ERROR, "vImageConvert_BGRX8888ToPlanar8 failed: %{public}zd", buf, 0xCu);
      }
      *(_QWORD *)buf = -2005;
      v61 = CFSTR("vImageConvert_BGRX8888ToPlanar8 failed.");
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v61);
LABEL_133:
      v58 = 0;
      *(_QWORD *)(a3 + 32) = v57;
      *(_BYTE *)(a3 + 40) = 1;
      goto LABEL_134;
    }
    if (v32 == 1278226536)
    {
      v57 = vImageConvert_Planar8toPlanar16F(&blue, &dest, 0);
      if (v57
        || (v57 = vImageConvert_Planar8toPlanar16F(&green, &v66, 0)) != 0
        || (v57 = vImageConvert_Planar8toPlanar16F(&red, &v65, 0)) != 0)
      {
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134349056;
          *(_QWORD *)&buf[4] = v57;
          _os_log_error_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_ERROR, "vImageConvert_Planar8toPlanar16F failed: %{public}zd", buf, 0xCu);
        }
        *(_QWORD *)buf = -2005;
        v61 = CFSTR("vImageConvert_Planar8toPlanar16F failed.");
        sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v61);
        goto LABEL_133;
      }
      sub_1D3DF3738((uint64_t *)&dest);
      sub_1D3DF3738((uint64_t *)&v66);
      sub_1D3DF3738((uint64_t *)&v65);
    }
    else
    {
      v57 = vImageConvert_Planar8toPlanarF(&blue, &dest, 255.0, 0.0, 0);
      if (v57
        || (v57 = vImageConvert_Planar8toPlanarF(&green, &v66, 255.0, 0.0, 0)) != 0
        || (v57 = vImageConvert_Planar8toPlanarF(&red, &v65, 255.0, 0.0, 0)) != 0)
      {
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134349056;
          *(_QWORD *)&buf[4] = v57;
          _os_log_error_impl(&dword_1D3D6B000, v52, OS_LOG_TYPE_ERROR, "vImageConvert_Planar8toPlanarF failed: %{public}zd", buf, 0xCu);
        }
        *(_QWORD *)buf = -2005;
        v61 = CFSTR("vImageConvert_Planar8toPlanarF failed.");
        sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v61);
        goto LABEL_133;
      }
    }
    do
      v58 = __ldaxr((unint64_t *)&v71);
    while (__stlxr(0, (unint64_t *)&v71));
LABEL_134:
    v60 = v58;
    if (v56)
      free(v56);
    goto LABEL_136;
  }
  v12 = 0;
LABEL_84:
  v47 = v78;
  if (LOBYTE(v76->info))
  {
    if (!v78)
      return v12;
    *(_QWORD *)buf = v76->isa;
    (*(void (**)(void))(*v78 + 48))();
    v47 = v78;
  }
  if (v47 == v77)
  {
    v48 = 4;
    v47 = v77;
    goto LABEL_91;
  }
  if (v47)
  {
    v48 = 5;
LABEL_91:
    (*(void (**)(void))(*v47 + 8 * v48))();
  }
  return v12;
}

void sub_1D3DA8E24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,unint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  void *v48;
  void *v49;
  uint64_t v50;

  if (v49)
    free(v49);
  if (a9)
    free(a9);
  if (v48)
    free(v48);
  sub_1D3DF37A0((uint64_t)&a36);
  sub_1D3D74EDC(&a39);
  sub_1D3D87C3C((_QWORD *)(v50 - 144));
  sub_1D3D87C3C(&a48);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DA8F1C@<X0>(uint64_t result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v3;

  v2 = (unint64_t *)(result + 680);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(0, v2));
  *a2 = v3;
  return result;
}

void sub_1D3DA8F34(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DA8FD8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA8FEC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2AC0;
  return result;
}

void sub_1D3DA9010(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2AC0;
}

void sub_1D3DA9028(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DA90C8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA9100()
{
  return &unk_1E95B2B20;
}

void sub_1D3DA9110()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA9124()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2A40;
  return result;
}

void sub_1D3DA9148(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2A40;
}

uint64_t sub_1D3DA9160(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA9198()
{
  return &unk_1E95B2AA0;
}

void sub_1D3DA91A4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DA9248()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA925C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B29C0;
  return result;
}

void sub_1D3DA9280(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B29C0;
}

void sub_1D3DA9298(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DA9338(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA9370()
{
  return &unk_1E95B2A20;
}

void sub_1D3DA9380()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DA9394()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2940;
  return result;
}

void sub_1D3DA93B8(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2940;
}

uint64_t sub_1D3DA93D0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DA9408()
{
  return &unk_1E95B29A0;
}

void sub_1D3DA9418(uint64_t a1)
{
  sub_1D3DAB8E4(a1);
  JUMPOUT(0x1D8254C54);
}

BOOL sub_1D3DA943C(unint64_t *a1)
{
  unint64_t v3;

  if (!a1[25])
    return 0;
  if (!a1[26])
    return 0;
  if (!atomic_load(a1 + 27))
    return 0;
  if (!atomic_load(a1 + 28))
    return 0;
  v3 = atomic_load(a1 + 29);
  return v3 != 0;
}

uint64_t sub_1D3DA9480(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  _QWORD **v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  __int16 v14;
  qos_class_t v15;
  unsigned int v16;
  unint64_t v17;
  BOOL v18;
  const __CFAllocator *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int32x2_t v25;
  int8x8_t v26;
  int8x16_t v27;
  int8x16_t v28;
  uint64x2_t v29;
  uint64_t v30;
  OSStatus v31;
  NSObject *v32;
  _QWORD *p_isa;
  uint64_t v34;
  unint64_t v35;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;
  NSObject *v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  const __CFAllocator *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  int32x2_t v49;
  int8x8_t v50;
  int8x16_t v51;
  int8x16_t v52;
  uint64x2_t v53;
  uint64_t v54;
  OSStatus v55;
  NSObject *v56;
  _QWORD *v57;
  uint64_t v58;
  unint64_t v59;
  const __CFString *v60;
  NSObject *v61;
  unint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  const void *v69;
  uint64_t v70;
  unint64_t v72;
  const void *v73;
  unint64_t *v75;
  uint64_t v77;
  const __CFAllocator *v78;
  unint64_t v79;
  unint64_t v80;
  const void *v81;
  unint64_t v82;
  const void *v83;
  unint64_t *v85;
  unint64_t v87;
  const void *v88;
  _QWORD *v90;
  uint64_t v91;
  __int128 pixelTransferSessionOut;
  char v94;
  char v95;
  char v96;
  char v97;
  char v98;
  char v99;
  char v100;
  char v101;
  char v102;
  char v103;
  int v104;
  char v105;
  __int16 v106;
  char v107;
  char v108;
  unint64_t v109;
  CFStringRef v110;
  __int16 v111;
  char v112;
  __int16 v113;
  char v114;
  CFStringRef v115;
  _BYTE buf[12];
  __int16 v117;
  _BYTE v118[10];
  unint64_t v119;
  int v120;
  char v121;
  uint64_t v122;
  char v123;
  uint64_t v124;
  char v125;
  int v126;
  __int16 v127;
  _BYTE v128[120];
  unint64_t v129;
  char v130;
  __int16 v131;
  _QWORD v132[3];
  _QWORD *v133;
  _QWORD v134[3];
  _QWORD *v135;
  uint64_t v136;
  _QWORD v137[3];
  _QWORD *v138;
  uint64_t v139;

  v139 = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD **)(a1 + 200);
  if (!*(_QWORD *)(a1 + 200)
    || !*(_QWORD *)(a1 + 208)
    || (v6 = atomic_load((unint64_t *)(a1 + 216))) == 0
    || (v7 = atomic_load((unint64_t *)(a1 + 224))) == 0
    || (v8 = atomic_load((unint64_t *)(a1 + 232))) == 0)
  {
    v135 = v134;
    v136 = a3;
    v132[0] = &off_1E95B2BC0;
    v133 = v132;
    v134[0] = &off_1E95B2B40;
    v138 = v137;
    v137[0] = &off_1E95B2BC0;
    if (!*(_BYTE *)(a3 + 8)
      || (*(_QWORD *)buf = *(_QWORD *)a3, sub_1D3DAB5FC(a1, (os_signpost_id_t *)buf), v10 = v133, v133 == v132))
    {
      v11 = 4;
      v10 = v132;
    }
    else
    {
      if (!v133)
        goto LABEL_13;
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_13:
    v12 = v135;
    if (v135 == v134)
    {
      v13 = 4;
      v12 = v134;
    }
    else
    {
      if (!v135)
        goto LABEL_18;
      v13 = 5;
    }
    (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_18:
    if (*v5)
      goto LABEL_59;
    if (*(_BYTE *)(a1 + 192))
    {
      v14 = 0;
      v15 = *(_DWORD *)(a1 + 184);
      HIDWORD(v17) = v15 - 9;
      LODWORD(v17) = v15 - 9;
      v16 = v17 >> 2;
      v18 = 1;
      if (v16 <= 6 && ((0x22u >> v16) & 1) == 0)
      {
        if (((1 << v16) & 0x5D) == 0)
          v15 = qos_class_self();
        v18 = v15 != QOS_CLASS_USER_INTERACTIVE;
        if (v15 == QOS_CLASS_USER_INTERACTIVE)
          v14 = 257;
        else
          v14 = 0;
      }
    }
    else
    {
      v14 = 0;
      v18 = 1;
    }
    v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v20 = *(_QWORD *)(a1 + 8);
    v21 = *(_QWORD *)(a1 + 16);
    v22 = *(_DWORD *)(a1 + 24);
    v23 = HIBYTE(v22);
    if (HIBYTE(v22) - 32 >= 0x5Fu)
      v23 = 46;
    if (*(_DWORD *)(a1 + 24) - 32 >= 0x5F)
      v24 = 46;
    else
      v24 = *(_DWORD *)(a1 + 24);
    v25 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(v22), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
    v26 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v25, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v25, (int8x8_t)0x2E0000002ELL);
    v27.i64[0] = v26.u32[0];
    v27.i64[1] = v26.u32[1];
    v28.i64[0] = 255;
    v28.i64[1] = 255;
    v29 = vshlq_u64((uint64x2_t)vandq_s8(v27, v28), (uint64x2_t)xmmword_1D3E82010);
    v30 = v29.i64[0] | (v24 << 24);
    buf[4] = ((unint64_t)v30 | v29.i64[1]) >> 32;
    *(_DWORD *)buf = v30 | v29.i32[2] | v23;
    v110 = CFStringCreateWithFormat(v19, 0, CFSTR("ANMDImagePreprocessor[Transfer, %zu, %zu, %.4s]"), v20, v21, buf);
    *(_QWORD *)&pixelTransferSessionOut = 0;
    v31 = VTPixelTransferSessionCreate(v19, (VTPixelTransferSessionRef *)&pixelTransferSessionOut);
    if (v31)
    {
      if (qword_1EFE31850 != -1)
        dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
      v32 = qword_1EFE31848;
      if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&buf[4] = v31;
        _os_log_error_impl(&dword_1D3D6B000, v32, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate failed: %{public}d", buf, 8u);
      }
      v115 = CFSTR("VTPixelTransferSessionCreate failed.");
      *(_QWORD *)buf = -2003;
      sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&v115);
      sub_1D3DF5254((uint64_t)a2, v31);
    }
    else
    {
      p_isa = (_QWORD *)operator new();
      v34 = pixelTransferSessionOut;
      *(_QWORD *)&pixelTransferSessionOut = 0;
      *(_QWORD *)buf = v34;
      sub_1D3DC42A0((uint64_t)p_isa, 1, (unint64_t *)&v110);
      *p_isa = off_1E95B2FC0;
      do
        v35 = __ldaxr((unint64_t *)buf);
      while (__stlxr(0, (unint64_t *)buf));
      p_isa[3] = v35;
      *p_isa = &off_1E95B2ED0;
      *((_DWORD *)p_isa + 8) = 0;
      *((_BYTE *)p_isa + 36) = 0;
      *((_BYTE *)p_isa + 40) = 0;
      *((_BYTE *)p_isa + 44) = 0;
      *((_BYTE *)p_isa + 48) = 0;
      *((_WORD *)p_isa + 26) = 0;
      v115 = (CFStringRef)p_isa;
      sub_1D3D94AD4((unint64_t *)buf);
      p_isa[4] = 1;
      *((_BYTE *)p_isa + 40) = 1;
      *(_WORD *)((char *)p_isa + 41) = v113;
      *((_BYTE *)p_isa + 43) = v114;
      *((_DWORD *)p_isa + 11) = 1;
      *((_BYTE *)p_isa + 48) = 1;
      *(_WORD *)((char *)p_isa + 49) = v111;
      *((_BYTE *)p_isa + 51) = v112;
      *((_WORD *)p_isa + 26) = v14;
      v36 = (const __CFString *)*MEMORY[0x1E0C9AE50];
      if (sub_1D3DC32E4((uint64_t)p_isa, (const __CFString *)*MEMORY[0x1E0CED808], (const __CFString *)*MEMORY[0x1E0C9AE50], a2))
      {
        v37 = (const __CFString *)*MEMORY[0x1E0C9AE40];
        if (sub_1D3DC32E4((uint64_t)p_isa, (const __CFString *)*MEMORY[0x1E0CED868], (const __CFString *)*MEMORY[0x1E0C9AE40], a2)&& sub_1D3DC32E4((uint64_t)p_isa, (const __CFString *)*MEMORY[0x1E0CED800], v36, a2)&& sub_1D3DC32E4((uint64_t)p_isa, (const __CFString *)*MEMORY[0x1E0CED860], v36, a2)&& sub_1D3DC32E4((uint64_t)p_isa, (const __CFString *)*MEMORY[0x1E0CED848], (const __CFString *)*MEMORY[0x1E0CEDB40], a2)&& sub_1D3DC32E4((uint64_t)p_isa, (const __CFString *)*MEMORY[0x1E0CED7F0], (const __CFString *)*MEMORY[0x1E0CED490], a2))
        {
          if (v18
            || ((_BYTE)v14 ? (v38 = v36) : (v38 = v37),
                sub_1D3DC32E4((uint64_t)p_isa, (const __CFString *)*MEMORY[0x1E0CED838], v38, a2)))
          {
            if (qword_1EFE31850 != -1)
              dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
            v39 = qword_1EFE31848;
            if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_DEBUG))
            {
              v40 = atomic_load(p_isa + 3);
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "PixelTransferSession";
              v117 = 2050;
              *(_QWORD *)v118 = p_isa;
              *(_WORD *)&v118[8] = 2114;
              v119 = v40;
              _os_log_debug_impl(&dword_1D3D6B000, v39, OS_LOG_TYPE_DEBUG, "[PixelTransferSession::create] created <%{public}s %{public}p> with underlying session: %{public}@", buf, 0x20u);
              p_isa = &v115->isa;
            }
LABEL_58:
            sub_1D3DAB69C(v5, p_isa);
            v42 = *v5;
            sub_1D3D8C70C((unint64_t *)&v110);
            if (!v42)
              goto LABEL_131;
LABEL_59:
            if (*(_QWORD *)(a1 + 208))
            {
LABEL_84:
              v65 = (unint64_t *)(a1 + 216);
              v66 = atomic_load((unint64_t *)(a1 + 216));
              if (!v66 || (v67 = atomic_load((unint64_t *)(a1 + 224))) == 0)
              {
                LOBYTE(pixelTransferSessionOut) = 0;
                BYTE8(pixelTransferSessionOut) = 0;
                v94 = 0;
                v95 = 0;
                v96 = 0;
                v97 = 0;
                v98 = 0;
                v99 = 0;
                v100 = 0;
                v101 = 0;
                v102 = 0;
                v103 = 0;
                v107 = 0;
                v108 = 0;
                v109 = 0;
                v105 = 1;
                v104 = 1024;
                v106 = 257;
                *(_QWORD *)buf = CFRetain(CFSTR("MRC: ANMD Preprocessor Interleaved"));
                do
                  v68 = __ldaxr((unint64_t *)buf);
                while (__stlxr(0, (unint64_t *)buf));
                do
                  v69 = (const void *)__ldaxr(&v109);
                while (__stlxr(v68, &v109));
                if (v69)
                  CFRelease(v69);
                sub_1D3D8C70C((unint64_t *)buf);
                v128[0] = 0;
                v130 = 0;
                v131 = 0;
                v126 = 0;
                v127 = 0;
                v70 = *(_QWORD *)(a1 + 16);
                *(_QWORD *)buf = *(_QWORD *)(a1 + 8);
                buf[8] = 1;
                *(_QWORD *)&v118[2] = v70;
                LOBYTE(v119) = 1;
                v120 = *(_DWORD *)(a1 + 24);
                v121 = 1;
                v123 = 1;
                v122 = 64;
                v125 = 1;
                v124 = 64;
                sub_1D3D9AE68((uint64_t)v128, &pixelTransferSessionOut);
                if (!atomic_load(v65))
                {
                  sub_1D3DD5EF4((CVPixelBufferPoolRef *)&v115, (uint64_t *)buf, (uint64_t)a2);
                  do
                    v72 = __ldaxr((unint64_t *)&v115);
                  while (__stlxr(0, (unint64_t *)&v115));
                  do
                    v73 = (const void *)__ldaxr(v65);
                  while (__stlxr(v72, v65));
                  if (v73)
                    CFRelease(v73);
                  sub_1D3D982CC((unint64_t *)&v115);
                  if (!atomic_load(v65))
                    goto LABEL_128;
                }
                v75 = (unint64_t *)(a1 + 224);
                if (!atomic_load((unint64_t *)(a1 + 224)))
                {
                  if ((buf[8] != 0) != ((_BYTE)v119 != 0))
                  {
                    if (buf[8])
                    {
                      *(_QWORD *)&v118[2] = *(_QWORD *)buf;
                      LOBYTE(v119) = 1;
                      buf[8] = 0;
                    }
                    else
                    {
                      *(_QWORD *)buf = *(_QWORD *)&v118[2];
                      buf[8] = 1;
                      if ((_BYTE)v119)
                        LOBYTE(v119) = 0;
                    }
                  }
                  else if (buf[8])
                  {
                    v77 = *(_QWORD *)buf;
                    *(_QWORD *)buf = *(_QWORD *)&v118[2];
                    *(_QWORD *)&v118[2] = v77;
                  }
                  v78 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                  v79 = atomic_load(&v129);
                  v115 = CFStringCreateWithFormat(v78, 0, CFSTR("%@ 90CW"), v79);
                  do
                    v80 = __ldaxr((unint64_t *)&v115);
                  while (__stlxr(0, (unint64_t *)&v115));
                  do
                    v81 = (const void *)__ldaxr(&v129);
                  while (__stlxr(v80, &v129));
                  if (v81)
                    CFRelease(v81);
                  sub_1D3D8C70C((unint64_t *)&v115);
                  sub_1D3DD5EF4((CVPixelBufferPoolRef *)&v115, (uint64_t *)buf, (uint64_t)a2);
                  do
                    v82 = __ldaxr((unint64_t *)&v115);
                  while (__stlxr(0, (unint64_t *)&v115));
                  do
                    v83 = (const void *)__ldaxr(v75);
                  while (__stlxr(v82, v75));
                  if (v83)
                    CFRelease(v83);
                  sub_1D3D982CC((unint64_t *)&v115);
                  if (!atomic_load(v75))
                  {
LABEL_128:
                    if (v130)
                      sub_1D3D8C70C(&v129);
                    sub_1D3D8C70C(&v109);
                    goto LABEL_131;
                  }
                }
                if (v130)
                  sub_1D3D8C70C(&v129);
                sub_1D3D8C70C(&v109);
              }
              v85 = (unint64_t *)(a1 + 232);
              if (atomic_load((unint64_t *)(a1 + 232)))
                goto LABEL_127;
              sub_1D3DF3500((CVPixelBufferPoolRef *)buf, a1 + 64, a2);
              do
                v87 = __ldaxr((unint64_t *)buf);
              while (__stlxr(0, (unint64_t *)buf));
              do
                v88 = (const void *)__ldaxr(v85);
              while (__stlxr(v87, v85));
              if (v88)
                CFRelease(v88);
              sub_1D3D982CC((unint64_t *)buf);
              if (atomic_load(v85))
              {
LABEL_127:
                v9 = 1;
                goto LABEL_132;
              }
LABEL_131:
              v9 = 0;
LABEL_132:
              v90 = v138;
              if (*(_BYTE *)(v136 + 8))
              {
                if (!v138)
                  return v9;
                *(_QWORD *)buf = *(_QWORD *)v136;
                (*(void (**)(_QWORD *, _BYTE *))(*v138 + 48))(v138, buf);
                v90 = v138;
              }
              if (v90 == v137)
              {
                v91 = 4;
                v90 = v137;
              }
              else
              {
                if (!v90)
                  return v9;
                v91 = 5;
              }
              (*(void (**)(void))(*v90 + 8 * v91))();
              return v9;
            }
            v43 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v44 = *(_QWORD *)(a1 + 8);
            v45 = *(_QWORD *)(a1 + 16);
            v46 = *(_DWORD *)(a1 + 24);
            v47 = HIBYTE(v46);
            if (HIBYTE(v46) - 32 >= 0x5Fu)
              v47 = 46;
            if (*(_DWORD *)(a1 + 24) - 32 >= 0x5F)
              v48 = 46;
            else
              v48 = *(_DWORD *)(a1 + 24);
            v49 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(v46), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
            v50 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v49, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v49, (int8x8_t)0x2E0000002ELL);
            v51.i64[0] = v50.u32[0];
            v51.i64[1] = v50.u32[1];
            v52.i64[0] = 255;
            v52.i64[1] = 255;
            v53 = vshlq_u64((uint64x2_t)vandq_s8(v51, v52), (uint64x2_t)xmmword_1D3E82010);
            v54 = v53.i64[0] | (v48 << 24);
            buf[4] = ((unint64_t)v54 | v53.i64[1]) >> 32;
            *(_DWORD *)buf = v54 | v53.i32[2] | v47;
            v110 = CFStringCreateWithFormat(v43, 0, CFSTR("ANMDImagePreprocessor[Rotation, %zu, %zu, %.4s]"), v44, v45, buf);
            *(_QWORD *)&pixelTransferSessionOut = 0;
            v55 = VTPixelRotationSessionCreate(v43, (VTPixelRotationSessionRef *)&pixelTransferSessionOut);
            if (v55)
            {
              if (qword_1EFE31850 != -1)
                dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
              v56 = qword_1EFE31848;
              if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67240192;
                *(_DWORD *)&buf[4] = v55;
                _os_log_error_impl(&dword_1D3D6B000, v56, OS_LOG_TYPE_ERROR, "VTPixelRotationSessionCreate failed: %{public}d", buf, 8u);
              }
              v115 = CFSTR("VTPixelRotationSessionCreate failed.");
              *(_QWORD *)buf = -2003;
              sub_1D3D73E0C(a2, (uint64_t *)buf, (CFTypeRef *)&v115);
              sub_1D3DF5254((uint64_t)a2, v55);
            }
            else
            {
              v57 = (_QWORD *)operator new();
              v58 = pixelTransferSessionOut;
              *(_QWORD *)&pixelTransferSessionOut = 0;
              *(_QWORD *)buf = v58;
              sub_1D3DC42A0((uint64_t)v57, 1, (unint64_t *)&v110);
              *v57 = off_1E95B2FF8;
              do
                v59 = __ldaxr((unint64_t *)buf);
              while (__stlxr(0, (unint64_t *)buf));
              v57[3] = v59;
              *v57 = &off_1E95B2F18;
              *((_DWORD *)v57 + 8) = 0;
              *((_BYTE *)v57 + 36) = 0;
              *((_BYTE *)v57 + 40) = 0;
              *((_DWORD *)v57 + 11) = 0;
              *((_WORD *)v57 + 24) = 0;
              v115 = (CFStringRef)v57;
              sub_1D3DC4260((unint64_t *)buf);
              v57[4] = 0x5A00000001;
              *((_BYTE *)v57 + 40) = 1;
              *(_WORD *)((char *)v57 + 41) = v113;
              *((_BYTE *)v57 + 43) = v114;
              *((_DWORD *)v57 + 11) = 0;
              *((_WORD *)v57 + 24) = 257;
              v60 = (const __CFString *)*MEMORY[0x1E0C9AE50];
              if (sub_1D3DC32E4((uint64_t)v57, (const __CFString *)*MEMORY[0x1E0CED768], (const __CFString *)*MEMORY[0x1E0C9AE50], a2)&& sub_1D3DC32E4((uint64_t)v57, (const __CFString *)*MEMORY[0x1E0CED760], v60, a2)&& sub_1D3DC32E4((uint64_t)v57, (const __CFString *)*MEMORY[0x1E0CED7A0], (const __CFString *)*MEMORY[0x1E0CEDA40], a2)&& sub_1D3DC32E4((uint64_t)v57, (const __CFString *)*MEMORY[0x1E0CED7A8], v60, a2))
              {
                if (qword_1EFE31850 != -1)
                  dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
                v61 = qword_1EFE31848;
                if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_DEBUG))
                {
                  v62 = atomic_load(v57 + 3);
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "PixelRotationSession";
                  v117 = 2050;
                  *(_QWORD *)v118 = v57;
                  *(_WORD *)&v118[8] = 2114;
                  v119 = v62;
                  _os_log_debug_impl(&dword_1D3D6B000, v61, OS_LOG_TYPE_DEBUG, "[PixelRotationSession::create] created <%{public}s %{public}p> with underlying session: %{public}@", buf, 0x20u);
                  v57 = &v115->isa;
                }
LABEL_83:
                sub_1D3DAB6D8((_QWORD **)(a1 + 208), v57);
                v64 = *(_QWORD *)(a1 + 208);
                sub_1D3D8C70C((unint64_t *)&v110);
                if (!v64)
                  goto LABEL_131;
                goto LABEL_84;
              }
              v63 = sub_1D3DC4200(v57);
              MEMORY[0x1D8254C54](v63, 0x10E1C40D9779C66);
            }
            v57 = 0;
            goto LABEL_83;
          }
        }
      }
      v41 = sub_1D3DC3680(p_isa);
      MEMORY[0x1D8254C54](v41, 0x10E1C408CF0B0E2);
    }
    p_isa = 0;
    goto LABEL_58;
  }
  return 1;
}

void sub_1D3DAA1A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1D3D87C3C((_QWORD *)(v1 - 144));
  _Unwind_Resume(a1);
}

BOOL sub_1D3DAA2C8(uint64_t a1, unint64_t *a2, uint64_t a3, const __CFString *a4)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v11;
  uint64_t v12;
  NSObject *v13;
  _BOOL8 v14;
  _QWORD *v16;
  uint64_t v17;
  __CVBuffer *v19;
  OSType PixelFormatType;
  __CVBuffer *v21;
  size_t WidthOfPlane;
  __CVBuffer *v23;
  size_t HeightOfPlane;
  unint64_t v25;
  double v26;
  double v27;
  double v28;
  _BOOL4 v29;
  NSObject *v30;
  NSObject *v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  unint64_t v37;
  const void *v38;
  NSObject *v40;
  unint64_t v41;
  const void *v42;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  __CVBuffer *v47;
  size_t Width;
  __CVBuffer *v49;
  size_t Height;
  double v51;
  double v52;
  double v53;
  double v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  size_t v58;
  uint64_t (***v59)();
  uint64_t v60;
  CFTypeRef *v61;
  uint64_t v62;
  unint64_t v63;
  __CVBuffer *v64;
  NSObject *v65;
  __CVBuffer *v66;
  vImagePixelCount v67;
  __CVBuffer *v68;
  vImagePixelCount v69;
  __CVBuffer *v70;
  OSType v71;
  OSType v72;
  CFTypeRef v73;
  __CVBuffer *v74;
  __CVBuffer *v75;
  __CVBuffer *v77;
  NSObject *v78;
  NSObject *v79;
  _OWORD *v80;
  uint64_t v81;
  unint64_t *v82;
  unint64_t v83;
  const void *v84;
  unint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  NSObject *v88;
  NSObject *v89;
  __CVBuffer *v90;
  vImagePixelCount v91;
  __CVBuffer *v92;
  size_t v93;
  __CVBuffer *v94;
  OSType v95;
  __CVBuffer *v96;
  char *BaseAddress;
  __CVBuffer *v98;
  size_t BytesPerRow;
  unint64_t v100;
  NSObject *v101;
  NSObject *v102;
  vImage_Error v103;
  NSObject *v104;
  unint64_t v105;
  int v106;
  NSObject *oslog;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  const __CFString *v112;
  vImage_Buffer blue;
  vImage_Buffer green;
  _BYTE v115[24];
  CVPixelBufferRef v116;
  vImage_Buffer v117;
  CFTypeRef v118;
  uint64_t v119;
  char v120;
  CFTypeRef v121[3];
  CFTypeRef *v122;
  char v123;
  _QWORD v124[3];
  _QWORD *v125;
  _QWORD v126[3];
  _QWORD *v127;
  const __CFString *v128;
  _QWORD v129[3];
  _QWORD *v130;
  _BYTE v131[12];
  vImage_Buffer v132;
  uint64_t (**v133)();
  char v134;
  uint64_t (***v135)();
  __int128 buf;
  double v137;
  double v138;
  char *v139;
  uint64_t v140;

  v140 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 200)
    || !*(_QWORD *)(a1 + 208)
    || (v6 = atomic_load((unint64_t *)(a1 + 216))) == 0
    || (v7 = atomic_load((unint64_t *)(a1 + 224))) == 0
    || (v8 = atomic_load((unint64_t *)(a1 + 232))) == 0)
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v13 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_ERROR, "ANMDImagePreprocessor_VideoToolbox is not ready.", (uint8_t *)&buf, 2u);
    }
    *(_QWORD *)&buf = -6008;
    v128 = CFSTR("ANMDImagePreprocessor_VideoToolbox is not ready.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&buf, (CFTypeRef *)&v128);
    return 0;
  }
  v127 = v126;
  v128 = a4;
  v124[0] = &off_1E95B2CC0;
  v125 = v124;
  v126[0] = &off_1E95B2C40;
  v130 = v129;
  v129[0] = &off_1E95B2CC0;
  if (!LOBYTE(a4->info)
    || (*(_QWORD *)&buf = a4->isa, sub_1D3DAB38C(a1, (os_signpost_id_t *)&buf), v11 = v125, v125 == v124))
  {
    v12 = 4;
    v11 = v124;
  }
  else
  {
    if (!v125)
      goto LABEL_18;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_18:
  v16 = v127;
  if (v127 == v126)
  {
    v17 = 4;
    v16 = v126;
  }
  else
  {
    if (!v127)
      goto LABEL_23;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_23:
  if (atomic_load(a2))
  {
    v19 = (__CVBuffer *)atomic_load(a2);
    PixelFormatType = CVPixelBufferGetPixelFormatType(v19);
    if ((PixelFormatType | 0x10) == 0x34323076)
    {
      v21 = (__CVBuffer *)atomic_load(a2);
      WidthOfPlane = CVPixelBufferGetWidthOfPlane(v21, 0);
      v23 = (__CVBuffer *)atomic_load(a2);
      HeightOfPlane = CVPixelBufferGetHeightOfPlane(v23, 0);
      v25 = HeightOfPlane;
      v26 = (double)*(unint64_t *)(a1 + 8);
      v27 = (double)*(unint64_t *)(a1 + 16);
      v28 = v26 / v27;
      v108 = WidthOfPlane;
      if (vabdd_f64(1.0, v26 / v27) >= 2.22044605e-16)
      {
        v32 = (double)WidthOfPlane / (double)HeightOfPlane;
        v33 = 1.0 / v32;
        v34 = ceil(v32 * v27);
        if (v32 >= v28)
          v34 = (double)*(unint64_t *)(a1 + 8);
        v35 = ceil(v26 / v32);
        if (v32 <= v28)
        {
          v36 = (double)*(unint64_t *)(a1 + 16);
        }
        else
        {
          v34 = (double)*(unint64_t *)(a1 + 8);
          v36 = v35;
        }
        if (v33 <= v28)
        {
          if (v33 < v28)
            v26 = ceil(v33 * v27);
        }
        else
        {
          v27 = ceil(v26 / v33);
        }
        v29 = v34 * v36 < v26 * v27;
      }
      else
      {
        v29 = 0;
      }
      *(_BYTE *)(a1 + 28) = v29;
      v110 = 0;
      v111 = 0;
      sub_1D3DD5F9C((CVPixelBufferRef *)&buf, (unint64_t *)(a1 + 216), a3);
      do
        v37 = __ldaxr((unint64_t *)&buf);
      while (__stlxr(0, (unint64_t *)&buf));
      do
        v38 = (const void *)__ldaxr(&v111);
      while (__stlxr(v37, &v111));
      if (v38)
        CFRelease(v38);
      sub_1D3D74EDC((unint64_t *)&buf);
      if (!atomic_load(&v111))
        goto LABEL_66;
      if (qword_1EDB89F20 != -1)
        dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
      v40 = qword_1EDB89F78;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG))
      {
        v46 = atomic_load(&v111);
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = v46;
        _os_log_debug_impl(&dword_1D3D6B000, v40, OS_LOG_TYPE_DEBUG, "Allocated interleaved pixel buffer: %{public}@", (uint8_t *)&buf, 0xCu);
        if (v29)
          goto LABEL_58;
      }
      else if (v29)
      {
LABEL_58:
        sub_1D3DD5F9C((CVPixelBufferRef *)&buf, (unint64_t *)(a1 + 224), a3);
        do
          v41 = __ldaxr((unint64_t *)&buf);
        while (__stlxr(0, (unint64_t *)&buf));
        do
          v42 = (const void *)__ldaxr(&v110);
        while (__stlxr(v41, &v110));
        if (v42)
          CFRelease(v42);
        sub_1D3D74EDC((unint64_t *)&buf);
        if (atomic_load(&v110))
        {
          v44 = &v110;
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
          {
            v45 = atomic_load(&v110);
            LODWORD(buf) = 138543362;
            *(_QWORD *)((char *)&buf + 4) = v45;
            _os_log_debug_impl(&dword_1D3D6B000, v40, OS_LOG_TYPE_DEBUG, "Allocated interleaved90CW pixel buffer: %{public}@", (uint8_t *)&buf, 0xCu);
          }
LABEL_69:
          oslog = v40;
          v47 = (__CVBuffer *)atomic_load(v44);
          Width = CVPixelBufferGetWidth(v47);
          v49 = (__CVBuffer *)atomic_load(v44);
          Height = CVPixelBufferGetHeight(v49);
          v51 = (double)v108 / (double)v25;
          v52 = (double)Width;
          v53 = (double)Height;
          v54 = (double)Width / (double)Height;
          if (v51 <= v54)
          {
            if (v51 < v54)
            {
              Width = vcvtpd_u64_f64(v51 * v53);
              v52 = (double)(unint64_t)ceil(v51 * v53);
            }
          }
          else
          {
            Height = vcvtpd_u64_f64(v52 / v51);
            v53 = (double)(unint64_t)ceil(v52 / v51);
          }
          v55 = *(_QWORD *)(a1 + 200);
          buf = 0uLL;
          v137 = (double)v108;
          v138 = (double)v25;
          LOBYTE(v139) = 1;
          v121[0] = 0;
          v121[1] = 0;
          v121[2] = *(CFTypeRef *)&v52;
          v122 = *(CFTypeRef **)&v53;
          v123 = 1;
          LOBYTE(v133) = 0;
          v134 = 0;
          if ((sub_1D3DC2CF4(v55, a2, v44, (uint64_t)&buf, (uint64_t)v121, (unint64_t *)a3, (uint64_t)&v133) & 1) == 0)
            goto LABEL_76;
          if (v29)
          {
            v56 = *(_QWORD *)(a1 + 208);
            LOBYTE(buf) = 0;
            LOBYTE(v139) = 0;
            LOBYTE(v121[0]) = 0;
            v123 = 0;
            LOBYTE(v133) = 0;
            v134 = 0;
            v57 = sub_1D3DC3960(v56, &v110, &v111, (uint64_t)&buf, (uint64_t)v121, (unint64_t *)a3, (uint64_t)&v133);
            v58 = Width;
            if ((v57 & 1) == 0)
            {
LABEL_76:
              v14 = 0;
              goto LABEL_132;
            }
          }
          else
          {
            v57 = os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG);
            if ((_DWORD)v57)
            {
              LOWORD(buf) = 0;
              _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "ANMDImagePreprocessor: rotation is not needed", (uint8_t *)&buf, 2u);
            }
            v58 = Height;
            Height = Width;
          }
          *(_QWORD *)(a1 + 32) = Height;
          *(_QWORD *)(a1 + 40) = v58;
          *(_QWORD *)(a1 + 48) = Height >> 1;
          *(_QWORD *)(a1 + 56) = v58 >> 1;
          v121[0] = &off_1E95B3778;
          v122 = v121;
          v133 = &off_1E95B37F8;
          v135 = &v133;
          *(_QWORD *)&buf = a4;
          v139 = (char *)&buf + 8;
          *((_QWORD *)&buf + 1) = &off_1E95B37F8;
          if (!LOBYTE(a4->info)
            || (v117.data = a4->isa, sub_1D3DF39F4(v57, (os_signpost_id_t *)&v117), v59 = v135, v135 == &v133))
          {
            v60 = 4;
            v59 = &v133;
          }
          else
          {
            if (!v135)
              goto LABEL_86;
            v60 = 5;
          }
          (*v59)[v60]();
LABEL_86:
          v61 = v122;
          if (v122 == v121)
          {
            v62 = 4;
            v61 = v121;
          }
          else
          {
            if (!v122)
            {
LABEL_91:
              v63 = atomic_load(&v111);
              if (!v63 || (v64 = (__CVBuffer *)atomic_load(&v111), CVPixelBufferIsPlanar(v64)))
              {
                if (qword_1EDB89F90 != -1)
                  dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                v65 = qword_1EDB89F98;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v117.data) = 0;
                  _os_log_error_impl(&dword_1D3D6B000, v65, OS_LOG_TYPE_ERROR, "Invalid interleaved pixel buffer", (uint8_t *)&v117, 2u);
                }
                v117.data = (void *)-2006;
                v132.data = CFSTR("Invalid interleaved pixel buffer.");
                sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&v117, (CFTypeRef *)&v132.data);
LABEL_117:
                v109 = 0;
                goto LABEL_118;
              }
              v66 = (__CVBuffer *)atomic_load(&v111);
              v67 = CVPixelBufferGetWidth(v66);
              v68 = (__CVBuffer *)atomic_load(&v111);
              v69 = CVPixelBufferGetHeight(v68);
              v70 = (__CVBuffer *)atomic_load(&v111);
              v71 = CVPixelBufferGetPixelFormatType(v70);
              if (v67 != *(_QWORD *)(a1 + 128)
                || v69 != *(_QWORD *)(a1 + 120)
                || (v72 = v71, v71 != 1380410945) && v71 != 1380411457)
              {
                if (qword_1EDB89F90 != -1)
                  dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                v79 = qword_1EDB89F98;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v117.data) = 0;
                  _os_log_error_impl(&dword_1D3D6B000, v79, OS_LOG_TYPE_ERROR, "Invalid interleaved pixel buffer", (uint8_t *)&v117, 2u);
                }
                v117.data = (void *)-2001;
                v132.data = CFSTR("Invalid interleaved pixel buffer.");
                sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&v117, (CFTypeRef *)&v132.data);
                goto LABEL_117;
              }
              v73 = (CFTypeRef)atomic_load(&v111);
              if (v73)
                v73 = CFRetain(v73);
              v118 = v73;
              v119 = a3;
              v120 = sub_1D3DD48A0((unint64_t *)&v118, 1, a3);
              if ((v120 & 1) == 0)
              {
                if (qword_1EDB89F90 != -1)
                  dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                v88 = qword_1EDB89F98;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v117.data) = 0;
                  _os_log_error_impl(&dword_1D3D6B000, v88, OS_LOG_TYPE_ERROR, "Failed to lock interleaved pixel buffer for reading", (uint8_t *)&v117, 2u);
                }
                v109 = 0;
                goto LABEL_164;
              }
              memset(&v117, 0, sizeof(v117));
              v74 = (__CVBuffer *)atomic_load(&v111);
              v117.data = CVPixelBufferGetBaseAddress(v74);
              v117.height = v69;
              v117.width = v67;
              v75 = (__CVBuffer *)atomic_load(&v111);
              v117.rowBytes = CVPixelBufferGetBytesPerRow(v75);
              sub_1D3DD5F9C(&v116, (unint64_t *)(a1 + 232), a3);
              if (!atomic_load((unint64_t *)&v116))
              {
                if (qword_1EDB89F90 != -1)
                  dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                v89 = qword_1EDB89F98;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v132.data) = 0;
                  _os_log_error_impl(&dword_1D3D6B000, v89, OS_LOG_TYPE_ERROR, "Failed to create input pixel buffer from pixel buffer pool", (uint8_t *)&v132, 2u);
                }
                goto LABEL_162;
              }
              v77 = (__CVBuffer *)atomic_load((unint64_t *)&v116);
              if (CVPixelBufferIsPlanar(v77))
              {
                if (qword_1EDB89F90 != -1)
                  dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                v78 = qword_1EDB89F98;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v132.data) = 0;
                  _os_log_error_impl(&dword_1D3D6B000, v78, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", (uint8_t *)&v132, 2u);
                }
LABEL_161:
                v132.data = (void *)-2001;
                green.data = CFSTR("Invalid input pixel buffer.");
                sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&v132, (CFTypeRef *)&green.data);
LABEL_162:
                v109 = 0;
LABEL_163:
                sub_1D3D74EDC((unint64_t *)&v116);
LABEL_164:
                if (v120)
                  v120 = sub_1D3DD4A58((unint64_t *)&v118, 1, v119) ^ 1;
                sub_1D3D74EDC((unint64_t *)&v118);
LABEL_118:
                v80 = v139;
                if (*(_BYTE *)(buf + 8))
                {
                  if (!v139)
                    goto LABEL_126;
                  v117.data = *(void **)buf;
                  (*(void (**)(void))(*(_QWORD *)v139 + 48))();
                  v80 = v139;
                }
                if (v80 == (__int128 *)((char *)&buf + 8))
                {
                  v81 = 4;
                  v80 = (__int128 *)((char *)&buf + 8);
                }
                else
                {
                  if (!v80)
                    goto LABEL_126;
                  v81 = 5;
                }
                (*(void (**)(void))(*(_QWORD *)v80 + 8 * v81))();
LABEL_126:
                v82 = (unint64_t *)(a1 + 240);
                do
                  v83 = __ldaxr(&v109);
                while (__stlxr(0, &v109));
                do
                  v84 = (const void *)__ldaxr(v82);
                while (__stlxr(v83, v82));
                if (v84)
                  CFRelease(v84);
                sub_1D3D74EDC(&v109);
                v85 = atomic_load(v82);
                v14 = v85 != 0;
                goto LABEL_132;
              }
              v90 = (__CVBuffer *)atomic_load((unint64_t *)&v116);
              v91 = CVPixelBufferGetWidth(v90);
              v92 = (__CVBuffer *)atomic_load((unint64_t *)&v116);
              v93 = CVPixelBufferGetHeight(v92);
              v94 = (__CVBuffer *)atomic_load((unint64_t *)&v116);
              v95 = CVPixelBufferGetPixelFormatType(v94);
              if (v91 != *(_QWORD *)(a1 + 128)
                || v93 != 3 * *(_QWORD *)(a1 + 120)
                || v95 != 1278226534 && v95 != 1278226536)
              {
                if (qword_1EDB89F90 != -1)
                  dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                v101 = qword_1EDB89F98;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v132.data) = 0;
                  _os_log_error_impl(&dword_1D3D6B000, v101, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", (uint8_t *)&v132, 2u);
                }
                goto LABEL_161;
              }
              sub_1D3DF3A94((uint64_t)v115, (unint64_t *)&v116, a3);
              if (!v115[16])
              {
                if (qword_1EDB89F90 != -1)
                  dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                v102 = qword_1EDB89F98;
                if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                {
                  v106 = *(_DWORD *)(a3 + 24);
                  LODWORD(v132.data) = 67240192;
                  HIDWORD(v132.data) = v106;
                  _os_log_error_impl(&dword_1D3D6B000, v102, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&v132, 8u);
                }
                v109 = 0;
                goto LABEL_181;
              }
              v96 = (__CVBuffer *)atomic_load((unint64_t *)&v116);
              BaseAddress = (char *)CVPixelBufferGetBaseAddress(v96);
              v98 = (__CVBuffer *)atomic_load((unint64_t *)&v116);
              BytesPerRow = CVPixelBufferGetBytesPerRow(v98);
              v132.data = BaseAddress;
              v132.height = v93 / 3;
              v132.width = v91;
              v132.rowBytes = BytesPerRow;
              v100 = BytesPerRow * (v93 / 3);
              green.data = &BaseAddress[v100];
              green.height = v93 / 3;
              green.width = v91;
              green.rowBytes = BytesPerRow;
              blue.data = &BaseAddress[2 * v100];
              blue.height = v93 / 3;
              blue.width = v91;
              blue.rowBytes = BytesPerRow;
              if (v72 == 1380411457)
              {
                sub_1D3DF3AF0(&v117, &blue, &green, &v132);
              }
              else
              {
                v103 = vImageConvert_BGRXFFFFToPlanarF(&v117, &blue, &green, &v132, 0);
                if (v103)
                {
                  if (qword_1EDB89F90 != -1)
                    dispatch_once(&qword_1EDB89F90, &unk_1E95B34C8);
                  v104 = qword_1EDB89F98;
                  if (os_log_type_enabled((os_log_t)qword_1EDB89F98, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v131 = 134349056;
                    *(_QWORD *)&v131[4] = v103;
                    _os_log_error_impl(&dword_1D3D6B000, v104, OS_LOG_TYPE_ERROR, "vImageConvert_RGBXFFFFToPlanarF failed: %{public}zd", v131, 0xCu);
                  }
                  *(_QWORD *)v131 = -2005;
                  v112 = CFSTR("vImageConvert_RGBXFFFFToPlanarF failed.");
                  sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)v131, (CFTypeRef *)&v112);
                  v105 = 0;
                  *(_QWORD *)(a3 + 32) = v103;
                  *(_BYTE *)(a3 + 40) = 1;
                  goto LABEL_180;
                }
                sub_1D3DF3FDC((uint64_t)&v132);
                sub_1D3DF3FDC((uint64_t)&green);
                sub_1D3DF3FDC((uint64_t)&blue);
              }
              do
                v105 = __ldaxr((unint64_t *)&v116);
              while (__stlxr(0, (unint64_t *)&v116));
LABEL_180:
              v109 = v105;
LABEL_181:
              sub_1D3DF37A0((uint64_t)v115);
              goto LABEL_163;
            }
            v62 = 5;
          }
          (*((void (**)(void))*v61 + v62))();
          goto LABEL_91;
        }
LABEL_66:
        v14 = 0;
LABEL_132:
        sub_1D3D74EDC(&v110);
        sub_1D3D74EDC(&v111);
        goto LABEL_133;
      }
      v44 = &v111;
      goto LABEL_69;
    }
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v31 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 67240192;
      DWORD1(buf) = PixelFormatType;
      _os_log_error_impl(&dword_1D3D6B000, v31, OS_LOG_TYPE_ERROR, "Unsupported pixel format: %{public}#x", (uint8_t *)&buf, 8u);
    }
    *(_QWORD *)&buf = -2001;
    v121[0] = CFSTR("Unsupported pixel format.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&buf, v121);
  }
  else
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v30 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v30, OS_LOG_TYPE_ERROR, "Missing pixel buffer.", (uint8_t *)&buf, 2u);
    }
    *(_QWORD *)&buf = -6008;
    v121[0] = CFSTR("Missing pixel buffer.");
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)&buf, v121);
  }
  v14 = 0;
LABEL_133:
  v86 = v130;
  if (LOBYTE(v128->info))
  {
    if (!v130)
      return v14;
    *(_QWORD *)&buf = v128->isa;
    (*(void (**)(void))(*v130 + 48))();
    v86 = v130;
  }
  if (v86 == v129)
  {
    v87 = 4;
    v86 = v129;
    goto LABEL_140;
  }
  if (v86)
  {
    v87 = 5;
LABEL_140:
    (*(void (**)(void))(*v86 + 8 * v87))();
  }
  return v14;
}

void sub_1D3DAB254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t a14, unint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,unint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50)
{
  uint64_t v50;

  sub_1D3DF37A0((uint64_t)&a25);
  sub_1D3D74EDC(&a28);
  sub_1D3DF4088((uint64_t)&a34);
  sub_1D3D87C3C((_QWORD *)(v50 - 144));
  sub_1D3D74EDC(&a14);
  sub_1D3D74EDC(&a15);
  sub_1D3D87C3C(&a50);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DAB374@<X0>(uint64_t result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v3;

  v2 = (unint64_t *)(result + 240);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(0, v2));
  *a2 = v3;
  return result;
}

void sub_1D3DAB38C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_VideoToolbox::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DAB430()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAB444()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2CC0;
  return result;
}

void sub_1D3DAB468(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2CC0;
}

void sub_1D3DAB480(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_VideoToolbox::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DAB520(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAB558()
{
  return &unk_1E95B2D20;
}

void sub_1D3DAB568()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAB57C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2C40;
  return result;
}

void sub_1D3DAB5A0(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2C40;
}

uint64_t sub_1D3DAB5B8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAB5F0()
{
  return &unk_1E95B2CA0;
}

void sub_1D3DAB5FC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_VideoToolbox::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

_QWORD *sub_1D3DAB69C(_QWORD **a1, _QWORD *a2)
{
  _QWORD *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1D3DC3680(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

_QWORD *sub_1D3DAB6D8(_QWORD **a1, _QWORD *a2)
{
  _QWORD *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1D3DC4200(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

void sub_1D3DAB718()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAB72C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2BC0;
  return result;
}

void sub_1D3DAB750(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2BC0;
}

void sub_1D3DAB768(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_VideoToolbox::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DAB808(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAB840()
{
  return &unk_1E95B2C20;
}

void sub_1D3DAB850()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAB864()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2B40;
  return result;
}

void sub_1D3DAB888(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2B40;
}

uint64_t sub_1D3DAB8A0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAB8D8()
{
  return &unk_1E95B2BA0;
}

uint64_t sub_1D3DAB8E4(uint64_t a1)
{
  sub_1D3D74EDC((unint64_t *)(a1 + 240));
  sub_1D3D982CC((unint64_t *)(a1 + 232));
  sub_1D3D982CC((unint64_t *)(a1 + 224));
  sub_1D3D982CC((unint64_t *)(a1 + 216));
  sub_1D3DAB6D8((_QWORD **)(a1 + 208), 0);
  sub_1D3DAB69C((_QWORD **)(a1 + 200), 0);
  return a1;
}

void sub_1D3DAB93C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDPostprocessor::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t *sub_1D3DAB9DC(uint64_t *result, unint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[5];

  if (a2 > (result[2] - *result) >> 3)
  {
    if (a2 >> 61)
      sub_1D3D6D4F8();
    v2 = result;
    v3 = result[1] - *result;
    v5[4] = result + 2;
    v5[0] = sub_1D3D6D8A0(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 8 * v4;
    sub_1D3D742F0(v2, v5);
    return (uint64_t *)sub_1D3D743C8((uint64_t)v5);
  }
  return result;
}

void sub_1D3DABA5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D743C8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1D3DABA70(uint64_t a1, _OWORD *a2, uint64_t a3, char a4)
{
  __int128 *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  __int128 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  float v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  float *v22;
  float *v23;
  float v24;
  float *v25;
  float v26;
  float *v27;
  __int128 v28;
  float v29;
  float v30;
  __int128 *v31;
  __int128 v32;
  BOOL v33;
  uint64_t v34;
  float v35;
  unint64_t v36;
  float v37;
  float *v38;
  float *v39;
  float v40;
  uint64_t v41;
  __int128 v42;
  float v43;
  float v44;
  __int128 *v45;
  __int128 v46;
  __int128 v47;
  _OWORD *v48;
  _OWORD *v49;
  _OWORD *v50;
  __int128 v51;
  _OWORD *v52;
  BOOL v54;
  uint64_t v55;
  unint64_t v56;
  _OWORD *v57;
  float v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int64_t v63;
  int64_t v64;
  int64_t v65;
  uint64_t v66;
  unint64_t v67;
  float v68;
  unint64_t v69;
  uint64_t v70;
  _OWORD *v71;
  __int128 v72;
  uint64_t v73;
  uint64_t v74;
  int64_t v75;
  uint64_t v76;
  unint64_t v77;
  _OWORD *v78;
  uint64_t v79;
  uint64_t v80;
  int64_t v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  unint64_t v85;
  float v86;
  uint64_t v87;
  _OWORD *v88;
  __int128 v89;
  uint64_t v91;
  float v92;
  uint64_t v93;
  float v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  _BYTE v98[28];
  _BYTE v99[28];
  _BYTE v100[28];
  _BYTE v101[28];
  _BYTE v102[28];
  _BYTE v103[28];
  _BYTE v104[28];
  _BYTE v105[28];
  __int128 v106;
  __int128 v107;
  _BYTE v108[28];
  __int128 v109;

_QWORD *sub_1D3DAC3A8(_QWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  char *v8;

  a1[3] = 0;
  a1[4] = a4;
  if (a2)
  {
    if (a2 >= 0x924924924924925)
      sub_1D3D6D50C();
    v7 = (char *)operator new(28 * a2);
  }
  else
  {
    v7 = 0;
  }
  v8 = &v7[28 * a3];
  *a1 = v7;
  a1[1] = v8;
  a1[2] = v8;
  a1[3] = &v7[28 * a2];
  return a1;
}

__n128 sub_1D3DAC424(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  float v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _BYTE v10[28];
  _BYTE v11[28];
  _BYTE v12[28];
  _BYTE v13[28];

  result.n128_u32[0] = *(_DWORD *)(a2 + 16);
  v4 = *(float *)(a3 + 16);
  if (result.n128_f32[0] <= *(float *)(a1 + 16))
  {
    if (v4 > result.n128_f32[0])
    {
      *(_OWORD *)v11 = *(_OWORD *)a2;
      *(_OWORD *)&v11[12] = *(_OWORD *)(a2 + 12);
      v6 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v6;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v11[12];
      result = *(__n128 *)v11;
      *(_OWORD *)a3 = *(_OWORD *)v11;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)v12 = *(_OWORD *)a1;
        *(_OWORD *)&v12[12] = *(_OWORD *)(a1 + 12);
        v7 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v7;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v12[12];
        result = *(__n128 *)v12;
        *(_OWORD *)a2 = *(_OWORD *)v12;
      }
    }
  }
  else
  {
    if (v4 <= result.n128_f32[0])
    {
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a1 + 12);
      v8 = *(_OWORD *)(a2 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 12) = v8;
      *(_OWORD *)(a2 + 12) = *(_OWORD *)&v13[12];
      result = *(__n128 *)v13;
      *(_OWORD *)a2 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a3 + 16);
      if (result.n128_f32[0] <= *(float *)(a2 + 16))
        return result;
      *(_OWORD *)v10 = *(_OWORD *)a2;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a2 + 12);
      v9 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v9;
    }
    else
    {
      *(_OWORD *)v10 = *(_OWORD *)a1;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a1 + 12);
      v5 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 12) = v5;
    }
    *(_OWORD *)(a3 + 12) = *(_OWORD *)&v10[12];
    result = *(__n128 *)v10;
    *(_OWORD *)a3 = *(_OWORD *)v10;
  }
  return result;
}

__n128 sub_1D3DAC55C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[28];
  _BYTE v13[28];
  _BYTE v14[28];

  result = sub_1D3DAC424(a1, a2, a3);
  result.n128_u32[0] = *(_DWORD *)(a4 + 16);
  if (result.n128_f32[0] > *(float *)(a3 + 16))
  {
    *(_OWORD *)v12 = *(_OWORD *)a3;
    *(_OWORD *)&v12[12] = *(_OWORD *)(a3 + 12);
    v9 = *(_OWORD *)(a4 + 12);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 12) = v9;
    *(_OWORD *)(a4 + 12) = *(_OWORD *)&v12[12];
    result = *(__n128 *)v12;
    *(_OWORD *)a4 = *(_OWORD *)v12;
    result.n128_u32[0] = *(_DWORD *)(a3 + 16);
    if (result.n128_f32[0] > *(float *)(a2 + 16))
    {
      *(_OWORD *)v13 = *(_OWORD *)a2;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a2 + 12);
      v10 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v10;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v13[12];
      result = *(__n128 *)v13;
      *(_OWORD *)a3 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)v14 = *(_OWORD *)a1;
        *(_OWORD *)&v14[12] = *(_OWORD *)(a1 + 12);
        v11 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v11;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v14[12];
        result = *(__n128 *)v14;
        *(_OWORD *)a2 = *(_OWORD *)v14;
      }
    }
  }
  return result;
}

BOOL sub_1D3DAC658(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  _OWORD *v17;
  _OWORD *v18;
  __int128 v19;
  _BYTE v20[28];
  __int128 v21;
  _BYTE v22[28];
  _BYTE v23[28];
  _BYTE v24[28];
  _BYTE v25[28];

  v4 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 2);
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 12) > *(float *)(a1 + 16))
      {
        *(_OWORD *)v20 = *(_OWORD *)a1;
        *(_OWORD *)&v20[12] = *(_OWORD *)(a1 + 12);
        v6 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 12) = v6;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v20[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v20;
      }
      return result;
    case 3:
      sub_1D3DAC424(a1, a1 + 28, a2 - 28);
      return 1;
    case 4:
      sub_1D3DAC55C(a1, a1 + 28, a1 + 56, a2 - 28);
      return 1;
    case 5:
      v16 = (_OWORD *)(a1 + 28);
      v17 = (_OWORD *)(a1 + 56);
      v18 = (_OWORD *)(a1 + 84);
      sub_1D3DAC55C(a1, a1 + 28, a1 + 56, a1 + 84);
      if (*(float *)(a2 - 12) > *(float *)(a1 + 100))
      {
        *(_OWORD *)v22 = *v18;
        *(_OWORD *)&v22[12] = *(_OWORD *)(a1 + 96);
        v19 = *(_OWORD *)(a2 - 16);
        *v18 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 96) = v19;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v22[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v22;
        if (*(float *)(a1 + 100) > *(float *)(a1 + 72))
        {
          *(_OWORD *)v23 = *v17;
          *(_OWORD *)&v23[12] = *(_OWORD *)(a1 + 68);
          *v17 = *v18;
          *(_OWORD *)(a1 + 68) = *(_OWORD *)(a1 + 96);
          *v18 = *(_OWORD *)v23;
          *(_OWORD *)(a1 + 96) = *(_OWORD *)&v23[12];
          if (*(float *)(a1 + 72) > *(float *)(a1 + 44))
          {
            *(_OWORD *)v24 = *v16;
            *(_OWORD *)&v24[12] = *(_OWORD *)(a1 + 40);
            *v16 = *v17;
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 68);
            *v17 = *(_OWORD *)v24;
            *(_OWORD *)(a1 + 68) = *(_OWORD *)&v24[12];
            if (*(float *)(a1 + 44) > *(float *)(a1 + 16))
            {
              *(_OWORD *)v25 = *(_OWORD *)a1;
              *(_OWORD *)&v25[12] = *(_OWORD *)(a1 + 12);
              *(_OWORD *)a1 = *v16;
              *(_OWORD *)(a1 + 12) = *(_OWORD *)(a1 + 40);
              *v16 = *(_OWORD *)v25;
              *(_OWORD *)(a1 + 40) = *(_OWORD *)&v25[12];
            }
          }
        }
      }
      return 1;
    default:
      v7 = a1 + 56;
      sub_1D3DAC424(a1, a1 + 28, a1 + 56);
      v8 = a1 + 84;
      if (a1 + 84 == a2)
        return 1;
      v9 = 0;
      v10 = 0;
      break;
  }
  while (1)
  {
    v11 = *(float *)(v8 + 16);
    if (v11 > *(float *)(v7 + 16))
    {
      v21 = *(_OWORD *)v8;
      v12 = *(_QWORD *)(v8 + 20);
      v13 = v9;
      while (1)
      {
        v14 = a1 + v13;
        *(_OWORD *)(v14 + 84) = *(_OWORD *)(a1 + v13 + 56);
        *(_OWORD *)(v14 + 96) = *(_OWORD *)(a1 + v13 + 68);
        if (v13 == -56)
          break;
        v13 -= 28;
        if (v11 <= *(float *)(v14 + 44))
        {
          v15 = a1 + v13 + 84;
          goto LABEL_13;
        }
      }
      v15 = a1;
LABEL_13:
      *(_OWORD *)v15 = v21;
      *(float *)(v15 + 16) = v11;
      *(_QWORD *)(v15 + 20) = v12;
      if (++v10 == 8)
        return v8 + 28 == a2;
    }
    v7 = v8;
    v9 += 28;
    v8 += 28;
    if (v8 == a2)
      return 1;
  }
}

void sub_1D3DAC930(char **a1, _DWORD *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8)
{
  unint64_t v16;
  char *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  char *v36;
  char *v37;
  char *v38;
  __int128 v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;

  v16 = (unint64_t)a1[2];
  v17 = a1[1];
  if ((unint64_t)v17 >= v16)
  {
    v25 = 0x6DB6DB6DB6DB6DB7 * ((v17 - *a1) >> 2);
    v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) > 0x924924924924924)
      sub_1D3D6D4F8();
    v27 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v16 - (_QWORD)*a1) >> 2);
    if (2 * v27 > v26)
      v26 = 2 * v27;
    if (v27 >= 0x492492492492492)
      v28 = 0x924924924924924;
    else
      v28 = v26;
    sub_1D3DAC3A8(&v42, v28, v25, (uint64_t)(a1 + 2));
    v29 = v44;
    v30 = *a3;
    v31 = *a4;
    v32 = *a5;
    v33 = *a6;
    v34 = *a7;
    v35 = *a8;
    *(_DWORD *)v44 = *a2;
    *((_DWORD *)v29 + 1) = v30;
    *((_DWORD *)v29 + 2) = v31;
    *((_DWORD *)v29 + 3) = v32;
    *((_DWORD *)v29 + 4) = v33;
    *((_DWORD *)v29 + 5) = v34;
    *((_DWORD *)v29 + 6) = v35;
    v24 = v29 + 28;
    v44 = v29 + 28;
    v37 = *a1;
    v36 = a1[1];
    v38 = v43;
    if (v36 == *a1)
    {
      v40 = a1[1];
    }
    else
    {
      do
      {
        v39 = *(_OWORD *)(v36 - 28);
        *((_OWORD *)v38 - 1) = *((_OWORD *)v36 - 1);
        *(_OWORD *)(v38 - 28) = v39;
        v38 -= 28;
        v36 -= 28;
      }
      while (v36 != v37);
      v40 = *a1;
      v36 = a1[1];
      v24 = v44;
    }
    *a1 = v38;
    a1[1] = v24;
    v41 = a1[2];
    a1[2] = v45;
    v44 = v36;
    v45 = v41;
    v42 = v40;
    v43 = v40;
    if (v36 != v40)
      v44 = &v40[(v36 - v40 - 28) % 0x1CuLL];
    if (v40)
      operator delete(v40);
  }
  else
  {
    v18 = *a3;
    v19 = *a4;
    v20 = *a5;
    v21 = *a6;
    v22 = *a7;
    v23 = *a8;
    *(_DWORD *)v17 = *a2;
    *((_DWORD *)v17 + 1) = v18;
    *((_DWORD *)v17 + 2) = v19;
    *((_DWORD *)v17 + 3) = v20;
    *((_DWORD *)v17 + 4) = v21;
    *((_DWORD *)v17 + 5) = v22;
    v24 = v17 + 28;
    *((_DWORD *)v17 + 6) = v23;
  }
  a1[1] = v24;
}

unint64_t *sub_1D3DACB24(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 32))
    *(_BYTE *)(a1 + 32) = sub_1D3DD4E7C((unint64_t *)a1, a1 + 8, 1, *(_QWORD *)(a1 + 24)) ^ 1;
  return sub_1D3D82B54((unint64_t *)a1);
}

void sub_1D3DACB70()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DACB84()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95ADBA8;
  return result;
}

void sub_1D3DACBA8(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95ADBA8;
}

void sub_1D3DACBC0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDPostprocessor::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DACC60(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc9inference4anmd17ANMDPostprocessor3runERKNS1_21ANMDImagePreprocessorERKNS_6Sample11PixelBufferERK17CGAffineTransformRNSt3__18optionalINS_5ErrorEEERKNSE_IyEEE3$_4"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DACC98()
{
  return &unk_1E95AD088;
}

void sub_1D3DACCA8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DACCBC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95ADB50;
  return result;
}

void sub_1D3DACCE0(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95ADB50;
}

uint64_t sub_1D3DACCF8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc9inference4anmd17ANMDPostprocessor3runERKNS1_21ANMDImagePreprocessorERKNS_6Sample11PixelBufferERK17CGAffineTransformRNSt3__18optionalINS_5ErrorEEERKNSE_IyEEE3$_3"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DACD30()
{
  return &unk_1E95AD078;
}

uint64_t sub_1D3DACD3C(uint64_t a1, uint64_t a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = (unint64_t *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  do
    v5 = __ldaxr(v4);
  while (__stlxr(0, v4));
  *(_QWORD *)(a1 + 8) = v5;
  v6 = (unint64_t *)(a2 + 16);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(0, v6));
  *(_QWORD *)(a1 + 16) = v7;
  v8 = *(_OWORD *)(a2 + 24);
  v9 = *(_OWORD *)(a2 + 40);
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  v10 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  v11 = a1 + 72;
  *(_QWORD *)(a1 + 64) = v10;
  *(_BYTE *)(a1 + 200) = 0;
  if (*(_BYTE *)(a2 + 200))
  {
    sub_1D3D860F0(v11, (__int128 *)(a2 + 72));
    *(_BYTE *)(a1 + 200) = 1;
    if (*(_BYTE *)(a2 + 200))
    {
      sub_1D3D85FD8(a2 + 72);
      *(_BYTE *)(a2 + 200) = 0;
    }
  }
  v12 = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a2 + 208) = 0;
  *(_QWORD *)(a1 + 208) = v12;
  v13 = *(_QWORD *)(a2 + 216);
  *(_QWORD *)(a2 + 216) = 0;
  *(_QWORD *)(a1 + 216) = v13;
  v14 = *(_QWORD *)(a2 + 224);
  *(_QWORD *)(a2 + 224) = 0;
  *(_QWORD *)(a1 + 224) = v14;
  v15 = *(_QWORD *)(a2 + 232);
  *(_QWORD *)(a2 + 232) = 0;
  *(_QWORD *)(a1 + 232) = v15;
  *(_QWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
  *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
  v16 = *(_QWORD *)(a2 + 264);
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_QWORD *)(a1 + 264) = v16;
  return a1;
}

uint64_t sub_1D3DACE4C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void **v5;

  v2 = *(_QWORD *)(a1 + 264);
  *(_QWORD *)(a1 + 264) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v5 = (void **)(a1 + 240);
  sub_1D3DACF04(&v5);
  sub_1D3DACF78((uint64_t *)(a1 + 232), 0);
  sub_1D3DACF78((uint64_t *)(a1 + 224), 0);
  sub_1D3DACF78((uint64_t *)(a1 + 216), 0);
  sub_1D3DACF78((uint64_t *)(a1 + 208), 0);
  if (*(_BYTE *)(a1 + 200))
    sub_1D3D85FD8(a1 + 72);
  v3 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  sub_1D3D8BA0C((unint64_t *)(a1 + 16));
  sub_1D3D8BA0C((unint64_t *)(a1 + 8));
  return a1;
}

void sub_1D3DACF04(void ***a1)
{
  void **v1;
  uint64_t *v2;
  uint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (uint64_t *)**a1;
  if (v2)
  {
    v4 = (uint64_t *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_1D3DACF78(--v4, 0);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_1D3DACF78(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    sub_1D3D82720(v2 + 16);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

void sub_1D3DACFC4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDModel::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DAD064(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a2 + 128))
  {
    if (*(_BYTE *)(a1 + 128))
    {
      if (*(char *)(a1 + 23) < 0)
        operator delete(*(void **)a1);
      v4 = *(_OWORD *)a2;
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      *(_OWORD *)a1 = v4;
      *(_BYTE *)(a2 + 23) = 0;
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
      sub_1D3D85E40((_QWORD *)(a1 + 32));
      v5 = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a1 + 32) = v5;
      sub_1D3D85CA8((_QWORD *)(a1 + 40));
      v6 = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a2 + 40) = 0;
      *(_QWORD *)(a1 + 40) = v6;
      sub_1D3D861CC(a1 + 48, (uint64_t *)(a2 + 48));
      sub_1D3D861CC(a1 + 88, (uint64_t *)(a2 + 88));
    }
  }
  else if (*(_BYTE *)(a1 + 128))
  {
    sub_1D3D85FD8(a1);
    *(_BYTE *)(a1 + 128) = 0;
  }
  else
  {
    sub_1D3D860F0(a1, (__int128 *)a2);
    *(_BYTE *)(a1 + 128) = 1;
  }
}

uint64_t sub_1D3DAD13C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    sub_1D3DACF78((uint64_t *)(i - 8), 0);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

double sub_1D3DAD18C(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  double result;

  v6 = operator new();
  v7 = *(_DWORD *)(a2 + 4);
  *(int8x16_t *)(v6 + 8) = vextq_s8(*(int8x16_t *)(a2 + 56), *(int8x16_t *)(a2 + 56), 8uLL);
  if (v7 == 3)
    v8 = 1380411457;
  else
    v8 = 1380410945;
  *(_DWORD *)(v6 + 24) = v8;
  *(_BYTE *)(v6 + 28) = 0;
  *(_QWORD *)&v9 = -1;
  *((_QWORD *)&v9 + 1) = -1;
  *(_OWORD *)(v6 + 32) = v9;
  *(_OWORD *)(v6 + 48) = v9;
  *(_QWORD *)v6 = &off_1E95B2580;
  v10 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v6 + 128) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v6 + 144) = v10;
  *(_OWORD *)(v6 + 160) = *(_OWORD *)(a2 + 96);
  v11 = *(_QWORD *)(a2 + 112);
  v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v6 + 64) = *(_OWORD *)a2;
  *(_OWORD *)(v6 + 80) = v12;
  v13 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v6 + 96) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v6 + 112) = v13;
  v14 = *a3;
  *(_QWORD *)(v6 + 176) = v11;
  *(_QWORD *)(v6 + 184) = v14;
  *(_DWORD *)(v6 + 192) = 1;
  result = 0.0;
  *(_OWORD *)(v6 + 200) = 0u;
  *(_OWORD *)(v6 + 216) = 0u;
  *(_OWORD *)(v6 + 232) = 0u;
  *a1 = v6;
  return result;
}

uint64_t sub_1D3DAD258(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1D3DAB8E4(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

double sub_1D3DAD294(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  double result;

  v4 = operator new();
  *(int8x16_t *)(v4 + 8) = vextq_s8(*(int8x16_t *)(a2 + 56), *(int8x16_t *)(a2 + 56), 8uLL);
  strcpy((char *)(v4 + 24), "ARGB");
  *(_QWORD *)&v5 = -1;
  *((_QWORD *)&v5 + 1) = -1;
  *(_OWORD *)(v4 + 32) = v5;
  *(_OWORD *)(v4 + 48) = v5;
  *(_BYTE *)(v4 + 64) = 0;
  *(_BYTE *)(v4 + 192) = 0;
  *(_BYTE *)(v4 + 208) = 0;
  *(_BYTE *)(v4 + 336) = 0;
  *(_BYTE *)(v4 + 352) = 0;
  *(_BYTE *)(v4 + 384) = 0;
  *(_BYTE *)(v4 + 392) = 0;
  *(_BYTE *)(v4 + 424) = 0;
  *(_BYTE *)(v4 + 432) = 0;
  *(_BYTE *)(v4 + 464) = 0;
  *(_BYTE *)(v4 + 472) = 0;
  *(_BYTE *)(v4 + 504) = 0;
  *(_BYTE *)(v4 + 512) = 0;
  *(_BYTE *)(v4 + 544) = 0;
  *(_QWORD *)v4 = &off_1E95B2538;
  v6 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v4 + 616) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v4 + 632) = v6;
  *(_OWORD *)(v4 + 648) = *(_OWORD *)(a2 + 96);
  *(_QWORD *)(v4 + 664) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v4 + 552) = *(_OWORD *)a2;
  *(_OWORD *)(v4 + 568) = v7;
  v8 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 584) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v4 + 600) = v8;
  result = 0.0;
  *(_OWORD *)(v4 + 672) = 0u;
  *a1 = v4;
  return result;
}

void sub_1D3DAD370()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAD384()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AD838;
  return result;
}

void sub_1D3DAD3A8(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AD838;
}

void sub_1D3DAD3C0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDModel::prepare", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DAD460(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAD498()
{
  return &unk_1E95ACFE8;
}

void sub_1D3DAD4A8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAD4BC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AD7E0;
  return result;
}

void sub_1D3DAD4E0(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AD7E0;
}

uint64_t sub_1D3DAD4F8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAD530()
{
  return &unk_1E95ACFD8;
}

void sub_1D3DAD53C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDModel::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DAD5E0()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAD5F4()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2DC0;
  return result;
}

void sub_1D3DAD618(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2DC0;
}

void sub_1D3DAD630(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDModel::run", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DAD6D0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel3runERKNS_6SampleERKNSt3__18optionalINS6_17reference_wrapperINS2_16InferenceMetricsEEEEERNS7_INS_5ErrorEEERKNS7_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAD708()
{
  return &unk_1E95B2E20;
}

void sub_1D3DAD718()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAD72C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B2D40;
  return result;
}

void sub_1D3DAD750(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B2D40;
}

uint64_t sub_1D3DAD768(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel3runERKNS_6SampleERKNSt3__18optionalINS6_17reference_wrapperINS2_16InferenceMetricsEEEEERNS7_INS_5ErrorEEERKNS7_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAD7A0()
{
  return &unk_1E95B2DA0;
}

void sub_1D3DAD7AC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDModel::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DAD850()
{
  JUMPOUT(0x1D8254C54);
}

const char *sub_1D3DAD864()
{
  return "anmd-model";
}

uint64_t sub_1D3DAD874()
{
  return 0;
}

uint64_t sub_1D3DAD87C()
{
  return 0;
}

const char *sub_1D3DAD884()
{
  return "MRCANMD";
}

const char *sub_1D3DAD890()
{
  return "main";
}

const char *sub_1D3DAD89C()
{
  return "input_image";
}

const char *sub_1D3DAD8B0()
{
  return "detections";
}

const char *sub_1D3DAD8C4()
{
  return "box_cls";
}

const char *sub_1D3DAD8D8()
{
  return "rotation";
}

char **sub_1D3DAD8EC()
{
  return off_1E95B2610;
}

void sub_1D3DAD900()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAD914()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AC040;
  return result;
}

void sub_1D3DAD938(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AC040;
}

void sub_1D3DAD950(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89F20 != -1)
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89F78;
    if (os_signpost_enabled((os_log_t)qword_1EDB89F78))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDModel::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DAD9F0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel6createERKNS_7Context7OptionsEbRNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DADA28()
{
  return &unk_1E95ABC38;
}

void sub_1D3DADA38()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DADA4C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95ABFE8;
  return result;
}

void sub_1D3DADA70(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95ABFE8;
}

uint64_t sub_1D3DADA88(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel6createERKNS_7Context7OptionsEbRNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DADAC0()
{
  return &unk_1E95ABC28;
}

void sub_1D3DADACC(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  std::__shared_weak_count *v4;
  os_unfair_lock_s *v5;
  _QWORD *v6;
  uint64_t v7;
  NSObject *shared_weak_owners;
  _QWORD *v9;
  uint64_t v10;
  NSObject *v11;
  dispatch_queue_t v12;
  uint64_t (*v13)(_QWORD);
  CFTypeRef v14;
  CFTypeRef v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  uint64_t (***v19)();
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  NSObject *v25;
  NSObject *v26;
  dispatch_time_t v27;
  NSObject *v28;
  uint64_t *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  void *v35;
  __int128 v36;
  _BYTE v37[24];
  _BYTE *v38;
  uint64_t (**v39)();
  char v40;
  uint64_t (***v41)();
  _QWORD *v42;
  uint64_t v43;
  uint64_t context[3];
  uint64_t *v45;
  char v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v2 = a2 + 3;
  if (!a2[3])
    return;
  v4 = (std::__shared_weak_count *)a1;
  v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  v6 = sub_1D3D967F4(&v4[1].__vftable, (unint64_t)&unk_1D3E68948);
  if (!v6)
  {
    v7 = (uint64_t)v4->__vftable;
    shared_weak_owners = v4->__shared_weak_owners_;
    v35 = &unk_1D3E68948;
    *(_QWORD *)&v36 = "ANMDContext";
    *((_QWORD *)&v36 + 1) = 11;
    v9 = (_QWORD *)operator new();
    v10 = operator new();
    v11 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v12 = dispatch_queue_create_with_target_V2("mrc::Context::ConcreteBase<mrc::inference::anmd::(anonymous namespace)::ANMDContext>::ConcreteBase(const Options &, dispatch_queue_t _Nonnull) [_Derived = mrc::inference::anmd::(anonymous namespace)::ANMDContext]", v11, shared_weak_owners);
    v13 = MEMORY[0x1E0C82E98];
    *(_QWORD *)(v10 + 8) = v12;
    *(_QWORD *)(v10 + 16) = v13;
    *(_QWORD *)v10 = &off_1E95AEF60;
    *(_QWORD *)(v10 + 24) = *(_QWORD *)v7;
    v14 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 8));
    if (v14)
      v14 = CFRetain(v14);
    *(_QWORD *)(v10 + 32) = v14;
    v15 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 16));
    if (v15)
      v15 = CFRetain(v15);
    *(_QWORD *)(v10 + 40) = v15;
    v16 = *(_OWORD *)(v7 + 24);
    v17 = *(_OWORD *)(v7 + 40);
    *(_WORD *)(v10 + 80) = *(_WORD *)(v7 + 56);
    *(_OWORD *)(v10 + 48) = v16;
    *(_OWORD *)(v10 + 64) = v17;
    *(_BYTE *)(v10 + 88) = 0;
    *(_BYTE *)(v10 + 360) = 0;
    *(_BYTE *)(v10 + 368) = 0;
    *(_BYTE *)(v10 + 464) = 0;
    *(_QWORD *)(v10 + 472) = dispatch_group_create();
    *(_QWORD *)(v10 + 480) = MEMORY[0x1E0C82E98];
    *v9 = v10;
    v18 = (_QWORD *)operator new();
    *v18 = &off_1E95B0430;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = v10;
    v9[1] = v18;
    v39 = &off_1E95AFD28;
    v41 = &v39;
    v42 = v9;
    sub_1D3D96968((uint64_t)&v43, (uint64_t)&v39);
    sub_1D3E23E40((uint64_t)context, (uint64_t)&unk_1D3E68948, &v36, (uint64_t *)&v42);
    sub_1D3D969CC((uint64_t *)&v42);
    v19 = v41;
    if (v41 == &v39)
    {
      v20 = 4;
      v19 = &v39;
    }
    else
    {
      if (!v41)
      {
LABEL_12:
        v6 = sub_1D3D96A58((uint64_t *)&v4[1], &v35, context);
        sub_1D3D969CC((uint64_t *)&v45);
        sub_1D3E23B04((uint64_t *)v4);
        goto LABEL_13;
      }
      v20 = 5;
    }
    (*v19)[v20]();
    goto LABEL_12;
  }
LABEL_13:
  if ((_UNKNOWN *)v6[3] != &unk_1D3E68948)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_59;
  }
  v21 = (uint64_t *)v6[6];
  if (!v21)
  {
LABEL_59:
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_60;
  }
  v22 = *v21;
  v4 = (std::__shared_weak_count *)v21[1];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v5);
  if (!v22)
  {
    if (qword_1EDB89F20 == -1)
    {
LABEL_23:
      v25 = qword_1EDB89F78;
      if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
      {
        LOWORD(context[0]) = 0;
        _os_log_error_impl(&dword_1D3D6B000, v25, OS_LOG_TYPE_ERROR, "Unable to retrieve or instantiate concrete ANMD context.", (uint8_t *)context, 2u);
      }
      LOBYTE(v39) = 0;
      v40 = 0;
      sub_1D3DF4E68((uint64_t)&v42, -1, 0);
      sub_1D3DF50BC(context, (uint64_t *)&v42);
      v46 = 1;
      if (!*v2)
        sub_1D3D75A24();
      (*(void (**)(_QWORD, uint64_t (***)(), uint64_t *))(*(_QWORD *)*v2 + 48))(*v2, &v39, context);
      if (v46)
        sub_1D3DF4F24((unint64_t *)context);
      sub_1D3DF4F24((unint64_t *)&v42);
      goto LABEL_52;
    }
LABEL_60:
    dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    goto LABEL_23;
  }
  if (!*v2)
  {
    v2 = &v38;
    goto LABEL_30;
  }
  if ((_QWORD *)*v2 != a2)
  {
    v38 = (_BYTE *)*v2;
LABEL_30:
    *v2 = 0;
    goto LABEL_32;
  }
  v38 = v37;
  (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v37);
LABEL_32:
  if (!v38)
    goto LABEL_52;
  v26 = *(NSObject **)(v22 + 472);
  v27 = dispatch_time(0, 3000000000);
  if (dispatch_group_wait(v26, v27))
  {
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v28 = qword_1EDB89F78;
    if (os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_ERROR))
    {
      LOWORD(context[0]) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v28, OS_LOG_TYPE_ERROR, "Timed out waiting for model to be loaded.", (uint8_t *)context, 2u);
    }
    LOBYTE(v39) = 0;
    v40 = 0;
    sub_1D3DF4E68((uint64_t)&v42, -6010, CFSTR("Timed out waiting for model to be loaded."));
    sub_1D3DF50BC(context, (uint64_t *)&v42);
    v46 = 1;
    if (!v38)
      sub_1D3D75A24();
    (*(void (**)(_BYTE *, uint64_t (***)(), uint64_t *))(*(_QWORD *)v38 + 48))(v38, &v39, context);
    if (v46)
      sub_1D3DF4F24((unint64_t *)context);
    sub_1D3DF4F24((unint64_t *)&v42);
  }
  else
  {
    context[0] = (uint64_t)&off_1E95AFDD8;
    context[1] = v22;
    context[2] = (uint64_t)v37;
    v45 = context;
    dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v22 + 8), context, (dispatch_function_t)sub_1D3DAE290);
    v29 = v45;
    if (v45 == context)
    {
      v30 = 4;
      v29 = context;
    }
    else
    {
      if (!v45)
        goto LABEL_47;
      v30 = 5;
    }
    (*(void (**)(void))(*v29 + 8 * v30))();
  }
LABEL_47:
  v31 = v38;
  if (v38 == v37)
  {
    v32 = 4;
    v31 = v37;
  }
  else
  {
    if (!v38)
      goto LABEL_52;
    v32 = 5;
  }
  (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_52:
  if (v4)
  {
    v33 = (unint64_t *)&v4->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1D3DAE080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DAE1F8(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 472);
    *(_QWORD *)(v1 + 472) = 0;
    if (v2)
      (*(void (**)(void))(v1 + 480))();
    if (*(_BYTE *)(v1 + 464))
      sub_1D3DF4F24((unint64_t *)(v1 + 368));
    if (*(_BYTE *)(v1 + 360))
      sub_1D3DACE4C(v1 + 88);
    sub_1D3D8BA0C((unint64_t *)(v1 + 40));
    sub_1D3D8BA0C((unint64_t *)(v1 + 32));
    v3 = *(_QWORD *)(v1 + 8);
    *(_QWORD *)v1 = &off_1E95AEEA0;
    *(_QWORD *)(v1 + 8) = 0;
    if (v3)
      (*(void (**)(void))(v1 + 16))();
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3DAE290(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (!v1)
    sub_1D3D75A24();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void sub_1D3DAE2B8()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3DAE2CC(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95AFDD8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3DAE304(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AFDD8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unint64_t *sub_1D3DAE324(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *result;
  unint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  CFTypeRef v12;
  CFTypeRef v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  char **v29;
  char **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  unint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  int64x2_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  int v48;
  NSObject *v49;
  _BOOL4 v50;
  double v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  char *v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  char *v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  char *v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  unint64_t v78;
  _QWORD *v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  double v89;
  uint64_t v90;
  NSObject *v91;
  os_signpost_id_t v92;
  char v93;
  unint64_t v94[3];
  _OWORD v95[2];
  __int16 v96;
  _QWORD *v97;
  _BYTE v98[24];
  char v99;
  char v100;
  __int128 v101;
  __int128 v102;
  int64x2_t v103;
  __int128 v104;
  char v105;
  uint64_t v106[2];
  _BYTE __p[24];
  unint64_t v108;
  __int128 *v109;
  char v110;
  unsigned __int8 v111;
  _QWORD v112[3];
  _QWORD *v113;
  _QWORD v114[3];
  _QWORD *v115;
  os_signpost_id_t *v116;
  _QWORD v117[3];
  _QWORD *v118;
  _QWORD v119[3];
  _QWORD *v120;
  _QWORD v121[3];
  _QWORD *v122;
  os_signpost_id_t *v123;
  _QWORD v124[3];
  _QWORD *v125;
  uint64_t v126;

  v126 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v2 + 464))
  {
    v3 = *(_QWORD *)(a1 + 16);
    __p[0] = 0;
    __p[8] = 0;
    sub_1D3DF4F6C((uint64_t)v94, v2 + 368);
    v99 = 1;
    v4 = *(_QWORD *)(v3 + 24);
    if (!v4)
      sub_1D3D75A24();
    result = (unint64_t *)(*(uint64_t (**)(uint64_t, _BYTE *, unint64_t *))(*(_QWORD *)v4 + 48))(v4, __p, v94);
LABEL_4:
    if (!v99)
      return result;
    v6 = v94;
    return sub_1D3DF4F24(v6);
  }
  if (!*(_BYTE *)(v2 + 360))
  {
    dispatch_group_enter(*(dispatch_group_t *)(v2 + 472));
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v93 = 1;
    v114[0] = &off_1E95ABFE8;
    v115 = v114;
    v112[0] = &off_1E95AC040;
    v113 = v112;
    v92 = os_signpost_id_make_with_pointer((os_log_t)qword_1EDB89F78, (const void *)v2);
    v118 = v117;
    v116 = &v92;
    v117[0] = &off_1E95AC040;
    v94[0] = v92;
    sub_1D3DAD7AC(v92, v94);
    v7 = v113;
    if (v113 == v112)
    {
      v8 = 4;
      v7 = v112;
    }
    else
    {
      if (!v113)
        goto LABEL_14;
      v8 = 5;
    }
    (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_14:
    v9 = v115;
    if (v115 == v114)
    {
      v10 = 4;
      v9 = v114;
    }
    else
    {
      if (!v115)
        goto LABEL_19;
      v10 = 5;
    }
    (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_19:
    v11 = (_QWORD *)operator new();
    *v11 = &off_1E95ABEC8;
    v94[0] = *(_QWORD *)(v2 + 24);
    v12 = (CFTypeRef)atomic_load((unint64_t *)(v2 + 32));
    if (v12)
      v12 = CFRetain(v12);
    v94[1] = (unint64_t)v12;
    v13 = (CFTypeRef)atomic_load((unint64_t *)(v2 + 40));
    if (v13)
      v13 = CFRetain(v13);
    v94[2] = (unint64_t)v13;
    v14 = *(_OWORD *)(v2 + 48);
    v15 = *(_OWORD *)(v2 + 64);
    v96 = *(_WORD *)(v2 + 80);
    v95[0] = v14;
    v95[1] = v15;
    v97 = v11;
    v98[0] = 0;
    v100 = 0;
    v101 = 0u;
    v102 = 0u;
    v103 = 0u;
    v104 = 0u;
    v105 = 1;
    if (qword_1EDB89F20 != -1)
      dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
    v91 = qword_1EDB89F78;
    v16 = os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v16)
    {
      *(_WORD *)__p = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v91, OS_LOG_TYPE_DEBUG, "ANMDModel::create: shouldMakeReadyImmediately is set to true", __p, 2u);
    }
    if (v100)
    {
      v16 = *((_QWORD *)&v104 + 1);
      if (*((_QWORD *)&v104 + 1))
      {
        v16 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)&v104 + 1) + 24))(*((_QWORD *)&v104 + 1));
        if ((_DWORD)v16)
        {
LABEL_141:
          __p[0] = 0;
          v111 = 0;
          if (v105)
          {
            sub_1D3DACD3C((uint64_t)__p, (uint64_t)v94);
            v111 = 1;
            if (v105)
              sub_1D3DACE4C((uint64_t)v94);
          }
          v79 = v118;
          if (*((_BYTE *)v116 + 8))
          {
            if (!v118)
              goto LABEL_152;
            v94[0] = *v116;
            (*(void (**)(void))(*v118 + 48))();
            v79 = v118;
          }
          if (v79 == v117)
          {
            v80 = 4;
            v79 = v117;
          }
          else
          {
            if (!v79)
              goto LABEL_152;
            v80 = 5;
          }
          (*(void (**)(void))(*v79 + 8 * v80))();
LABEL_152:
          v81 = v111;
          if (*(unsigned __int8 *)(v2 + 360) == v111)
          {
            if (!*(_BYTE *)(v2 + 360))
              goto LABEL_159;
            v82 = sub_1D3DACE4C(v2 + 88);
            sub_1D3DACD3C(v82, (uint64_t)__p);
          }
          else if (*(_BYTE *)(v2 + 360))
          {
            sub_1D3DACE4C(v2 + 88);
            *(_BYTE *)(v2 + 360) = 0;
          }
          else
          {
            sub_1D3DACD3C(v2 + 88, (uint64_t)__p);
            *(_BYTE *)(v2 + 360) = 1;
          }
          v81 = v111;
LABEL_159:
          if (v81)
            sub_1D3DACE4C((uint64_t)__p);
          dispatch_group_leave(*(dispatch_group_t *)(v2 + 472));
          if (!*(_BYTE *)(v2 + 360))
            goto LABEL_167;
          goto LABEL_162;
        }
      }
    }
    v122 = v121;
    v119[0] = &off_1E95AD838;
    v120 = v119;
    v121[0] = &off_1E95AD7E0;
    v125 = v124;
    v123 = &v92;
    v124[0] = &off_1E95AD838;
    if (!v93 || (*(_QWORD *)__p = v92, sub_1D3DACFC4(v16, (os_signpost_id_t *)__p), v17 = v120, v120 == v119))
    {
      v18 = 4;
      v17 = v119;
    }
    else
    {
      if (!v120)
        goto LABEL_36;
      v18 = 5;
    }
    (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_36:
    v19 = v122;
    if (v122 == v121)
    {
      v20 = 4;
      v19 = v121;
    }
    else
    {
      if (!v122)
        goto LABEL_41;
      v20 = 5;
    }
    (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_41:
    v106[0] = (*(uint64_t (**)(_QWORD *))(*v97 + 16))(v97);
    v106[1] = v21;
    v22 = (*(uint64_t (**)(_QWORD *))(*v97 + 24))(v97);
    v23 = (*(uint64_t (**)(_QWORD *))(*v97 + 32))(v97);
    v24 = (*(uint64_t (**)(_QWORD *))(*v97 + 40))(v97);
    v25 = (*(uint64_t (**)(_QWORD *))(*v97 + 48))(v97);
    sub_1D3D88124(__p, (uint64_t)v106, v22, v23, v24, v25, v94, v2 + 368, (uint64_t)&v92);
    sub_1D3DAD064((uint64_t)v98, (uint64_t)__p);
    if (v110)
      sub_1D3D85FD8((uint64_t)__p);
    if (!v100)
      goto LABEL_129;
    v26 = v97;
    if ((_QWORD)v101)
    {
LABEL_45:
      if (*((_QWORD *)&v101 + 1))
      {
LABEL_46:
        if ((_QWORD)v102)
        {
LABEL_47:
          if (*((_QWORD *)&v102 + 1))
          {
LABEL_48:
            v27 = (*(uint64_t (**)(_QWORD *))(*v26 + 88))(v26);
            if (v28)
            {
              v29 = (char **)v27;
              v30 = (char **)(v27 + 8 * v28);
              do
              {
                sub_1D3D81D4C(__p, *v29);
                sub_1D3D86FC8(v106, (uint64_t)v98, (uint64_t)__p, v2 + 368);
                if ((__p[23] & 0x80000000) != 0)
                  operator delete(*(void **)__p);
                v31 = v106[0];
                if (!v106[0])
                  goto LABEL_129;
                if ((sub_1D3D831A4(v106[0], v2 + 368) & 1) == 0)
                {
                  sub_1D3D82720(v31 + 16);
                  v75 = v31;
                  goto LABEL_128;
                }
                v32 = v103.i64[1];
                if (v103.i64[1] >= (unint64_t)v104)
                {
                  v33 = (v103.i64[1] - v103.i64[0]) >> 3;
                  v34 = v33 + 1;
                  if ((unint64_t)(v33 + 1) >> 61)
                    sub_1D3D6D4F8();
                  v35 = v104 - v103.i64[0];
                  if ((uint64_t)(v104 - v103.i64[0]) >> 2 > v34)
                    v34 = v35 >> 2;
                  if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
                    v36 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v36 = v34;
                  v109 = &v104;
                  if (v36)
                    v36 = (unint64_t)sub_1D3D6D8A0(v36);
                  else
                    v37 = 0;
                  v38 = (uint64_t *)(v36 + 8 * v33);
                  v39 = v36 + 8 * v37;
                  v108 = v39;
                  v106[0] = 0;
                  *v38 = v31;
                  v40 = v38 + 1;
                  *(_QWORD *)&__p[16] = v38 + 1;
                  v41 = (_QWORD *)v103.i64[1];
                  v42 = (_QWORD *)v103.i64[0];
                  if (v103.i64[1] == v103.i64[0])
                  {
                    v45 = 0;
                    v44 = vdupq_n_s64(v103.u64[1]);
                  }
                  else
                  {
                    do
                    {
                      v43 = *--v41;
                      *v41 = 0;
                      *--v38 = v43;
                    }
                    while (v41 != v42);
                    v44 = v103;
                    v40 = *(_QWORD **)&__p[16];
                    v39 = v108;
                    v45 = v106[0];
                  }
                  v103.i64[0] = (uint64_t)v38;
                  v103.i64[1] = (uint64_t)v40;
                  *(int64x2_t *)&__p[8] = v44;
                  v46 = v104;
                  *(_QWORD *)&v104 = v39;
                  v108 = v46;
                  *(_QWORD *)__p = v44.i64[0];
                  sub_1D3DAD13C((uint64_t)__p);
                  v103.i64[1] = (uint64_t)v40;
                  v106[0] = 0;
                  if (v45)
                  {
                    sub_1D3D82720(v45 + 16);
                    MEMORY[0x1D8254C54](v45, 0x1062C40434092AELL);
                  }
                }
                else
                {
                  *(_QWORD *)v103.i64[1] = v31;
                  v103.i64[1] = v32 + 8;
                }
                ++v29;
              }
              while (v29 != v30);
            }
            v47 = *((_QWORD *)&v104 + 1);
            if (*((_QWORD *)&v104 + 1))
              goto LABEL_183;
            v48 = _os_feature_enabled_impl();
            if (qword_1EDB89F20 != -1)
              dispatch_once(&qword_1EDB89F20, &unk_1E95B3508);
            v49 = qword_1EDB89F78;
            v50 = os_log_type_enabled((os_log_t)qword_1EDB89F78, OS_LOG_TYPE_DEBUG);
            if (v48)
            {
              if (v50)
              {
                *(_WORD *)__p = 0;
                _os_log_debug_impl(&dword_1D3D6B000, v49, OS_LOG_TYPE_DEBUG, "ANMDImagePreprocessor: using Video Toolbox", __p, 2u);
              }
              v51 = sub_1D3DAD18C((uint64_t *)__p, *(_QWORD *)(v101 + 8) + 16, (uint64_t *)v95);
              v52 = *(_QWORD *)__p;
              *(_QWORD *)__p = 0;
              v53 = *((_QWORD *)&v104 + 1);
              *((_QWORD *)&v104 + 1) = v52;
              if (v53)
                (*(void (**)(uint64_t, double))(*(_QWORD *)v53 + 8))(v53, v51);
              sub_1D3DAD258((uint64_t *)__p);
            }
            else
            {
              if (v50)
              {
                *(_WORD *)__p = 0;
                _os_log_debug_impl(&dword_1D3D6B000, v49, OS_LOG_TYPE_DEBUG, "ANMDImagePreprocessor: using Accelerate", __p, 2u);
              }
              v89 = sub_1D3DAD294((uint64_t *)__p, *(_QWORD *)(v101 + 8) + 16);
              v90 = *((_QWORD *)&v104 + 1);
              *((_QWORD *)&v104 + 1) = *(_QWORD *)__p;
              if (v90)
                (*(void (**)(uint64_t, double))(*(_QWORD *)v90 + 8))(v90, v89);
            }
            v47 = *((_QWORD *)&v104 + 1);
            if (*((_QWORD *)&v104 + 1))
            {
LABEL_183:
              LOBYTE(v64) = (*(uint64_t (**)(uint64_t, uint64_t, os_signpost_id_t *))(*(_QWORD *)v47 + 32))(v47, v2 + 368, &v92);
              goto LABEL_130;
            }
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__p = 0;
              _os_log_error_impl(&dword_1D3D6B000, v49, OS_LOG_TYPE_ERROR, "Failed to allocate image preprocessor.", __p, 2u);
            }
LABEL_129:
            LOBYTE(v64) = 0;
            goto LABEL_130;
          }
          v70 = (char *)(*(uint64_t (**)(_QWORD *))(*v26 + 80))(v26);
          sub_1D3D81D4C(__p, v70);
          sub_1D3D86FC8(v106, (uint64_t)v98, (uint64_t)__p, v2 + 368);
          v71 = (_QWORD *)v106[0];
          v106[0] = 0;
          v72 = *((_QWORD *)&v102 + 1);
          *((_QWORD *)&v102 + 1) = v71;
          if (v72)
          {
            sub_1D3D82720(v72 + 16);
            MEMORY[0x1D8254C54](v72, 0x1062C40434092AELL);
            v71 = (_QWORD *)*((_QWORD *)&v102 + 1);
          }
          if (v71
            && ((*(void (**)(_QWORD *))(*v97 + 80))(v97),
                sub_1D3D82524(v71, v73, (unint64_t *)(v2 + 368))))
          {
            v74 = sub_1D3D831A4(*((uint64_t *)&v102 + 1), v2 + 368);
            if ((__p[23] & 0x80000000) != 0)
              operator delete(*(void **)__p);
            if (v74)
            {
              v26 = v97;
              goto LABEL_48;
            }
          }
          else if ((__p[23] & 0x80000000) != 0)
          {
            operator delete(*(void **)__p);
          }
          v64 = *((_QWORD *)&v102 + 1);
          *((_QWORD *)&v102 + 1) = 0;
          if (!v64)
            goto LABEL_130;
LABEL_127:
          sub_1D3D82720(v64 + 16);
          v75 = v64;
LABEL_128:
          MEMORY[0x1D8254C54](v75, 0x1062C40434092AELL);
          goto LABEL_129;
        }
        v65 = (char *)(*(uint64_t (**)(_QWORD *))(*v26 + 72))(v26);
        sub_1D3D81D4C(__p, v65);
        sub_1D3D86FC8(v106, (uint64_t)v98, (uint64_t)__p, v2 + 368);
        v66 = (_QWORD *)v106[0];
        v106[0] = 0;
        v67 = v102;
        *(_QWORD *)&v102 = v66;
        if (v67)
        {
          sub_1D3D82720(v67 + 16);
          MEMORY[0x1D8254C54](v67, 0x1062C40434092AELL);
          v66 = (_QWORD *)v102;
        }
        if (v66
          && ((*(void (**)(_QWORD *))(*v97 + 72))(v97),
              sub_1D3D82524(v66, v68, (unint64_t *)(v2 + 368))))
        {
          v69 = sub_1D3D831A4(v102, v2 + 368);
          if ((__p[23] & 0x80000000) != 0)
            operator delete(*(void **)__p);
          if (v69)
          {
            v26 = v97;
            goto LABEL_47;
          }
        }
        else if ((__p[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)__p);
        }
        v64 = v102;
        *(_QWORD *)&v102 = 0;
        if (v64)
          goto LABEL_127;
LABEL_130:
        v76 = v125;
        if (*((_BYTE *)v123 + 8))
        {
          if (!v125)
            goto LABEL_138;
          *(_QWORD *)__p = *v123;
          (*(void (**)(void))(*v125 + 48))();
          v76 = v125;
        }
        if (v76 == v124)
        {
          v77 = 4;
          v76 = v124;
          goto LABEL_137;
        }
        if (v76)
        {
          v77 = 5;
LABEL_137:
          (*(void (**)(void))(*v76 + 8 * v77))();
        }
LABEL_138:
        if ((v64 & 1) == 0 && os_log_type_enabled(v91, OS_LOG_TYPE_INFO))
        {
          sub_1D3DF53CC((CFErrorRef *)&v123, v2 + 368);
          v78 = atomic_load((unint64_t *)&v123);
          *(_DWORD *)__p = 138543362;
          *(_QWORD *)&__p[4] = v78;
          _os_log_impl(&dword_1D3D6B000, v91, OS_LOG_TYPE_INFO, "Failed to prepare model: %{public}@", __p, 0xCu);
          sub_1D3D7448C((unint64_t *)&v123);
        }
        goto LABEL_141;
      }
      v59 = (char *)(*(uint64_t (**)(_QWORD *))(*v26 + 64))(v26);
      sub_1D3D81D4C(__p, v59);
      sub_1D3D86FC8(v106, (uint64_t)v98, (uint64_t)__p, v2 + 368);
      v60 = (_QWORD *)v106[0];
      v106[0] = 0;
      v61 = *((_QWORD *)&v101 + 1);
      *((_QWORD *)&v101 + 1) = v60;
      if (v61)
      {
        sub_1D3D82720(v61 + 16);
        MEMORY[0x1D8254C54](v61, 0x1062C40434092AELL);
        v60 = (_QWORD *)*((_QWORD *)&v101 + 1);
      }
      if (v60
        && ((*(void (**)(_QWORD *))(*v97 + 64))(v97),
            sub_1D3D82524(v60, v62, (unint64_t *)(v2 + 368))))
      {
        v63 = sub_1D3D831A4(*((uint64_t *)&v101 + 1), v2 + 368);
        if ((__p[23] & 0x80000000) != 0)
          operator delete(*(void **)__p);
        if (v63)
        {
          v26 = v97;
          goto LABEL_46;
        }
      }
      else if ((__p[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)__p);
      }
      v64 = *((_QWORD *)&v101 + 1);
      *((_QWORD *)&v101 + 1) = 0;
      if (v64)
        goto LABEL_127;
      goto LABEL_130;
    }
    v54 = (char *)(*(uint64_t (**)(_QWORD *))(*v97 + 56))(v97);
    sub_1D3D81D4C(__p, v54);
    sub_1D3D862A0(v106, (uint64_t)v98, (uint64_t)__p, v2 + 368);
    v55 = (_QWORD *)v106[0];
    v106[0] = 0;
    v56 = v101;
    *(_QWORD *)&v101 = v55;
    if (v56)
    {
      sub_1D3D82720(v56 + 16);
      MEMORY[0x1D8254C54](v56, 0x1062C40434092AELL);
      v55 = (_QWORD *)v101;
    }
    if (v55)
    {
      (*(void (**)(_QWORD *))(*v97 + 56))(v97);
      v58 = sub_1D3D823D4(v55, v57, (unint64_t *)(v2 + 368));
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      if (v58)
      {
        v26 = v97;
        goto LABEL_45;
      }
    }
    else if ((__p[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__p);
    }
    v64 = v101;
    *(_QWORD *)&v101 = 0;
    if (v64)
      goto LABEL_127;
    goto LABEL_130;
  }
LABEL_162:
  if (*(_BYTE *)(v2 + 288))
  {
    v83 = *(_QWORD *)(v2 + 352);
    if (v83)
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v83 + 24))(v83))
      {
        v84 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)__p = v2 + 88;
        __p[8] = 1;
        LOBYTE(v94[0]) = 0;
        v99 = 0;
        v85 = *(_QWORD *)(v84 + 24);
        if (!v85)
          sub_1D3D75A24();
        result = (unint64_t *)(*(uint64_t (**)(uint64_t, _BYTE *, unint64_t *))(*(_QWORD *)v85 + 48))(v85, __p, v94);
        goto LABEL_4;
      }
    }
  }
LABEL_167:
  v86 = *(_QWORD *)(a1 + 16);
  LOBYTE(v123) = 0;
  LOBYTE(v124[0]) = 0;
  v87 = *(unsigned __int8 *)(v2 + 464);
  if (*(_BYTE *)(v2 + 464))
  {
    sub_1D3DF4F6C((uint64_t)v94, v2 + 368);
  }
  else
  {
    sub_1D3DF4E68((uint64_t)__p, -1, 0);
    sub_1D3DF50BC(v94, (uint64_t *)__p);
  }
  v99 = 1;
  v88 = *(_QWORD *)(v86 + 24);
  if (!v88)
    sub_1D3D75A24();
  result = (unint64_t *)(*(uint64_t (**)(uint64_t, os_signpost_id_t **, unint64_t *))(*(_QWORD *)v88 + 48))(v88, &v123, v94);
  if (v99)
    result = sub_1D3DF4F24(v94);
  if (!v87)
  {
    v6 = (unint64_t *)__p;
    return sub_1D3DF4F24(v6);
  }
  return result;
}

void sub_1D3DAF0EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  uint64_t v61;

  sub_1D3D87C3C((_QWORD *)(v61 - 144));
  if (a50)
    sub_1D3DACE4C((uint64_t)&a16);
  sub_1D3D87C3C((_QWORD *)(v61 - 248));
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DAF240(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd12_GLOBAL__N_111ANMDContext7performENSt3__18functionIFvONS4_8optionalINS4_17reference_wrapperINS1_9ANMDModelEEEEEONS6_INS_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAF278()
{
  return &unk_1E95AEB50;
}

void sub_1D3DAF288()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAF29C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AFD28;
  return result;
}

void sub_1D3DAF2C0(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AFD28;
}

uint64_t sub_1D3DAF2D8(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
  {
    sub_1D3D96F10(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3DAF30C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_9inference4anmd12_GLOBAL__N_111ANMDContextEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAF344()
{
  return &unk_1E95AEB30;
}

void sub_1D3DAF354(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DAF378(uint64_t a1)
{
  return sub_1D3DAE1F8(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1D3DAF380(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc9inference4anmd12_GLOBAL__N_111ANMDContextEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1D3DAF3BC(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEEA0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DAF3F8(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEEA0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DAF444(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 472);
  *(_QWORD *)(a1 + 472) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 480))();
  if (*(_BYTE *)(a1 + 464))
    sub_1D3DF4F24((unint64_t *)(a1 + 368));
  if (*(_BYTE *)(a1 + 360))
    sub_1D3DACE4C(a1 + 88);
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEEA0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v3)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DAF4C4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 472);
  *(_QWORD *)(a1 + 472) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 480))();
  if (*(_BYTE *)(a1 + 464))
    sub_1D3DF4F24((unint64_t *)(a1 + 368));
  if (*(_BYTE *)(a1 + 360))
    sub_1D3DACE4C(a1 + 88);
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEEA0;
  *(_QWORD *)(a1 + 8) = 0;
  if (v3)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

unint64_t *sub_1D3DAF554@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  unint64_t *result;
  uint64_t v4;
  unint64_t v5[12];
  char v6;
  _QWORD v7[3];
  unint64_t *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  LOBYTE(v5[0]) = 0;
  v6 = 0;
  v7[0] = &off_1E95AD788;
  v7[1] = v5;
  v8 = v7;
  sub_1D3DADACC(a1, v7);
  result = v8;
  if (v8 == v7)
  {
    v4 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      goto LABEL_6;
    v4 = 5;
  }
  result = (unint64_t *)(*(uint64_t (**)(void))(*result + 8 * v4))();
LABEL_6:
  if (v6)
  {
    result = sub_1D3DF53CC(a2, (uint64_t)v5);
    if (v6)
      return sub_1D3DF4F24(v5);
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1D3DAF624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21)
    sub_1D3DF4F24((unint64_t *)&a9);
  _Unwind_Resume(exception_object);
}

void sub_1D3DAF678()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DAF68C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AD788;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DAF6C0(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AD788;
  a2[1] = v2;
  return result;
}

unint64_t *sub_1D3DAF6DC(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t *result;

  if (!a2[8])
    return sub_1D3D74C98(*(unint64_t **)(a1 + 8), a3);
  if (!*(_BYTE *)(*(_QWORD *)a2 + 200))
    return sub_1D3D74C98(*(unint64_t **)(a1 + 8), a3);
  v5 = *(_QWORD *)(*(_QWORD *)a2 + 264);
  if (!v5)
    return sub_1D3D74C98(*(unint64_t **)(a1 + 8), a3);
  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  if ((result & 1) == 0)
    return sub_1D3D74C98(*(unint64_t **)(a1 + 8), a3);
  return result;
}

uint64_t sub_1D3DAF73C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel19preflightForContextERNS_7ContextEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DAF774()
{
  return &unk_1E95ACFC8;
}

uint64_t sub_1D3DAF780(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AF9B0;
  *(_QWORD *)(a1 + 16) = 0;
  v3 = *(_QWORD *)(a2 + 16);
  if (v3)
  {
    v4 = (unsigned int *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    v6 = *(unsigned int **)(a1 + 16);
    if (v6)
      sub_1D3D6D13C(v6);
  }
  *(_QWORD *)(a1 + 16) = v3;
  return a1;
}

_QWORD *sub_1D3DAF7E0(_QWORD *a1)
{
  unsigned int *v2;

  *a1 = &off_1E95AF990;
  v2 = (unsigned int *)a1[2];
  if (v2)
    sub_1D3D6D13C(v2);
  a1[2] = 0;
  return a1;
}

void sub_1D3DAF824(_QWORD *a1)
{
  sub_1D3DAF7E0(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DAF848(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E95AF2A0;
  sub_1D3D7F520(*(_QWORD **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  sub_1D3DAF7E0((_QWORD *)(a1 + 48));
  sub_1D3D7F598((unsigned int **)(a1 + 40));
  sub_1D3D7F558((_QWORD *)(a1 + 16));
  return a1;
}

void sub_1D3DAF8A4(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E95AF2A0;
  sub_1D3D7F520(*(_QWORD **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  sub_1D3DAF7E0((_QWORD *)(a1 + 48));
  sub_1D3D7F598((unsigned int **)(a1 + 40));
  sub_1D3D7F558((_QWORD *)(a1 + 16));
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DAF910(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, __int128 *a5)
{
  unsigned int **v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int *v16;
  _BYTE *v17;
  __int128 v18;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = off_1E95AF2A0;
  sub_1D3DAF780(a1 + 16, a2);
  *(_QWORD *)(a1 + 40) = 0;
  v9 = (unsigned int **)(a1 + 40);
  v10 = *a3;
  if (*a3)
  {
    v11 = (unsigned int *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    if (*v9)
      sub_1D3D6D13C(*v9);
  }
  *(_QWORD *)(a1 + 48) = &off_1E95AF990;
  *(_QWORD *)(a1 + 40) = v10;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  v13 = *(_QWORD *)(a4 + 16);
  if (v13)
  {
    v14 = (unsigned int *)(v13 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v16 = *(unsigned int **)(a1 + 64);
    if (v16)
      sub_1D3D6D13C(v16);
  }
  *(_QWORD *)(a1 + 64) = v13;
  v17 = (_BYTE *)(a1 + 72);
  if (*((char *)a5 + 23) < 0)
  {
    sub_1D3D7FCC0(v17, *(void **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v18 = *a5;
    *(_QWORD *)(a1 + 88) = *((_QWORD *)a5 + 2);
    *(_OWORD *)v17 = v18;
  }
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 96) = a1 + 104;
  return a1;
}

void sub_1D3DAFA20(_Unwind_Exception *a1)
{
  _QWORD *v1;
  unsigned int **v2;
  _QWORD *v3;

  sub_1D3DAF7E0(v3);
  sub_1D3D7F598(v2);
  sub_1D3D7F558(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DAFA54(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  unsigned int **v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = off_1E95AF2A0;
  sub_1D3DAF780(a1 + 16, a2);
  *(_QWORD *)(a1 + 40) = 0;
  v7 = (unsigned int **)(a1 + 40);
  v8 = *a3;
  if (*a3)
  {
    v9 = (unsigned int *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    if (*v7)
      sub_1D3D6D13C(*v7);
  }
  *(_QWORD *)(a1 + 48) = &off_1E95AF990;
  *(_QWORD *)(a1 + 40) = v8;
  *(_DWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  sub_1D3D7F3AC(a1 + 96, a4);
  return a1;
}

void sub_1D3DAFB04(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1D3D7F558(v1);
  _Unwind_Resume(a1);
}

void sub_1D3DAFD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  sub_1D3D8C70C(&a9);
  _Unwind_Resume(a1);
}

double sub_1D3DAFD90()
{
  double result;

  result = 0.0;
  xmmword_1EFE31758 = 0u;
  *(_OWORD *)&qword_1EFE31768 = 0u;
  dword_1EFE31778 = 1065353216;
  qword_1EFE31780 = (uint64_t)&xmmword_1EFE31758;
  return result;
}

uint64_t sub_1D3DAFDB4(unint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  int8x8_t v10;
  uint8x8_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *i;
  unint64_t v15;
  uint64_t v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  int8x8_t prime;
  void *v22;
  void *v23;
  uint64_t v24;
  _QWORD **v25;
  unint64_t v26;
  uint8x8_t v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  _QWORD *j;
  unint64_t v32;
  unint64_t v33;
  uint8x8_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  objc_class *v38;
  void *v40;

  v3 = a2 + 3;
  if (!a2[3])
    goto LABEL_83;
  os_unfair_lock_lock_with_options();
  if (qword_1EFE31788 != -1)
    dispatch_once(&qword_1EFE31788, &unk_1E95B0490);
  v5 = qword_1EFE31780;
  v6 = operator new(0x38uLL);
  v7 = v6;
  *v6 = 0;
  v6[1] = 0;
  v6[2] = a1;
  v8 = (_QWORD *)*v3;
  if (*v3)
  {
    if (v8 == a2)
    {
      v6[6] = v6 + 3;
      (*(void (**)(_QWORD *))(*a2 + 24))(a2);
      v9 = v7[2];
      goto LABEL_11;
    }
    v6[6] = v8;
  }
  else
  {
    v3 = v6 + 6;
  }
  *v3 = 0;
  v9 = a1;
LABEL_11:
  v7[1] = v9;
  v10 = *(int8x8_t *)((char *)&xmmword_1EFE31758 + 8);
  if (*((_QWORD *)&xmmword_1EFE31758 + 1))
  {
    v11 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EFE31758 + 8));
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v12 = v9;
      if (*((_QWORD *)&xmmword_1EFE31758 + 1) <= v9)
        v12 = v9 % *((_QWORD *)&xmmword_1EFE31758 + 1);
    }
    else
    {
      v12 = (*((_QWORD *)&xmmword_1EFE31758 + 1) - 1) & v9;
    }
    v13 = *(_QWORD **)(xmmword_1EFE31758 + 8 * v12);
    if (v13)
    {
      for (i = (_QWORD *)*v13; i; i = (_QWORD *)*i)
      {
        v15 = i[1];
        if (v15 == v9)
        {
          if (i[2] == v7[2])
          {
            sub_1D3DB029C(1, v7);
            goto LABEL_82;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v15 >= *((_QWORD *)&xmmword_1EFE31758 + 1))
              v15 %= *((_QWORD *)&xmmword_1EFE31758 + 1);
          }
          else
          {
            v15 &= *((_QWORD *)&xmmword_1EFE31758 + 1) - 1;
          }
          if (v15 != v12)
            break;
        }
      }
    }
  }
  v16 = v5 + 16;
  v17 = (float)(unint64_t)(qword_1EFE31770 + 1);
  if (!*((_QWORD *)&xmmword_1EFE31758 + 1)
    || (float)(*(float *)&dword_1EFE31778 * (float)*((unint64_t *)&xmmword_1EFE31758 + 1)) < v17)
  {
    v18 = 1;
    if (*((_QWORD *)&xmmword_1EFE31758 + 1) >= 3uLL)
      v18 = (*((_QWORD *)&xmmword_1EFE31758 + 1) & (*((_QWORD *)&xmmword_1EFE31758 + 1) - 1)) != 0;
    v19 = v18 | (2 * *((_QWORD *)&xmmword_1EFE31758 + 1));
    v20 = vcvtps_u32_f32(v17 / *(float *)&dword_1EFE31778);
    if (v19 <= v20)
      prime = (int8x8_t)v20;
    else
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v10 = *(int8x8_t *)((char *)&xmmword_1EFE31758 + 8);
    }
    if (*(_QWORD *)&prime > *(_QWORD *)&v10)
      goto LABEL_96;
    if (*(_QWORD *)&prime >= *(_QWORD *)&v10)
      goto LABEL_68;
    v28 = vcvtps_u32_f32((float)(unint64_t)qword_1EFE31770 / *(float *)&dword_1EFE31778);
    if (*(_QWORD *)&v10 < 3uLL || (v29 = (uint8x8_t)vcnt_s8(v10), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
    {
      v28 = std::__next_prime(v28);
    }
    else
    {
      v30 = 1 << -(char)__clz(v28 - 1);
      if (v28 >= 2)
        v28 = v30;
    }
    if (*(_QWORD *)&prime <= v28)
      prime = (int8x8_t)v28;
    if (*(_QWORD *)&prime >= *(_QWORD *)&v10)
    {
      v10 = *(int8x8_t *)((char *)&xmmword_1EFE31758 + 8);
      goto LABEL_68;
    }
    if (prime)
    {
LABEL_96:
      if (*(_QWORD *)&prime >> 61)
        sub_1D3D6D50C();
      v22 = operator new(8 * *(_QWORD *)&prime);
      v23 = (void *)xmmword_1EFE31758;
      *(_QWORD *)&xmmword_1EFE31758 = v22;
      if (v23)
        operator delete(v23);
      v24 = 0;
      *((int8x8_t *)&xmmword_1EFE31758 + 1) = prime;
      do
        *(_QWORD *)(xmmword_1EFE31758 + 8 * v24++) = 0;
      while (*(_QWORD *)&prime != v24);
      v25 = (_QWORD **)qword_1EFE31768;
      if (qword_1EFE31768)
      {
        v26 = *(_QWORD *)(qword_1EFE31768 + 8);
        v27 = (uint8x8_t)vcnt_s8(prime);
        v27.i16[0] = vaddlv_u8(v27);
        if (v27.u32[0] > 1uLL)
        {
          if (v26 >= *(_QWORD *)&prime)
            v26 %= *(_QWORD *)&prime;
        }
        else
        {
          v26 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(xmmword_1EFE31758 + 8 * v26) = v16;
        for (j = *v25; j; v26 = v32)
        {
          v32 = j[1];
          if (v27.u32[0] > 1uLL)
          {
            if (v32 >= *(_QWORD *)&prime)
              v32 %= *(_QWORD *)&prime;
          }
          else
          {
            v32 &= *(_QWORD *)&prime - 1;
          }
          if (v32 != v26)
          {
            if (!*(_QWORD *)(xmmword_1EFE31758 + 8 * v32))
            {
              *(_QWORD *)(xmmword_1EFE31758 + 8 * v32) = v25;
              goto LABEL_64;
            }
            *v25 = (_QWORD *)*j;
            *j = **(_QWORD **)(xmmword_1EFE31758 + 8 * v32);
            **(_QWORD **)(xmmword_1EFE31758 + 8 * v32) = j;
            j = v25;
          }
          v32 = v26;
LABEL_64:
          v25 = (_QWORD **)j;
          j = (_QWORD *)*j;
        }
      }
      v10 = prime;
    }
    else
    {
      v40 = (void *)xmmword_1EFE31758;
      *(_QWORD *)&xmmword_1EFE31758 = 0;
      if (v40)
        operator delete(v40);
      v10 = 0;
      *((_QWORD *)&xmmword_1EFE31758 + 1) = 0;
    }
  }
LABEL_68:
  v33 = v7[1];
  v34 = (uint8x8_t)vcnt_s8(v10);
  v34.i16[0] = vaddlv_u8(v34);
  if (v34.u32[0] > 1uLL)
  {
    if (v33 >= *(_QWORD *)&v10)
      v33 %= *(_QWORD *)&v10;
  }
  else
  {
    v33 &= *(_QWORD *)&v10 - 1;
  }
  v35 = xmmword_1EFE31758;
  v36 = *(_QWORD **)(xmmword_1EFE31758 + 8 * v33);
  if (v36)
  {
    *v7 = *v36;
  }
  else
  {
    *v7 = qword_1EFE31768;
    qword_1EFE31768 = (uint64_t)v7;
    *(_QWORD *)(v35 + 8 * v33) = v16;
    if (!*v7)
      goto LABEL_81;
    v37 = *(_QWORD *)(*v7 + 8);
    if (v34.u32[0] > 1uLL)
    {
      if (v37 >= *(_QWORD *)&v10)
        v37 %= *(_QWORD *)&v10;
    }
    else
    {
      v37 &= *(_QWORD *)&v10 - 1;
    }
    v36 = (_QWORD *)(xmmword_1EFE31758 + 8 * v37);
  }
  *v36 = v7;
LABEL_81:
  ++qword_1EFE31770;
LABEL_82:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EFE31750);
LABEL_83:
  v38 = (objc_class *)objc_opt_class();
  class_getName(v38);
  return _CFRuntimeBridgeClasses();
}

void sub_1D3DB0284(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1D3DB029C(1, v1);
  _Unwind_Resume(a1);
}

void sub_1D3DB029C(char a1, _QWORD *__p)
{
  _QWORD *v3;
  uint64_t v4;

  if (a1)
  {
    v3 = (_QWORD *)__p[6];
    if (v3 == __p + 3)
    {
      v4 = 4;
      v3 = __p + 3;
      goto LABEL_6;
    }
    if (v3)
    {
      v4 = 5;
LABEL_6:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
  }
  operator delete(__p);
}

uint64_t sub_1D3DB02F4(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF3B0;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  return a1;
}

void sub_1D3DB0324(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF3B0;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  JUMPOUT(0x1D8254C54);
}

BOOL sub_1D3DB0364(uint64_t a1, int a2, int a3, int a4, int a5)
{
  _QWORD *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BOOL8 result;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;

  v6 = *(_QWORD **)(a1 + 16);
  if (a3 <= a2)
    v7 = a2;
  else
    v7 = a3;
  v8 = v7;
  if (a5)
  {
    v9 = a2;
    v10 = a4;
    v11 = sub_1D3D6D4A0(*(_QWORD **)(a1 + 16), a2, a4) ^ 1;
    while (1)
    {
      result = v8 != v9;
      if (v8 == v9)
        break;
      v13 = sub_1D3D6D4A0(v6, ++v9, v10);
      v14 = *(unsigned __int8 *)(a1 + 32);
      if (v14 == 2)
        v15 = 0;
      else
        v15 = v11;
      if (v14 == 1)
        v16 = 1;
      else
        v16 = v15;
      if (v13 == v16)
        return 1;
    }
  }
  else
  {
    v17 = a4;
    v18 = a2;
    v19 = sub_1D3D6D4A0(*(_QWORD **)(a1 + 16), a4, a2) ^ 1;
    while (1)
    {
      result = v8 != v18;
      if (v8 == v18)
        break;
      v20 = sub_1D3D6D4A0(v6, v17, ++v18);
      v21 = *(unsigned __int8 *)(a1 + 32);
      if (v21 == 2)
        v22 = 0;
      else
        v22 = v19;
      if (v21 == 1)
        v23 = 1;
      else
        v23 = v22;
      if (v20 == v23)
        return 1;
    }
  }
  return result;
}

uint64_t sub_1D3DB045C(uint64_t *a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  float v9;
  int v10;
  float v12;
  float v13;
  _QWORD *v14;
  float v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t result;
  unsigned int *v23;
  unsigned int v24;

  v9 = sqrtf((float)((float)(a4 - a6) * (float)(a4 - a6)) + (float)((float)(a3 - a5) * (float)(a3 - a5))) + 0.5;
  v10 = (int)v9;
  if ((int)v9 < 2)
  {
LABEL_10:
    result = 0;
  }
  else
  {
    v12 = (float)(int)v9;
    v13 = (float)(a5 - a3) / v12;
    v14 = *(_QWORD **)(a2 + 16);
    v15 = (float)(a6 - a4) / v12;
    v16 = sub_1D3D6D4A0(v14, (int)(float)(a3 + 0.5), (int)(float)(a4 + 0.5)) ^ 1;
    v17 = *(unsigned __int8 *)(a2 + 32);
    if (v17 == 2)
      v16 = 0;
    if (v17 == 1)
      v18 = 1;
    else
      v18 = v16;
    v19 = 1;
    while (1)
    {
      v20 = (int)(float)((float)(a3 + (float)((float)v19 * v13)) + 0.5);
      v21 = (int)(float)((float)(a4 + (float)((float)v19 * v15)) + 0.5);
      if (sub_1D3D6D4A0(v14, v20, v21) == v18)
        break;
      if (v10 == ++v19)
        goto LABEL_10;
    }
    result = operator new();
    *(_DWORD *)(result + 8) = 0;
    v23 = (unsigned int *)(result + 8);
    *(_QWORD *)result = &off_1E95AF250;
    *(float *)(result + 12) = (float)v20;
    *(float *)(result + 16) = (float)v21;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  *a1 = result;
  return result;
}

uint64_t sub_1D3DB05C8(uint64_t *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  unsigned int *v24;
  unsigned int v25;
  uint64_t v26;
  float v27;
  float v28;
  unsigned int *v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  uint64_t result;
  float v35;
  float v36;
  unsigned int *v37;
  unsigned int v38;
  float v39;
  float v40;
  float v41;

  v10 = (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2);
  v11 = (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
  v12 = (*(float (**)(_QWORD))(*(_QWORD *)*a3 + 16))(*a3);
  v13 = (*(float (**)(_QWORD))(*(_QWORD *)*a3 + 24))(*a3);
  v14 = (*(float (**)(_QWORD))(*(_QWORD *)*a4 + 16))(*a4);
  v15 = (*(float (**)(_QWORD))(*(_QWORD *)*a4 + 24))(*a4);
  v16 = (*(float (**)(_QWORD))(*(_QWORD *)*a5 + 16))(*a5);
  v39 = (*(float (**)(_QWORD))(*(_QWORD *)*a5 + 24))(*a5);
  v40 = v16;
  v17 = (float)((float)((float)(v10 + v12) + v14) + v16) * 0.25;
  v18 = (float)((float)((float)(v11 + v13) + v15) + v39) * 0.25;
  v19 = v14 + 1.0;
  if (v14 <= v17)
    v19 = v14;
  v41 = v19;
  if (v15 <= v18)
    v20 = v15;
  else
    v20 = v15 + 1.0;
  v21 = operator new();
  v22 = v11 + 1.0;
  if (v11 <= v18)
    v22 = v11;
  v23 = v10 + 1.0;
  *(_DWORD *)(v21 + 8) = 0;
  v24 = (unsigned int *)(v21 + 8);
  *(_QWORD *)v21 = &off_1E95AF250;
  if (v10 <= v17)
    v23 = v10;
  *(float *)(v21 + 12) = v23;
  *(float *)(v21 + 16) = v22;
  do
    v25 = __ldxr(v24);
  while (__stxr(v25 + 1, v24));
  *a1 = v21;
  v26 = operator new();
  v27 = v13 + 1.0;
  if (v13 <= v18)
    v27 = v13;
  v28 = v12 + 1.0;
  *(_DWORD *)(v26 + 8) = 0;
  v29 = (unsigned int *)(v26 + 8);
  *(_QWORD *)v26 = &off_1E95AF250;
  if (v12 <= v17)
    v28 = v12;
  *(float *)(v26 + 12) = v28;
  *(float *)(v26 + 16) = v27;
  do
    v30 = __ldxr(v29);
  while (__stxr(v30 + 1, v29));
  a1[1] = v26;
  v31 = operator new();
  *(_DWORD *)(v31 + 8) = 0;
  v32 = (unsigned int *)(v31 + 8);
  *(_QWORD *)v31 = &off_1E95AF250;
  *(float *)(v31 + 12) = v41;
  *(float *)(v31 + 16) = v20;
  do
    v33 = __ldxr(v32);
  while (__stxr(v33 + 1, v32));
  a1[2] = v31;
  result = operator new();
  v35 = v39 + 1.0;
  if (v39 <= v18)
    v35 = v39;
  v36 = v40 + 1.0;
  *(_DWORD *)(result + 8) = 0;
  v37 = (unsigned int *)(result + 8);
  *(_QWORD *)result = &off_1E95AF250;
  if (v40 <= v17)
    v36 = v40;
  *(float *)(result + 12) = v36;
  *(float *)(result + 16) = v35;
  do
    v38 = __ldxr(v37);
  while (__stxr(v38 + 1, v37));
  a1[3] = result;
  return result;
}

void sub_1D3DB087C(_Unwind_Exception *a1)
{
  unsigned int **v1;
  unsigned int **v2;

  do
    sub_1D3D6D834(--v2);
  while (v2 != v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB089C(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int *v8;

  for (i = 0; i != 4; ++i)
  {
    v5 = *(_QWORD *)(a2 + 8 * i);
    if (v5)
    {
      v6 = (unsigned int *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    v8 = *(unsigned int **)(a1 + 8 * i);
    if (v8)
      sub_1D3D6D13C(v8);
    *(_QWORD *)(a1 + 8 * i) = v5;
  }
  return a1;
}

_QWORD *sub_1D3DB0904(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1D3D6D864(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1D3DB096C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_1D3D6D79C(&a9);
  _Unwind_Resume(a1);
}

void sub_1D3DB0980(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;

  sub_1D3DB09EC(&v6, a1);
  v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  *a2 = 0;
}

void sub_1D3DB09EC(_QWORD *a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  _QWORD *v5;
  NSObject *v6;
  _QWORD *v7;
  _QWORD *v8;
  NSObject *v9;
  dispatch_queue_t v10;
  uint64_t (*v11)(_QWORD);
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  void *v20;
  __int128 v21;
  uint64_t v22[3];
  uint64_t v23[5];
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD *v26;
  _QWORD v27[5];

  v27[4] = *MEMORY[0x1E0C80C00];
  v4 = (os_unfair_lock_s *)(a2 + 1);
  os_unfair_lock_lock_with_options();
  v5 = sub_1D3D967F4(a2 + 3, (unint64_t)&unk_1D3E68DB0);
  if (!v5)
  {
    v6 = a2[2];
    v20 = &unk_1D3E68DB0;
    *(_QWORD *)&v21 = "DecoderAppC3DContext";
    *((_QWORD *)&v21 + 1) = 20;
    v7 = (_QWORD *)operator new();
    v8 = (_QWORD *)operator new();
    v9 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v10 = dispatch_queue_create_with_target_V2("mrc::Context::ConcreteBase<mrc::(anonymous namespace)::DecoderAppC3DContext>::ConcreteBase(const Options &, dispatch_queue_t _Nonnull) [_Derived = mrc::(anonymous namespace)::DecoderAppC3DContext]", v9, v6);
    v11 = MEMORY[0x1E0C82E98];
    *v8 = &off_1E95AEE20;
    v8[1] = v10;
    v8[2] = v11;
    v8[3] = 0;
    *v7 = v8;
    v12 = (_QWORD *)operator new();
    *v12 = &off_1E95B03C0;
    v12[1] = 0;
    v12[2] = 0;
    v12[3] = v8;
    v7[1] = v12;
    v24[0] = &off_1E95AFC78;
    v25 = v24;
    v26 = v7;
    sub_1D3D96968((uint64_t)v27, (uint64_t)v24);
    sub_1D3E23E40((uint64_t)v22, (uint64_t)&unk_1D3E68DB0, &v21, (uint64_t *)&v26);
    sub_1D3D969CC((uint64_t *)&v26);
    v13 = v25;
    if (v25 == v24)
    {
      v14 = 4;
      v13 = v24;
    }
    else
    {
      if (!v25)
      {
LABEL_7:
        v5 = sub_1D3D96A58(a2 + 3, &v20, v22);
        sub_1D3D969CC(v23);
        sub_1D3E23B04(a2);
        goto LABEL_8;
      }
      v14 = 5;
    }
    (*(void (**)(void))(*v13 + 8 * v14))();
    goto LABEL_7;
  }
LABEL_8:
  if ((_UNKNOWN *)v5[3] != &unk_1D3E68DB0)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_15:
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  v15 = (uint64_t *)v5[6];
  if (!v15)
    goto LABEL_15;
  v17 = *v15;
  v16 = v15[1];
  *a1 = v17;
  a1[1] = v16;
  if (v16)
  {
    v18 = (unint64_t *)(v16 + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  os_unfair_lock_unlock(v4);
}

void sub_1D3DB0C40(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;

  sub_1D3D969CC((uint64_t *)(v2 + 24));
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB0CD4(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    sub_1D3DB0EB0((unint64_t **)(result + 24), 0);
    v2 = *(_QWORD *)(v1 + 8);
    *(_QWORD *)v1 = &off_1E95AEE60;
    *(_QWORD *)(v1 + 8) = 0;
    if (v2)
      (*(void (**)(void))(v1 + 16))();
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

void sub_1D3DB0D38()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB0D4C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AFC78;
  return result;
}

void sub_1D3DB0D70(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AFC78;
}

void sub_1D3DB0D88(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (*(_QWORD *)a2)
  {
    v2 = *(std::__shared_weak_count **)(*(_QWORD *)a2 + 8);
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        v4 = __ldaxr(p_shared_owners);
      while (__stlxr(v4 - 1, p_shared_owners));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    JUMPOUT(0x1D8254C54);
  }
}

uint64_t sub_1D3DB0E00(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_12_GLOBAL__N_120DecoderAppC3DContextEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB0E38()
{
  return &unk_1E95AEB10;
}

void sub_1D3DB0E48(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DB0E6C(uint64_t a1)
{
  return sub_1D3DB0CD4(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1D3DB0E74(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc12_GLOBAL__N_120DecoderAppC3DContextEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

unint64_t *sub_1D3DB0EB0(unint64_t **a1, unint64_t *a2)
{
  unint64_t *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1D3DB0F74(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3DB0EEC(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE60;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DB0F28(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE60;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

unint64_t *sub_1D3DB0F74(unint64_t *a1)
{
  unint64_t v2;
  NSObject *v3;
  _BYTE v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  if (*a1)
  {
    if (qword_1EDB89360 != -1)
      dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
    v3 = qword_1EDB89398;
    if (os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v5 = 134349056;
      *(_QWORD *)&v5[4] = v2;
      _os_log_debug_impl(&dword_1D3D6B000, v3, OS_LOG_TYPE_DEBUG, "AppC3D session will be released: %{public}p", v5, 0xCu);
    }
    AppC3DRelease();
  }
  if (*((_BYTE *)a1 + 128))
    sub_1D3DF4F24(a1 + 4);
  *(_QWORD *)v5 = a1 + 1;
  sub_1D3D74BF0((void ***)v5);
  return a1;
}

void sub_1D3DB107C(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_1D3D6D5A8(a1);
}

uint64_t sub_1D3DB1088(uint64_t a1)
{
  uint64_t v2;

  sub_1D3DB0EB0((unint64_t **)(a1 + 24), 0);
  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE60;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DB10D0(uint64_t a1)
{
  uint64_t v2;

  sub_1D3DB0EB0((unint64_t **)(a1 + 24), 0);
  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE60;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DB1128(uint64_t a1, __int128 *a2)
{
  BOOL v4;
  const void *v5;
  CFTypeID v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  CFTypeID v13;
  uint8_t buf[4];
  char v15;
  _BYTE v16[24];
  _BYTE *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)buf = 4;
  v15 = 1;
  if ((sub_1D3DDC428(*(unint64_t **)(a1 + 8), CFSTR("AppClipCode"), (uint64_t)buf) & 1) == 0)
  {
LABEL_19:
    **((_WORD **)a2 + 8) = 256;
    return;
  }
  if ((os_variant_has_factory_content() & 1) != 0
    || (MEMORY[0x1E0CF8790] ? (v4 = MEMORY[0x1E0CF8760] == 0) : (v4 = 1), v4))
  {
    if (qword_1EDB89360 != -1)
      dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
    v12 = qword_1EDB89398;
    if (os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_INFO, "AppC3D is not available.", buf, 2u);
    }
    goto LABEL_19;
  }
  dispatch_group_enter(*((dispatch_group_t *)a2 + 9));
  v5 = (const void *)atomic_load((unint64_t *)a1);
  if (v5)
  {
    v6 = CFGetTypeID(v5);
    if (qword_1EDB893E0 != -1)
    {
      v13 = v6;
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
      v6 = v13;
    }
    if (v6 != qword_1EDB893D8)
      _os_assumes_log();
  }
  v7 = (char *)operator new(0x60uLL);
  v8 = *a2;
  *(_OWORD *)(v7 + 24) = a2[1];
  v9 = a2[3];
  *(_OWORD *)(v7 + 40) = a2[2];
  *(_OWORD *)(v7 + 56) = v9;
  *(_OWORD *)(v7 + 72) = a2[4];
  *(_QWORD *)v7 = &off_1E95B0040;
  *(_OWORD *)(v7 + 8) = v8;
  *((_QWORD *)v7 + 11) = a1;
  v17 = v7;
  sub_1D3E23840((uint64_t)v5 + 16, 1, (uint64_t)v16);
  v10 = v17;
  if (v17 == v16)
  {
    v11 = 4;
    v10 = v16;
  }
  else
  {
    if (!v17)
      return;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
}

void sub_1D3DB133C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3DB1378()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3DB138C(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x60uLL);
  *(_QWORD *)v2 = &off_1E95B0040;
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  *((_QWORD *)v2 + 11) = *(_QWORD *)(a1 + 88);
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1D3DB13EC(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __n128 result;
  __int128 v4;
  __int128 v5;

  *(_QWORD *)a2 = &off_1E95B0040;
  v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  result = *(__n128 *)(a1 + 40);
  v4 = *(_OWORD *)(a1 + 56);
  v5 = *(_OWORD *)(a1 + 72);
  *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v5;
  *(_OWORD *)(a2 + 56) = v4;
  *(__n128 *)(a2 + 40) = result;
  return result;
}

void sub_1D3DB1434(uint64_t a1)
{
  uint64_t *v2;
  CFTypeID v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  __int16 v7;
  _QWORD *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  __int128 v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  _QWORD context[2];
  unsigned __int8 v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)atomic_load(*(unint64_t **)(a1 + 88));
  if (v2)
  {
    v3 = CFGetTypeID(v2);
    if (qword_1EDB893E0 != -1)
      dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
    if (v3 != qword_1EDB893D8)
      _os_assumes_log();
  }
  sub_1D3DB09EC(&v14, v2 + 2);
  v4 = v14;
  v5 = *(_QWORD *)(a1 + 48);
  v13 = *(_OWORD *)(a1 + 8);
  v6 = operator new(0x38uLL);
  *v6 = &off_1E95AD100;
  v6[1] = v4;
  v6[2] = v5;
  v6[3] = a1 + 56;
  *((_OWORD *)v6 + 2) = v13;
  v6[6] = a1 + 32;
  v19 = v6;
  context[0] = v18;
  context[1] = &v17;
  dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v4 + 8), context, (dispatch_function_t)sub_1D3DB1664);
  v7 = v17;
  v8 = v19;
  if (v19 == v18)
  {
    v9 = 4;
    v8 = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_11;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_11:
  **(_WORD **)(a1 + 72) = v7 | 0x100;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 80));
  v10 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_1D3DB15D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  unint64_t *p_shared_owners;
  unint64_t v14;

  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DB1620(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder18decodeUsingAppC3D_ERKNS0_4PassEE3$_0"))
    return a1 + 8;
  else
    return 0;
}

void *sub_1D3DB1658()
{
  return &unk_1E95AEBC0;
}

uint64_t sub_1D3DB1664(_QWORD *a1)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t result;

  v2 = *(_QWORD *)(*a1 + 24);
  if (!v2)
    sub_1D3D75A24();
  v3 = (_BYTE *)a1[1];
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  *v3 = result;
  return result;
}

void sub_1D3DB16A8()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3DB16BC(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x38uLL);
  *(_QWORD *)v2 = &off_1E95AD100;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 sub_1D3DB1704(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E95AD100;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1D3DB1734(double *a1)
{
  uint64_t v2;
  unint64_t **v3;
  unint64_t *v4;
  unint64_t *v5;
  CGFloat v6;
  unint64_t *v7;
  CGFloat *p_b;
  int8x16_t *v9;
  uint64_t v10;
  double *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  const void *v23;
  CGFloat tx;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  uint64_t *v28;
  unint64_t **v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  NSObject *v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t *v41;
  int v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  double *v48;
  double *v49;
  CGFloat v50;
  CGFloat Height;
  unint64_t *v52;
  unint64_t *v53;
  uint64_t v54;
  unint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  CGFloat v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t *v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  _BOOL4 v68;
  const char *v69;
  unint64_t v70;
  unint64_t *v71;
  unint64_t *v72;
  unint64_t *v73;
  CGFloat v74;
  unint64_t v75;
  int v76;
  _BOOL4 v77;
  const char *v78;
  unint64_t *v79;
  unint64_t *v80;
  unint64_t *v81;
  unint64_t *v82;
  unint64_t v83;
  unint64_t v84;
  const void *v85;
  unint64_t v86;
  const void *v87;
  unint64_t *i;
  unint64_t *v89;
  _OWORD *v90;
  uint64_t v91;
  const char *v93;
  unint64_t *v94;
  unint64_t v95;
  const void *v96;
  const char *v97;
  const __CFString *v98;
  CMTime time;
  CMTime v100;
  unsigned __int8 v101;
  unint64_t v102;
  CGAffineTransform v103[2];
  char v104;
  double Width;
  double v106;
  float64x2_t v107;
  float64x2_t v108;
  float64x2_t v109;
  double v110;
  int8x16_t v111;
  int8x16_t v112;
  int32x2_t v113;
  float v114;
  unsigned __int8 v115;
  _QWORD v116[3];
  _QWORD *v117;
  _QWORD v118[3];
  _QWORD *v119;
  __int128 buf;
  unint64_t **v121;
  char *v122;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)a1 + 1);
  v5 = *(unint64_t **)(v2 + 24);
  v3 = (unint64_t **)(v2 + 24);
  v4 = v5;
  if (v5)
    goto LABEL_44;
  v7 = (unint64_t *)*((_QWORD *)a1 + 2);
  v6 = a1[3];
  Width = COERCE_DOUBLE(&off_1E95AD1B0);
  *(_QWORD *)&v107.f64[1] = &Width;
  v111.i64[0] = (uint64_t)&off_1E95AD158;
  v112.i64[1] = (uint64_t)&v111;
  p_b = &v103[0].b;
  *(_QWORD *)&v103[0].tx = &v103[0].b;
  v103[0].a = v6;
  *(_QWORD *)&v103[0].b = &off_1E95AD158;
  if (!*(_BYTE *)(*(_QWORD *)&v6 + 8)
    || (*(_QWORD *)&buf = **(_QWORD **)&v6,
        sub_1D3DB27E4((uint64_t)a1, (os_signpost_id_t *)&buf),
        v9 = (int8x16_t *)v112.i64[1],
        (int8x16_t *)v112.i64[1] == &v111))
  {
    v10 = 4;
    v9 = &v111;
  }
  else
  {
    if (!v112.i64[1])
      goto LABEL_8;
    v10 = 5;
  }
  (*(void (**)(void))(v9->i64[0] + 8 * v10))();
LABEL_8:
  v11 = *(double **)&v107.f64[1];
  if (*(double **)&v107.f64[1] == &Width)
  {
    v12 = 4;
    v11 = &Width;
    goto LABEL_12;
  }
  if (*(_QWORD *)&v107.f64[1])
  {
    v12 = 5;
LABEL_12:
    (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
  }
  v118[0] = 0;
  v116[0] = 0;
  v100.value = 0;
  AppC3DConfigCreate();
  v13 = v118[0];
  if (v118[0] || !v116[0])
  {
    if (qword_1EDB89360 != -1)
      dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
    v17 = qword_1EDB89398;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    LODWORD(buf) = 138543362;
    *(_QWORD *)((char *)&buf + 4) = v13;
    v97 = "AppC3DConfigCreate failed, and returned %{public}@";
LABEL_189:
    _os_log_error_impl(&dword_1D3D6B000, v17, OS_LOG_TYPE_ERROR, v97, (uint8_t *)&buf, 0xCu);
    goto LABEL_28;
  }
  AppC3DConfigSetTrackingConfig();
  v14 = v118[0];
  if (v118[0])
  {
    if (qword_1EDB89360 != -1)
      dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
    v17 = qword_1EDB89398;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    LODWORD(buf) = 138543362;
    *(_QWORD *)((char *)&buf + 4) = v14;
    v97 = "AppC3DConfigSetTrackingConfig returned %{public}@";
    goto LABEL_189;
  }
  AppC3DConfigSetTrackingMode();
  v15 = v118[0];
  if (v118[0])
  {
    if (qword_1EDB89360 != -1)
      dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
    v17 = qword_1EDB89398;
    if (!os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    LODWORD(buf) = 138543362;
    *(_QWORD *)((char *)&buf + 4) = v15;
    v97 = "AppC3DConfigSetTrackingMode returned %{public}@";
    goto LABEL_189;
  }
  if (qword_1EDB89FB8[0] != -1)
    dispatch_once_f(qword_1EDB89FB8, 0, (dispatch_function_t)sub_1D3E0ECD4);
  v16 = byte_1EDB89F50;
  if (qword_1EDB89360 != -1)
    dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
  v17 = qword_1EDB89398;
  v18 = os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_DEBUG);
  if (v16)
  {
    if (v18)
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v17, OS_LOG_TYPE_DEBUG, "Device has ANE, will not tempt with fallback device.", (uint8_t *)&buf, 2u);
    }
  }
  else
  {
    if (v18)
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_1D3D6B000, v17, OS_LOG_TYPE_DEBUG, "Device does not have ANE, will set fallback device to GPU.", (uint8_t *)&buf, 2u);
    }
    AppC3DConfigSetANEFallbackDevice();
    v19 = v118[0];
    if (v118[0])
    {
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        goto LABEL_28;
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v19;
      v97 = "AppC3DConfigSetANEFallbackDevice returned %{public}@";
      goto LABEL_189;
    }
  }
  AppC3DCreate();
  v20 = v118[0];
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 138543362;
    *(_QWORD *)((char *)&buf + 4) = v20;
    v97 = "AppC3DCreate failed, and returned %{public}@";
    goto LABEL_189;
  }
LABEL_28:
  if (v116[0])
    AppC3DConfigRelease();
  if (v118[0])
  {
    *(_QWORD *)&buf = -3001;
    time.value = (CMTimeValue)CFSTR("AppC3D error.");
    sub_1D3D73E0C(v7, (uint64_t *)&buf, (CFTypeRef *)&time);
    v21 = v7 + 8;
    v22 = v118[0];
    do
      v23 = (const void *)__ldaxr(v21);
    while (__stlxr(v22, v21));
    if (v23)
      CFRelease(v23);
  }
  tx = v103[0].tx;
  if (*(_BYTE *)(*(_QWORD *)&v103[0].a + 8))
  {
    if (!*(_QWORD *)&v103[0].tx)
      goto LABEL_43;
    *(_QWORD *)&buf = **(_QWORD **)&v103[0].a;
    (*(void (**)(void))(**(_QWORD **)&v103[0].tx + 48))();
    tx = v103[0].tx;
  }
  if (*(CGAffineTransform **)&tx == (CGAffineTransform *)&v103[0].b)
  {
    v25 = 4;
  }
  else
  {
    if (tx == 0.0)
      goto LABEL_43;
    v25 = 5;
    p_b = *(CGFloat **)&tx;
  }
  (*(void (**)(CGFloat *))(*(_QWORD *)p_b + 8 * v25))(p_b);
LABEL_43:
  sub_1D3DB0EB0(v3, 0);
  v4 = *v3;
  if (!*v3)
    return 0;
LABEL_44:
  v27 = (unint64_t *)*((_QWORD *)a1 + 2);
  v26 = *((_QWORD *)a1 + 3);
  v28 = (uint64_t *)*((_QWORD *)a1 + 4);
  v29 = (unint64_t **)*((_QWORD *)a1 + 5);
  v118[0] = &off_1E95AD260;
  v118[1] = v29;
  v119 = v118;
  *(_QWORD *)&buf = v26;
  v116[0] = &off_1E95AD208;
  v116[1] = v29;
  v30 = v116;
  v117 = v116;
  v31 = (_QWORD *)&buf + 1;
  *((_QWORD *)&buf + 1) = &off_1E95AD208;
  v121 = v29;
  v122 = (char *)&buf + 8;
  if (*(_BYTE *)(v26 + 8))
  {
    v103[0].a = *(CGFloat *)v26;
    sub_1D3DB32A4((uint64_t)v118, (os_signpost_id_t *)v103);
    v30 = v117;
    if (v117 == v116)
    {
      v32 = 4;
      v30 = v116;
    }
    else
    {
      if (!v117)
        goto LABEL_51;
      v32 = 5;
    }
  }
  else
  {
    v32 = 4;
  }
  (*(void (**)(void))(*v30 + 8 * v32))();
LABEL_51:
  v33 = v119;
  if (v119 == v118)
  {
    v34 = 4;
    v33 = v118;
  }
  else
  {
    if (!v119)
      goto LABEL_56;
    v34 = 5;
  }
  (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_56:
  v102 = 0;
  sub_1D3DE772C((const __CFDictionary *)&v100, (uint64_t)v29);
  sub_1D3DE77DC((const __CFData *)&v111, (uint64_t)v29);
  if (qword_1EDB89360 != -1)
    dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
  v35 = qword_1EDB89398;
  if (!os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_DEBUG))
  {
    v36 = v101;
    goto LABEL_60;
  }
  Width = COERCE_DOUBLE(sub_1D3DE7A7C((uint64_t)v29));
  v67 = atomic_load((unint64_t *)&Width);
  LODWORD(v103[0].a) = 138543362;
  *(_QWORD *)((char *)&v103[0].a + 4) = v67;
  _os_log_debug_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_DEBUG, "start decoding sample: %{public}@", (uint8_t *)v103, 0xCu);
  sub_1D3D8C70C((unint64_t *)&Width);
  v36 = v101;
  v68 = os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG);
  if (v36)
  {
    if (!v68)
      goto LABEL_120;
    LOWORD(v103[0].a) = 0;
    v69 = "has PTS";
  }
  else
  {
    if (!v68)
      goto LABEL_120;
    LOWORD(v103[0].a) = 0;
    v69 = "no PTS, will use current time";
  }
  _os_log_debug_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_DEBUG, v69, (uint8_t *)v103, 2u);
LABEL_120:
  v76 = v115;
  v77 = os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG);
  if (v76)
  {
    if (!v77)
      goto LABEL_60;
    LOWORD(v103[0].a) = 0;
    v78 = "has camera intrinsic matrix";
  }
  else
  {
    if (!v77)
      goto LABEL_60;
    LOWORD(v103[0].a) = 0;
    v78 = "no camera intrinsic matrix, will derive from pixel buffer";
  }
  _os_log_debug_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_DEBUG, v78, (uint8_t *)v103, 2u);
LABEL_60:
  if (v36)
  {
    time = v100;
    CMTimeGetSeconds(&time);
  }
  else
  {
    CFAbsoluteTimeGetCurrent();
  }
  if (v115)
  {
    Width = *(float *)v111.i32;
    v106 = *(float *)v112.i32;
    v107 = vcvtq_f64_f32((float32x2_t)__PAIR64__(v111.u32[1], v113.u32[0]));
    v108 = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v112.i8, v113));
    v109 = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v111, v111, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v112, v112, 8uLL)));
    v110 = v114;
  }
  else
  {
    Width = CGRectGetWidth(*(CGRect *)(*v29 + 1));
    v106 = 0.0;
    v107.f64[0] = (CGRectGetWidth(*(CGRect *)(*v29 + 1)) + -1.0) * 0.5;
    v107.f64[1] = 0.0;
    v108.f64[0] = CGRectGetWidth(*(CGRect *)(*v29 + 1));
    v108.f64[1] = (CGRectGetHeight(*(CGRect *)(*v29 + 1)) + -1.0) * 0.5;
    v109 = 0uLL;
    v110 = 1.0;
  }
  if (!*v4 || v4[1] != v4[2] || *((_BYTE *)v4 + 128))
  {
LABEL_168:
    if (!v102)
      goto LABEL_72;
    goto LABEL_169;
  }
  atomic_load(*v29);
  AppC3DProcessCameraFrameData();
  v37 = v102;
  if (v102)
  {
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      goto LABEL_169;
    LODWORD(v103[0].a) = 138543362;
    *(_QWORD *)((char *)&v103[0].a + 4) = v37;
    v93 = "AppC3DProcessCameraFrameData returned %{public}@";
LABEL_167:
    _os_log_error_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_ERROR, v93, (uint8_t *)v103, 0xCu);
    goto LABEL_168;
  }
  AppC3DWait();
  v38 = v102;
  if (v102)
  {
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      goto LABEL_169;
    LODWORD(v103[0].a) = 138543362;
    *(_QWORD *)((char *)&v103[0].a + 4) = v38;
    v93 = "AppC3DWait returned %{public}@";
    goto LABEL_167;
  }
  AppC3DFlush();
  v39 = v102;
  if (!v102)
    goto LABEL_72;
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v103[0].a) = 138543362;
    *(_QWORD *)((char *)&v103[0].a + 4) = v39;
    v93 = "AppC3DFlush returned %{public}@";
    goto LABEL_167;
  }
LABEL_169:
  v103[0].a = NAN;
  v98 = CFSTR("AppC3D error.");
  sub_1D3D73E0C(v4 + 4, (uint64_t *)v103, (CFTypeRef *)&v98);
  v94 = v4 + 12;
  v95 = v102;
  do
    v96 = (const void *)__ldaxr(v94);
  while (__stlxr(v95, v94));
  if (v96)
    CFRelease(v96);
LABEL_72:
  if (*((_BYTE *)v4 + 128))
  {
    v41 = (unint64_t *)v4[1];
    v40 = (unint64_t *)v4[2];
    if (v40 == v41)
    {
      v4[2] = (unint64_t)v41;
      LOBYTE(v103[0].a) = 0;
      v104 = 0;
    }
    else
    {
      do
        v40 = sub_1D3D74F14(v40 - 1);
      while (v40 != v41);
      v42 = *((unsigned __int8 *)v4 + 128);
      v4[2] = (unint64_t)v41;
      LOBYTE(v103[0].a) = 0;
      v104 = 0;
      if (!v42)
      {
LABEL_98:
        sub_1D3D74C98(v27, (uint64_t)v103);
        if (v104)
          sub_1D3DF4F24((unint64_t *)v103);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          sub_1D3DF53CC((CFErrorRef *)&v98, (uint64_t)v27);
          v70 = atomic_load((unint64_t *)&v98);
          LODWORD(v103[0].a) = 138543362;
          *(_QWORD *)((char *)&v103[0].a + 4) = v70;
          _os_log_error_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_ERROR, "failed to decode, error: %{public}@", (uint8_t *)v103, 0xCu);
          sub_1D3D7448C((unint64_t *)&v98);
        }
        goto LABEL_102;
      }
    }
    sub_1D3DF50BC(v103, (uint64_t *)v4 + 4);
    v104 = 1;
    if (*((_BYTE *)v4 + 128))
    {
      sub_1D3DF4F24(v4 + 4);
      *((_BYTE *)v4 + 128) = 0;
    }
    goto LABEL_98;
  }
  if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
  {
    v43 = (uint64_t)(v4[2] - v4[1]) >> 3;
    LODWORD(v103[0].a) = 134349056;
    *(_QWORD *)((char *)&v103[0].a + 4) = v43;
    _os_log_impl(&dword_1D3D6B000, v35, OS_LOG_TYPE_INFO, "finished decoding, number of descriptors: %{public}zu", (uint8_t *)v103, 0xCu);
  }
  v44 = (unint64_t *)v4[1];
  v45 = (unint64_t *)v4[2];
  if (v44 != v45)
  {
    do
    {
      v46 = atomic_load(v44);
      if (*(_BYTE *)(v46 + 64))
      {
        v47 = atomic_load(v44);
        v48 = *(double **)(v47 + 40);
        v49 = *(double **)(v47 + 48);
        while (v48 != v49)
        {
          memset(v103, 0, 48);
          v50 = CGRectGetWidth(*(CGRect *)(*v29 + 1));
          Height = CGRectGetHeight(*(CGRect *)(*v29 + 1));
          CGAffineTransformMakeScale(v103, v50, Height);
          *(float64x2_t *)v48 = vaddq_f64(*(float64x2_t *)&v103[0].tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v103[0].c, v48[1]), *(float64x2_t *)&v103[0].a, *v48));
          v48 += 2;
        }
      }
      ++v44;
    }
    while (v44 != v45);
    v53 = (unint64_t *)v4[1];
    v52 = (unint64_t *)v4[2];
    v54 = (char *)v52 - (char *)v53;
    if ((char *)v52 - (char *)v53 >= 1)
    {
      v55 = (unint64_t *)v28[1];
      v56 = v54 >> 3;
      v57 = v28[2];
      if (v54 >> 3 <= (v57 - (uint64_t)v55) >> 3)
      {
        if (v56 <= 0)
        {
          v71 = &v53[v56];
          v72 = (unint64_t *)v28[1];
          v79 = &v55[v56];
          v80 = &v72[-v56];
          v81 = (unint64_t *)v28[1];
          if (v80 < v55)
          {
            v82 = v80;
            v81 = (unint64_t *)v28[1];
            do
            {
              do
                v83 = __ldaxr(v82);
              while (__stlxr(0, v82));
              *v81++ = v83;
              ++v82;
            }
            while (v82 < v55);
          }
          v28[1] = (uint64_t)v81;
          if (v72 != v79)
          {
            do
            {
              --v80;
              --v72;
              do
                v84 = __ldaxr(v80);
              while (__stlxr(0, v80));
              do
                v85 = (const void *)__ldaxr(v72);
              while (__stlxr(v84, v72));
              if (v85)
                CFRelease(v85);
            }
            while (v80 != v55);
          }
          while (v53 != v71)
          {
            do
              v86 = __ldaxr(v53);
            while (__stlxr(0, v53));
            do
              v87 = (const void *)__ldaxr(v55);
            while (__stlxr(v86, v55));
            if (v87)
              CFRelease(v87);
            ++v53;
            ++v55;
          }
        }
        else
        {
          if ((unint64_t *)v4[1] == v52)
          {
            v65 = (unint64_t *)v28[1];
          }
          else
          {
            v64 = (unint64_t *)v4[1];
            v65 = (unint64_t *)v28[1];
            do
            {
              do
                v66 = __ldaxr(v64);
              while (__stlxr(0, v64));
              *v65++ = v66;
              ++v64;
            }
            while (v64 != v52);
          }
          v28[1] = (uint64_t)v65;
        }
      }
      else
      {
        v58 = ((uint64_t)v55 - *v28) >> 3;
        if ((unint64_t)(v58 + v56) >> 61)
          sub_1D3D6D4F8();
        v59 = v57 - *v28;
        v60 = v59 >> 2;
        if (v59 >> 2 <= (unint64_t)(v58 + v56))
          v60 = v58 + v56;
        if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8)
          v61 = 1.49166815e-154;
        else
          v61 = *(double *)&v60;
        *(_QWORD *)&v103[0].tx = v28 + 2;
        if (v61 == 0.0)
          v62 = 0;
        else
          v61 = COERCE_DOUBLE(sub_1D3D6D8A0(*(unint64_t *)&v61));
        v73 = (unint64_t *)(*(_QWORD *)&v61 + 8 * v58);
        v103[0].a = v61;
        *(_QWORD *)&v103[0].b = v73;
        *(_QWORD *)&v103[0].c = v73;
        *(_QWORD *)&v103[0].d = *(_QWORD *)&v61 + 8 * v62;
        *(_QWORD *)&v74 = &v73[v56];
        do
        {
          do
            v75 = __ldaxr(v53);
          while (__stlxr(0, v53));
          *v73++ = v75;
          ++v53;
        }
        while (v73 != *(unint64_t **)&v74);
        v103[0].c = v74;
        sub_1D3D75E08(v28, v103, (uint64_t)v55);
        sub_1D3D75F10((uint64_t)v103);
      }
    }
    v89 = (unint64_t *)v4[1];
    for (i = (unint64_t *)v4[2]; i != v89; i = sub_1D3D74F14(i - 1))
      ;
    v4[2] = (unint64_t)v89;
    v63 = 1;
    goto LABEL_150;
  }
LABEL_102:
  v63 = 0;
LABEL_150:
  v90 = v122;
  if (*(_BYTE *)(buf + 8))
  {
    if (!v122)
      return v63;
    v103[0].a = *(CGFloat *)buf;
    (*(void (**)(void))(*(_QWORD *)v122 + 48))();
    v90 = v122;
  }
  if (v90 == (__int128 *)((char *)&buf + 8))
  {
    v91 = 4;
    goto LABEL_157;
  }
  if (v90)
  {
    v91 = 5;
    v31 = v90;
LABEL_157:
    (*(void (**)(_QWORD *))(*v31 + 8 * v91))(v31);
  }
  return v63;
}

void sub_1D3DB2614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  _QWORD *v32;
  uint64_t v33;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;

  v35 = *(_QWORD *)(v33 - 160);
  if (*(_BYTE *)(v35 + 8))
  {
    v38 = *(_QWORD *)(v33 - 128);
    if (!v38)
      goto LABEL_9;
    a32 = *(_QWORD *)v35;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v38 + 48))(v38, &a32);
  }
  v36 = *(_QWORD **)(v33 - 128);
  if (v36 == v32)
  {
    v37 = 4;
  }
  else
  {
    if (!v36)
      goto LABEL_9;
    v37 = 5;
    v32 = *(_QWORD **)(v33 - 128);
  }
  (*(void (**)(_QWORD *))(*v32 + 8 * v37))(v32);
LABEL_9:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DB27A0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120DecoderAppC3DContext6decodeERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS5_IyEERKNS_6SampleERKNS5_INS4_17reference_wrapperIKNS_6RegionEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB27D8()
{
  return &unk_1E95ACE98;
}

void sub_1D3DB27E4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89360 != -1)
    dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89398;
    if (os_signpost_enabled((os_log_t)qword_1EDB89398))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "AppClipCodeDecoderInternal::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

void sub_1D3DB2884(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  BOOL v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  unint64_t v17;
  BOOL v18;
  const __CFArray *v19;
  CFIndex v20;
  CGPoint *v21;
  const __CFArray *v22;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v24;
  CFTypeID v25;
  uint64_t v26;
  __int128 v27;
  uint8_t *v28;
  double *v29;
  double *v30;
  double v31;
  double *v32;
  double *v33;
  double *v34;
  uint8_t *v35;
  double v36;
  double v37;
  double v38;
  uint8_t *v40;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  uint8_t *v48;
  uint8_t *v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE *v54;
  __int128 v55;
  _OWORD *v56;
  _OWORD *v57;
  _OWORD *v58;
  BOOL v59;
  char v60;
  uint64_t v61;
  int v62;
  unint64_t v63;
  int v64;
  __int16 Metadata;
  unint64_t v66;
  __int16 v67;
  __int16 DataVersion;
  unint64_t v69;
  __int16 v70;
  unint64_t v72;
  CFTypeRef v73;
  unint64_t *v74;
  const void *v75;
  unint64_t v76;
  unint64_t *v77;
  unint64_t v78;
  const void *v79;
  unint64_t v80;
  void **v81;
  void *v82;
  _OWORD *v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  _QWORD *v91;
  unint64_t v92;
  unint64_t *v93;
  unint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  int v102;
  uint8_t *v103;
  NSObject *v104;
  const char *v105;
  const __CFArray *v107;
  CFIndex Count;
  unint64_t *v110;
  unint64_t v111;
  const void *v112;
  NSObject *oslog;
  _QWORD *v114;
  uint64_t *v115;
  uint64_t NumberOfTrackingData;
  _QWORD *v117;
  _OWORD *v119;
  uint64_t Corners;
  uint64_t Data;
  unint64_t v122;
  _BYTE buf[32];
  __int128 v124;
  __int128 v125;
  uint8_t v126[16];
  uint64_t v127;
  unint64_t v128;
  _QWORD *v129;
  uint64_t v130;

  v130 = *MEMORY[0x1E0C80C00];
  if (a2)
    v9 = a7 == 0;
  else
    v9 = 0;
  v10 = !v9;
  if (qword_1EDB89360 != -1)
    dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
  v11 = qword_1EDB89398;
  if (v10)
  {
    if (os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = a7;
      _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "AppC3D update callback called with error %{public}@", buf, 0xCu);
    }
    return;
  }
  v117 = a1;
  oslog = qword_1EDB89398;
  if (os_log_type_enabled((os_log_t)qword_1EDB89398, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134349056;
    *(_QWORD *)&buf[4] = a2;
    _os_log_debug_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_DEBUG, "AppC3D update callback called with tracking result: %{public}p", buf, 0xCu);
  }
  v122 = 0;
  NumberOfTrackingData = AppC3DTrackingResultGetNumberOfTrackingData();
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134349312;
    *(_QWORD *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 2050;
    *(_QWORD *)&buf[14] = NumberOfTrackingData;
    _os_log_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_INFO, "Tracking result %{public}p has %{public}zu tracking data.", buf, 0x16u);
  }
  if (!NumberOfTrackingData)
    goto LABEL_137;
  v12 = 0;
  v115 = a1 + 1;
  v114 = a1 + 3;
  do
  {
    Data = AppC3DTrackingResultCreateData();
    v13 = atomic_load((unint64_t *)&Data);
    v14 = v122;
    if (v13)
      v15 = v122 == 0;
    else
      v15 = 0;
    if (!v15)
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v14;
        _os_log_error_impl(&dword_1D3D6B000, oslog, OS_LOG_TYPE_ERROR, "AppC3DTrackingResultCreateData failed, and returned %{public}@", buf, 0xCu);
      }
      sub_1D3DB386C((unint64_t *)&Data);
      break;
    }
    Corners = AppC3DTrackingResultCreateCorners();
    v16 = atomic_load((unint64_t *)&Corners);
    v17 = v122;
    if (v16)
      v18 = v122 == 0;
    else
      v18 = 0;
    if (!v18)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        goto LABEL_120;
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v17;
      v103 = buf;
      v104 = oslog;
      v105 = "AppC3DTrackingResultCreateCorners failed, and returned %{public}@";
      goto LABEL_122;
    }
    v19 = (const __CFArray *)atomic_load((unint64_t *)&Corners);
    if (CFArrayGetCount(v19) != 4)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        goto LABEL_120;
      v107 = (const __CFArray *)atomic_load((unint64_t *)&Corners);
      Count = CFArrayGetCount(v107);
      *(_DWORD *)buf = 134349056;
      *(_QWORD *)&buf[4] = Count;
      v103 = buf;
      v104 = oslog;
      v105 = "AppC3DTrackingResultCreateCorners returns unexpected number of corners: %{public}ld";
LABEL_122:
      _os_log_error_impl(&dword_1D3D6B000, v104, OS_LOG_TYPE_ERROR, v105, v103, 0xCu);
LABEL_120:
      v102 = 4;
      goto LABEL_114;
    }
    v20 = 0;
    v21 = (CGPoint *)buf;
    do
    {
      v22 = (const __CFArray *)atomic_load((unint64_t *)&Corners);
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, v20);
      v24 = ValueAtIndex;
      if (!ValueAtIndex || (v25 = CFGetTypeID(ValueAtIndex), v25 != CFDictionaryGetTypeID()))
      {
        if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
          goto LABEL_120;
LABEL_121:
        *(_DWORD *)v126 = 134349056;
        *(_QWORD *)&v126[4] = v20;
        v103 = v126;
        v104 = oslog;
        v105 = "AppC3DTrackingResultCreateCorners returns unexpected object at: %{public}ld";
        goto LABEL_122;
      }
      if (!CGPointMakeWithDictionaryRepresentation(v24, v21))
      {
        if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
          goto LABEL_120;
        goto LABEL_121;
      }
      ++v20;
      ++v21;
    }
    while (v20 != 4);
    v26 = 0;
    v27 = *(_OWORD *)&buf[16];
    *(_OWORD *)&buf[16] = v125;
    v125 = v27;
    v28 = buf;
    v29 = (double *)&buf[8];
    v30 = (double *)&buf[8];
    v31 = *(double *)buf;
    v32 = (double *)&buf[8];
    v33 = (double *)&buf[8];
    v34 = (double *)&buf[8];
    do
    {
      v35 = v28;
      v28 = &buf[v26 + 16];
      v36 = *(double *)v28;
      v37 = *(double *)v28 + *(double *)&buf[v26 + 24];
      v38 = v31 + *v30;
      if (v37 < v38)
      {
        v30 = (double *)&buf[v26 + 24];
      }
      else
      {
        v28 = v35;
        v30 = v32;
      }
      if (v37 >= v38)
        v32 = v33;
      else
        v32 = (double *)&buf[v26 + 24];
      if (v37 >= v38)
        v33 = v34;
      else
        v33 = (double *)&buf[v26 + 24];
      if (v37 >= v38)
        v34 = v29;
      else
        v34 = (double *)&buf[v26 + 24];
      if (v37 >= v38)
        v29 = (double *)(v35 + 8);
      else
        v29 = (double *)&buf[v26 + 24];
      v26 += 16;
      if (v37 < v38)
        v31 = v36;
    }
    while (v26 != 48);
    if (v28 != buf && v28 != v126)
    {
      if (&buf[16] == v28)
      {
        v45 = *(_OWORD *)buf;
        v46 = *(_OWORD *)&buf[16];
        *(_OWORD *)&buf[16] = v124;
        v124 = v125;
        *(_OWORD *)buf = v46;
        v125 = v45;
      }
      else
      {
        v40 = v35 + 16;
        if (v37 < v38 || v40 == v126)
        {
          v42 = v125;
          v44 = *(_OWORD *)&buf[16];
          v43 = v124;
          *(_OWORD *)&buf[16] = *(_OWORD *)buf;
          v124 = v44;
          v125 = v43;
          *(_OWORD *)buf = v42;
        }
        else
        {
          v47 = (v28 - buf) >> 4;
          if (v47 == (v126 - v28) >> 4)
          {
            v48 = v28 + 16;
            v49 = &buf[16];
            do
            {
              *(_OWORD *)v126 = *((_OWORD *)v49 - 1);
              v50 = *(_OWORD *)v126;
              *((_OWORD *)v49 - 1) = *((_OWORD *)v48 - 1);
              *((_OWORD *)v48 - 1) = v50;
              if (v49 == v28)
                break;
              v49 += 16;
              v9 = v48 == v126;
              v48 += 16;
            }
            while (!v9);
          }
          else
          {
            v51 = (v126 - v28) >> 4;
            v52 = (v28 - buf) >> 4;
            do
            {
              v53 = v52;
              v52 = v51;
              v51 = v53 % v51;
            }
            while (v51);
            if (v52)
            {
              v54 = &buf[16 * v52];
              do
              {
                v55 = *((_OWORD *)v54 - 1);
                v54 -= 16;
                *(_OWORD *)v126 = v55;
                v56 = &v54[16 * v47];
                v57 = v54;
                do
                {
                  v58 = v57;
                  v57 = v56;
                  *v58 = *v56;
                  v59 = __OFSUB__(v47, (v126 - (uint8_t *)v56) >> 4);
                  v61 = v47 - ((v126 - (uint8_t *)v56) >> 4);
                  v60 = (v61 < 0) ^ v59;
                  v56 = &buf[16 * v61];
                  if (v60)
                    v56 = &v57[v47];
                }
                while (v56 != (_OWORD *)v54);
                *v57 = *(_OWORD *)v126;
              }
              while (v54 != buf);
            }
          }
        }
      }
    }
    AppC3DTrackingResultGetConfidence();
    v63 = v122;
    if (v122)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        goto LABEL_120;
      *(_DWORD *)v126 = 138543362;
      *(_QWORD *)&v126[4] = v63;
      v103 = v126;
      v104 = oslog;
      v105 = "AppC3DTrackingResultGetConfidence returned %{public}@";
      goto LABEL_122;
    }
    v64 = v62;
    Metadata = AppC3DTrackingResultGetMetadata();
    v66 = v122;
    if (v122)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        goto LABEL_120;
      *(_DWORD *)v126 = 138543362;
      *(_QWORD *)&v126[4] = v66;
      v103 = v126;
      v104 = oslog;
      v105 = "AppC3DTrackingResultGetMetadata returned %{public}@";
      goto LABEL_122;
    }
    v67 = Metadata;
    DataVersion = AppC3DTrackingResultGetDataVersion();
    v69 = v122;
    if (v122)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        goto LABEL_120;
      *(_DWORD *)v126 = 138543362;
      *(_QWORD *)&v126[4] = v69;
      v103 = v126;
      v104 = oslog;
      v105 = "AppC3DTrackingResultGetDataVersion returned %{public}@";
      goto LABEL_122;
    }
    v70 = DataVersion;
    v119 = sub_1D3DB36B4();
    if (atomic_load((unint64_t *)&v119))
    {
      v72 = atomic_load((unint64_t *)&v119);
      v73 = CFRetain(CFSTR("AppClipCode"));
      v74 = (unint64_t *)(v72 + 16);
      do
        v75 = (const void *)__ldaxr(v74);
      while (__stlxr((unint64_t)v73, v74));
      if (v75)
        CFRelease(v75);
      v76 = atomic_load((unint64_t *)&v119);
      v77 = (unint64_t *)(v76 + 24);
      do
        v78 = __ldaxr((unint64_t *)&Data);
      while (__stlxr(0, (unint64_t *)&Data));
      do
        v79 = (const void *)__ldaxr(v77);
      while (__stlxr(v78, v77));
      if (v79)
        CFRelease(v79);
      v80 = atomic_load((unint64_t *)&v119);
      v81 = (void **)(v80 + 40);
      if (*(_BYTE *)(v80 + 64))
      {
        v82 = *v81;
        if (*v81)
        {
          *(_QWORD *)(v80 + 48) = v82;
          operator delete(v82);
        }
        *(_BYTE *)(v80 + 64) = 0;
      }
      *v81 = 0;
      *(_QWORD *)(v80 + 48) = 0;
      *(_QWORD *)(v80 + 56) = 0;
      sub_1D3DB38A4((_QWORD *)(v80 + 40), 4uLL);
      v83 = *(_OWORD **)(v80 + 48);
      v84 = *(_OWORD *)buf;
      v85 = *(_OWORD *)&buf[16];
      v86 = v125;
      v83[2] = v124;
      v83[3] = v86;
      *v83 = v84;
      v83[1] = v85;
      *(_QWORD *)(v80 + 48) = v83 + 4;
      *(_BYTE *)(v80 + 64) = 1;
      v87 = atomic_load((unint64_t *)&v119);
      *(_DWORD *)(v87 + 32) = v64;
      *(_BYTE *)(v87 + 36) = 1;
      v88 = atomic_load((unint64_t *)&v119);
      *(_DWORD *)(v88 + 216) = 0;
      *(_BYTE *)(v88 + 220) = 1;
      v89 = atomic_load((unint64_t *)&v119);
      *(_WORD *)(v89 + 216) = v67 | 0x100;
      v90 = atomic_load((unint64_t *)&v119);
      *(_WORD *)(v90 + 218) = v70 | 0x100;
      v91 = v117;
      v93 = (unint64_t *)v117[2];
      v92 = v117[3];
      if ((unint64_t)v93 >= v92)
      {
        v96 = ((uint64_t)v93 - *v115) >> 3;
        if ((unint64_t)(v96 + 1) >> 61)
          sub_1D3D6D4F8();
        v97 = v92 - *v115;
        v98 = v97 >> 2;
        if (v97 >> 2 <= (unint64_t)(v96 + 1))
          v98 = v96 + 1;
        if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF8)
          v99 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v99 = v98;
        v129 = v114;
        if (v99)
          v99 = (unint64_t)sub_1D3D6D8A0(v99);
        else
          v100 = 0;
        *(_QWORD *)v126 = v99;
        *(_QWORD *)&v126[8] = v99 + 8 * v96;
        v127 = *(_QWORD *)&v126[8];
        v128 = v99 + 8 * v100;
        do
          v101 = __ldaxr((unint64_t *)&v119);
        while (__stlxr(0, (unint64_t *)&v119));
        *(_QWORD *)(v99 + 8 * v96) = v101;
        v127 += 8;
        sub_1D3DB37F8(v115, v126);
        v95 = (_QWORD *)v117[2];
        sub_1D3D75F10((uint64_t)v126);
        v91 = v117;
      }
      else
      {
        do
          v94 = __ldaxr((unint64_t *)&v119);
        while (__stlxr(0, (unint64_t *)&v119));
        *v93 = v94;
        v95 = v93 + 1;
        v117[2] = v95;
      }
      v102 = 0;
      v91[2] = v95;
    }
    else
    {
      v102 = 4;
    }
    sub_1D3D74F14((unint64_t *)&v119);
LABEL_114:
    sub_1D3D74138((unint64_t *)&Corners);
    sub_1D3DB386C((unint64_t *)&Data);
    if (v102)
      break;
    ++v12;
  }
  while (v12 != NumberOfTrackingData);
LABEL_137:
  if (v122)
  {
    *(_QWORD *)buf = -3001;
    *(_QWORD *)v126 = CFSTR("AppC3D error.");
    sub_1D3D73E0C(v117 + 4, (uint64_t *)buf, (CFTypeRef *)v126);
    v110 = v117 + 12;
    v111 = v122;
    do
      v112 = (const void *)__ldaxr(v110);
    while (__stlxr(v111, v110));
    if (v112)
      CFRelease(v112);
  }
}

void sub_1D3DB3224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  unint64_t v17;
  va_list va;
  va_list va1;

  va_start(va1, a16);
  va_start(va, a16);
  v17 = va_arg(va1, _QWORD);
  sub_1D3D74138((unint64_t *)va);
  sub_1D3DB386C((unint64_t *)va1);
  _Unwind_Resume(a1);
}

void sub_1D3DB32A4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  CGFloat Width;
  CGFloat Height;
  __CVBuffer *v7;
  _DWORD v8[2];
  __int16 v9;
  CGFloat v10;
  __int16 v11;
  int v12;
  __int16 v13;
  CGFloat v14;
  __int16 v15;
  OSType PixelFormatType;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89360 != -1)
    dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89398;
    if (os_signpost_enabled((os_log_t)qword_1EDB89398))
    {
      Width = CGRectGetWidth(*(CGRect *)(**(_QWORD **)(a1 + 8) + 8));
      Height = CGRectGetHeight(*(CGRect *)(**(_QWORD **)(a1 + 8) + 8));
      v7 = (__CVBuffer *)atomic_load(**(unint64_t ***)(a1 + 8));
      v8[0] = 67110144;
      v8[1] = 17;
      v9 = 2050;
      v10 = Width;
      v11 = 1024;
      v12 = 17;
      v13 = 2050;
      v14 = Height;
      v15 = 1026;
      PixelFormatType = CVPixelBufferGetPixelFormatType(v7);
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "AppClipCodeDecoderInternal::decode", "samplePixelBufferWidth=%{public, signpost.description:attribute}.*g, samplePixelBufferHeight=%{public, signpost.description:attribute}.*g, samplePixelBufferPixelFormatType=0x%{public, signpost.description:attribute}x", (uint8_t *)v8, 0x28u);
    }
  }
}

void sub_1D3DB3404()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB3418(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AD208;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DB344C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AD208;
  a2[1] = v2;
  return result;
}

void sub_1D3DB3468(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v3;
  NSObject *v4;
  CGFloat Width;
  CGFloat Height;
  __CVBuffer *v7;
  _DWORD v8[2];
  __int16 v9;
  CGFloat v10;
  __int16 v11;
  int v12;
  __int16 v13;
  CGFloat v14;
  __int16 v15;
  OSType PixelFormatType;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (qword_1EDB89360 != -1)
    dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EDB89398;
    if (os_signpost_enabled((os_log_t)qword_1EDB89398))
    {
      Width = CGRectGetWidth(*(CGRect *)(**(_QWORD **)(a1 + 8) + 8));
      Height = CGRectGetHeight(*(CGRect *)(**(_QWORD **)(a1 + 8) + 8));
      v7 = (__CVBuffer *)atomic_load(**(unint64_t ***)(a1 + 8));
      v8[0] = 67110144;
      v8[1] = 17;
      v9 = 2050;
      v10 = Width;
      v11 = 1024;
      v12 = 17;
      v13 = 2050;
      v14 = Height;
      v15 = 1026;
      PixelFormatType = CVPixelBufferGetPixelFormatType(v7);
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v3, "AppClipCodeDecoderInternal::decode", "samplePixelBufferWidth=%{public, signpost.description:attribute}.*g, samplePixelBufferHeight=%{public, signpost.description:attribute}.*g, samplePixelBufferPixelFormatType=0x%{public, signpost.description:attribute}x", (uint8_t *)v8, 0x28u);
    }
  }
}

uint64_t sub_1D3DB35C4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6decodeERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS5_IyEERKNS_6SampleERKNS5_INS4_17reference_wrapperIKNS_6RegionEEEEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB35FC()
{
  return &unk_1E95ACEC8;
}

void sub_1D3DB360C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB3620(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AD260;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DB3654(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AD260;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3DB3670(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6decodeERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS5_IyEERKNS_6SampleERKNS5_INS4_17reference_wrapperIKNS_6RegionEEEEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB36A8()
{
  return &unk_1E95ACED8;
}

_OWORD *sub_1D3DB36B4()
{
  _OWORD *Instance;
  _OWORD *v1;
  CFTypeID v2;
  CFTypeID v3;

  if (qword_1EFE31A20 != -1)
    dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v1 = Instance;
  if (Instance)
  {
    v2 = CFGetTypeID(Instance);
    if (qword_1EFE31A20 != -1)
      dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
    if (v2 != qword_1EFE31A28)
      _os_assumes_log();
    v1[20] = 0u;
    v1[21] = 0u;
    v1[18] = 0u;
    v1[19] = 0u;
    v1[16] = 0u;
    v1[17] = 0u;
    v1[14] = 0u;
    v1[15] = 0u;
    v1[12] = 0u;
    v1[13] = 0u;
    v1[10] = 0u;
    v1[11] = 0u;
    v1[8] = 0u;
    v1[9] = 0u;
    v1[6] = 0u;
    v1[7] = 0u;
    v1[4] = 0u;
    v1[5] = 0u;
    v1[2] = 0u;
    v1[3] = 0u;
    v1[1] = 0u;
    v3 = CFGetTypeID(v1);
    if (qword_1EFE31A20 != -1)
      dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
    if (v3 != qword_1EFE31A28)
      _os_assumes_log();
  }
  return v1;
}

uint64_t sub_1D3DB37F8(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = sub_1D3D75F5C(a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = result;
  v5 = *a1;
  *a1 = result;
  a2[1] = v5;
  v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
  return result;
}

unint64_t *sub_1D3DB386C(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

char *sub_1D3DB38A4(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    sub_1D3D6D4F8();
  result = (char *)sub_1D3D6DB64(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

_QWORD *sub_1D3DB38E0()
{
  _QWORD *result;
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1EDB89048)
    _os_assumes_log();
  if (qword_1EFE31A28)
    _os_assumes_log();
  qword_1EDB89048 = (uint64_t)"MRCDescriptor";
  qword_1EFE31A28 = _CFRuntimeRegisterClass();
  v2[0] = &off_1E95B4128;
  v3 = v2;
  sub_1D3DAFDB4(qword_1EFE31A28, v2);
  result = v3;
  if (v3 == v2)
  {
    v1 = 4;
    result = v2;
  }
  else
  {
    if (!v3)
      return result;
    v1 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v1))();
}

void sub_1D3DB39B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1D3DB3A00()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB3A14()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B4128;
  return result;
}

void sub_1D3DB3A38(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B4128;
}

CFStringRef sub_1D3DB3A50@<X0>(CFTypeRef *a1@<X1>, CFStringRef *a2@<X8>)
{
  CFTypeRef v3;
  CFTypeID v4;
  CFStringRef result;

  v3 = *a1;
  if (*a1)
  {
    v4 = CFGetTypeID(*a1);
    if (qword_1EFE31A20 != -1)
      dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
    if (v4 != qword_1EFE31A28)
      _os_assumes_log();
  }
  result = sub_1D3E274F0((uint64_t)v3 + 16, 1);
  *a2 = result;
  return result;
}

uint64_t sub_1D3DB3AE0(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc2CFINS_10DescriptorENS_2cf6TraitsIS1_NS2_13PersonalitiesIS1_XtlNS_12fixed_stringILm13EEEtlNS_18basic_fixed_stringIcLm13ENSt3__111char_traitsIcEEEEtlA14_cLc77ELc82ELc67ELc68ELc101ELc115ELc99ELc114ELc105ELc112ELc116ELc111ELc114EEEEEJEEEEEE18registerClassOnce_EPvEUlPKvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB3B18()
{
  return &unk_1E95B4198;
}

unint64_t *sub_1D3DB3B24(unint64_t *cf)
{
  CFTypeID v2;
  CFTypeID v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE31A20 != -1)
      dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
    if (v2 != qword_1EFE31A28)
      _os_assumes_log();
    v3 = CFGetTypeID(cf);
    if (qword_1EFE31A20 != -1)
      dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
    if (v3 != qword_1EFE31A28)
      _os_assumes_log();
  }
  if (*((_BYTE *)cf + 344))
  {
    v4 = (void *)cf[40];
    if (v4)
    {
      cf[41] = (unint64_t)v4;
      operator delete(v4);
    }
  }
  if (*((_BYTE *)cf + 312))
  {
    v5 = (void *)cf[36];
    if (v5)
    {
      cf[37] = (unint64_t)v5;
      operator delete(v5);
    }
  }
  if (*((_BYTE *)cf + 208))
    sub_1D3DB386C(cf + 25);
  if (*((_BYTE *)cf + 136))
    sub_1D3D7F520((_QWORD *)cf[15]);
  if (*((_BYTE *)cf + 96))
  {
    v6 = (void *)cf[9];
    if (v6)
    {
      cf[10] = (unint64_t)v6;
      operator delete(v6);
    }
  }
  if (*((_BYTE *)cf + 64))
  {
    v7 = (void *)cf[5];
    if (v7)
    {
      cf[6] = (unint64_t)v7;
      operator delete(v7);
    }
  }
  sub_1D3DB386C(cf + 3);
  return sub_1D3D8C70C(cf + 2);
}

uint64_t sub_1D3DB3C7C(unsigned __int8 *cf, unsigned __int8 *a2)
{
  CFTypeID v4;
  CFTypeID v5;
  const void *v6;
  const void *v7;
  BOOL v8;
  const __CFString *v11;
  const __CFString *v12;
  const void *v13;
  const void *v14;
  uint64_t result;
  int v16;

  if (!cf)
    goto LABEL_5;
  v4 = CFGetTypeID(cf);
  if (qword_1EFE31A20 != -1)
    dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
  if (v4 != qword_1EFE31A28)
  {
    _os_assumes_log();
    if (!a2)
      goto LABEL_10;
  }
  else
  {
LABEL_5:
    if (!a2)
      goto LABEL_10;
  }
  v5 = CFGetTypeID(a2);
  if (qword_1EFE31A20 != -1)
    dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
  if (v5 != qword_1EFE31A28)
    _os_assumes_log();
LABEL_10:
  v6 = (const void *)atomic_load((unint64_t *)a2 + 2);
  v7 = (const void *)atomic_load((unint64_t *)cf + 2);
  if (v7 != v6)
  {
    v8 = !v6 || v7 == 0;
    if (v8 || !CFEqual(v7, v6))
    {
      if (!atomic_load((unint64_t *)cf + 2))
        return 0;
      if (!atomic_load((unint64_t *)a2 + 2))
        return 0;
      v11 = (const __CFString *)atomic_load((unint64_t *)cf + 2);
      v12 = (const __CFString *)atomic_load((unint64_t *)a2 + 2);
      if (CFStringCompare(v11, v12, 0))
        return 0;
    }
  }
  v13 = (const void *)atomic_load((unint64_t *)a2 + 3);
  v14 = (const void *)atomic_load((unint64_t *)cf + 3);
  if (v14 != v13)
  {
    result = 0;
    if (!v13)
      return result;
    if (!v14)
      return result;
    result = CFEqual(v14, v13);
    if (!(_DWORD)result)
      return result;
  }
  if (cf[36] && a2[36])
  {
    if (*((float *)cf + 8) != *((float *)a2 + 8))
      return 0;
  }
  else if ((cf[36] != 0) != (a2[36] != 0))
  {
    return 0;
  }
  result = sub_1D3E2716C((uint64_t)(cf + 40), (uint64_t)(a2 + 40));
  if (!(_DWORD)result)
    return result;
  result = sub_1D3E2716C((uint64_t)(cf + 72), (uint64_t)(a2 + 72));
  if (!(_DWORD)result)
    return result;
  if (cf[105] && a2[105])
  {
    if (cf[104] != a2[104])
      return 0;
  }
  else if ((cf[105] != 0) != (a2[105] != 0))
  {
    return 0;
  }
  if ((sub_1D3E27220((uint64_t)(cf + 112), (uint64_t)(a2 + 112)) & 1) != 0)
    return 0;
  if (cf[164] && a2[164])
  {
    if (!sub_1D3E27300((uint64_t)(cf + 144), (uint64_t)(a2 + 144)))
      return 0;
  }
  else if ((cf[164] != 0) != (a2[164] != 0))
  {
    return 0;
  }
  if (cf[208] && a2[208])
  {
    if (sub_1D3E273C4(cf + 168, a2 + 168))
      goto LABEL_50;
    return 0;
  }
  if ((cf[208] != 0) != (a2[208] != 0))
    return 0;
LABEL_50:
  v16 = (cf[220] != 0) ^ (a2[220] != 0);
  if (cf[220])
  {
    if (a2[220])
      v16 = !sub_1D3E27468(cf + 216, a2 + 216);
  }
  return v16 ^ 1u;
}

unint64_t sub_1D3DB3F44(unint64_t *cf)
{
  CFTypeID v2;
  uint64_t v3;
  const void *v4;
  CFHashCode v5;
  const void *v6;
  CFHashCode v7;
  CFHashCode v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  BOOL v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  CFHashCode v32;
  const void *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v41;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE31A20 != -1)
      dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
    if (v2 != qword_1EFE31A28)
      _os_assumes_log();
  }
  v3 = 3317042773;
  v41 = 0;
  v4 = (const void *)atomic_load(cf + 2);
  v5 = 3317042773;
  if (v4)
    v5 = CFHash(v4) + 2654435769u;
  v41 ^= v5 + (v41 << 6) + (v41 >> 2);
  v6 = (const void *)atomic_load(cf + 3);
  v7 = 3317042773;
  if (v6)
    v7 = CFHash(v6) + 2654435769u;
  v8 = (v7 + (v41 << 6) + (v41 >> 2)) ^ v41;
  v9 = *((float *)cf + 8);
  v10 = LODWORD(v9) + 2654435769;
  if (v9 == 0.0)
    v10 = 2654435769;
  if (*((_BYTE *)cf + 36))
    v11 = v10;
  else
    v11 = 3317042773;
  v41 = ((v8 >> 2) + (v8 << 6) + v11) ^ v8;
  sub_1D3E28524(&v41, (uint64_t)(cf + 5));
  sub_1D3E28524(&v41, (uint64_t)(cf + 9));
  if (*((_BYTE *)cf + 105))
    v12 = *((unsigned __int8 *)cf + 104) + 2654435769;
  else
    v12 = 3317042773;
  v13 = ((v41 >> 2) + (v41 << 6) + v12) ^ v41;
  v14 = 3317042773;
  if (*((_BYTE *)cf + 136))
  {
    v14 = 3317042773;
    if (cf[16])
    {
      v15 = (unint64_t *)cf[14];
      v14 = 2654435769;
      if (v15 != cf + 15)
      {
        v16 = 0;
        do
        {
          v17 = (unint64_t *)v15[1];
          v18 = v15;
          if (v17)
          {
            do
            {
              v19 = v17;
              v17 = (unint64_t *)*v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              v19 = (unint64_t *)v18[2];
              v20 = *v19 == (_QWORD)v18;
              v18 = v19;
            }
            while (!v20);
          }
          v16 ^= (v16 << 6)
               + 2654435769u
               + (v16 >> 2)
               + ((*((int *)v15 + 8)
                 + 2654435769
                 + ((*((int *)v15 + 7) + 2654435769) << 6)
                 + ((unint64_t)(*((int *)v15 + 7) + 2654435769) >> 2)) ^ (*((int *)v15 + 7) + 2654435769));
          v15 = v19;
        }
        while (v19 != cf + 15);
        v14 = v16 + 2654435769u;
      }
    }
  }
  v21 = (v14 + (v13 << 6) + (v13 >> 2)) ^ v13;
  v22 = 3317042773;
  if (*((_BYTE *)cf + 164))
  {
    if (*((_BYTE *)cf + 148))
      v23 = *((int *)cf + 36) + 2654435769;
    else
      v23 = 3317042773;
    if (*((_BYTE *)cf + 156))
      v24 = *((int *)cf + 38) + 2654435769;
    else
      v24 = 3317042773;
    v25 = ((v23 >> 2) + (v23 << 6) + v24) ^ v23;
    if (*((_BYTE *)cf + 161))
      v26 = *((unsigned __int8 *)cf + 160) + 2654435769;
    else
      v26 = 3317042773;
    v22 = ((v26 + (v25 << 6) + (v25 >> 2)) ^ v25) + 2654435769u;
  }
  v27 = (v22 + (v21 << 6) + (v21 >> 2)) ^ v21;
  v41 = v27;
  if (*((_BYTE *)cf + 208))
  {
    v28 = *((unsigned __int8 *)cf + 168);
    v29 = *((unsigned __int8 *)cf + 192);
    v30 = cf[22];
    v31 = cf[23];
    v32 = 3317042773;
    v33 = (const void *)atomic_load(cf + 25);
    if (v33)
      v32 = CFHash(v33) + 2654435769u;
    v34 = v31 + 2654435769u;
    if (!v29)
      v34 = 3317042773;
    v35 = (v34
         + (((v30 + ((v28 + 2654435769) << 6) + 3318044711u) ^ (v28 + 2654435769)) << 6)
         + (((v30 + ((v28 + 2654435769) << 6) + 3318044711u) ^ (v28 + 2654435769)) >> 2)) ^ (v30
                                                                                               + ((v28 + 2654435769) << 6)
                                                                                               + 3318044711u) ^ (v28 + 2654435769);
    v36 = (((v35 >> 2) + (v35 << 6) + v32) ^ v35) + 2654435769u;
    v27 = v41;
  }
  else
  {
    v36 = 3317042773;
  }
  if (*((_BYTE *)cf + 220))
  {
    if (*((_BYTE *)cf + 217))
      v37 = *((unsigned __int8 *)cf + 216) + 2654435769;
    else
      v37 = 3317042773;
    if (*((_BYTE *)cf + 219))
      v38 = *((unsigned __int8 *)cf + 218) + 2654435769;
    else
      v38 = 3317042773;
    v3 = (((v37 >> 2) + (v37 << 6) + v38) ^ v37) + 2654435769u;
  }
  v39 = (v36 + (v27 << 6) + (v27 >> 2)) ^ v27;
  return (v3 + (v39 << 6) + (v39 >> 2)) ^ v39;
}

CFStringRef sub_1D3DB42D0(CFTypeRef cf)
{
  CFTypeID v2;
  CFStringRef result;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE31A20 != -1)
      dispatch_once_f(&qword_1EFE31A20, 0, (dispatch_function_t)sub_1D3DB38E0);
    if (v2 != qword_1EFE31A28)
      _os_assumes_log();
  }
  result = sub_1D3E274F0((uint64_t)cf + 16, 0);
  if (!result)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<%s %p>"), "MRCDescriptor", cf);
  return result;
}

void sub_1D3DB4388()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB439C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AD158;
  return result;
}

void sub_1D3DB43C0(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AD158;
}

void sub_1D3DB43D8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89360 != -1)
    dispatch_once(&qword_1EDB89360, &unk_1E95B0510);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89398;
    if (os_signpost_enabled((os_log_t)qword_1EDB89398))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "AppClipCodeDecoderInternal::create", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DB4478(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6createERNSt3__18optionalINS_5ErrorEEERKNS3_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB44B0()
{
  return &unk_1E95ACEA8;
}

void sub_1D3DB44C0()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB44D4()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AD1B0;
  return result;
}

void sub_1D3DB44F8(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AD1B0;
}

uint64_t sub_1D3DB4510(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6createERNSt3__18optionalINS_5ErrorEEERKNS3_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB4548()
{
  return &unk_1E95ACEB8;
}

void sub_1D3DB4558(uint64_t a1)
{
  sub_1D3DB457C(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DB457C(uint64_t a1)
{
  void **v2;
  void **v4;

  *(_QWORD *)a1 = &off_1E95AF310;
  v2 = (void **)(a1 + 16);
  sub_1D3D7F814((unsigned int **)(a1 + 80));
  sub_1D3DB45E8((unsigned int **)(a1 + 72));
  sub_1D3D6D10C((unsigned int **)(a1 + 64));
  v4 = (void **)(a1 + 40);
  sub_1D3D6D3BC(&v4);
  v4 = v2;
  sub_1D3D6D79C(&v4);
  return a1;
}

unsigned int **sub_1D3DB45E8(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

uint64_t sub_1D3DB4618(uint64_t a1, uint64_t *a2, unsigned int ***a3, char a4)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AF310;
  *(_BYTE *)(a1 + 12) = a4;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  sub_1D3D6D6A8((unsigned int *)(a1 + 16), *a3, a3[1], a3[1] - *a3);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  v6 = *a2;
  if (v6)
  {
    v7 = (unsigned int *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v9 = *(unsigned int **)(a1 + 64);
    if (v9)
      sub_1D3D6D13C(v9);
  }
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 64) = v6;
  return a1;
}

void sub_1D3DB46C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D6D3BC((void ***)va);
  sub_1D3D6D79C((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB46E4(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD v10[3];
  char v11;
  _QWORD *v12;
  _QWORD *v13;

  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL)
      sub_1D3D6D4F8();
    v6 = (_QWORD *)result;
    v7 = sub_1D3DB485C(a4);
    v8 = v7;
    *v6 = v7;
    v6[1] = v7;
    v6[2] = &v7[3 * v9];
    v13 = v7;
    v12 = v7;
    v10[0] = v6 + 2;
    v10[1] = &v12;
    v10[2] = &v13;
    v11 = 0;
    if (a2 != a3)
    {
      do
      {
        *v7 = 0;
        v7[1] = 0;
        v7[2] = 0;
        sub_1D3D8E528(v7, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
        v7 = v13 + 3;
        v13 += 3;
        a2 += 24;
      }
      while (a2 != a3);
      v8 = v7;
    }
    v11 = 1;
    result = sub_1D3DB47F8((uint64_t)v10);
    v6[1] = v8;
  }
  return result;
}

void sub_1D3DB47D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_1D3D6D3BC(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB47F8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(_QWORD **)(a1 + 16);
    v3 = **(_QWORD **)(a1 + 8);
    if (v2 != v3)
    {
      v4 = **(_QWORD **)(a1 + 16);
      do
      {
        v6 = *(void **)(v4 - 24);
        v4 -= 24;
        v5 = v6;
        if (v6)
        {
          *(_QWORD *)(v2 - 16) = v5;
          operator delete(v5);
        }
        v2 = v4;
      }
      while (v4 != v3);
    }
  }
  return a1;
}

void *sub_1D3DB485C(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL)
    sub_1D3D6D50C();
  return operator new(24 * a1);
}

uint64_t sub_1D3DB48A0(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int *v5;
  uint64_t (**v7)(_QWORD);
  int v8;
  uint64_t v9;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AF990;
  *(_QWORD *)(a1 + 16) = 0;
  v2 = operator new();
  *(_DWORD *)(v2 + 8) = 0;
  v3 = (unsigned int *)(v2 + 8);
  *(_QWORD *)v2 = &off_1E95AF5A0;
  v8 = 0;
  v7 = &off_1E95AF9B0;
  v9 = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  sub_1D3D7F558(&v7);
  do
    v4 = __ldxr(v3);
  while (__stxr(v4 + 1, v3));
  v5 = *(unsigned int **)(a1 + 16);
  if (v5)
    sub_1D3D6D13C(v5);
  *(_QWORD *)(a1 + 16) = v2;
  return a1;
}

unsigned int **sub_1D3DB4958(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

void sub_1D3DB4988(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 24;
      v7 = v4 - 24;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 24;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1D3DB4A14(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = &off_1E95AF5A0;
  v3 = (void **)(a1 + 16);
  sub_1D3DB4988(&v3);
  return a1;
}

void sub_1D3DB4A58(uint64_t a1)
{
  void **v1;

  *(_QWORD *)a1 = &off_1E95AF5A0;
  v1 = (void **)(a1 + 16);
  sub_1D3DB4988(&v1);
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB4AAC(_QWORD *a1)
{
  *a1 = &off_1E95AFA60;
  sub_1D3D7F558(a1 + 2);
  return a1;
}

void sub_1D3DB4ADC(_QWORD *a1)
{
  *a1 = &off_1E95AFA60;
  sub_1D3D7F558(a1 + 2);
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DB4B20(uint64_t a1)
{
  sub_1D3DB5128(a1);
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DB4B44(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int i;
  uint64_t v15;
  char *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  unsigned int *v40;
  unsigned int v41;
  uint64_t j;
  uint64_t v43;
  uint64_t k;
  unsigned int v45;
  unsigned int *v46;
  _QWORD *exception;
  void *v49[3];
  void *__p;
  _BYTE *v51;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v3 = (unsigned int *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
    *a2 = v2;
  }
  else
  {
    v6 = *(unsigned int **)(a1 + 16);
    if (v6)
    {
      v7 = v6 + 2;
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    __p = v6;
    sub_1D3D91AD4((unsigned int **)&__p);
    v9 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v6 + 16))(v6);
    v10 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v6 + 24))(v6);
    LODWORD(v49[0]) = 0;
    sub_1D3D821BC(&__p, 0x20uLL, v49);
    sub_1D3D81C50((uint64_t)v49, v9);
    v11 = *((_QWORD *)v49[2] + 2);
    v12 = 4 * v9 / 5;
    v13 = v9 / 5;
    for (i = 1; i != 5; ++i)
    {
      v15 = (*(uint64_t (**)(unsigned int *, _QWORD, uint64_t))(*(_QWORD *)v6 + 40))(v6, (i * v10 / 5), v11);
      v11 = v15;
      if ((int)v13 < v12)
      {
        v16 = (char *)__p;
        v17 = (unsigned __int8 *)(v15 + v13);
        v18 = v12 - v13;
        do
        {
          v19 = *v17++;
          ++*(_DWORD *)&v16[((unint64_t)v19 >> 1) & 0x7C];
          --v18;
        }
        while (v18);
      }
    }
    v20 = (unint64_t)(v51 - (_BYTE *)__p) >> 2;
    if ((int)v20 < 1)
    {
      v22 = 0;
      v23 = 0;
      v29 = 0;
    }
    else
    {
      v21 = 0;
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v25 = ((unint64_t)(v51 - (_BYTE *)__p) >> 2);
      do
      {
        v26 = *((_DWORD *)__p + v21);
        if (v26 > v24)
        {
          v24 = *((_DWORD *)__p + v21);
          v23 = v21;
        }
        if (v26 > v22)
          v22 = *((_DWORD *)__p + v21);
        ++v21;
      }
      while (v25 != v21);
      v27 = 0;
      v28 = 0;
      v29 = 0;
      do
      {
        if (((int)v27 - v23) * ((int)v27 - v23) * *((_DWORD *)__p + v27) > v28)
        {
          v29 = v27;
          v28 = (v27 - v23) * (v27 - v23) * *((_DWORD *)__p + v27);
        }
        ++v27;
      }
      while (v25 != v27);
    }
    if (v23 <= v29)
      v30 = v29;
    else
      v30 = v23;
    if (v23 >= v29)
      v31 = v29;
    else
      v31 = v23;
    if (v30 - v31 <= (int)v20 >> 4)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_1D3DDE1A0(exception, "Too little dynamic range in luminance");
      *exception = &off_1E95AF510;
      __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
    }
    v32 = v30 - 1;
    if (v30 - 1 > v31)
    {
      v33 = v32;
      v34 = v31;
      v35 = -v31;
      v36 = -1;
      v37 = 1;
      do
      {
        if ((v35 + (int)v33) * (v35 + (int)v33) * v37 * (v22 - *((_DWORD *)__p + v33)) > v36)
        {
          v32 = v33;
          v36 = (v35 + v33) * (v35 + v33) * v37 * (v22 - *((_DWORD *)__p + v33));
        }
        --v33;
        ++v37;
      }
      while (v33 > v34);
    }
    v38 = operator new();
    sub_1D3D938C4(v38, v9, v10);
    v39 = 8 * v32;
    v40 = (unsigned int *)(v38 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    *a2 = v38;
    if (v10 > 0)
    {
      for (j = 0; j != v10; ++j)
      {
        v43 = (*(uint64_t (**)(unsigned int *, uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, j, v11);
        v11 = v43;
        if (v9 >= 1)
        {
          for (k = 0; k != v9; ++k)
          {
            if (v39 > *(unsigned __int8 *)(v43 + k))
              *(_DWORD *)(*(_QWORD *)(v38 + 48)
                        + (((unint64_t)(k + j * *(_QWORD *)(v38 + 24)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (k + j * *(_QWORD *)(v38 + 24));
          }
        }
      }
    }
    do
      v45 = __ldxr(v40);
    while (__stxr(v45 + 1, v40));
    v46 = *(unsigned int **)(a1 + 24);
    if (v46)
      sub_1D3D6D13C(v46);
    *(_QWORD *)(a1 + 24) = v38;
    sub_1D3D7F558(v49);
    if (__p)
    {
      v51 = __p;
      operator delete(__p);
    }
  }
}

void sub_1D3DB4F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  void *v15;

  __cxa_free_exception(v15);
  sub_1D3D7F558(&a11);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DB4F9C@<X0>(unsigned int **a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v12;

  v4 = operator new();
  v5 = v4;
  v6 = *a1;
  if (*a1)
  {
    v7 = v6 + 2;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v12 = v6;
  sub_1D3DB505C(v4, v6);
  v9 = (unsigned int *)(v5 + 8);
  do
    v10 = __ldxr(v9);
  while (__stxr(v10 + 1, v9));
  *a2 = v5;
  return sub_1D3D91AD4(&v12);
}

void sub_1D3DB5030(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  MEMORY[0x1D8254C54](v2, 0x10A1C409D1393C9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB505C(uint64_t a1, unsigned int *a2)
{
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v9;

  if (a2)
  {
    v4 = a2 + 2;
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    v9 = a2;
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = off_1E95AFA10;
    *(_QWORD *)(a1 + 16) = 0;
    do
      v6 = __ldxr(v4);
    while (__stxr(v6 + 1, v4));
    v7 = *(unsigned int **)(a1 + 16);
    if (v7)
      sub_1D3D6D13C(v7);
  }
  else
  {
    v9 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = off_1E95AFA10;
    *(_QWORD *)(a1 + 16) = 0;
  }
  *(_QWORD *)(a1 + 16) = a2;
  sub_1D3D91AD4(&v9);
  *(_QWORD *)a1 = &off_1E95AF478;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = -1;
  return a1;
}

void sub_1D3DB5114(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB5128(uint64_t a1)
{
  unsigned int **v2;

  *(_QWORD *)a1 = &off_1E95AF478;
  v2 = (unsigned int **)(a1 + 24);
  sub_1D3D81D1C((unsigned int **)(a1 + 32));
  sub_1D3D6D10C(v2);
  *(_QWORD *)a1 = off_1E95AFA10;
  sub_1D3D91AD4((unsigned int **)(a1 + 16));
  return a1;
}

_QWORD *sub_1D3DB517C(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E95AF4A8;
  v2 = a1[2];
  if (v2)
    MEMORY[0x1D8254C3C](v2, 0x1000C8077774924);
  return a1;
}

void sub_1D3DB51C4(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_1E95AF4A8;
  v1 = a1[2];
  if (v1)
    MEMORY[0x1D8254C3C](v1, 0x1000C8077774924);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DB521C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t sub_1D3DB5224(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_1D3DB522C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

void *sub_1D3DB5234(uint64_t a1, int a2, void *a3)
{
  int v6;
  _QWORD *exception;

  if (a2 < 0 || (*(int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) <= a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "Requested row is outside the image");
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (!a3)
    a3 = (void *)operator new[]();
  return memcpy(a3, (const void *)(*(_QWORD *)(a1 + 24)+ *(int *)(a1 + 44)+ (*(int *)(a1 + 48) + (uint64_t)a2) * *(int *)(a1 + 32)), v6);
}

void sub_1D3DB52FC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1D3DB5310(uint64_t a1)
{
  void *v2;
  void *v3;
  int v4;
  int v5;

  if (*(_DWORD *)(a1 + 44) || *(_DWORD *)(a1 + 48) || (v2 = *(void **)(a1 + 24)) == 0)
  {
    v2 = *(void **)(a1 + 16);
    if (!v2)
    {
      v3 = (void *)operator new[]();
      v2 = v3;
      *(_QWORD *)(a1 + 16) = v3;
      v4 = *(_DWORD *)(a1 + 36);
      if (v4 == *(_DWORD *)(a1 + 32))
      {
        memcpy(v3, (const void *)(*(_QWORD *)(a1 + 24) + *(int *)(a1 + 48) * (uint64_t)v4 + *(int *)(a1 + 44)), *(int *)(a1 + 56) * (uint64_t)v4);
      }
      else if (*(int *)(a1 + 56) >= 1)
      {
        v5 = 0;
        do
        {
          memcpy((void *)(*(_QWORD *)(a1 + 16) + *(int *)(a1 + 36) * (uint64_t)v5), (const void *)(*(_QWORD *)(a1 + 24)+ *(int *)(a1 + 32) * (uint64_t)(v5 + *(_DWORD *)(a1 + 48))+ *(int *)(a1 + 44)), *(int *)(a1 + 52));
          ++v5;
        }
        while (v5 < *(_DWORD *)(a1 + 56));
        return *(void **)(a1 + 16);
      }
    }
  }
  return v2;
}

uint64_t sub_1D3DB53FC()
{
  return 1;
}

uint64_t sub_1D3DB5404@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int *v11;
  int v12;
  unsigned int v13;
  _QWORD *exception;

  result = operator new();
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_DWORD *)(a1 + 32);
  v8 = *(_DWORD *)(a1 + 40);
  v7 = *(_DWORD *)(a1 + 44);
  v9 = *(_DWORD *)(a1 + 52);
  v10 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(result + 8) = 0;
  v11 = (unsigned int *)(result + 8);
  v12 = *(_DWORD *)(a1 + 48);
  *(_QWORD *)result = &off_1E95AF538;
  *(_QWORD *)(result + 16) = v5;
  *(_QWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = v6;
  *(_DWORD *)(result + 36) = v8;
  *(_DWORD *)(result + 40) = v12;
  *(_DWORD *)(result + 44) = v7;
  *(_DWORD *)(result + 48) = v10;
  *(_DWORD *)(result + 52) = v9;
  if (v10 + v12 > v8 || v9 + v7 > v6)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(exception, "Crop rectangle does not fit within image data.");
    *exception = &off_1E95AF510;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  do
    v13 = __ldxr(v11);
  while (__stxr(v13 + 1, v11));
  *a2 = result;
  return result;
}

void sub_1D3DB54EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  MEMORY[0x1D8254C54](a10, 0x10D1C40DFE2B95DLL);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB5520(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t *v7;

  v3 = *(_QWORD *)(a1 + 8);
  v1 = a1 + 8;
  v2 = v3;
  if (!v3)
    return 0;
  v4 = v1;
  do
  {
    v5 = *(_DWORD *)(v2 + 32);
    v6 = v5 < 0;
    if (v5 >= 0)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (!v6)
      v4 = v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 != v1 && *(int *)(v4 + 32) <= 0)
    return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 40) + 16))(*(_QWORD *)(v4 + 40), 0);
  else
    return 0;
}

void sub_1D3DB5578(uint64_t **a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t **v6;
  uint64_t v7;
  int v8;
  _DWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  __int128 v13;
  _QWORD v14[2];
  char v15;

  v4 = operator new(0x28uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_1E95B02E0;
  *((_DWORD *)v4 + 8) = a2;
  *((_QWORD *)&v13 + 1) = v4;
  v4[3] = &off_1E95AEF80;
  *(_QWORD *)&v13 = v4 + 3;
  v5 = (uint64_t)a1[1];
  v6 = a1 + 1;
  v7 = (uint64_t)(a1 + 1);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *(_DWORD *)(v5 + 32);
        if (v8 < 1)
          break;
        v5 = *(_QWORD *)v7;
        v6 = (uint64_t **)v7;
        if (!*(_QWORD *)v7)
          goto LABEL_8;
      }
      if ((v8 & 0x80000000) == 0)
        break;
      v5 = *(_QWORD *)(v7 + 8);
      if (!v5)
      {
        v6 = (uint64_t **)(v7 + 8);
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v9 = operator new(0x38uLL);
    v14[1] = a1 + 1;
    v9[8] = 0;
    *((_QWORD *)v9 + 5) = 0;
    *((_QWORD *)v9 + 6) = 0;
    v15 = 1;
    sub_1D3D7F928(a1, v7, v6, (uint64_t *)v9);
    v14[0] = 0;
    sub_1D3DB570C((uint64_t)v14);
    v7 = (uint64_t)v9;
  }
  v10 = *(std::__shared_weak_count **)(v7 + 48);
  *(_OWORD *)(v7 + 40) = v13;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_1D3DB56F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1D3D96F10((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1D3DB570C(uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1D3D96F10((uint64_t)v1 + 40);
    operator delete(v1);
  }
}

void sub_1D3DB5754()
{
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DB5768(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

std::wstring *sub_1D3DB5770@<X0>(uint64_t a1@<X0>, std::wstring *a2@<X8>)
{
  return std::to_wstring(a2, *(_DWORD *)(a1 + 8));
}

void sub_1D3DB5778(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E95B02E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1D3DB5788(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E95B02E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DB57B8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1D3DB57C8(_BYTE *__dst, void *__src, unint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  v5 = __dst;
  if (a3 > 4)
  {
    if (a3 >= 0x3FFFFFFFFFFFFFF8)
      sub_1D3D7FD48();
    v6 = (a3 & 0xFFFFFFFFFFFFFFFELL) + 2;
    if ((a3 | 1) != 5)
      v6 = a3 | 1;
    v7 = sub_1D3D82278(v6 + 1);
    v5[1] = a3;
    v5[2] = v8 | 0x8000000000000000;
    *v5 = v7;
    v5 = v7;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, 4 * a3 + 4);
}

_QWORD *sub_1D3DB5850(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E95AF538;
  v2 = a1[3];
  if (v2)
    MEMORY[0x1D8254C3C](v2, 0x1000C8077774924);
  return a1;
}

void sub_1D3DB5898(_QWORD *a1)
{
  uint64_t v1;

  *a1 = &off_1E95AF538;
  v1 = a1[3];
  if (v1)
    MEMORY[0x1D8254C3C](v1, 0x1000C8077774924);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DB58F0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_1D3DB58F8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t sub_1D3DB5900(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t sub_1D3DB5908(uint64_t a1, int a2, uint64_t a3)
{
  int v6;
  int v7;
  uint64_t v8;
  _BYTE *v9;
  _QWORD *exception;
  char *v12;
  _QWORD v13[2];
  char v14;
  uint64_t v15;
  uint64_t v16;

  if (a2 < 0 || (*(int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) <= a2)
  {
    sub_1D3D93A78((uint64_t)&v15);
    sub_1D3D8C900(&v15, (uint64_t)"Requested row is outside the image: ", 36);
    std::ostream::operator<<();
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3D93B64(v13, (uint64_t)&v16);
    if (v14 >= 0)
      v12 = (char *)v13;
    else
      v12 = (char *)v13[0];
    sub_1D3DDE1A0(exception, v12);
    *exception = &off_1E95AF510;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (!a3)
    a3 = operator new[]();
  if (v6 >= 1)
  {
    v7 = *(_DWORD *)(a1 + 32) - (*(_DWORD *)(a1 + 44) + a2) + *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 40);
    v8 = v6;
    v9 = (_BYTE *)a3;
    do
    {
      *v9++ = *(_BYTE *)(*(_QWORD *)(a1 + 16) + v7);
      v7 += *(_DWORD *)(a1 + 32);
      --v8;
    }
    while (v8);
  }
  return a3;
}

void sub_1D3DB5A64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  void *v12;
  void *v13;
  int v14;
  int v15;

  if (v14 < 0)
  {
    operator delete(v13);
    if ((v15 & 1) == 0)
    {
LABEL_6:
      sub_1D3D93C38((uint64_t)&a12);
      _Unwind_Resume(a1);
    }
  }
  else if (!v15)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v12);
  goto LABEL_6;
}

uint64_t sub_1D3DB5AA8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
  {
    v2 = operator new[]();
    *(_QWORD *)(a1 + 24) = v2;
  }
  if (*(int *)(a1 + 52) >= 1)
  {
    v3 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v3, v2 + *(int *)(a1 + 48) * (uint64_t)(int)v3);
      v3 = (v3 + 1);
    }
    while ((int)v3 < *(_DWORD *)(a1 + 52));
  }
  return v2;
}

uint64_t sub_1D3DB5B38()
{
  return 0;
}

unsigned int **sub_1D3DB5B40(uint64_t *a1, unsigned int *a2, int a3, unsigned int **a4, int a5)
{
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v11;
  unsigned int *v12;

  if (a2)
  {
    v5 = a2 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v12 = a2;
  v7 = *a4;
  if (*a4)
  {
    v8 = v7 + 2;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v11 = v7;
  sub_1D3DB5BDC(a1, &v12, a3, a3, &v11, a5);
  sub_1D3DB45E8(&v11);
  return sub_1D3D6D10C(&v12);
}

void sub_1D3DB5BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, unsigned int *a10)
{
  sub_1D3DB45E8(&a9);
  sub_1D3D6D10C(&a10);
  _Unwind_Resume(a1);
}

void sub_1D3DB5BDC(uint64_t *a1, unsigned int **a2, int a3, int a4, _QWORD *a5, int a6)
{
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  float *v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  float v32;
  BOOL v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int *v37;
  char *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *exception;
  char *v42;
  int v43;
  _QWORD __dst[2];
  char v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int *v49;
  char *v50;
  _BYTE *v51;

  v11 = operator new();
  sub_1D3D938C4(v11, a3, a4);
  v12 = (unsigned int *)(v11 + 8);
  do
    v13 = __ldxr(v12);
  while (__stxr(v13 + 1, v12));
  *a1 = v11;
  LODWORD(v47) = 0;
  sub_1D3D8CDDC(&v50, 2 * a3, &v47);
  v43 = a4;
  if (a4 >= 1)
  {
    v14 = 0;
    do
    {
      v15 = v50;
      v16 = v51 - v50;
      v17 = (v51 - v50) >> 2;
      if (v51 - v50 >= 1)
      {
        v18 = 0;
        v19 = 0;
        do
        {
          v20 = (float *)&v15[4 * v19];
          *v20 = (float)v18 + 0.5;
          v20[1] = (float)(int)v14 + 0.5;
          v19 += 2;
          ++v18;
        }
        while (v17 > v19);
      }
      (*(void (**)(_QWORD, char **))(*(_QWORD *)*a5 + 16))(*a5, &v50);
      v21 = *a2;
      if (*a2)
      {
        v22 = v21 + 2;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v49 = v21;
      if (v51 != v50)
      {
        v24 = 0;
        v25 = *((_QWORD *)v21 + 7);
        v26 = -v25;
        v27 = *((_QWORD *)v21 + 2);
        v28 = v27 & -v25;
        v29 = v25 - 1;
        v30 = *((_QWORD *)v21 + 4);
        do
        {
          v31 = (float *)&v50[4 * v24];
          v32 = v31[1];
          v33 = *v31 >= 0.0 && *v31 < (float)(v27 & v29 | v30 & v26);
          if (!v33 || (v32 >= 0.0 ? (v34 = v32 < (float)(v30 & v29 | v28)) : (v34 = 0), !v34))
          {
            sub_1D3D6D10C(&v49);
            sub_1D3D93A78((uint64_t)&v47);
            sub_1D3D8C900(&v47, (uint64_t)"Transformed point out of bounds! original point at row: ", 56);
            v39 = (_QWORD *)std::ostream::operator<<();
            sub_1D3D8C900(v39, (uint64_t)", dimensionX=", 13);
            v40 = (_QWORD *)std::ostream::operator<<();
            sub_1D3D8C900(v40, (uint64_t)", dimensionY=", 13);
            std::ostream::operator<<();
            exception = __cxa_allocate_exception(0x20uLL);
            sub_1D3D93B64(__dst, (uint64_t)&v48);
            if (v46 >= 0)
              v42 = (char *)__dst;
            else
              v42 = (char *)__dst[0];
            sub_1D3DDE1A0(exception, v42);
            *exception = &off_1E95AF388;
            __cxa_throw(exception, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
          }
          v24 += 2;
        }
        while (v24 < (v51 - v50) >> 2);
      }
      sub_1D3D6D10C(&v49);
      if (v16 >= 1)
      {
        v35 = 0;
        v36 = 0;
        v37 = *a2;
        v38 = v50;
        do
        {
          if (sub_1D3D6D4A0(v37, (int)*(float *)&v38[4 * v36], (int)*(float *)&v38[4 * v36 + 4]) != a6)
            *(_DWORD *)(*(_QWORD *)(v11 + 48)
                      + (((unint64_t)(v35 + v14 * *(_QWORD *)(v11 + 24)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v35 + v14 * *(_QWORD *)(v11 + 24));
          v36 += 2;
          ++v35;
        }
        while (v17 > v36);
      }
      ++v14;
    }
    while (v14 != v43);
  }
  if (v50)
  {
    v51 = v50;
    operator delete(v50);
  }
}

void sub_1D3DB5F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int **a10)
{
  sub_1D3D6D10C(a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB5FCC()
{
  uint64_t result;

  result = operator new();
  qword_1EDB89E10 = result;
  return result;
}

void sub_1D3DB5FF8()
{
  unint64_t v0;
  uint64_t (**v1)();
  uint64_t (*v2)();

  v0 = atomic_load(qword_1EDB89DE8);
  if (v0 != -1)
  {
    v1 = &v2;
    v2 = sub_1D3DB5FCC;
    std::__call_once(qword_1EDB89DE8, &v1, (void (__cdecl *)(void *))sub_1D3DA51A8);
  }
}

uint64_t sub_1D3DB604C(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF358;
  sub_1D3D6D10C((unsigned int **)(a1 + 48));
  return sub_1D3DB5128(a1);
}

void sub_1D3DB607C(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF358;
  sub_1D3D6D10C((unsigned int **)(a1 + 48));
  sub_1D3DB5128(a1);
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3DB60C0@<X0>(unsigned int **result@<X0>, unsigned int **a2@<X8>)
{
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  unsigned int *v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  int *v58;
  uint64_t v59;
  int *v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t i;
  uint64_t v68;
  unint64_t v69;
  unsigned int v70;
  unsigned int *v71;
  unsigned int *v72;
  unsigned int v73;
  unsigned int **v74;
  int v75;
  int v76;
  int v77;
  uint64_t v78;
  unsigned int *v79;

  v3 = result[6];
  if (v3)
  {
    *a2 = 0;
LABEL_92:
    v72 = v3 + 2;
    do
      v73 = __ldxr(v72);
    while (__stxr(v73 + 1, v72));
    goto LABEL_94;
  }
  v4 = (uint64_t)result;
  v5 = result[2];
  if (v5)
  {
    v6 = v5 + 2;
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v79 = v5;
  sub_1D3D91AD4(&v79);
  if ((*(int (**)(unsigned int *))(*(_QWORD *)v5 + 16))(v5) >= *(_DWORD *)(v4 + 76)
    && (*(int (**)(unsigned int *))(*(_QWORD *)v5 + 24))(v5) >= *(_DWORD *)(v4 + 76))
  {
    v12 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v5 + 48))(v5);
    v13 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v5 + 16))(v5);
    v14 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v5 + 24))(v5);
    v75 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v5 + 32))(v5);
    v76 = v14;
    v15 = *(_DWORD *)(v4 + 56);
    v16 = v13 >> v15;
    v17 = *(_DWORD *)(v4 + 72);
    if ((v17 & v13) != 0)
      v18 = v16 + 1;
    else
      v18 = v16;
    v19 = v14 >> v15;
    if ((v17 & v14) != 0)
      v20 = v19 + 1;
    else
      v20 = v19;
    v21 = operator new[]();
    v78 = v20;
    if ((int)v20 >= 1)
    {
      v22 = 0;
      v23 = *(_DWORD *)(v4 + 56);
      v24 = *(unsigned int *)(v4 + 68);
      do
      {
        if ((int)v18 >= 1)
        {
          v25 = 0;
          v26 = (_DWORD)v22 << v23;
          if (((_DWORD)v22 << v23) + (int)v24 >= v76)
            v26 = v76 - v24;
          v27 = v26 * v75;
          do
          {
            if ((int)v24 < 1)
            {
              v31 = 0;
              v30 = 0;
              v34 = 255;
            }
            else
            {
              v29 = 0;
              v30 = 0;
              v31 = 0;
              v32 = (_DWORD)v25 << v23;
              if (((_DWORD)v25 << v23) + (int)v24 >= v13)
                v32 = v13 - v24;
              v33 = v32 + v27;
              v34 = 255;
              do
              {
                v35 = v12;
                v36 = v24;
                do
                {
                  v37 = *(unsigned __int8 *)(v35 + v33);
                  v31 += v37;
                  if (v34 >= v37)
                    v34 = *(unsigned __int8 *)(v35 + v33);
                  if (v30 <= v37)
                    v30 = *(unsigned __int8 *)(v35 + v33);
                  ++v35;
                  --v36;
                }
                while (v36);
                ++v29;
                v33 += v75;
              }
              while (v29 != (_DWORD)v24);
            }
            if (v30 - v34 >= 25)
            {
              v38 = v31 >> (2 * v23);
            }
            else
            {
              v38 = v34 >> 1;
              if (v22)
              {
                if (v25)
                {
                  v28 = v22 * v18 - 1;
                  if (v34 < (*(_DWORD *)(v21 + 4 * (v25 + (v22 - 1) * (int)v18))
                            + 2 * *(_DWORD *)(v21 + 4 * (v28 + (int)v25))
                            + *(_DWORD *)(v21 + 4 * (v25 + (v22 - 1) * (int)v18) - 4)) >> 2)
                    v38 = (*(_DWORD *)(v21 + 4 * (v25 + (v22 - 1) * (int)v18))
                         + 2 * *(_DWORD *)(v21 + 4 * (v28 + (int)v25))
                         + *(_DWORD *)(v21 + 4 * (v25 + (v22 - 1) * (int)v18) - 4)) >> 2;
                }
              }
            }
            *(_DWORD *)(v21 + 4 * (v25 + v22 * (int)v18)) = v38;
            ++v25;
          }
          while (v25 != v18);
        }
        ++v22;
      }
      while (v22 != v78);
    }
    v39 = operator new();
    sub_1D3D938C4(v39, v13, v76);
    v74 = a2;
    v40 = (unsigned int *)(v39 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    v79 = (unsigned int *)v39;
    if ((int)v78 > 0)
    {
      v42 = 0;
      v43 = *(_DWORD *)(v4 + 60);
      v44 = v43 - 1;
      v45 = 1 - v43;
      v46 = 4 * (int)v18;
      v47 = *(_DWORD *)(v4 + 68);
      do
      {
        if (v42 <= v44)
          v48 = v44;
        else
          v48 = v42;
        if ((int)v78 - v43 < v48)
          v48 = (int)v78 - v43;
        v77 = v42;
        if ((int)v18 >= 1)
        {
          v49 = 0;
          v50 = v46 * (v45 + v48);
          if ((v42 << *(_DWORD *)(v4 + 56)) + v47 >= v76)
            v51 = v76 - v47;
          else
            v51 = v42 << *(_DWORD *)(v4 + 56);
          v52 = v75 * v51;
          v53 = v51;
          v54 = v21 + v50;
          do
          {
            if (v49 <= v44)
              v55 = v44;
            else
              v55 = v49;
            if ((int)v18 - v43 < v55)
              v55 = (int)v18 - v43;
            if ((v49 << *(_DWORD *)(v4 + 56)) + v47 >= v13)
              v56 = v13 - v47;
            else
              v56 = v49 << *(_DWORD *)(v4 + 56);
            if ((int)v45 >= v43)
            {
              v57 = 0;
            }
            else
            {
              v57 = 0;
              v58 = (int *)(v54 + 4 * (v45 + v55));
              v59 = 1 - v43;
              do
              {
                v60 = v58;
                v61 = 2 * v43 - 1;
                do
                {
                  v62 = *v60++;
                  v57 += v62;
                  --v61;
                }
                while (v61);
                ++v59;
                v58 = (int *)((char *)v58 + v46);
              }
              while (v43 != (_DWORD)v59);
            }
            if (v47 >= 1)
            {
              v63 = 0;
              v64 = v12 + v52 + v56;
              v65 = v53;
              v66 = v57 / (((2 * v44) | 1) * ((2 * v44) | 1));
              do
              {
                if (v47 >= 1)
                {
                  for (i = 0; i < v47; ++i)
                  {
                    if (v66 >= *(unsigned __int8 *)(v64 + i))
                    {
                      v68 = *(_QWORD *)(v39 + 24);
                      v69 = ((unint64_t)(v56 + i + v65 * v68) >> 3) & 0x1FFFFFFFFFFFFFFCLL;
                      *(_DWORD *)(*(_QWORD *)(v39 + 48) + v69) |= 1 << (v56 + i + v65 * v68);
                      v47 = *(_DWORD *)(v4 + 68);
                    }
                  }
                }
                ++v63;
                ++v65;
                v64 += v75;
              }
              while (v63 < v47);
            }
            ++v49;
          }
          while (v49 != (_DWORD)v18);
        }
        ++v42;
        v40 = (unsigned int *)(v39 + 8);
      }
      while (v77 + 1 != (_DWORD)v78);
    }
    do
      v70 = __ldxr(v40);
    while (__stxr(v70 + 1, v40));
    v71 = *(unsigned int **)(v4 + 48);
    if (v71)
      sub_1D3D6D13C(v71);
    *(_QWORD *)(v4 + 48) = v39;
    MEMORY[0x1D8254C3C](v21, 0x1000C8052888210);
    result = sub_1D3D6D10C(&v79);
    a2 = v74;
  }
  else
  {
    sub_1D3DB4B44(v4, (uint64_t *)&v79);
    v8 = v79;
    if (v79)
    {
      v9 = v79 + 2;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = *(unsigned int **)(v4 + 48);
    if (v11)
      sub_1D3D6D13C(v11);
    *(_QWORD *)(v4 + 48) = v8;
    result = sub_1D3D6D10C(&v79);
  }
  *a2 = 0;
  v3 = *(unsigned int **)(v4 + 48);
  if (v3)
    goto LABEL_92;
LABEL_94:
  *a2 = v3;
  return result;
}

void sub_1D3DB6638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  sub_1D3D6D10C((unsigned int **)va);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DB6670@<X0>(unsigned int **a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v12;

  v4 = operator new();
  v5 = v4;
  v6 = *a1;
  if (*a1)
  {
    v7 = v6 + 2;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v12 = v6;
  sub_1D3DB6730(v4, v6);
  v9 = (unsigned int *)(v5 + 8);
  do
    v10 = __ldxr(v9);
  while (__stxr(v10 + 1, v9));
  *a2 = v5;
  return sub_1D3D91AD4(&v12);
}

void sub_1D3DB6704(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  MEMORY[0x1D8254C54](v2, 0x10A1C406BBA158DLL);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB6730(uint64_t a1, unsigned int *a2)
{
  unsigned int *v3;
  unsigned int v4;
  unsigned int *v6;

  if (a2)
  {
    v3 = a2 + 2;
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v6 = a2;
  sub_1D3DB505C(a1, a2);
  sub_1D3D91AD4(&v6);
  *(_QWORD *)a1 = &off_1E95AF358;
  *(_QWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 56) = xmmword_1D3E82030;
  *(_QWORD *)(a1 + 72) = 0x1800000007;
  return a1;
}

void sub_1D3DB67AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  _Unwind_Resume(a1);
}

void sub_1D3DB67C0(std::string *a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  std::string *v13;
  std::string::size_type size;
  int v15;
  uint64_t v16;
  int v17;
  std::string *v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  std::string *v25;
  uint64_t v26;
  int v27;
  int v28;
  const char *v29;
  const char *v30;
  std::string v31;
  std::string *v32;
  std::string v33;
  std::string *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = a2[1] - *a2;
  if (v3 <= 1)
    goto LABEL_79;
  v6 = (unsigned __int8 *)(v2 + 1);
  if (*(_BYTE *)(v2 + 1))
  {
    if ((int)v3 > 47)
    {
      memset(&v33, 0, sizeof(v33));
      std::string::append(&v33, "01", 2uLL);
      if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v7 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
      else
        v7 = v33.__r_.__value_.__r.__words[1];
      v8 = *((_DWORD *)a2 + 2) - *a2;
      if (v8 >= 8)
        v8 = 8;
      if (v8 < 5)
      {
        v9 = 0;
      }
      else
      {
        v9 = 0;
        v10 = (unsigned __int8 *)(*a2 + 4);
        v11 = v8 - 4;
        do
        {
          v12 = *v10++;
          v9 = (v12 != 0) | (2 * v9);
          --v11;
        }
        while (v11);
      }
      std::to_string(&v31, v9);
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = &v31;
      else
        v13 = (std::string *)v31.__r_.__value_.__r.__words[0];
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
      else
        size = v31.__r_.__value_.__l.__size_;
      std::string::append(&v33, (const std::string::value_type *)v13, size);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
      sub_1D3DB6E18(&v33, a2, 8u, v7);
      v15 = sub_1D3DC24A0(a2, 48, &v33);
      goto LABEL_28;
    }
    goto LABEL_16;
  }
  if (v3 <= 2)
LABEL_79:
    sub_1D3DB6E04();
  if (!*(_BYTE *)(v2 + 2))
  {
    memset(&v33, 0, sizeof(v33));
    v15 = sub_1D3DC24A0(a2, 5, &v33);
LABEL_28:
    if (v15)
    {
      a1->__r_.__value_.__r.__words[0] = 0;
      a1->__r_.__value_.__l.__size_ = 0;
      a1->__r_.__value_.__r.__words[2] = 0;
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
    }
    else
    {
      *a1 = v33;
    }
    return;
  }
  if ((int)v3 < 5)
  {
LABEL_16:
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    return;
  }
  v16 = 0;
  v17 = 0;
  do
    v17 = (v6[v16++] != 0) | (2 * v17);
  while ((_DWORD)v16 != 4);
  if (v17 == 5)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if ((_DWORD)v3 != 60)
      return;
    sub_1D3DB700C((uint64_t)a1, a2, 5u);
    v34 = &v33;
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E95AD8E8;
    v32 = &v31;
    v33.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E95AD890;
    sub_1D3DB7078(a1, *a2, a2[1], 0x2Du, 15, (uint64_t)&v33, (uint64_t)&v31);
LABEL_41:
    v18 = v32;
    if (v32 == &v31)
    {
      v19 = 4;
      v18 = &v31;
    }
    else
    {
      if (!v32)
        goto LABEL_55;
      v19 = 5;
    }
    (*(void (**)(void))(v18->__r_.__value_.__r.__words[0] + 8 * v19))();
LABEL_55:
    v25 = v34;
    if (v34 == &v33)
    {
      v26 = 4;
      v25 = &v33;
    }
    else
    {
      if (!v34)
        return;
      v26 = 5;
    }
    (*(void (**)(void))(v25->__r_.__value_.__r.__words[0] + 8 * v26))();
    return;
  }
  if (v17 == 4)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if ((_DWORD)v3 != 60)
      return;
    sub_1D3DB700C((uint64_t)a1, a2, 5u);
    v34 = &v33;
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E95AFE88;
    v32 = &v31;
    v33.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E95AFE30;
    sub_1D3DB7078(a1, *a2, a2[1], 0x2Du, 15, (uint64_t)&v33, (uint64_t)&v31);
    goto LABEL_41;
  }
  if ((int)v3 <= 5)
    goto LABEL_16;
  v20 = 0;
  v21 = v3 - 1;
  if ((int)v3 - 1 >= 5)
    v22 = 5;
  else
    v22 = v3 - 1;
  v23 = v6;
  do
  {
    v24 = *v23++;
    v20 = (v24 != 0) | (2 * v20);
    --v22;
  }
  while (v22);
  if (v20 == 13)
  {
    sub_1D3DB7350(a1, (uint64_t)a2);
    return;
  }
  if (v20 == 12)
  {
    sub_1D3DB71D0(a1, (uint64_t)a2);
    return;
  }
  if ((int)v3 <= 7)
    goto LABEL_16;
  v27 = 0;
  if (v21 >= 7)
    v21 = 7;
  do
  {
    v28 = *v6++;
    v27 = (v28 != 0) | (2 * v27);
    --v21;
  }
  while (v21);
  switch(v27)
  {
    case '8':
      v29 = "310";
      goto LABEL_68;
    case '9':
      v29 = "320";
LABEL_68:
      v30 = "11";
      goto LABEL_78;
    case ':':
      v29 = "310";
      goto LABEL_71;
    case ';':
      v29 = "320";
LABEL_71:
      v30 = "13";
      goto LABEL_78;
    case '<':
      v29 = "310";
      goto LABEL_74;
    case '=':
      v29 = "320";
LABEL_74:
      v30 = "15";
      goto LABEL_78;
    case '>':
      v29 = "310";
      goto LABEL_77;
    case '?':
      v29 = "320";
LABEL_77:
      v30 = "17";
LABEL_78:
      sub_1D3DB7598(a1, (uint64_t)a2, (std::string::size_type)v29, v30);
      break;
    default:
      goto LABEL_16;
  }
}

void sub_1D3DB6D44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void **a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t *a23)
{
  uint64_t v23;
  void **v24;
  void **p_p;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;

  p_p = a16;
  if (a16 == v24)
  {
    v27 = 4;
    p_p = &__p;
  }
  else
  {
    if (!a16)
      goto LABEL_6;
    v27 = 5;
  }
  (*((void (**)(void))*p_p + v27))();
LABEL_6:
  v28 = a23;
  if (a23 == &a17)
  {
    v29 = 4;
    v28 = &a17;
  }
  else
  {
    if (!a23)
      goto LABEL_11;
    v29 = 5;
  }
  (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_11:
  if (*(char *)(v23 + 23) < 0)
    operator delete(*(void **)v23);
  _Unwind_Resume(exception_object);
}

void sub_1D3DB6E04()
{
  sub_1D3D93CBC("vector");
}

void sub_1D3DB6E18(std::string *this, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  std::string *v17;
  std::string::size_type size;
  uint64_t v19;
  int v20;
  std::string *v21;
  char *v22;
  int v23;
  int v24;
  int v25;
  std::string *v26;
  std::string::size_type v27;
  std::string v28;

  v7 = 0;
  v8 = -a3;
  v9 = a3;
  do
  {
    v10 = v9 + 10 * v7;
    v11 = *a2;
    v12 = a2[1];
    if ((int)(v12 - *a2 - v10) < 1)
    {
      v13 = 0;
LABEL_9:
      std::string::push_back(this, 48);
      goto LABEL_10;
    }
    v13 = 0;
    v14 = (unsigned __int8 *)(v11 + v10);
    v15 = v8 + v12 - v11;
    if (v15 >= 10)
      v15 = 10;
    do
    {
      v16 = *v14++;
      v13 = (v16 != 0) | (2 * v13);
      --v15;
    }
    while (v15);
    if ((v13 + 99) <= 0xC6)
      goto LABEL_9;
LABEL_10:
    if ((v13 + 9) <= 0x12)
      std::string::push_back(this, 48);
    std::to_string(&v28, v13);
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v17 = &v28;
    else
      v17 = (std::string *)v28.__r_.__value_.__r.__words[0];
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
    else
      size = v28.__r_.__value_.__l.__size_;
    std::string::append(this, (const std::string::value_type *)v17, size);
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v28.__r_.__value_.__l.__data_);
    ++v7;
    v8 -= 10;
  }
  while (v7 != 4);
  v19 = 0;
  v20 = 0;
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = this;
  else
    v21 = (std::string *)this->__r_.__value_.__r.__words[0];
  v22 = (char *)v21 + a4;
  do
  {
    v23 = v22[v19] - 48;
    if ((v19 & 1) == 0)
      v23 *= 3;
    v20 += v23;
    ++v19;
  }
  while (v19 != 13);
  v24 = v20 % 10;
  if (v24)
    v25 = 10 - v24;
  else
    v25 = 0;
  std::to_string(&v28, v25);
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v26 = &v28;
  else
    v26 = (std::string *)v28.__r_.__value_.__r.__words[0];
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v27 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  else
    v27 = v28.__r_.__value_.__l.__size_;
  std::string::append(this, (const std::string::value_type *)v26, v27);
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v28.__r_.__value_.__l.__data_);
}

void sub_1D3DB6FEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1D3DB700C(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  int v6;

  std::string::append((std::string *)a1, "01", 2uLL);
  if (*(char *)(a1 + 23) >= 0)
    v6 = *(unsigned __int8 *)(a1 + 23);
  else
    v6 = *(_DWORD *)(a1 + 8);
  std::string::push_back((std::string *)a1, 57);
  sub_1D3DB6E18((std::string *)a1, a2, a3, v6);
}

void sub_1D3DB7078(std::string *a1, uint64_t a2, int a3, unsigned int a4, int a5, uint64_t a6, uint64_t a7)
{
  int v9;
  int v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  std::string *v17;
  std::string::size_type size;
  std::string v19;

  v9 = a3 - a2 - a4;
  if (v9 >= a5)
    v9 = a5;
  if (v9 < 1)
  {
    v10 = 0;
  }
  else
  {
    v10 = 0;
    v11 = (unsigned __int8 *)(a2 + a4);
    do
    {
      v12 = *v11++;
      v10 = (v12 != 0) | (2 * v10);
      --v9;
    }
    while (v9);
  }
  LODWORD(v19.__r_.__value_.__l.__data_) = v10;
  if (!a6
    || ((*(void (**)(uint64_t, std::string *, std::string *))(*(_QWORD *)a6 + 48))(a6, a1, &v19),
        LODWORD(v19.__r_.__value_.__l.__data_) = v10,
        (v13 = *(_QWORD *)(a7 + 24)) == 0))
  {
    sub_1D3D75A24();
  }
  v14 = (*(uint64_t (**)(uint64_t, std::string *))(*(_QWORD *)v13 + 48))(v13, &v19);
  v15 = 100000;
  v16 = 5;
  do
  {
    if (!(v14 / v15))
      std::string::push_back(a1, 48);
    v15 /= 10;
    --v16;
  }
  while (v16);
  std::to_string(&v19, v14);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &v19;
  else
    v17 = (std::string *)v19.__r_.__value_.__r.__words[0];
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v19.__r_.__value_.__r.__words[2]);
  else
    size = v19.__r_.__value_.__l.__size_;
  std::string::append(a1, (const std::string::value_type *)v17, size);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
}

void sub_1D3DB71B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1D3DB71D0(std::string *a1, uint64_t a2)
{
  int v4;
  int v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  std::string *p_p;
  std::string::size_type size;
  double result;
  std::string __p;
  std::string v13;

  if (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2 > 49)
  {
    memset(&v13, 0, sizeof(v13));
    sub_1D3DB700C((uint64_t)&v13, (uint64_t *)a2, 8u);
    v4 = *(_DWORD *)(a2 + 8) - *(_QWORD *)a2;
    if (v4 >= 50)
      v4 = 50;
    if (v4 < 49)
    {
      v5 = 0;
    }
    else
    {
      v5 = 0;
      v6 = (unsigned __int8 *)(*(_QWORD *)a2 + 48);
      v7 = v4 - 48;
      do
      {
        v8 = *v6++;
        v5 = (v8 != 0) | (2 * v5);
        --v7;
      }
      while (v7);
    }
    std::string::append(&v13, "392", 3uLL);
    std::to_string(&__p, v5);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    std::string::append(&v13, (const std::string::value_type *)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (sub_1D3DC18F0((uint64_t *)a2, 50, &v13))
    {
      a1->__r_.__value_.__r.__words[0] = 0;
      a1->__r_.__value_.__l.__size_ = 0;
      a1->__r_.__value_.__r.__words[2] = 0;
      if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v13.__r_.__value_.__l.__data_);
    }
    else
    {
      result = *(double *)&v13.__r_.__value_.__l.__data_;
      *a1 = v13;
    }
  }
  else
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
  }
  return result;
}

void sub_1D3DB7314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

double sub_1D3DB7350(std::string *a1, uint64_t a2)
{
  int v4;
  int v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  std::string *p_p;
  std::string::size_type size;
  int v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  std::string *v16;
  std::string::size_type v17;
  double result;
  std::string __p;
  std::string v20;

  if (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2 <= 59)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    return result;
  }
  memset(&v20, 0, sizeof(v20));
  sub_1D3DB700C((uint64_t)&v20, (uint64_t *)a2, 8u);
  v4 = *(_DWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v4 >= 50)
    v4 = 50;
  if (v4 < 49)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = (unsigned __int8 *)(*(_QWORD *)a2 + 48);
    v7 = v4 - 48;
    do
    {
      v8 = *v6++;
      v5 = (v8 != 0) | (2 * v5);
      --v7;
    }
    while (v7);
  }
  std::string::append(&v20, "393", 3uLL);
  std::to_string(&__p, v5);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  std::string::append(&v20, (const std::string::value_type *)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v11 = *(_DWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v11 >= 60)
    v11 = 60;
  if (v11 < 51)
  {
    v12 = 0;
  }
  else
  {
    v12 = 0;
    v13 = (unsigned __int8 *)(*(_QWORD *)a2 + 50);
    v14 = v11 - 50;
    do
    {
      v15 = *v13++;
      v12 = (v15 != 0) | (2 * v12);
      --v14;
    }
    while (v14);
    if ((v12 + 99) > 0xC6)
      goto LABEL_27;
  }
  std::string::push_back(&v20, 48);
LABEL_27:
  if ((v12 + 9) <= 0x12)
    std::string::push_back(&v20, 48);
  std::to_string(&__p, v12);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = &__p;
  else
    v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v17 = __p.__r_.__value_.__l.__size_;
  std::string::append(&v20, (const std::string::value_type *)v16, v17);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (sub_1D3DC18F0((uint64_t *)a2, 60, &v20))
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v20.__r_.__value_.__l.__data_);
  }
  else
  {
    result = *(double *)&v20.__r_.__value_.__l.__data_;
    *a1 = v20;
  }
  return result;
}

void sub_1D3DB7550(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_1D3DB7598(std::string *a1, uint64_t a2, std::string::size_type a3, const char *a4)
{
  int v4;
  _QWORD *v9;
  uint64_t v10;
  std::string *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  std::string::size_type v19;
  int v20;
  std::string *v21;
  std::string::size_type size;
  int v23;
  std::string *v24;
  std::string::size_type v25;
  int v26;
  std::string *v27;
  std::string::size_type v28;
  _QWORD v29[3];
  _QWORD *v30;
  std::string v31;
  std::string *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  if (v4 != 84)
    return;
  sub_1D3DB700C((uint64_t)a1, (uint64_t *)a2, 8u);
  v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E95AD940;
  v31.__r_.__value_.__l.__size_ = a3;
  v32 = &v31;
  v29[0] = &off_1E95AD998;
  v30 = v29;
  sub_1D3DB7078(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8), 0x30u, 20, (uint64_t)&v31, (uint64_t)v29);
  v9 = v30;
  if (v30 == v29)
  {
    v10 = 4;
    v9 = v29;
  }
  else
  {
    if (!v30)
      goto LABEL_7;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  v11 = v32;
  if (v32 == &v31)
  {
    v12 = 4;
    v11 = &v31;
    goto LABEL_11;
  }
  if (v32)
  {
    v12 = 5;
LABEL_11:
    (*(void (**)(void))(v11->__r_.__value_.__r.__words[0] + 8 * v12))();
  }
  v13 = *(_QWORD *)a2;
  v14 = *(_DWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v14 >= 84)
    v14 = 84;
  if (v14 < 69)
  {
    v15 = 0;
  }
  else
  {
    v15 = 0;
    v16 = (unsigned __int8 *)(v13 + 68);
    v17 = v14 - 68;
    do
    {
      v18 = *v16++;
      v15 = (v18 != 0) | (2 * v15);
      --v17;
    }
    while (v17);
    if (v15 == 38400)
      return;
  }
  v19 = strlen(a4);
  std::string::append(a1, a4, v19);
  if (v15 >= 0)
    v20 = v15;
  else
    v20 = v15 + 31;
  if ((v15 + 3839) <= 0x1DFE)
    std::string::push_back(a1, 48);
  std::to_string(&v31, v15 / 384);
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = &v31;
  else
    v21 = (std::string *)v31.__r_.__value_.__r.__words[0];
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
  else
    size = v31.__r_.__value_.__l.__size_;
  std::string::append(a1, (const std::string::value_type *)v21, size);
  v23 = (v20 >> 5) % 12;
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  if ((v23 + 10) <= 0x12)
    std::string::push_back(a1, 48);
  std::to_string(&v31, v23 + 1);
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v24 = &v31;
  else
    v24 = (std::string *)v31.__r_.__value_.__r.__words[0];
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v25 = HIBYTE(v31.__r_.__value_.__r.__words[2]);
  else
    v25 = v31.__r_.__value_.__l.__size_;
  std::string::append(a1, (const std::string::value_type *)v24, v25);
  v26 = v15 - (v20 & 0xFFFFFFE0);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  if ((v26 + 9) <= 0x12)
    std::string::push_back(a1, 48);
  std::to_string(&v31, v26);
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v27 = &v31;
  else
    v27 = (std::string *)v31.__r_.__value_.__r.__words[0];
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v28 = HIBYTE(v31.__r_.__value_.__r.__words[2]);
  else
    v28 = v31.__r_.__value_.__l.__size_;
  std::string::append(a1, (const std::string::value_type *)v27, v28);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
}

void sub_1D3DB7888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  uint64_t v20;

  if (a19 < 0)
    operator delete(__p);
  if (*(char *)(v20 + 23) < 0)
    operator delete(*(void **)v20);
  _Unwind_Resume(exception_object);
}

void sub_1D3DB7940()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB7954()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AD998;
  return result;
}

void sub_1D3DB7978(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AD998;
}

uint64_t sub_1D3DB7990(uint64_t a1, _DWORD *a2)
{
  return (*a2 % 100000);
}

uint64_t sub_1D3DB79BC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL16DecodeAI013x0x1xERKNS0_8BitArrayEPKcS7_E3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB79F4()
{
  return &unk_1E95AD028;
}

void sub_1D3DB7A04()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB7A18(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AD940;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DB7A4C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AD940;
  a2[1] = v2;
  return result;
}

void sub_1D3DB7A68(uint64_t a1, std::string *a2, int *a3)
{
  int v4;
  const char *v5;
  std::string::size_type v6;
  std::string *v7;
  std::string::size_type size;
  std::string v9;

  v4 = *a3;
  v5 = *(const char **)(a1 + 8);
  v6 = strlen(v5);
  std::string::append(a2, v5, v6);
  std::to_string(&v9, v4 / 100000);
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v7 = &v9;
  else
    v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  else
    size = v9.__r_.__value_.__l.__size_;
  std::string::append(a2, (const std::string::value_type *)v7, size);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
}

void sub_1D3DB7B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DB7B24(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL16DecodeAI013x0x1xERKNS0_8BitArrayEPKcS7_E3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DB7B5C()
{
  return &unk_1E95AD018;
}

void sub_1D3DB7B6C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB7B80()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AD8E8;
  return result;
}

void sub_1D3DB7BA4(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AD8E8;
}

uint64_t sub_1D3DB7BBC(uint64_t a1, unsigned int *a2)
{
  if ((int)*a2 >= 10000)
    return *a2 - 10000;
  else
    return *a2;
}

uint64_t sub_1D3DB7BD8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI01320xERKNS0_8BitArrayEE3$_1"))
    return a1 + 8;
  else
    return 0;
}

void *sub_1D3DB7C10()
{
  return &unk_1E95AD008;
}

void sub_1D3DB7C20()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB7C34()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AD890;
  return result;
}

void sub_1D3DB7C58(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AD890;
}

std::string *sub_1D3DB7C70(int a1, std::string *this, int *a3)
{
  const std::string::value_type *v4;

  if (*a3 >= 10000)
    v4 = "3203";
  else
    v4 = "3202";
  return std::string::append(this, v4, 4uLL);
}

uint64_t sub_1D3DB7C9C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI01320xERKNS0_8BitArrayEE3$_0"))
    return a1 + 8;
  else
    return 0;
}

void *sub_1D3DB7CD4()
{
  return &unk_1E95ACFF8;
}

void sub_1D3DB7CE4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB7CF8()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AFE88;
  return result;
}

void sub_1D3DB7D1C(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AFE88;
}

uint64_t sub_1D3DB7D34(uint64_t a1, unsigned int *a2)
{
  return *a2;
}

uint64_t sub_1D3DB7D3C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI013103ERKNS0_8BitArrayEE3$_1"))
    return a1 + 8;
  else
    return 0;
}

void *sub_1D3DB7D74()
{
  return &unk_1E95AEB70;
}

void sub_1D3DB7D84()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB7D98()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AFE30;
  return result;
}

void sub_1D3DB7DBC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AFE30;
}

std::string *sub_1D3DB7DD4(int a1, std::string *this)
{
  return std::string::append(this, "3103", 4uLL);
}

uint64_t sub_1D3DB7DE8(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI013103ERKNS0_8BitArrayEE3$_0"))
    return a1 + 8;
  else
    return 0;
}

void *sub_1D3DB7E20()
{
  return &unk_1E95AEB60;
}

void sub_1D3DB7E30()
{
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DB7E44(int a1@<W1>, uint64_t a2@<X2>, uint64_t a3@<X3>, int a4@<W4>, _QWORD **a5@<X5>, uint64_t a6@<X8>)
{
  _QWORD *v11;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  char *v16;
  char v17;
  BOOL v18;
  void *v19;
  char *v20;
  char *v22;
  char v23;
  int v24;
  uint64_t i;
  uint64_t j;
  int v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  int k;
  int v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  std::wstring *v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  std::wstring::size_type v48;
  char v49;
  uint64_t v50;
  float v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  void *v55;
  char *v56;
  uint64_t v57;
  void *v58;
  char *v59;
  uint64_t v60;
  std::wstring __dst;
  _QWORD v62[2];
  uint64_t (**v63)();
  _QWORD v64[10];
  char v65;
  uint64_t (**v66)();
  _QWORD v67[3];

  v67[2] = *MEMORY[0x1E0C80C00];
  v11 = *a5;
  if (!*a5)
  {
    v11 = (_QWORD *)operator new();
    *v11 = &off_1E95AF150;
    v11[1] = v11 + 1;
    v11[2] = v11 + 1;
    v11[3] = 0;
    v11[4] = v11 + 4;
    v11[5] = v11 + 4;
    v11[6] = 0;
    v13 = *a5;
    *a5 = v11;
    if (v13)
    {
      (*(void (**)(_QWORD *))(*v13 + 8))(v13);
      v11 = *a5;
    }
  }
  v58 = 0;
  v59 = 0;
  v60 = 0;
  sub_1D3DB8410(&v58, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  v55 = 0;
  v56 = 0;
  v57 = 0;
  sub_1D3DB8410(&v55, *(const void **)a3, *(_QWORD *)(a3 + 8), *(_QWORD *)(a3 + 8) - *(_QWORD *)a3);
  v14 = v11 + 1;
  sub_1D3DB8488((unint64_t)v62, (uint64_t *)&v58, (uint64_t)v55, 0, a1);
  sub_1D3DB8A80(v11 + 1, (uint64_t)v62);
  if (v58 != v59)
  {
    v15 = v59 - 1;
    if (v59 - 1 > v58)
    {
      v16 = (char *)v58 + 1;
      do
      {
        v17 = *(v16 - 1);
        *(v16 - 1) = *v15;
        *v15-- = v17;
        v18 = v16++ >= v15;
      }
      while (!v18);
    }
  }
  v19 = v55;
  v20 = v56 - 1;
  if (v55 != v56 && v20 > v55)
  {
    v22 = (char *)v55 + 1;
    do
    {
      v23 = *(v22 - 1);
      *(v22 - 1) = *v20;
      *v20-- = v23;
      v18 = v22++ >= v20;
    }
    while (!v18);
  }
  sub_1D3DB8488((unint64_t)v62, (uint64_t *)&v58, (uint64_t)v19, 1, a1);
  sub_1D3DB8A80(v11 + 4, (uint64_t)v62);
  if (a4)
    v24 = 1;
  else
    v24 = 2;
  for (i = v11[2]; (_QWORD *)i != v14; i = *(_QWORD *)(i + 8))
  {
    if (*(_DWORD *)(i + 72) >= v24)
    {
      for (j = v11[5]; (_QWORD *)j != v11 + 4; j = *(_QWORD *)(j + 8))
      {
        if (*(_DWORD *)(j + 72) >= v24)
        {
          v27 = 9 * *(_DWORD *)(i + 24) + *(_DWORD *)(j + 24);
          if ((*(_DWORD *)(i + 20) + 16 * *(_DWORD *)(j + 20)) % 79 == v27 - (v27 > 72) - (v27 - (v27 > 72) > 8))
          {
            v28 = *(_DWORD *)(i + 16);
            v29 = *(int *)(j + 16);
            sub_1D3D92968((uint64_t)v62);
            *(_QWORD *)((char *)&v64[2] + (_QWORD)*(v63 - 3)) = 13;
            sub_1D3D92A5C(&v63, 48);
            v30 = v29 + 4537077 * v28 - 10000000000000;
            std::wostream::operator<<();
            v31 = 0;
            for (k = 0; k != 13; ++k)
            {
              v33 = std::wistream::get() - 48;
              if ((k & 1) == 0)
                v33 *= 3;
              v31 += v33;
            }
            std::wostream::put();
            v35 = *(double *)(i + 48);
            v34 = *(double *)(i + 56);
            v37 = *(double *)(j + 48);
            v36 = *(double *)(j + 56);
            v38 = *(double *)(i + 40);
            v39 = *(double *)(j + 40);
            sub_1D3D92AFC(&__dst, (uint64_t)v64);
            v40 = std::wstring::insert(&__dst, 0, dword_1D3E6A040, 2uLL);
            v41 = v34;
            v42 = v38;
            v43 = (float)(v41 - v42) / 46.0;
            v44 = v39;
            v45 = v36;
            v46 = (float)(v44 - v45) / 46.0;
            v47 = v35;
            v48 = v40->__r_.__value_.__r.__words[0];
            v67[0] = v40->__r_.__value_.__l.__size_;
            *(_QWORD *)((char *)v67 + 7) = *(std::wstring::size_type *)((char *)&v40->__r_.__value_.__r.__words[1] + 7);
            v49 = HIBYTE(v40->__r_.__value_.__r.__words[2]);
            v40->__r_.__value_.__l.__size_ = 0;
            v40->__r_.__value_.__r.__words[2] = 0;
            v50 = (int)(float)(v42 - v43);
            v40->__r_.__value_.__r.__words[0] = 0;
            v51 = v37;
            *(_QWORD *)a6 = 0x100000000000;
            *(_QWORD *)(a6 + 23) = *(_QWORD *)((char *)v67 + 7);
            v52 = v67[0];
            *(_QWORD *)(a6 + 8) = v48;
            *(_QWORD *)(a6 + 16) = v52;
            *(_BYTE *)(a6 + 31) = v49;
            v53 = v50 | ((unint64_t)(int)v47 << 32);
            v54 = (int)(float)(v44 + (float)(v46 * 2.0)) | ((unint64_t)(int)v51 << 32);
            *(_QWORD *)(a6 + 32) = v53;
            *(_QWORD *)(a6 + 40) = v54;
            *(_QWORD *)(a6 + 48) = v54;
            *(_QWORD *)(a6 + 56) = v53;
            *(_QWORD *)(a6 + 112) = 0;
            *(_QWORD *)(a6 + 104) = 0;
            *(_QWORD *)(a6 + 72) = 0;
            *(_QWORD *)(a6 + 80) = 0;
            *(_QWORD *)(a6 + 64) = 0;
            *(_QWORD *)(a6 + 96) = a6 + 104;
            *(_BYTE *)(a6 + 120) = 0;
            *(_DWORD *)(a6 + 124) = 0;
            *(_DWORD *)(a6 + 128) = 0;
            *(_DWORD *)(a6 + 88) = 0;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__dst.__r_.__value_.__l.__data_);
            *(_BYTE *)(a6 + 120) = v30 < 0x9184E72A000;
            *(float *)(a6 + 124) = v43;
            *(float *)(a6 + 128) = v46;
            v62[0] = off_1E95B0270;
            v66 = off_1E95B02C0;
            v63 = off_1E95B0298;
            v64[0] = off_1E95B01C0;
            if (v65 < 0)
              operator delete((void *)v64[8]);
            std::wstreambuf::~wstreambuf();
            std::wostream::~wostream();
            std::wistream::~wistream();
            MEMORY[0x1D8254C00](&v66);
            goto LABEL_39;
          }
        }
      }
    }
  }
  *(_DWORD *)a6 = 1;
  *(_QWORD *)(a6 + 104) = 0;
  *(_QWORD *)(a6 + 112) = 0;
  *(_OWORD *)(a6 + 4) = 0u;
  *(_OWORD *)(a6 + 20) = 0u;
  *(_OWORD *)(a6 + 36) = 0u;
  *(_OWORD *)(a6 + 52) = 0u;
  *(_OWORD *)(a6 + 68) = 0u;
  *(_QWORD *)(a6 + 84) = 0;
  *(_QWORD *)(a6 + 96) = a6 + 104;
  *(_BYTE *)(a6 + 120) = 0;
  *(_DWORD *)(a6 + 124) = 0;
  *(_DWORD *)(a6 + 128) = 0;
LABEL_39:
  if (v55)
    operator delete(v55);
  if (v58)
    operator delete(v58);
}

void sub_1D3DB83A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0)
    operator delete(__p);
  sub_1D3D92CD0((uint64_t)&a22);
  if (a10)
    operator delete(a10);
  if (a13)
    operator delete(a13);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3DB8410(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = sub_1D3D81E74(result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1D3DB846C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1D3DB8488(unint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  unint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  BOOL v21;
  float v22;
  float v23;
  BOOL v25;
  float v26;
  BOOL v28;
  float v29;
  float v30;
  BOOL v32;
  float v33;
  BOOL v35;
  unsigned __int8 *v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  float v44;
  float v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  int v49;
  int v50;
  float v51;
  float v52;
  int v53;
  int v54;
  int v55;
  int v56;
  float v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  float v61;
  float v62;
  char *v63;
  int v64;
  float v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  float v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int8 *v73;
  unsigned int v74;
  float v75;
  double v76;
  float v77;
  float v78;
  int v79;
  int v80;
  unint64_t v81;
  int v82;
  int v83;
  __int128 v84;
  int v86;
  int v88;
  int32x4_t v89;
  int v90[5];
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;

  v6 = result;
  v94 = *MEMORY[0x1E0C80C00];
  v89 = 0uLL;
  v8 = *a2;
  v7 = (unsigned __int8 *)a2[1];
  v9 = v7 - *a2;
  v10 = v7;
  v11 = v7;
  if ((int)v9 >= 50)
  {
    v12 = (unsigned __int8 *)(v8 + 18);
    if (v7 != (unsigned __int8 *)(v8 + 18))
    {
      while (*v12 != (a4 ^ 1))
      {
        if (++v12 == v7)
        {
          v12 = (unsigned __int8 *)a2[1];
          break;
        }
      }
      if (v12 != v7)
      {
        v13 = 0;
        v10 = v12;
        v11 = v12;
        while (1)
        {
          if (*v11 == (*v12 == 0))
            goto LABEL_11;
          if (++v11 == v7)
          {
            v11 = v7;
LABEL_11:
            v89.i32[v13] = (_DWORD)v11 - (_DWORD)v12;
            if (v11 == v7)
              break;
            if (++v13 == 4)
            {
              v14 = (float)vaddvq_s32(v89);
              v15 = v14 / 14.0;
              v16 = v14 / 12.0;
              if (v15 >= 4.0)
                v17 = 0.0;
              else
                v17 = 0.5;
              v18 = v17 + (float)(v16 * 0.5);
              v19 = (float)(v89.i32[3] + v89.i32[2]);
              v20 = -(float)(v18 - (float)(v15 * 2.0));
              v21 = v20 > v19 || (float)(v18 + (float)(v16 * 2.0)) < v19;
              v22 = (float)v89.i32[0];
              v23 = v15 - v18;
              v25 = v21 || v23 > v22 || (float)(v18 + (float)(v16 * 8.0)) < v22;
              v26 = (float)v89.i32[1];
              v28 = v25 || v20 > v26 || (float)(v18 + (float)(v16 * 9.0)) < v26;
              v29 = v16 + v18;
              v30 = (float)v89.i32[2];
              v32 = v28 || v23 > v30 || v29 < v30;
              v33 = (float)v89.i32[3];
              v35 = v32 || v23 > v33 || v29 < v33;
              if (!v35 && (uint64_t)&v10[-v8] > v11 - v10 && v7 - v11 > v11 - v10)
                goto LABEL_51;
              v10 += v89.i32[1] + v89.i32[0];
              v89.i64[0] = v89.i64[1];
              v13 = 2;
            }
            v12 = v11;
          }
        }
      }
    }
    v10 = v7;
    v11 = v7;
  }
LABEL_51:
  if (v10 >= v11 || v8 == (_QWORD)v10)
    goto LABEL_102;
  v37 = v10;
  while (v37 != (unsigned __int8 *)v8)
  {
    v38 = *--v37;
    if (v38 == *v10)
    {
      v39 = a3;
      v40 = (_DWORD)v37 + 1;
      goto LABEL_60;
    }
  }
  v39 = a3;
  v40 = v8;
LABEL_60:
  v86 = v40;
  v41 = vaddvq_s32(v89) + (_DWORD)v10 - v40;
  v42 = (_DWORD)v11 - v8;
  bzero(&v91, 0x400uLL);
  if (v41 < 1)
  {
    v45 = 0.0;
    v44 = 0.0;
    result = v9;
  }
  else
  {
    v43 = -(uint64_t)v41;
    v44 = 0.0;
    v45 = 0.0;
    result = v9;
    do
    {
      v46 = *(unsigned __int8 *)(v39 + v42 + v43);
      v44 = v44 + (float)v46;
      v45 = v45 + (float)(v46 * v46);
      ++*((_DWORD *)&v91 + v46);
      v47 = __CFADD__(v43++, 1);
    }
    while (!v47);
  }
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v52 = (float)(v45 / (float)(v41 + 1)) - (float)((float)(v44 / (float)(v41 + 1)) * (float)(v44 / (float)(v41 + 1)));
  v53 = (int)((double)v41 * 0.3);
  while (1)
  {
    v54 = *((_DWORD *)&v91 + v48);
    if (v54 + v49 >= v53)
      break;
    v50 += v54 * v48++;
    v49 += v54;
    if (v48 == 255)
      goto LABEL_71;
  }
  v50 += (v53 - v49) * v48;
LABEL_71:
  v55 = 0;
  v56 = 0;
  v57 = (float)(v50 / v53);
  v58 = 255;
  while (1)
  {
    v59 = *((_DWORD *)&v91 + v58);
    if (v59 + v55 >= v53)
      break;
    v56 += v59 * v58;
    v55 += v59;
    v47 = v58-- != 0;
    if (v58 == 0 || !v47)
      goto LABEL_76;
  }
  v56 += (v53 - v55) * v58;
LABEL_76:
  v60 = 0;
  v61 = (float)(v56 / v53);
  v62 = 1.0 / (float)(v52 + v52);
  v63 = (char *)&unk_1D3E69F20;
  v64 = -1;
  v65 = -0.15;
  do
  {
    v66 = 0;
    v67 = 0;
    do
    {
      v67 += *(_DWORD *)&v63[v66 * 4];
      v51 = (double)v41 / 15.0;
      v90[v66++] = (int)((float)(v51 * (float)v67) + 0.5);
    }
    while (v66 != 5);
    v68 = 0;
    v69 = 0.0;
    do
    {
      if (v68)
        v70 = v90[(v68 - 1)];
      else
        v70 = 0;
      v71 = v90[v68];
      if (v70 < (int)v71)
      {
        v72 = v71 - v70;
        v73 = (unsigned __int8 *)(v39 + v42 - v41 + v70);
        do
        {
          v74 = *v73++;
          v75 = (float)v74;
          if (((v68 & 1) == 0) != a4)
            v76 = fmin((float)(v75 - v61), 0.0);
          else
            v76 = fmax((float)(v75 - v57), 0.0);
          v77 = v76;
          v69 = v69 + (float)(v62 * (float)(v77 * v77));
          --v72;
        }
        while (v72);
      }
      ++v68;
    }
    while (v68 != 5);
    v78 = (float)-v69 / (float)v41;
    if (v78 > v65)
    {
      v64 = v60;
      v65 = v78;
    }
    ++v60;
    v63 += 20;
  }
  while (v60 != 9);
  v79 = a4 ? result + ~(v86 - v8) : v86 - (int)v8;
  v80 = a4 ? result + ~v42 : v42;
  LODWORD(v91) = v64;
  DWORD1(v91) = v86 - v8;
  DWORD2(v91) = v42;
  *(double *)&v92 = (double)v79;
  *((double *)&v92 + 1) = (double)a5;
  *(double *)&v93 = (double)v80;
  *((double *)&v93 + 1) = (double)a5;
  if (v64 < 0
    || (v90[0] = 0, result = sub_1D3DB8B34(v8, v7, (uint64_t)&v91, 1, v90), v81 = result, (_DWORD)result == 0x7FFFFFFF)
    || (v88 = 0, result = sub_1D3DB8B34(*a2, (_BYTE *)a2[1], (uint64_t)&v91, 0, &v88), (_DWORD)result == 0x7FFFFFFF))
  {
LABEL_102:
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 48) = 0u;
    *(_OWORD *)v6 = xmmword_1D3E82040;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_DWORD *)(v6 + 16) = -1;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_DWORD *)(v6 + 56) = 0;
  }
  else
  {
    v82 = v90[0];
    v83 = v88;
    if (a4)
    {
      v83 = -v88;
      v82 = -v90[0];
    }
    *(double *)&v92 = (float)((float)v79 - (float)v82);
    *((double *)&v92 + 1) = (float)a5;
    *(double *)&v93 = (float)((float)v80 + (float)v83);
    *((double *)&v93 + 1) = *((double *)&v92 + 1);
    *(_DWORD *)v6 = result + 1597 * v81;
    *(_DWORD *)(v6 + 4) = ((result >> 30) & 0xFFFFFFFC) + HIDWORD(v81);
    v84 = v92;
    *(_OWORD *)(v6 + 8) = v91;
    *(_OWORD *)(v6 + 24) = v84;
    *(_OWORD *)(v6 + 40) = v93;
    *(_DWORD *)(v6 + 56) = 1;
  }
  return result;
}

uint64_t *sub_1D3DB8A80(uint64_t *result, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  if (*(_DWORD *)a2 != 0x7FFFFFFF)
  {
    v3 = result;
    v4 = result[1];
    if ((uint64_t *)v4 == result)
    {
LABEL_7:
      result = (uint64_t *)operator new(0x50uLL);
      v5 = *(_OWORD *)(a2 + 16);
      *((_OWORD *)result + 1) = *(_OWORD *)a2;
      *((_OWORD *)result + 2) = v5;
      v6 = *(_OWORD *)(a2 + 48);
      *((_OWORD *)result + 3) = *(_OWORD *)(a2 + 32);
      *((_OWORD *)result + 4) = v6;
      v7 = *v3;
      *result = *v3;
      result[1] = (uint64_t)v3;
      *(_QWORD *)(v7 + 8) = result;
      *v3 = (uint64_t)result;
      ++v3[2];
    }
    else
    {
      while (*(_DWORD *)(v4 + 16) != *(_DWORD *)a2
           || *(_DWORD *)(v4 + 20) != *(_DWORD *)(a2 + 4)
           || *(_DWORD *)(a2 + 8) != *(_DWORD *)(v4 + 24))
      {
        v4 = *(_QWORD *)(v4 + 8);
        if ((uint64_t *)v4 == result)
          goto LABEL_7;
      }
      ++*(_DWORD *)(v4 + 72);
    }
  }
  return result;
}

unint64_t sub_1D3DB8B34(uint64_t a1, _BYTE *a2, uint64_t a3, int a4, int *a5)
{
  unint64_t v8;
  unint64_t v9;
  int v10;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  BOOL v15;
  _BYTE *v16;
  _BYTE *v17;
  char *v18;
  char *v19;
  int v20;
  BOOL v21;
  int v22;
  float v23;
  float v24;
  uint64_t v26;
  unsigned int v27;
  uint64_t i;
  float v30;
  int v31;
  uint64_t v32;
  float v33;
  int32x4_t *v34;
  _DWORD *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  _BOOL4 v44;
  _BOOL4 v45;
  _BOOL4 v46;
  float v47;
  uint64_t v48;
  char *v49;
  int64_t v50;
  __int32 v51;
  float v52;
  uint64_t v53;
  char *v54;
  float v55;
  uint64_t v56;
  char *v57;
  int v58;
  float v59;
  uint64_t v60;
  __int32 v61;
  uint64_t v62;
  int32x4_t *v63;
  __int32 v64;
  uint64_t v65;
  int32x4_t *v66;
  __int32 v67;
  uint64_t j;
  __int32 v69;
  uint64_t k;
  uint64_t v71;
  int v72;
  unsigned int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  unsigned int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  _DWORD v86[4];
  _DWORD v87[4];
  int32x4_t v88;
  int32x4_t v89;
  int32x4_t v90;
  int32x4_t v91;

  v90 = 0u;
  v91 = 0u;
  if (a4)
  {
    v8 = sub_1D3DB90EC(a1, a1 + *(int *)(a3 + 4), (uint64_t)&v90);
    if (v8 >= v9)
      goto LABEL_22;
    v10 = 16;
  }
  else
  {
    v12 = (_BYTE *)(a1 + *(int *)(a3 + 8));
    v13 = sub_1D3DB91B0(v12, a2, (uint64_t)&v90);
    v15 = v14 != a2 || v91.i32[3] == 0;
    if (v15)
      v16 = v13;
    else
      v16 = v12;
    if (v15)
      v17 = v14;
    else
      v17 = a2;
    if (v16 >= v17)
      goto LABEL_22;
    v18 = &v91.i8[12];
    v19 = &v90.i8[4];
    do
    {
      v20 = *((_DWORD *)v19 - 1);
      *((_DWORD *)v19 - 1) = *(_DWORD *)v18;
      *(_DWORD *)v18 = v20;
      v18 -= 4;
      v21 = v19 >= v18;
      v19 += 4;
    }
    while (!v21);
    v10 = 15;
  }
  v22 = vaddvq_s32(vaddq_s32(v91, v90));
  *a5 = v22;
  v23 = (float)v22 / (float)v10;
  v24 = (float)(*(_DWORD *)(a3 + 8) - *(_DWORD *)(a3 + 4)) / 15.0;
  if ((float)(v23 * 1.5) < v24 || v23 > (float)(v24 * 1.5))
    goto LABEL_22;
  for (i = 0; i != 8; ++i)
  {
    v30 = (float)v90.i32[i] / v23;
    v31 = (int)(float)(v30 + 0.5);
    if (v31 >= 8)
      v31 = 8;
    if (v31 <= 1)
      v31 = 1;
    v32 = i >> 1;
    v33 = v30 - (float)v31;
    if ((i & 1) != 0)
      v34 = &v88;
    else
      v34 = &v89;
    if ((i & 1) != 0)
      v35 = v86;
    else
      v35 = v87;
    v34->i32[v32] = v31;
    *(float *)&v35[v32] = v33;
  }
  v36 = vaddvq_s32(v89);
  v37 = vaddvq_s32(v88);
  v38 = vaddvq_s32(vaddq_s32(v88, v89));
  v39 = v38 - v10;
  v40 = ((v36 & 1) == 0) ^ a4;
  if (a4)
    v41 = 12;
  else
    v41 = 11;
  if (a4)
    v42 = 4;
  else
    v42 = 5;
  if (a4)
    v43 = 12;
  else
    v43 = 10;
  v44 = v36 > v41;
  v45 = v37 > v43;
  v46 = v37 < 4;
  if (v39 == -1)
  {
    if (v40)
    {
      v26 = 0;
      v27 = 0x7FFFFFFF;
      if ((v37 & 1) != 0 || v36 > v41)
        return v27 | (unint64_t)(v26 << 32);
LABEL_81:
      v52 = *(float *)v87;
      v53 = 1;
      v54 = (char *)v87;
      do
      {
        if (v52 < *(float *)&v87[v53])
        {
          v52 = *(float *)&v87[v53];
          v54 = (char *)&v87[v53];
        }
        ++v53;
      }
      while (v53 != 4);
      v50 = v54 - (char *)v87;
      v51 = *(__int32 *)((char *)v89.i32 + v54 - (char *)v87) + 1;
      goto LABEL_86;
    }
    if ((v37 & 1) == 0)
      goto LABEL_22;
    v46 = 1;
  }
  else if (v39 == 1)
  {
    if (v40)
    {
      if ((v37 & 1) != 0)
        goto LABEL_22;
      v44 = 1;
    }
    else
    {
      if ((v37 & 1) == 0)
        goto LABEL_22;
      v45 = 1;
    }
  }
  else
  {
    if (v38 != v10)
      goto LABEL_22;
    if (v40)
    {
      if ((v37 & 1) == 0)
        goto LABEL_22;
      v44 = v36 >= v37 || v36 > v41;
      v46 = v36 >= v37 || v37 < 4;
      v45 = v37 > v43 || v36 < v37;
      if (v36 < v42 || v36 < v37)
        goto LABEL_80;
      goto LABEL_68;
    }
    if ((v37 & 1) != 0)
      goto LABEL_22;
  }
  if (v36 < v42)
  {
LABEL_80:
    if (v44)
      goto LABEL_22;
    goto LABEL_81;
  }
LABEL_68:
  if (v44)
  {
    v47 = *(float *)v87;
    v48 = 1;
    v49 = (char *)v87;
    do
    {
      if (*(float *)&v87[v48] < v47)
      {
        v47 = *(float *)&v87[v48];
        v49 = (char *)&v87[v48];
      }
      ++v48;
    }
    while (v48 != 4);
    v50 = v49 - (char *)v87;
    v51 = *(__int32 *)((char *)v89.i32 + v49 - (char *)v87) - 1;
LABEL_86:
    *(__int32 *)((char *)v89.i32 + v50) = v51;
    if (v46)
      goto LABEL_87;
    goto LABEL_94;
  }
  if (v46)
  {
LABEL_87:
    if (!v45)
    {
      v55 = *(float *)v86;
      v56 = 1;
      v57 = (char *)v86;
      do
      {
        if (v55 < *(float *)&v86[v56])
        {
          v55 = *(float *)&v86[v56];
          v57 = (char *)&v86[v56];
        }
        ++v56;
      }
      while (v56 != 4);
      v58 = 1;
LABEL_100:
      *(__int32 *)((char *)v88.i32 + v57 - (char *)v86) += v58;
      goto LABEL_101;
    }
LABEL_22:
    v26 = 0;
    v27 = 0x7FFFFFFF;
    return v27 | (unint64_t)(v26 << 32);
  }
LABEL_94:
  if (v45)
  {
    v59 = *(float *)v86;
    v60 = 1;
    v57 = (char *)v86;
    do
    {
      if (*(float *)&v86[v60] < v59)
      {
        v59 = *(float *)&v86[v60];
        v57 = (char *)&v86[v60];
      }
      ++v60;
    }
    while (v60 != 4);
    v58 = -1;
    goto LABEL_100;
  }
LABEL_101:
  v61 = v89.i32[0];
  v62 = 1;
  v63 = &v89;
  do
  {
    if (v89.i32[v62] < v61)
    {
      v61 = v89.i32[v62];
      v63 = (int32x4_t *)((char *)&v89 + v62 * 4);
    }
    ++v62;
  }
  while (v62 != 4);
  if (!v63->i32[0])
    goto LABEL_22;
  v64 = v88.i32[0];
  v65 = 1;
  v66 = &v88;
  do
  {
    if (v88.i32[v65] < v64)
    {
      v64 = v88.i32[v65];
      v66 = (int32x4_t *)((char *)&v88 + v65 * 4);
    }
    ++v65;
  }
  while (v65 != 4);
  if (!v66->i32[0])
    goto LABEL_22;
  v67 = 0;
  for (j = 3; j != -1; --j)
    v67 = v89.i32[j] + 9 * v67;
  v69 = 0;
  for (k = 3; k != -1; --k)
    v69 = v88.i32[k] + 9 * v69;
  v71 = (3 * v69 + v67);
  v26 = 0;
  if (a4)
  {
    v72 = vaddvq_s32(v89);
    v27 = 0x7FFFFFFF;
    if ((v72 & 1) == 0 && (v72 - 13) >= 0xFFFFFFF7)
    {
      v73 = (12 - v72) >> 1;
      v74 = dword_1D3E69FD4[v73];
      v75 = 9 - v74;
      v76 = sub_1D3DFDC3C(v89.i32, 4u, v74, 1);
      v77 = sub_1D3DFDC3C(v88.i32, 4u, v75, 0);
      v78 = dword_1D3E69FFC[v73];
      v79 = v77 + dword_1D3E69FE8[v73] * v76;
LABEL_122:
      v27 = v79 + v78;
      v26 = v71;
    }
  }
  else
  {
    v80 = vaddvq_s32(v88);
    v27 = 0x7FFFFFFF;
    if ((v80 & 1) == 0 && (v80 - 11) >= 0xFFFFFFF9)
    {
      v81 = (10 - v80) >> 1;
      v82 = dword_1D3E6A010[v81];
      v83 = 9 - v82;
      v84 = sub_1D3DFDC3C(v89.i32, 4u, v82, 0);
      v85 = sub_1D3DFDC3C(v88.i32, 4u, v83, 1);
      v78 = dword_1D3E6A030[v81];
      v79 = v84 + dword_1D3E6A020[v81] * v85;
      goto LABEL_122;
    }
  }
  return v27 | (unint64_t)(v26 << 32);
}

uint64_t sub_1D3DB90EC(uint64_t result, uint64_t a2, uint64_t a3)
{
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  int v11;
  BOOL v12;

  *(_DWORD *)(a3 + 28) = 0;
  v3 = (int *)(a3 + 28);
  if (a2 == result)
  {
    v9 = 0;
    v8 = a2;
  }
  else
  {
    v4 = 0;
    v5 = a2;
    while (1)
    {
      v6 = v5;
      while (v6 != result)
      {
        v7 = *(unsigned __int8 *)--v6;
        if (v7 == (*(_BYTE *)(v5 - 1) == 0))
        {
          v8 = v6 + 1;
          goto LABEL_8;
        }
      }
      v8 = result;
LABEL_8:
      *(_DWORD *)(a3 + 4 * v4) = v5 - v8;
      if (v8 == result)
        break;
      ++v4;
      v5 = v8;
      if (v4 == 8)
        goto LABEL_13;
    }
    v8 = result;
LABEL_13:
    v9 = *v3;
  }
  v10 = a3 + 4;
  do
  {
    v11 = *(_DWORD *)(v10 - 4);
    *(_DWORD *)(v10 - 4) = *v3;
    *v3-- = v11;
    v12 = v10 >= (unint64_t)v3;
    v10 += 4;
  }
  while (!v12);
  if (v8 != result || v9 == 0)
    return v8;
  return result;
}

_BYTE *sub_1D3DB91B0(_BYTE *result, _BYTE *a2, uint64_t a3)
{
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;

  if (result != a2)
  {
    v3 = 0;
    v4 = result;
    v5 = result;
    while (1)
    {
      while (*v5 == (*v4 == 0))
      {
LABEL_6:
        *(_DWORD *)(a3 + 4 * v3) = (_DWORD)v5 - (_DWORD)v4;
        if (v5 == a2)
          return a2;
        ++v3;
        v4 = v5;
        if (v3 == 8)
          return result;
      }
      if (++v5 == a2)
      {
        v5 = a2;
        goto LABEL_6;
      }
    }
  }
  return a2;
}

_QWORD *sub_1D3DB921C(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E95AF150;
  v2 = a1 + 1;
  sub_1D3DB92AC(a1 + 4);
  sub_1D3DB92AC(v2);
  return a1;
}

void sub_1D3DB925C(_QWORD *a1)
{
  _QWORD *v1;

  *a1 = &off_1E95AF150;
  v1 = a1 + 1;
  sub_1D3DB92AC(a1 + 4);
  sub_1D3DB92AC(v1);
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB92AC(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void sub_1D3DB9310(std::exception *a1)
{
  sub_1D3DDE164(a1);
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DB9334(_QWORD *a1, char *a2)
{
  _QWORD *result;

  result = sub_1D3DDE1A0(a1, a2);
  *result = &off_1E95AF510;
  return result;
}

void sub_1D3DB9358()
{
  JUMPOUT(0x1D8254C54);
}

float sub_1D3DB936C(float *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float result;

  v2 = *a2;
  v3 = a2[1] - *a2;
  if ((int)((unint64_t)v3 >> 2) >= 1)
  {
    v4 = 0;
    v5 = (int)(v3 >> 2);
    do
    {
      v6 = (float *)(v2 + 4 * v4);
      v7 = *v6;
      v8 = v6[1];
      v9 = a1[11] + (float)((float)(v8 * a1[10]) + (float)(a1[9] * *v6));
      *v6 = (float)(a1[5] + (float)((float)(v8 * a1[4]) + (float)(a1[3] * *v6))) / v9;
      result = (float)(a1[8] + (float)((float)(v8 * a1[7]) + (float)(a1[6] * v7))) / v9;
      v6[1] = result;
      v4 += 2;
    }
    while (v4 < v5);
  }
  return result;
}

unsigned int **sub_1D3DB93EC(uint64_t *a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15, float a16, float a17)
{
  float *v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int *v30;
  unsigned int *v31;
  float *v32;

  sub_1D3DB9500((uint64_t *)&v32, a2, a3, a4, a5, a6, a7, a8, a9);
  sub_1D3DB976C((uint64_t *)&v31, v32);
  sub_1D3D6F2E0((unsigned int **)&v32);
  sub_1D3DB9500((uint64_t *)&v32, a10, a11, a12, a13, a14, a15, a16, a17);
  v26 = v31;
  v25 = v32;
  if (v31)
  {
    v27 = v31 + 2;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  v30 = v26;
  sub_1D3DB9654(a1, v25, (uint64_t)&v30);
  sub_1D3D6F2E0(&v30);
  sub_1D3D6F2E0((unsigned int **)&v32);
  return sub_1D3D6F2E0(&v31);
}

void sub_1D3DB94C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  unsigned int *v3;
  va_list va;
  unsigned int *v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, unsigned int *);
  va_copy(va2, va1);
  v5 = va_arg(va2, unsigned int *);
  sub_1D3D6F2E0((unsigned int **)va);
  sub_1D3D6F2E0((unsigned int **)va2);
  sub_1D3D6F2E0((unsigned int **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DB9500(uint64_t *a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  float v16;
  float v17;
  uint64_t result;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  unsigned int *v28;
  unsigned int v29;

  v16 = (float)((float)(a2 - a4) + a6) - a8;
  v17 = (float)((float)(a3 - a5) + a7) - a9;
  result = operator new();
  if (v16 == 0.0 && v17 == 0.0)
  {
    v19 = a7 - a5;
    v21 = a2;
    v20 = a3;
    v22 = a5 - a3;
    v23 = a6 - a4;
    v24 = a4 - a2;
    v25 = 0.0;
    v26 = 0.0;
  }
  else
  {
    v27 = (float)((float)(a4 - a6) * (float)(a9 - a7)) - (float)((float)(a8 - a6) * (float)(a5 - a7));
    v26 = (float)((float)((float)(a4 - a6) * v17) - (float)(v16 * (float)(a5 - a7))) / v27;
    v21 = a2;
    v20 = a3;
    v19 = (float)(a9 - a3) + (float)(v26 * a9);
    v25 = (float)((float)(v16 * (float)(a9 - a7)) - (float)((float)(a8 - a6) * v17)) / v27;
    v22 = (float)(a5 - a3) + (float)(v25 * a5);
    v23 = (float)(a8 - a2) + (float)(v26 * a8);
    v24 = (float)(a4 - a2) + (float)(v25 * a4);
  }
  *(_DWORD *)(result + 8) = 0;
  v28 = (unsigned int *)(result + 8);
  *(_QWORD *)result = &off_1E95AF428;
  *(float *)(result + 12) = v24;
  *(float *)(result + 16) = v23;
  *(float *)(result + 20) = v21;
  *(float *)(result + 24) = v22;
  *(float *)(result + 28) = v19;
  *(float *)(result + 32) = v20;
  *(float *)(result + 36) = v25;
  *(float *)(result + 40) = v26;
  *(_DWORD *)(result + 44) = 1065353216;
  do
    v29 = __ldxr(v28);
  while (__stxr(v29 + 1, v28));
  *a1 = result;
  return result;
}

uint64_t sub_1D3DB9654(uint64_t *a1, float *a2, uint64_t a3)
{
  uint64_t result;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  unsigned int *v25;
  unsigned int v26;

  result = operator new();
  v7 = a2[3];
  v8 = a2[4];
  v9 = *(float *)(*(_QWORD *)a3 + 12);
  v10 = *(float *)(*(_QWORD *)a3 + 16);
  v11 = *(float *)(*(_QWORD *)a3 + 36);
  v12 = *(float *)(*(_QWORD *)a3 + 40);
  v14 = *(float *)(*(_QWORD *)a3 + 20);
  v13 = *(float *)(*(_QWORD *)a3 + 24);
  v15 = *(float *)(*(_QWORD *)a3 + 28);
  v16 = *(float *)(*(_QWORD *)a3 + 32);
  v17 = *(float *)(*(_QWORD *)a3 + 44);
  v18 = a2[5];
  v19 = a2[6];
  v20 = a2[7];
  v21 = a2[8];
  v22 = a2[9];
  v23 = a2[10];
  v24 = a2[11];
  *(_DWORD *)(result + 8) = 0;
  v25 = (unsigned int *)(result + 8);
  *(_QWORD *)result = &off_1E95AF428;
  *(float *)(result + 12) = (float)((float)(v8 * v13) + (float)(v7 * v9)) + (float)(v18 * v11);
  *(float *)(result + 16) = (float)((float)(v8 * v15) + (float)(v7 * v10)) + (float)(v18 * v12);
  *(float *)(result + 20) = (float)((float)(v8 * v16) + (float)(v7 * v14)) + (float)(v18 * v17);
  *(float *)(result + 24) = (float)((float)(v13 * v20) + (float)(v19 * v9)) + (float)(v21 * v11);
  *(float *)(result + 28) = (float)((float)(v15 * v20) + (float)(v19 * v10)) + (float)(v21 * v12);
  *(float *)(result + 32) = (float)((float)(v16 * v20) + (float)(v19 * v14)) + (float)(v21 * v17);
  *(float *)(result + 36) = (float)((float)(v13 * v23) + (float)(v22 * v9)) + (float)(v24 * v11);
  *(float *)(result + 40) = (float)((float)(v15 * v23) + (float)(v22 * v10)) + (float)(v24 * v12);
  *(float *)(result + 44) = (float)((float)(v16 * v23) + (float)(v22 * v14)) + (float)(v24 * v17);
  do
    v26 = __ldxr(v25);
  while (__stxr(v26 + 1, v25));
  *a1 = result;
  return result;
}

uint64_t sub_1D3DB976C(uint64_t *a1, float *a2)
{
  uint64_t result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  unsigned int *v14;
  unsigned int v15;

  result = operator new();
  v6 = a2[10];
  v5 = a2[11];
  v7 = a2[7];
  v8 = a2[8];
  v9 = a2[9];
  v10 = a2[5];
  v11 = a2[6];
  v13 = a2[3];
  v12 = a2[4];
  *(_DWORD *)(result + 8) = 0;
  v14 = (unsigned int *)(result + 8);
  *(_QWORD *)result = &off_1E95AF428;
  *(float *)(result + 12) = (float)(v7 * v5) - (float)(v6 * v8);
  *(float *)(result + 16) = (float)(v6 * v10) - (float)(v12 * v5);
  *(float *)(result + 20) = (float)(v12 * v8) - (float)(v7 * v10);
  *(float *)(result + 24) = (float)(v9 * v8) - (float)(v11 * v5);
  *(float *)(result + 28) = (float)(v13 * v5) - (float)(v9 * v10);
  *(float *)(result + 32) = (float)(v11 * v10) - (float)(v13 * v8);
  *(float *)(result + 36) = (float)(v11 * v6) - (float)(v9 * v7);
  *(float *)(result + 40) = (float)(v9 * v12) - (float)(v13 * v6);
  *(float *)(result + 44) = (float)(v13 * v7) - (float)(v11 * v12);
  do
    v15 = __ldxr(v14);
  while (__stxr(v15 + 1, v14));
  *a1 = result;
  return result;
}

float sub_1D3DB983C(unsigned int **a1, float *a2, int32x2_t a3)
{
  double v3;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  float32x4_t v8;
  int32x2_t v10;
  unsigned int *v11;

  *(float *)a3.i32 = (float)((float)(a2[3] * (float)((float)(a2[7] * a2[11]) - (float)(a2[10] * a2[8])))
                           - (float)(a2[6] * (float)((float)(a2[4] * a2[11]) - (float)(a2[10] * a2[5]))))
                   + (float)(a2[9] * (float)((float)(a2[4] * a2[8]) - (float)(a2[7] * a2[5])));
  *a1 = 0;
  v10 = a3;
  v3 = fabsf(*(float *)a3.i32);
  if (v3 > 0.00001)
  {
    sub_1D3DB976C((uint64_t *)&v11, a2);
    v5 = v11;
    if (v11)
    {
      v6 = v11 + 2;
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    *a1 = v5;
    sub_1D3D6F2E0(&v11);
    v8 = (float32x4_t)vdupq_lane_s32(v10, 0);
    *(float32x4_t *)(v5 + 3) = vdivq_f32(*(float32x4_t *)(v5 + 3), v8);
    *(float32x4_t *)(v5 + 7) = vdivq_f32(*(float32x4_t *)(v5 + 7), v8);
    *(float *)&v3 = *((float *)v5 + 11) / *(float *)v10.i32;
    v5[11] = LODWORD(v3);
  }
  return *(float *)&v3;
}

void sub_1D3DB9914(_Unwind_Exception *a1)
{
  unsigned int **v1;

  sub_1D3D6F2E0(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1D3DB9928(float **a1, const void **a2, uint64_t a3)
{
  const void *v5;
  uint64_t v6;
  _BOOL8 v8;
  char *v10;
  unint64_t v11;
  int v12;
  size_t v13;
  char *v14;
  __n128 v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  float *v29;
  float *v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  char *v38;
  __int128 *v39;
  uint64_t v40;
  float v41;
  float *v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  uint64_t v48;
  __int128 *v49;
  uint64_t v50;
  char *v51;
  __int128 *v52;
  uint64_t v53;
  float v54;
  float *v55;
  float v56;
  float *v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  __int128 v63;
  __int128 v64;
  float v65;
  __int128 v66;
  __int128 v67;
  float v68;
  __int128 v69;
  __int128 v70;
  float v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  char v79;
  char v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  char v90;
  _BYTE v91[40];
  void *v92[3];
  char *v93;
  uint64_t v94;
  uint64_t v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  uint64_t v105;

  v105 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = (uint64_t)a2[1];
  if ((unint64_t)(v6 - (_QWORD)v5) < 0x10)
    return 0;
  v93 = 0;
  v94 = 0;
  v95 = 0;
  sub_1D3D8E528(&v93, v5, v6, (v6 - (uint64_t)v5) >> 2);
  memset(v92, 0, sizeof(v92));
  sub_1D3D8E528(v92, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  sub_1D3DB9E64((uint64_t)v91, a2, &v93);
  sub_1D3DB9E64((uint64_t)&v81, (_QWORD *)a3, v92);
  v8 = 0;
  if (v91[36] && v90)
  {
    v10 = v93;
    v11 = (unint64_t)(v94 - (_QWORD)v93) >> 2;
    if ((v11 & 0x80000000) == 0)
      v12 = (unint64_t)(v94 - (_QWORD)v93) >> 2;
    else
      v12 = v11 + 1;
    if ((int)v11 < -1)
      v13 = -1;
    else
      v13 = 72 * (v12 >> 1);
    v14 = (char *)operator new[]();
    bzero(v14, v13);
    if ((int)v11 >= 2)
    {
      v16 = 0;
      v17 = (uint64_t)v12 >> 1;
      v18 = &v14[64 * v17];
      v19 = &v18[4 * v17];
      v20 = &v14[56 * (int)v17];
      v21 = &v20[4 * v17];
      v22 = &v14[48 * (int)v17];
      v23 = &v22[4 * v17];
      v24 = &v14[40 * (int)v17];
      v25 = &v14[32 * v17];
      v26 = &v14[24 * (int)v17];
      v27 = &v14[4 * v17];
      v28 = &v27[16 * v17];
      v29 = (float *)((char *)v92[0] + 4);
      v30 = (float *)(v10 + 4);
      do
      {
        v31 = *(v30 - 1);
        v32 = *v30;
        v33 = *(v29 - 1);
        v34 = *v29;
        *(float *)&v26[4 * v16] = v31;
        *(float *)&v27[4 * v16] = v31;
        *(float *)&v25[4 * v16] = v32;
        *(float *)&v27[8 * (v12 >> 1) + 4 * v16] = v32;
        *(_DWORD *)&v24[4 * v16] = 1065353216;
        *(_DWORD *)&v28[4 * v16] = 1065353216;
        *(float *)&v22[4 * v16] = -(float)(v31 * v34);
        *(float *)&v23[4 * v16] = -(float)(v31 * v33);
        *(float *)&v20[4 * v16] = -(float)(v32 * v34);
        v15.n128_f32[0] = -(float)(v32 * v33);
        *(_DWORD *)&v21[4 * v16] = v15.n128_u32[0];
        *(float *)&v18[4 * v16] = v34;
        *(float *)&v19[4 * v16++] = v33;
        v29 += 2;
        v30 += 2;
      }
      while (v12 >> 1 != v16);
    }
    v80 = 78;
    v79 = 65;
    v77 = 9;
    v78 = 2 * (v12 >> 1);
    v75 = v78;
    v76 = v78;
    v73 = 45;
    v74 = 9;
    MEMORY[0x1E0C80A78](v15);
    v72 = 0;
    sgesvd_NEWLAPACK();
    MEMORY[0x1D8254C3C](v14, 0x1000C8052888210);
    if (fabsf(v104) >= 0.00001)
    {
      v35 = 0;
      *(float *)&v69 = v96 / (float)-v104;
      *((float *)&v69 + 1) = v99 / (float)-v104;
      *((float *)&v69 + 2) = v102 / (float)-v104;
      *((float *)&v69 + 3) = v97 / (float)-v104;
      *(float *)&v70 = v100 / (float)-v104;
      *((float *)&v70 + 1) = v103 / (float)-v104;
      *((float *)&v70 + 2) = v98 / (float)-v104;
      *((float *)&v70 + 3) = v101 / (float)-v104;
      v71 = 1.0;
      v68 = 0.0;
      v66 = 0u;
      v67 = 0u;
      v36 = v91;
      do
      {
        v37 = 0;
        v38 = (char *)&v66 + 12 * v35;
        v39 = &v69;
        do
        {
          v40 = 0;
          v41 = *(float *)&v38[4 * v37];
          v42 = (float *)v39;
          do
          {
            v43 = *v42;
            v42 += 3;
            v41 = v41 + (float)(v43 * *(float *)&v36[v40]);
            v40 += 4;
          }
          while (v40 != 12);
          *(float *)&v38[4 * v37++] = v41;
          v39 = (__int128 *)((char *)v39 + 4);
        }
        while (v37 != 3);
        ++v35;
        v36 += 12;
      }
      while (v35 != 3);
      v69 = v66;
      v70 = v67;
      v71 = v68;
      v44 = (float)(v85 * v89) - (float)(v86 * v88);
      v45 = (float)(v86 * v87) - (float)(v84 * v89);
      v46 = (float)(v84 * v88) - (float)(v85 * v87);
      v47 = (float)((float)(v82 * v45) + (float)(v44 * v81)) + (float)(v46 * v83);
      v8 = v47 != 0.0;
      if (v47 != 0.0)
      {
        v48 = 0;
        *(float *)&v66 = v44 / v47;
        *((float *)&v66 + 1) = (float)((float)(v83 * v88) - (float)(v82 * v89)) / v47;
        *((float *)&v66 + 2) = (float)((float)(v82 * v86) - (float)(v83 * v85)) / v47;
        *((float *)&v66 + 3) = v45 / v47;
        *(float *)&v67 = (float)((float)(v81 * v89) - (float)(v83 * v87)) / v47;
        *((float *)&v67 + 1) = (float)((float)(v83 * v84) - (float)(v81 * v86)) / v47;
        *((float *)&v67 + 2) = v46 / v47;
        *((float *)&v67 + 3) = (float)((float)(v82 * v87) - (float)(v81 * v88)) / v47;
        v68 = (float)((float)(v81 * v85) - (float)(v82 * v84)) / v47;
        v65 = 0.0;
        v63 = 0u;
        v64 = 0u;
        v49 = &v69;
        do
        {
          v50 = 0;
          v51 = (char *)&v63 + 12 * v48;
          v52 = &v66;
          do
          {
            v53 = 0;
            v54 = *(float *)&v51[4 * v50];
            v55 = (float *)v52;
            do
            {
              v56 = *v55;
              v55 += 3;
              v54 = v54 + (float)(v56 * *(float *)((char *)v49 + v53));
              v53 += 4;
            }
            while (v53 != 12);
            *(float *)&v51[4 * v50++] = v54;
            v52 = (__int128 *)((char *)v52 + 4);
          }
          while (v50 != 3);
          ++v48;
          v49 = (__int128 *)((char *)v49 + 12);
        }
        while (v48 != 3);
        v69 = v63;
        v70 = v64;
        v57 = *a1;
        v59 = *(_QWORD *)((char *)&v63 + 4);
        v58 = HIDWORD(v63);
        *((_DWORD *)v57 + 3) = v63;
        *((_DWORD *)v57 + 4) = v58;
        v60 = HIDWORD(v70);
        v57[5] = *((float *)&v70 + 2);
        *((_DWORD *)v57 + 6) = v59;
        v61 = DWORD1(v70);
        *((_DWORD *)v57 + 7) = v70;
        *((_DWORD *)v57 + 8) = v60;
        v71 = v65;
        v57[9] = *((float *)&v59 + 1);
        *((_DWORD *)v57 + 10) = v61;
        v57[11] = v71;
      }
    }
    else
    {
      v8 = 0;
    }
  }
  if (v92[0])
    operator delete(v92[0]);
  if (v93)
    operator delete(v93);
  return v8;
}

void sub_1D3DB9E58(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_1D3D6D5A8(a1);
}

void sub_1D3DB9E64(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  float *v8;
  float *v9;
  unint64_t v10;
  int *v11;
  _DWORD *v12;
  int v13;
  float v14;
  float v15;
  float *v16;
  float v17;
  float v18;
  float *v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float v24;
  unint64_t v25;
  float *v26;
  float *v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  unint64_t v33;
  float *v34;
  float *v35;
  float *v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float *v42;
  float *v43;
  void *__p;
  float *v45;

  v6 = a2[1] - *a2;
  v7 = (unint64_t)(v6 >> 2) >> 1;
  sub_1D3D8D5CC(&__p, v7);
  sub_1D3D8D5CC(&v42, v7);
  v8 = (float *)__p;
  if ((unint64_t)v6 >= 8)
  {
    v9 = v42;
    if (v7 <= 1)
      v10 = 1;
    else
      v10 = (unint64_t)(v6 >> 2) >> 1;
    v11 = (int *)(*a2 + 4);
    v12 = __p;
    do
    {
      *v12++ = *(v11 - 1);
      v13 = *v11;
      v11 += 2;
      *(_DWORD *)v9++ = v13;
      --v10;
    }
    while (v10);
  }
  v14 = 0.0;
  v15 = 0.0;
  if (v8 != v45)
  {
    v16 = v8;
    do
    {
      v17 = *v16++;
      v15 = v15 + v17;
    }
    while (v16 != v45);
  }
  v18 = (float)v7;
  v19 = v42;
  if (v42 != v43)
  {
    v14 = 0.0;
    v20 = v42;
    do
    {
      v21 = *v20++;
      v14 = v14 + v21;
    }
    while (v20 != v43);
  }
  v22 = v15 / v18;
  v23 = 0.0;
  v24 = v14 / v18;
  if ((unint64_t)v6 >= 8)
  {
    if (v7 <= 1)
      v25 = 1;
    else
      v25 = (unint64_t)(v6 >> 2) >> 1;
    v26 = v8;
    v27 = v42;
    do
    {
      v28 = *v26++;
      v29 = v23 + (float)((float)(v28 - v22) * (float)(v28 - v22));
      v30 = *v27++;
      v23 = v29 + (float)((float)(v30 - v24) * (float)(v30 - v24));
      --v25;
    }
    while (v25);
  }
  v31 = 1.41421356 / sqrtf(v23 / v18);
  v32 = -(float)(v31 * v24);
  if ((unint64_t)v6 < 8)
  {
LABEL_26:
    *(float *)a1 = v31;
    *(_QWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(float *)(a1 + 16) = v31;
    *(_DWORD *)(a1 + 20) = 0;
    *(float *)(a1 + 24) = -(float)(v31 * v22);
    *(float *)(a1 + 28) = v32;
    *(_DWORD *)(a1 + 32) = 1065353216;
    *(_BYTE *)(a1 + 36) = 1;
    if (!v19)
    {
      if (!v8)
        return;
      goto LABEL_28;
    }
  }
  else
  {
    if (v7 <= 1)
      v33 = 1;
    else
      v33 = (unint64_t)(v6 >> 2) >> 1;
    v34 = (float *)(*a3 + 4);
    v35 = v8;
    v36 = v42;
    while (1)
    {
      v37 = *v35;
      v38 = *v36 * 0.0;
      v39 = (float)(v38 + (float)(*v35 * 0.0)) + 1.0;
      if (v39 == 0.0)
        break;
      v40 = (float)((float)(v38 + (float)(v31 * v37)) - (float)(v31 * v22)) / v39;
      v41 = (float)(v32 + (float)((float)(*v36 * v31) + (float)(v37 * 0.0))) / v39;
      *(v34 - 1) = v40;
      *v34 = v41;
      v34 += 2;
      ++v36;
      ++v35;
      if (!--v33)
        goto LABEL_26;
    }
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 36) = 0;
  }
  v43 = v19;
  operator delete(v19);
  v8 = (float *)__p;
  if (!__p)
    return;
LABEL_28:
  v45 = v8;
  operator delete(v8);
}

void sub_1D3DBA08C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DBA0A8(int a1, float *a2, int a3, float *a4, uint64_t a5)
{
  uint64_t result;
  size_t v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  _DWORD *v27;
  float v28;
  uint64_t v29;
  float v30;
  float v31;
  void *v32;
  size_t v33;
  void *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  uint64_t v45;
  int v46;

  result = 2;
  if (a3 >= 15 && (a3 & 3) == 3 && (a1 == a3 || a3 + 1 == a1) && *a2 <= *a4)
  {
    v11 = (a3 - 1);
    v12 = (float *)malloc_type_calloc(v11, 4uLL, 0x100004052888210uLL);
    v13 = 0;
    do
    {
      v12[v13] = a2[v13 + 1] - a2[v13];
      ++v13;
    }
    while (v11 != v13);
    v14 = 0;
    v15 = 0.0;
    v16 = 0.0;
    v17 = 0.0;
    v18 = 0.0;
    do
    {
      v15 = v15 + (float)(int)v14;
      v16 = v16 + (float)((float)(int)v14 * (float)(int)v14);
      v19 = v12[v14];
      v17 = v17 + (float)((float)(int)v14 * v19);
      v18 = v18 + v19;
      ++v14;
    }
    while (v11 != v14);
    v20 = 0;
    v21 = (float)((float)((float)(int)v11 * v17) - (float)(v15 * v18))
        / (float)((float)((float)(int)v11 * v16) - (float)(v15 * v15));
    v22 = (float)(v18 - (float)(v21 * v15)) / (float)(int)v11;
    v23 = 0.0;
    do
    {
      v23 = v23
          + (float)((float)((float)(v22 + (float)(v21 * (float)(int)v20)) - v12[v20])
                  * (float)((float)(v22 + (float)(v21 * (float)(int)v20)) - v12[v20]));
      ++v20;
    }
    while (v11 != v20);
    v24 = v23 * (float)(int)v11;
    v25 = (float)(v18 * v18) * 0.01;
    free(v12);
    if (v24 > v25)
      return 2;
    v26 = (float)(a2[1] - *a2) / 3.0;
    if (fabsf((float)(*a4 - *a2) + (float)(v26 * -2.0)) > (float)(v26 * 0.5))
      return 2;
    *(float *)(a5 + 72) = v26;
    v27 = *(_DWORD **)(a5 + 64);
    v27[12] = *(_DWORD *)a2;
    v28 = a2[v11];
    v27[10] = 0;
    v29 = (a3 - 2);
    v30 = a2[v29];
    v31 = (float)(v28 - v30) / 3.0;
    if (vabds_f32(a4[v11] - v28, v31) > (float)(v31 * 0.5) || vabds_f32(a4[v29] - v30, v31) > (float)(v31 * 0.5))
    {
      return 2;
    }
    else
    {
      *(float *)(a5 + 76) = v31;
      v27[11] = 0;
      v27[13] = LODWORD(a4[v11]);
      v32 = *(void **)(a5 + 16);
      if (v32)
        free(v32);
      v33 = (a3 - 3) >> 2;
      *(_QWORD *)(a5 + 8) = v33;
      *(_QWORD *)(a5 + 16) = 0;
      v34 = malloc_type_calloc(v33, 1uLL, 0x100004077774924uLL);
      v35 = 0;
      LOBYTE(v36) = 0;
      *(_QWORD *)(a5 + 16) = v34;
      do
      {
        v36 = ((float)(a4[v35 + 1] - a2[v35 + 1]) > (float)(a2[v35 + 2] - a4[v35 + 1])) | (char)(2 * v36);
        if ((++v35 & 3) == 0)
        {
          if (v36 > 9)
            goto LABEL_35;
          *(_BYTE *)((v35 >> 2) + *(_QWORD *)(a5 + 16) - 1) = v36;
          LOBYTE(v36) = 0;
        }
      }
      while (v29 - 1 != v35);
      v37 = *(_QWORD *)(a5 + 8);
      if ((int)v37 >= 1)
      {
        v38 = 0;
        v39 = *(_QWORD *)(a5 + 16);
        v40 = *(_QWORD *)(a5 + 8) + 1;
        v41 = 1;
        do
        {
          v42 = *(char *)(v39 + (v40 - 2));
          if (!v41)
            v42 = dword_1D3E6A164[*(char *)(v39 + (v40 - 2))];
          v38 += v42;
          v41 ^= 1u;
          --v40;
        }
        while (v40 > 1);
        HIDWORD(v43) = -858993459 * v38 + 429496728;
        LODWORD(v43) = HIDWORD(v43);
        if ((v43 >> 1) >= 0x19999999)
        {
          v44 = *(char *)(v39 + (v37 - 1));
          if ((int)v37 >= 2)
          {
            v45 = (v37 - 2);
            v46 = 2;
            do
            {
              if (v46 > 7)
                v46 = 2;
              v44 += v46 * *(char *)(v39 + v45--);
              ++v46;
            }
            while (v45 != -1);
          }
          if ((-1171354717 * v44 + 195225786) >= 0x1745D175)
          {
LABEL_35:
            *(_QWORD *)(a5 + 8) = 0;
            *(_DWORD *)(a5 + 24) = 0;
            return 2;
          }
        }
      }
      result = 0;
      *(_DWORD *)(a5 + 24) = 1065353216;
      *(_DWORD *)(a5 + 80) = 1;
      *(_DWORD *)(a5 + 84) = v37;
      *(_DWORD *)(*(_QWORD *)(a5 + 64) + 20) = a3;
    }
  }
  return result;
}

uint64_t sub_1D3DBA44C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t i;

  v3 = a3 - 1;
  if ((unint64_t)(a3 - 1) >= *(_QWORD *)(result + 8))
    v3 = *(_QWORD *)(result + 8);
  if (v3)
  {
    for (i = 0; i != v3; ++i)
      *(_BYTE *)(a2 + i) = *(_BYTE *)(*(_QWORD *)(result + 16) + i) + 48;
  }
  *(_BYTE *)(a2 + v3) = 0;
  return result;
}

BOOL sub_1D3DBA488(int a1)
{
  return (a1 & 3) != 0 && a1 > 14;
}

uint64_t sub_1D3DBA498()
{
  _QWORD *v0;
  uint64_t v1;
  unsigned int *v2;
  unsigned int v3;
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  _QWORD *v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t result;
  unsigned int *v22;
  unsigned int v23;

  v0 = (_QWORD *)operator new();
  v1 = operator new();
  *(_DWORD *)(v1 + 8) = 0;
  v2 = (unsigned int *)(v1 + 8);
  *(_QWORD *)v1 = &off_1E95AFAA8;
  *(_OWORD *)(v1 + 16) = 0u;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)(v1 + 64) = 0u;
  *(_QWORD *)(v1 + 80) = 0x11D00000100;
  *(_QWORD *)(v1 + 88) = 0;
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 + 1, v2));
  *v0 = v1;
  qword_1EDB89E20 = (uint64_t)v0;
  v4 = (_QWORD *)operator new();
  v5 = operator new();
  *(_DWORD *)(v5 + 8) = 0;
  v6 = (unsigned int *)(v5 + 8);
  *(_QWORD *)v5 = &off_1E95AFAA8;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_QWORD *)(v5 + 80) = 0x12D00000100;
  *(_QWORD *)(v5 + 88) = 0;
  do
    v7 = __ldxr(v6);
  while (__stxr(v7 + 1, v6));
  *v4 = v5;
  qword_1EDB89F08 = (uint64_t)v4;
  v8 = (_QWORD *)operator new();
  v9 = operator new();
  *(_DWORD *)(v9 + 8) = 0;
  v10 = (unsigned int *)(v9 + 8);
  *(_QWORD *)v9 = &off_1E95AFAA8;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_QWORD *)(v9 + 80) = 0x1300000010;
  *(_QWORD *)(v9 + 88) = 0;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  *v8 = v9;
  qword_1EDB89EE0 = (uint64_t)v8;
  v12 = (_QWORD *)operator new();
  v13 = operator new();
  *(_DWORD *)(v13 + 8) = 0;
  v14 = (unsigned int *)(v13 + 8);
  *(_QWORD *)v13 = &off_1E95AFAA8;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_OWORD *)(v13 + 48) = 0u;
  *(_OWORD *)(v13 + 64) = 0u;
  *(_QWORD *)(v13 + 80) = 0x4300000040;
  *(_QWORD *)(v13 + 88) = 0;
  do
    v15 = __ldxr(v14);
  while (__stxr(v15 + 1, v14));
  *v12 = v13;
  qword_1EDB89EE8 = (uint64_t)v12;
  qword_1EDB89EF0 = qword_1EDB89F08;
  v16 = (_QWORD *)operator new();
  v17 = operator new();
  *(_DWORD *)(v17 + 8) = 0;
  v18 = (unsigned int *)(v17 + 8);
  *(_QWORD *)v17 = &off_1E95AFAA8;
  *(_OWORD *)(v17 + 16) = 0u;
  *(_OWORD *)(v17 + 32) = 0u;
  *(_OWORD *)(v17 + 48) = 0u;
  *(_OWORD *)(v17 + 64) = 0u;
  *(_QWORD *)(v17 + 80) = 0x40900000400;
  *(_QWORD *)(v17 + 88) = 0;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  *v16 = v17;
  qword_1EDB89EF8 = (uint64_t)v16;
  v20 = (_QWORD *)operator new();
  result = operator new();
  *(_DWORD *)(result + 8) = 0;
  v22 = (unsigned int *)(result + 8);
  *(_QWORD *)result = &off_1E95AFAA8;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_QWORD *)(result + 80) = 0x106900001000;
  *(_QWORD *)(result + 88) = 0;
  do
    v23 = __ldxr(v22);
  while (__stxr(v23 + 1, v22));
  *v20 = result;
  qword_1EDB89F00 = (uint64_t)v20;
  return result;
}

void sub_1D3DBA79C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D8254C54](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DBA7D4(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &off_1E95AFAA8;
  sub_1D3DBA894((unsigned int **)(a1 + 72));
  sub_1D3DBA894((unsigned int **)(a1 + 64));
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 16);
  if (v3)
  {
    *(_QWORD *)(a1 + 24) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1D3DBA82C(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &off_1E95AFAA8;
  sub_1D3DBA894((unsigned int **)(a1 + 72));
  sub_1D3DBA894((unsigned int **)(a1 + 64));
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 16);
  if (v3)
  {
    *(_QWORD *)(a1 + 24) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3DBA894(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

void sub_1D3DBA8C4(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t **v4;
  uint64_t *v5;

  v3 = a1;
  v1 = (unint64_t *)(a1 + 88);
  v2 = atomic_load(v1);
  if (v2 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(v1, &v4, (void (__cdecl *)(void *))sub_1D3DBA910);
  }
}

_QWORD *sub_1D3DBA910(uint64_t ***a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v39;
  int v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int *v43;
  unsigned int *v44;
  int v45;
  uint64_t v46;
  uint64_t (**v47)(_QWORD);
  int v48;
  uint64_t v49;
  unsigned int *v50;

  v1 = **a1;
  v2 = *v1;
  sub_1D3DBAD60((char **)(*v1 + 16), *(int *)(*v1 + 80));
  sub_1D3DBAD60((char **)(v2 + 40), *(int *)(v2 + 80));
  if (*(int *)(v2 + 80) >= 1)
  {
    v3 = 0;
    v4 = *(_QWORD *)(v2 + 16);
    v5 = 1;
    do
    {
      *(_DWORD *)(v4 + 4 * v3) = v5;
      v5 *= 2;
      v6 = *(int *)(v2 + 80);
      if (v5 >= (int)v6)
        v5 = (*(_DWORD *)(v2 + 84) ^ v5) & (v6 - 1);
      ++v3;
    }
    while (v3 < v6);
    if ((int)v6 >= 2)
    {
      v7 = 0;
      v8 = *(_QWORD *)(v2 + 40);
      do
      {
        *(_DWORD *)(v8 + 4 * *(int *)(v4 + 4 * v7)) = v7;
        ++v7;
      }
      while (v7 < *(int *)(v2 + 80) - 1);
    }
  }
  v9 = (unsigned int *)operator new();
  v10 = (unsigned int *)(v2 + 8);
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  v39 = (unsigned int *)v2;
  do
    v12 = __ldxr(v10);
  while (__stxr(v12 + 1, v10));
  v50 = (unsigned int *)v2;
  v13 = operator new();
  *(_DWORD *)(v13 + 8) = 0;
  v14 = (unsigned int *)(v13 + 8);
  *(_QWORD *)v13 = &off_1E95AF5E0;
  LODWORD(v47) = 0;
  sub_1D3D821BC((_QWORD *)(v13 + 16), 1uLL, &v47);
  v48 = 0;
  v47 = &off_1E95AF9D0;
  do
    v15 = __ldxr(v14);
  while (__stxr(v15 + 1, v14));
  v49 = v13;
  sub_1D3DBB1C8((uint64_t)v9, &v50, (uint64_t)&v47);
  v16 = v9 + 2;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  v44 = v9;
  do
    v18 = __ldxr(v16);
  while (__stxr(v18 + 1, v16));
  v19 = *(unsigned int **)(v2 + 64);
  if (v19)
    sub_1D3D6D13C(v19);
  *(_QWORD *)(v2 + 64) = v9;
  sub_1D3DBA894(&v44);
  sub_1D3D82064(&v47);
  sub_1D3D82034(&v50);
  sub_1D3D81F38(&v39);
  v20 = *(_QWORD *)(v2 + 64);
  v45 = 0;
  v44 = (unsigned int *)&off_1E95AF9D0;
  v21 = *(_QWORD *)(v20 + 40);
  if (v21)
  {
    v22 = (unsigned int *)(v21 + 8);
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  v46 = v21;
  **(_DWORD **)(v21 + 16) = 0;
  sub_1D3D82064(&v44);
  v24 = (unsigned int *)operator new();
  do
    v25 = __ldxr(v10);
  while (__stxr(v25 + 1, v10));
  v42 = (unsigned int *)v2;
  do
    v26 = __ldxr(v10);
  while (__stxr(v26 + 1, v10));
  v43 = (unsigned int *)v2;
  v27 = operator new();
  *(_DWORD *)(v27 + 8) = 0;
  v28 = (unsigned int *)(v27 + 8);
  *(_QWORD *)v27 = &off_1E95AF5E0;
  LODWORD(v44) = 0;
  sub_1D3D821BC((_QWORD *)(v27 + 16), 1uLL, &v44);
  v45 = 0;
  v44 = (unsigned int *)&off_1E95AF9D0;
  do
    v29 = __ldxr(v28);
  while (__stxr(v29 + 1, v28));
  v46 = v27;
  sub_1D3DBB1C8((uint64_t)v24, &v43, (uint64_t)&v44);
  v30 = v24 + 2;
  do
    v31 = __ldxr(v30);
  while (__stxr(v31 + 1, v30));
  v39 = v24;
  do
    v32 = __ldxr(v30);
  while (__stxr(v32 + 1, v30));
  v33 = *(unsigned int **)(v2 + 72);
  if (v33)
    sub_1D3D6D13C(v33);
  *(_QWORD *)(v2 + 72) = v24;
  sub_1D3DBA894(&v39);
  sub_1D3D82064(&v44);
  sub_1D3D82034(&v43);
  sub_1D3D81F38(&v42);
  v34 = *(_QWORD *)(v2 + 72);
  v40 = 0;
  v39 = (unsigned int *)&off_1E95AF9D0;
  v35 = *(_QWORD *)(v34 + 40);
  if (v35)
  {
    v36 = (unsigned int *)(v35 + 8);
    do
      v37 = __ldxr(v36);
    while (__stxr(v37 + 1, v36));
  }
  v41 = v35;
  **(_DWORD **)(v35 + 16) = 1;
  return sub_1D3D82064(&v39);
}

void sub_1D3DBAC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, uint64_t a10, uint64_t a11, unsigned int *a12, unsigned int *a13, uint64_t a14)
{
  sub_1D3DBA894(&a9);
  sub_1D3D82064(&a14);
  sub_1D3D82034(&a13);
  sub_1D3D81F38(&a12);
  _Unwind_Resume(a1);
}

void sub_1D3DBAD60(char **a1, unint64_t a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  int v18;
  char *v19;

  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 2;
  if (a2 <= v5)
  {
    if (a2 >= v5)
      return;
    v19 = &v3[4 * a2];
    goto LABEL_15;
  }
  v6 = a2 - v5;
  v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 2)
  {
    bzero(a1[1], 4 * v6);
    v19 = &v4[4 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }
  if (a2 >> 62)
    sub_1D3D6D4F8();
  v8 = v7 - v3;
  v9 = v8 >> 1;
  if (v8 >> 1 <= a2)
    v9 = a2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
    v10 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v10 = v9;
  v11 = (char *)sub_1D3D82278(v10);
  v12 = *a1;
  v13 = a1[1];
  v14 = &v11[4 * v5];
  v16 = &v11[4 * v15];
  bzero(v14, 4 * v6);
  v17 = &v14[4 * v6];
  while (v13 != v12)
  {
    v18 = *((_DWORD *)v13 - 1);
    v13 -= 4;
    *((_DWORD *)v14 - 1) = v18;
    v14 -= 4;
  }
  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12)
    operator delete(v12);
}

void sub_1D3DBAE60()
{
  unint64_t v0;
  uint64_t (**v1)();
  uint64_t (*v2)();

  v0 = atomic_load(&qword_1EDB89E98);
  if (v0 != -1)
  {
    v1 = &v2;
    v2 = sub_1D3DBA498;
    std::__call_once(&qword_1EDB89E98, &v1, (void (__cdecl *)(void *))sub_1D3DA51A8);
  }
}

void sub_1D3DBAEB4(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  _QWORD *exception;
  uint64_t (**v23)(_QWORD);
  int v24;
  uint64_t v25;
  unsigned int *v26;
  uint64_t (**v27)(_QWORD);
  int v28;
  uint64_t v29;
  int v30;

  sub_1D3DBA8C4(a2);
  if (a3 < 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "Degree must be non-negative");
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  if (a4)
  {
    v8 = operator new();
    *(_DWORD *)(v8 + 8) = 0;
    v9 = (unsigned int *)(v8 + 8);
    *(_QWORD *)v8 = &off_1E95AF5E0;
    v30 = 0;
    sub_1D3D821BC((_QWORD *)(v8 + 16), (a3 + 1), &v30);
    v28 = 0;
    v27 = &off_1E95AF9D0;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    v29 = v8;
    **(_DWORD **)(v8 + 16) = a4;
    v11 = operator new();
    v12 = v11;
    if (a2)
    {
      v13 = (unsigned int *)(a2 + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v26 = (unsigned int *)a2;
    v24 = 0;
    v23 = &off_1E95AF9D0;
    if (v29)
    {
      v15 = (unsigned int *)(v29 + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    v25 = v29;
    sub_1D3DBB1C8(v11, &v26, (uint64_t)&v23);
    v17 = (unsigned int *)(v12 + 8);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
    *a1 = v12;
    sub_1D3D82064(&v23);
    sub_1D3D82034(&v26);
    sub_1D3D82064(&v27);
  }
  else
  {
    *a1 = 0;
    v19 = *(_QWORD *)(a2 + 64);
    if (v19)
    {
      v20 = (unsigned int *)(v19 + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    *a1 = v19;
  }
}

void sub_1D3DBB068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;

  __cxa_free_exception(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DBB0DC(uint64_t a1, int a2)
{
  _QWORD *exception;

  sub_1D3DBA8C4(a1);
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "Cannot calculate the inverse of 0");
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  return *(unsigned int *)(*(_QWORD *)(a1 + 16)
                         + 4 * (*(_DWORD *)(a1 + 80) + ~*(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * a2)));
}

void sub_1D3DBB150(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DBB164(uint64_t a1, int a2, int a3)
{
  uint64_t result;

  sub_1D3DBA8C4(a1);
  result = 0;
  if (a2)
  {
    if (a3)
      return *(unsigned int *)(*(_QWORD *)(a1 + 16)
                             + 4
                             * ((*(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * a3)
                               + *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * a2))
                              % (*(_DWORD *)(a1 + 80) - 1)));
  }
  return result;
}

uint64_t sub_1D3DBB1C8(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unsigned int **v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  _DWORD *v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int *v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int *v34;
  _DWORD *v35;
  unint64_t v36;
  uint64_t v37;
  int *v38;
  int v39;
  _QWORD *exception;
  unsigned int *v41;
  uint64_t (**v42)(_QWORD);
  int v43;
  uint64_t v44;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E95AF2F0;
  *(_QWORD *)(a1 + 16) = 0;
  v6 = (unsigned int **)(a1 + 16);
  v7 = *a2;
  if (*a2)
  {
    v8 = (unsigned int *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    if (*v6)
      sub_1D3D6D13C(*v6);
  }
  *(_QWORD *)(a1 + 24) = &off_1E95AF9D0;
  *(_QWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v10 = *(_QWORD *)(a3 + 16);
  v11 = *(_DWORD **)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24) - (_QWORD)v11;
  if (!v12)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(exception, "need coefficients");
    *exception = &off_1E95AF510;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  v13 = v12 >> 2;
  if ((int)(v12 >> 2) < 2 || *v11)
  {
    v14 = (unsigned int *)(v10 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v16 = *(unsigned int **)(a1 + 40);
    if (v16)
      sub_1D3D6D13C(v16);
    *(_QWORD *)(a1 + 40) = v10;
  }
  else
  {
    v18 = (v12 >> 2);
    v19 = 1;
    while (!v11[v19])
    {
      if (v18 == ++v19)
        goto LABEL_20;
    }
    if ((_DWORD)v19 == (_DWORD)v13)
    {
LABEL_20:
      v20 = *a2;
      sub_1D3DBA8C4(*a2);
      v21 = *(_QWORD *)(v20 + 64);
      if (v21)
      {
        v22 = (unsigned int *)(v21 + 8);
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v41 = (unsigned int *)v21;
      v42 = &off_1E95AF9D0;
      v43 = 0;
      v24 = *(_QWORD *)(v21 + 40);
      if (v24)
      {
        v25 = (unsigned int *)(v24 + 8);
        do
          v26 = __ldxr(v25);
        while (__stxr(v26 + 1, v25));
        v44 = v24;
        do
          v27 = __ldxr(v25);
        while (__stxr(v27 + 1, v25));
      }
      else
      {
        v44 = 0;
      }
      v28 = *(unsigned int **)(a1 + 40);
      if (v28)
        sub_1D3D6D13C(v28);
      *(_QWORD *)(a1 + 40) = v24;
      sub_1D3D82064(&v42);
      sub_1D3DBA894(&v41);
      return a1;
    }
    v29 = operator new();
    v30 = (int)v13 - (int)v19;
    *(_DWORD *)(v29 + 8) = 0;
    v31 = (unsigned int *)(v29 + 8);
    *(_QWORD *)v29 = &off_1E95AF5E0;
    LODWORD(v41) = 0;
    sub_1D3D821BC((_QWORD *)(v29 + 16), v30, &v41);
    v43 = 0;
    v42 = &off_1E95AF9D0;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    v44 = v29;
    do
      v33 = __ldxr(v31);
    while (__stxr(v33 + 1, v31));
    v34 = *(unsigned int **)(a1 + 40);
    if (v34)
      sub_1D3D6D13C(v34);
    *(_QWORD *)(a1 + 40) = v29;
    sub_1D3D82064(&v42);
    v35 = *(_DWORD **)(*(_QWORD *)(a1 + 40) + 16);
    v36 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) - (_QWORD)v35;
    if ((int)(v36 >> 2) >= 1)
    {
      v37 = (v36 >> 2);
      v38 = (int *)(*(_QWORD *)(*(_QWORD *)(a3 + 16) + 16) + 4 * v19);
      do
      {
        v39 = *v38++;
        *v35++ = v39;
        --v37;
      }
      while (v37);
    }
  }
  return a1;
}

void sub_1D3DBB46C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  unsigned int **v2;
  _QWORD *v3;
  va_list va;

  va_start(va, a2);
  sub_1D3D82064((uint64_t *)va);
  sub_1D3D82064(v3);
  sub_1D3D82034(v2);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3DBB4EC(_QWORD *a1)
{
  unsigned int **v2;

  *a1 = &off_1E95AF2F0;
  v2 = (unsigned int **)(a1 + 2);
  sub_1D3D82064(a1 + 3);
  sub_1D3D82034(v2);
  return a1;
}

void sub_1D3DBB52C(_QWORD *a1)
{
  unsigned int **v1;

  *a1 = &off_1E95AF2F0;
  v1 = (unsigned int **)(a1 + 2);
  sub_1D3D82064(a1 + 3);
  sub_1D3D82034(v1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DBB57C(uint64_t a1, int a2)
{
  unsigned int *v2;
  unint64_t v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v10;
  uint64_t v11;

  v2 = *(unsigned int **)(*(_QWORD *)(a1 + 40) + 16);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) - (_QWORD)v2;
  if (!a2)
    return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) - 4);
  v5 = v3 >> 2;
  if (a2 == 1)
  {
    if ((int)v5 < 1)
    {
      return 0;
    }
    else
    {
      LODWORD(v6) = 0;
      v7 = (v3 >> 2);
      do
      {
        v8 = *v2++;
        v6 = v8 ^ v6;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v6 = *v2;
    if ((int)v5 >= 2)
    {
      v10 = (v3 >> 2);
      v11 = 1;
      do
        v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 4 * v11++) ^ sub_1D3DBB164(*(_QWORD *)(a1 + 16), a2, v6);
      while (v10 != v11);
    }
  }
  return v6;
}

uint64_t *sub_1D3DBB638(uint64_t *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t *v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int *v21;
  _QWORD *v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  int *v26;
  unint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  int *v30;
  int v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int *v48;
  unsigned int v49;
  _QWORD *exception;
  uint64_t (**v51)(_QWORD);
  int v52;
  unsigned int *v53;
  unsigned int *v54;
  uint64_t (**v55)(_QWORD);
  int v56;
  unsigned int *v57;
  uint64_t (**v58)(_QWORD);
  int v59;
  unsigned int *v60;
  uint64_t (**v61)(_QWORD);
  int v62;
  unsigned int *v63;
  int v64;

  v3 = *a3;
  if (*(_QWORD *)(a2 + 16) != *(_QWORD *)(*a3 + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "GenericGFPolys do not have same GenericGF field");
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  v5 = result;
  v6 = *(_QWORD *)(a2 + 40);
  if (**(_DWORD **)(v6 + 16))
  {
    if (**(_DWORD **)(*(_QWORD *)(v3 + 40) + 16))
    {
      v62 = 0;
      v61 = &off_1E95AF9D0;
      v63 = 0;
      v7 = (unsigned int *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
      v63 = (unsigned int *)v6;
      v9 = *a3;
      v59 = 0;
      v58 = &off_1E95AF9D0;
      v60 = 0;
      v10 = *(_QWORD *)(v9 + 40);
      if (v10)
      {
        v11 = (unsigned int *)(v10 + 8);
        do
          v12 = __ldxr(v11);
        while (__stxr(v12 + 1, v11));
      }
      v60 = (unsigned int *)v10;
      if (*((_QWORD *)v63 + 3) - *((_QWORD *)v63 + 2) > *(_QWORD *)(v10 + 24) - *(_QWORD *)(v10 + 16))
      {
        v56 = 0;
        v55 = &off_1E95AF9D0;
        v13 = v63 + 2;
        v57 = 0;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
        v57 = v63;
        if (v60)
        {
          v15 = v60 + 2;
          do
            v16 = __ldxr(v15);
          while (__stxr(v16 + 1, v15));
        }
        if (v63)
          sub_1D3D6D13C(v63);
        v63 = v60;
        if (v57)
        {
          v17 = v57 + 2;
          do
            v18 = __ldxr(v17);
          while (__stxr(v18 + 1, v17));
        }
        if (v60)
          sub_1D3D6D13C(v60);
        v60 = v57;
        sub_1D3D82064(&v55);
      }
      v19 = operator new();
      v20 = (uint64_t)(*((_QWORD *)v60 + 3) - *((_QWORD *)v60 + 2)) >> 2;
      *(_DWORD *)(v19 + 8) = 0;
      v21 = (unsigned int *)(v19 + 8);
      *(_QWORD *)v19 = &off_1E95AF5E0;
      v64 = 0;
      v22 = sub_1D3D821BC((_QWORD *)(v19 + 16), v20, &v64);
      v56 = 0;
      v55 = &off_1E95AF9D0;
      do
        v23 = __ldxr(v21);
      while (__stxr(v23 + 1, v21));
      v57 = (unsigned int *)v19;
      v24 = *((_QWORD *)v60 + 2);
      v25 = *((_QWORD *)v60 + 3) - v24;
      v26 = (int *)*((_QWORD *)v63 + 2);
      v27 = (v25 >> 2) - ((*((_QWORD *)v63 + 3) - (_QWORD)v26) >> 2);
      if ((int)v27 >= 1)
      {
        v28 = (_DWORD *)*v22;
        v29 = (v25 >> 2) - ((*((_QWORD *)v63 + 3) - (_QWORD)v26) >> 2);
        v30 = (int *)*((_QWORD *)v60 + 2);
        do
        {
          v31 = *v30++;
          *v28++ = v31;
          --v29;
        }
        while (v29);
      }
      if ((int)v27 < (int)(v25 >> 2))
      {
        v32 = (int)v27;
        v33 = (_DWORD *)*v22;
        v34 = (int)((uint64_t)v25 >> 2);
        do
        {
          v35 = *v26++;
          v33[v32] = *(_DWORD *)(v24 + 4 * v32) ^ v35;
          ++v32;
        }
        while (v32 < v34);
      }
      v36 = operator new();
      v37 = v36;
      v38 = *(unsigned int **)(a2 + 16);
      if (v38)
      {
        v39 = v38 + 2;
        do
          v40 = __ldxr(v39);
        while (__stxr(v40 + 1, v39));
      }
      v54 = v38;
      v52 = 0;
      v51 = &off_1E95AF9D0;
      v41 = v57;
      if (v57)
      {
        v42 = v57 + 2;
        do
          v43 = __ldxr(v42);
        while (__stxr(v43 + 1, v42));
      }
      v53 = v41;
      sub_1D3DBB1C8(v36, &v54, (uint64_t)&v51);
      v44 = (unsigned int *)(v37 + 8);
      do
        v45 = __ldxr(v44);
      while (__stxr(v45 + 1, v44));
      *v5 = v37;
      sub_1D3D82064(&v51);
      sub_1D3D82034(&v54);
      sub_1D3D82064(&v55);
      sub_1D3D82064(&v58);
      return sub_1D3D82064(&v61);
    }
    else
    {
      v48 = (unsigned int *)(a2 + 8);
      do
        v49 = __ldxr(v48);
      while (__stxr(v49 + 1, v48));
      *result = a2;
    }
  }
  else
  {
    v46 = (unsigned int *)(v3 + 8);
    do
      v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
    *result = v3;
  }
  return result;
}

void sub_1D3DBB9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  sub_1D3D82064((uint64_t *)va);
  sub_1D3D82064((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void sub_1D3DBBA4C()
{
  void *v0;

  __cxa_free_exception(v0);
  JUMPOUT(0x1D3DBBA44);
}

void sub_1D3DBBA5C(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v6;
  _DWORD *v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int *v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int *v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int v43;
  _QWORD *exception;
  uint64_t (**v45)(_QWORD);
  int v46;
  uint64_t v47;
  unsigned int *v48;
  uint64_t (**v49)(_QWORD);
  int v50;
  uint64_t v51;
  uint64_t (**v52)(_QWORD);
  int v53;
  uint64_t v54;
  uint64_t (**v55)(_QWORD);
  int v56;
  uint64_t v57;
  int v58;

  v3 = *(_QWORD *)(a2 + 16);
  if (v3 != *(_QWORD *)(*a3 + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DB9334(exception, "GenericGFPolys do not have same GenericGF field");
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(_DWORD **)(v6 + 16);
  if (*v7 && **(_DWORD **)(*(_QWORD *)(*a3 + 40) + 16))
  {
    v56 = 0;
    v55 = &off_1E95AF9D0;
    v57 = 0;
    v8 = (unsigned int *)(v6 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    v57 = v6;
    v10 = *(_QWORD *)(v6 + 24);
    v11 = *a3;
    v53 = 0;
    v52 = &off_1E95AF9D0;
    v12 = *(_QWORD *)(v11 + 40);
    if (v12)
    {
      v13 = (unsigned int *)(v12 + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v54 = v12;
    v16 = *(_QWORD *)(v12 + 16);
    v15 = *(_QWORD *)(v12 + 24);
    v17 = operator new();
    v18 = v10 - (_QWORD)v7;
    v19 = v15 - v16;
    v20 = (v15 - v16) >> 2;
    *(_DWORD *)(v17 + 8) = 0;
    v21 = (unsigned int *)(v17 + 8);
    *(_QWORD *)v17 = &off_1E95AF5E0;
    v58 = 0;
    sub_1D3D821BC((_QWORD *)(v17 + 16), (int)(v20 + (v18 >> 2) - 1), &v58);
    v50 = 0;
    v49 = &off_1E95AF9D0;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    v51 = v17;
    if ((int)(v18 >> 2) >= 1)
    {
      v23 = 0;
      v24 = 0;
      v25 = ((unint64_t)v18 >> 2);
      v26 = v19 & 0x3FFFFFFFCLL;
      do
      {
        if ((int)v20 >= 1)
        {
          v27 = 0;
          v28 = *(_DWORD *)(*(_QWORD *)(v57 + 16) + 4 * v24);
          v29 = *(_QWORD *)(v17 + 16);
          do
          {
            v30 = *(_DWORD *)(v29 + v23 + v27);
            v31 = sub_1D3DBB164(*(_QWORD *)(a2 + 16), v28, *(_DWORD *)(*(_QWORD *)(v54 + 16) + v27)) ^ v30;
            v17 = v51;
            v29 = *(_QWORD *)(v51 + 16);
            *(_DWORD *)(v29 + v23 + v27) = v31;
            v27 += 4;
          }
          while (v26 != v27);
        }
        ++v24;
        v23 += 4;
      }
      while (v24 != v25);
    }
    v32 = operator new();
    v33 = v32;
    v34 = *(unsigned int **)(a2 + 16);
    if (v34)
    {
      v35 = v34 + 2;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    v48 = v34;
    v46 = 0;
    v45 = &off_1E95AF9D0;
    if (v51)
    {
      v37 = (unsigned int *)(v51 + 8);
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
    v47 = v51;
    sub_1D3DBB1C8(v32, &v48, (uint64_t)&v45);
    v39 = (unsigned int *)(v33 + 8);
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
    *a1 = v33;
    sub_1D3D82064(&v45);
    sub_1D3D82034(&v48);
    sub_1D3D82064(&v49);
    sub_1D3D82064(&v52);
    sub_1D3D82064(&v55);
  }
  else
  {
    sub_1D3DBA8C4(*(_QWORD *)(a2 + 16));
    v41 = *(_QWORD *)(v3 + 64);
    if (v41)
    {
      v42 = (unsigned int *)(v41 + 8);
      do
        v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
    }
    *a1 = v41;
  }
}

void sub_1D3DBBD5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unsigned int *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  uint64_t v19;

  sub_1D3D82064(&a9);
  sub_1D3D82034(&a12);
  MEMORY[0x1D8254C54](v19, 0x10E1C405E447FC4);
  sub_1D3D82064(&a13);
  sub_1D3D82064(&a16);
  sub_1D3D82064(&a19);
  _Unwind_Resume(a1);
}

void sub_1D3DBBDEC(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t (**v27)(_QWORD);
  int v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t (**v31)(_QWORD);
  int v32;
  uint64_t v33;
  int v34;

  if (a3 == 1)
  {
    *a1 = 0;
    if (a2)
    {
      v10 = (unsigned int *)(a2 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    *a1 = a2;
  }
  else if (a3)
  {
    v12 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 24) - *(_QWORD *)(*(_QWORD *)(a2 + 40) + 16);
    v13 = operator new();
    *(_DWORD *)(v13 + 8) = 0;
    v14 = (unsigned int *)(v13 + 8);
    *(_QWORD *)v13 = &off_1E95AF5E0;
    v34 = 0;
    sub_1D3D821BC((_QWORD *)(v13 + 16), (int)(v12 >> 2), &v34);
    v32 = 0;
    v31 = &off_1E95AF9D0;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v33 = v13;
    if ((int)((unint64_t)v12 >> 2) >= 1)
    {
      v16 = 0;
      v17 = v12 & 0x3FFFFFFFCLL;
      do
      {
        *(_DWORD *)(*(_QWORD *)(v33 + 16) + v16) = sub_1D3DBB164(*(_QWORD *)(a2 + 16), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + v16), a3);
        v16 += 4;
      }
      while (v17 != v16);
    }
    v18 = operator new();
    v19 = v18;
    v20 = *(unsigned int **)(a2 + 16);
    if (v20)
    {
      v21 = v20 + 2;
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    v30 = v20;
    v28 = 0;
    v27 = &off_1E95AF9D0;
    if (v33)
    {
      v23 = (unsigned int *)(v33 + 8);
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    v29 = v33;
    sub_1D3DBB1C8(v18, &v30, (uint64_t)&v27);
    v25 = (unsigned int *)(v19 + 8);
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
    *a1 = v19;
    sub_1D3D82064(&v27);
    sub_1D3D82034(&v30);
    sub_1D3D82064(&v31);
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 16);
    sub_1D3DBA8C4(v6);
    v7 = *(_QWORD *)(v6 + 64);
    if (v7)
    {
      v8 = (unsigned int *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    *a1 = v7;
  }
}

void sub_1D3DBBFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unsigned int *a12, uint64_t a13)
{
  uint64_t v13;

  sub_1D3D82064(&a9);
  sub_1D3D82034(&a12);
  MEMORY[0x1D8254C54](v13, 0x10E1C405E447FC4);
  sub_1D3D82064(&a13);
  _Unwind_Resume(a1);
}

unint64_t sub_1D3DBC050(uint64_t *a1, uint64_t a2, int a3)
{
  unsigned int *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  unsigned int *v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  unsigned int *v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int *v39;
  unsigned int *v40;
  unsigned int v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int *v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int *v51;
  unsigned int v52;
  uint64_t v53;
  unsigned int *v54;
  unsigned int *v55;
  unsigned int v56;
  uint64_t v57;
  unsigned int *v58;
  unsigned int *v59;
  unsigned int v60;
  uint64_t v61;
  unsigned int *v62;
  unsigned int *v63;
  unsigned int v64;
  uint64_t v65;
  unsigned int *v66;
  unsigned int *v67;
  unsigned int v68;
  unsigned int *v69;
  unsigned int *v70;
  unsigned int *v71;
  unsigned int v72;
  unsigned int *v73;
  unsigned int *v74;
  unsigned int v75;
  unsigned int *v76;
  unsigned int *v77;
  unsigned int v78;
  unsigned int *v79;
  unsigned int v80;
  unsigned int *v81;
  unsigned int *v82;
  unsigned int v83;
  unsigned int *v84;
  unsigned int *v85;
  unsigned int v86;
  unsigned int *v87;
  unsigned int *v88;
  unsigned int v89;
  uint64_t v90;
  unsigned int *v91;
  unsigned int *v92;
  unsigned int v93;
  int v94;
  _DWORD *v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unsigned int *v101;
  unsigned int *v102;
  unsigned int *v103;
  unsigned int v104;
  unsigned int *v105;
  unsigned int *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unsigned int *v113;
  unsigned int v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  unsigned int *v118;
  unsigned int *v119;
  unsigned int *v120;
  unsigned int v121;
  uint64_t v122;
  unsigned int *v123;
  unsigned int v124;
  unsigned int *v125;
  unsigned int v126;
  uint64_t v127;
  unsigned int *v128;
  unsigned int *v129;
  unsigned int v130;
  unsigned int *v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int *v134;
  unsigned int *v135;
  unsigned int *v136;
  unsigned int v137;
  unsigned int *v138;
  unsigned int *v139;
  unsigned int *v140;
  unsigned int v141;
  unsigned int *v142;
  unsigned int *v143;
  unsigned int v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int *v147;
  unsigned int v148;
  unsigned int *v149;
  unsigned int *v150;
  unsigned int *v151;
  unsigned int v152;
  unsigned int *v153;
  unsigned int *v154;
  unsigned int v155;
  int v156;
  int v157;
  _QWORD *v158;
  unsigned int **v159;
  unsigned int **v160;
  unsigned int *v161;
  unsigned int *v162;
  unsigned int v163;
  unsigned int *v164;
  unsigned int *v165;
  unsigned int *v166;
  unsigned int v167;
  unsigned int *v168;
  unsigned int *v169;
  unsigned int *v170;
  unsigned int v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  unint64_t v177;
  int v178;
  unsigned int *v179;
  unsigned int v180;
  unsigned int *v181;
  _QWORD *v182;
  unsigned int v183;
  int v184;
  int i;
  uint64_t v187;
  unint64_t v188;
  unsigned int *v189;
  unsigned int *v190;
  unsigned int v191;
  unsigned int *v192;
  unsigned int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  unsigned int *v198;
  _QWORD *v199;
  unsigned int v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  uint64_t v204;
  int v205;
  uint64_t v206;
  int v207;
  uint64_t v208;
  int v209;
  int v210;
  int v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  unint64_t v218;
  uint64_t v219;
  void ***v220;
  _QWORD *v222;
  _QWORD *v223;
  _QWORD *v224;
  _QWORD *exception;
  _QWORD *v226;
  _QWORD *v227;
  _QWORD *v228;
  _QWORD *v229;
  _QWORD *v230;
  _QWORD *v231;
  _QWORD *v232;
  uint64_t v233;
  unsigned int *v234;
  unsigned int *v235;
  signed int v236;
  unint64_t v237;
  uint64_t (**v238)(_QWORD);
  int v239;
  uint64_t v240;
  unsigned int *v241;
  unsigned int *v242;
  unsigned int *v243;
  unsigned int *v244;
  unsigned int **v245;
  _QWORD *v246;
  _QWORD *v247;
  unsigned int *v248;
  uint64_t (**v249)(_QWORD);
  int v250;
  uint64_t v251;
  unsigned int *v252;
  unsigned int *v253;
  uint64_t (**v254)(_QWORD);
  int v255;
  uint64_t v256;
  uint64_t (**v257)(_QWORD);
  int v258;
  uint64_t v259;
  unsigned int *v260;
  unsigned int *v261;
  unsigned int *v262;
  unsigned int *v263;
  unsigned int *v264;
  unsigned int *v265;
  unsigned int *v266;
  unsigned int *v267;
  unsigned int *v268;
  unsigned int *v269;
  unsigned int *v270;
  unsigned int *v271;
  unsigned int *v272;
  unsigned int *v273;
  unsigned int *v274;
  unsigned int *v275;
  unsigned int *v276;
  unsigned int *v277;
  unsigned int *v278;
  unsigned int *v279;
  int v280;
  uint64_t v281;
  unsigned int *v282;
  unsigned int *v283;
  int v284;
  uint64_t v285;

  v6 = (unsigned int *)operator new();
  v7 = (unsigned int *)*a1;
  if (*a1)
  {
    v8 = v7 + 2;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v259 = 0;
  v260 = v7;
  v258 = 0;
  v257 = &off_1E95AF9D0;
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = (unsigned int *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v259 = v10;
  sub_1D3DBB1C8((uint64_t)v6, &v260, (uint64_t)&v257);
  v13 = v6 + 2;
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 + 1, v13));
  v261 = v6;
  sub_1D3D82064(&v257);
  sub_1D3D82034(&v260);
  v15 = operator new();
  *(_DWORD *)(v15 + 8) = 0;
  v16 = (unsigned int *)(v15 + 8);
  *(_QWORD *)v15 = &off_1E95AF5E0;
  LODWORD(v283) = 0;
  sub_1D3D821BC((_QWORD *)(v15 + 16), a3, &v283);
  v255 = 0;
  v254 = &off_1E95AF9D0;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  v256 = v15;
  v235 = (unsigned int *)*a1;
  sub_1D3DBAE60();
  v18 = *(unsigned int **)qword_1EDB89E20;
  if (*(_QWORD *)qword_1EDB89E20)
  {
    v19 = v18 + 2;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v283 = v18;
  sub_1D3D81F38(&v283);
  if (a3 < 1)
    goto LABEL_18;
  v233 = a2;
  v234 = v18;
  v21 = 0;
  v22 = 4 * (v235 != v18);
  v23 = 1;
  do
  {
    v24 = v261;
    v25 = *a1;
    sub_1D3DBA8C4(*a1);
    v26 = sub_1D3DBB57C((uint64_t)v24, *(_DWORD *)(*(_QWORD *)(v25 + 16) + v22));
    *(_DWORD *)(*(_QWORD *)(v256 + 16) + 4 * (v21 + ((*(_QWORD *)(v256 + 24) - *(_QWORD *)(v256 + 16)) >> 2)) - 4) = v26;
    v23 &= v26 == 0;
    --v21;
    v22 += 4;
  }
  while (-(uint64_t)a3 != v21);
  if ((v23 & 1) != 0)
  {
LABEL_18:
    v27 = 0;
    goto LABEL_208;
  }
  v28 = (unsigned int *)operator new();
  v29 = (unsigned int *)*a1;
  if (*a1)
  {
    v30 = v29 + 2;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v251 = 0;
  v252 = v29;
  v250 = 0;
  v249 = &off_1E95AF9D0;
  if (v256)
  {
    v32 = (unsigned int *)(v256 + 8);
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  v251 = v256;
  sub_1D3DBB1C8((uint64_t)v28, &v252, (uint64_t)&v249);
  v34 = v28 + 2;
  do
    v35 = __ldxr(v34);
  while (__stxr(v35 + 1, v34));
  v253 = v28;
  sub_1D3D82064(&v249);
  sub_1D3D82034(&v252);
  sub_1D3DBAEB4((uint64_t *)&v248, *a1, a3, 1);
  v36 = v248;
  if (v248)
  {
    v37 = v248 + 2;
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
  }
  v244 = v36;
  v39 = v253;
  if (v253)
  {
    v40 = v253 + 2;
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  v243 = v39;
  if ((int)(((*(_QWORD *)(*((_QWORD *)v36 + 5) + 24) - *(_QWORD *)(*((_QWORD *)v36 + 5) + 16)) >> 2) - 1) >= (int)(((*(_QWORD *)(*((_QWORD *)v39 + 5) + 24) - *(_QWORD *)(*((_QWORD *)v39 + 5) + 16)) >> 2) - 1))
    goto LABEL_44;
  v42 = v36 + 2;
  do
    v43 = __ldxr(v42);
  while (__stxr(v43 + 1, v42));
  v283 = v36;
  v44 = v39 + 2;
  do
    v45 = __ldxr(v44);
  while (__stxr(v45 + 1, v44));
  sub_1D3D6D13C(v36);
  v46 = v283;
  v244 = v39;
  if (v283)
  {
    v47 = v283 + 2;
    do
      v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
  }
  if (v243)
    sub_1D3D6D13C(v243);
  v243 = v46;
  sub_1D3DBA894(&v283);
  v36 = v244;
  if (v244)
  {
LABEL_44:
    v49 = v36 + 2;
    do
      v50 = __ldxr(v49);
    while (__stxr(v50 + 1, v49));
  }
  v278 = v36;
  if (v243)
  {
    v51 = v243 + 2;
    do
      v52 = __ldxr(v51);
    while (__stxr(v52 + 1, v51));
  }
  v277 = v243;
  v53 = *a1;
  sub_1D3DBA8C4(*a1);
  v54 = *(unsigned int **)(v53 + 72);
  if (v54)
  {
    v55 = v54 + 2;
    do
      v56 = __ldxr(v55);
    while (__stxr(v56 + 1, v55));
  }
  v276 = v54;
  v57 = *a1;
  sub_1D3DBA8C4(*a1);
  v58 = *(unsigned int **)(v57 + 64);
  if (v58)
  {
    v59 = v58 + 2;
    do
      v60 = __ldxr(v59);
    while (__stxr(v60 + 1, v59));
  }
  v275 = v58;
  v61 = *a1;
  sub_1D3DBA8C4(*a1);
  v62 = *(unsigned int **)(v61 + 64);
  if (v62)
  {
    v63 = v62 + 2;
    do
      v64 = __ldxr(v63);
    while (__stxr(v64 + 1, v63));
  }
  v274 = v62;
  v65 = *a1;
  sub_1D3DBA8C4(*a1);
  v66 = *(unsigned int **)(v65 + 72);
  if (v66)
  {
    v67 = v66 + 2;
    do
      v68 = __ldxr(v67);
    while (__stxr(v68 + 1, v67));
  }
  v273 = v66;
  v236 = a3 >> 1;
  while (1)
  {
    v69 = v277;
    if ((int)(((*(_QWORD *)(*((_QWORD *)v69 + 5) + 24) - *(_QWORD *)(*((_QWORD *)v69 + 5) + 16)) >> 2) - 1) < v236)
      break;
    v70 = v278;
    if (v278)
    {
      v71 = v278 + 2;
      do
        v72 = __ldxr(v71);
      while (__stxr(v72 + 1, v71));
    }
    v272 = v70;
    v73 = v276;
    if (v276)
    {
      v74 = v276 + 2;
      do
        v75 = __ldxr(v74);
      while (__stxr(v75 + 1, v74));
    }
    v271 = v73;
    v76 = v274;
    if (v274)
    {
      v77 = v274 + 2;
      do
        v78 = __ldxr(v77);
      while (__stxr(v78 + 1, v77));
    }
    v270 = v76;
    v79 = v69 + 2;
    do
      v80 = __ldxr(v79);
    while (__stxr(v80 + 1, v79));
    if (v70)
      sub_1D3D6D13C(v70);
    v278 = v69;
    v81 = v275;
    if (v275)
    {
      v82 = v275 + 2;
      do
        v83 = __ldxr(v82);
      while (__stxr(v83 + 1, v82));
    }
    if (v276)
      sub_1D3D6D13C(v276);
    v276 = v81;
    v84 = v273;
    if (v273)
    {
      v85 = v273 + 2;
      do
        v86 = __ldxr(v85);
      while (__stxr(v86 + 1, v85));
    }
    if (v274)
      sub_1D3D6D13C(v274);
    v274 = v84;
    if (!**(_DWORD **)(*((_QWORD *)v278 + 5) + 16))
    {
      exception = __cxa_allocate_exception(0x20uLL);
      v226 = sub_1D3DBD59C(exception, "r_{i-1} was zero");
      __cxa_throw(v226, (struct type_info *)&unk_1E95AE290, (void (*)(void *))sub_1D3DBD574);
    }
    v87 = v272;
    if (v272)
    {
      v88 = v272 + 2;
      do
        v89 = __ldxr(v88);
      while (__stxr(v89 + 1, v88));
    }
    if (v277)
      sub_1D3D6D13C(v277);
    v277 = v87;
    v90 = *a1;
    sub_1D3DBA8C4(*a1);
    v91 = *(unsigned int **)(v90 + 64);
    if (v91)
    {
      v92 = v91 + 2;
      do
        v93 = __ldxr(v92);
      while (__stxr(v93 + 1, v92));
    }
    v269 = v91;
    v94 = sub_1D3DBB0DC(*a1, *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v278 + 5) + 16)+ 4* (((*(_QWORD *)(*((_QWORD *)v278 + 5) + 24) - *(_QWORD *)(*((_QWORD *)v278 + 5) + 16)) >> 2)+ (int)((*(_QWORD *)(*((_QWORD *)v278 + 5) + 16) - *(_QWORD *)(*((_QWORD *)v278 + 5) + 24)) >> 2))));
    while (1)
    {
      v95 = *(_DWORD **)(*((_QWORD *)v277 + 5) + 16);
      v96 = *(_QWORD *)(*((_QWORD *)v277 + 5) + 24);
      v97 = (unint64_t)(v96 - (_QWORD)v95) >> 2;
      v98 = (*(_QWORD *)(*((_QWORD *)v278 + 5) + 24) - *(_QWORD *)(*((_QWORD *)v278 + 5) + 16)) >> 2;
      if ((int)v97 - 1 < (int)v98 - 1 || !*v95)
        break;
      v99 = sub_1D3DBB164(*a1, v95[v97 + (int)(((unint64_t)v95 - v96) >> 2)], v94);
      v100 = v97 - v98;
      v101 = v269;
      sub_1D3DBAEB4((uint64_t *)&v268, *a1, v100, v99);
      sub_1D3DBB638((uint64_t *)&v283, (uint64_t)v101, (uint64_t *)&v268);
      v102 = v283;
      if (v283)
      {
        v103 = v283 + 2;
        do
          v104 = __ldxr(v103);
        while (__stxr(v104 + 1, v103));
      }
      if (v269)
        sub_1D3D6D13C(v269);
      v269 = v102;
      sub_1D3DBA894(&v283);
      sub_1D3DBA894(&v268);
      if (v100 < 0)
      {
        v222 = __cxa_allocate_exception(0x20uLL);
        sub_1D3DDE1A0(v222, "degree must not be less then 0");
        *v222 = &off_1E95AF510;
        __cxa_throw(v222, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
      }
      v106 = v277;
      v105 = v278;
      if (v99)
      {
        v107 = *((_QWORD *)v278 + 5);
        v109 = *(_QWORD *)(v107 + 16);
        v108 = *(_QWORD *)(v107 + 24);
        v110 = operator new();
        v111 = v108 - v109;
        v112 = (int)(v100 + (v111 >> 2));
        *(_DWORD *)(v110 + 8) = 0;
        v113 = (unsigned int *)(v110 + 8);
        *(_QWORD *)v110 = &off_1E95AF5E0;
        LODWORD(v279) = 0;
        sub_1D3D821BC((_QWORD *)(v110 + 16), v112, &v279);
        v284 = 0;
        v283 = (unsigned int *)&off_1E95AF9D0;
        do
          v114 = __ldxr(v113);
        while (__stxr(v114 + 1, v113));
        v285 = v110;
        if ((int)(v111 >> 2) >= 1)
        {
          v115 = 0;
          do
          {
            v116 = sub_1D3DBB164(*((_QWORD *)v105 + 2), *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v105 + 5) + 16) + v115), v99);
            *(_DWORD *)(*(_QWORD *)(v285 + 16) + v115) = v116;
            v115 += 4;
          }
          while ((v111 & 0x3FFFFFFFCLL) != v115);
        }
        v117 = operator new();
        v118 = (unsigned int *)v117;
        v119 = (unsigned int *)*((_QWORD *)v105 + 2);
        if (v119)
        {
          v120 = v119 + 2;
          do
            v121 = __ldxr(v120);
          while (__stxr(v121 + 1, v120));
        }
        v282 = v119;
        v280 = 0;
        v279 = (unsigned int *)&off_1E95AF9D0;
        v122 = v285;
        if (v285)
        {
          v123 = (unsigned int *)(v285 + 8);
          do
            v124 = __ldxr(v123);
          while (__stxr(v124 + 1, v123));
        }
        v281 = v122;
        sub_1D3DBB1C8(v117, &v282, (uint64_t)&v279);
        v125 = v118 + 2;
        do
          v126 = __ldxr(v125);
        while (__stxr(v126 + 1, v125));
        v266 = v118;
        sub_1D3D82064(&v279);
        sub_1D3D82034(&v282);
        sub_1D3D82064(&v283);
      }
      else
      {
        v127 = *((_QWORD *)v278 + 2);
        sub_1D3DBA8C4(v127);
        v128 = *(unsigned int **)(v127 + 64);
        if (v128)
        {
          v129 = v128 + 2;
          do
            v130 = __ldxr(v129);
          while (__stxr(v130 + 1, v129));
        }
        v266 = v128;
      }
      sub_1D3DBB638((uint64_t *)&v267, (uint64_t)v106, (uint64_t *)&v266);
      v131 = v267;
      if (v267)
      {
        v132 = v267 + 2;
        do
          v133 = __ldxr(v132);
        while (__stxr(v133 + 1, v132));
      }
      if (v277)
        sub_1D3D6D13C(v277);
      v277 = v131;
      sub_1D3DBA894(&v267);
      sub_1D3DBA894(&v266);
    }
    v134 = v269;
    v135 = v276;
    if (v276)
    {
      v136 = v276 + 2;
      do
        v137 = __ldxr(v136);
      while (__stxr(v137 + 1, v136));
    }
    v265 = v135;
    sub_1D3DBBA5C((uint64_t *)&v279, (uint64_t)v134, (uint64_t *)&v265);
    v138 = v279;
    v139 = v271;
    if (v271)
    {
      v140 = v271 + 2;
      do
        v141 = __ldxr(v140);
      while (__stxr(v141 + 1, v140));
    }
    v264 = v139;
    sub_1D3DBB638((uint64_t *)&v283, (uint64_t)v138, (uint64_t *)&v264);
    v142 = v283;
    if (v283)
    {
      v143 = v283 + 2;
      do
        v144 = __ldxr(v143);
      while (__stxr(v144 + 1, v143));
    }
    if (v275)
      sub_1D3D6D13C(v275);
    v275 = v142;
    sub_1D3DBA894(&v283);
    sub_1D3DBA894(&v264);
    sub_1D3DBA894(&v279);
    sub_1D3DBA894(&v265);
    v145 = v269;
    v146 = v274;
    if (v274)
    {
      v147 = v274 + 2;
      do
        v148 = __ldxr(v147);
      while (__stxr(v148 + 1, v147));
    }
    v263 = v146;
    sub_1D3DBBA5C((uint64_t *)&v279, (uint64_t)v145, (uint64_t *)&v263);
    v149 = v279;
    v150 = v270;
    if (v270)
    {
      v151 = v270 + 2;
      do
        v152 = __ldxr(v151);
      while (__stxr(v152 + 1, v151));
    }
    v262 = v150;
    sub_1D3DBB638((uint64_t *)&v283, (uint64_t)v149, (uint64_t *)&v262);
    v153 = v283;
    if (v283)
    {
      v154 = v283 + 2;
      do
        v155 = __ldxr(v154);
      while (__stxr(v155 + 1, v154));
    }
    if (v273)
      sub_1D3D6D13C(v273);
    v273 = v153;
    sub_1D3DBA894(&v283);
    sub_1D3DBA894(&v262);
    sub_1D3DBA894(&v279);
    sub_1D3DBA894(&v263);
    sub_1D3DBA894(&v269);
    sub_1D3DBA894(&v270);
    sub_1D3DBA894(&v271);
    sub_1D3DBA894(&v272);
  }
  v156 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v273 + 5) + 24) - 4);
  if (!v156)
  {
    v227 = __cxa_allocate_exception(0x20uLL);
    v228 = sub_1D3DBD59C(v227, "sigmaTilde(0) was zero");
    __cxa_throw(v228, (struct type_info *)&unk_1E95AE290, (void (*)(void *))sub_1D3DBD574);
  }
  v157 = sub_1D3DBB0DC(*a1, v156);
  sub_1D3DBBDEC((uint64_t *)&v279, (uint64_t)v273, v157);
  sub_1D3DBBDEC((uint64_t *)&v282, (uint64_t)v277, v157);
  v245 = 0;
  v246 = 0;
  v247 = 0;
  v283 = (unsigned int *)&v245;
  LOBYTE(v284) = 0;
  v158 = operator new(0x10uLL);
  v159 = (unsigned int **)v158;
  v246 = v158 + 2;
  v247 = v158 + 2;
  *v158 = 0;
  v158[1] = 0;
  v245 = (unsigned int **)v158;
  v160 = (unsigned int **)v158;
  v161 = v279;
  if (v279)
  {
    v162 = v279 + 2;
    do
      v163 = __ldxr(v162);
    while (__stxr(v163 + 1, v162));
    v164 = (unsigned int *)*v158;
    v160 = v159;
    if (*v159)
    {
      sub_1D3D6D13C(v164);
      v160 = v245;
    }
  }
  *v159 = v161;
  v165 = v282;
  if (v282)
  {
    v166 = v282 + 2;
    do
      v167 = __ldxr(v166);
    while (__stxr(v167 + 1, v166));
  }
  v168 = v160[1];
  if (v168)
    sub_1D3D6D13C(v168);
  v160[1] = v165;
  sub_1D3DBA894(&v282);
  sub_1D3DBA894(&v279);
  sub_1D3DBA894(&v273);
  sub_1D3DBA894(&v274);
  sub_1D3DBA894(&v275);
  sub_1D3DBA894(&v276);
  sub_1D3DBA894(&v277);
  sub_1D3DBA894(&v278);
  sub_1D3DBA894(&v243);
  sub_1D3DBA894(&v244);
  v169 = *v245;
  if (*v245)
  {
    v170 = v169 + 2;
    do
      v171 = __ldxr(v170);
    while (__stxr(v171 + 1, v170));
  }
  v242 = v169;
  v172 = *((_QWORD *)v169 + 5);
  v174 = *(_QWORD *)(v172 + 16);
  v173 = *(_QWORD *)(v172 + 24);
  v175 = operator new();
  v176 = v175;
  v177 = (unint64_t)(v173 - v174) >> 2;
  v178 = v177 - 1;
  if ((_DWORD)v177 == 2)
  {
    *(_DWORD *)(v175 + 8) = 0;
    v179 = (unsigned int *)(v175 + 8);
    *(_QWORD *)v175 = &off_1E95AF5E0;
    LODWORD(v279) = 0;
    sub_1D3D821BC((_QWORD *)(v175 + 16), 1uLL, &v279);
    v284 = 0;
    v283 = (unsigned int *)&off_1E95AF9D0;
    do
      v180 = __ldxr(v179);
    while (__stxr(v180 + 1, v179));
    v285 = v176;
    **(_DWORD **)(v176 + 16) = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v242 + 5) + 24) - 8);
  }
  else
  {
    *(_DWORD *)(v175 + 8) = 0;
    v181 = (unsigned int *)(v175 + 8);
    *(_QWORD *)v175 = &off_1E95AF5E0;
    v182 = (_QWORD *)(v175 + 16);
    LODWORD(v279) = 0;
    sub_1D3D821BC((_QWORD *)(v175 + 16), v178, &v279);
    v284 = 0;
    v283 = (unsigned int *)&off_1E95AF9D0;
    do
      v183 = __ldxr(v181);
    while (__stxr(v183 + 1, v181));
    v184 = 0;
    v285 = v176;
    for (i = 1; i < *(_DWORD *)(*a1 + 80) && v184 < v178; ++i)
    {
      if (!sub_1D3DBB57C((uint64_t)v242, i))
        *(_DWORD *)(*v182 + 4 * v184++) = sub_1D3DBB0DC(*a1, i);
    }
    if (v184 != v178)
    {
      v231 = __cxa_allocate_exception(0x20uLL);
      v232 = sub_1D3DBD59C(v231, "Error locator degree does not match number of roots");
      __cxa_throw(v232, (struct type_info *)&unk_1E95AE290, (void (*)(void *))sub_1D3DBD574);
    }
  }
  sub_1D3DBA894(&v242);
  v187 = v285;
  v188 = *(_QWORD *)(v285 + 24) - *(_QWORD *)(v285 + 16);
  v27 = v188 >> 2;
  if (!(v188 >> 2))
  {
    v229 = __cxa_allocate_exception(0x20uLL);
    v230 = sub_1D3DBD59C(v229, "Error exists but cannot find error location");
    __cxa_throw(v230, (struct type_info *)&unk_1E95AE290, (void (*)(void *))sub_1D3DBD574);
  }
  v189 = v245[1];
  if (v189)
  {
    v190 = v189 + 2;
    do
      v191 = __ldxr(v190);
    while (__stxr(v191 + 1, v190));
    v187 = v285;
    v240 = 0;
    v241 = v189;
    v239 = 0;
    v238 = &off_1E95AF9D0;
    if (!v285)
      goto LABEL_191;
  }
  else
  {
    v240 = 0;
    v241 = 0;
    v239 = 0;
    v238 = &off_1E95AF9D0;
  }
  v192 = (unsigned int *)(v187 + 8);
  do
    v193 = __ldxr(v192);
  while (__stxr(v193 + 1, v192));
LABEL_191:
  v240 = v187;
  v195 = *(_QWORD *)(v187 + 16);
  v194 = *(_QWORD *)(v187 + 24);
  v196 = operator new();
  v237 = v188;
  v197 = v194 - v195;
  *(_DWORD *)(v196 + 8) = 0;
  v198 = (unsigned int *)(v196 + 8);
  *(_QWORD *)v196 = &off_1E95AF5E0;
  v199 = (_QWORD *)(v196 + 16);
  LODWORD(v282) = 0;
  sub_1D3D821BC((_QWORD *)(v196 + 16), (int)(v197 >> 2), &v282);
  v280 = 0;
  v279 = (unsigned int *)&off_1E95AF9D0;
  do
    v200 = __ldxr(v198);
  while (__stxr(v200 + 1, v198));
  v281 = v196;
  if ((int)((unint64_t)v197 >> 2) >= 1)
  {
    v201 = 0;
    v202 = ((unint64_t)v197 >> 2);
    do
    {
      v203 = sub_1D3DBB0DC(*a1, *(_DWORD *)(*(_QWORD *)(v240 + 16) + 4 * v201));
      v204 = 0;
      v205 = 1;
      do
      {
        if (v201 != v204)
        {
          v206 = *a1;
          v207 = sub_1D3DBB164(*a1, *(_DWORD *)(*(_QWORD *)(v240 + 16) + 4 * v204), v203);
          v205 = sub_1D3DBB164(v206, v205, v207 ^ 1u);
        }
        ++v204;
      }
      while (v202 != v204);
      v208 = *a1;
      v209 = sub_1D3DBB57C((uint64_t)v241, v203);
      v210 = sub_1D3DBB0DC(*a1, v205);
      v211 = sub_1D3DBB164(v208, v209, v210);
      *(_DWORD *)(*v199 + 4 * v201) = v211;
      if (v235 != v234)
        *(_DWORD *)(*v199 + 4 * v201) = sub_1D3DBB164(*a1, v211, v203);
      ++v201;
    }
    while (v201 != v202);
  }
  sub_1D3D82064(&v238);
  sub_1D3DBA894(&v241);
  v212 = 0;
  v213 = *(_QWORD *)(v233 + 16);
  v214 = *(_QWORD *)(v213 + 16);
  v215 = *(_QWORD *)(v213 + 24);
  do
  {
    v216 = *a1;
    v217 = *(int *)(*(_QWORD *)(v285 + 16) + 4 * v212);
    sub_1D3DBA8C4(*a1);
    if (!(_DWORD)v217)
    {
      v224 = __cxa_allocate_exception(0x20uLL);
      sub_1D3DDE1A0(v224, "cannot give log(0)");
      *v224 = &off_1E95AF510;
      __cxa_throw(v224, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
    }
    v218 = ~*(_DWORD *)(*(_QWORD *)(v216 + 40) + 4 * v217) + ((unint64_t)(v215 - v214) >> 2);
    if ((v218 & 0x80000000) != 0
      || (v219 = *(_QWORD *)(v233 + 16),
          v214 = *(_QWORD *)(v219 + 16),
          v215 = *(_QWORD *)(v219 + 24),
          v218 >= (v215 - v214) >> 2))
    {
      v223 = __cxa_allocate_exception(0x20uLL);
      sub_1D3DDE1A0(v223, "Invalid position (ReedSolomonDecoder)");
      *v223 = &off_1E95AF510;
      __cxa_throw(v223, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
    }
    *(_DWORD *)(v214 + 4 * v218) ^= *(_DWORD *)(*(_QWORD *)(v281 + 16) + 4 * v212++);
  }
  while ((v237 >> 2) != v212);
  sub_1D3D82064(&v279);
  v220 = (void ***)sub_1D3D82064(&v283);
  v283 = (unsigned int *)&v245;
  sub_1D3DBD504(v220);
  sub_1D3DBA894(&v248);
  sub_1D3DBA894(&v253);
LABEL_208:
  sub_1D3D82064(&v254);
  sub_1D3DBA894(&v261);
  return v27;
}

void sub_1D3DBD13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,unsigned int *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,unsigned int *a37)
{
  uint64_t v37;

  sub_1D3D82034(&a28);
  MEMORY[0x1D8254C54](v37, 0x10E1C405E447FC4);
  sub_1D3D82064(&a30);
  sub_1D3DBA894(&a37);
  _Unwind_Resume(a1);
}

void sub_1D3DBD504(void ***a1)
{
  void **v1;
  unsigned int **v2;
  unsigned int **v4;
  void *v5;

  v1 = *a1;
  v2 = (unsigned int **)**a1;
  if (v2)
  {
    v4 = (unsigned int **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3DBA894(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1D3DBD578(std::exception *a1)
{
  sub_1D3DDE164(a1);
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DBD59C(_QWORD *a1, char *a2)
{
  _QWORD *result;

  result = sub_1D3DDE1A0(a1, a2);
  *result = &off_1E95AF450;
  return result;
}

void MRCSegmentationMaskGetEstimatedRegionOfInterest(uint64_t *cf)
{
  CFTypeID v2;

  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (qword_1EFE317E8 != -1)
      dispatch_once_f(&qword_1EFE317E8, 0, (dispatch_function_t)sub_1D3D93D74);
    if (v2 != qword_1EFE317F0)
      _os_assumes_log();
  }
  sub_1D3D948D0(cf + 2);
}

BOOL MRCSegmentationMaskWritePGMToFile(const void *a1, const __CFURL *a2)
{
  _BOOL8 v2;
  uint64_t Data;
  uint64_t DataType;
  uint64_t Width;
  uint64_t BytesPerRow;
  uint64_t v9;
  const std::locale::facet *v10;
  _QWORD *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  _QWORD *v14;
  const std::locale::facet *v15;
  uint64_t v16;
  std::locale::id *v17;
  uint64_t v18;
  uint64_t i;
  _QWORD *v20;
  const std::locale::facet *v21;
  uint64_t Height;
  std::locale v24;
  uint64_t v25;
  _BYTE v26[408];
  uint64_t v27;
  UInt8 buffer[1024];
  uint64_t v29;

  v2 = 0;
  v29 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    Data = MRCSegmentationMaskGetData(a1);
    DataType = MRCSegmentationMaskGetDataType(a1);
    Width = MRCSegmentationMaskGetWidth(a1);
    Height = MRCSegmentationMaskGetHeight(a1);
    BytesPerRow = MRCSegmentationMaskGetBytesPerRow(a1);
    if (DataType == 1 && (v9 = BytesPerRow, CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024)))
    {
      sub_1D3DBD9FC(&v25);
      if ((v26[*(_QWORD *)(v25 - 24) + 24] & 5) != 0)
      {
        v2 = 0;
      }
      else
      {
        sub_1D3D8C900(&v25, (uint64_t)"P2", 2);
        std::ios_base::getloc((const std::ios_base *)&v26[*(_QWORD *)(v25 - 24) - 8]);
        v10 = std::locale::use_facet(&v24, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
        std::locale::~locale(&v24);
        std::ostream::put();
        std::ostream::flush();
        v11 = (_QWORD *)std::ostream::operator<<();
        sub_1D3D8C900(v11, (uint64_t)" ", 1);
        v12 = (_QWORD *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
        v13 = std::locale::use_facet(&v24, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
        std::locale::~locale(&v24);
        std::ostream::put();
        std::ostream::flush();
        v14 = (_QWORD *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(_QWORD *)(*v14 - 24)));
        v15 = std::locale::use_facet(&v24, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
        std::locale::~locale(&v24);
        std::ostream::put();
        std::ostream::flush();
        if (Height)
        {
          v16 = 0;
          v17 = (std::locale::id *)MEMORY[0x1E0DE4A90];
          do
          {
            v18 = Data;
            for (i = Width; i; --i)
            {
              v20 = (_QWORD *)std::ostream::operator<<();
              sub_1D3D8C900(v20, (uint64_t)" ", 1);
              v18 += 4;
            }
            std::ios_base::getloc((const std::ios_base *)&v26[*(_QWORD *)(v25 - 24) - 8]);
            v21 = std::locale::use_facet(&v24, v17);
            ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
            std::locale::~locale(&v24);
            std::ostream::put();
            std::ostream::flush();
            ++v16;
            Data += v9;
          }
          while (v16 != Height);
        }
        v2 = (v26[*(_QWORD *)(v25 - 24) + 24] & 5) == 0;
      }
      v25 = *MEMORY[0x1E0DE4F48];
      *(_QWORD *)&v26[*(_QWORD *)(v25 - 24) - 8] = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 24);
      MEMORY[0x1D8254A74](v26);
      std::ostream::~ostream();
      MEMORY[0x1D8254BF4](&v27);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void sub_1D3DBD9BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11, uint64_t a12)
{
  std::locale::~locale(&a11);
  sub_1D3DBDB00(&a12);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3DBD9FC(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;

  v2 = MEMORY[0x1E0DE4FB0];
  v3 = MEMORY[0x1E0DE4FB0] + 64;
  a1[52] = MEMORY[0x1E0DE4FB0] + 64;
  v4 = a1 + 1;
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 8);
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 16);
  *a1 = v5;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v5 - 24)) = v6;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v7, a1 + 1);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *a1 = v2 + 24;
  a1[52] = v3;
  MEMORY[0x1D8254A68](v4);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 4);
  return a1;
}

void sub_1D3DBDAC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1D8254BF4](v1 + 416);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3DBDB00(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F48];
  v3 = *MEMORY[0x1E0DE4F48];
  *a1 = *MEMORY[0x1E0DE4F48];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x1D8254A74](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1D8254BF4](a1 + 52);
  return a1;
}

CGImageRef MRCSegmentationMaskCreateJetColorMapImage(const void *a1)
{
  uint64_t Data;
  uint64_t DataType;
  size_t Width;
  size_t Height;
  uint64_t BytesPerRow;
  uint64_t v7;
  size_t v8;
  const UInt8 *v9;
  const __CFData *v10;
  CGDataProvider *v11;
  CGColorSpace *DeviceRGB;
  CGImageRef v13;
  _QWORD block[9];

  if (!a1)
    return 0;
  Data = MRCSegmentationMaskGetData(a1);
  DataType = MRCSegmentationMaskGetDataType(a1);
  Width = MRCSegmentationMaskGetWidth(a1);
  Height = MRCSegmentationMaskGetHeight(a1);
  BytesPerRow = MRCSegmentationMaskGetBytesPerRow(a1);
  if (DataType != 1)
    return 0;
  v7 = BytesPerRow;
  v8 = (4 * (Width & 0x7FFFFFFFFFFFFFFLL) + 15) & 0x3FFFFFFFFFFFFFF0;
  v9 = (const UInt8 *)malloc_type_malloc(v8 * Height, 0x40AAB4DCuLL);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = sub_1D3DBDCD4;
  block[3] = &unk_1E95B2E48;
  block[4] = Data;
  block[5] = v7;
  block[6] = v9;
  block[7] = v8;
  block[8] = Width;
  dispatch_apply(Height, 0, block);
  v10 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, v8 * Height, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  v11 = CGDataProviderCreateWithCFData(v10);
  CFRelease(v10);
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v13 = CGImageCreate(Width, Height, 8uLL, 0x20uLL, v8, DeviceRGB, 0x2002u, v11, 0, 0, kCGRenderingIntentDefault);
  CGColorSpaceRelease(DeviceRGB);
  CGDataProviderRelease(v11);
  return v13;
}

_QWORD *sub_1D3DBDCD4(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  float v5;
  double v6;
  unint64_t v7;
  double *v8;
  unint64_t v9;
  double *v10;
  double *v11;
  double v12;
  int v13;
  unint64_t v14;
  double *v15;
  unint64_t v16;
  double *v17;
  double *v18;
  double v19;
  int v21;
  unint64_t v22;
  double *v23;
  unint64_t v24;
  double *v25;
  double *v26;
  double v27;
  int v28;

  if (result[8])
  {
    v2 = 0;
    v3 = result[4] + result[5] * a2;
    v4 = result[6] + result[7] * a2;
    do
    {
      v5 = *(float *)(v3 + 4 * v2);
      *(_BYTE *)(v4 + 4 * v2 + 3) = -1;
      v6 = v5;
      v7 = 5;
      v8 = (double *)&unk_1D3E6A1D8;
      do
      {
        v9 = v7 >> 1;
        v10 = &v8[3 * (v7 >> 1)];
        v12 = *v10;
        v11 = v10 + 3;
        v7 += ~(v7 >> 1);
        if (v12 > v6)
          v7 = v9;
        else
          v8 = v11;
      }
      while (v7);
      if (v8 == (double *)&unk_1D3E6A1D8)
      {
        LOBYTE(v13) = 0;
      }
      else if (v8 == (double *)&unk_1D3E6A250)
      {
        LOBYTE(v13) = 127;
      }
      else
      {
        v13 = (int)((*(v8 - 1) + (v8[1] - *(v8 - 1)) * ((v6 - *(v8 - 3)) / (*v8 - *(v8 - 3)))) * 255.0);
      }
      v14 = 6;
      v15 = (double *)&unk_1D3E6A250;
      do
      {
        v16 = v14 >> 1;
        v17 = &v15[3 * (v14 >> 1)];
        v19 = *v17;
        v18 = v17 + 3;
        v14 += ~(v14 >> 1);
        if (v19 > v6)
          v14 = v16;
        else
          v15 = v18;
      }
      while (v14);
      if (v15 == (double *)&unk_1D3E6A250 || v15 == (double *)&unk_1D3E6A2E0)
        LOBYTE(v21) = 0;
      else
        v21 = (int)((*(v15 - 1) + (v15[1] - *(v15 - 1)) * ((v6 - *(v15 - 3)) / (*v15 - *(v15 - 3)))) * 255.0);
      v22 = 5;
      v23 = (double *)&unk_1D3E6A2E0;
      do
      {
        v24 = v22 >> 1;
        v25 = &v23[3 * (v22 >> 1)];
        v27 = *v25;
        v26 = v25 + 3;
        v22 += ~(v22 >> 1);
        if (v27 > v6)
          v22 = v24;
        else
          v23 = v26;
      }
      while (v22);
      if (v23 == (double *)&unk_1D3E6A2E0)
      {
        LOBYTE(v28) = 127;
      }
      else if (v23 == (double *)"N5zxing6StringE")
      {
        LOBYTE(v28) = 0;
      }
      else
      {
        v28 = (int)((*(v23 - 1) + (v23[1] - *(v23 - 1)) * ((v6 - *(v23 - 3)) / (*v23 - *(v23 - 3)))) * 255.0);
      }
      *(_BYTE *)(v4 + ((4 * v2) | 2)) = v13;
      *(_BYTE *)(v4 + ((4 * v2) | 1)) = v21;
      *(_BYTE *)(v4 + 4 * v2++) = v28;
    }
    while (v2 < result[8]);
  }
  return result;
}

uint64_t sub_1D3DBDEDC(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E95AF718;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void sub_1D3DBDF18(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E95AF718;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DBDF68()
{
  JUMPOUT(0x1D8254C54);
}

float sub_1D3DBDF7C(float *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  float *v7;
  float v8;
  float v9;
  float result;

  v2 = *a2;
  v3 = a2[1];
  v4 = v3 - *a2;
  if (v3 != *a2)
  {
    v5 = 0;
    v6 = v4 >> 2;
    do
    {
      v7 = (float *)(v2 + 4 * v5);
      v8 = *v7;
      v9 = v7[1];
      *v7 = (float)((float)((float)((float)(a1[3] + (float)(a1[4] * *v7)) + (float)(a1[5] * v9))
                          + (float)((float)(*v7 * a1[6]) * *v7))
                  + (float)((float)(*v7 * a1[7]) * v9))
          + (float)((float)(v9 * a1[8]) * v9);
      result = (float)((float)((float)((float)(a1[9] + (float)(a1[10] * v8)) + (float)(a1[11] * v9))
                             + (float)((float)(v8 * a1[12]) * v8))
                     + (float)((float)(v8 * a1[13]) * v9))
             + (float)((float)(v9 * a1[14]) * v9);
      v7[1] = result;
      v5 += 2;
    }
    while (v6 > v5);
  }
  return result;
}

uint64_t sub_1D3DBE008(float *a1, uint64_t *a2, _QWORD *a3)
{
  unsigned int *v3;
  unsigned int v4;
  _BOOL8 v5;
  float *v7;

  if (*a2 == a2[1] && *a3 == a3[1])
    return 1;
  if (a1)
  {
    v3 = (unsigned int *)(a1 + 2);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v7 = a1;
  v5 = sub_1D3DBE07C(&v7, a2, a3);
  sub_1D3DBE3CC((unsigned int **)&v7);
  return v5;
}

BOOL sub_1D3DBE07C(float **a1, uint64_t *a2, _QWORD *a3)
{
  unint64_t v6;
  int v7;
  int v8;
  size_t v9;
  char *v10;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  float v18;
  char *v19;
  float v20;
  double v21;
  float *v22;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;

  v6 = (unint64_t)(a2[1] - *a2) >> 2;
  if ((v6 & 0x80000000) == 0)
    v7 = (unint64_t)(a2[1] - *a2) >> 2;
  else
    v7 = v6 + 1;
  v8 = v7 >> 1;
  if ((int)v6 < -1)
    v9 = -1;
  else
    v9 = 104 * v8;
  v10 = (char *)operator new[]();
  v11 = 2 * v8;
  bzero(v10, v9);
  if ((int)v6 >= 2)
  {
    v13 = 0;
    v14 = (uint64_t)v7 >> 1;
    v15 = *a2;
    v16 = *a3 + 4;
    do
    {
      v17 = *(float *)(v15 + v13);
      v18 = *(float *)(v15 + v13 + 4);
      *(_DWORD *)&v10[48 * (int)v14 + 4 + v13] = 1065353216;
      *(_DWORD *)&v10[v13] = 1065353216;
      *(float *)&v10[56 * (int)v14 + 4 + v13] = v17;
      *(float *)&v10[4 * v11 + v13] = v17;
      *(float *)&v10[64 * (int)v14 + 4 + v13] = v18;
      *(float *)&v10[16 * v14 + v13] = v18;
      *(float *)&v10[72 * (int)v14 + 4 + v13] = v17 * v17;
      *(float *)&v10[24 * (int)v14 + v13] = v17 * v17;
      v19 = &v10[96 * (int)v14 + 4 + v13];
      v20 = v17 * v18;
      *(float *)&v10[80 * (int)v14 + 4 + v13] = v20;
      *(float *)&v10[32 * v14 + v13] = v20;
      *(float *)&v10[88 * (int)v14 + 4 + v13] = v18 * v18;
      *(float *)&v10[40 * (int)v14 + v13] = v18 * v18;
      *((_DWORD *)v19 - 1) = *(_DWORD *)(v16 + v13 - 4);
      v12.n128_u32[0] = *(_DWORD *)(v16 + v13);
      *(_DWORD *)v19 = v12.n128_u32[0];
      v13 += 8;
    }
    while (8 * (v7 >> 1) != v13);
  }
  MEMORY[0x1E0C80A78](v12);
  sgesvd_NEWLAPACK();
  MEMORY[0x1D8254C3C](v10, 0x1000C8052888210);
  v21 = fabsf(v36);
  if (v21 >= 0.00001)
  {
    v22 = *a1;
    v22[3] = v24 / (float)-v36;
    v22[4] = v25 / (float)-v36;
    v22[5] = v26 / (float)-v36;
    v22[6] = v27 / (float)-v36;
    v22[7] = v28 / (float)-v36;
    v22[8] = v29 / (float)-v36;
    v22[9] = v30 / (float)-v36;
    v22[10] = v31 / (float)-v36;
    v22[11] = v32 / (float)-v36;
    v22[12] = v33 / (float)-v36;
    v22[13] = v34 / (float)-v36;
    v22[14] = v35 / (float)-v36;
  }
  return v21 >= 0.00001;
}

void sub_1D3DBE3C0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_1D3D6D5A8(a1);
}

unsigned int **sub_1D3DBE3CC(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

void sub_1D3DBE400(uint64_t a1)
{
  sub_1D3DBF89C(a1);
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DBE424(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t *v5;
  unsigned int **v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  void *v10;
  uint64_t *v11;
  CFTypeID v12;
  uint64_t v13;
  unsigned int **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  CFTypeID v24;
  _QWORD v25[5];
  _QWORD *v26;
  unint64_t v27;
  _QWORD v28[3];
  _QWORD *v29;
  const __CFString *v30;
  uint64_t v31;
  unsigned int *v32[3];
  unsigned int **v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 144);
  if (v3)
    goto LABEL_30;
  v25[0] = MEMORY[0x1E0C809B0];
  v25[1] = 3221225472;
  v25[2] = sub_1D3DBE804;
  v25[3] = &unk_1E95B2E68;
  v25[4] = a1;
  v26 = v25;
  v28[0] = &off_1E95AFEE0;
  v28[1] = &v26;
  v29 = v28;
  if (!*(_BYTE *)(a1 + 136))
  {
    v8 = (void *)MEMORY[0x1D8255128]();
    v30 = CFSTR("_MRCContextOptionIsOneShot");
    v31 = MEMORY[0x1E0C9AAB0];
    objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v9, (uint64_t)&v31, &v30, 1);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v27 = MRCContextCreateWithOptions(v10);
    v11 = (uint64_t *)atomic_load(&v27);
    if (v11)
    {
      v12 = CFGetTypeID(v11);
      if (qword_1EDB893E0 != -1)
      {
        v24 = v12;
        dispatch_once_f(&qword_1EDB893E0, 0, (dispatch_function_t)sub_1D3D73FB8);
        v12 = v24;
      }
      if (v12 != qword_1EDB893D8)
        _os_assumes_log();
    }
    v13 = (uint64_t)v29;
    if (v29)
    {
      if (v29 == v28)
      {
        v33 = v32;
        (*(void (**)(_QWORD *, unsigned int **))(v28[0] + 24))(v28, v32);
LABEL_18:
        sub_1D3DBE984(v11 + 2, v32);
        v14 = v33;
        if (v33 == v32)
        {
          v15 = 4;
          v14 = v32;
        }
        else
        {
          if (!v33)
          {
LABEL_23:
            sub_1D3DBEEE4(&v27);

            objc_autoreleasePoolPop(v8);
            goto LABEL_24;
          }
          v15 = 5;
        }
        (*(void (**)(void))&(*v14)[2 * v15])();
        goto LABEL_23;
      }
      v13 = (*(uint64_t (**)(void))(*v29 + 16))();
    }
    v33 = (unsigned int **)v13;
    goto LABEL_18;
  }
  v5 = *(uint64_t **)(a1 + 128);
  v33 = v32;
  v32[0] = (unsigned int *)&off_1E95AFEE0;
  v32[1] = (unsigned int *)&v26;
  sub_1D3DBE984(v5, v32);
  v6 = v33;
  if (v33 == v32)
  {
    v7 = 4;
    v6 = v32;
  }
  else
  {
    if (!v33)
      goto LABEL_24;
    v7 = 5;
  }
  (*(void (**)(void))&(*v6)[2 * v7])();
LABEL_24:
  v16 = v29;
  if (v29 == v28)
  {
    v17 = 4;
    v16 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_29;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_29:

  v3 = *(_QWORD *)(a1 + 144);
  if (v3)
  {
LABEL_30:
    *a2 = 0;
LABEL_31:
    v18 = (unsigned int *)(v3 + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
    goto LABEL_33;
  }
  sub_1D3DC0640((unsigned int **)a1, (uint64_t *)v32);
  v20 = v32[0];
  if (v32[0])
  {
    v21 = v32[0] + 2;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  v23 = *(unsigned int **)(a1 + 144);
  if (v23)
    sub_1D3D6D13C(v23);
  *(_QWORD *)(a1 + 144) = v20;
  sub_1D3D6D10C(v32);
  v3 = *(_QWORD *)(a1 + 144);
  *a2 = 0;
  if (v3)
    goto LABEL_31;
LABEL_33:
  *a2 = v3;
}

void sub_1D3DBE724(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1D3D6D10C((unsigned int **)(v1 - 88));
  _Unwind_Resume(a1);
}

void sub_1D3DBE804(uint64_t a1, void *a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  double Width;
  CGFloat Height;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  double MinX;
  double MinY;
  double v14;
  const char *v15;
  _QWORD v16[6];
  CGRect v17;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void *)objc_msgSend_newTextureByBinarizingPixelBuffer_error_(a2, (const char *)a2, *(_QWORD *)(v2 + 88), 0);
  if (v3)
  {
    v4 = operator new();
    Width = CGRectGetWidth(*(CGRect *)(v2 + 96));
    Height = CGRectGetHeight(*(CGRect *)(v2 + 96));
    sub_1D3D938C4(v4, (unint64_t)Width, (unint64_t)Height);
    v7 = (unsigned int *)(v4 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v9 = *(unsigned int **)(v2 + 144);
    if (v9)
      sub_1D3D6D13C(v9);
    *(_QWORD *)(v2 + 144) = v4;
    v10 = *(_QWORD *)(v4 + 48);
    v11 = *(_QWORD *)(v4 + 24);
    MinX = CGRectGetMinX(*(CGRect *)(v2 + 96));
    MinY = CGRectGetMinY(*(CGRect *)(v2 + 96));
    v14 = CGRectGetWidth(*(CGRect *)(v2 + 96));
    v17 = *(CGRect *)(v2 + 96);
    v16[0] = vcvtmd_u64_f64(MinX) >> 3;
    v16[1] = vcvtmd_u64_f64(MinY);
    v16[2] = 0;
    v16[3] = (vcvtpd_u64_f64(v14) + 7) >> 3;
    v16[4] = vcvtpd_u64_f64(CGRectGetHeight(v17));
    v16[5] = 1;
    objc_msgSend_getBytes_bytesPerRow_fromRegion_mipmapLevel_(v3, v15, v10, (unint64_t)(v11 + 7) >> 3, v16, 0);
  }

}

void sub_1D3DBE954(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  MEMORY[0x1D8254C54](v2, 0x1091C409401DBA8);

  _Unwind_Resume(a1);
}

void sub_1D3DBE984(uint64_t *a1, _QWORD *a2)
{
  _QWORD *v2;
  os_unfair_lock_s *v5;
  _QWORD *v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD *v9;
  uint64_t v10;
  NSObject *v11;
  dispatch_queue_t v12;
  uint64_t (*v13)(_QWORD);
  CFTypeRef v14;
  CFTypeRef v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  void *v36;
  __int128 v37;
  _BYTE v38[24];
  _BYTE *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t context[3];
  uint64_t *v43;
  char v44;
  unint64_t v45[3];
  unint64_t *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v2 = a2 + 3;
  if (!a2[3])
    return;
  v5 = (os_unfair_lock_s *)(a1 + 1);
  os_unfair_lock_lock_with_options();
  v6 = sub_1D3D967F4(a1 + 3, (unint64_t)&unk_1D3E6A3A8);
  if (!v6)
  {
    v7 = *a1;
    v8 = a1[2];
    v36 = &unk_1D3E6A3A8;
    *(_QWORD *)&v37 = "MetalHybridBinarizerContext";
    *((_QWORD *)&v37 + 1) = 27;
    v9 = (_QWORD *)operator new();
    v10 = operator new();
    v11 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v12 = dispatch_queue_create_with_target_V2("mrc::Context::ConcreteBase<quagga::(anonymous namespace)::MetalHybridBinarizerContext>::ConcreteBase(const Options &, dispatch_queue_t _Nonnull) [_Derived = quagga::(anonymous namespace)::MetalHybridBinarizerContext]", v11, v8);
    v13 = MEMORY[0x1E0C82E98];
    *(_QWORD *)(v10 + 8) = v12;
    *(_QWORD *)(v10 + 16) = v13;
    *(_QWORD *)v10 = &off_1E95AFAC8;
    *(_QWORD *)(v10 + 24) = *(_QWORD *)v7;
    v14 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 8));
    if (v14)
      v14 = CFRetain(v14);
    *(_QWORD *)(v10 + 32) = v14;
    v15 = (CFTypeRef)atomic_load((unint64_t *)(v7 + 16));
    if (v15)
      v15 = CFRetain(v15);
    *(_QWORD *)(v10 + 40) = v15;
    v16 = *(_OWORD *)(v7 + 24);
    v17 = *(_OWORD *)(v7 + 40);
    *(_WORD *)(v10 + 80) = *(_WORD *)(v7 + 56);
    *(_OWORD *)(v10 + 48) = v16;
    *(_OWORD *)(v10 + 64) = v17;
    *(_QWORD *)(v10 + 88) = 0;
    *(_BYTE *)(v10 + 96) = 0;
    *(_BYTE *)(v10 + 192) = 0;
    *v9 = v10;
    v18 = (_QWORD *)operator new();
    *v18 = &off_1E95B0468;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = v10;
    v9[1] = v18;
    v45[0] = (unint64_t)&off_1E95AFC20;
    v46 = v45;
    v40 = v9;
    sub_1D3D96968((uint64_t)&v41, (uint64_t)v45);
    sub_1D3E23E40((uint64_t)context, (uint64_t)&unk_1D3E6A3A8, &v37, (uint64_t *)&v40);
    sub_1D3D969CC((uint64_t *)&v40);
    v19 = v46;
    if (v46 == v45)
    {
      v20 = 4;
      v19 = v45;
    }
    else
    {
      if (!v46)
      {
LABEL_12:
        v6 = sub_1D3D96A58(a1 + 3, &v36, context);
        sub_1D3D969CC((uint64_t *)&v43);
        sub_1D3E23B04(a1);
        goto LABEL_13;
      }
      v20 = 5;
    }
    (*(void (**)(void))(*v19 + 8 * v20))();
    goto LABEL_12;
  }
LABEL_13:
  if ((_UNKNOWN *)v6[3] != &unk_1D3E6A3A8)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_47:
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  v21 = (uint64_t *)v6[6];
  if (!v21)
    goto LABEL_47;
  v23 = *v21;
  v22 = (std::__shared_weak_count *)v21[1];
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
  }
  os_unfair_lock_unlock(v5);
  if (!v23)
  {
    v45[0] = 0;
    sub_1D3DF4E68((uint64_t)&v40, -1, 0);
    sub_1D3DF50BC(context, (uint64_t *)&v40);
    v44 = 1;
    if (!*v2)
      sub_1D3D75A24();
    (*(void (**)(_QWORD, unint64_t *, uint64_t *))(*(_QWORD *)*v2 + 48))(*v2, v45, context);
    if (v44)
      sub_1D3DF4F24((unint64_t *)context);
    sub_1D3DF4F24((unint64_t *)&v40);
    sub_1D3D8BA0C(v45);
    goto LABEL_40;
  }
  if (!*v2)
  {
    v2 = &v39;
    goto LABEL_27;
  }
  if ((_QWORD *)*v2 != a2)
  {
    v39 = (_BYTE *)*v2;
LABEL_27:
    *v2 = 0;
    goto LABEL_29;
  }
  v39 = v38;
  (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v38);
LABEL_29:
  if (!v39)
    goto LABEL_40;
  context[0] = (uint64_t)&off_1E95AFF38;
  context[1] = v23;
  context[2] = (uint64_t)v38;
  v43 = context;
  dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v23 + 8), context, (dispatch_function_t)sub_1D3DBEF98);
  v30 = v43;
  if (v43 == context)
  {
    v31 = 4;
    v30 = context;
  }
  else
  {
    if (!v43)
      goto LABEL_35;
    v31 = 5;
  }
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(*v30 + 8 * v31))(v30, v26, v27, v28, v29);
LABEL_35:
  v32 = v39;
  if (v39 == v38)
  {
    v33 = 4;
    v32 = v38;
  }
  else
  {
    if (!v39)
      goto LABEL_40;
    v33 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*v32 + 8 * v33))(v32, v26, v27, v28, v29);
LABEL_40:
  if (v22)
  {
    v34 = (unint64_t *)&v22->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void sub_1D3DBEDBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a2)
    sub_1D3D6D5A8(exception_object);
  _Unwind_Resume(exception_object);
}

unint64_t *sub_1D3DBEEE4(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1D3DBEF1C(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 192))
      sub_1D3DF4F24((unint64_t *)(result + 96));
    sub_1D3D8BA0C((unint64_t *)(v1 + 88));
    sub_1D3D8BA0C((unint64_t *)(v1 + 40));
    sub_1D3D8BA0C((unint64_t *)(v1 + 32));
    v2 = *(_QWORD *)(v1 + 8);
    *(_QWORD *)v1 = &off_1E95AEE40;
    *(_QWORD *)(v1 + 8) = 0;
    if (v2)
      (*(void (**)(void))(v1 + 16))();
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3DBEF98(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (!v1)
    sub_1D3D75A24();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void sub_1D3DBEFC0()
{
  JUMPOUT(0x1D8254C54);
}

__n128 sub_1D3DBEFD4(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E95AFF38;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1D3DBF00C(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E95AFF38;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unint64_t *sub_1D3DBF02C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *result;
  unint64_t *v7;
  void *v9;
  void *v10;
  id v11;
  _MRCMetalContext *v12;
  const char *v13;
  void *v14;
  id v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  unint64_t v19;
  unsigned int v20;
  int v22;
  unsigned int v23;
  unint64_t v24;
  BOOL v25;
  int v26;
  uint64_t v28;
  _MRCMetalHybridBinarizer *v29;
  const char *v30;
  void *v31;
  id v32;
  id v33;
  unint64_t v34;
  const void *v35;
  unint64_t *v36;
  unint64_t v37;
  const void *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44[12];
  id v45[12];
  char v46;
  id v47[2];

  v2 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v2 + 192))
  {
    v3 = *(_QWORD *)(a1 + 16);
    v44[0] = 0;
    sub_1D3DF4F6C((uint64_t)v45, v2 + 96);
    v46 = 1;
    v4 = *(_QWORD *)(v3 + 24);
    if (!v4)
      sub_1D3D75A24();
    (*(void (**)(uint64_t, uint64_t *, id *))(*(_QWORD *)v4 + 48))(v4, v44, v45);
    if (v46)
      sub_1D3DF4F24((unint64_t *)v45);
    v5 = (unint64_t *)v44;
    return sub_1D3D8BA0C(v5);
  }
  v7 = (unint64_t *)(v2 + 88);
  if (!atomic_load((unint64_t *)(v2 + 88)))
  {
    v9 = (void *)MEMORY[0x1D8255128]();
    sub_1D3E18620((uint64_t *)v45, v2 + 24);
    v10 = (void *)atomic_load((unint64_t *)v45);
    v11 = v10;
    sub_1D3D8BA0C((unint64_t *)v45);
    v12 = [_MRCMetalContext alloc];
    v45[0] = 0;
    v14 = (void *)objc_msgSend_initWithDevice_libraryURL_error_(v12, v13, (uint64_t)v11, 0, v45);
    v15 = v45[0];
    v18 = v15;
    if (v14)
    {
      HIDWORD(v19) = *(_DWORD *)(v2 + 48) - 9;
      LODWORD(v19) = HIDWORD(v19);
      v20 = (0x22u >> (v19 >> 2)) & 1;
      if ((v19 >> 2) <= 6 && v20 == 0)
      {
        objc_msgSend_commandQueue(v14, v16, v17);
        objc_claimAutoreleasedReturnValue();
        v22 = *(_DWORD *)(v2 + 48) - 9;
        HIDWORD(v24) = v22;
        LODWORD(v24) = v22;
        v23 = v24 >> 2;
        v25 = v23 > 6;
        v26 = (1 << v23) & 0x5D;
        if (v25 || v26 == 0)
          v22 = qos_class_self() - 9;
        HIDWORD(v28) = v22;
        LODWORD(v28) = v22;
        __asm { BR              X10 }
      }
      v29 = [_MRCMetalHybridBinarizer alloc];
      v47[0] = v18;
      v31 = (void *)objc_msgSend_initWithMetalContext_error_(v29, v30, (uint64_t)v14, v47);
      v32 = v47[0];

      v33 = v31;
      v44[0] = (uint64_t)v33;
      do
        v34 = __ldaxr((unint64_t *)v44);
      while (__stlxr(0, (unint64_t *)v44));
      do
        v35 = (const void *)__ldaxr(v7);
      while (__stlxr(v34, v7));
      if (v35)
        CFRelease(v35);
      sub_1D3D8BA0C((unint64_t *)v44);

    }
    else
    {
      v32 = v15;
    }

    if (v32)
    {
      v45[0] = (id)CFRetain(v32);
      if (*(_BYTE *)(v2 + 192))
        sub_1D3DF4F24((unint64_t *)(v2 + 96));
      *(_OWORD *)(v2 + 160) = 0u;
      v36 = (unint64_t *)(v2 + 160);
      *(_OWORD *)(v2 + 128) = 0u;
      *(_OWORD *)(v2 + 144) = 0u;
      *(_OWORD *)(v2 + 112) = 0u;
      *(_QWORD *)(v2 + 96) = -1;
      *(_QWORD *)(v2 + 104) = 0;
      *(_OWORD *)(v2 + 176) = 0u;
      *(_BYTE *)(v2 + 192) = 1;
      do
        v37 = __ldaxr((unint64_t *)v45);
      while (__stlxr(0, (unint64_t *)v45));
      do
        v38 = (const void *)__ldaxr(v36);
      while (__stlxr(v37, v36));
      if (v38)
        CFRelease(v38);
      sub_1D3D7448C((unint64_t *)v45);
    }

    objc_autoreleasePoolPop(v9);
  }
  v39 = atomic_load(v7);
  v40 = *(_QWORD *)(a1 + 16);
  if (!v39)
  {
    v47[0] = 0;
    v42 = *(unsigned __int8 *)(v2 + 192);
    if (*(_BYTE *)(v2 + 192))
    {
      sub_1D3DF4F6C((uint64_t)v45, v2 + 96);
    }
    else
    {
      sub_1D3DF4E68((uint64_t)v44, -1, 0);
      sub_1D3DF50BC(v45, v44);
    }
    v46 = 1;
    v43 = *(_QWORD *)(v40 + 24);
    if (!v43)
      sub_1D3D75A24();
    (*(void (**)(uint64_t, id *, id *))(*(_QWORD *)v43 + 48))(v43, v47, v45);
    if (v46)
      sub_1D3DF4F24((unint64_t *)v45);
    if (!v42)
      sub_1D3DF4F24((unint64_t *)v44);
    v5 = (unint64_t *)v47;
    return sub_1D3D8BA0C(v5);
  }
  LOBYTE(v45[0]) = 0;
  v46 = 0;
  v41 = *(_QWORD *)(v40 + 24);
  if (!v41)
    sub_1D3D75A24();
  result = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, id *))(*(_QWORD *)v41 + 48))(v41, v2 + 88, v45);
  if (v46)
    return sub_1D3DF4F24((unint64_t *)v45);
  return result;
}

void sub_1D3DBF3E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t sub_1D3DBF4BC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN6quagga12_GLOBAL__N_127MetalHybridBinarizerContext7performENSt3__18functionIFvRKN3mrc5CFRefIPKvEEONS2_8optionalINS4_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DBF4F4()
{
  return &unk_1E95AEB90;
}

void sub_1D3DBF504()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DBF518()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95AFC20;
  return result;
}

void sub_1D3DBF53C(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95AFC20;
}

uint64_t sub_1D3DBF554(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
  {
    sub_1D3D96F10(result);
    JUMPOUT(0x1D8254C54);
  }
  return result;
}

uint64_t sub_1D3DBF588(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeIN6quagga12_GLOBAL__N_127MetalHybridBinarizerContextEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DBF5C0()
{
  return &unk_1E95AEB00;
}

void sub_1D3DBF5D0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DBF5F4(uint64_t a1)
{
  return sub_1D3DBEF1C(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1D3DBF5FC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6quagga12_GLOBAL__N_127MetalHybridBinarizerContextEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1D3DBF638(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE40;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DBF674(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE40;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DBF6C0(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 192))
    sub_1D3DF4F24((unint64_t *)(a1 + 96));
  sub_1D3D8BA0C((unint64_t *)(a1 + 88));
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE40;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  return a1;
}

void sub_1D3DBF724(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 192))
    sub_1D3DF4F24((unint64_t *)(a1 + 96));
  sub_1D3D8BA0C((unint64_t *)(a1 + 88));
  sub_1D3D8BA0C((unint64_t *)(a1 + 40));
  sub_1D3D8BA0C((unint64_t *)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E95AEE40;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 16))();
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DBF79C()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DBF7B0(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AFEE0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DBF7E4(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AFEE0;
  a2[1] = v2;
  return result;
}

void sub_1D3DBF800(uint64_t a1, unint64_t *a2)
{
  void *v4;
  unint64_t v6;

  v4 = (void *)MEMORY[0x1D8255128]();
  if (atomic_load(a2))
    v6 = atomic_load(a2);
  else
    v6 = 0;
  (*(void (**)(_QWORD, unint64_t))(**(_QWORD **)(a1 + 8) + 16))(**(_QWORD **)(a1 + 8), v6);
  objc_autoreleasePoolPop(v4);
}

uint64_t sub_1D3DBF858(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN6quagga12_GLOBAL__N_118performWithContextERKNSt3__18optionalINS1_17reference_wrapperIN3mrc7ContextEEEEEU13block_pointerFvP24_MRCMetalHybridBinarizerEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DBF890()
{
  return &unk_1E95AEB80;
}

uint64_t sub_1D3DBF89C(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AFAE8;
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 88));
  sub_1D3D6D10C((unsigned int **)(a1 + 144));
  return sub_1D3DC18AC(a1);
}

unint64_t *sub_1D3DBF8DC@<X0>(uint64_t *a1@<X0>, CFErrorRef *a2@<X8>)
{
  unint64_t *result;
  uint64_t v4;
  unint64_t v5[12];
  char v6;
  _QWORD v7[3];
  unint64_t *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  LOBYTE(v5[0]) = 0;
  v6 = 0;
  v7[0] = &off_1E95AD9F0;
  v7[1] = v5;
  v8 = v7;
  sub_1D3DBE984(a1, v7);
  result = v8;
  if (v8 == v7)
  {
    v4 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      goto LABEL_6;
    v4 = 5;
  }
  result = (unint64_t *)(*(uint64_t (**)(void))(*result + 8 * v4))();
LABEL_6:
  if (v6)
  {
    result = sub_1D3DF53CC(a2, (uint64_t)v5);
    if (v6)
      return sub_1D3DF4F24(v5);
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1D3DBF9AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21)
    sub_1D3DF4F24((unint64_t *)&a9);
  _Unwind_Resume(exception_object);
}

void sub_1D3DBFA00()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DBFA14(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95AD9F0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DBFA48(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95AD9F0;
  a2[1] = v2;
  return result;
}

unint64_t *sub_1D3DBFA64(unint64_t *result, unint64_t *a2, uint64_t a3)
{
  if (!atomic_load(a2))
    return sub_1D3D74C98((unint64_t *)result[1], a3);
  return result;
}

uint64_t sub_1D3DBFA7C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN6quagga20MetalHybridBinarizer19preflightForContextERN3mrc7ContextEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DBFAB4()
{
  return &unk_1E95AD038;
}

std::string *sub_1D3DBFAC0(std::string *a1, const std::string::value_type *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  const std::string::value_type *v11;
  std::string::size_type v12;
  std::string::value_type *v14;
  std::string::value_type *v15;
  const std::string::value_type *v16;
  BOOL v17;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  const std::string::value_type *v25;
  void *__src;
  uint64_t v27;
  _BYTE __len[12];
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  int v32;
  uint8_t buf[4];
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v6 = MEMORY[0x1D8255020]("UTF-8", a3);
  if (v6 == -1)
  {
    if (qword_1EFE31880 != -1)
      dispatch_once(&qword_1EFE31880, &unk_1E95B3648);
    v9 = qword_1EFE31878;
    if (os_log_type_enabled((os_log_t)qword_1EFE31878, OS_LOG_TYPE_ERROR))
    {
      v24 = *__error();
      *(_DWORD *)__len = 136446722;
      *(_QWORD *)&__len[4] = "UTF-8";
      v29 = 2082;
      v30 = a3;
      v31 = 1026;
      v32 = v24;
      _os_log_error_impl(&dword_1D3D6B000, v9, OS_LOG_TYPE_ERROR, "[ZXing] iconv_open(\"%{public}s\", \"%{public}s\") failed: %{public, errno}d", __len, 0x1Cu);
    }
    v10 = a2[23];
    if (v10 >= 0)
      v11 = a2;
    else
      v11 = *(const std::string::value_type **)a2;
    if (v10 >= 0)
      v12 = *((unsigned __int8 *)a2 + 23);
    else
      v12 = *((_QWORD *)a2 + 1);
    return std::string::append(a1, v11, v12);
  }
  else
  {
    v7 = v6;
    if (a2[23] < 0)
      v8 = *((_QWORD *)a2 + 1);
    else
      v8 = *((unsigned __int8 *)a2 + 23);
    v27 = v8;
    *(_QWORD *)__len = 4 * v8;
    v14 = (std::string::value_type *)malloc_type_malloc((4 * v8) | 1, 0x5EBAF320uLL);
    v15 = v14;
    if (a2[23] >= 0)
      v16 = a2;
    else
      v16 = *(const std::string::value_type **)a2;
    v25 = v16;
    __src = v14;
    if (v14)
      v17 = v16 == 0;
    else
      v17 = 1;
    if (!v17 && v8 != 0)
    {
      while (1)
      {
        while (1)
        {
          v19 = __src;
          v20 = MEMORY[0x1D8255008](v7, &v25, &v27, &__src, __len);
          if ((_BYTE *)__src - v19 >= 1)
            std::string::append(a1, v15, (_BYTE *)__src - v19);
          if (v20 == -1)
            break;
          v8 = v27;
          if (!v27)
            goto LABEL_27;
        }
        if (*__error() != 7)
        {
          if (qword_1EFE31880 != -1)
            dispatch_once(&qword_1EFE31880, &unk_1E95B3648);
          v22 = qword_1EFE31878;
          if (os_log_type_enabled((os_log_t)qword_1EFE31878, OS_LOG_TYPE_ERROR))
            goto LABEL_44;
          goto LABEL_27;
        }
        v21 = v27;
        if (v8 == v27)
          break;
        memmove(v15, __src, *(size_t *)__len);
        __src = v15;
        v8 = v21;
        if (!v21)
          goto LABEL_27;
      }
      if (qword_1EFE31880 != -1)
        dispatch_once(&qword_1EFE31880, &unk_1E95B3648);
      v22 = qword_1EFE31878;
      if (os_log_type_enabled((os_log_t)qword_1EFE31878, OS_LOG_TYPE_ERROR))
      {
LABEL_44:
        v23 = *__error();
        *(_DWORD *)buf = 67240192;
        v34 = v23;
        _os_log_error_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_ERROR, "[ZXing] iconv failed: %{public, errno}d", buf, 8u);
      }
    }
LABEL_27:
    free(v15);
    return (std::string *)MEMORY[0x1D8255014](v7);
  }
}

void sub_1D3DBFDE8(uint64_t a1)
{
  sub_1D3DC0540(a1);
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3DBFE0C@<X0>(unsigned int **result@<X0>, unsigned int **a2@<X8>)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int **v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int *v14;
  int v15;
  int v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned __int8 *v26;
  unsigned int *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int *v34;
  int v35;
  unsigned __int8 *v36;
  _DWORD *v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  unsigned int *v50;
  unsigned int *v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  unsigned int v59;
  signed int v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int *v66;
  unsigned int v67;
  char v68;
  unsigned int *v69;
  unsigned int *v70;
  unsigned int v71;
  unsigned int **v72;
  unsigned int *v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  unsigned int *v81;
  unsigned int *v82;

  v3 = result[3];
  if (v3)
  {
    v4 = v3 + 2;
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *a2 = v3;
  }
  else
  {
    v6 = result;
    v7 = result[2];
    if (v7)
    {
      v8 = v7 + 2;
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    v81 = v7;
    v10 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v7 + 16))(v7);
    v11 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v81 + 24))(v81);
    v12 = v11;
    if (v11 >= v10)
      v13 = v10;
    else
      v13 = v11;
    v14 = (unsigned int *)operator new();
    v76 = v12;
    sub_1D3D938C4((uint64_t)v14, v10, v12);
    v15 = (int)(float)((float)((float)((float)((float)v13 * 0.13) / 6.0) * 0.5) + 1.0);
    v16 = 6 * v15;
    v17 = v14 + 2;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
    v82 = v14;
    if (v10 < v16 || v12 < v16)
      goto LABEL_54;
    v19 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v81 + 48))(v81);
    v20 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v81 + 32))(v81);
    v72 = a2;
    v21 = v10 + 1;
    v22 = v6[4];
    v22[v21] = 0;
    *v22 = 0;
    v74 = v21;
    v23 = v21;
    if (v10 >= 1)
    {
      v24 = v10;
      v25 = v22;
      v26 = (unsigned __int8 *)v19;
      do
      {
        v27 = &v25[v23];
        v25[1] = 0;
        ++v25;
        v28 = *v26++;
        v27[1] = *v27 + v28;
        --v24;
      }
      while (v24);
    }
    v73 = v22;
    if (v12 > 1)
    {
      v29 = v20;
      v30 = 1;
      v31 = (uint64_t)&v22[2 * v74 + 2];
      v32 = v19 + v20 + 1;
      do
      {
        v33 = v30 * v29;
        v34 = &v73[++v30 * v74];
        *v34 = 0;
        v34[1] = *(unsigned __int8 *)(v19 + v33);
        if (v10 >= 2)
        {
          v35 = *(unsigned __int8 *)(v19 + v33);
          v36 = (unsigned __int8 *)v32;
          v37 = (_DWORD *)v31;
          v38 = v10 - 1;
          v39 = 1 - v10;
          do
          {
            v40 = *v36++;
            v35 += v40;
            *v37++ = v35 + v34[v39++];
            --v38;
          }
          while (v38);
        }
        v31 += v23 * 4;
        v32 += v29;
      }
      while (v30 != v12);
      if (v12 >= 6)
      {
        v41 = 0;
        v42 = 0;
        v75 = v12 / 6u;
        v43 = 6;
        v77 = v12;
        do
        {
          v80 = v19;
          v78 = v43;
          if (v43 >= v76)
            v44 = v76;
          else
            v44 = v43;
          v79 = v42;
          v45 = 6 * (v42 + v15);
          if (v45 >= v12)
            v45 = v12;
          if (v10 >= 6)
          {
            v46 = 0;
            v47 = 0;
            v48 = 0;
            v49 = (6 * (v42 - v15) + 6) & ~((6 * (v42 - v15) + 6) >> 31);
            v50 = &v73[v49 * (int)v74];
            v51 = &v73[v45 * (int)v74];
            v52 = v45 - v49;
            if (6 * v42 + 6 >= v77)
              v53 = v77;
            else
              v53 = 6 * v42 + 6;
            v54 = 6;
            do
            {
              if (v10 >= v54)
                v55 = v54;
              else
                v55 = v10;
              v56 = 6 * (v48 + v15);
              if (v56 >= v10)
                v56 = v10;
              v57 = v48 + 1;
              if (6 * v42 < v53)
              {
                v58 = v46 + v55;
                v59 = (6 * (v48 - v15) + 6) & ~((6 * (v48 - v15) + 6) >> 31);
                v60 = (v50[v59] + v51[v56] - (v50[v56] + v51[v59])) / ((v56 - v59) * v52);
                v61 = 6 * v57;
                if (6 * v57 >= v10)
                  v61 = v10;
                v62 = 6 * v48;
                v63 = v19;
                v64 = v41;
                do
                {
                  if (v62 < v61)
                  {
                    v65 = 0;
                    do
                    {
                      if (v60 >= *(unsigned __int8 *)(v63 + v65))
                        *(_DWORD *)(*((_QWORD *)v14 + 6)
                                  + (((unint64_t)(v47 + v65 + v64 * *((_QWORD *)v14 + 3)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v47 + v65 + v64 * *((_QWORD *)v14 + 3));
                      ++v65;
                    }
                    while (v58 != v65);
                  }
                  ++v64;
                  v63 += v29;
                }
                while (v64 != v44);
              }
              v47 += 6;
              v54 += 6;
              v46 -= 6;
              v19 += 6;
              v48 = v57;
            }
            while (v57 != v10 / 6);
          }
          ++v42;
          v41 += 6;
          v12 = v77;
          v43 = v78 + 6;
          v19 = v80 + 6 * v29;
        }
        while (v79 + 1 != v75);
      }
    }
    v14 = v82;
    a2 = v72;
    if (v82)
    {
LABEL_54:
      v66 = v14 + 2;
      do
        v67 = __ldxr(v66);
      while (__stxr(v67 + 1, v66));
      v68 = 0;
    }
    else
    {
      v68 = 1;
    }
    v69 = v6[3];
    if (v69)
      sub_1D3D6D13C(v69);
    v6[3] = v14;
    *a2 = 0;
    if ((v68 & 1) == 0)
    {
      v70 = v14 + 2;
      do
        v71 = __ldxr(v70);
      while (__stxr(v71 + 1, v70));
    }
    *a2 = v14;
    sub_1D3D6D10C(&v82);
    return sub_1D3D91AD4(&v81);
  }
  return result;
}

void sub_1D3DC02EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  sub_1D3D6D10C((unsigned int **)(v13 - 88));
  sub_1D3D91AD4((unsigned int **)va);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC0338@<X0>(unsigned int **a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v12;

  v4 = operator new();
  v5 = v4;
  v6 = *a1;
  if (*a1)
  {
    v7 = v6 + 2;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v12 = v6;
  sub_1D3DC03FC(v4, &v12);
  v9 = (unsigned int *)(v5 + 8);
  do
    v10 = __ldxr(v9);
  while (__stxr(v10 + 1, v9));
  *a2 = v5;
  return sub_1D3D91AD4(&v12);
}

void sub_1D3DC03D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  MEMORY[0x1D8254C54](v2, 0x10B1C4009E930FDLL);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DC03FC(uint64_t a1, unsigned int **a2)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int *v10;

  v4 = *a2;
  if (*a2)
  {
    v5 = v4 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    v10 = v4;
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = off_1E95AFA10;
    *(_QWORD *)(a1 + 16) = 0;
    do
      v7 = __ldxr(v5);
    while (__stxr(v7 + 1, v5));
    v8 = *(unsigned int **)(a1 + 16);
    if (v8)
      sub_1D3D6D13C(v8);
  }
  else
  {
    v10 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = off_1E95AFA10;
    *(_QWORD *)(a1 + 16) = 0;
  }
  *(_QWORD *)(a1 + 16) = v4;
  sub_1D3D91AD4(&v10);
  *(_QWORD *)a1 = &off_1E95AF3D0;
  *(_QWORD *)(a1 + 24) = 0;
  (*(void (**)(unsigned int *))(*(_QWORD *)*a2 + 16))(*a2);
  (*(void (**)(unsigned int *))(*(_QWORD *)*a2 + 24))(*a2);
  *(_QWORD *)(a1 + 32) = operator new[]();
  return a1;
}

void sub_1D3DC050C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DC0540(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &off_1E95AF3D0;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    MEMORY[0x1D8254C3C](v2, 0x1000C8052888210);
  sub_1D3D6D10C((unsigned int **)(a1 + 24));
  *(_QWORD *)a1 = off_1E95AFA10;
  sub_1D3D91AD4((unsigned int **)(a1 + 16));
  return a1;
}

uint64_t sub_1D3DC05A4(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AED98;
  sub_1D3D6D10C((unsigned int **)(a1 + 80));
  *(_QWORD *)a1 = &off_1E95AF358;
  sub_1D3D6D10C((unsigned int **)(a1 + 48));
  return sub_1D3DB5128(a1);
}

void sub_1D3DC05E8(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AED98;
  sub_1D3D6D10C((unsigned int **)(a1 + 80));
  *(_QWORD *)a1 = &off_1E95AF358;
  sub_1D3D6D10C((unsigned int **)(a1 + 48));
  sub_1D3DB5128(a1);
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3DC0640@<X0>(unsigned int **result@<X0>, uint64_t *a2@<X8>)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int **v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  BOOL v15;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  unsigned int *v22;
  unsigned int v23;
  _BYTE *v24;
  int v25;
  int v26;
  unsigned int v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unint64_t v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  uint8x8_t v42;
  uint8x8_t v43;
  uint8x8_t v44;
  uint8x8_t v45;
  uint8x8_t v46;
  uint8x8_t v47;
  uint8x8_t v48;
  uint8x8_t v49;
  uint8x8_t v50;
  uint8x8_t v51;
  uint8x8_t v52;
  int8x8_t v53;
  uint8x8_t v54;
  uint8x8_t v55;
  uint8x8_t v56;
  int8x8_t v57;
  int16x8_t v58;
  unsigned int v59;
  double v60;
  int8x8_t v61;
  int8x8_t v62;
  int8x8_t v63;
  int8x8_t v64;
  int8x8_t v65;
  int8x8_t v66;
  int8x8_t v67;
  int8x8_t v68;
  int8x8_t v69;
  uint8x8_t v70;
  uint8x8_t v71;
  uint8x8_t v72;
  uint8x8_t v73;
  uint8x8_t v74;
  uint8x8_t v75;
  uint8x8_t v76;
  uint8x8_t v77;
  uint8x8_t v78;
  uint8x8_t v79;
  uint8x8_t v80;
  uint8x8_t v81;
  uint8x8_t v82;
  uint8x8_t v83;
  int8x8_t v84;
  unsigned __int8 v85;
  int v86;
  unsigned int v87;
  int16x8_t v88;
  int v89;
  unint64_t v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int8x8_t v100;
  int v101;
  unsigned int v102;
  int8x8_t v103;
  int8x8_t v104;
  int8x8_t v105;
  int8x8_t v106;
  int8x8_t v107;
  int8x8_t v108;
  int8x8_t v109;
  int v110;
  int8x8_t v111;
  int8x8_t v112;
  int8x8_t v113;
  int8x8_t v114;
  int8x8_t v115;
  int8x8_t v116;
  int8x8_t v117;
  unsigned int v118;
  int8x8_t v119;
  uint8x8_t v120;
  uint8x8_t v121;
  uint8x8_t v122;
  uint8x8_t v123;
  uint8x8_t v124;
  uint8x8_t v125;
  uint8x8_t v126;
  uint8x8_t v127;
  uint8x8_t v128;
  uint8x8_t v129;
  uint8x8_t v130;
  uint8x8_t v131;
  uint8x8_t v132;
  uint8x8_t v133;
  int8x8_t v134;
  int16x8_t v135;
  unsigned int v136;
  double v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  int v141;
  int v142;
  int v143;
  uint64_t v144;
  int v145;
  int v146;
  int v147;
  int v148;
  uint64_t v149;
  int v150;
  unsigned int v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  unsigned int v167;
  unsigned int v168;
  signed int v169;
  unint64_t v170;
  int v171;
  uint64_t v172;
  int v173;
  unint64_t v174;
  unsigned int v175;
  uint8x8_t v176;
  int8x8_t v177;
  unint64_t v178;
  unsigned int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  uint64_t v185;
  uint64_t v186;
  int8x8_t v187;
  int8x8_t v188;
  unsigned int v189;
  unsigned int v190;
  signed int v191;
  unint64_t v192;
  int v193;
  unsigned int v194;
  int v195;
  unint64_t v196;
  unsigned int v197;
  uint8x8_t v198;
  uint64_t v199;
  uint64_t v200;
  int8x8_t v201;
  int8x8_t v202;
  int8x8_t v203;
  int8x8_t v204;
  int8x8_t v205;
  unsigned int *v206;
  unsigned int v207;
  unsigned int *v208;
  unsigned int v209;
  unsigned int v210;
  unsigned int **v211;
  unsigned int v212;
  uint64_t *v213;
  unsigned int v214;
  uint64_t v215;
  int v216;
  uint64_t v217;
  int v218;
  uint64_t v219;
  unint64_t v220;
  int v221;
  uint64_t v222;
  signed int v223;
  int v224;
  int v225;
  uint64_t v226;
  uint64_t v227;
  int v228;
  unint64_t v229;
  unsigned int *v230;
  unsigned int *v231;

  v3 = result[10];
  if (v3)
  {
    v4 = v3 + 2;
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *a2 = (uint64_t)v3;
    return result;
  }
  v6 = result;
  v7 = result[2];
  if (v7)
  {
    v8 = v7 + 2;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v231 = v7;
  v10 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v7 + 48))(v7);
  v11 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v231 + 16))(v231);
  v12 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v231 + 24))(v231);
  v13 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v231 + 32))(v231);
  *a2 = 0;
  v15 = (v13 & 7) == 0 && (v10 & 7) == 0 && v11 >= 0x18;
  if (v15 && v12 > 0x17)
  {
    v20 = operator new();
    v229 = v11;
    v213 = a2;
    sub_1D3D938C4(v20, v11, v12);
    v210 = (v11 + 7) >> 3;
    v21 = (v210 + 15) & 0x3FFFFFF0;
    v22 = (unsigned int *)(v20 + 8);
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    v211 = v6;
    v215 = v20;
    *a2 = v20;
    v24 = malloc_type_malloc(((v12 + 7) >> 3) * v21, 0xE7E7F764uLL);
    v209 = (v12 + 7) >> 3;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v212 = v210 + 15;
    v29 = 8 * v13;
    v214 = v12;
    v220 = v12 - 7;
    v216 = (v11 - 8) & ~((int)(v11 - 8) >> 31);
    v30 = 3 * v13;
    v31 = 6 * v13;
    v32 = 5 * v13;
    v33 = ~v21;
    v34 = 7 * v13;
    v35 = 4 * v13;
    v36 = 2 * v13;
    v221 = v13;
    v37 = v13;
    do
    {
      v38 = 0;
      v39 = (v27 >> 3) - 1;
      v40 = v26;
      v41 = v33;
      do
      {
        v42 = *(uint8x8_t *)(v10 + (v25 + v38));
        v43 = *(uint8x8_t *)(v10 + (v37 + v38));
        v44 = *(uint8x8_t *)(v10 + (v36 + v38));
        v45 = *(uint8x8_t *)(v10 + (v30 + v38));
        v46 = *(uint8x8_t *)(v10 + (v35 + v38));
        v47 = *(uint8x8_t *)(v10 + (v32 + v38));
        v48 = *(uint8x8_t *)(v10 + (v31 + v38));
        v49 = *(uint8x8_t *)(v10 + (v34 + v38));
        v50 = vmax_u8(vmax_u8(vmax_u8(v42, v43), vmax_u8(v44, v45)), vmax_u8(vmax_u8(v46, v47), vmax_u8(v48, v49)));
        v51 = vpmax_u8(v50, v50);
        v52 = vpmax_u8(v51, v51);
        v53 = (int8x8_t)vpmax_u8(v52, v52);
        v54 = vmin_u8(vmin_u8(vmin_u8(v42, v43), vmin_u8(v44, v45)), vmin_u8(vmin_u8(v46, v47), vmin_u8(v48, v49)));
        v55 = vpmin_u8(v54, v54);
        v56 = vpmin_u8(v55, v55);
        v57 = (int8x8_t)vpmin_u8(v56, v56);
        if (vsub_s8(v53, v57).u8[0] > 0x18u)
        {
          v58 = (int16x8_t)vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddl_u8(v43, v42), v44), v45), v46), v47), v48), v49);
          *(int16x4_t *)v58.i8 = vadd_s16((int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v58, (int8x16_t)v58, 8uLL), *(int16x4_t *)v58.i8);
          *(int16x4_t *)v58.i8 = vpadd_s16(*(int16x4_t *)v58.i8, *(int16x4_t *)v58.i8);
          *(int16x4_t *)v58.i8 = vpadd_s16(*(int16x4_t *)v58.i8, *(int16x4_t *)v58.i8);
          v58.i8[0] = vdup_lane_s8(vshrn_n_s16(v58, 6uLL), 0).u8[0];
        }
        else
        {
          v58.i8[0] = vdup_lane_s8((int8x8_t)vshr_n_u8((uint8x8_t)v57, 1uLL), 0).u8[0];
          if (v28)
          {
            if (v38)
            {
              v59 = (v24[v41 + 1]
                   + v24[v41]
                   + 2 * v24[v39]) >> 2;
              v60 = COERCE_DOUBLE(vdup_n_s8(v59));
              if (v59 > v57.u8[0])
                *(double *)v58.i64 = v60;
            }
          }
        }
        v38 += 8;
        v24[v40] = v58.i8[0];
        ++v39;
        ++v41;
        ++v40;
      }
      while (v38 < v11 - 7);
      if (v11 > v38)
      {
        v61 = *(int8x8_t *)(v10 + (v13 * v28 + v216));
        v62 = *(int8x8_t *)(v10 + (v28 | 1) * v13 + v216);
        v63 = *(int8x8_t *)(v10 + (v28 | 2) * v13 + v216);
        v64 = *(int8x8_t *)(v10 + (v28 | 3) * v13 + v216);
        v65 = *(int8x8_t *)(v10 + (v28 | 4) * v13 + v216);
        v66 = *(int8x8_t *)(v10 + (v28 | 5) * v13 + v216);
        v67 = *(int8x8_t *)(v10 + (v28 | 6) * v13 + v216);
        v68 = *(int8x8_t *)(v10 + (v28 | 7) * v13 + v216);
        v69 = qword_1D3E6AAA8[((_BYTE)v11 - ((v11 - 8) & ~((int)(v11 - 8) >> 31))) & 7];
        v70 = (uint8x8_t)vand_s8(v69, v61);
        v71 = (uint8x8_t)vand_s8(v69, v62);
        v72 = (uint8x8_t)vand_s8(v69, v63);
        v73 = (uint8x8_t)vand_s8(v69, v64);
        v74 = (uint8x8_t)vand_s8(v69, v65);
        v75 = (uint8x8_t)vand_s8(v69, v66);
        v76 = (uint8x8_t)vand_s8(v69, v67);
        v77 = (uint8x8_t)vand_s8(v69, v68);
        v78 = vmax_u8(vmax_u8(vmax_u8(v70, v71), vmax_u8(v72, v73)), vmax_u8(vmax_u8(v74, v75), vmax_u8(v76, v77)));
        v79 = vpmax_u8(v78, v78);
        v80 = vpmax_u8(v79, v79);
        v81 = vmin_u8(vmin_u8(vmin_u8((uint8x8_t)vorn_s8(v61, v69), (uint8x8_t)vorn_s8(v62, v69)), vmin_u8((uint8x8_t)vorn_s8(v63, v69), (uint8x8_t)vorn_s8(v64, v69))), vmin_u8(vmin_u8((uint8x8_t)vorn_s8(v65, v69), (uint8x8_t)vorn_s8(v66, v69)), vmin_u8((uint8x8_t)vorn_s8(v67, v69), (uint8x8_t)vorn_s8(v68, v69))));
        v82 = vpmin_u8(v81, v81);
        v83 = vpmin_u8(v82, v82);
        v84 = (int8x8_t)vpmin_u8(v83, v83);
        if (vsub_s8((int8x8_t)vpmax_u8(v80, v80), v84).u8[0] > 0x18u)
        {
          v88 = (int16x8_t)vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddl_u8(v71, v70), v72), v73), v74), v75), v76), v77);
          *(int16x4_t *)v88.i8 = vadd_s16((int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v88, (int8x16_t)v88, 8uLL), *(int16x4_t *)v88.i8);
          *(int16x4_t *)v88.i8 = vpadd_s16(*(int16x4_t *)v88.i8, *(int16x4_t *)v88.i8);
          *(int16x4_t *)v88.i8 = vpadd_s16(*(int16x4_t *)v88.i8, *(int16x4_t *)v88.i8);
          v85 = vdup_lane_s8(vshrn_n_s16(v88, 6uLL), 0).u8[0];
          v86 = v21 * (v28 >> 3);
        }
        else
        {
          v85 = vdup_lane_s8((int8x8_t)vshr_n_u8((uint8x8_t)v84, 1uLL), 0).u8[0];
          v86 = v21 * (v28 >> 3);
          if (v28)
          {
            if ((_DWORD)v38)
            {
              v87 = (v24[((v28 >> 3) - 1) * v21 + (v38 >> 3)]
                   + v24[((v28 >> 3) - 1) * v21 - 1 + (v38 >> 3)]
                   + 2
                   * v24[((v21 * v28) >> 3) - 1 + (v38 >> 3)]) >> 2;
              if (v87 > v84.u8[0])
                v85 = vdup_n_s8(v87).u8[0];
            }
          }
        }
        v24[v86 + (v38 >> 3)] = v85;
      }
      v28 += 8;
      v27 += (8 * (v210 + 15)) & 0xFFFFFF80;
      v33 += v21;
      v26 += v21;
      v34 += v29;
      v31 += v29;
      v32 += v29;
      v35 += v29;
      v30 += v29;
      v36 += v29;
      v37 += v29;
      v25 += v29;
    }
    while (v28 < v220);
    if (v12 > v28)
    {
      v89 = 0;
      v90 = 0;
      v91 = (v12 - 8) & ~((int)(v12 - 8) >> 31);
      v92 = (v91 + 7) * v13;
      v93 = (v91 + 6) * v221;
      v94 = (v91 + 5) * v221;
      v95 = (v91 + 4) * v221;
      v96 = (v91 + 3) * v221;
      v97 = (v91 + 2) * v221;
      v98 = v91 * v221;
      v99 = v221 + v91 * v221;
      v100 = 0;
      v101 = v12 - v91 - 1;
      v102 = v11;
      v103 = 0;
      v104 = 0;
      v105 = 0;
      v106 = 0;
      v107 = 0;
      v108 = 0;
      v109 = 0;
      do
      {
        v15 = v102 >= 8;
        v102 -= 8;
        if (v15)
          v110 = v90;
        else
          v110 = (v11 - 8) & ~((int)(v11 - 8) >> 31);
        switch(v101)
        {
          case 0:
            v103 = 0;
            goto LABEL_51;
          case 1:
LABEL_51:
            v104 = 0;
            goto LABEL_52;
          case 2:
LABEL_52:
            v105 = 0;
            goto LABEL_53;
          case 3:
LABEL_53:
            v106 = 0;
            goto LABEL_54;
          case 4:
LABEL_54:
            v107 = 0;
            goto LABEL_55;
          case 5:
LABEL_55:
            v108 = 0;
            goto LABEL_56;
          case 6:
LABEL_56:
            v109 = 0;
            break;
          default:
            break;
        }
        switch(v101)
        {
          case 0:
            goto LABEL_65;
          case 1:
            goto LABEL_64;
          case 2:
            goto LABEL_63;
          case 3:
            goto LABEL_62;
          case 4:
            goto LABEL_61;
          case 5:
            goto LABEL_60;
          case 6:
            goto LABEL_59;
          case 7:
            v109 = *(int8x8_t *)(v10 + (v110 + v92));
LABEL_59:
            v108 = *(int8x8_t *)(v10 + (v110 + v93));
LABEL_60:
            v107 = *(int8x8_t *)(v10 + (v110 + v94));
LABEL_61:
            v106 = *(int8x8_t *)(v10 + (v110 + v95));
LABEL_62:
            v105 = *(int8x8_t *)(v10 + (v110 + v96));
LABEL_63:
            v104 = *(int8x8_t *)(v10 + (v110 + v97));
LABEL_64:
            v103 = *(int8x8_t *)(v10 + (v110 + v99));
LABEL_65:
            v100 = *(int8x8_t *)(v10 + (v110 + v98));
            break;
          default:
            break;
        }
        v111 = v109;
        v112 = v108;
        v113 = v107;
        v114 = v106;
        v115 = v105;
        v116 = v104;
        v117 = v103;
        if (v11 - v110 <= 7)
          v118 = 8 - (v11 - v110);
        else
          v118 = 0;
        v119 = qword_1D3E6AAA8[v118];
        v103 = vorn_s8(v103, v119);
        v104 = vorn_s8(v104, v119);
        v105 = vorn_s8(v105, v119);
        v106 = vorn_s8(v106, v119);
        v107 = vorn_s8(v107, v119);
        v108 = vorn_s8(v108, v119);
        switch(v101)
        {
          case 0:
            v103 = (int8x8_t)-1;
            goto LABEL_71;
          case 1:
LABEL_71:
            v104 = (int8x8_t)-1;
            goto LABEL_72;
          case 2:
LABEL_72:
            v105 = (int8x8_t)-1;
            goto LABEL_73;
          case 3:
LABEL_73:
            v106 = (int8x8_t)-1;
            goto LABEL_74;
          case 4:
LABEL_74:
            v107 = (int8x8_t)-1;
            goto LABEL_75;
          case 5:
LABEL_75:
            v108 = (int8x8_t)-1;
            goto LABEL_76;
          case 6:
LABEL_76:
            v109 = (int8x8_t)-1;
            break;
          default:
            v109 = vorn_s8(v109, v119);
            break;
        }
        v120 = (uint8x8_t)vand_s8(v119, v100);
        v121 = (uint8x8_t)vand_s8(v119, v117);
        v122 = (uint8x8_t)vand_s8(v119, v116);
        v123 = (uint8x8_t)vand_s8(v119, v115);
        v124 = (uint8x8_t)vand_s8(v119, v114);
        v125 = (uint8x8_t)vand_s8(v119, v113);
        v126 = (uint8x8_t)vand_s8(v119, v112);
        v127 = (uint8x8_t)vand_s8(v119, v111);
        v128 = vmax_u8(vmax_u8(vmax_u8(v120, v121), vmax_u8(v122, v123)), vmax_u8(vmax_u8(v124, v125), vmax_u8(v126, v127)));
        v129 = vpmax_u8(v128, v128);
        v130 = vpmax_u8(v129, v129);
        v100 = vorn_s8(v100, v119);
        v131 = vmin_u8(vmin_u8(vmin_u8((uint8x8_t)v100, (uint8x8_t)v103), vmin_u8((uint8x8_t)v104, (uint8x8_t)v105)), vmin_u8(vmin_u8((uint8x8_t)v106, (uint8x8_t)v107), vmin_u8((uint8x8_t)v108, (uint8x8_t)v109)));
        v132 = vpmin_u8(v131, v131);
        v133 = vpmin_u8(v132, v132);
        v134 = (int8x8_t)vpmin_u8(v133, v133);
        if (vsub_s8((int8x8_t)vpmax_u8(v130, v130), v134).u8[0] > 0x18u)
        {
          v135 = (int16x8_t)vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddw_u8(vaddl_u8(v121, v120), v122), v123), v124), v125), v126), v127);
          *(int16x4_t *)v135.i8 = vadd_s16((int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v135, (int8x16_t)v135, 8uLL), *(int16x4_t *)v135.i8);
          *(int16x4_t *)v135.i8 = vpadd_s16(*(int16x4_t *)v135.i8, *(int16x4_t *)v135.i8);
          *(int16x4_t *)v135.i8 = vpadd_s16(*(int16x4_t *)v135.i8, *(int16x4_t *)v135.i8);
          v135.i8[0] = vdup_lane_s8(vshrn_n_s16(v135, 6uLL), 0).u8[0];
        }
        else
        {
          v135.i8[0] = vdup_lane_s8((int8x8_t)vshr_n_u8((uint8x8_t)v134, 1uLL), 0).u8[0];
          if ((_DWORD)v28)
          {
            if (v90)
            {
              v136 = (v24[((v28 >> 3) - 1) * v21 + v89]
                    + v24[((v28 >> 3) - 1) * v21 - 1 + v89]
                    + 2 * v24[(v27 >> 3) - 1 + v89]) >> 2;
              v137 = COERCE_DOUBLE(vdup_n_s8(v136));
              if (v136 > v134.u8[0])
                *(double *)v135.i64 = v137;
            }
          }
        }
        v24[(v28 >> 3) * v21 + v89] = v135.i8[0];
        v90 += 8;
        ++v89;
      }
      while (v90 < v11);
    }
    v138 = 0;
    v218 = (int)(v12 + 7) / 8 - 3;
    v223 = v210 - 3;
    v217 = *(_QWORD *)(v215 + 24);
    v139 = *(_QWORD *)(v215 + 48);
    v222 = v10;
    do
    {
      v140 = 0;
      v141 = ((int)v138 >> 3) - 1;
      v142 = v221 * v138;
      if ((int)v138 < 8)
        v141 = 0;
      v143 = v221 * (v138 | 1);
      if (v141 >= v218)
        v144 = v218;
      else
        v144 = v141;
      v145 = v221 * (v138 | 2);
      v146 = v221 * (v138 | 3);
      v147 = v221 * (v138 | 4);
      v148 = v221 * (v138 | 5);
      v149 = v221 * (v138 | 6);
      v150 = v221 * (v138 | 7);
      v151 = v144 + 3;
      v219 = v138;
      v152 = v217 * v138;
      v153 = v217 * (v138 | 1);
      v154 = v217 * (v138 | 2);
      v155 = v217 * (v138 | 3);
      v156 = v217 * (v138 | 4);
      v157 = v217 * (v138 | 5);
      v158 = v217 * (v138 | 6);
      v159 = v217 * (v138 | 7);
      v160 = v144;
      v224 = (v212 & 0x3FFFFFF0) * v144;
      v227 = v158;
      v226 = v159;
      do
      {
        if (v160 > 0xFFFFFFFC)
        {
          v175 = 0;
        }
        else
        {
          v161 = v157;
          v162 = v156;
          v163 = v155;
          v164 = v154;
          v165 = v153;
          v166 = v149;
          v167 = 0;
          v168 = 0;
          v169 = (v140 >> 3) - 1;
          if (!v140)
            v169 = 0;
          if (v169 >= v223)
            v170 = v223;
          else
            v170 = v169;
          v171 = v224 + v170;
          v172 = v160;
          do
          {
            v173 = v171;
            v174 = v170;
            if (v170 <= 0xFFFFFFFC)
            {
              do
              {
                v167 += v24[v173];
                ++v174;
                ++v168;
                ++v173;
              }
              while (v174 < (v170 + 3));
            }
            LODWORD(v160) = v160 + 1;
            v171 += v21;
          }
          while (v160 < v151);
          if (v168)
            v175 = v167 / v168;
          else
            v175 = 0;
          v149 = v166;
          v153 = v165;
          v154 = v164;
          v155 = v163;
          v156 = v162;
          v157 = v161;
          v160 = v172;
          v10 = v222;
          v158 = v227;
          v159 = v226;
        }
        v176 = (uint8x8_t)vdup_n_s8(v175);
        v177 = vpadd_s8(vpadd_s8(vpadd_s8(vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v142 + v140)), v176)), vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v143 + v140)), v176))), vpadd_s8(vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v145 + v140)), v176)), vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v146 + v140)), v176)))), vpadd_s8(vpadd_s8(vbic_s8((int8x8_t)0x8040201008040201,
                       (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v147 + v140)), v176)),
                     vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v148 + v140)), v176))), vpadd_s8(vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v149 + v140)), v176)), vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v150 + v140)), v176)))));
        *(_DWORD *)(v139 + (((v152 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[0] << ((v152 + v140) & 0x18);
        *(_DWORD *)(v139 + (((v153 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[1] << (v153 + v140);
        *(_DWORD *)(v139 + (((v154 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[2] << ((v154 + v140) & 0x1E);
        *(_DWORD *)(v139 + (((v155 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[3] << (v155 + v140);
        *(_DWORD *)(v139 + (((v156 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[4] << ((v156 + v140) & 0x1C);
        *(_DWORD *)(v139 + (((v157 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[5] << (v157 + v140);
        *(_DWORD *)(v139 + (((v158 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[6] << ((v158 + v140) & 0x1E);
        *(_DWORD *)(v139 + (((v159 + v140) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v177.u8[7] << (v159 + v140);
        v140 += 8;
      }
      while (v140 < v229);
      v138 = v219 + 8;
    }
    while (v219 + 8 < v220);
    if (v214 > v138)
    {
      v178 = 0;
      v179 = (v138 >> 3) - 1;
      if ((_DWORD)v219 == -8)
        v179 = 0;
      v225 = (v138 | 6) * v221;
      if ((int)v179 >= (int)(v209 - 3))
        v179 = v209 - 3;
      v228 = (v138 | 5) * v221;
      v180 = (v138 | 4) * v221;
      v181 = (v138 | 3) * v221;
      v182 = (v138 | 2) * v221;
      v183 = (v138 | 1) * v221;
      v184 = v221 * v138;
      v185 = *v213;
      v186 = v138 & 0xFFFFFFF8;
      v187 = vpadd_s8(0, 0);
      v188 = vpadd_s8(v187, v187);
      if (v179 > 0xFFFFFFFC)
        goto LABEL_129;
      while (2)
      {
        v189 = 0;
        v190 = 0;
        v191 = (v178 >> 3) - 1;
        if (!v178)
          v191 = 0;
        v192 = v191 >= v223 ? v223 : v191;
        v193 = 16 * v179 * (v212 >> 4) + v192;
        v194 = v179;
        do
        {
          v195 = v193;
          v196 = v192;
          if (v192 <= 0xFFFFFFFC)
          {
            do
            {
              v190 += v24[v195];
              ++v196;
              ++v189;
              ++v195;
            }
            while (v196 < (v192 + 3));
          }
          ++v194;
          v193 += v21;
        }
        while (v194 < v179 + 3);
        if (v189)
          v197 = v190 / v189;
        else
LABEL_129:
          v197 = 0;
        v198 = (uint8x8_t)vdup_n_s8(v197);
        switch(v214 & 7)
        {
          case 1u:
            v198.i8[0] = vpadd_s8(vpadd_s8(vpadd_s8(vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v184 + v178)), v198)), 0), v187), v188).u8[0];
            v199 = *(_QWORD *)(v185 + 24);
            v200 = *(_QWORD *)(v185 + 48);
LABEL_154:
            *(_DWORD *)(v200 + (((v178 + v199 * v186) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v198.u8[0] << ((v178 + v199 * v186) & 0x18);
            goto LABEL_155;
          case 2u:
            v205 = 0;
            v201 = 0;
            v202 = 0;
            v203 = 0;
            v204 = 0;
            goto LABEL_142;
          case 3u:
            v201 = 0;
            v202 = 0;
            v203 = 0;
            v204 = 0;
            goto LABEL_141;
          case 4u:
            v202 = 0;
            v203 = 0;
            v204 = 0;
            goto LABEL_140;
          case 5u:
            v203 = 0;
            v204 = 0;
            goto LABEL_139;
          case 6u:
            v204 = 0;
            goto LABEL_138;
          case 7u:
            v204 = vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v225 + v178)), v198));
LABEL_138:
            v203 = vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v178 + v228)), v198));
LABEL_139:
            v202 = vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v178 + v180)), v198));
LABEL_140:
            v201 = vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v178 + v181)), v198));
LABEL_141:
            v205 = vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v178 + v182)), v198));
LABEL_142:
            v198 = (uint8x8_t)vpadd_s8(vpadd_s8(vpadd_s8(vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v178 + v184)), v198)), vbic_s8((int8x8_t)0x8040201008040201, (int8x8_t)vcgt_u8(*(uint8x8_t *)(v10 + (v178 + v183)), v198))), vpadd_s8(v205, v201)), vpadd_s8(vpadd_s8(v202, v203), vpadd_s8(v204, 0)));
            switch(v214 & 7)
            {
              case 2u:
                v199 = *(_QWORD *)(v185 + 24);
                v200 = *(_QWORD *)(v185 + 48);
                goto LABEL_153;
              case 3u:
                v199 = *(_QWORD *)(v185 + 24);
                v200 = *(_QWORD *)(v185 + 48);
                goto LABEL_152;
              case 4u:
                v199 = *(_QWORD *)(v185 + 24);
                v200 = *(_QWORD *)(v185 + 48);
                goto LABEL_151;
              case 5u:
                v199 = *(_QWORD *)(v185 + 24);
                v200 = *(_QWORD *)(v185 + 48);
                goto LABEL_150;
              case 6u:
                v199 = *(_QWORD *)(v185 + 24);
                v200 = *(_QWORD *)(v185 + 48);
                goto LABEL_149;
              case 7u:
                v199 = *(_QWORD *)(v185 + 24);
                v200 = *(_QWORD *)(v185 + 48);
                *(_DWORD *)(v200 + (((v178 + v199 * (v186 | 6)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v198.u8[6] << ((v178 + v199 * (v186 | 6)) & 0x1E);
LABEL_149:
                *(_DWORD *)(v200 + (((v178 + v199 * (v186 | 5)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v198.u8[5] << (v178 + v199 * (v186 | 5));
LABEL_150:
                *(_DWORD *)(v200 + (((v178 + v199 * (v186 | 4)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v198.u8[4] << ((v178 + v199 * (v186 | 4)) & 0x1C);
LABEL_151:
                *(_DWORD *)(v200 + (((v178 + v199 * (v186 | 3)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v198.u8[3] << (v178 + v199 * (v186 | 3));
LABEL_152:
                *(_DWORD *)(v200 + (((v178 + v199 * (v186 | 2)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v198.u8[2] << ((v178 + v199 * (v186 | 2)) & 0x1E);
LABEL_153:
                *(_DWORD *)(v200 + (((v178 + v199 * (v186 | 1)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= v198.u8[1] << (v178 + v199 * (v186 | 1));
                goto LABEL_154;
              default:
                goto LABEL_155;
            }
          default:
LABEL_155:
            v178 += 8;
            if (v178 >= v229)
              break;
            continue;
        }
        break;
      }
    }
    free(v24);
    v6 = v211;
    v17 = (unsigned int *)v215;
    goto LABEL_157;
  }
  sub_1D3DB60C0(v6, &v230);
  v17 = v230;
  if (v230)
  {
    v18 = v230 + 2;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
    *a2 = (uint64_t)v17;
    sub_1D3D6D10C(&v230);
LABEL_157:
    v206 = v17 + 2;
    do
      v207 = __ldxr(v206);
    while (__stxr(v207 + 1, v206));
    goto LABEL_159;
  }
  *a2 = 0;
  sub_1D3D6D10C(&v230);
LABEL_159:
  v208 = v6[10];
  if (v208)
    sub_1D3D6D13C(v208);
  v6[10] = v17;
  return sub_1D3D91AD4(&v231);
}

void sub_1D3DC1718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int **a13)
{
  uint64_t v13;

  sub_1D3D6D10C(a13);
  sub_1D3D91AD4((unsigned int **)(v13 - 96));
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC1774@<X0>(unsigned int **a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v12;

  v4 = (_QWORD *)operator new();
  v5 = v4;
  v6 = *a1;
  if (*a1)
  {
    v7 = v6 + 2;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v12 = v6;
  sub_1D3DC1834(v4, v6);
  v9 = (unsigned int *)(v5 + 1);
  do
    v10 = __ldxr(v9);
  while (__stxr(v10 + 1, v9));
  *a2 = v5;
  return sub_1D3D91AD4(&v12);
}

void sub_1D3DC1808(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  MEMORY[0x1D8254C54](v2, 0x10A1C40D086140DLL);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3DC1834(_QWORD *a1, unsigned int *a2)
{
  unsigned int *v3;
  unsigned int v4;
  unsigned int *v6;

  if (a2)
  {
    v3 = a2 + 2;
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v6 = a2;
  sub_1D3DB6730((uint64_t)a1, a2);
  sub_1D3D91AD4(&v6);
  *a1 = &off_1E95AED98;
  a1[10] = 0;
  return a1;
}

void sub_1D3DC1898(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D91AD4((unsigned int **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DC18AC(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AED98;
  sub_1D3D6D10C((unsigned int **)(a1 + 80));
  *(_QWORD *)a1 = &off_1E95AF358;
  sub_1D3D6D10C((unsigned int **)(a1 + 48));
  return sub_1D3DB5128(a1);
}

uint64_t sub_1D3DC18F0(uint64_t *a1, int a2, std::string *a3)
{
  void **v4;
  std::string::size_type v5;
  std::string v7;
  _BYTE v8[8];
  void *__p[2];
  unsigned __int8 v10;
  int v11[2];

  v11[0] = a2;
  v11[1] = 0;
  memset(&v7, 0, sizeof(v7));
  sub_1D3DC19D4((uint64_t)v8, v11, a1, &v7);
  if ((v10 & 0x80u) == 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if ((v10 & 0x80u) == 0)
    v5 = v10;
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a3, (const std::string::value_type *)v4, v5);
  if ((char)v10 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_1D3DC1980(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1D3DC1970);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D3DC19D4(uint64_t a1, int *a2, uint64_t *a3, std::string *this)
{
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  std::string::value_type v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  void *v36;
  char v37;
  int i;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  unsigned __int8 *v44;
  int v45;
  int v46;
  unsigned int v47;
  uint64_t v48;
  unsigned __int8 *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v55;
  std::string *p_dst;
  std::string::size_type size;
  std::string *v58;
  std::string::size_type v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  unsigned __int8 *v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  unsigned __int8 *v74;
  int v75;
  std::string::value_type v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  unsigned __int8 *v85;
  uint64_t v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  int v91;
  int v92;
  int v93;
  int v94;
  unsigned __int8 *v95;
  int v96;
  std::string::value_type v97;
  int v98;
  int v99;
  unsigned __int8 *v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  _BYTE *v110;
  __int128 v111;
  void *exception;
  _BYTE v114[24];
  _BYTE v115[24];
  std::string __dst;

  while (1)
  {
    v8 = *a2;
    v7 = a2[1];
    switch(v7)
    {
      case 3:
        v9 = v8 + 5;
        v16 = *a3;
        v17 = *((_DWORD *)a3 + 2) - *a3;
        if (v8 + 5 > v17)
          goto LABEL_39;
        v18 = *a2;
        while (1)
        {
          v19 = v17 - v18;
          v20 = v17 - v18 >= 5 ? 5 : v17 - v18;
          if (v19 < 1)
            break;
          v21 = 0;
          v22 = (unsigned __int8 *)(v16 + v18);
          v23 = v22;
          do
          {
            v24 = *v23++;
            v21 = (v24 != 0) | (2 * v21);
            --v20;
          }
          while (v20);
          if (v21 <= 0x19)
            goto LABEL_29;
          if (v21 == 31)
          {
LABEL_182:
            *a2 = v9;
            goto LABEL_184;
          }
          v25 = v18 + 6;
          if (v18 + 6 > v17)
            goto LABEL_39;
          v26 = 0;
          v27 = v19 >= 6 ? 6 : v19;
          do
          {
            v28 = v26;
            v29 = *v22++;
            v26 = (v29 != 0) | (2 * v26);
            --v27;
          }
          while (v27);
          if ((2 * v28 - 52) > 9)
            goto LABEL_39;
          v30 = v26 - 4;
          *a2 = v25;
          if (v30 == 36)
            goto LABEL_184;
LABEL_30:
          std::string::push_back(this, v30);
          v18 = *a2;
          v9 = *a2 + 5;
          v16 = *a3;
          v17 = *((_DWORD *)a3 + 2) - *a3;
          if (v9 > v17)
            goto LABEL_39;
        }
        LOBYTE(v21) = 0;
LABEL_29:
        v30 = v21 + 65;
        *a2 = v9;
        goto LABEL_30;
      case 2:
        v31 = v8 + 5;
        v32 = *a3;
        v33 = a3[1];
        v34 = v33 - *a3;
        v35 = *a2;
        if (v8 + 5 <= v34)
        {
          while (1)
          {
            v81 = v34 - v35;
            if (v34 - v35 >= 5)
              v82 = 5;
            else
              v82 = v34 - v35;
            if (v81 < 1)
              goto LABEL_33;
            v83 = 0;
            v84 = v35;
            v85 = (unsigned __int8 *)(v32 + v35);
            v86 = v35;
            v87 = v82;
            do
            {
              v83 = (*(_BYTE *)(v32 + v86++) != 0) | (2 * v83);
              --v87;
            }
            while (v87);
            if ((v83 - 5) >= 0xB)
            {
              if (v35 + 7 > v34)
                goto LABEL_33;
              v88 = 0;
              v89 = v81 >= 7 ? 7 : v34 - v35;
              v90 = v35;
              do
              {
                v91 = v88;
                v88 = (*(_BYTE *)(v32 + v90++) != 0) | (2 * v88);
                --v89;
              }
              while (v89);
              if ((2 * v91 - 64) >= 0x34)
              {
                if (v35 + 8 > v34)
                  goto LABEL_33;
                v92 = 0;
                v93 = v81 >= 8 ? 8 : v34 - v35;
                do
                {
                  v92 = (*(_BYTE *)(v32 + v84++) != 0) | (2 * v92);
                  --v93;
                }
                while (v93);
                if ((v92 - 232) > 0x14)
                  goto LABEL_33;
              }
            }
            v94 = 0;
            v95 = (unsigned __int8 *)(v32 + v35);
            do
            {
              v96 = *v95++;
              v94 = (v96 != 0) | (2 * v94);
              --v82;
            }
            while (v82);
            if (v94 == 15)
              break;
            if ((v94 - 5) > 9)
            {
              v98 = 0;
              if (v81 >= 7)
                v99 = 7;
              else
                v99 = v81;
              v100 = (unsigned __int8 *)(v32 + v35);
              do
              {
                v101 = v98;
                v102 = *v100++;
                v98 = (v102 != 0) | (2 * v98);
                --v99;
              }
              while (v99);
              if ((2 * v101 - 64) > 0x19)
              {
                if ((2 * v101 - 90) > 0x19)
                {
                  v104 = 0;
                  if (v81 >= 8)
                    v81 = 8;
                  do
                  {
                    v105 = *v85++;
                    v104 = (v105 != 0) | (2 * v104);
                    --v81;
                  }
                  while (v81);
                  if ((v104 - 253) <= 0xFFFFFFEA)
                  {
                    exception = __cxa_allocate_exception(0x10uLL);
                    MEMORY[0x1D8254978](exception, "Decoding invalid ISO-IEC-646 value");
LABEL_214:
                    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
                  }
                  v97 = asc_1D3E84127[v104 - 232];
                  v103 = v35 + 8;
                }
                else
                {
                  v103 = v35 + 7;
                  v97 = v98 + 7;
                }
              }
              else
              {
                v103 = v35 + 7;
                v97 = v98 + 1;
              }
              *a2 = v103;
              if (v97 == 36)
                goto LABEL_184;
            }
            else
            {
              v97 = v94 + 43;
              *a2 = v31;
            }
            std::string::push_back(this, v97);
            v35 = *a2;
            v31 = *a2 + 5;
            v32 = *a3;
            v33 = a3[1];
            v34 = v33 - *a3;
            if (v31 > v34)
              goto LABEL_33;
          }
          *a2 = v31;
LABEL_184:
          std::string::push_back(this, 29);
          a2[1] = 0;
          v63 = *a2;
          if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
            sub_1D3D7FCC0(&__dst, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
          else
            __dst = *this;
          v36 = (void *)__dst.__r_.__value_.__r.__words[0];
          v37 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
LABEL_177:
          v47 = -1;
          goto LABEL_178;
        }
LABEL_33:
        if (v35 + 3 <= v34)
        {
          v107 = 0;
          v15 = (v35 + 3);
          while (!*(_BYTE *)(v32 + v35 + v107))
          {
            if ((_DWORD)++v107 == 3)
              goto LABEL_175;
          }
        }
        if (sub_1D3DC2420(v32, v33, v35))
        {
          v14 = *a2 + 5;
          if (v14 >= *((_DWORD *)a3 + 2) - *(_DWORD *)a3)
            v14 = *((_DWORD *)a3 + 2) - *(_DWORD *)a3;
          HIDWORD(v15) = 1;
LABEL_38:
          LODWORD(v15) = v14;
LABEL_175:
          v36 = 0;
          v37 = 0;
          *(_QWORD *)a2 = v15;
          goto LABEL_176;
        }
LABEL_39:
        v36 = 0;
        v37 = 0;
LABEL_176:
        v63 = 0x7FFFFFFF;
        goto LABEL_177;
      case 1:
        v9 = v8 + 5;
        v10 = *a3;
        v11 = a3[1];
        v12 = v11 - *a3;
        v13 = *a2;
        if (v8 + 5 <= v12)
        {
          do
          {
            v64 = v12 - v13;
            if (v12 - v13 >= 5)
              v65 = 5;
            else
              v65 = v12 - v13;
            if (v64 < 1)
              break;
            v66 = 0;
            v67 = v13;
            v68 = (unsigned __int8 *)(v10 + v13);
            v69 = v13;
            v70 = v65;
            do
            {
              v66 = (*(_BYTE *)(v10 + v69++) != 0) | (2 * v66);
              --v70;
            }
            while (v70);
            if ((v66 - 5) >= 0xB)
            {
              if (v13 + 6 > v12)
                break;
              v71 = 0;
              v72 = v64 >= 6 ? 6 : v12 - v13;
              do
              {
                v71 = (*(_BYTE *)(v10 + v67++) != 0) | (2 * v71);
                --v72;
              }
              while (v72);
              if ((v71 - 16) > 0x2E)
                break;
            }
            v73 = 0;
            v74 = (unsigned __int8 *)(v10 + v13);
            do
            {
              v75 = *v74++;
              v73 = (v75 != 0) | (2 * v73);
              --v65;
            }
            while (v65);
            if (v73 == 15)
              goto LABEL_182;
            if ((v73 - 5) > 9)
            {
              v77 = 0;
              if (v64 >= 6)
                v78 = 6;
              else
                v78 = v64;
              do
              {
                v79 = v77;
                v80 = *v68++;
                v77 = (v80 != 0) | (2 * v77);
                --v78;
              }
              while (v78);
              if ((2 * v79 - 32) > 0x19)
              {
                if ((v77 - 63) <= 0xFFFFFFFA)
                {
                  exception = __cxa_allocate_exception(0x10uLL);
                  MEMORY[0x1D8254978](exception, "Decoding invalid alphanumeric value");
                  goto LABEL_214;
                }
                v76 = asc_1D3E840FE[v77 - 58];
              }
              else
              {
                v76 = v77 + 33;
              }
              *a2 = v13 + 6;
              if (v76 == 36)
                goto LABEL_184;
            }
            else
            {
              v76 = v73 + 43;
              *a2 = v9;
            }
            std::string::push_back(this, v76);
            v13 = *a2;
            v9 = *a2 + 5;
            v10 = *a3;
            v11 = a3[1];
            v12 = v11 - *a3;
          }
          while (v9 <= v12);
        }
        if (v13 + 3 <= v12)
        {
          v106 = 0;
          v15 = (v13 + 3);
          while (!*(_BYTE *)(v10 + v13 + v106))
          {
            if ((_DWORD)++v106 == 3)
              goto LABEL_175;
          }
        }
        if (sub_1D3DC2420(v10, v11, v13))
        {
          v14 = *a2 + 5;
          if (v14 >= *((_DWORD *)a3 + 2) - *(_DWORD *)a3)
            v14 = *((_DWORD *)a3 + 2) - *(_DWORD *)a3;
          HIDWORD(v15) = 2;
          goto LABEL_38;
        }
        goto LABEL_39;
    }
    for (i = *a2; ; i = *a2)
    {
      v39 = i + 7;
      v40 = *a3;
      v41 = *((_DWORD *)a3 + 2) - *a3;
      if (i + 7 > v41)
        break;
      v48 = 0;
      v49 = (unsigned __int8 *)(v40 + i);
      while (!v49[v48])
      {
        if ((_DWORD)++v48 == 4)
          goto LABEL_88;
      }
      if (v41 - i >= 7)
        v50 = 7;
      else
        v50 = v41 - i;
      if (v41 - i < 1)
      {
        v53 = -8;
      }
      else
      {
        v51 = 0;
        do
        {
          v52 = *v49++;
          v51 = (v52 != 0) | (2 * v51);
          --v50;
        }
        while (v50);
        v53 = v51 - 8;
      }
      v46 = v53 / 11;
      v47 = v53 % 11;
      if ((v53 / 11) > 0xA || v47 > 0xA)
      {
LABEL_88:
        v55 = *((_DWORD *)a3 + 2) - *a3;
        goto LABEL_89;
      }
LABEL_68:
      v55 = *((_DWORD *)a3 + 2) - *a3;
      if (v39 == 0x7FFFFFFF)
        goto LABEL_89;
      *a2 = v39;
      if (v46 == 10)
      {
        std::string::push_back(this, 29);
        if (v47 == 10)
          goto LABEL_193;
        v63 = *a2;
        if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
          sub_1D3D7FCC0(&__dst, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
        else
          __dst = *this;
        v36 = (void *)__dst.__r_.__value_.__r.__words[0];
        goto LABEL_197;
      }
      std::to_string(&__dst, v46);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_dst = &__dst;
      else
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      else
        size = __dst.__r_.__value_.__l.__size_;
      std::string::append(this, (const std::string::value_type *)p_dst, size);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__dst.__r_.__value_.__l.__data_);
      if (v47 == 10)
        goto LABEL_193;
      std::to_string(&__dst, v47);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v58 = &__dst;
      else
        v58 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v59 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      else
        v59 = __dst.__r_.__value_.__l.__size_;
      std::string::append(this, (const std::string::value_type *)v58, v59);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (i + 4 > v41)
      goto LABEL_88;
    if (v41 - i >= 4)
      v42 = 4;
    else
      v42 = v41 - i;
    if (v41 - i <= 0)
      goto LABEL_192;
    v43 = 0;
    v44 = (unsigned __int8 *)(v40 + i);
    do
    {
      v45 = *v44++;
      v43 = (v45 != 0) | (2 * v43);
      --v42;
    }
    while (v42);
    if (v43)
    {
      v46 = v43 - 1;
      if ((v43 - 1) > 0xA)
        goto LABEL_88;
      v47 = 10;
      v39 = *((_DWORD *)a3 + 2) - *a3;
      goto LABEL_68;
    }
    v55 = 0x7FFFFFFF;
    if (v41 != 0x7FFFFFFF)
    {
LABEL_192:
      *a2 = v41;
      std::string::push_back(this, 29);
LABEL_193:
      std::string::push_back(this, 29);
      v63 = *a2;
      if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
        sub_1D3D7FCC0(&__dst, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
      else
        __dst = *this;
      v36 = (void *)__dst.__r_.__value_.__r.__words[0];
      v47 = -1;
LABEL_197:
      v37 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      goto LABEL_178;
    }
LABEL_89:
    if (i < v55)
    {
      v60 = 0;
      v61 = v40 + i;
      while (!*(_BYTE *)(v61 + v60))
      {
        if (v60 <= 2)
        {
          v62 = i + 1 + v60++;
          if (v62 < v55)
            continue;
        }
        v36 = 0;
        v37 = 0;
        *a2 = i + 4;
        a2[1] = 1;
        goto LABEL_96;
      }
    }
    v36 = 0;
    v37 = 0;
LABEL_96:
    v47 = -1;
    v63 = 0x7FFFFFFF;
LABEL_178:
    v108 = *a2;
    if (v63 != 0x7FFFFFFF || v8 == v108)
      break;
    if (v37 < 0)
      operator delete(v36);
  }
  v109 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if (v63 == 0x7FFFFFFF || (v47 & 0x80000000) != 0)
  {
    if (v109 < 0)
    {
      v110 = v114;
      sub_1D3D7FCC0(v114, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
      v47 = -1;
    }
    else
    {
      v47 = -1;
      v110 = v114;
LABEL_206:
      *(_OWORD *)v110 = *(_OWORD *)&this->__r_.__value_.__l.__data_;
      *((_QWORD *)v110 + 2) = *((_QWORD *)&this->__r_.__value_.__l + 2);
    }
  }
  else
  {
    if ((v109 & 0x80000000) == 0)
    {
      v110 = v115;
      goto LABEL_206;
    }
    v110 = v115;
    sub_1D3D7FCC0(v115, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
  }
  *(_DWORD *)a1 = v108;
  v111 = *(_OWORD *)v110;
  *(_QWORD *)(a1 + 24) = *((_QWORD *)v110 + 2);
  *(_OWORD *)(a1 + 8) = v111;
  *((_QWORD *)v110 + 1) = 0;
  *((_QWORD *)v110 + 2) = 0;
  *(_QWORD *)v110 = 0;
  *(_DWORD *)(a1 + 32) = v47;
  if (v37 < 0)
    operator delete(v36);
}

void sub_1D3DC23DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  char v22;
  void *v23;

  if (v22 < 0)
    operator delete(v23);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DC2420(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v3 = a2 - a1;
  if ((int)a2 - (int)a1 <= a3)
    return 0;
  v4 = 0;
  v5 = a3 + 2;
  do
  {
    if ((_DWORD)a2 - (_DWORD)a1 - a3 == v4)
      break;
    if (v4 == 2)
    {
      if (v3 <= v5)
        goto LABEL_13;
      if (!*(_BYTE *)(a1 + v5))
        return 0;
    }
    else
    {
      if (v3 <= a3 + v4)
LABEL_13:
        sub_1D3DB6E04();
      if (*(_BYTE *)(a1 + a3 + v4))
        return 0;
    }
    ++v4;
  }
  while (v4 != 5);
  return 1;
}

uint64_t sub_1D3DC24A0(uint64_t *a1, int a2, std::string *a3)
{
  std::string::size_type v6;
  std::string::size_type size;
  char v8;
  void **v9;
  std::string::size_type v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  std::string::size_type v14;
  std::string *v15;
  std::string::size_type v16;
  std::string v18;
  std::string __p;
  int v20;
  void *v21[2];
  unsigned __int8 v22;
  int __val;
  _DWORD v24[2];
  int v25[2];

  v6 = 0;
  size = 0;
  v8 = 0;
  v25[1] = 0;
  memset(v24, 0, 7);
  do
  {
    v25[0] = a2;
    if (v8 < 0)
    {
      sub_1D3D7FCC0(&__p, (void *)v6, size);
    }
    else
    {
      __p.__r_.__value_.__r.__words[0] = v6;
      __p.__r_.__value_.__l.__size_ = size;
      LODWORD(__p.__r_.__value_.__r.__words[2]) = v24[0];
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v24 + 3);
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = v8;
    }
    sub_1D3DC19D4((uint64_t)&v20, v25, a1, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if ((v22 & 0x80u) == 0)
      v9 = v21;
    else
      v9 = (void **)v21[0];
    if ((v22 & 0x80u) == 0)
      v10 = v22;
    else
      v10 = (std::string::size_type)v21[1];
    std::string::append(a3, (const std::string::value_type *)v9, v10);
    if (__val < 0)
    {
      if (v8 < 0)
      {
        size = 0;
        *(_BYTE *)v6 = 0;
      }
      else
      {
        v8 = 0;
        v6 &= 0xFFFFFFFFFFFFFF00;
      }
    }
    else
    {
      std::to_string(&v18, __val);
      if (v8 < 0)
        operator delete((void *)v6);
      size = v18.__r_.__value_.__l.__size_;
      v6 = v18.__r_.__value_.__r.__words[0];
      v24[0] = v18.__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v24 + 3) = *(_DWORD *)((char *)&v18.__r_.__value_.__r.__words[2] + 3);
      v8 = HIBYTE(v18.__r_.__value_.__r.__words[2]);
    }
    v11 = v20;
    if ((char)v22 < 0)
      operator delete(v21[0]);
    v12 = a2 == v11;
    a2 = v11;
  }
  while (!v12);
  while ((SHIBYTE(a3->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v13 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
    if (!*((_BYTE *)&a3->__r_.__value_.__s + 23) || *((_BYTE *)&a3[-1].__r_.__value_.__r.__words[2] + v13 + 7) != 29)
      goto LABEL_32;
    v14 = v13 - 1;
    *((_BYTE *)&a3->__r_.__value_.__s + 23) = v13 - 1;
    v15 = a3;
LABEL_31:
    v15->__r_.__value_.__s.__data_[v14] = 0;
  }
  v16 = a3->__r_.__value_.__l.__size_;
  if (v16)
  {
    v15 = (std::string *)a3->__r_.__value_.__r.__words[0];
    if (*(_BYTE *)(a3->__r_.__value_.__r.__words[0] + v16 - 1) == 29)
    {
      v14 = v16 - 1;
      a3->__r_.__value_.__l.__size_ = v14;
      goto LABEL_31;
    }
  }
LABEL_32:
  if (v8 < 0)
    operator delete((void *)v6);
  return 0;
}

void sub_1D3DC2670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;

  operator delete(v25);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1D3DC2650);
  }
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC26DC(unsigned int **a1, uint64_t a2, unsigned int ***a3)
{
  unsigned int **v5;
  unsigned int **v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int **v16;
  unsigned int **v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int **v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int *v39;

  *a1 = 0;
  (*(void (**)(unsigned int **__return_ptr, uint64_t))(*(_QWORD *)a2 + 16))(&v39, a2);
  v5 = *a3;
  v6 = a3[1];
  while (v5 != v6)
  {
    v7 = *v5;
    if (*v5)
    {
      v8 = v7 + 2;
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    v38 = v7;
    v10 = v39;
    if (v39)
    {
      v11 = v39 + 2;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    v36 = v10;
    if (v7)
    {
      v13 = v7 + 2;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v35 = v7;
    sub_1D3DCDE34(&v37, (uint64_t *)&v36, &v35, 0);
    v15 = v37;
    if (v37)
    {
      v27 = v37 + 2;
      do
        v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
      *a1 = v15;
      sub_1D3D7F7E4(&v37);
      sub_1D3DC2944(&v35);
      v29 = &v36;
LABEL_33:
      sub_1D3D6D10C(v29);
      sub_1D3DC2944(&v38);
      return sub_1D3D6D10C(&v39);
    }
    *a1 = 0;
    sub_1D3D7F7E4(&v37);
    sub_1D3DC2944(&v35);
    sub_1D3D6D10C(&v36);
    sub_1D3DC2944(&v38);
    ++v5;
  }
  v17 = a3[3];
  v16 = a3[4];
  while (v17 != v16)
  {
    v18 = *v17;
    if (*v17)
    {
      v19 = v18 + 2;
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    v38 = v18;
    v21 = v39;
    if (v39)
    {
      v22 = v39 + 2;
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    v34 = v21;
    if (v18)
    {
      v24 = v18 + 2;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
    }
    v33 = v18;
    sub_1D3DCDE34(&v37, (uint64_t *)&v34, &v33, 1);
    v26 = v37;
    if (v37)
    {
      v30 = v37 + 2;
      do
        v31 = __ldxr(v30);
      while (__stxr(v31 + 1, v30));
      *a1 = v26;
      sub_1D3D7F7E4(&v37);
      sub_1D3DC2944(&v33);
      v29 = &v34;
      goto LABEL_33;
    }
    *a1 = 0;
    sub_1D3D7F7E4(&v37);
    sub_1D3DC2944(&v33);
    sub_1D3D6D10C(&v34);
    sub_1D3DC2944(&v38);
    ++v17;
  }
  return sub_1D3D6D10C(&v39);
}

void sub_1D3DC28F4(_Unwind_Exception *a1)
{
  unsigned int **v1;

  sub_1D3D7F7E4(v1);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC2944(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

void sub_1D3DC297C(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

void sub_1D3DC2988(_QWORD *a1)
{
  sub_1D3DC3680(a1);
  JUMPOUT(0x1D8254C54);
}

unint64_t *sub_1D3DC29B0@<X0>(uint64_t a1@<X0>, CFDictionaryRef *a2@<X8>)
{
  unint64_t v4;
  const void *v5;
  CFTypeID v6;
  unint64_t v7;
  const void *v8;
  CFTypeID v9;
  void **v10;
  unint64_t v11;
  void *v12;
  void *v13;
  unint64_t v14;
  unint64_t *result;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18[12];
  char v19;
  void *values;
  unint64_t v21;
  void *keys[2];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  LOBYTE(v18[0]) = 0;
  v19 = 0;
  sub_1D3DC2B94(&v17, a1, (CFStringRef)*MEMORY[0x1E0CED830], v18);
  if (v19
    || (v4 = atomic_load(&v17)) != 0
    && (v5 = (const void *)atomic_load(&v17), v6 = CFGetTypeID(v5), v6 != CFStringGetTypeID()))
  {
    *a2 = 0;
  }
  else
  {
    sub_1D3DC2B94(&v16, a1, (CFStringRef)*MEMORY[0x1E0CED828], v18);
    if (v19
      || (v7 = atomic_load(&v16)) != 0
      && (v8 = (const void *)atomic_load(&v16), v9 = CFGetTypeID(v8), v9 != CFArrayGetTypeID()))
    {
      *a2 = 0;
    }
    else
    {
      *(_OWORD *)keys = xmmword_1E95B2EF8;
      values = 0;
      v21 = 0;
      v10 = (void **)MEMORY[0x1E0C9B0D0];
      v11 = atomic_load(&v17);
      v12 = *v10;
      if (v11)
        v13 = (void *)v11;
      else
        v13 = v12;
      v14 = atomic_load(&v16);
      if (!v14)
        v14 = (unint64_t)v12;
      values = v13;
      v21 = v14;
      *a2 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    sub_1D3D8BA0C(&v16);
  }
  result = sub_1D3D8BA0C(&v17);
  if (v19)
    return sub_1D3DF4F24(v18);
  return result;
}

void sub_1D3DC2B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unint64_t a11, unint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  sub_1D3D8BA0C(&a10);
  sub_1D3D8BA0C(&a11);
  if (a24)
    sub_1D3DF4F24(&a12);
  _Unwind_Resume(a1);
}

const char *sub_1D3DC2B88()
{
  return "PixelTransferSession";
}

void sub_1D3DC2B94(_QWORD *a1, uint64_t a2, CFStringRef propertyKey, unint64_t *a4)
{
  const void *v7;
  OSStatus v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  const __CFString *v13;
  uint64_t propertyValueOut;
  uint8_t buf[8];
  __int16 v16;
  CFStringRef v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  propertyValueOut = 0;
  v7 = (const void *)atomic_load((unint64_t *)(a2 + 24));
  v8 = VTSessionCopyProperty(v7, propertyKey, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], &propertyValueOut);
  if (v8 == -12900)
  {
LABEL_9:
    v10 = 0;
    goto LABEL_10;
  }
  v9 = v8;
  if (v8)
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v11 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)&buf[4] = v9;
      v16 = 2114;
      v17 = propertyKey;
      _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "VTSessionCopyProperty failed with status %{public}d, key=%{public}@", buf, 0x12u);
    }
    *(_QWORD *)buf = -2011;
    v13 = CFSTR("VTSessionCopyProperty failed.");
    v12 = sub_1D3D73E0C(a4, (uint64_t *)buf, (CFTypeRef *)&v13);
    sub_1D3DF5254(v12, v9);
    goto LABEL_9;
  }
  v10 = propertyValueOut;
LABEL_10:
  *a1 = v10;
}

uint64_t sub_1D3DC2CF4(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  unint64_t v10;
  unint64_t v12;
  _QWORD *v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  const void *v25;
  unint64_t v26;
  const void *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;
  OpaqueVTPixelTransferSession *v32;
  __CVBuffer *v33;
  __CVBuffer *v34;
  OSStatus v35;
  NSObject *v36;
  _QWORD *v37;
  uint64_t v38;
  const __CFString *v39;
  CFDictionaryRef DictionaryRepresentation;
  const __CFString *v41;
  uint8_t v42[8];
  _QWORD v43[3];
  _QWORD *v44;
  _QWORD v45[3];
  _QWORD *v46;
  uint8_t buf[8];
  _QWORD v48[3];
  _QWORD *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!atomic_load((unint64_t *)(a1 + 24)))
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v19 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v19, OS_LOG_TYPE_ERROR, "Invalid pixel transfer session.", buf, 2u);
    }
    *(_QWORD *)buf = -2004;
    v41 = CFSTR("Invalid pixel transfer session.");
    sub_1D3D73E0C(a6, (uint64_t *)buf, (CFTypeRef *)&v41);
    return 0;
  }
  v10 = atomic_load(a2);
  if (!v10 || (v12 = atomic_load(a3)) == 0)
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v18 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v18, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", buf, 2u);
    }
    *(_QWORD *)buf = -2004;
    v41 = CFSTR("Invalid source and/or destination buffer.");
    sub_1D3D73E0C(a6, (uint64_t *)buf, (CFTypeRef *)&v41);
    return 0;
  }
  v45[0] = &off_1E95B3030;
  v45[1] = a1;
  v46 = v45;
  *(_QWORD *)buf = a7;
  v43[0] = &off_1E95B30B0;
  v43[1] = a1;
  v44 = v43;
  v48[0] = &off_1E95B30B0;
  v48[1] = a1;
  v49 = v48;
  if (!*(_BYTE *)(a7 + 8)
    || (v41 = *(const __CFString **)a7, sub_1D3DC31E8((uint64_t)v45, (os_signpost_id_t *)&v41), v16 = v44, v44 == v43))
  {
    v17 = 4;
    v16 = v43;
  }
  else
  {
    if (!v44)
      goto LABEL_22;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_22:
  v22 = v46;
  if (v46 == v45)
  {
    v23 = 4;
    v22 = v45;
  }
  else
  {
    if (!v46)
      goto LABEL_27;
    v23 = 5;
  }
  (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_27:
  v41 = 0;
  if (*(_BYTE *)(a4 + 32))
  {
    DictionaryRepresentation = CGRectCreateDictionaryRepresentation(*(CGRect *)a4);
    do
      v24 = __ldaxr((unint64_t *)&DictionaryRepresentation);
    while (__stlxr(0, (unint64_t *)&DictionaryRepresentation));
    do
      v25 = (const void *)__ldaxr((unint64_t *)&v41);
    while (__stlxr(v24, (unint64_t *)&v41));
    if (v25)
      CFRelease(v25);
    sub_1D3D8BAAC((unint64_t *)&DictionaryRepresentation);
  }
  DictionaryRepresentation = 0;
  if (*(_BYTE *)(a5 + 32))
  {
    *(_QWORD *)v42 = CGRectCreateDictionaryRepresentation(*(CGRect *)a5);
    do
      v26 = __ldaxr((unint64_t *)v42);
    while (__stlxr(0, (unint64_t *)v42));
    do
      v27 = (const void *)__ldaxr((unint64_t *)&DictionaryRepresentation);
    while (__stlxr(v26, (unint64_t *)&DictionaryRepresentation));
    if (v27)
      CFRelease(v27);
    sub_1D3D8BAAC((unint64_t *)v42);
  }
  v28 = (const __CFString *)*MEMORY[0x1E0CED850];
  v29 = (const __CFString *)atomic_load((unint64_t *)&v41);
  if (sub_1D3DC32E4(a1, v28, v29, a6))
  {
    v30 = (const __CFString *)*MEMORY[0x1E0CED7D0];
    v31 = (const __CFString *)atomic_load((unint64_t *)&DictionaryRepresentation);
    if (sub_1D3DC32E4(a1, v30, v31, a6))
    {
      v32 = (OpaqueVTPixelTransferSession *)atomic_load((unint64_t *)(a1 + 24));
      v33 = (__CVBuffer *)atomic_load(a2);
      v34 = (__CVBuffer *)atomic_load(a3);
      v35 = VTPixelTransferSessionTransferImage(v32, v33, v34);
      if (!v35)
      {
        v20 = 1;
        goto LABEL_50;
      }
      if (qword_1EFE31850 != -1)
        dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
      v36 = qword_1EFE31848;
      if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v42 = 67240192;
        *(_DWORD *)&v42[4] = v35;
        _os_log_error_impl(&dword_1D3D6B000, v36, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionTransferImage failed: %{public}d", v42, 8u);
      }
      *(_QWORD *)v42 = -2004;
      v39 = CFSTR("VTPixelTransferSessionTransferImage failed.");
      sub_1D3D73E0C(a6, (uint64_t *)v42, (CFTypeRef *)&v39);
      sub_1D3DF5254((uint64_t)a6, v35);
    }
  }
  v20 = 0;
LABEL_50:
  sub_1D3D8BAAC((unint64_t *)&DictionaryRepresentation);
  sub_1D3D8BAAC((unint64_t *)&v41);
  v37 = v49;
  if (*(_BYTE *)(*(_QWORD *)buf + 8))
  {
    if (!v49)
      return v20;
    v41 = **(const __CFString ***)buf;
    (*(void (**)(void))(*v49 + 48))();
    v37 = v49;
  }
  if (v37 == v48)
  {
    v38 = 4;
    v37 = v48;
    goto LABEL_57;
  }
  if (v37)
  {
    v38 = 5;
LABEL_57:
    (*(void (**)(void))(*v37 + 8 * v38))();
  }
  return v20;
}

void sub_1D3DC3184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  unint64_t v4;
  va_list va;
  unint64_t v6;
  va_list va1;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v6 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  sub_1D3D8BAAC((unint64_t *)va);
  sub_1D3D8BAAC((unint64_t *)va1);
  sub_1D3D87C3C((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1D3DC31E8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  uint64_t v3;
  NSObject *v4;
  const __CFString *v5;
  int v6;
  const __CFString *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (qword_1EFE31850 != -1)
    dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EFE31848;
    if (os_signpost_enabled((os_log_t)qword_1EFE31848))
    {
      v5 = (const __CFString *)atomic_load((unint64_t *)(v3 + 16));
      if (!v5)
        v5 = CFSTR("<anonymous>");
      v6 = 138543362;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::transferImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

BOOL sub_1D3DC32E4(uint64_t a1, const __CFString *a2, const __CFString *a3, unint64_t *a4)
{
  const void *v7;
  OSStatus v8;
  NSObject *v9;
  uint64_t v10;
  const __CFString *v12;
  const __CFString *v13;
  uint8_t buf[8];
  __int16 v15;
  const __CFString *v16;
  __int16 v17;
  const __CFString *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v7 = (const void *)atomic_load((unint64_t *)(a1 + 24));
  v8 = VTSessionSetProperty(v7, a2, a3);
  if (v8)
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v9 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      v12 = CFSTR("<null>");
      *(_DWORD *)buf = 67240706;
      if (a3)
        v12 = a3;
      *(_DWORD *)&buf[4] = v8;
      v15 = 2114;
      v16 = a2;
      v17 = 2114;
      v18 = v12;
      _os_log_error_impl(&dword_1D3D6B000, v9, OS_LOG_TYPE_ERROR, "VTSessionSetProperty failed with status %{public}d, key=%{public}@, value=%{public}@", buf, 0x1Cu);
    }
    v13 = CFSTR("VTSessionSetProperty failed.");
    *(_QWORD *)buf = -2011;
    v10 = sub_1D3D73E0C(a4, (uint64_t *)buf, (CFTypeRef *)&v13);
    sub_1D3DF5254(v10, v8);
  }
  return v8 == 0;
}

void sub_1D3DC3430()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DC3444(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B30B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DC3478(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B30B0;
  a2[1] = v2;
  return result;
}

void sub_1D3DC3494(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  uint64_t v3;
  NSObject *v4;
  const __CFString *v5;
  int v6;
  const __CFString *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (qword_1EFE31850 != -1)
    dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EFE31848;
    if (os_signpost_enabled((os_log_t)qword_1EFE31848))
    {
      v5 = (const __CFString *)atomic_load((unint64_t *)(v3 + 16));
      if (!v5)
        v5 = CFSTR("<anonymous>");
      v6 = 138543362;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::transferImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1D3DC3590(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelTransferSession13transferImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DC35C8()
{
  return &unk_1E95B3110;
}

void sub_1D3DC35D8()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DC35EC(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B3030;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DC3620(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B3030;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3DC363C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelTransferSession13transferImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DC3674()
{
  return &unk_1E95B3090;
}

_QWORD *sub_1D3DC3680(_QWORD *a1)
{
  unint64_t *v2;
  OpaqueVTPixelTransferSession *v4;

  v2 = a1 + 3;
  if (atomic_load(a1 + 3))
  {
    v4 = (OpaqueVTPixelTransferSession *)atomic_load(v2);
    VTPixelTransferSessionInvalidate(v4);
  }
  *a1 = off_1E95B2FC0;
  sub_1D3D94AD4(v2);
  *a1 = off_1E95B2E98;
  sub_1D3D8C70C(a1 + 2);
  return a1;
}

void sub_1D3DC36EC(_QWORD *a1)
{
  sub_1D3DC4200(a1);
  JUMPOUT(0x1D8254C54);
}

unint64_t *sub_1D3DC3714@<X0>(uint64_t a1@<X0>, CFDictionaryRef *a2@<X8>)
{
  const __CFString *v3;
  const void *v4;
  const __CFAllocator *v5;
  OSStatus v6;
  int v7;
  const void *v8;
  NSObject *v9;
  unint64_t v10;
  const void *v11;
  CFTypeID v12;
  const void *v13;
  unint64_t *result;
  const void *v15;
  unint64_t v16[12];
  char v17;
  const __CFString *v18;
  void *keys;
  __int16 v20;
  const __CFString *v21;
  const void *propertyValueOut[2];

  propertyValueOut[1] = *(const void **)MEMORY[0x1E0C80C00];
  LOBYTE(v16[0]) = 0;
  v17 = 0;
  v3 = (const __CFString *)*MEMORY[0x1E0CED798];
  propertyValueOut[0] = 0;
  v4 = (const void *)atomic_load((unint64_t *)(a1 + 24));
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = VTSessionCopyProperty(v4, v3, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], propertyValueOut);
  v7 = v6;
  if (v6 == -12900)
  {
LABEL_9:
    v8 = 0;
    goto LABEL_10;
  }
  if (v6)
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v9 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      LODWORD(keys) = 67240450;
      HIDWORD(keys) = v7;
      v20 = 2114;
      v21 = v3;
      _os_log_error_impl(&dword_1D3D6B000, v9, OS_LOG_TYPE_ERROR, "VTSessionCopyProperty failed with status %{public}d, key=%{public}@", (uint8_t *)&keys, 0x12u);
    }
    v18 = CFSTR("VTSessionCopyProperty failed.");
    keys = (void *)-2011;
    sub_1D3D73E0C(v16, (uint64_t *)&keys, (CFTypeRef *)&v18);
    sub_1D3DF5254((uint64_t)v16, v7);
    goto LABEL_9;
  }
  v8 = propertyValueOut[0];
LABEL_10:
  v15 = v8;
  if (v17
    || (v10 = atomic_load((unint64_t *)&v15)) != 0
    && (v11 = (const void *)atomic_load((unint64_t *)&v15), v12 = CFGetTypeID(v11), v12 != CFArrayGetTypeID()))
  {
    *a2 = 0;
  }
  else
  {
    keys = CFSTR("MostRecentChainDescription");
    propertyValueOut[0] = 0;
    v13 = (const void *)atomic_load((unint64_t *)&v15);
    if (!v13)
      v13 = (const void *)*MEMORY[0x1E0C9B0D0];
    propertyValueOut[0] = v13;
    *a2 = CFDictionaryCreate(v5, (const void **)&keys, propertyValueOut, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  result = sub_1D3D8BA0C((unint64_t *)&v15);
  if (v17)
    return sub_1D3DF4F24(v16);
  return result;
}

void sub_1D3DC3924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  sub_1D3D8BA0C(&a10);
  if (a23)
    sub_1D3DF4F24(&a11);
  _Unwind_Resume(a1);
}

const char *sub_1D3DC3954()
{
  return "PixelRotationSession";
}

uint64_t sub_1D3DC3960(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  unint64_t v10;
  unint64_t v12;
  _QWORD *v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  int v25;
  OpaqueVTPixelRotationSession *v26;
  __CVBuffer *v27;
  __CVBuffer *v28;
  OSStatus v29;
  NSObject *v30;
  __CVBuffer *v31;
  __CVBuffer *v32;
  __CVBuffer *v33;
  __CVBuffer *v34;
  int v35;
  NSObject *v36;
  _QWORD *v37;
  uint64_t v38;
  const __CFString *v39;
  _QWORD v40[3];
  _QWORD *v41;
  _QWORD v42[3];
  _QWORD *v43;
  uint8_t buf[8];
  _QWORD v45[3];
  _QWORD *v46;
  uint8_t v47[8];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!atomic_load((unint64_t *)(a1 + 24)))
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v19 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v19, OS_LOG_TYPE_ERROR, "Invalid pixel rotation session.", buf, 2u);
    }
    *(_QWORD *)buf = -2004;
    *(_QWORD *)v47 = CFSTR("Invalid pixel rotation session.");
    sub_1D3D73E0C(a6, (uint64_t *)buf, (CFTypeRef *)v47);
    return 0;
  }
  v10 = atomic_load(a2);
  if (!v10 || (v12 = atomic_load(a3)) == 0)
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v18 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v18, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", buf, 2u);
    }
    *(_QWORD *)buf = -2004;
    *(_QWORD *)v47 = CFSTR("Invalid source and/or destination buffer.");
    sub_1D3D73E0C(a6, (uint64_t *)buf, (CFTypeRef *)v47);
    return 0;
  }
  v42[0] = &off_1E95B3130;
  v42[1] = a1;
  v43 = v42;
  *(_QWORD *)buf = a7;
  v40[0] = &off_1E95B31B0;
  v40[1] = a1;
  v41 = v40;
  v45[0] = &off_1E95B31B0;
  v45[1] = a1;
  v46 = v45;
  if (!*(_BYTE *)(a7 + 8)
    || (*(_QWORD *)v47 = *(_QWORD *)a7, sub_1D3DC3EB0((uint64_t)v42, (os_signpost_id_t *)v47), v16 = v41, v41 == v40))
  {
    v17 = 4;
    v16 = v40;
  }
  else
  {
    if (!v41)
      goto LABEL_22;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_22:
  v22 = v43;
  if (v43 == v42)
  {
    v23 = 4;
    v22 = v42;
  }
  else
  {
    if (!v43)
      goto LABEL_27;
    v23 = 5;
  }
  (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_27:
  v24 = *(unsigned __int8 *)(a4 + 32);
  v25 = *(unsigned __int8 *)(a5 + 32);
  v26 = (OpaqueVTPixelRotationSession *)atomic_load((unint64_t *)(a1 + 24));
  v27 = (__CVBuffer *)atomic_load(a2);
  if (!(v24 | v25))
  {
    v28 = (__CVBuffer *)atomic_load(a3);
    v29 = VTPixelRotationSessionRotateImage(v26, v27, v28);
    if (v29)
    {
      if (qword_1EFE31850 != -1)
        dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
      v30 = qword_1EFE31848;
      if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v47 = 67240192;
        *(_DWORD *)&v47[4] = v29;
        _os_log_error_impl(&dword_1D3D6B000, v30, OS_LOG_TYPE_ERROR, "VTPixelRotationSessionRotateImage failed: %{public}d", v47, 8u);
      }
      *(_QWORD *)v47 = -2004;
      v39 = CFSTR("VTPixelRotationSessionRotateImage failed.");
      sub_1D3D73E0C(a6, (uint64_t *)v47, (CFTypeRef *)&v39);
      sub_1D3DF5254((uint64_t)a6, v29);
      goto LABEL_45;
    }
LABEL_46:
    v20 = 1;
    goto LABEL_47;
  }
  if (!*(_BYTE *)(a4 + 32))
  {
    v31 = (__CVBuffer *)atomic_load(a2);
    CVPixelBufferGetWidth(v31);
    v32 = (__CVBuffer *)atomic_load(a2);
    CVPixelBufferGetHeight(v32);
  }
  atomic_load(a3);
  if (!*(_BYTE *)(a5 + 32))
  {
    v33 = (__CVBuffer *)atomic_load(a3);
    CVPixelBufferGetWidth(v33);
    v34 = (__CVBuffer *)atomic_load(a3);
    CVPixelBufferGetHeight(v34);
  }
  v35 = VTPixelRotationSessionRotateSubImage();
  if (!v35)
    goto LABEL_46;
  if (qword_1EFE31850 != -1)
    dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
  v36 = qword_1EFE31848;
  if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v47 = 67240192;
    *(_DWORD *)&v47[4] = v35;
    _os_log_error_impl(&dword_1D3D6B000, v36, OS_LOG_TYPE_ERROR, "VTPixelRotationSessionRotateSubImage failed: %{public}d", v47, 8u);
  }
  *(_QWORD *)v47 = -2004;
  v39 = CFSTR("VTPixelRotationSessionRotateSubImage failed.");
  sub_1D3D73E0C(a6, (uint64_t *)v47, (CFTypeRef *)&v39);
  sub_1D3DF5254((uint64_t)a6, v35);
LABEL_45:
  v20 = 0;
LABEL_47:
  v37 = v46;
  if (*(_BYTE *)(*(_QWORD *)buf + 8))
  {
    if (!v46)
      return v20;
    *(_QWORD *)v47 = **(_QWORD **)buf;
    (*(void (**)(void))(*v46 + 48))();
    v37 = v46;
  }
  if (v37 == v45)
  {
    v38 = 4;
    v37 = v45;
    goto LABEL_54;
  }
  if (v37)
  {
    v38 = 5;
LABEL_54:
    (*(void (**)(void))(*v37 + 8 * v38))();
  }
  return v20;
}

void sub_1D3DC3E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  sub_1D3D87C3C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D3DC3EB0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  uint64_t v3;
  NSObject *v4;
  const __CFString *v5;
  int v6;
  const __CFString *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (qword_1EFE31850 != -1)
    dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EFE31848;
    if (os_signpost_enabled((os_log_t)qword_1EFE31848))
    {
      v5 = (const __CFString *)atomic_load((unint64_t *)(v3 + 16));
      if (!v5)
        v5 = CFSTR("<anonymous>");
      v6 = 138543362;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelRotationSession::rotateImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

void sub_1D3DC3FB0()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DC3FC4(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B31B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DC3FF8(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B31B0;
  a2[1] = v2;
  return result;
}

void sub_1D3DC4014(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  uint64_t v3;
  NSObject *v4;
  const __CFString *v5;
  int v6;
  const __CFString *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if (qword_1EFE31850 != -1)
    dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = qword_1EFE31848;
    if (os_signpost_enabled((os_log_t)qword_1EFE31848))
    {
      v5 = (const __CFString *)atomic_load((unint64_t *)(v3 + 16));
      if (!v5)
        v5 = CFSTR("<anonymous>");
      v6 = 138543362;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v4, OS_SIGNPOST_INTERVAL_END, v2, "PixelRotationSession::rotateImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1D3DC4110(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelRotationSession11rotateImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DC4148()
{
  return &unk_1E95B3210;
}

void sub_1D3DC4158()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DC416C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E95B3130;
  result[1] = v3;
  return result;
}

uint64_t sub_1D3DC41A0(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E95B3130;
  a2[1] = v2;
  return result;
}

uint64_t sub_1D3DC41BC(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelRotationSession11rotateImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DC41F4()
{
  return &unk_1E95B3190;
}

_QWORD *sub_1D3DC4200(_QWORD *a1)
{
  unint64_t *v2;
  OpaqueVTPixelRotationSession *v4;

  v2 = a1 + 3;
  if (atomic_load(a1 + 3))
  {
    v4 = (OpaqueVTPixelRotationSession *)atomic_load(v2);
    VTPixelRotationSessionInvalidate(v4);
  }
  *a1 = off_1E95B2FF8;
  sub_1D3DC4260(v2);
  *a1 = off_1E95B2E98;
  sub_1D3D8C70C(a1 + 2);
  return a1;
}

unint64_t *sub_1D3DC4260(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1D3DC42A0(uint64_t a1, int a2, unint64_t *a3)
{
  const void *v4;

  *(_QWORD *)a1 = off_1E95B2E98;
  *(_DWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = (const void *)atomic_load(a3);
  sub_1D3D95C6C((unint64_t *)(a1 + 16), v4);
  return a1;
}

void sub_1D3DC42EC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *v1 = v4;
  sub_1D3D8C70C(v2);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC4308(unsigned int **a1, uint64_t a2, int *a3)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t i;
  int64x2_t v20;
  uint64_t v21;
  int32x2_t v27;
  float64x2_t v28;
  const double *v29;
  const double *v30;
  int8x16_t v31;
  int64x2_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float64x2_t v35;
  float64x2_t v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int *v40;
  uint64_t v41;
  int v42;
  int v43;
  int8x16_t v44;
  float64x2_t v45;
  double v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  double v50;
  double v51;
  unsigned int *v52;
  double v53;
  double v54;
  _QWORD *v55;
  int v56;
  int v57;
  double v58;
  double v60;
  BOOL v61;
  int v62;
  uint64_t v63;
  unsigned int **v64;
  unsigned int *v65;
  unsigned int *v66;
  unsigned int v67;
  double v68;
  double v69;
  unsigned int *v70;
  unsigned int *v71;
  __int128 v72;
  unsigned int *v73;
  unsigned int *v74;
  unsigned int v75;
  unsigned int *v76;
  unsigned int *v77;
  unsigned int v78;
  double v79;
  double v80;
  double v81;
  double v82;
  float64x2_t v83;
  double v84;
  double v85;
  double v86;
  BOOL v87;
  BOOL v88;
  double v90;
  double v91;
  double v92;
  float64_t v93;
  BOOL v94;
  int v95;
  double v96;
  int v97;
  int v98;
  double v99;
  double v100;
  uint64_t v101;
  float v102;
  float v103;
  double v104;
  float v105;
  double v106;
  double v107;
  float v108;
  double v109;
  double v110;
  double v111;
  double v112;
  unint64_t v113;
  int v114;
  double v115;
  int v116;
  double v117;
  BOOL v118;
  int v119;
  unsigned int v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  uint64_t v124;
  int v125;
  float64_t v126;
  _QWORD *v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t *v130;
  unsigned int *v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int *v134;
  unsigned int *v135;
  unsigned int *v136;
  unsigned int v137;
  unsigned int *v138;
  unsigned int v139;
  uint64_t j;
  void *v141;
  unsigned int *v142;
  unsigned int *v143;
  unsigned int v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int *v148;
  unsigned int *v149;
  unsigned int v150;
  unsigned int **v151;
  unsigned int *v152;
  unsigned int *v153;
  unsigned int v154;
  unsigned int *v155;
  unsigned int *v156;
  unsigned int v157;
  unsigned int *v158;
  unsigned int *v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int *v162;
  unsigned int *v163;
  unsigned int *v164;
  unsigned int v165;
  unsigned int *v167;
  unsigned int *v168;
  unsigned int *v169;
  unsigned int *v170;
  unsigned int v171;
  unsigned int v172;
  unsigned int *v173;
  _OWORD *v174;
  unint64_t k;
  unsigned int *v176;
  unsigned int *v177;
  unsigned int v178;
  float64_t v179;
  int v180;
  unsigned int *v181;
  unsigned int *v182;
  unsigned int v183;
  unsigned int *v184;
  unsigned int *v185;
  unsigned int v186;
  uint64_t v187;
  char *v188;
  unsigned int *v189;
  unsigned int v190;
  unsigned int **v191;
  char *v192;
  BOOL v193;
  unsigned int *v194;
  unsigned int *v195;
  unsigned int v196;
  unsigned int *v197;
  unsigned int *v198;
  unsigned int v199;
  unsigned int *v200;
  unsigned int *v201;
  unsigned int v202;
  _BOOL4 v203;
  uint64_t *v204;
  uint64_t *v205;
  uint64_t v206;
  unsigned int *v207;
  uint64_t v208;
  unsigned int *v209;
  unsigned int v210;
  uint64_t v211;
  unsigned int *v212;
  unsigned int v213;
  unsigned int *v214;
  uint64_t v215;
  unsigned int *v216;
  int v217;
  unsigned int *v218;
  unsigned int *v219;
  unsigned int *v220;
  unsigned int v221;
  unsigned int *v222;
  unsigned int *v223;
  unsigned int v224;
  float v225;
  float v226;
  float v227;
  float v228;
  uint64_t v229;
  int v230;
  float v231;
  int v232;
  int v233;
  int v234;
  int v235;
  uint64_t v236;
  uint64_t v237;
  int v238;
  uint64_t v239;
  int v240;
  uint64_t v241;
  float v242;
  float v243;
  float v244;
  float v245;
  float v246;
  uint64_t v247;
  float v248;
  float v249;
  float v250;
  float v251;
  float v252;
  uint64_t v253;
  float64_t v254;
  float v255;
  uint64_t v256;
  unsigned int *v257;
  unsigned int v258;
  unsigned int v259;
  unsigned int *v260;
  unsigned int *v261;
  unsigned int *v262;
  unsigned int v263;
  unsigned int *v264;
  unsigned int *v265;
  unsigned int v266;
  BOOL v267;
  float64x2_t *v268;
  unsigned int *v269;
  unsigned int *v270;
  unsigned int v271;
  unsigned int v272;
  unsigned int *v273;
  unsigned int *v274;
  unsigned int v275;
  unsigned int *v276;
  unsigned int *v277;
  unsigned int *v278;
  unsigned int v279;
  unsigned int *v280;
  unsigned int *v281;
  unsigned int v282;
  int v283;
  unsigned int *v284;
  unsigned int *v285;
  unsigned int v286;
  unsigned int *v287;
  unsigned int *v288;
  unsigned int *v289;
  unsigned int v290;
  unsigned int *v291;
  unsigned int *v292;
  unsigned int v293;
  int v294;
  int v295;
  int v296;
  float v297;
  float v298;
  float v299;
  float v300;
  float v301;
  float v302;
  float v303;
  float v304;
  unsigned int *v305;
  float v306;
  float v307;
  int v308;
  unsigned int *v309;
  unsigned int *v310;
  unsigned int v311;
  float64_t v312;
  unsigned int *v313;
  unsigned int v314;
  int v315;
  unsigned int *v316;
  unsigned int *v317;
  unsigned int v318;
  unsigned int *v319;
  unsigned int *v320;
  unsigned int v321;
  unsigned int *v322;
  unsigned int *v323;
  unsigned int v324;
  unsigned int *v325;
  unsigned int *v326;
  unsigned int v327;
  unsigned int *v328;
  unsigned int *v329;
  unsigned int v330;
  unsigned int *v331;
  unsigned int v332;
  unsigned int *v333;
  unsigned int *v334;
  unsigned int *v335;
  unsigned int v336;
  unsigned int *v337;
  unsigned int v338;
  unsigned int *v339;
  unsigned int v340;
  unsigned int *v341;
  unsigned int *v342;
  unsigned int v343;
  double v346;
  double v347;
  double v348;
  double v349;
  double v350;
  double v351;
  float64x2_t v352;
  float64x2_t v353;
  uint64_t v354;
  int v355;
  float64x2_t v356;
  double v357;
  double v358;
  uint64_t v359;
  unsigned int *v360;
  unsigned int *v361;
  unsigned int *v362;
  double v363;
  double v364;
  unsigned int *v365;
  unsigned int *v366;
  unsigned int *v367;
  uint64_t *v368[3];
  unsigned int *v369;
  unsigned int *v370;
  unsigned int *v371;
  unsigned int *v372;
  float64x2_t v373;
  float64x2_t v374;
  uint64_t v375;
  unsigned int *v376;
  float64x2_t v377;
  double v378;
  unsigned int *v379;
  unsigned int *v380;
  float64x2_t v381;
  float64x2_t v382;
  uint64_t v383;
  unsigned int *v384;
  void *__p;
  float64x2_t v386;
  float64x2_t v387;
  uint64_t v388;
  unsigned int *v389;
  double v390;
  double v391;
  uint64_t (**v392)();
  uint64_t v393;
  unsigned int *v394;
  unsigned int **v395;
  int v396;
  unsigned int *v397;
  unsigned int *v398;
  unsigned int *v399;
  uint64_t **v400;
  unsigned int *v401;
  unsigned int *v402;
  unsigned int *v403;
  unsigned int *v404;
  unsigned int *v405;
  unsigned int *v406;
  unsigned int *v407;
  unsigned int *v408;
  unsigned int *v409;
  double v410;
  double v411;
  unsigned int *v412;
  unsigned int ***v413;
  __int128 v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  __int128 v418;
  uint64_t v419;
  float64x2_t *v420;
  unsigned int *v421;
  unsigned int **v422;
  char v423;
  float v424;
  float v425;
  float v426;
  _BYTE v427[40];
  float v428;
  float v429;
  float v430;
  _QWORD v431[5];
  float v432;
  float v433;
  float v434;
  double *v435;
  _QWORD v436[4];
  float v437;
  float v438;
  float v439;
  float64x2_t v440;
  double v441;
  _QWORD *v442;
  double v443;
  uint64_t v444;
  double v445;
  uint64_t v446;
  uint64_t v447;

  v447 = *MEMORY[0x1E0C80C00];
  v370 = 0;
  v371 = 0;
  v368[0] = (uint64_t *)&v369;
  v368[1] = (uint64_t *)&v370;
  v368[2] = (uint64_t *)&v371;
  v369 = 0;
  (*(void (**)(unsigned int **__return_ptr))(**(_QWORD **)(*(_QWORD *)a2 + 16) + 16))(&v367);
  LODWORD(v393) = 0;
  v392 = &off_1E95AF210;
  v394 = 0;
  v4 = v367;
  if (v367)
  {
    v5 = v367 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    if (v394)
      sub_1D3D6D13C(v394);
  }
  v394 = v4;
  sub_1D3D6D10C(&v367);
  v355 = *a3;
  v7 = v394;
  v8 = *((_QWORD *)v394 + 7);
  v9 = -v8;
  v10 = *((_QWORD *)v394 + 4);
  v11 = v10 & -v8--;
  v12 = *((_QWORD *)v394 + 2);
  LOBYTE(v377.f64[0]) = 0;
  *(_QWORD *)&v377.f64[1] = v12 & v8 | v11;
  *(_QWORD *)&v378 = v10 & v8 | v12 & v9;
  v379 = 0;
  v13 = v394 + 2;
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 + 1, v13));
  if (v379)
    sub_1D3D6D13C(v379);
  v379 = v7;
  v407 = 0;
  if (v355 < 0)
  {
    v15 = (unsigned int *)operator new();
    sub_1D3D938C4((uint64_t)v15, *((_QWORD *)v394 + 2) & (*((_QWORD *)v394 + 7) - 1) | *((_QWORD *)v394 + 4) & -*((_QWORD *)v394 + 7), *((_QWORD *)v394 + 4) & (*((_QWORD *)v394 + 7) - 1) | *((_QWORD *)v394 + 2) & -*((_QWORD *)v394 + 7));
    v16 = v15 + 2;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    if (v407)
      sub_1D3D6D13C(v407);
    v407 = v15;
  }
  v18 = 0;
  for (i = 0; i != 4; ++i)
  {
    sub_1D3E1CD9C((uint64_t)&v420 + v18);
    v18 += 56;
  }
  v21 = 0;
  v414 = xmmword_1D3E82050;
  v417 = 0;
  v415 = 0x3FF0000000000000;
  v416 = 0;
  v418 = xmmword_1D3E82050;
  v419 = 0x3FF0000000000000;
  __asm
  {
    FMOV            V1.2D, #8.0
    FMOV            V0.2D, #0.5
  }
  v352 = _Q0;
  v353 = _Q1;
  v27 = vdup_n_s32(0x7FC00000u);
  do
  {
    v28 = (float64x2_t)*(&v414 + v21);
    v29 = (const double *)(v394 + 8);
    v30 = (const double *)(v394 + 4);
    v20.i64[0] = *((_QWORD *)v394 + 7);
    v31.i64[0] = vnegq_s64(v20).u64[0];
    v32.i64[0] = -1;
    v32.i64[1] = -1;
    v31.i64[1] = vaddq_s64(vdupq_n_s64(*(_QWORD *)(v394 + 56)), v32).i64[1];
    v33 = (int8x16_t)vld1q_dup_f64(v30);
    v34 = (int8x16_t)vld1q_dup_f64(v29);
    v372 = (unsigned int *)&v377;
    v35 = vcvtq_f64_u64(vshrq_n_u64((uint64x2_t)vorrq_s8(vandq_s8(v34, v31), vandq_s8(v33, vextq_s8(v31, v31, 8uLL))), 1uLL));
    v356 = vaddq_f64(vrndmq_f64(vaddq_f64(vmulq_f64(v28, v353), vsubq_f64(v35, vmulq_f64(v28, v35)))), v352);
    v373 = v356;
    v375 = 1;
    v36 = vabsq_f64(v28);
    if (v36.f64[0] < v36.f64[1])
      v36.f64[0] = v36.f64[1];
    v374 = vdivq_f64(v28, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v36.f64[0], 0));
    v376 = 0;
    if (v355 < 0)
    {
      v37 = v407;
      if (v407)
      {
        v38 = v407 + 2;
        do
          v39 = __ldxr(v38);
        while (__stxr(v39 + 1, v38));
        v40 = v37;
        if (v376)
        {
          sub_1D3D6D13C(v376);
          v40 = v407;
        }
      }
      else
      {
        v40 = 0;
      }
      v376 = v37;
      v41 = *((_QWORD *)v40 + 5);
      if (v41 >= 1)
        bzero(*((void **)v40 + 6), 4 * (v41 - ((v41 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
    }
    v354 = v21;
    v42 = 1;
    while (2)
    {
      v43 = (8 * v42) & 0x7FFFFFF0;
      if ((v42 & 1) != 0)
        v43 = -v43;
      v44 = (int8x16_t)vmulq_n_f64(v374, (double)v43);
      v45 = (float64x2_t)vextq_s8(v44, v44, 8uLL);
      v46 = vsubq_f64(v356, v45).f64[0];
      v47 = vaddq_f64(v356, v45);
      v48.f64[0] = v46;
      v48.f64[1] = v47.f64[1];
      v373 = v48;
      if (v46 >= 0.0
        && v46 < (double)*((unint64_t *)v372 + 1)
        && v47.f64[1] >= 0.0
        && v47.f64[1] < (double)*((unint64_t *)v372 + 2))
      {
        do
        {
          v49 = v374;
          v50 = v374.f64[0] + v373.f64[0];
          v51 = v374.f64[1] + v373.f64[1];
          v373.f64[0] = v50;
          v373.f64[1] = v374.f64[1] + v373.f64[1];
          if (v50 < 0.0
            || (v52 = v372, v53 = (double)*((unint64_t *)v372 + 1), v50 >= v53)
            || v51 < 0.0
            || (v54 = (double)*((unint64_t *)v372 + 2), v51 >= v54))
          {
            v406 = 0;
            goto LABEL_161;
          }
          v55 = (_QWORD *)*((_QWORD *)v372 + 3);
          v56 = sub_1D3D6D4A0(v55, (int)v50, (int)v51);
          v57 = *(unsigned __int8 *)v52;
          v58 = v50 - v49.f64[0];
          _NF = v50 - v49.f64[0] >= 0.0 && v58 < v53;
          if (_NF
            && ((v60 = v51 - v49.f64[1], v51 - v49.f64[1] >= 0.0) ? (v61 = v60 < v54) : (v61 = 0),
                v61 && (v57 != sub_1D3D6D4A0(v55, (int)v58, (int)v60)) == (v57 != v56)))
          {
            v62 = 2;
          }
          else
          {
            v63 = 0;
            LODWORD(v375) = v57 == v56;
            HIDWORD(v375) = v57 != v56;
            v391 = 0.0;
            v390 = 0.0;
            v363 = 0.0;
            v364 = 0.0;
            v357 = 0.0;
            v358 = 0.0;
            v411 = 0.0;
            v410 = 0.0;
            do
            {
              v64 = (unsigned int **)((char *)&v420 + v63);
              v64[1] = *(unsigned int **)((char *)&v420 + v63);
              v64[3] = 0;
              v64[4] = 0;
              *((_DWORD *)v64 + 12) = 2143289344;
              v64[5] = (unsigned int *)v27;
              v63 += 56;
            }
            while (v63 != 224);
            __p = v52;
            v386 = v373;
            v387 = v374;
            LODWORD(v388) = v57 == v56;
            HIDWORD(v388) = v57 != v56;
            v389 = 0;
            v65 = v376;
            if (v376)
            {
              v66 = v376 + 2;
              do
                v67 = __ldxr(v66);
              while (__stxr(v67 + 1, v66));
              if (v389)
                sub_1D3D6D13C(v389);
            }
            v389 = v65;
            v68 = v387.f64[0];
            v69 = -v387.f64[1];
            v387.f64[0] = -v387.f64[1];
            v387.f64[1] = v68;
            if (sub_1D3E1CDEC((double *)&__p, (uint64_t)&v420, -v68, v69)
              && sub_1D3E1CF20((uint64_t)&__p, (uint64_t)&v390, -v387.f64[1], v387.f64[0]))
            {
              if (v420 != (float64x2_t *)v421)
              {
                v70 = v421 - 4;
                if (v421 - 4 > (unsigned int *)v420)
                {
                  v71 = (unsigned int *)&v420[1];
                  do
                  {
                    v72 = *((_OWORD *)v71 - 1);
                    *((_OWORD *)v71 - 1) = *(_OWORD *)v70;
                    *(_OWORD *)v70 = v72;
                    v70 -= 4;
                    _CF = v71 >= v70;
                    v71 += 4;
                  }
                  while (!_CF);
                }
              }
              v380 = (unsigned int *)__p;
              v381 = v386;
              v382 = v387;
              v383 = v388;
              v384 = 0;
              v73 = v389;
              if (v389)
              {
                v74 = v389 + 2;
                do
                  v75 = __ldxr(v74);
                while (__stxr(v75 + 1, v74));
                if (v384)
                  sub_1D3D6D13C(v384);
              }
              v384 = v73;
              __p = v372;
              v386 = v373;
              v387 = v374;
              v388 = v375;
              v76 = v376;
              if (v376)
              {
                v77 = v376 + 2;
                do
                  v78 = __ldxr(v77);
                while (__stxr(v78 + 1, v77));
              }
              if (v389)
                sub_1D3D6D13C(v389);
              v389 = v76;
              v79 = fabs(v382.f64[1]);
              v80 = fabs(v382.f64[0]);
              if (v79 < v80)
                v79 = v80;
              v387.f64[0] = -v382.f64[1] / v79;
              v387.f64[1] = v382.f64[0] / v79;
              if (!sub_1D3E1CDEC((double *)&__p, (uint64_t)&v420, v382.f64[0] / v79, -v387.f64[0]))
                goto LABEL_126;
              v81 = v387.f64[1];
              v82 = -v387.f64[0];
              if (!sub_1D3E1CF20((uint64_t)&__p, (uint64_t)&v363, v387.f64[1], -v387.f64[0]))
                goto LABEL_126;
              if (!sub_1D3E1CDEC((double *)&__p, (uint64_t)v427, v387.f64[1], -v387.f64[0]))
                goto LABEL_126;
              v83 = v387;
              if (!sub_1D3E1CF20((uint64_t)&__p, (uint64_t)&v357, v387.f64[1], -v387.f64[0]))
                goto LABEL_126;
              v84 = v391;
              v85 = sqrt((v391 - v364) * (v391 - v364) + (v390 - v363) * (v390 - v363)) + -1.0;
              v86 = sqrt((v364 - v358) * (v364 - v358) + (v363 - v357) * (v363 - v357)) + -1.0;
              v87 = v85 < 8.0 || v86 < 10.0;
              v88 = v87 || v86 < v85 * 0.25;
              if (v88 || v86 > v85 * 8.0)
                goto LABEL_126;
              v348 = v357;
              v350 = v390;
              v346 = v358;
              v90 = fabs(v83.f64[0]);
              v91 = fabs(v83.f64[1]);
              if (v90 < v91)
                v90 = v91;
              v92 = v83.f64[0] / v90;
              v93 = v83.f64[1] / v90;
              v382.f64[0] = v83.f64[0] / v90;
              v382.f64[1] = v83.f64[1] / v90;
              sub_1D3E1CD9C((uint64_t)&v440);
              v94 = sub_1D3E1D0B8((double *)&v380, (uint64_t)&v435, (int)(v86 / 5.0 + 1.0), (float *)&v440, -v93, v92);
              if (*(_QWORD *)&v440.f64[0])
              {
                v440.f64[1] = v440.f64[0];
                operator delete(*(void **)&v440.f64[0]);
              }
              if (!v94)
                goto LABEL_126;
              if (v436[0] - (_QWORD)v435 < 0x11uLL)
                v95 = 0;
              else
                v95 = (int)sqrt((v435[1] - *(double *)(v436[0] - 8)) * (v435[1] - *(double *)(v436[0] - 8))+ (*v435 - *(double *)(v436[0] - 16)) * (*v435 - *(double *)(v436[0] - 16)));
              v96 = -v81;
              v97 = v95 / 3;
              if (v97 >= (int)(v85 / 5.0))
                v97 = (int)(v85 / 5.0);
              v98 = 2 * v97;
              v99 = fabs(v82);
              v100 = fabs(v96);
              if (v99 < v100)
                v99 = v100;
              v387.f64[0] = v82 / v99;
              v387.f64[1] = v96 / v99;
              if (!sub_1D3E1D0B8((double *)&__p, (uint64_t)v431, 2 * v97, (float *)&v435, v96 / v99, -(v82 / v99)))
                goto LABEL_126;
              if (!sub_1D3E1CF20((uint64_t)&__p, (uint64_t)&v410, v387.f64[1], -v387.f64[0]))
                goto LABEL_126;
              if (vabdd_f64(sqrt((v84 - v411) * (v84 - v411) + (v350 - v410) * (v350 - v410)) + -1.0, v86) / v86 >= 0.5)
                goto LABEL_126;
              if (vabdd_f64(sqrt((v411 - v346) * (v411 - v346) + (v410 - v348) * (v410 - v348)) + -1.0, v85) / v85 >= 0.5)
                goto LABEL_126;
              if (v436[0] - (_QWORD)v435 < 0x41uLL)
                goto LABEL_126;
              if (v431[1] - v431[0] <= 0x40uLL)
                goto LABEL_126;
              if (!sub_1D3E1D0B8((double *)&v380, (uint64_t)&v435, v98, (float *)v431, -v382.f64[1], v382.f64[0]))
                goto LABEL_126;
              v101 = 0;
              *(_QWORD *)&v440.f64[0] = &v420;
              *(_QWORD *)&v440.f64[1] = v427;
              v441 = COERCE_DOUBLE(&v435);
              v442 = v431;
              do
                sub_1D3E1D47C(*(_QWORD *)&v440.f64[v101++], 0, 1.0);
              while (v101 != 4);
              v102 = (float)(v428 * v425) - (float)(v429 * v424);
              v351 = (float)((float)((float)(v430 * v425) - (float)(v429 * v426)) / v102);
              v363 = v351;
              v364 = (float)((float)((float)(v428 * v426) - (float)(v430 * v424)) / v102);
              v347 = v364;
              v103 = (float)(v437 * v425) - (float)(v438 * v424);
              v104 = (float)((float)((float)(v437 * v426) - (float)(v439 * v424)) / v103);
              v390 = (float)((float)((float)(v439 * v425) - (float)(v438 * v426)) / v103);
              v391 = v104;
              v105 = (float)(v437 * v433) - (float)(v438 * v432);
              v106 = (float)((float)((float)(v439 * v433) - (float)(v438 * v434)) / v105);
              v107 = (float)((float)((float)(v437 * v434) - (float)(v439 * v432)) / v105);
              v410 = v106;
              v411 = v107;
              v108 = (float)(v428 * v433) - (float)(v429 * v432);
              v109 = (float)((float)((float)(v430 * v433) - (float)(v429 * v434)) / v108);
              v357 = v109;
              v358 = (float)((float)((float)(v428 * v434) - (float)(v430 * v432)) / v108);
              v110 = v358;
              v349 = v390;
              v111 = sub_1D3E1D67C((uint64_t)&v435, v390, v104, v106, v107);
              if (((*(_QWORD *)&v111 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF)
                goto LABEL_126;
              v112 = sub_1D3E1D67C((uint64_t)v431, v109, v110, v106, v107);
              if (((*(_QWORD *)&v112 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF)
              {
                v113 = 0;
                v114 = (int)(v111 + 0.5);
                v115 = vabdd_f64(v111, (double)v114);
                v116 = (int)(v112 + 0.5);
                v117 = vabdd_f64(v112, (double)v116);
                v118 = 1;
                while (1)
                {
                  v119 = dword_1D3E6F7C0[v113];
                  v120 = v114 - v119;
                  if (v114 - v119 < 0)
                    v120 = v119 - v114;
                  if (v120 <= 1)
                  {
                    v121 = dword_1D3E6F7A8[v113];
                    v122 = v116 - v121;
                    if (v116 - v121 < 0)
                      v122 = v121 - v116;
                    if (v122 < 2)
                      break;
                  }
                  v118 = v113++ < 5;
                  if (v113 == 6)
                    goto LABEL_132;
                }
                v114 = dword_1D3E6F7C0[v113];
                v116 = dword_1D3E6F7A8[v113];
                if (v118)
                  goto LABEL_142;
LABEL_132:
                v123 = v114 - v116;
                if (v114 - v116 < 0)
                  v123 = v116 - v114;
                if (v117 >= v115)
                  v119 = v114;
                else
                  v119 = v116;
                if (v123 <= 5)
                  v121 = v119;
                else
                  v121 = v116;
                if (v123 > 5)
                  v119 = v114;
LABEL_142:
                v62 = 2;
                if ((v119 - 5) <= 0x43 && v121 >= 4 && v121 <= 72)
                {
                  v124 = (2 * v119);
                  v125 = 2 * v121;
                  v440.f64[0] = sub_1D3E1D9F8(v349, v104, v106, v107, v351, v347, 0.5);
                  v440.f64[1] = v126;
                  v441 = sub_1D3E1D9F8(v106, v107, v109, v110, v349, v104, 0.3);
                  v442 = v127;
                  v443 = sub_1D3E1D9F8(v109, v110, v351, v347, v106, v107, 0.5);
                  v444 = v128;
                  v445 = sub_1D3E1D9F8(v351, v347, v349, v104, v109, v110, 0.5);
                  v446 = v129;
                  v412 = 0;
                  v130 = (unint64_t *)v372;
                  sub_1D3E1DA64((uint64_t *)&v409, v440.f64, v124, v125);
                  sub_1D3E1DAE0((uint64_t *)&v413, v130, v124, v125, &v409, v57 != v56);
                  v131 = (unsigned int *)v413;
                  if (v413)
                  {
                    v132 = (unsigned int *)(v413 + 1);
                    do
                      v133 = __ldxr(v132);
                    while (__stxr(v133 + 1, v132));
                  }
                  if (v412)
                    sub_1D3D6D13C(v412);
                  v412 = v131;
                  sub_1D3D6D10C((unsigned int **)&v413);
                  sub_1D3D6F2E0(&v409);
                  if (v412)
                  {
                    v134 = (unsigned int *)operator new();
                    v135 = v412;
                    if (v412)
                    {
                      v136 = v412 + 2;
                      do
                        v137 = __ldxr(v136);
                      while (__stxr(v137 + 1, v136));
                    }
                    v408 = v135;
                    sub_1D3E1DD44(&v395, &v440);
                    sub_1D3DB4618((uint64_t)v134, (uint64_t *)&v408, &v395, v57 != v56);
                    v138 = v134 + 2;
                    do
                      v139 = __ldxr(v138);
                    while (__stxr(v139 + 1, v138));
                    v406 = v134;
                    v413 = &v395;
                    sub_1D3D6D79C((void ***)&v413);
                    sub_1D3D6D10C(&v408);
                    v62 = 1;
                  }
                  else
                  {
                    v62 = 2;
                  }
                  sub_1D3D6D10C(&v412);
                }
              }
              else
              {
LABEL_126:
                v62 = 2;
              }
              sub_1D3D6D10C(&v384);
            }
            else
            {
              v62 = 2;
            }
            sub_1D3D6D10C(&v389);
          }
        }
        while (v62 == 2);
        if (v406)
        {
          sub_1D3D6D10C(&v376);
          goto LABEL_165;
        }
LABEL_161:
        sub_1D3DC6848(&v406);
        ++v42;
        if (v355 < 0)
          continue;
      }
      break;
    }
    sub_1D3D6D10C(&v376);
    v21 = v354 + 1;
  }
  while (v354 != 3);
  v406 = 0;
LABEL_165:
  for (j = 0; j != -28; j -= 7)
  {
    v141 = (void *)v436[j - 1];
    if (v141)
    {
      v436[j] = v141;
      operator delete(v141);
    }
  }
  sub_1D3D6D10C(&v407);
  sub_1D3D6D10C(&v379);
  v142 = v406;
  if (v406)
  {
    v143 = v406 + 2;
    do
      v144 = __ldxr(v143);
    while (__stxr(v144 + 1, v143));
  }
  if (v370)
    sub_1D3D6D13C(v370);
  v370 = v142;
  sub_1D3DC6848(&v406);
  if (v370)
  {
    v145 = (unsigned int *)*((_QWORD *)v370 + 8);
    if (v145)
    {
      v146 = v145 + 2;
      do
        v147 = __ldxr(v146);
      while (__stxr(v147 + 1, v146));
    }
    v366 = v145;
    sub_1D3DC7D80((unsigned int **)&v420, &v366);
    v148 = (unsigned int *)v420;
    if (v420)
    {
      v149 = (unsigned int *)&v420->f64[1];
      do
        v150 = __ldxr(v149);
      while (__stxr(v150 + 1, v149));
    }
    if (v369)
      sub_1D3D6D13C(v369);
    v369 = v148;
    sub_1D3D7F814((unsigned int **)&v420);
    sub_1D3D6D10C(&v366);
    if (v369)
    {
      sub_1D3DC6878(a1, v368);
      v392 = &off_1E95AF210;
      v151 = &v394;
LABEL_207:
      sub_1D3D6D10C(v151);
      goto LABEL_213;
    }
  }
  v392 = &off_1E95AF210;
  sub_1D3D6D10C(&v394);
  (*(void (**)(unsigned int **__return_ptr))(**(_QWORD **)(*(_QWORD *)a2 + 16) + 16))(&v362);
  LODWORD(v364) = 0;
  v363 = COERCE_DOUBLE(&off_1E95AF1B0);
  v365 = 0;
  v152 = v362;
  if (v362)
  {
    v153 = v362 + 2;
    do
      v154 = __ldxr(v153);
    while (__stxr(v154 + 1, v153));
    if (v365)
      sub_1D3D6D13C(v365);
  }
  v365 = v152;
  sub_1D3D6D10C(&v362);
  sub_1D3DCBCB0((uint64_t *)&v420, (uint64_t)&v363, *((unsigned __int8 *)a3 + 16));
  v155 = (unsigned int *)v420;
  if (v420)
  {
    v156 = (unsigned int *)&v420->f64[1];
    do
      v157 = __ldxr(v156);
    while (__stxr(v157 + 1, v156));
  }
  if (v370)
    sub_1D3D6D13C(v370);
  v370 = v155;
  sub_1D3DC6848((unsigned int **)&v420);
  if (v370)
  {
    v158 = (unsigned int *)*((_QWORD *)v370 + 10);
    if (v158)
    {
      v159 = v158 + 2;
      do
        v160 = __ldxr(v159);
      while (__stxr(v160 + 1, v159));
      do
        v161 = __ldxr(v159);
      while (__stxr(v161 + 1, v159));
      v162 = v158;
    }
    else
    {
      v162 = 0;
    }
    v420 = (float64x2_t *)v162;
    if (v369)
      sub_1D3D6D13C(v369);
    v369 = v158;
    sub_1D3D7F814((unsigned int **)&v420);
    if (v369)
    {
      sub_1D3DC6878(a1, v368);
LABEL_206:
      v363 = COERCE_DOUBLE(&off_1E95AF1B0);
      v151 = &v365;
      goto LABEL_207;
    }
    if (*a3 < 0)
    {
      v422 = 0;
      v420 = 0;
      v421 = 0;
      sub_1D3D6D6A8((unsigned int *)&v420, *((unsigned int ***)v370 + 2), *((unsigned int ***)v370 + 3), (uint64_t)(*((_QWORD *)v370 + 3) - *((_QWORD *)v370 + 2)) >> 3);
      v167 = (unsigned int *)v420;
      v168 = v421;
      *(_QWORD *)&v440.f64[0] = &v420;
      sub_1D3D6D79C((void ***)&v440);
      if (v167 != v168)
      {
        (*(void (**)(unsigned int **__return_ptr))(**(_QWORD **)(*(_QWORD *)a2 + 16) + 16))(&v360);
        v358 = 0.0;
        v359 = 0;
        v357 = 0.0;
        sub_1D3D6D6A8((unsigned int *)&v357, *((unsigned int ***)v370 + 2), *((unsigned int ***)v370 + 3), (uint64_t)(*((_QWORD *)v370 + 3) - *((_QWORD *)v370 + 2)) >> 3);
        v361 = 0;
        if (*(_QWORD *)&v358 - *(_QWORD *)&v357 != 32)
        {
          v173 = 0;
          goto LABEL_415;
        }
        v169 = v360;
        if (v360)
        {
          v170 = v360 + 2;
          do
            v171 = __ldxr(v170);
          while (__stxr(v171 + 1, v170));
          v440 = 0uLL;
          v441 = 0.0;
          do
            v172 = __ldxr(v170);
          while (__stxr(v172 + 1, v170));
        }
        else
        {
          v440 = 0uLL;
          v441 = 0.0;
        }
        v401 = v169;
        v409 = v169;
        sub_1D3DDE3FC((_QWORD **)&v357, (uint64_t)&v440, 0.5);
        sub_1D3D6D10C(&v409);
        v414 = 0uLL;
        v415 = 0;
        v420 = (float64x2_t *)&v414;
        LOBYTE(v421) = 0;
        v174 = operator new(0x40uLL);
        v415 = (uint64_t)(v174 + 4);
        *v174 = 0u;
        v174[1] = 0u;
        v174[2] = 0u;
        v174[3] = 0u;
        *(_QWORD *)&v414 = v174;
        *((_QWORD *)&v414 + 1) = v174 + 4;
        sub_1D3D8D6EC(&__p, 4uLL);
        for (k = 0; k != 4; ++k)
        {
          v176 = v401;
          if (v401)
          {
            v177 = v401 + 2;
            do
              v178 = __ldxr(v177);
            while (__stxr(v178 + 1, v177));
          }
          v408 = v176;
          v179 = v440.f64[0];
          v180 = k - 3;
          if (k <= 2)
            v180 = k + 1;
          v410 = 0.0;
          v181 = *(unsigned int **)(*(_QWORD *)&v440.f64[0] + 8 * k);
          if (*(double *)&v181 != 0.0)
          {
            v182 = v181 + 2;
            do
              v183 = __ldxr(v182);
            while (__stxr(v183 + 1, v182));
          }
          v410 = *(double *)&v181;
          v411 = 0.0;
          v184 = *(unsigned int **)(*(_QWORD *)&v179 + 8 * v180);
          if (*(double *)&v184 != 0.0)
          {
            v185 = v184 + 2;
            do
              v186 = __ldxr(v185);
            while (__stxr(v186 + 1, v185));
            if (v411 != 0.0)
            {
              sub_1D3D6D13C(*(unsigned int **)&v411);
              v176 = v408;
            }
          }
          v411 = *(double *)&v184;
          v187 = v414;
          v188 = (char *)__p;
          if (v176)
          {
            v189 = v176 + 2;
            do
              v190 = __ldxr(v189);
            while (__stxr(v190 + 1, v189));
          }
          v191 = (unsigned int **)(v187 + 16 * k);
          v413 = (unsigned int ***)v176;
          v192 = &v188[4 * k];
          v193 = sub_1D3DDE8D8((unsigned int **)&v413, (unsigned int **)&v410, 1, v191, v192);
          sub_1D3D6D10C((unsigned int **)&v413);
          if (v193)
          {
            sub_1D3D6D834((unsigned int **)&v411);
            sub_1D3D6D834((unsigned int **)&v410);
            sub_1D3D6D10C(&v408);
          }
          else
          {
            v194 = v408;
            if (v408)
            {
              v195 = v408 + 2;
              do
                v196 = __ldxr(v195);
              while (__stxr(v196 + 1, v195));
            }
            v412 = v194;
            v420 = 0;
            v197 = *(unsigned int **)&v411;
            if (v411 != 0.0)
            {
              v198 = (unsigned int *)(*(_QWORD *)&v411 + 8);
              do
                v199 = __ldxr(v198);
              while (__stxr(v199 + 1, v198));
            }
            v420 = (float64x2_t *)v197;
            v421 = 0;
            v200 = *(unsigned int **)&v410;
            if (v410 != 0.0)
            {
              v201 = (unsigned int *)(*(_QWORD *)&v410 + 8);
              do
                v202 = __ldxr(v201);
              while (__stxr(v202 + 1, v201));
              if (v421)
                sub_1D3D6D13C(v421);
            }
            v421 = v200;
            v203 = sub_1D3DDE8D8(&v412, (unsigned int **)&v420, 0, v191, v192);
            sub_1D3D6D834(&v421);
            sub_1D3D6D834((unsigned int **)&v420);
            sub_1D3D6D10C(&v412);
            sub_1D3D6D834((unsigned int **)&v411);
            sub_1D3D6D834((unsigned int **)&v410);
            sub_1D3D6D10C(&v408);
            if (!v203)
              goto LABEL_329;
          }
        }
        v380 = 0;
        v381 = 0uLL;
        v205 = (uint64_t *)*((_QWORD *)&v414 + 1);
        v204 = (uint64_t *)v414;
        v410 = COERCE_DOUBLE(&v380);
        LOBYTE(v411) = 0;
        v206 = *((_QWORD *)&v414 + 1) - v414;
        if (*((_QWORD *)&v414 + 1) != (_QWORD)v414)
        {
          if (v206 < 0)
            sub_1D3D6D4F8();
          v380 = (unsigned int *)operator new(*((_QWORD *)&v414 + 1) - v414);
          *(_QWORD *)&v381.f64[0] = v380;
          *(_QWORD *)&v381.f64[1] = &v380[4 * (v206 >> 4)];
          v413 = (unsigned int ***)v380;
          v412 = v380;
          v420 = (float64x2_t *)&v381.f64[1];
          v421 = (unsigned int *)&v412;
          v422 = (unsigned int **)&v413;
          v207 = v380;
          v423 = 0;
          do
          {
            *(_QWORD *)v207 = 0;
            v208 = *v204;
            if (*v204)
            {
              v209 = (unsigned int *)(v208 + 8);
              do
                v210 = __ldxr(v209);
              while (__stxr(v210 + 1, v209));
              if (*(_QWORD *)v207)
                sub_1D3D6D13C(*(unsigned int **)v207);
            }
            *(_QWORD *)v207 = v208;
            *((_QWORD *)v207 + 1) = 0;
            v211 = v204[1];
            if (v211)
            {
              v212 = (unsigned int *)(v211 + 8);
              do
                v213 = __ldxr(v212);
              while (__stxr(v213 + 1, v212));
              v214 = (unsigned int *)*((_QWORD *)v207 + 1);
              if (v214)
                sub_1D3D6D13C(v214);
            }
            *((_QWORD *)v207 + 1) = v211;
            v204 += 2;
            v207 = (unsigned int *)(v413 + 2);
            v413 += 2;
          }
          while (v204 != v205);
          v423 = 1;
          sub_1D3DDFD64((uint64_t)&v420);
          *(_QWORD *)&v381.f64[0] = v207;
        }
        v373 = 0uLL;
        v372 = 0;
        sub_1D3D8D760(&v372, __p, *(uint64_t *)&v386.f64[0], (uint64_t)(*(_QWORD *)&v386.f64[0] - (_QWORD)__p) >> 2);
        v215 = 0;
        v216 = v372;
        do
        {
          v217 = v216[v215];
          v218 = v380;
          v410 = 0.0;
          v219 = *(unsigned int **)&v380[4 * v215];
          if (*(double *)&v219 != 0.0)
          {
            v220 = v219 + 2;
            do
              v221 = __ldxr(v220);
            while (__stxr(v221 + 1, v220));
          }
          v410 = *(double *)&v219;
          v413 = 0;
          v222 = *(unsigned int **)&v218[4 * v215 + 2];
          if (v222)
          {
            v223 = v222 + 2;
            do
              v224 = __ldxr(v223);
            while (__stxr(v224 + 1, v223));
          }
          v413 = (unsigned int ***)v222;
          v225 = (*(float (**)(unsigned int *))(*(_QWORD *)v219 + 16))(v219);
          v226 = (*(float (**)(double))(**(_QWORD **)&v410 + 24))(COERCE_DOUBLE(*(_QWORD *)&v410));
          v227 = ((float (*)(unsigned int ***))(*v413)[2])(v413);
          v228 = ((float (*)(unsigned int ***))(*v413)[3])(v413);
          *((float *)&v420 + v215) = (float)v217
                                   / sqrtf((float)((float)(v226 - v228) * (float)(v226 - v228))+ (float)((float)(v225 - v227) * (float)(v225 - v227)));
          sub_1D3D6D834((unsigned int **)&v413);
          sub_1D3D6D834((unsigned int **)&v410);
          ++v215;
        }
        while (v215 != 4);
        v229 = 0;
        v230 = -1;
        v231 = 0.0;
        do
        {
          if (*((float *)&v420 + v229) > v231)
          {
            v230 = v229;
            v231 = *((float *)&v420 + v229);
          }
          ++v229;
        }
        while (v229 != 4);
        if (v230 <= 4)
          v232 = -1;
        else
          v232 = -5;
        if (v230 < 1)
          v232 = 3;
        v233 = v232 + v230;
        if (v230 <= 2)
          v234 = 1;
        else
          v234 = -3;
        if (v230 < -1)
          v234 = 5;
        if (*((float *)&v420 + v232 + v230) > *((float *)&v420 + v234 + v230))
        {
          if (v230 <= 5)
            v235 = -2;
          else
            v235 = -6;
          if (v230 < 2)
            v235 = 2;
          v233 = v235 + v230;
        }
        if (v216)
        {
          *(_QWORD *)&v373.f64[0] = v216;
          operator delete(v216);
        }
        v420 = (float64x2_t *)&v380;
        sub_1D3DDF8B0((void ***)&v420);
        v236 = 0;
        v237 = v233;
        v238 = v233 - 4;
        while (1)
        {
          v239 = v236 + v237;
          v240 = v238 + v236;
          if (v236 + v237 <= 3)
            v240 = v236 + v237;
          if (v239 < 0)
            v240 = v239 + 4;
          v241 = v414;
          v242 = sub_1D3DDF92C((_QWORD *)(v414 + 16 * v240));
          v244 = v243;
          v246 = v245;
          if (v239 <= 2)
            v247 = 1;
          else
            v247 = -3;
          if (v239 < -1)
            v247 = 5;
          v249 = sub_1D3DDF92C((_QWORD *)(v241 + 16 * (v247 + v239)));
          v251 = v250;
          v252 = (float)(v242 * v250) - (float)(v244 * v249);
          if (fabsf(v252) >= 0.00000011921)
          {
            v255 = v248;
            v256 = operator new();
            v253 = v256;
            *(_DWORD *)(v256 + 8) = 0;
            v257 = (unsigned int *)(v256 + 8);
            *(_QWORD *)v256 = &off_1E95AF250;
            *(float *)(v256 + 12) = (float)((float)(v244 * v255) - (float)(v246 * v251)) / v252;
            *(float *)(v256 + 16) = (float)((float)(v246 * v249) - (float)(v242 * v255)) / v252;
            do
              v258 = __ldxr(v257);
            while (__stxr(v258 + 1, v257));
            v420 = (float64x2_t *)v256;
            v254 = v440.f64[0];
            do
              v259 = __ldxr(v257);
            while (__stxr(v259 + 1, v257));
          }
          else
          {
            v253 = 0;
            v420 = 0;
            v254 = v440.f64[0];
          }
          v260 = *(unsigned int **)(*(_QWORD *)&v254 + 8 * v236);
          if (v260)
            sub_1D3D6D13C(v260);
          *(_QWORD *)(*(_QWORD *)&v254 + 8 * v236) = v253;
          sub_1D3D6D834((unsigned int **)&v420);
          v261 = v401;
          if (v401)
          {
            v262 = v401 + 2;
            do
              v263 = __ldxr(v262);
            while (__stxr(v263 + 1, v262));
          }
          v407 = v261;
          v406 = 0;
          v264 = *(unsigned int **)(*(_QWORD *)&v440.f64[0] + 8 * v236);
          if (v264)
          {
            v265 = v264 + 2;
            do
              v266 = __ldxr(v265);
            while (__stxr(v266 + 1, v265));
          }
          v406 = v264;
          v267 = sub_1D3DDF9B8(v261, &v406);
          sub_1D3D6D834(&v406);
          sub_1D3D6D10C(&v407);
          if (!v267)
            break;
          if (++v236 == 4)
          {
            v377 = v440;
            v378 = v441;
            v268 = &v440;
            goto LABEL_330;
          }
        }
LABEL_329:
        v268 = &v377;
LABEL_330:
        v268->f64[0] = 0.0;
        v268->f64[1] = 0.0;
        v268[1].f64[0] = 0.0;
        if (__p)
        {
          *(_QWORD *)&v386.f64[0] = __p;
          operator delete(__p);
        }
        v420 = (float64x2_t *)&v414;
        sub_1D3DDF8B0((void ***)&v420);
        v420 = &v440;
        sub_1D3D6D79C((void ***)&v420);
        sub_1D3D6D10C(&v401);
        if (*(_QWORD *)&v377.f64[0] == *(_QWORD *)&v377.f64[1])
        {
LABEL_412:
          v420 = &v377;
          sub_1D3D6D79C((void ***)&v420);
          v173 = v361;
          if (v361)
          {
            v339 = v361 + 2;
            do
              v340 = __ldxr(v339);
            while (__stxr(v340 + 1, v339));
          }
LABEL_415:
          if (v371)
            sub_1D3D6D13C(v371);
          v371 = v173;
          sub_1D3D7F7E4(&v361);
          v420 = (float64x2_t *)&v357;
          sub_1D3D6D79C((void ***)&v420);
          sub_1D3D6D10C(&v360);
          v341 = v371;
          if (v371)
          {
            v342 = v371 + 2;
            do
              v343 = __ldxr(v342);
            while (__stxr(v343 + 1, v342));
            *a1 = v341;
            goto LABEL_206;
          }
          goto LABEL_209;
        }
        v269 = v360;
        if (v360)
        {
          v270 = v360 + 2;
          do
            v271 = __ldxr(v270);
          while (__stxr(v271 + 1, v270));
          v421 = 0;
          v420 = 0;
          v422 = 0;
          do
            v272 = __ldxr(v270);
          while (__stxr(v272 + 1, v270));
        }
        else
        {
          v421 = 0;
          v420 = 0;
          v422 = 0;
        }
        v399 = v269;
        v380 = 0;
        v372 = v269;
        sub_1D3DDE3FC(&v377, (uint64_t)&v420, 1.0);
        sub_1D3D6D10C(&v372);
        v273 = v399;
        if (*(double *)&v399 != 0.0)
        {
          v274 = v399 + 2;
          do
            v275 = __ldxr(v274);
          while (__stxr(v275 + 1, v274));
        }
        v410 = *(double *)&v273;
        v276 = (unsigned int *)v420;
        v413 = 0;
        v277 = *(unsigned int **)&v420->f64[0];
        if (*(_QWORD *)&v420->f64[0])
        {
          v278 = v277 + 2;
          do
            v279 = __ldxr(v278);
          while (__stxr(v279 + 1, v278));
        }
        v413 = (unsigned int ***)v277;
        v280 = (unsigned int *)*((_QWORD *)v276 + 3);
        if (v280)
        {
          v281 = v280 + 2;
          do
            v282 = __ldxr(v281);
          while (__stxr(v282 + 1, v281));
        }
        v412 = v280;
        v283 = sub_1D3DDFA6C((unsigned int **)&v410, (unsigned int **)&v413, &v412);
        sub_1D3D6D834(&v412);
        sub_1D3D6D834((unsigned int **)&v413);
        sub_1D3D6D10C((unsigned int **)&v410);
        v284 = v399;
        if (*(double *)&v399 != 0.0)
        {
          v285 = v399 + 2;
          do
            v286 = __ldxr(v285);
          while (__stxr(v286 + 1, v285));
        }
        v409 = v284;
        v287 = (unsigned int *)v420;
        v288 = *(unsigned int **)&v420[1].f64[0];
        if (v288)
        {
          v289 = v288 + 2;
          do
            v290 = __ldxr(v289);
          while (__stxr(v290 + 1, v289));
        }
        v408 = v288;
        v291 = (unsigned int *)*((_QWORD *)v287 + 3);
        if (v291)
        {
          v292 = v291 + 2;
          do
            v293 = __ldxr(v292);
          while (__stxr(v293 + 1, v292));
        }
        v407 = v291;
        v294 = sub_1D3DDFA6C(&v409, &v408, &v407);
        sub_1D3D6D834(&v407);
        sub_1D3D6D834(&v408);
        sub_1D3D6D10C(&v409);
        if (v283 < 0 || v294 < 0)
        {
          v328 = v380;
          if (v380)
          {
            v329 = v380 + 2;
            do
              v330 = __ldxr(v329);
            while (__stxr(v330 + 1, v329));
          }
        }
        else
        {
          if (((v283 + 1) & 1) != 0)
            v295 = v283 + 2;
          else
            v295 = v283 + 1;
          if ((((_BYTE)v294 + 1) & 1) != 0)
            v296 = v294 + 2;
          else
            v296 = v294 + 1;
          if ((v295 - 145) >= 0xFFFFFF79 && v296 >= 8 && v296 < 0x91)
          {
            v297 = (*(float (**)(_QWORD))(***(_QWORD ***)&v377.f64[0] + 16))(**(_QWORD **)&v377.f64[0]);
            v298 = (*(float (**)(_QWORD))(***(_QWORD ***)&v377.f64[0] + 24))(**(_QWORD **)&v377.f64[0]);
            v299 = (*(float (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)&v377.f64[0] + 24) + 16))(*(_QWORD *)(*(_QWORD *)&v377.f64[0] + 24));
            v300 = (*(float (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)&v377.f64[0] + 24) + 24))(*(_QWORD *)(*(_QWORD *)&v377.f64[0] + 24));
            v301 = (*(float (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)&v377.f64[0] + 16) + 16))(*(_QWORD *)(*(_QWORD *)&v377.f64[0] + 16));
            v302 = (*(float (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)&v377.f64[0] + 16) + 24))(*(_QWORD *)(*(_QWORD *)&v377.f64[0] + 16));
            v303 = (*(float (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)&v377.f64[0] + 8) + 16))(*(_QWORD *)(*(_QWORD *)&v377.f64[0] + 8));
            v304 = (*(float (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)&v377.f64[0] + 8) + 24))(*(_QWORD *)(*(_QWORD *)&v377.f64[0] + 8));
            sub_1D3DB93EC((uint64_t *)&v440, 0.0, 0.0, (float)v295, 0.0, (float)v295, (float)v296, 0.0, (float)v296, v297, v298, v299, v300, v301, v302, v303, v304);
            v406 = 0;
            v305 = v399;
            v306 = (*(float (**)(_QWORD))(**(_QWORD **)&v420->f64[0] + 16))(*(_QWORD *)&v420->f64[0]);
            v307 = (*(float (**)(_QWORD))(**(_QWORD **)&v420->f64[0] + 24))(*(_QWORD *)&v420->f64[0]);
            v308 = sub_1D3D6D4A0(v305, (int)v306, (int)v307);
            v309 = v399;
            if (*(double *)&v399 != 0.0)
            {
              v310 = v399 + 2;
              do
                v311 = __ldxr(v310);
              while (__stxr(v311 + 1, v310));
            }
            v404 = v309;
            v312 = v440.f64[0];
            if (*(_QWORD *)&v440.f64[0])
            {
              v313 = (unsigned int *)(*(_QWORD *)&v440.f64[0] + 8);
              do
                v314 = __ldxr(v313);
              while (__stxr(v314 + 1, v313));
            }
            v403 = *(unsigned int **)&v312;
            sub_1D3DB5FF8();
            v315 = v308 ^ 1;
            v316 = v404;
            if (v404)
            {
              v317 = v404 + 2;
              do
                v318 = __ldxr(v317);
              while (__stxr(v318 + 1, v317));
            }
            *(_QWORD *)&v414 = v316;
            v319 = v403;
            if (v403)
            {
              v320 = v403 + 2;
              do
                v321 = __ldxr(v320);
              while (__stxr(v321 + 1, v320));
            }
            __p = v319;
            sub_1D3DB5BDC((uint64_t *)&v405, (unsigned int **)&v414, v295, v296, &__p, v315);
            sub_1D3DB45E8((unsigned int **)&__p);
            sub_1D3D6D10C((unsigned int **)&v414);
            v322 = v405;
            if (v405)
            {
              v323 = v405 + 2;
              do
                v324 = __ldxr(v323);
              while (__stxr(v324 + 1, v323));
            }
            if (v406)
              sub_1D3D6D13C(v406);
            v406 = v322;
            sub_1D3D6D10C(&v405);
            sub_1D3D6F2E0(&v403);
            sub_1D3D6D10C(&v404);
            v325 = v406;
            if (v406)
            {
              v326 = v406 + 2;
              do
                v327 = __ldxr(v326);
              while (__stxr(v327 + 1, v326));
            }
            v402 = v325;
            sub_1D3DC7D80((unsigned int **)&v400, &v402);
            sub_1D3D6D10C(&v402);
            if (v400)
              *((_DWORD *)sub_1D3D7F308(v400 + 12, 9, (unsigned int *)&unk_1D3E80D00) + 8) = v315;
            sub_1D3D6D10C(&v406);
            sub_1D3D6F2E0((unsigned int **)&v440);
            goto LABEL_400;
          }
          v328 = v380;
          if (v380)
          {
            v331 = v380 + 2;
            do
              v332 = __ldxr(v331);
            while (__stxr(v332 + 1, v331));
          }
        }
        v400 = (uint64_t **)v328;
LABEL_400:
        *(_QWORD *)&v440.f64[0] = &v420;
        sub_1D3D6D79C((void ***)&v440);
        sub_1D3D7F814(&v380);
        sub_1D3D6D10C(&v399);
        if (v400)
        {
          v333 = (unsigned int *)operator new();
          v398 = 0;
          v396 = 0;
          v395 = (unsigned int **)&off_1E95AF9B0;
          v397 = 0;
          v334 = (unsigned int *)v400[4];
          if (v334)
          {
            v335 = v334 + 2;
            do
              v336 = __ldxr(v335);
            while (__stxr(v336 + 1, v335));
            if (v397)
              sub_1D3D6D13C(v397);
          }
          v397 = v334;
          v394 = 0;
          v392 = 0;
          v393 = 0;
          sub_1D3D6D6A8((unsigned int *)&v392, *(unsigned int ***)&v377.f64[0], *(unsigned int ***)&v377.f64[1], (uint64_t)(*(_QWORD *)&v377.f64[1] - *(_QWORD *)&v377.f64[0]) >> 3);
          sub_1D3D7F3AC((uint64_t)&v390, v400 + 12);
          sub_1D3E17B10((uint64_t)v333, (uint64_t *)&v398, (uint64_t)&v395, (unsigned int ***)&v392, 2, &v390);
          v337 = v333 + 2;
          do
            v338 = __ldxr(v337);
          while (__stxr(v338 + 1, v337));
          if (v361)
            sub_1D3D6D13C(v361);
          v361 = v333;
          sub_1D3D7F520(*(_QWORD **)&v391);
          v420 = (float64x2_t *)&v392;
          sub_1D3D6D79C((void ***)&v420);
          sub_1D3D7F558(&v395);
          sub_1D3D7F598(&v398);
        }
        sub_1D3D7F814((unsigned int **)&v400);
        goto LABEL_412;
      }
    }
  }
LABEL_209:
  v363 = COERCE_DOUBLE(&off_1E95AF1B0);
  sub_1D3D6D10C(&v365);
  *a1 = 0;
  v163 = v371;
  if (v371)
  {
    v164 = v371 + 2;
    do
      v165 = __ldxr(v164);
    while (__stxr(v165 + 1, v164));
  }
  *a1 = v163;
LABEL_213:
  sub_1D3D7F814(&v369);
  sub_1D3DC6848(&v370);
  return sub_1D3D7F7E4(&v371);
}

void sub_1D3DC630C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,unsigned int *a44,unsigned int *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,unsigned int *a55,unsigned int *a56,unsigned int *a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a65;
  uint64_t a69;
  unsigned int **v69;
  uint64_t v70;

  sub_1D3D7F814((unsigned int **)&STACK[0x2C0]);
  sub_1D3D6D10C((unsigned int **)&STACK[0x2F0]);
  sub_1D3D6F2E0((unsigned int **)(v70 - 240));
  *(_QWORD *)(v70 - 240) = &STACK[0x370];
  sub_1D3D6D79C((void ***)(v70 - 240));
  sub_1D3D7F814((unsigned int **)&a69);
  sub_1D3D6D10C((unsigned int **)&STACK[0x2B8]);
  STACK[0x370] = (unint64_t)&a65;
  sub_1D3D6D79C((void ***)&STACK[0x370]);
  sub_1D3D7F7E4(&a45);
  STACK[0x370] = (unint64_t)&a41;
  sub_1D3D6D79C((void ***)&STACK[0x370]);
  sub_1D3D6D10C(&a44);
  sub_1D3D6D10C(v69);
  sub_1D3D7F814(&a55);
  sub_1D3DC6848(&a56);
  sub_1D3D7F7E4(&a57);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC6848(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

unsigned int **sub_1D3DC6878(_QWORD *a1, uint64_t **a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int **v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int **result;
  uint64_t *v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  _QWORD v19[3];
  unsigned int **v20[3];
  uint64_t (**v21)(_QWORD);
  int v22;
  uint64_t v23;
  unsigned int *v24;
  unsigned int ***v25;

  v4 = *(unsigned __int8 *)(*a2[1] + 12);
  *((_DWORD *)sub_1D3D7F308((uint64_t **)(**a2 + 96), 9, (unsigned int *)&unk_1D3E80D00) + 8) = v4;
  v5 = operator new();
  v24 = 0;
  v6 = **a2;
  v22 = 0;
  v21 = &off_1E95AF9B0;
  v23 = 0;
  v7 = *(_QWORD *)(v6 + 32);
  if (v7)
  {
    v8 = (unsigned int *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v23 = v7;
  v10 = *a2[1];
  memset(v20, 0, sizeof(v20));
  sub_1D3D6D6A8((unsigned int *)v20, *(unsigned int ***)(v10 + 16), *(unsigned int ***)(v10 + 24), (uint64_t)(*(_QWORD *)(v10 + 24) - *(_QWORD *)(v10 + 16)) >> 3);
  sub_1D3D7F3AC((uint64_t)v19, (_QWORD *)(**a2 + 96));
  sub_1D3E17B10(v5, (uint64_t *)&v24, (uint64_t)&v21, v20, 2, v19);
  v11 = (unsigned int **)a2[2];
  v12 = (unsigned int *)(v5 + 8);
  do
    v13 = __ldxr(v12);
  while (__stxr(v13 + 1, v12));
  if (*v11)
    sub_1D3D6D13C(*v11);
  *v11 = (unsigned int *)v5;
  sub_1D3D7F520((_QWORD *)v19[1]);
  v25 = v20;
  sub_1D3D6D79C((void ***)&v25);
  sub_1D3D7F558(&v21);
  result = sub_1D3D7F598(&v24);
  v15 = a2[2];
  *a1 = 0;
  v16 = *v15;
  if (v16)
  {
    v17 = (unsigned int *)(v16 + 8);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  *a1 = v16;
  return result;
}

void sub_1D3DC6A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  *(_QWORD *)(v6 - 56) = va;
  sub_1D3D6D79C((void ***)(v6 - 56));
  sub_1D3D7F558((uint64_t *)va1);
  sub_1D3D7F598((unsigned int **)(v6 - 64));
  MEMORY[0x1D8254C54](v5, 0x10A1C4006AAC113);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DC6A70(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF1B0;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  return a1;
}

void sub_1D3DC6AA0(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF1B0;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DC6AE0(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF210;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  return a1;
}

void sub_1D3DC6B10(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E95AF210;
  sub_1D3D6D10C((unsigned int **)(a1 + 16));
  JUMPOUT(0x1D8254C54);
}

void sub_1D3DC6B50(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89E30 != -1)
    dispatch_once(&qword_1EDB89E30, &unk_1E95B32A8);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89E38;
    if (os_signpost_enabled((os_log_t)qword_1EDB89E38))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "Decoder::postProcessForComposite_", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

unint64_t *sub_1D3DC6BF0(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t *v3;
  const void *v6;
  const void *v7;
  BOOL v8;

  v3 = a1;
  if (a1 != a2)
  {
    while (1)
    {
      v6 = (const void *)atomic_load(a3);
      v7 = (const void *)atomic_load(v3);
      if (v7 == v6)
        break;
      v8 = !v6 || v7 == 0;
      if (!v8 && CFEqual(v7, v6))
        break;
      if (++v3 == a2)
        return a2;
    }
  }
  return v3;
}

_QWORD *sub_1D3DC6C5C(_QWORD *a1, const void *a2, unint64_t a3)
{
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    sub_1D3D8223C(a1, a3);
    v6 = (char *)a1[1];
    memmove(v6, a2, 4 * a3);
    a1[1] = &v6[4 * a3];
  }
  return a1;
}

void sub_1D3DC6CC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1D3DC6CDC(char *result, char *__src, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  void **v10;
  char *v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  size_t v15;
  void *v16;
  char *v17;

  v5 = result;
  v6 = *((_QWORD *)result + 2);
  v7 = *(char **)result;
  if ((unint64_t)(v6 - *(_QWORD *)result) < 0x20)
  {
    if (v7)
    {
      *((_QWORD *)result + 1) = v7;
      operator delete(v7);
      v6 = 0;
      *v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
    }
    v8 = v6 >> 1;
    if ((unint64_t)(v6 >> 1) <= 8)
      v8 = 8;
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL)
      v9 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    result = sub_1D3D8223C(v5, v9);
    v11 = (char *)v5[1];
    v10 = (void **)(v5 + 1);
    v7 = v11;
LABEL_15:
    v15 = a3 - (_QWORD)__src;
    if (v15)
    {
      v16 = v7;
      v17 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v10 = (void **)(result + 8);
  v12 = (_BYTE *)*((_QWORD *)result + 1);
  v13 = v12 - v7;
  if ((unint64_t)(v12 - v7) > 0x1F)
    goto LABEL_15;
  v14 = &__src[v13];
  if (v12 != v7)
  {
    result = (char *)memmove(*(void **)result, __src, v13);
    v7 = (char *)*v10;
  }
  v15 = a3 - (_QWORD)v14;
  if (v15)
  {
    v16 = v7;
    v17 = v14;
LABEL_17:
    result = (char *)memmove(v16, v17, v15);
  }
LABEL_18:
  *v10 = &v7[v15];
  return result;
}

void sub_1D3DC6DD0(uint64_t a1, _DWORD *a2)
{
  unint64_t v4;
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  unint64_t v15;
  int v16;

  v5 = *(_DWORD **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    v7 = *(_DWORD **)a1;
    v8 = ((uint64_t)v5 - *(_QWORD *)a1) >> 2;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62)
      sub_1D3D6D4F8();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 1 > v9)
      v9 = v10 >> 1;
    v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL;
    v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11)
      v12 = v9;
    if (v12)
    {
      v12 = (unint64_t)sub_1D3D82278(v12);
      v7 = *(_DWORD **)a1;
      v5 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = (_DWORD *)(v12 + 4 * v8);
    v15 = v12 + 4 * v13;
    *v14 = *a2;
    v6 = v14 + 1;
    while (v5 != v7)
    {
      v16 = *--v5;
      *--v14 = v16;
    }
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = v15;
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }
  *(_QWORD *)(a1 + 8) = v6;
}

unint64_t *sub_1D3DC6EA8()
{
  _QWORD *v0;
  char *v1;
  uint64_t i;
  _QWORD *v3;
  char *v4;
  uint64_t j;
  _QWORD *v6;
  char *v7;
  uint64_t k;
  _QWORD *v9;
  char *v10;
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v14;
  CFTypeRef v15;
  CFTypeRef v16;
  CFTypeRef v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v0 = (_QWORD *)operator new();
  v16 = CFRetain(CFSTR("UPCE"));
  v17 = CFRetain(CFSTR("GS1DataBar"));
  v0[1] = 0;
  v0[2] = 0;
  *v0 = 0;
  v12 = v0;
  LOBYTE(v13) = 0;
  v1 = (char *)operator new(0x10uLL);
  *v0 = v1;
  v0[1] = v1;
  v0[2] = v1 + 16;
  v0[1] = sub_1D3DC72A8((uint64_t)&v16, (uint64_t)&v18, (uint64_t)v1);
  qword_1EFE31790 = (uint64_t)v0;
  for (i = 8; i != -8; i -= 8)
    sub_1D3D8C70C((unint64_t *)((char *)&v16 + i));
  v3 = (_QWORD *)operator new();
  v16 = CFRetain(CFSTR("EAN8"));
  v17 = CFRetain(CFSTR("GS1DataBarLimited"));
  v3[1] = 0;
  v3[2] = 0;
  *v3 = 0;
  v12 = v3;
  LOBYTE(v13) = 0;
  v4 = (char *)operator new(0x10uLL);
  *v3 = v4;
  v3[1] = v4;
  v3[2] = v4 + 16;
  v3[1] = sub_1D3DC72A8((uint64_t)&v16, (uint64_t)&v18, (uint64_t)v4);
  qword_1EFE31798 = (uint64_t)v3;
  for (j = 8; j != -8; j -= 8)
    sub_1D3D8C70C((unint64_t *)((char *)&v16 + j));
  v6 = (_QWORD *)operator new();
  v12 = CFRetain(CFSTR("EAN13"));
  v13 = CFRetain(CFSTR("Code128"));
  v14 = CFRetain(CFSTR("GS1DataBar"));
  v15 = CFRetain(CFSTR("GS1DataBarExpanded"));
  v16 = v6;
  v6[1] = 0;
  v6[2] = 0;
  *v6 = 0;
  LOBYTE(v17) = 0;
  v7 = (char *)operator new(0x20uLL);
  *v6 = v7;
  v6[1] = v7;
  v6[2] = v7 + 32;
  v6[1] = sub_1D3DC72A8((uint64_t)&v12, (uint64_t)&v16, (uint64_t)v7);
  qword_1EFE317A0 = (uint64_t)v6;
  for (k = 24; k != -8; k -= 8)
    sub_1D3D8C70C((unint64_t *)((char *)&v12 + k));
  v9 = (_QWORD *)operator new();
  v16 = CFRetain(CFSTR("Code128"));
  v9[1] = 0;
  v9[2] = 0;
  *v9 = 0;
  v12 = v9;
  LOBYTE(v13) = 0;
  v10 = (char *)operator new(8uLL);
  *v9 = v10;
  v9[1] = v10;
  v9[2] = v10 + 8;
  v9[1] = sub_1D3DC72A8((uint64_t)&v16, (uint64_t)&v17, (uint64_t)v10);
  qword_1EFE317A8 = (uint64_t)v9;
  return sub_1D3D8C70C((unint64_t *)&v16);
}

void sub_1D3DC717C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  void **v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, void **);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  *(_QWORD *)(v2 + 8) = v3;
  sub_1D3DC7340((void ***)va);
  sub_1D3D8C70C((unint64_t *)va1);
  MEMORY[0x1D8254C54](v2, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DC72A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  CFTypeRef v7;

  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      v7 = (CFTypeRef)atomic_load((unint64_t *)(a1 + v6));
      if (v7)
        v7 = CFRetain(v7);
      *(_QWORD *)(a3 + v6) = v7;
      v6 += 8;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_1D3DC7340(void ***a1)
{
  void **v1;
  unint64_t *v2;
  unint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (unint64_t *)**a1;
  if (v2)
  {
    v4 = (unint64_t *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3D8C70C(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1D3DC73B4()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DC73C8()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B00F0;
  return result;
}

void sub_1D3DC73EC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B00F0;
}

void sub_1D3DC7404(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (qword_1EDB89E30 != -1)
    dispatch_once(&qword_1EDB89E30, &unk_1E95B32A8);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EDB89E38;
    if (os_signpost_enabled((os_log_t)qword_1EDB89E38))
    {
      *(_WORD *)v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1D3D6B000, v3, OS_SIGNPOST_INTERVAL_END, v2, "Decoder::postProcessForComposite_", (const char *)&unk_1D3E89A2B, v4, 2u);
    }
  }
}

uint64_t sub_1D3DC74A4(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder24postProcessForComposite_ERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DC74DC()
{
  return &unk_1E95AEBE0;
}

void sub_1D3DC74EC()
{
  JUMPOUT(0x1D8254C54);
}

_QWORD *sub_1D3DC7500()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E95B0098;
  return result;
}

void sub_1D3DC7524(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E95B0098;
}

uint64_t sub_1D3DC753C(uint64_t a1, uint64_t a2)
{
  if (sub_1D3D7521C(*(_QWORD *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder24postProcessForComposite_ERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1D3DC7574()
{
  return &unk_1E95AEBD0;
}

void sub_1D3DC7580(unsigned int **a1, unsigned int *a2, _DWORD *a3)
{
  unsigned int *v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  _QWORD *exception;
  _QWORD *v20;
  uint64_t (**v21)();
  uint64_t (*v22)();

  if (a2)
  {
    v4 = a2 + 2;
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *a1 = a2;
    return;
  }
  v6 = a3[14];
  v7 = -v6;
  v8 = a3[4];
  v9 = v8 & -v6--;
  v10 = a3[8];
  v11 = v10 & v6 | v9;
  v12 = v8 & v6 | v10 & v7;
  if (((v12 | v11) & 1) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3E17508(exception, "Number of rows and columns must be even");
LABEL_19:
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
  }
  v13 = atomic_load(&qword_1EFE317E0);
  if (v13 != -1)
  {
    v21 = &v22;
    v22 = sub_1D3DD6C40;
    std::__call_once(&qword_1EFE317E0, &v21, (void (__cdecl *)(void *))sub_1D3DD8A78);
  }
  v14 = *(_QWORD *)qword_1EFE317D8;
  if (*(_QWORD *)(qword_1EFE317D8 + 8) == *(_QWORD *)qword_1EFE317D8)
  {
LABEL_18:
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3E17508(exception, "Error version not found");
    goto LABEL_19;
  }
  v15 = 0;
  while (1)
  {
    *a1 = 0;
    v16 = *(unsigned int **)(v14 + 8 * v15);
    if (v16)
    {
      v17 = v16 + 2;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      if (*a1)
        sub_1D3D6D13C(*a1);
    }
    *a1 = v16;
    if (v16[4] == v11 && v16[5] == v12)
      break;
    sub_1D3DC778C(a1);
    ++v15;
    v14 = *(_QWORD *)qword_1EFE317D8;
    if (v15 >= (uint64_t)(*(_QWORD *)(qword_1EFE317D8 + 8) - *(_QWORD *)qword_1EFE317D8) >> 3)
      goto LABEL_18;
  }
  if (!v16)
  {
    v20 = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(v20, "Couldn't decode version");
    *v20 = &off_1E95AF388;
    __cxa_throw(v20, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
  }
}

void sub_1D3DC7754(_Unwind_Exception *a1)
{
  unsigned int **v1;

  sub_1D3DC778C(v1);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC778C(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

uint64_t sub_1D3DC77BC(uint64_t a1)
{
  unsigned int **v2;

  *(_QWORD *)a1 = &off_1E95AF1D0;
  v2 = (unsigned int **)(a1 + 16);
  sub_1D3D6D10C((unsigned int **)(a1 + 32));
  sub_1D3DC778C((unsigned int **)(a1 + 24));
  sub_1D3D6D10C(v2);
  return a1;
}

void sub_1D3DC7804(uint64_t a1)
{
  unsigned int **v2;

  *(_QWORD *)a1 = &off_1E95AF1D0;
  v2 = (unsigned int **)(a1 + 16);
  sub_1D3D6D10C((unsigned int **)(a1 + 32));
  sub_1D3DC778C((unsigned int **)(a1 + 24));
  sub_1D3D6D10C(v2);
  JUMPOUT(0x1D8254C54);
}

uint64_t sub_1D3DC785C(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;

  v10 = a2 - 2;
  v11 = a3 - 2;
  if (sub_1D3DC79AC(a1, a2 - 2, a3 - 2, a4, a5))
    v12 = 2;
  else
    v12 = 0;
  v13 = v12 | sub_1D3DC79AC(a1, v10, a3 - 1, a4, a5);
  if (sub_1D3DC79AC(a1, a2 - 1, v11, a4, a5))
    v14 = 2;
  else
    v14 = 0;
  v15 = v14 | (4 * v13) | sub_1D3DC79AC(a1, a2 - 1, a3 - 1, a4, a5);
  if (sub_1D3DC79AC(a1, a2 - 1, a3, a4, a5))
    v16 = 2;
  else
    v16 = 0;
  v17 = v16 | (4 * v15) | sub_1D3DC79AC(a1, a2, v11, a4, a5);
  if (sub_1D3DC79AC(a1, a2, a3 - 1, a4, a5))
    v18 = 2;
  else
    v18 = 0;
  return v18 | (4 * v17) | sub_1D3DC79AC(a1, a2, a3, a4, a5);
}

uint64_t sub_1D3DC79AC(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v5 = a4 + a2;
  v6 = a3 - (((_BYTE)a4 + 4) & 7) + 4;
  if (a2 >= 0)
  {
    v6 = a3;
    v5 = a2;
  }
  if (v6 < 0)
  {
    v6 += a5;
    v5 = v5 - (((_BYTE)a5 + 4) & 7) + 4;
  }
  v7 = *(_QWORD *)(a1 + 32);
  v8 = v5;
  v9 = *(_QWORD *)(v7 + 24) * v5 + v6;
  *(_DWORD *)(*(_QWORD *)(v7 + 48) + ((v9 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v9;
  return sub_1D3D6D4A0(*(_QWORD **)(a1 + 16), v6, v8);
}

_QWORD *sub_1D3DC7A2C(_QWORD *a1)
{
  *a1 = &off_1E95AF230;
  sub_1D3D7F558(a1 + 2);
  return a1;
}

void sub_1D3DC7A5C(_QWORD *a1)
{
  *a1 = &off_1E95AF230;
  sub_1D3D7F558(a1 + 2);
  JUMPOUT(0x1D8254C54);
}

unsigned int **sub_1D3DC7A9C(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

void sub_1D3DC7ACC(void ***a1)
{
  void **v1;
  unsigned int **v2;
  unsigned int **v4;
  void *v5;

  v1 = *a1;
  v2 = (unsigned int **)**a1;
  if (v2)
  {
    v4 = (unsigned int **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1D3DC7A9C(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1D3DC7B40(uint64_t a1, __int128 *a2)
{
  std::string *v4;
  __int128 v5;
  char v6;
  std::string *v7;
  unint64_t v8;
  int v9;
  std::string::size_type v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v4 = (std::string *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0)
    operator delete(v4->__r_.__value_.__l.__data_);
  v5 = *a2;
  v4->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
  *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  *((_BYTE *)a2 + 23) = 0;
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a1 + 88) = 0;
  v6 = *(_BYTE *)(a1 + 87);
  if (v6 < 0)
  {
    v7 = *(std::string **)(a1 + 64);
    v8 = *(_QWORD *)(a1 + 72);
  }
  else
  {
    v7 = v4;
    v8 = *(unsigned __int8 *)(a1 + 87);
  }
  v9 = *(_DWORD *)(a1 + 96);
  if ((v9 & 8) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v7 + v8;
    *(_QWORD *)(a1 + 16) = v7;
    *(_QWORD *)(a1 + 24) = v7;
    *(_QWORD *)(a1 + 32) = (char *)v7 + v8;
  }
  if ((v9 & 0x10) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v7 + v8;
    v10 = v6 < 0 ? (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v4, v10, 0);
    v11 = *(char *)(a1 + 87) < 0 ? *(_QWORD *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(_QWORD *)(a1 + 40) = v7;
    *(_QWORD *)(a1 + 48) = v7;
    *(_QWORD *)(a1 + 56) = (char *)v7 + v11;
    if ((*(_BYTE *)(a1 + 96) & 3) != 0)
    {
      if (v8 >> 31)
      {
        v12 = ((v8 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v13 = 0x7FFFFFFF * ((v12 + ((v8 - 0x80000000 - v12) >> 1)) >> 30);
        v7 = (std::string *)((char *)v7 + v13 + 0x7FFFFFFF);
        v8 = v8 - v13 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 48) = v7;
      }
      if (v8)
        *(_QWORD *)(a1 + 48) = (char *)v7 + v8;
    }
  }
}

unsigned int **sub_1D3DC7C80()
{
  unsigned int **v0;
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v7;
  unsigned int *v8;

  v0 = (unsigned int **)operator new();
  sub_1D3DBAE60();
  v1 = *(unsigned int **)qword_1EDB89F08;
  if (*(_QWORD *)qword_1EDB89F08)
  {
    v2 = v1 + 2;
    do
      v3 = __ldxr(v2);
    while (__stxr(v3 + 1, v2));
    v7 = v1;
    do
      v4 = __ldxr(v2);
    while (__stxr(v4 + 1, v2));
    v8 = v1;
    *v0 = 0;
    do
      v5 = __ldxr(v2);
    while (__stxr(v5 + 1, v2));
    if (*v0)
      sub_1D3D6D13C(*v0);
  }
  else
  {
    v7 = 0;
    v8 = 0;
    *v0 = 0;
  }
  *v0 = v1;
  qword_1EFE317B8 = (uint64_t)v0;
  sub_1D3D82034(&v8);
  return sub_1D3D81F38(&v7);
}

void sub_1D3DC7D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, unsigned int *a10)
{
  uint64_t v10;

  sub_1D3D82034(&a10);
  sub_1D3D81F38(&a9);
  MEMORY[0x1D8254C54](v10, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC7D80(unsigned int **a1, unsigned int **a2)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int **result;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int *v19;

  *a1 = 0;
  v4 = *a2;
  if (*a2)
  {
    v5 = v4 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v18 = v4;
  sub_1D3DC9888((uint64_t *)&v19, &v18);
  v7 = v19;
  if (v19)
  {
    v8 = v19 + 2;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    *a1 = v7;
    sub_1D3D7F814(&v19);
    return sub_1D3D6D10C(&v18);
  }
  else
  {
    *a1 = 0;
    sub_1D3D7F814(&v19);
    sub_1D3D6D10C(&v18);
    v11 = *a2;
    *((_QWORD *)v11 + 7) = 1;
    v12 = v11 + 2;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    v17 = v11;
    sub_1D3DC9888((uint64_t *)&v19, &v17);
    v14 = v19;
    if (v19)
    {
      v15 = v19 + 2;
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    if (*a1)
      sub_1D3D6D13C(*a1);
    *a1 = v14;
    sub_1D3D7F814(&v19);
    result = sub_1D3D6D10C(&v17);
    *((_QWORD *)v11 + 7) = 0;
  }
  return result;
}

void sub_1D3DC7E98(void *a1, uint64_t a2, ...)
{
  uint64_t v2;
  unsigned int *v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, unsigned int *);
  v6 = va_arg(va1, _QWORD);
  sub_1D3D7F814((unsigned int **)va1);
  sub_1D3D6D10C((unsigned int **)va);
  *(_QWORD *)(v2 + 56) = 0;
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D3DC7E84);
}

void sub_1D3DC7EC8(void *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_1D3D6D10C((unsigned int **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D3DC7E14);
}

void sub_1D3DC7EE4(_Unwind_Exception *a1)
{
  unsigned int **v1;

  sub_1D3D7F814(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1D3DC7EF8(uint64_t *a1, uint64_t a2, char *a3)
{
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  int v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  int v18;
  char v19;
  uint64_t v20;
  int v21;
  uint64_t *v22;
  std::string::size_type size;
  const std::string::value_type *v24;
  std::string::size_type v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  int v41;
  unsigned int *v42;
  unsigned int *v43;
  unsigned int v44;
  char v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  int v66;
  int v67;
  int v68;
  unsigned int *v69;
  unsigned int *v70;
  unsigned int v71;
  char v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  uint64_t v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  char v85;
  unsigned int *v86;
  unsigned int *v87;
  unsigned int v88;
  unsigned int v89;
  char v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  char *v99;
  uint64_t v100;
  char v101;
  uint64_t v102;
  size_t v103;
  char *v104;
  char *v105;
  char *v106;
  char *v107;
  char v108;
  void *v109;
  void **v110;
  std::string::size_type v111;
  uint64_t v112;
  unsigned int *v113;
  unsigned int v114;
  uint64_t v115;
  unsigned int *v116;
  _BYTE *v117;
  unsigned int v118;
  uint64_t v119;
  uint64_t v120;
  unsigned int *v121;
  unsigned int v122;
  unsigned int *v123;
  unsigned int *v124;
  unsigned int v125;
  unsigned int *v126;
  unsigned int *v127;
  unsigned int v128;
  unsigned int *v129;
  unsigned int v130;
  unsigned int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _QWORD *v136;
  _QWORD *v137;
  _QWORD *v138;
  _QWORD *v139;
  _QWORD *exception;
  _QWORD *v141;
  _QWORD *v142;
  uint64_t *v143;
  uint64_t *v144;
  uint64_t v145;
  uint64_t (**v146)(_QWORD);
  int v147;
  uint64_t v148;
  unsigned int *v149;
  unsigned int *v150;
  unsigned int *v151;
  unsigned int *v152;
  unsigned int *v153;
  unsigned int *v154;
  unsigned int *v155;
  unsigned int *v156;
  uint64_t v157;
  _QWORD v158[10];
  char v159;
  uint64_t v160;
  std::string v161;
  uint64_t v162;
  _QWORD v163[10];
  char v164;
  uint64_t v165;
  unsigned int *v166;
  uint64_t (**v167)(_QWORD);
  int v168;
  uint64_t v169;
  void *__p[2];
  uint64_t v171;
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v147 = 0;
  v146 = &off_1E95AF9B0;
  if (a2)
  {
    v5 = (unsigned int *)(a2 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v148 = a2;
  v7 = operator new();
  *(_DWORD *)(v7 + 8) = 0;
  v8 = (unsigned int *)(v7 + 8);
  *(_QWORD *)v7 = &off_1E95AFA60;
  sub_1D3DAF780(v7 + 16, (uint64_t)&v146);
  *(_QWORD *)(v7 + 40) = 0;
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  v166 = (unsigned int *)v7;
  sub_1D3D93A78((uint64_t)&v162);
  memset(&v161, 0, sizeof(v161));
  sub_1D3D93A78((uint64_t)&v157);
  if (a3)
    v10 = a3;
  else
    v10 = "ISO-8859-1";
  v143 = a1;
  sub_1D3D81D4C(__p, v10);
  v11 = sub_1D3DA526C((uint64_t)__p);
  if (SHIBYTE(v171) < 0)
    operator delete(__p[0]);
  v144 = (uint64_t *)v11;
  v12 = 1;
LABEL_12:
  switch(v12)
  {
    case 1:
      v13 = v166;
      if (v166)
      {
        v14 = v166 + 2;
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }
      v16 = 0;
      v156 = v13;
      while (2)
      {
        v17 = sub_1D3DA34C8((uint64_t)v13, 8);
        v18 = v17;
        if (!v17)
        {
          exception = __cxa_allocate_exception(0x20uLL);
          sub_1D3DDE1A0(exception, "Not enough bits to decode");
          goto LABEL_259;
        }
        v19 = v17 + 0x80;
        if (v17 <= 128)
        {
          if ((v16 & 1) == 0)
            v19 = v17;
          LOBYTE(__p[0]) = v19 - 1;
          sub_1D3D8C900(&v162, (uint64_t)__p, 1);
LABEL_195:
          v12 = 1;
          goto LABEL_196;
        }
        if (v17 != 129)
        {
          if (v17 <= 0xE5)
          {
            if (v17 <= 0x8B)
            {
              LOBYTE(__p[0]) = 48;
              sub_1D3D8C900(&v162, (uint64_t)__p, 1);
            }
            std::ostream::operator<<();
            v20 = v16;
LABEL_36:
            v13 = v156;
            v16 = v20;
            if ((int)(8
                     * (*(_DWORD *)(*((_QWORD *)v156 + 4) + 24) - *(_DWORD *)(*((_QWORD *)v156 + 4) + 16) - v156[10])
                     - v156[11]) <= 0)
              goto LABEL_195;
            continue;
          }
          if (v17 == 232)
          {
            if (v156[10] != 1)
            {
              LOBYTE(__p[0]) = 29;
              sub_1D3D8C900(&v162, (uint64_t)__p, 1);
            }
            goto LABEL_35;
          }
          if (v17 == 230)
          {
            v12 = 2;
LABEL_196:
            v22 = (uint64_t *)&v156;
            goto LABEL_197;
          }
          if (v17 != 231)
          {
            if ((v17 - 233) < 2)
            {
LABEL_35:
              v20 = v16;
              goto LABEL_36;
            }
            v21 = 3;
            v12 = 4;
            v22 = (uint64_t *)&v156;
            v20 = 1;
            switch(v18)
            {
              case 235:
                goto LABEL_36;
              case 236:
                size = HIBYTE(v161.__r_.__value_.__r.__words[2]);
                if ((v161.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  size = v161.__r_.__value_.__l.__size_;
                if (size)
                  goto LABEL_35;
                v24 = "[)>\x1E05\x1D";
                goto LABEL_42;
              case 237:
                v25 = HIBYTE(v161.__r_.__value_.__r.__words[2]);
                if ((v161.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  v25 = v161.__r_.__value_.__l.__size_;
                if (v25)
                  goto LABEL_35;
                v24 = "[)>\x1E06\x1D";
LABEL_42:
                std::string::append(&v161, v24, 7uLL);
                sub_1D3D8C900(&v157, (uint64_t)"\x1E\x04", 2);
                v20 = v16;
                goto LABEL_36;
              case 238:
                goto LABEL_197;
              case 239:
                goto LABEL_200;
              case 240:
                v12 = 5;
                goto LABEL_196;
              case 241:
                if ((int)(8
                         * (*(_DWORD *)(*((_QWORD *)v156 + 4) + 24)
                          - *(_DWORD *)(*((_QWORD *)v156 + 4) + 16)
                          - v156[10])
                         - v156[11]) < 8)
                  goto LABEL_35;
                sub_1D3D93B64(__p, (uint64_t)v163);
                sub_1D3DC7B3C(&v161, (const std::string::value_type *)__p, *(_QWORD *)v144[1]);
                if (SHIBYTE(v171) < 0)
                  operator delete(__p[0]);
                sub_1D3D81D4C(__p, "");
                sub_1D3DC7B40((uint64_t)v163, (__int128 *)__p);
                if (SHIBYTE(v171) < 0)
                  operator delete(__p[0]);
                std::ios_base::clear((std::ios_base *)((char *)&v163[-1] + *(_QWORD *)(v162 - 24)), 0);
                v26 = sub_1D3DA34C8((uint64_t)v156, 8);
                v27 = v26;
                if ((v26 & 0xFFFFFFC0) == 0x80)
                {
                  if ((int)(8
                           * (*(_DWORD *)(*((_QWORD *)v156 + 4) + 24)
                            - *(_DWORD *)(*((_QWORD *)v156 + 4) + 16)
                            - v156[10])
                           - v156[11]) > 7)
                  {
                    v28 = sub_1D3DA34C8((uint64_t)v156, 8) + 254 * v26;
                    v29 = -32386;
LABEL_56:
                    v32 = v28 + v29;
LABEL_58:
                    v144 = sub_1D3DA51B4(v32);
                    goto LABEL_35;
                  }
                }
                else if (v26 < 192)
                {
                  v32 = v26 - 1;
                  if (v26 >= 1)
                    goto LABEL_58;
                }
                else if ((int)(8
                              * (*(_DWORD *)(*((_QWORD *)v156 + 4) + 24)
                               - *(_DWORD *)(*((_QWORD *)v156 + 4) + 16)
                               - v156[10])
                              - v156[11]) > 15)
                {
                  v30 = sub_1D3DA34C8((uint64_t)v156, 8);
                  v31 = sub_1D3DA34C8((uint64_t)v156, 8);
                  v28 = 254 * v30 + 64516 * v27;
                  v29 = v31 - 12370944;
                  goto LABEL_56;
                }
                exception = __cxa_allocate_exception(0x20uLL);
                sub_1D3DDE1A0(exception, "ECI value improperly encoded");
                break;
              case 254:
                v20 = v16;
                if (v156[11] != 8
                               * (*(_DWORD *)(*((_QWORD *)v156 + 4) + 24)
                                - *(_DWORD *)(*((_QWORD *)v156 + 4) + 16)
                                - v156[10]))
                  goto LABEL_262;
                goto LABEL_36;
              default:
LABEL_262:
                exception = __cxa_allocate_exception(0x20uLL);
                sub_1D3DDE1A0(exception, "Not to be used in ASCII encodation");
                break;
            }
LABEL_259:
            *exception = &off_1E95AF330;
            __cxa_throw(exception, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
          }
          v21 = 6;
LABEL_200:
          v22 = (uint64_t *)&v156;
          v12 = v21;
LABEL_197:
          sub_1D3DB4958((unsigned int **)v22);
          if ((int)(8
                   * (*(_DWORD *)(*((_QWORD *)v166 + 4) + 24) - *(_DWORD *)(*((_QWORD *)v166 + 4) + 16) - v166[10])
                   - v166[11]) <= 0)
            goto LABEL_204;
          goto LABEL_12;
        }
        break;
      }
      sub_1D3DB4958(&v156);
LABEL_204:
      sub_1D3D93B64(__p, (uint64_t)v163);
      sub_1D3DC7B3C(&v161, (const std::string::value_type *)__p, *(_QWORD *)v144[1]);
      if (SHIBYTE(v171) < 0)
        operator delete(__p[0]);
      sub_1D3D93B64(__p, (uint64_t)v158);
      if (SHIBYTE(v171) < 0)
      {
        v109 = __p[1];
        operator delete(__p[0]);
        if (!v109)
          goto LABEL_218;
      }
      else if (!HIBYTE(v171))
      {
        goto LABEL_218;
      }
      sub_1D3D93B64(__p, (uint64_t)v158);
      if (v171 >= 0)
        v110 = __p;
      else
        v110 = (void **)__p[0];
      if (v171 >= 0)
        v111 = HIBYTE(v171);
      else
        v111 = (std::string::size_type)__p[1];
      std::string::append(&v161, (const std::string::value_type *)v110, v111);
      if (SHIBYTE(v171) < 0)
        operator delete(__p[0]);
LABEL_218:
      LODWORD(__p[1]) = 0;
      __p[0] = &off_1E95AF9B0;
      v112 = v148;
      if (v148)
      {
        v113 = (unsigned int *)(v148 + 8);
        do
          v114 = __ldxr(v113);
        while (__stxr(v114 + 1, v113));
      }
      v171 = v112;
      v115 = operator new();
      *(_DWORD *)(v115 + 8) = 0;
      v116 = (unsigned int *)(v115 + 8);
      *(_QWORD *)v115 = off_1E95AF718;
      v117 = (_BYTE *)(v115 + 16);
      if (SHIBYTE(v161.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_1D3D7FCC0(v117, v161.__r_.__value_.__l.__data_, v161.__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)v117 = *(_OWORD *)&v161.__r_.__value_.__l.__data_;
        *(_QWORD *)(v115 + 32) = *((_QWORD *)&v161.__r_.__value_.__l + 2);
      }
      do
        v118 = __ldxr(v116);
      while (__stxr(v118 + 1, v116));
      v150 = (unsigned int *)v115;
      v119 = operator new();
      v168 = 0;
      v167 = &off_1E95AF9B0;
      v120 = v171;
      if (v171)
      {
        v121 = (unsigned int *)(v171 + 8);
        do
          v122 = __ldxr(v121);
        while (__stxr(v122 + 1, v121));
      }
      v169 = v120;
      v123 = v150;
      if (v150)
      {
        v124 = v150 + 2;
        do
          v125 = __ldxr(v124);
        while (__stxr(v125 + 1, v124));
      }
      v149 = v123;
      *(_DWORD *)(v119 + 8) = 0;
      v126 = (unsigned int *)(v119 + 8);
      *(_QWORD *)v119 = off_1E95AF2A0;
      *(_DWORD *)(v119 + 24) = 0;
      *(_QWORD *)(v119 + 16) = &off_1E95AF9B0;
      *(_QWORD *)(v119 + 32) = 0;
      if (v120)
      {
        v127 = (unsigned int *)(v120 + 8);
        do
          v128 = __ldxr(v127);
        while (__stxr(v128 + 1, v127));
      }
      *(_QWORD *)(v119 + 32) = v120;
      *(_QWORD *)(v119 + 40) = 0;
      if (v123)
      {
        v129 = v123 + 2;
        do
          v130 = __ldxr(v129);
        while (__stxr(v130 + 1, v129));
      }
      *(_QWORD *)(v119 + 104) = 0;
      *(_DWORD *)(v119 + 56) = 0;
      *(_QWORD *)(v119 + 40) = v123;
      *(_QWORD *)(v119 + 48) = &off_1E95AF990;
      *(_QWORD *)(v119 + 112) = 0;
      *(_OWORD *)(v119 + 64) = 0u;
      *(_OWORD *)(v119 + 80) = 0u;
      *(_QWORD *)(v119 + 96) = v119 + 104;
      do
        v131 = __ldxr(v126);
      while (__stxr(v131 + 1, v126));
      *v143 = v119;
      sub_1D3D7F598(&v149);
      sub_1D3D7F558(&v167);
      sub_1D3D7F598(&v150);
      sub_1D3D7F558(__p);
      v132 = *MEMORY[0x1E0DE4F60];
      v157 = v132;
      v133 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
      *(_QWORD *)((char *)&v158[-1] + *(_QWORD *)(v132 - 24)) = v133;
      v134 = MEMORY[0x1E0DE4FB8];
      v158[0] = MEMORY[0x1E0DE4FB8] + 16;
      if (v159 < 0)
        operator delete((void *)v158[8]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1D8254BF4](&v160);
      if (SHIBYTE(v161.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v161.__r_.__value_.__l.__data_);
      v162 = v132;
      *(_QWORD *)((char *)&v163[-1] + *(_QWORD *)(v132 - 24)) = v133;
      v163[0] = v134 + 16;
      if (v164 < 0)
        operator delete((void *)v163[8]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1D8254BF4](&v165);
      sub_1D3DB4958(&v166);
      return sub_1D3D7F558(&v146);
    case 2:
      v69 = v166;
      if (v166)
      {
        v70 = v166 + 2;
        do
          v71 = __ldxr(v70);
        while (__stxr(v71 + 1, v70));
      }
      v72 = 0;
      v73 = 0;
      v155 = v69;
      v75 = *(_QWORD *)(*((_QWORD *)v69 + 4) + 16);
      v74 = *(_QWORD *)(*((_QWORD *)v69 + 4) + 24);
      v76 = v69[10];
      v77 = v69[11];
LABEL_126:
      if (8 * ((_DWORD)v74 - (_DWORD)v75 - v76) - v77 == 8 || (v78 = sub_1D3DA34C8((uint64_t)v69, 8), v78 == 254))
      {
LABEL_154:
        v12 = 1;
        v22 = (uint64_t *)&v155;
        goto LABEL_197;
      }
      v79 = 0;
      v80 = sub_1D3DA34C8((uint64_t)v155, 8) + (v78 << 8) - 1;
      v81 = v80 / 1600;
      v80 %= 1600;
      LODWORD(__p[0]) = v81;
      HIDWORD(__p[0]) = v80 / 40;
      LODWORD(__p[1]) = v80 % 40;
      while (1)
      {
        v82 = *(unsigned int *)((char *)__p + v79);
        v83 = (int)v82;
        switch(v73)
        {
          case 0:
            if ((int)v82 > 2)
            {
              if (v82 > 0x27)
              {
                v136 = __cxa_allocate_exception(0x20uLL);
                sub_1D3DDE1A0(v136, "decodeC40Segment: no C40_BASIC_SET_CHARS for cValue");
                goto LABEL_253;
              }
              v85 = byte_1D3E6B598[v82];
              if ((v72 & 1) != 0)
                LOBYTE(v167) = v85 ^ 0x80;
              else
                LOBYTE(v167) = v85;
              goto LABEL_146;
            }
            v73 = v82 + 1;
            break;
          case 1:
            if ((v72 & 1) != 0)
              LOBYTE(v167) = v82 ^ 0x80;
            else
              LOBYTE(v167) = *(_DWORD *)((char *)__p + v79);
            goto LABEL_146;
          case 2:
            if ((int)v82 <= 26)
            {
              v84 = byte_1D3E6B5C0[(int)v82];
              if ((v72 & 1) != 0)
                LOBYTE(v167) = v84 ^ 0x80;
              else
                LOBYTE(v167) = byte_1D3E6B5C0[v83];
LABEL_146:
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              v72 = 0;
LABEL_151:
              v73 = 0;
              break;
            }
            if ((_DWORD)v82 != 30)
            {
              if ((_DWORD)v82 != 27)
              {
                v136 = __cxa_allocate_exception(0x20uLL);
                sub_1D3DDE1A0(v136, "decodeC40Segment: Upper Shift");
LABEL_253:
                *v136 = &off_1E95AF330;
                __cxa_throw(v136, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
              }
              LOBYTE(v167) = 29;
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              goto LABEL_151;
            }
            v73 = 0;
            v72 = 1;
            break;
          case 3:
            if ((v72 & 1) != 0)
              LOBYTE(v167) = v82 - 32;
            else
              LOBYTE(v167) = v82 + 96;
            goto LABEL_146;
          default:
            v136 = __cxa_allocate_exception(0x20uLL);
            sub_1D3DDE1A0(v136, "decodeC40Segment: no case");
            goto LABEL_253;
        }
        v79 += 4;
        if (v79 == 12)
        {
          v69 = v155;
          v75 = *(_QWORD *)(*((_QWORD *)v155 + 4) + 16);
          v74 = *(_QWORD *)(*((_QWORD *)v155 + 4) + 24);
          v76 = v155[10];
          v77 = v155[11];
          if ((int)(8 * (v74 - v75 - v76) - v77) <= 0)
            goto LABEL_154;
          goto LABEL_126;
        }
      }
    case 3:
      v42 = v166;
      if (v166)
      {
        v43 = v166 + 2;
        do
          v44 = __ldxr(v43);
        while (__stxr(v44 + 1, v43));
      }
      v45 = 0;
      v46 = 0;
      v154 = v42;
      v48 = *(_QWORD *)(*((_QWORD *)v42 + 4) + 16);
      v47 = *(_QWORD *)(*((_QWORD *)v42 + 4) + 24);
      v49 = v42[10];
      v50 = v42[11];
LABEL_73:
      if (8 * ((_DWORD)v47 - (_DWORD)v48 - v49) - v50 == 8 || (v51 = sub_1D3DA34C8((uint64_t)v42, 8), v51 == 254))
      {
LABEL_102:
        v12 = 1;
        v22 = (uint64_t *)&v154;
        goto LABEL_197;
      }
      v52 = 0;
      v53 = sub_1D3DA34C8((uint64_t)v154, 8) + (v51 << 8) - 1;
      v54 = v53 / 1600;
      v53 %= 1600;
      LODWORD(__p[0]) = v54;
      HIDWORD(__p[0]) = v53 / 40;
      LODWORD(__p[1]) = v53 % 40;
      while (1)
      {
        v55 = *(unsigned int *)((char *)__p + v52);
        v56 = *(_DWORD *)((char *)__p + v52);
        switch(v46)
        {
          case 0:
            if ((int)v55 > 2)
            {
              if (v56 > 0x27)
              {
                v137 = __cxa_allocate_exception(0x20uLL);
                sub_1D3DDE1A0(v137, "decodeC40Segment: no TEXT_BASIC_SET_CHARS for cValue");
                goto LABEL_255;
              }
              if ((v45 & 1) != 0)
                LOBYTE(v167) = byte_1D3E6B5DB[v55] ^ 0x80;
              else
                LOBYTE(v167) = byte_1D3E6B5DB[v55];
              goto LABEL_93;
            }
            v46 = v56 + 1;
            break;
          case 1:
            if ((v45 & 1) != 0)
              LOBYTE(v167) = v56 ^ 0x80;
            else
              LOBYTE(v167) = *(_DWORD *)((char *)__p + v52);
            goto LABEL_93;
          case 2:
            if (v56 <= 26)
            {
              if ((v45 & 1) != 0)
                LOBYTE(v167) = byte_1D3E6B5C0[(int)v55] ^ 0x80;
              else
                LOBYTE(v167) = byte_1D3E6B5C0[(int)v55];
LABEL_93:
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              v45 = 0;
LABEL_99:
              v46 = 0;
              break;
            }
            if ((_DWORD)v55 != 30)
            {
              if ((_DWORD)v55 != 27)
              {
                v137 = __cxa_allocate_exception(0x20uLL);
                sub_1D3DDE1A0(v137, "decodeTextSegment: Upper Shift");
LABEL_255:
                *v137 = &off_1E95AF330;
                __cxa_throw(v137, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
              }
              LOBYTE(v167) = 29;
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              goto LABEL_99;
            }
            v46 = 0;
            v45 = 1;
            break;
          case 3:
            if ((int)v55 > 31)
            {
              v137 = __cxa_allocate_exception(0x20uLL);
              sub_1D3DDE1A0(v137, "decodeC40Segment: no TEXT_SHIFT3_SET_CHARS for cValue");
              goto LABEL_255;
            }
            if ((v45 & 1) != 0)
              LOBYTE(v167) = byte_1D3E6B603[(int)v55] ^ 0x80;
            else
              LOBYTE(v167) = byte_1D3E6B603[(int)v55];
            goto LABEL_93;
          default:
            v137 = __cxa_allocate_exception(0x20uLL);
            sub_1D3DDE1A0(v137, "decodeTextSegment: no case");
            goto LABEL_255;
        }
        v52 += 4;
        if (v52 == 12)
        {
          v42 = v154;
          v48 = *(_QWORD *)(*((_QWORD *)v154 + 4) + 16);
          v47 = *(_QWORD *)(*((_QWORD *)v154 + 4) + 24);
          v49 = v154[10];
          v50 = v154[11];
          if ((int)(8 * (v47 - v48 - v49) - v50) <= 0)
            goto LABEL_102;
          goto LABEL_73;
        }
      }
    case 4:
      v57 = v166;
      if (v166)
      {
        v58 = v166 + 2;
        do
          v59 = __ldxr(v58);
        while (__stxr(v59 + 1, v58));
      }
      v153 = v57;
      v61 = *(_QWORD *)(*((_QWORD *)v57 + 4) + 16);
      v60 = *(_QWORD *)(*((_QWORD *)v57 + 4) + 24);
      v62 = v57[10];
      v63 = v57[11];
      do
      {
        if (8 * ((_DWORD)v60 - (_DWORD)v61 - v62) - v63 == 8)
          break;
        v64 = sub_1D3DA34C8((uint64_t)v57, 8);
        if (v64 == 254)
          break;
        v65 = 0;
        v66 = sub_1D3DA34C8((uint64_t)v153, 8) + (v64 << 8) - 1;
        v67 = v66 / 1600;
        v66 %= 1600;
        LODWORD(__p[0]) = v67;
        HIDWORD(__p[0]) = v66 / 40;
        LODWORD(__p[1]) = v66 % 40;
        do
        {
          v68 = *(_DWORD *)((char *)__p + v65);
          switch(v68)
          {
            case 0:
              LOBYTE(v167) = 13;
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              break;
            case 1:
              LOBYTE(v167) = 42;
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              break;
            case 2:
              LOBYTE(v167) = 62;
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              break;
            case 3:
              LOBYTE(v167) = 32;
              sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              break;
            default:
              if (v68 > 13)
              {
                if (v68 > 0x27)
                {
                  v138 = __cxa_allocate_exception(0x20uLL);
                  sub_1D3DDE1A0(v138, "decodeAnsiX12Segment: no case");
                  *v138 = &off_1E95AF330;
                  __cxa_throw(v138, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
                }
                LOBYTE(v167) = v68 + 51;
                sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              }
              else
              {
                LOBYTE(v167) = v68 + 44;
                sub_1D3D8C900(&v162, (uint64_t)&v167, 1);
              }
              break;
          }
          v65 += 4;
        }
        while (v65 != 12);
        v57 = v153;
        v61 = *(_QWORD *)(*((_QWORD *)v153 + 4) + 16);
        v60 = *(_QWORD *)(*((_QWORD *)v153 + 4) + 24);
        v62 = v153[10];
        v63 = v153[11];
      }
      while ((int)(8 * (v60 - v61 - v62) - v63) > 0);
      v12 = 1;
      v22 = (uint64_t *)&v153;
      goto LABEL_197;
    case 5:
      v33 = v166;
      if (v166)
      {
        v34 = v166 + 2;
        do
          v35 = __ldxr(v34);
        while (__stxr(v35 + 1, v34));
      }
      v152 = v33;
      v37 = *(_QWORD *)(*((_QWORD *)v33 + 4) + 16);
      v36 = *(_QWORD *)(*((_QWORD *)v33 + 4) + 24);
      v38 = v33[10];
      v39 = v33[11];
LABEL_63:
      if ((int)(8 * (v36 - v37 - v38) - v39) < 17)
        goto LABEL_163;
      v40 = 0;
      while (1)
      {
        v41 = sub_1D3DA34C8((uint64_t)v152, 6);
        if (v41 == 31)
          break;
        LOBYTE(__p[0]) = ~(2 * v41) & 0x40 | v41;
        sub_1D3D8C900(&v162, (uint64_t)__p, 1);
        if (++v40 == 4)
        {
          v37 = *(_QWORD *)(*((_QWORD *)v152 + 4) + 16);
          v36 = *(_QWORD *)(*((_QWORD *)v152 + 4) + 24);
          v38 = v152[10];
          v39 = v152[11];
          v12 = 1;
          v22 = (uint64_t *)&v152;
          if ((int)(8 * (v36 - v37 - v38) - v39) > 0)
            goto LABEL_63;
          goto LABEL_197;
        }
      }
      if (((2 * (_BYTE)v40 + 2) & 6) != 0)
        sub_1D3DA34C8((uint64_t)v152, (2 * (_BYTE)v40 + 2) & 6);
LABEL_163:
      v12 = 1;
      v22 = (uint64_t *)&v152;
      goto LABEL_197;
    case 6:
      v86 = v166;
      if (v166)
      {
        v87 = v166 + 2;
        do
          v88 = __ldxr(v87);
        while (__stxr(v88 + 1, v87));
      }
      v151 = v86;
      v89 = v86[10];
      v90 = sub_1D3DA34C8((uint64_t)v86, 8);
      v91 = v89 + 2;
      v92 = (v90 + ~(149 * v89 + 149 + (int)(149 * v89 + 149) / 255));
      if (v90 + ~(149 * v89 + 149 + (int)(149 * v89 + 149) / 255))
      {
        if (v92 < 0xFA)
          goto LABEL_166;
        v93 = 250 * v92 + (sub_1D3DA34C8((uint64_t)v151, 8) + ~(-107 * v91 + (int)(149 * v91) / 255));
        v91 = v89 + 3;
        v92 = v93 - 62250;
      }
      else
      {
        v92 = (int)(8
                  * (*(_DWORD *)(*((_QWORD *)v151 + 4) + 24) - *(_DWORD *)(*((_QWORD *)v151 + 4) + 16) - v151[10])
                  - v151[11])
            / 8;
      }
      if ((v92 & 0x80000000) != 0)
      {
        v142 = __cxa_allocate_exception(0x20uLL);
        sub_1D3DDE1A0(v142, "NegativeArraySizeException");
        *v142 = &off_1E95AF330;
        __cxa_throw(v142, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
      }
LABEL_166:
      v94 = v92;
      v95 = operator new[]();
      if (v92)
      {
        v96 = v95;
        v97 = 0;
        v98 = 0;
        v99 = 0;
        v100 = 0;
        v145 = v92;
        do
        {
          if ((int)(8
                   * (*(_DWORD *)(*((_QWORD *)v151 + 4) + 24) - *(_DWORD *)(*((_QWORD *)v151 + 4) + 16) - v151[10])
                   - v151[11]) <= 7)
          {
            v139 = __cxa_allocate_exception(0x20uLL);
            sub_1D3DDE1A0(v139, "byteSegments");
            *v139 = &off_1E95AF330;
            __cxa_throw(v139, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
          }
          v101 = sub_1D3DA34C8((uint64_t)v151, 8) + ~((int)(149 * v91) % 255);
          *(_BYTE *)(v96 + v100) = v101;
          if (v98 >= v99)
          {
            v102 = (uint64_t)&v98[-v97 + 1];
            if (v102 < 0)
              sub_1D3D6D4F8();
            if (2 * (uint64_t)&v99[-v97] > (unint64_t)v102)
              v102 = 2 * (_QWORD)&v99[-v97];
            if ((unint64_t)&v99[-v97] >= 0x3FFFFFFFFFFFFFFFLL)
              v103 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v103 = v102;
            if (v103)
              v104 = (char *)operator new(v103);
            else
              v104 = 0;
            v105 = &v98[(_QWORD)v104 - v97];
            *v105 = v101;
            v106 = v105 + 1;
            if (v98 != (char *)v97)
            {
              v107 = &v98[~v97];
              do
              {
                v108 = *--v98;
                (v107--)[(_QWORD)v104] = v108;
              }
              while (v98 != (char *)v97);
              v105 = v104;
            }
            v99 = &v104[v103];
            if (v97)
              operator delete((void *)v97);
            v97 = (unint64_t)v105;
            v98 = v106;
            v94 = v145;
          }
          else
          {
            *v98++ = v101;
          }
          LOBYTE(__p[0]) = *(_BYTE *)(v96 + v100);
          sub_1D3D8C900(&v162, (uint64_t)__p, 1);
          ++v91;
          ++v100;
        }
        while (v100 != v94);
        if (v97)
          operator delete((void *)v97);
        v12 = 1;
        v22 = (uint64_t *)&v151;
      }
      else
      {
        v12 = 1;
        v22 = (uint64_t *)&v151;
      }
      goto LABEL_197;
    default:
      v141 = __cxa_allocate_exception(0x20uLL);
      sub_1D3DDE1A0(v141, "Unsupported mode indicator");
      *v141 = &off_1E95AF330;
      __cxa_throw(v141, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
}

void sub_1D3DC94C0(void *a1, int a2)
{
  _QWORD *exception;
  char *v3;

  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_1D3D93A78((uint64_t)&STACK[0x2C8]);
    sub_1D3D81D4C(&STACK[0x2B0], "Unsupported ECI: ");
    sub_1D3DC7B40((uint64_t)&STACK[0x2D0], (__int128 *)&STACK[0x2B0]);
    if (SLOBYTE(STACK[0x2C7]) < 0)
      operator delete((void *)STACK[0x2B0]);
    std::ostream::operator<<();
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3D93B64(&STACK[0x2B0], (uint64_t)&STACK[0x2D0]);
    if (SLOBYTE(STACK[0x2C7]) >= 0)
      v3 = (char *)&STACK[0x2B0];
    else
      v3 = (char *)STACK[0x2B0];
    sub_1D3DDE1A0(exception, v3);
    *exception = &off_1E95AF330;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1A0, (void (*)(void *))sub_1D3DDE1E4);
  }
  JUMPOUT(0x1D3DC9880);
}

void sub_1D3DC957C()
{
  void *v0;
  void *v1;
  int v2;
  int v3;

  if (v2 < 0)
  {
    operator delete(v1);
    if ((v3 & 1) == 0)
      goto LABEL_6;
  }
  else if (!v3)
  {
LABEL_6:
    sub_1D3D93C38((uint64_t)&STACK[0x2C8]);
    __cxa_end_catch();
    JUMPOUT(0x1D3DC97BCLL);
  }
  __cxa_free_exception(v0);
  goto LABEL_6;
}

void sub_1D3DC95E4(void *a1, int a2)
{
  if (a2)
    sub_1D3D6D5A8(a1);
  JUMPOUT(0x1D3DC9880);
}

void sub_1D3DC95F4()
{
  if (SLOBYTE(STACK[0x2DF]) < 0)
    operator delete((void *)STACK[0x2C8]);
  JUMPOUT(0x1D3DC97BCLL);
}

void sub_1D3DC9610()
{
  uint64_t v0;

  MEMORY[0x1D8254C54](v0, 0x1093C40E92185C3);
  sub_1D3D7F558(&STACK[0x2C8]);
  JUMPOUT(0x1D3DC9850);
}

void sub_1D3DC9690(void *a1, int a2)
{
  if (a2)
  {
    if (SLOBYTE(STACK[0x2DF]) < 0)
      operator delete((void *)STACK[0x2C8]);
    __cxa_begin_catch(a1);
    sub_1D3D81D4C(&STACK[0x2C8], "ISO-8859-1");
    sub_1D3DA526C((uint64_t)&STACK[0x2C8]);
    if (SLOBYTE(STACK[0x2DF]) < 0)
      operator delete((void *)STACK[0x2C8]);
    __cxa_end_catch();
    JUMPOUT(0x1D3DC8000);
  }
  JUMPOUT(0x1D3DC9880);
}

void sub_1D3DC96F4()
{
  if (SLOBYTE(STACK[0x2DF]) < 0)
    operator delete((void *)STACK[0x2C8]);
  __cxa_end_catch();
  JUMPOUT(0x1D3DC9850);
}

void sub_1D3DC971C()
{
  JUMPOUT(0x1D3DC9858);
}

void sub_1D3DC9724()
{
  JUMPOUT(0x1D3DC9870);
}

void sub_1D3DC972C()
{
  uint64_t v0;

  MEMORY[0x1D8254C54](v0, 0x10A1C4099511FF1);
  JUMPOUT(0x1D3DC9878);
}

void sub_1D3DC974C()
{
  JUMPOUT(0x1D3DC9878);
}

void sub_1D3DC9754()
{
  JUMPOUT(0x1D3DC9850);
}

void sub_1D3DC975C()
{
  void *v0;

  __cxa_free_exception(v0);
  JUMPOUT(0x1D3DC9850);
}

void sub_1D3DC9770()
{
  JUMPOUT(0x1D3DC9810);
}

void sub_1D3DC9778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,unsigned int *a24,__int16 a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  char a64;
  void *v64;

  __cxa_free_exception(v64);
  sub_1D3DB4958(&a24);
  sub_1D3D93C38((uint64_t)&a25);
  if (a63 < 0)
    operator delete(__p);
  sub_1D3D93C38((uint64_t)&a64);
  sub_1D3DB4958((unsigned int **)&STACK[0x2A8]);
  sub_1D3D7F558(&a14);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DC9888(uint64_t *a1, unsigned int **a2)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  signed int v14;
  signed int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unsigned int *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  char v56;
  char v57;
  int v58;
  _BOOL4 v60;
  int v61;
  _BOOL4 v64;
  uint64_t v65;
  int v66;
  int v67;
  int v68;
  int v69;
  char v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  char v81;
  char v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  char v89;
  char v90;
  char v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  unsigned int *v98;
  unsigned int v99;
  int *v100;
  const void *v101;
  int64_t v102;
  char *v103;
  uint64_t v104;
  int v105;
  char *v106;
  uint64_t v107;
  uint64_t v108;
  size_t v109;
  _QWORD *v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  int v115;
  _DWORD *v116;
  uint64_t v117;
  uint64_t v118;
  unsigned int *v119;
  unsigned int *v120;
  unsigned int v121;
  unsigned int *v122;
  unsigned int *v123;
  unsigned int v124;
  unsigned int *v125;
  unsigned int v126;
  _QWORD *v127;
  unsigned int *v128;
  unsigned int *v129;
  unsigned int v130;
  unsigned int *v131;
  uint64_t v132;
  unsigned int *v133;
  unsigned int *v134;
  unsigned int v135;
  int v136;
  int v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  uint64_t v143;
  uint64_t v144;
  unsigned int *v145;
  unsigned int v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  char v151;
  uint64_t v152;
  uint64_t v153;
  unsigned int *v154;
  unsigned int v155;
  int v156;
  int v157;
  BOOL v158;
  int v159;
  char v160;
  uint64_t v161;
  uint64_t v162;
  unsigned int *v163;
  unsigned int v164;
  uint64_t *v165;
  uint64_t v166;
  unint64_t v167;
  int v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unsigned int *v172;
  unsigned int *v173;
  unsigned int v174;
  uint64_t v175;
  unsigned int *v176;
  unsigned int v177;
  int v178;
  unsigned int *v179;
  unsigned int v180;
  int v181;
  unsigned __int8 *v182;
  _DWORD *v183;
  uint64_t v184;
  int v185;
  unint64_t v186;
  uint64_t *v187;
  unsigned int *v188;
  unsigned int *v189;
  unsigned int v190;
  uint64_t i;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  unsigned int *v202;
  unsigned int v203;
  uint64_t v204;
  unsigned int *v205;
  _BYTE *v206;
  unsigned int v207;
  unsigned int *v208;
  unsigned int v209;
  _QWORD *exception;
  _QWORD *v212;
  _QWORD *v213;
  _QWORD *v214;
  unsigned int **v215;
  uint64_t *v216;
  uint64_t v218;
  int v219;
  uint64_t v220;
  int v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  int v225;
  uint64_t v226;
  int v227;
  uint64_t v228;
  int v229;
  uint64_t v230;
  uint64_t v231;
  int v232;
  int v233;
  uint64_t v234;
  int v235;
  unint64_t v236;
  int v237;
  char *__p;
  _QWORD *__pa;
  uint64_t v240;
  uint64_t v241;
  int v242;
  _QWORD v243[3];
  unsigned int *v244;
  uint64_t (**v245)(_QWORD);
  int v246;
  uint64_t v247;
  uint64_t (**v248)(_QWORD);
  int v249;
  unsigned int *v250;
  uint64_t (**v251)(_QWORD);
  int v252;
  unsigned int *v253;
  unsigned int *v254;
  unsigned int *v255[2];
  uint64_t v256;
  uint64_t (**v257)(_QWORD);
  int v258;
  uint64_t v259;
  _QWORD *v260;
  char *v261;
  _QWORD *v262;
  unsigned int *v263[2];
  uint64_t v264;
  unsigned int *v265;
  unsigned int *v266;
  uint64_t (**v267)();
  int v268;
  unsigned int *v269;
  unsigned int *v270;
  unsigned int *v271;
  __int128 v272;
  unsigned int *v273;
  unsigned int *v274;
  _QWORD *v275;
  unsigned int *v276;
  char v277;
  char **v278;
  char *v279;

  v3 = *a2;
  if (*a2)
  {
    v4 = v3 + 2;
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v268 = 0;
  v266 = v3;
  v267 = &off_1E95AF1D0;
  v270 = 0;
  v271 = 0;
  v269 = 0;
  if ((unint64_t)(*((_QWORD *)v3 + 2) - 8) > 0x88 || (*((_QWORD *)v3 + 2) & 1) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(exception, "Dimension must be even, > 8 < 144");
    *exception = &off_1E95AF388;
    __cxa_throw(exception, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
  }
  v7 = v3 + 2;
  do
    v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
  *(_QWORD *)&v272 = v3;
  sub_1D3DC7580(&v274, 0, v3);
  v9 = v274;
  if (v274)
  {
    v10 = v274 + 2;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v270 = v9;
  sub_1D3DC778C(&v274);
  sub_1D3D6D10C((unsigned int **)&v272);
  if (v266)
  {
    v12 = v266 + 2;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v263[0] = v266;
  v14 = v270[4];
  if (v14 != (v266[8] & (v266[14] - 1) | v266[4] & -v266[14]))
  {
    v212 = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(v212, "Dimension of bitMatrix must match the version size");
    *v212 = &off_1E95AF510;
    __cxa_throw(v212, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  v15 = v270[5];
  v16 = (int)v270[6];
  v17 = (int)v270[7];
  v18 = (uint64_t *)operator new();
  v228 = (v15 / (int)v17);
  v220 = (v14 / (int)v16);
  sub_1D3D938C4((uint64_t)v18, (int)v228 * (int)v17, (int)v220 * (int)v16);
  v215 = a2;
  v240 = v16;
  v231 = v17;
  v19 = (unsigned int *)(v18 + 1);
  do
    v20 = __ldxr(v19);
  while (__stxr(v20 + 1, v19));
  v274 = (unsigned int *)v18;
  if ((int)v220 > 0)
  {
    v222 = 0;
    v223 = 0;
    v224 = v17 + 2;
    v226 = v16;
    v218 = v16 + 2;
    do
    {
      if ((int)v228 >= 1)
      {
        v21 = 0;
        v234 = 1;
        __p = 0;
        do
        {
          v230 = v21;
          if ((int)v16 >= 1)
          {
            v22 = 0;
            v23 = v263[0];
            v24 = v223;
            do
            {
              v25 = v17;
              if ((int)v17 >= 1)
              {
                v26 = v234;
                v27 = v231;
                v28 = __p;
                do
                {
                  if (sub_1D3D6D4A0(v23, v26, v222 * v218 + 1 + v22))
                    *(_DWORD *)(v18[6] + (((unint64_t)&v28[v24 * v18[3]] >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << ((_BYTE)v28 + v24 * v18[3]);
                  ++v28;
                  ++v26;
                  --v27;
                }
                while (v27);
              }
              ++v22;
              ++v24;
              v17 = v25;
            }
            while (v22 != v240);
          }
          v21 = v230 + 1;
          __p += v17;
          v16 = v226;
          v234 += v224;
        }
        while (v230 + 1 != v228);
      }
      ++v222;
      v223 += v16;
      v19 = (unsigned int *)(v18 + 1);
    }
    while (v222 != v220);
  }
  do
    v29 = __ldxr(v19);
  while (__stxr(v29 + 1, v19));
  if (v269)
    sub_1D3D6D13C(v269);
  v269 = (unsigned int *)v18;
  sub_1D3D6D10C(&v274);
  sub_1D3D6D10C(v263);
  v30 = (unsigned int *)operator new();
  sub_1D3D938C4((uint64_t)v30, *((_QWORD *)v269 + 2) & (*((_QWORD *)v269 + 7) - 1) | *((_QWORD *)v269 + 4) & -*((_QWORD *)v269 + 7), *((_QWORD *)v269 + 4) & (*((_QWORD *)v269 + 7) - 1) | *((_QWORD *)v269 + 2) & -*((_QWORD *)v269 + 7));
  v31 = v30 + 2;
  do
    v32 = __ldxr(v31);
  while (__stxr(v32 + 1, v31));
  if (v271)
    sub_1D3D6D13C(v271);
  v271 = v30;
  sub_1D3D6D10C(&v266);
  v33 = *v215;
  if (*v215)
  {
    v34 = v33 + 2;
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
  }
  v265 = v33;
  sub_1D3DC7580(&v274, v270, v33);
  v216 = (uint64_t *)v274;
  sub_1D3DC778C(&v274);
  sub_1D3D6D10C(&v265);
  sub_1D3D81C50((uint64_t)v263, (int)v270[10]);
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v232 = 0;
  v227 = 0;
  v221 = 0;
  v39 = *((_QWORD *)v269 + 7);
  v40 = -v39;
  v41 = *((_QWORD *)v269 + 2);
  v42 = v41 & -v39;
  LODWORD(v39) = v39 - 1;
  v43 = *((_QWORD *)v269 + 4);
  v44 = v43 & v39 | v42;
  v45 = v41 & v39 | v43 & v40;
  v46 = v44 - 2;
  v47 = v45 & 7;
  v233 = v44 - 1;
  v235 = v45 - 2;
  v225 = v44 - 3;
  v229 = v45 - 3;
  v48 = 4;
  do
  {
    if (v48 == v44 && !v37 && (v38 & 1) == 0)
    {
      v37 = 2;
      if (sub_1D3DC79AC((uint64_t)&v267, v233, 0, v44, v45))
        v49 = 2;
      else
        v49 = 0;
      v38 = 1;
      v50 = v49 | sub_1D3DC79AC((uint64_t)&v267, v233, 1, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, v233, 2, v44, v45))
        v51 = 2;
      else
        v51 = 0;
      v52 = v51 | (4 * v50) | sub_1D3DC79AC((uint64_t)&v267, 0, v235, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, 0, v45 - 1, v44, v45))
        v53 = 2;
      else
        v53 = 0;
      v54 = v53 | (4 * v52);
      goto LABEL_58;
    }
    v60 = v48 != v46 || v37 != 0;
    v61 = (v45 & 3) == 0 || v60;
    if (((v61 | v232) & 1) == 0)
    {
      v37 = 2;
      if (sub_1D3DC79AC((uint64_t)&v267, v225, 0, v44, v45))
        v75 = 2;
      else
        v75 = 0;
      v76 = v75 | sub_1D3DC79AC((uint64_t)&v267, v46, 0, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, v233, 0, v44, v45))
        v77 = 2;
      else
        v77 = 0;
      v78 = v77 | (4 * v76) | sub_1D3DC79AC((uint64_t)&v267, 0, v45 - 4, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, 0, v229, v44, v45))
        v79 = 2;
      else
        v79 = 0;
      v80 = v79 | (4 * v78) | sub_1D3DC79AC((uint64_t)&v267, 0, v235, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, 0, v45 - 1, v44, v45))
        v81 = 2;
      else
        v81 = 0;
      v57 = v81 | (4 * v80);
      v232 = 1;
      v58 = 1;
      goto LABEL_113;
    }
    v64 = v48 != v44 + 4 || v37 != 2 || v47 != 0;
    if (((v64 | v227) & 1) != 0)
    {
      if (v47 != 4)
        v60 = 1;
      if (((v60 | v221) & 1) == 0)
      {
        v37 = 2;
        if (sub_1D3DC79AC((uint64_t)&v267, v225, 0, v44, v45))
          v92 = 2;
        else
          v92 = 0;
        v93 = v92 | sub_1D3DC79AC((uint64_t)&v267, v46, 0, v44, v45);
        if (sub_1D3DC79AC((uint64_t)&v267, v233, 0, v44, v45))
          v94 = 2;
        else
          v94 = 0;
        v95 = v94 | (4 * v93) | sub_1D3DC79AC((uint64_t)&v267, 0, v235, v44, v45);
        if (sub_1D3DC79AC((uint64_t)&v267, 0, v45 - 1, v44, v45))
          v96 = 2;
        else
          v96 = 0;
        v54 = v96 | (4 * v95);
        v221 = 1;
LABEL_58:
        v55 = v54 | sub_1D3DC79AC((uint64_t)&v267, 1, v45 - 1, v44, v45);
        if (sub_1D3DC79AC((uint64_t)&v267, 2, v45 - 1, v44, v45))
          v56 = 2;
        else
          v56 = 0;
        v57 = v56 | (4 * v55);
        v58 = 3;
LABEL_113:
        v82 = sub_1D3DC79AC((uint64_t)&v267, v58, v45 - 1, v44, v45);
        *(_BYTE *)(*(_QWORD *)(v264 + 16) + v36++) = v57 | v82;
        v48 -= 2;
        goto LABEL_114;
      }
      v219 = v38;
      v65 = v48;
      v66 = v37 + 5;
      v67 = v48 - 3;
      do
      {
        v68 = v37;
        v69 = v67;
        if (v65 < v44 && (v37 & 0x80000000) == 0 && (sub_1D3D6D4A0(v271, v37, v65) & 1) == 0)
        {
          v70 = sub_1D3DC785C((uint64_t)&v267, v65, v37, v44, v45);
          *(_BYTE *)(*(_QWORD *)(v264 + 16) + v36++) = v70;
        }
        v158 = v65 < 2;
        v65 -= 2;
        if (v158)
          break;
        v67 = v69 - 2;
        v37 += 2;
        v66 += 2;
      }
      while (v37 < v45);
      v71 = v68 + 5;
      v46 = v44 - 2;
      do
      {
        v72 = v71;
        if (v69 + 2 >= 0 && v71 < v45 && (sub_1D3D6D4A0(v271, v71, (v69 + 2)) & 1) == 0)
        {
          v73 = sub_1D3DC785C((uint64_t)&v267, v69 + 2, v72, v44, v45);
          *(_BYTE *)(*(_QWORD *)(v264 + 16) + v36++) = v73;
        }
        v74 = v69 + 4;
        v69 += 2;
        if (v74 >= v44)
          break;
        v71 = v72 - 2;
      }
      while (v72 > 1);
      v48 = v69 + 5;
      v37 = v72 - 1;
      v38 = v219;
    }
    else
    {
      if (sub_1D3DC79AC((uint64_t)&v267, v233, 0, v44, v45))
        v83 = 2;
      else
        v83 = 0;
      v84 = v83 | sub_1D3DC79AC((uint64_t)&v267, v233, v45 - 1, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, 0, v229, v44, v45))
        v85 = 2;
      else
        v85 = 0;
      v86 = v85 | (4 * v84) | sub_1D3DC79AC((uint64_t)&v267, 0, v235, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, 0, v45 - 1, v44, v45))
        v87 = 2;
      else
        v87 = 0;
      v88 = v87 | (4 * v86) | sub_1D3DC79AC((uint64_t)&v267, 1, v229, v44, v45);
      if (sub_1D3DC79AC((uint64_t)&v267, 1, v235, v44, v45))
        v89 = 2;
      else
        v89 = 0;
      v227 = 1;
      v90 = v89 | (4 * v88);
      v91 = sub_1D3DC79AC((uint64_t)&v267, 1, v45 - 1, v44, v45);
      *(_BYTE *)(*(_QWORD *)(v264 + 16) + v36++) = v90 | v91;
      v37 = 4;
      v48 = v44 + 2;
    }
LABEL_114:
    v47 = v45 & 7;
  }
  while (v48 < v44 || v37 < v45);
  if (v36 != v270[10])
  {
    v213 = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(v213, "Did not read all codewords");
    *v213 = &off_1E95AF388;
    __cxa_throw(v213, (struct type_info *)&unk_1E95AE1E8, (void (*)(void *))sub_1D3E174E0);
  }
  v258 = 0;
  v257 = &off_1E95AF9B0;
  v259 = 0;
  v97 = v264;
  if (v264)
  {
    v98 = (unsigned int *)(v264 + 8);
    do
      v99 = __ldxr(v98);
    while (__stxr(v99 + 1, v98));
  }
  v259 = v97;
  v100 = (int *)v216[4];
  v101 = (const void *)*((_QWORD *)v100 + 1);
  v102 = *((_QWORD *)v100 + 2) - (_QWORD)v101;
  if (v102 < 0)
    sub_1D3D6D4F8();
  v103 = (char *)sub_1D3D6D8A0(v102 >> 3);
  memmove(v103, v101, v102);
  v104 = 0;
  v105 = 0;
  v106 = &v103[8 * (v102 >> 3)];
  if ((unint64_t)(v102 >> 3) <= 1)
    v107 = 1;
  else
    v107 = v102 >> 3;
  do
    v105 += **(_DWORD **)&v103[8 * v104++];
  while (v107 != v104);
  __pa = v103;
  v260 = 0;
  v261 = 0;
  v262 = 0;
  v274 = (unsigned int *)&v260;
  LOBYTE(v275) = 0;
  if (v105)
  {
    if (v105 < 0)
      sub_1D3D6D4F8();
    v108 = v105;
    v109 = 8 * v105;
    v110 = operator new(v109);
    v260 = v110;
    v262 = &v110[v108];
    bzero(v110, v109);
    v261 = (char *)&v110[v109 / 8];
    v111 = v103;
    if (v106 == v103)
    {
      LODWORD(v112) = 0;
      goto LABEL_179;
    }
  }
  else
  {
    v111 = v103;
  }
  v113 = 0;
  LODWORD(v112) = 0;
  v114 = (v106 - v111) >> 3;
  if (v114 <= 1)
    v114 = 1;
  v236 = v114;
  do
  {
    v115 = 0;
    v241 = v113;
    v116 = (_DWORD *)__pa[v113];
    v112 = (int)v112;
    while (v115 < *v116)
    {
      v117 = (int)v116[1];
      sub_1D3D81C50((uint64_t)&v274, *v100 + v117);
      v118 = operator new();
      DWORD2(v272) = 0;
      *(_QWORD *)&v272 = &off_1E95AF9B0;
      v273 = 0;
      v119 = v276;
      if (v276)
      {
        v120 = v276 + 2;
        do
          v121 = __ldxr(v120);
        while (__stxr(v121 + 1, v120));
        if (v273)
          sub_1D3D6D13C(v273);
      }
      *(_DWORD *)(v118 + 8) = 0;
      v122 = (unsigned int *)(v118 + 8);
      v273 = v119;
      *(_QWORD *)v118 = &off_1E95AF230;
      *(_DWORD *)(v118 + 12) = v117;
      *(_DWORD *)(v118 + 24) = 0;
      *(_QWORD *)(v118 + 16) = &off_1E95AF9B0;
      *(_QWORD *)(v118 + 32) = 0;
      if (v119)
      {
        v123 = v119 + 2;
        do
          v124 = __ldxr(v123);
        while (__stxr(v124 + 1, v123));
        v125 = *(unsigned int **)(v118 + 32);
        if (v125)
          sub_1D3D6D13C(v125);
      }
      *(_QWORD *)(v118 + 32) = v119;
      do
        v126 = __ldxr(v122);
      while (__stxr(v126 + 1, v122));
      v255[0] = (unsigned int *)v118;
      sub_1D3D7F558(&v272);
      v127 = v260;
      v128 = v255[0];
      if (v255[0])
      {
        v129 = v255[0] + 2;
        do
          v130 = __ldxr(v129);
        while (__stxr(v130 + 1, v129));
      }
      v131 = (unsigned int *)v127[v112];
      if (v131)
        sub_1D3D6D13C(v131);
      v127[v112++] = v128;
      sub_1D3DC7A9C(v255);
      sub_1D3D7F558(&v274);
      ++v115;
    }
    v113 = v241 + 1;
  }
  while (v241 + 1 != v236);
  v110 = v260;
LABEL_179:
  v132 = *v110;
  LODWORD(v275) = 0;
  v274 = (unsigned int *)&off_1E95AF9B0;
  v276 = 0;
  v133 = *(unsigned int **)(v132 + 32);
  if (v133)
  {
    v134 = v133 + 2;
    do
      v135 = __ldxr(v134);
    while (__stxr(v135 + 1, v134));
    if (v276)
      sub_1D3D6D13C(v276);
  }
  v276 = v133;
  v136 = v133[6] - v133[4];
  sub_1D3D7F558(&v274);
  v242 = v136;
  v237 = *v100;
  v137 = v136 - *v100;
  v138 = (v137 - 1);
  if (v137 <= 1)
  {
    LODWORD(v140) = 0;
  }
  else
  {
    v139 = 0;
    LODWORD(v140) = 0;
    do
    {
      if ((int)v112 >= 1)
      {
        v141 = 0;
        v140 = (int)v140;
        do
        {
          v142 = *(_BYTE *)(*(_QWORD *)(v259 + 16) + v140);
          v143 = v260[v141];
          LODWORD(v275) = 0;
          v274 = (unsigned int *)&off_1E95AF9B0;
          v276 = 0;
          v144 = *(_QWORD *)(v143 + 32);
          if (v144)
          {
            v145 = (unsigned int *)(v144 + 8);
            do
              v146 = __ldxr(v145);
            while (__stxr(v146 + 1, v145));
            if (v276)
              sub_1D3D6D13C(v276);
          }
          ++v140;
          v276 = (unsigned int *)v144;
          *(_BYTE *)(*(_QWORD *)(v144 + 16) + v139) = v142;
          sub_1D3D7F558(&v274);
          ++v141;
        }
        while (v141 != v112);
      }
      ++v139;
    }
    while (v139 != v138);
  }
  v147 = *((_DWORD *)v216 + 3);
  if (v147 == 24)
    v148 = 8;
  else
    v148 = v112;
  if ((int)v148 < 1)
  {
    LODWORD(v150) = v140;
  }
  else
  {
    v149 = 0;
    v150 = (int)v140;
    do
    {
      v151 = *(_BYTE *)(*(_QWORD *)(v259 + 16) + v150);
      v152 = v260[v149];
      LODWORD(v275) = 0;
      v274 = (unsigned int *)&off_1E95AF9B0;
      v276 = 0;
      v153 = *(_QWORD *)(v152 + 32);
      if (v153)
      {
        v154 = (unsigned int *)(v153 + 8);
        do
          v155 = __ldxr(v154);
        while (__stxr(v155 + 1, v154));
        if (v276)
          sub_1D3D6D13C(v276);
      }
      ++v150;
      v276 = (unsigned int *)v153;
      *(_BYTE *)(*(_QWORD *)(v153 + 16) + (int)v138) = v151;
      sub_1D3D7F558(&v274);
      ++v149;
    }
    while (v149 != v148);
  }
  if (v237 >= 1)
  {
    do
    {
      if ((int)v112 >= 1)
      {
        v156 = 0;
        v150 = (int)v150;
        do
        {
          v157 = v156;
          if (v147 == 24)
          {
            v157 = (v156 + 8) % (int)v112;
            v158 = v157 <= 7;
          }
          else
          {
            v158 = 1;
          }
          v159 = !v158;
          v160 = *(_BYTE *)(*(_QWORD *)(v259 + 16) + v150);
          v161 = v260[v157];
          LODWORD(v275) = 0;
          v274 = (unsigned int *)&off_1E95AF9B0;
          v276 = 0;
          v162 = *(_QWORD *)(v161 + 32);
          if (v162)
          {
            v163 = (unsigned int *)(v162 + 8);
            do
              v164 = __ldxr(v163);
            while (__stxr(v164 + 1, v163));
            if (v276)
              sub_1D3D6D13C(v276);
          }
          ++v150;
          v276 = (unsigned int *)v162;
          *(_BYTE *)(*(_QWORD *)(v162 + 16) + v137 - v159) = v160;
          sub_1D3D7F558(&v274);
          ++v156;
        }
        while (v156 != (_DWORD)v112);
      }
      ++v137;
    }
    while (v137 < v242);
  }
  if (*(_QWORD *)(v259 + 24) - *(_QWORD *)(v259 + 16) != (int)v150)
  {
    v214 = __cxa_allocate_exception(0x20uLL);
    sub_1D3DDE1A0(v214, "rawCodewordsOffset != rawCodewords.length");
    *v214 = &off_1E95AF510;
    __cxa_throw(v214, (struct type_info *)&unk_1E95AE2D8, (void (*)(void *))sub_1D3DB930C);
  }
  if (__pa)
    operator delete(__pa);
  sub_1D3D7F558(&v257);
  v165 = v260;
  v166 = v261 - (char *)v260;
  v167 = (unint64_t)(v261 - (char *)v260) >> 3;
  if ((int)v167 < 1)
  {
    v168 = 0;
  }
  else
  {
    v168 = 0;
    v169 = ((unint64_t)(v261 - (char *)v260) >> 3);
    do
    {
      v170 = *v165++;
      v168 += *(_DWORD *)(v170 + 12);
      --v169;
    }
    while (v169);
  }
  sub_1D3D81C50((uint64_t)v255, v168);
  if ((int)v167 >= 1)
  {
    v171 = 0;
    do
    {
      v254 = 0;
      v172 = (unsigned int *)v260[v171];
      if (v172)
      {
        v173 = v172 + 2;
        do
          v174 = __ldxr(v173);
        while (__stxr(v174 + 1, v173));
      }
      v253 = 0;
      v254 = v172;
      v252 = 0;
      v251 = &off_1E95AF9B0;
      v175 = *((_QWORD *)v172 + 4);
      if (v175)
      {
        v176 = (unsigned int *)(v175 + 8);
        do
          v177 = __ldxr(v176);
        while (__stxr(v177 + 1, v176));
        if (v253)
        {
          sub_1D3D6D13C(v253);
          v172 = v254;
        }
        v253 = (unsigned int *)v175;
        v178 = v172[3];
        v249 = 0;
        v248 = &off_1E95AF9B0;
        v179 = (unsigned int *)(v175 + 8);
        v250 = 0;
        do
          v180 = __ldxr(v179);
        while (__stxr(v180 + 1, v179));
        if (v250)
          sub_1D3D6D13C(v250);
      }
      else
      {
        v253 = 0;
        v178 = v172[3];
        v249 = 0;
        v248 = &off_1E95AF9B0;
        v250 = 0;
      }
      v250 = (unsigned int *)v175;
      v181 = *(_QWORD *)(v175 + 24) - *(_QWORD *)(v175 + 16);
      sub_1D3D81F68((uint64_t)&v274, v181);
      if (v181 >= 1)
      {
        v182 = (unsigned __int8 *)*((_QWORD *)v250 + 2);
        v183 = (_DWORD *)*((_QWORD *)v276 + 2);
        v184 = v181;
        do
        {
          v185 = *v182++;
          *v183++ = v185;
          --v184;
        }
        while (v184);
      }
      v277 = 0;
      v186 = atomic_load(&qword_1EFE317C0);
      if (v186 != -1)
      {
        v279 = &v277;
        v278 = &v279;
        std::__call_once(&qword_1EFE317C0, &v278, (void (__cdecl *)(void *))sub_1D3DC7C80);
      }
      v187 = (uint64_t *)qword_1EFE317B8;
      DWORD2(v272) = 0;
      *(_QWORD *)&v272 = &off_1E95AF9D0;
      v188 = v276;
      if (v276)
      {
        v189 = v276 + 2;
        do
          v190 = __ldxr(v189);
        while (__stxr(v190 + 1, v189));
      }
      v273 = v188;
      sub_1D3DBC050(v187, (uint64_t)&v272, v181 - v178);
      sub_1D3D82064(&v272);
      if (v178 >= 1)
      {
        for (i = 0; i != v178; ++i)
          *(_BYTE *)(*((_QWORD *)v250 + 2) + i) = *(_DWORD *)(*((_QWORD *)v276 + 2) + 4 * i);
      }
      sub_1D3D82064(&v274);
      sub_1D3D7F558(&v248);
      if (v178 >= 1)
      {
        v192 = 0;
        v193 = v171;
        do
        {
          *(_BYTE *)(*(_QWORD *)(v256 + 16) + v193) = *(_BYTE *)(*((_QWORD *)v253 + 2) + v192++);
          v193 += (int)(v166 >> 3);
        }
        while (v178 != v192);
      }
      sub_1D3D7F558(&v251);
      sub_1D3DC7A9C(&v254);
      ++v171;
    }
    while (v171 != v167);
  }
  if (**(_BYTE **)(v256 + 16))
  {
    v275 = 0;
    v276 = 0;
    v274 = (unsigned int *)&v275;
    *((_DWORD *)sub_1D3D7F308((uint64_t **)&v274, 20, &dword_1D3E75678) + 8) = 200;
    v194 = *((_QWORD *)*v215 + 7);
    v195 = *((_QWORD *)*v215 + 4);
    v196 = *((_QWORD *)*v215 + 2);
    *((_DWORD *)sub_1D3D7F308((uint64_t **)&v274, 21, &dword_1D3E7567C) + 8) = v196 & (v194 - 1) | v195 & -(int)v194;
    v197 = *((_QWORD *)*v215 + 7);
    v198 = *((_QWORD *)*v215 + 2);
    v199 = *((_QWORD *)*v215 + 4);
    *((_DWORD *)sub_1D3D7F308((uint64_t **)&v274, 22, dword_1D3E75680) + 8) = v199 & (v197 - 1) | v198 & -(int)v197;
    v200 = operator new();
    v246 = 0;
    v245 = &off_1E95AF9B0;
    v201 = v256;
    if (v256)
    {
      v202 = (unsigned int *)(v256 + 8);
      do
        v203 = __ldxr(v202);
      while (__stxr(v203 + 1, v202));
    }
    v247 = v201;
    v204 = operator new();
    sub_1D3D81D4C(&v272, "");
    *(_DWORD *)(v204 + 8) = 0;
    v205 = (unsigned int *)(v204 + 8);
    *(_QWORD *)v204 = off_1E95AF718;
    v206 = (_BYTE *)(v204 + 16);
    if (SHIBYTE(v273) < 0)
    {
      sub_1D3D7FCC0(v206, (void *)v272, *((unint64_t *)&v272 + 1));
    }
    else
    {
      *(_OWORD *)v206 = v272;
      *(_QWORD *)(v204 + 32) = v273;
    }
    do
      v207 = __ldxr(v205);
    while (__stxr(v207 + 1, v205));
    v244 = (unsigned int *)v204;
    sub_1D3D7F3AC((uint64_t)v243, &v274);
    sub_1D3DAFA54(v200, (uint64_t)&v245, (uint64_t *)&v244, v243);
    v208 = (unsigned int *)(v200 + 8);
    do
      v209 = __ldxr(v208);
    while (__stxr(v209 + 1, v208));
    *a1 = v200;
    sub_1D3D7F520((_QWORD *)v243[1]);
    sub_1D3D7F598(&v244);
    if (SHIBYTE(v273) < 0)
      operator delete((void *)v272);
    sub_1D3D7F558(&v245);
    sub_1D3D7F520(v275);
  }
  else
  {
    *a1 = 0;
  }
  sub_1D3D7F558(v255);
  v274 = (unsigned int *)&v260;
  sub_1D3DC7ACC((void ***)&v274);
  sub_1D3D7F558(v263);
  v267 = &off_1E95AF1D0;
  sub_1D3D6D10C(&v271);
  sub_1D3DC778C(&v270);
  return sub_1D3D6D10C(&v269);
}

void sub_1D3DCADC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,unsigned int *a48,char *a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,char a55)
{
  uint64_t v55;

  sub_1D3D82064((_QWORD *)(v55 - 136));
  sub_1D3D7F558(&a42);
  sub_1D3D7F558(&a45);
  sub_1D3DC7A9C(&a48);
  sub_1D3D7F558(&a49);
  a49 = &a55;
  sub_1D3DC7ACC((void ***)&a49);
  sub_1D3D7F558((_QWORD *)(v55 - 240));
  sub_1D3DC77BC(v55 - 200);
  _Unwind_Resume(a1);
}

BOOL sub_1D3DCB08C(uint64_t a1, _QWORD *a2)
{
  return (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2) >= 0.0
      && (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2) < (float)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 16) & (unint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 56) - 1) | *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32) & -*(_QWORD *)(*(_QWORD *)(a1 + 16) + 56))
      && (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2) >= 0.0
      && (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2) < (float)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32) & (unint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 56) - 1) | *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16) & -*(_QWORD *)(*(_QWORD *)(a1 + 16) + 56));
}

uint64_t sub_1D3DCB164(uint64_t a1, unsigned int **a2, unsigned int **a3, float a4)
{
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  BOOL v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _QWORD *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  unsigned int *v43;
  unsigned int *v44;

  v7 = a1;
  v8 = *a2;
  if (*a2)
  {
    v9 = v8 + 2;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v44 = v8;
  if (!sub_1D3DCB08C(a1, &v44))
  {
    sub_1D3D6D834(&v44);
    return 0xFFFFFFFFLL;
  }
  v11 = *a3;
  if (*a3)
  {
    v12 = v11 + 2;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v43 = v11;
  v14 = sub_1D3DCB08C(v7, &v43);
  sub_1D3D6D834(&v43);
  sub_1D3D6D834(&v44);
  if (!v14)
    return 0xFFFFFFFFLL;
  v15 = (int)(*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 16))(*a2);
  v16 = (int)(*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 24))(*a2);
  v17 = (int)(*(float (**)(unsigned int *))(*(_QWORD *)*a3 + 16))(*a3);
  v18 = (int)(*(float (**)(unsigned int *))(*(_QWORD *)*a3 + 24))(*a3);
  if (v18 - v16 >= 0)
    v19 = v18 - v16;
  else
    v19 = v16 - v18;
  if (v17 - v15 >= 0)
    v20 = v17 - v15;
  else
    v20 = v15 - v17;
  if (v19 > v20)
    v21 = v20;
  else
    v21 = v19;
  if (v19 > v20)
    v22 = v19;
  else
    v22 = v20;
  if (v19 > v20)
    v23 = v16;
  else
    v23 = v15;
  if (v19 > v20)
    v24 = v15;
  else
    v24 = v16;
  if (v19 > v20)
    v25 = v18;
  else
    v25 = v17;
  if (v19 > v20)
    v18 = v17;
  v40 = v18;
  if (v24 < v18)
    v26 = 1;
  else
    v26 = -1;
  v39 = v26;
  if (v23 < v25)
    v27 = 1;
  else
    v27 = -1;
  v41 = v27;
  v42 = v21;
  if (v23 == v25)
    return 0;
  v38 = v22;
  v29 = *(_QWORD **)(v7 + 16);
  v30 = sub_1D3D6D4A0(v29, v15, v16);
  v31 = 0;
  LODWORD(v7) = 0;
  v32 = (signed int)-v38 >> 1;
  do
  {
    if (v19 <= v20)
      v33 = v23;
    else
      v33 = v24;
    v34 = v33;
    if (v19 <= v20)
      v35 = v24;
    else
      v35 = v23;
    v36 = sub_1D3D6D4A0(v29, v34, v35);
    v37 = (v30 ^ v36) & (v31 >= (int)(float)(a4 * 0.5));
    v7 = (v7 + v37);
    if (v37)
      v31 = 1;
    else
      ++v31;
    if (v37)
      v30 = v36;
    v32 += v42;
    if (v32 >= 1)
    {
      if (v24 == v40)
        return v7;
      v24 += v39;
      v32 -= v38;
    }
    v23 += v41;
  }
  while (v25 != v23);
  return v7;
}

void sub_1D3DCB3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  unsigned int *v6;
  va_list va;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, unsigned int *);
  sub_1D3D6D834((unsigned int **)va);
  sub_1D3D6D834((unsigned int **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DCB3CC(uint64_t *a1, unsigned int **a2, unsigned int **a3, float a4)
{
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;
  float v21;
  uint64_t result;
  float v23;
  float v24;
  float v25;
  BOOL v26;
  float v27;
  unsigned int *v28;
  unsigned int v29;
  float v30;
  unsigned int *v32;
  unsigned int *v33;

  v7 = *a2;
  if (*a2)
  {
    v8 = v7 + 2;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v33 = v7;
  v10 = *a3;
  if (*a3)
  {
    v11 = v10 + 2;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v32 = v10;
  v30 = (*(float (**)(unsigned int *))(*(_QWORD *)v7 + 16))(v7);
  v13 = (*(float (**)(unsigned int *))(*(_QWORD *)v33 + 24))(v33);
  v14 = (*(float (**)(unsigned int *))(*(_QWORD *)v32 + 16))(v32);
  v15 = (*(float (**)(unsigned int *))(*(_QWORD *)v32 + 24))(v32);
  sub_1D3D6D834(&v32);
  sub_1D3D6D834(&v33);
  v16 = (*(float (**)(unsigned int *))(*(_QWORD *)*a3 + 16))(*a3);
  v17 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 16))(*a2);
  v18 = (*(float (**)(unsigned int *))(*(_QWORD *)*a3 + 24))(*a3);
  v19 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 24))(*a2);
  v20 = operator new();
  v21 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 16))(*a2);
  result = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)*a2 + 24))(*a2);
  v24 = sqrtf((float)((float)(v13 - v15) * (float)(v13 - v15)) + (float)((float)(v30 - v14) * (float)(v30 - v14)));
  v25 = 1.0 / v24;
  v26 = v24 <= 0.00000011921;
  v27 = 0.0;
  if (!v26)
    v27 = v25;
  *(_DWORD *)(v20 + 8) = 0;
  v28 = (unsigned int *)(v20 + 8);
  *(_QWORD *)v20 = &off_1E95AF250;
  *(float *)(v20 + 12) = v21 + (float)((float)(v27 * (float)(v16 - v17)) * a4);
  *(float *)(v20 + 16) = v23 + (float)((float)(v27 * (float)(v18 - v19)) * a4);
  do
    v29 = __ldxr(v28);
  while (__stxr(v29 + 1, v28));
  *a1 = v20;
  return result;
}

void sub_1D3DCB5C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D8254C54](v1, 0x1081C40A085CBA5);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DCB604(uint64_t *a1, unsigned int **a2, unsigned int **a3, unsigned int **a4, float a5)
{
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int v15;
  float v16;
  float v17;
  float v18;
  float v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  uint64_t v33;
  float v34;
  uint64_t result;
  float v36;
  float v37;
  float v38;
  BOOL v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  unsigned int *v46;
  unsigned int v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  unsigned int *v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int *v61;

  v10 = *a2;
  if (*a2)
  {
    v11 = v10 + 2;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v61 = v10;
  v13 = *a3;
  if (*a3)
  {
    v14 = v13 + 2;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  v60 = v13;
  v16 = (*(float (**)(unsigned int *))(*(_QWORD *)v10 + 16))(v10);
  v17 = (*(float (**)(unsigned int *))(*(_QWORD *)v61 + 24))(v61);
  v18 = (*(float (**)(unsigned int *))(*(_QWORD *)v60 + 16))(v60);
  v19 = (*(float (**)(unsigned int *))(*(_QWORD *)v60 + 24))(v60);
  sub_1D3D6D834(&v60);
  sub_1D3D6D834(&v61);
  v20 = *a2;
  if (*a2)
  {
    v21 = v20 + 2;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  v59 = v20;
  v23 = *a4;
  if (*a4)
  {
    v24 = v23 + 2;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  v53 = v19;
  v54 = v18;
  v55 = v17;
  v56 = v16;
  v57 = a5;
  v58 = v23;
  v52 = (*(float (**)(unsigned int *))(*(_QWORD *)v20 + 16))(v20);
  v51 = (*(float (**)(unsigned int *))(*(_QWORD *)v59 + 24))(v59);
  v50 = (*(float (**)(unsigned int *))(*(_QWORD *)v58 + 16))(v58);
  v49 = (*(float (**)(unsigned int *))(*(_QWORD *)v58 + 24))(v58);
  sub_1D3D6D834(&v58);
  sub_1D3D6D834(&v59);
  v48 = (*(float (**)(unsigned int *))(*(_QWORD *)*a3 + 16))(*a3);
  v26 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 16))(*a2);
  v27 = (*(float (**)(unsigned int *))(*(_QWORD *)*a4 + 16))(*a4);
  v28 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 16))(*a2);
  v29 = (*(float (**)(unsigned int *))(*(_QWORD *)*a3 + 24))(*a3);
  v30 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 24))(*a2);
  v31 = (*(float (**)(unsigned int *))(*(_QWORD *)*a4 + 24))(*a4);
  v32 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 24))(*a2);
  v33 = operator new();
  v34 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 16))(*a2);
  result = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)*a2 + 24))(*a2);
  v37 = sqrtf((float)((float)(v55 - v53) * (float)(v55 - v53)) + (float)((float)(v56 - v54) * (float)(v56 - v54)));
  v38 = 1.0 / v37;
  v39 = v37 <= 0.00000011921;
  v40 = 0.0;
  if (v39)
    v38 = 0.0;
  v41 = sqrtf((float)((float)(v51 - v49) * (float)(v51 - v49)) + (float)((float)(v52 - v50) * (float)(v52 - v50)));
  if (v41 <= 0.00000011921)
    v42 = 0.0;
  else
    v42 = 1.0 / v41;
  v43 = (float)(v42 * (float)(v31 - v32)) + (float)((float)(v29 - v30) * v38);
  v44 = (float)(v42 * (float)(v27 - v28)) + (float)((float)(v48 - v26) * v38);
  v45 = sqrtf((float)(v43 * v43) + (float)(v44 * v44));
  if (v45 > 0.00000011921)
    v40 = 1.0 / v45;
  *(_DWORD *)(v33 + 8) = 0;
  v46 = (unsigned int *)(v33 + 8);
  *(_QWORD *)v33 = &off_1E95AF250;
  *(float *)(v33 + 12) = v34 + (float)((float)(v44 * v40) * v57);
  *(float *)(v33 + 16) = v36 + (float)((float)(v43 * v40) * v57);
  do
    v47 = __ldxr(v46);
  while (__stxr(v47 + 1, v46));
  *a1 = v33;
  return result;
}

void sub_1D3DCB964(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D8254C54](v1, 0x1081C40A085CBA5);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DCB9B4(_OWORD *a1, uint64_t a2, float a3)
{
  uint64_t v5;
  float v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int **result;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int *v25;
  unsigned int *v26;

  v5 = 0;
  *a1 = 0u;
  a1[1] = 0u;
  v6 = a3 * 1.41421356;
  do
  {
    if (v5)
      v7 = (int)v5 - 1;
    else
      v7 = 3;
    if (v5 == 3)
      v8 = 0;
    else
      v8 = v5 + 1;
    v9 = *(unsigned int **)(a2 + 8 * v5);
    if (v9)
    {
      v10 = v9 + 2;
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    v25 = v9;
    v12 = *(unsigned int **)(a2 + 8 * v7);
    if (v12)
    {
      v13 = v12 + 2;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v24 = v12;
    v15 = *(unsigned int **)(a2 + 8 * v8);
    if (v15)
    {
      v16 = v15 + 2;
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
    v23 = v15;
    sub_1D3DCB604((uint64_t *)&v26, &v25, &v24, &v23, v6);
    v18 = v26;
    if (v26)
    {
      v19 = v26 + 2;
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    v21 = (unsigned int *)*((_QWORD *)a1 + v5);
    if (v21)
      sub_1D3D6D13C(v21);
    *((_QWORD *)a1 + v5) = v18;
    sub_1D3D6D834(&v26);
    sub_1D3D6D834(&v23);
    sub_1D3D6D834(&v24);
    result = sub_1D3D6D834(&v25);
    ++v5;
  }
  while (v5 != 4);
  return result;
}

void sub_1D3DCBB04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, unsigned int *a10, unsigned int *a11, unsigned int *a12)
{
  uint64_t v12;
  uint64_t i;

  sub_1D3D6D834(&a12);
  sub_1D3D6D834(&a9);
  sub_1D3D6D834(&a10);
  sub_1D3D6D834(&a11);
  for (i = 24; i != -8; i -= 8)
    sub_1D3D6D834((unsigned int **)(v12 + i));
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DCBB50(unsigned int **a1, unsigned int **a2, unsigned int **a3)
{
  unsigned int **v4;
  unsigned int **v6;
  unsigned int **result;
  unsigned int **v8;

  v4 = a2;
  v6 = a2;
  while (1)
  {
    result = sub_1D3DCBBEC(a1++, v4);
    if (++v4 == a3)
      break;
    if (a1 == v6)
      v6 = v4;
  }
  if (a1 != v6)
  {
    v8 = v6;
    do
    {
      while (1)
      {
        result = sub_1D3DCBBEC(a1++, v6);
        if (++v6 == a3)
          break;
        if (a1 == v8)
          v8 = v6;
      }
      v6 = v8;
    }
    while (a1 != v8);
  }
  return result;
}

unsigned int **sub_1D3DCBBEC(unsigned int **a1, unsigned int **a2)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v14;

  v4 = *a1;
  if (*a1)
  {
    v5 = v4 + 2;
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v14 = v4;
  v7 = *a2;
  if (*a2)
  {
    v8 = v7 + 2;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = *a1;
  if (*a1)
  {
    sub_1D3D6D13C(v10);
    v4 = v14;
  }
  *a1 = v7;
  if (v4)
  {
    v11 = v4 + 2;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  if (*a2)
    sub_1D3D6D13C(*a2);
  *a2 = v4;
  return sub_1D3D6D834(&v14);
}

void sub_1D3DCBC9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D6D834((unsigned int **)va);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DCBCB0(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned __int8 v16;
  _DWORD *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int *v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  char v35;
  char v36;
  char v37;
  char v38;
  _BOOL4 v39;
  char v40;
  _BOOL4 v41;
  int v42;
  _BOOL4 v43;
  int v44;
  int v45;
  uint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  char v49;
  uint64_t v50;
  unsigned int *v51;
  unsigned int v52;
  uint64_t ii;
  int v55;
  unsigned int *v56;
  unsigned int *v57;
  unsigned int v58;
  char v59;
  int v60;
  int v61;
  unsigned int *v62;
  unsigned int *v63;
  unsigned int v64;
  int v65;
  unsigned int *v66;
  unsigned int *v67;
  unsigned int v68;
  unsigned int *v69;
  unsigned int *v70;
  unsigned int *v71;
  unsigned int v72;
  unsigned int *v73;
  unsigned int *v74;
  unsigned int v75;
  unsigned int *v76;
  unsigned int v77;
  unsigned int *v78;
  unsigned int *v79;
  unsigned int v80;
  uint64_t i;
  unint64_t v82;
  unsigned int *v83;
  unsigned int *v84;
  unsigned int v85;
  int v86;
  uint64_t v87;
  unsigned int *v88;
  unsigned int v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  unsigned int **v104;
  uint64_t j;
  unsigned int **v106;
  unsigned int *v107;
  unsigned int *v108;
  unsigned int v109;
  unsigned int *v110;
  unsigned int *v111;
  unsigned int v112;
  int v113;
  unsigned int *v114;
  unsigned int *v115;
  unsigned int v116;
  unsigned int *v117;
  unsigned int *v118;
  unsigned int v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  uint64_t v125;
  int v126;
  int v127;
  unsigned int v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int *v134;
  unsigned int *v135;
  unsigned int v136;
  int v137;
  uint64_t v138;
  unsigned int v139;
  int v140;
  int v141;
  int v142;
  unsigned int *v143;
  unsigned int *v144;
  unsigned int v145;
  signed int v146;
  unsigned int *v147;
  unsigned int *v148;
  unsigned int v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float v154;
  uint64_t k;
  uint64_t v156;
  unsigned int *v157;
  unsigned int v158;
  unsigned int *v159;
  uint64_t m;
  int v161;
  int v162;
  uint64_t v163;
  int v164;
  uint64_t v165;
  unsigned int *v166;
  unsigned int v167;
  unsigned int *v168;
  unsigned int *v169;
  unsigned int v170;
  unsigned int v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int *v175;
  unsigned int *v176;
  unsigned int v177;
  unsigned int *v178;
  unsigned int *v179;
  unsigned int v180;
  unsigned int v181;
  unsigned int v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int *v185;
  unsigned int v186;
  unsigned int *v187;
  unsigned int *v188;
  unsigned int v189;
  int v190;
  unsigned int *v191;
  unsigned int *v192;
  unsigned int v193;
  unsigned int *v194;
  unsigned int *v195;
  unsigned int v196;
  int v197;
  int v198;
  unsigned int v199;
  unsigned int *v200;
  unsigned int *v201;
  unsigned int v202;
  unsigned int *v203;
  unsigned int *v204;
  unsigned int v205;
  unsigned int *v206;
  unsigned int *v207;
  unsigned int v208;
  unsigned int *v209;
  unsigned int *v210;
  unsigned int v211;
  float v212;
  float v213;
  uint64_t v214;
  float v215;
  float v216;
  float v217;
  float v218;
  float v219;
  float v220;
  float v221;
  unsigned int *v222;
  unsigned int v223;
  uint64_t v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  float v230;
  unsigned int *v231;
  unsigned int v232;
  unsigned int *v233;
  unsigned int *v234;
  unsigned int v235;
  unsigned int *v236;
  unsigned int *v237;
  unsigned int v238;
  unsigned int *v239;
  unsigned int *v240;
  unsigned int v241;
  unsigned int *v242;
  unsigned int *v243;
  unsigned int v244;
  unsigned int *v245;
  unsigned int *v246;
  unsigned int v247;
  BOOL v248;
  unsigned int *v249;
  unsigned int *v250;
  unsigned int v251;
  BOOL v252;
  unsigned int *v253;
  unsigned int *v254;
  unsigned int v255;
  unsigned int *v256;
  unsigned int *v257;
  unsigned int v258;
  int v259;
  unsigned int *v260;
  unsigned int *v261;
  unsigned int v262;
  unsigned int *v263;
  unsigned int *v264;
  unsigned int v265;
  int v266;
  int v267;
  int v268;
  int v269;
  unsigned int *v270;
  unsigned int *v271;
  unsigned int v272;
  unsigned int *v273;
  unsigned int *v274;
  unsigned int v275;
  int v276;
  unsigned int *v277;
  unsigned int *v278;
  unsigned int v279;
  unsigned int *v280;
  unsigned int *v281;
  unsigned int v282;
  int v283;
  int v284;
  int v285;
  int v286;
  unsigned int **v287;
  unsigned int *v288;
  unsigned int *v289;
  unsigned int v290;
  unsigned int *v291;
  int v292;
  int v293;
  _BOOL4 v294;
  uint64_t n;
  float v296;
  float v297;
  float v298;
  float v299;
  float v300;
  float v301;
  float v302;
  float v303;
  unsigned int *v304;
  unsigned int *v305;
  unsigned int v306;
  unsigned int *v307;
  unsigned int *v308;
  unsigned int v309;
  unsigned int *v310;
  unsigned int v311;
  unsigned int *v312;
  unsigned int v313;
  unsigned int *v314;
  unsigned int v315;
  unsigned int *v316;
  unsigned int *v317;
  unsigned int v318;
  unsigned int *v319;
  unsigned int *v320;
  unsigned int v321;
  unsigned int *v322;
  unsigned int *v323;
  unsigned int v324;
  uint64_t v325;
  unsigned int *v326;
  unsigned int *v327;
  unsigned int v328;
  unsigned int *v329;
  unsigned int v330;
  unsigned int *v331;
  unsigned int *v332;
  unsigned int v333;
  unsigned int v334;
  unsigned int *v335;
  unsigned int *v336;
  float v337;
  unsigned int *v338;
  unsigned int v339;
  BOOL v340;
  unsigned int *v341;
  unsigned int v342;
  unsigned int *v343;
  unsigned int v344;
  unsigned int *v345;
  unsigned int v346;
  unsigned int *v347;
  unsigned int *v348;
  unsigned int v349;
  unsigned int *v350;
  unsigned int *v351;
  unsigned int v352;
  unsigned int *v353;
  unsigned int *v354;
  unsigned int v355;
  unsigned int *v356;
  unsigned int *v357;
  unsigned int v358;
  float v359;
  float v360;
  float v361;
  float v362;
  unsigned int *v363;
  unsigned int *v364;
  unsigned int v365;
  unsigned int *v366;
  unsigned int *v367;
  unsigned int v368;
  unsigned int *v369;
  unsigned int *v370;
  unsigned int v371;
  unsigned int *v372;
  unsigned int *v373;
  unsigned int v374;
  unsigned int *v375;
  unsigned int *v376;
  unsigned int v377;
  int v378;
  int v379;
  int v380;
  int v381;
  int v382;
  int v383;
  BOOL v384;
  int v385;
  int v386;
  float v388;
  float v389;
  float v390;
  float v391;
  float v392;
  float v393;
  float v394;
  uint64_t v395;
  unsigned int **v397[3];
  unsigned int *v398;
  unsigned int *v399;
  unsigned int **v400[3];
  unsigned int *v401;
  unsigned int *v402;
  unsigned int *v403;
  unsigned int *v404;
  unsigned int *v405;
  unsigned int *v406;
  unsigned int *v407;
  unsigned int **v408;
  unsigned int **v409;
  unint64_t v410;
  __int128 v411;
  __int128 v412;
  unsigned int *v413;
  unsigned int *v414;
  unsigned int *v415;
  unsigned int *v416;
  unsigned int *v417;
  unsigned int *v418;
  unsigned int *v419;
  _OWORD v420[2];
  __int128 v421;
  unsigned int *v422;
  unsigned int *v423;
  unsigned int *v424;
  unsigned int *v425;
  unsigned int *v426;
  unsigned int *v427;
  unsigned int *v428;
  unsigned int *v429;
  unsigned int *v430;
  unsigned int *v431;
  unsigned int *v432;
  unsigned int *v433;
  unsigned int *v434;
  unsigned int *v435;
  unsigned int *v436;
  unsigned int *v437;
  unsigned int *v438;
  unsigned int *v439;
  unsigned int *v440;
  unsigned int *v441;
  unsigned int *v442;
  unsigned int *v443;
  unsigned int *v444;
  unsigned int *v445;
  unsigned int *v446;
  unsigned int *v447;
  unsigned int *v448;
  unsigned int *v449;
  unsigned int *v450;
  unsigned int *v451;
  unsigned int *v452;
  unsigned int *v453;
  unsigned int *v454;
  unsigned int *v455;
  unsigned int *v456;
  unsigned int *v457;
  unsigned int *v458;
  unsigned int *v459[2];

  v5 = operator new();
  v6 = *(unsigned int **)(a2 + 16);
  v7 = v6 + 2;
  do
    v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
  v414 = v6;
  *(_DWORD *)(v5 + 8) = 0;
  v9 = (unsigned int *)(v5 + 8);
  *(_QWORD *)v5 = &off_1E95AF3B0;
  *(_QWORD *)(v5 + 16) = 0;
  do
    v10 = __ldxr(v7);
  while (__stxr(v10 + 1, v7));
  *(_QWORD *)(v5 + 16) = v6;
  v11 = v6[14];
  v12 = -v11;
  v13 = v6[8];
  --v11;
  v14 = v6[4];
  *(_DWORD *)(v5 + 24) = v14 & v11 | v13 & v12;
  *(_DWORD *)(v5 + 28) = v13 & v11 | v14 & v12;
  do
    v15 = __ldxr(v9);
  while (__stxr(v15 + 1, v9));
  v415 = (unsigned int *)v5;
  sub_1D3D6D10C(&v414);
  v411 = 0u;
  v412 = 0u;
  v408 = 0;
  v409 = 0;
  v410 = 0;
  v406 = 0;
  v407 = 0;
  v405 = 0;
  v16 = atomic_load((unsigned __int8 *)&qword_1EFE317D0);
  if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_1EFE317D0))
  {
    v337 = 0.06;
    if (a3)
      v337 = 0.5;
    dword_1EFE317C8 = LODWORD(v337);
    __cxa_guard_release(&qword_1EFE317D0);
  }
  v395 = a2;
  v17 = *(_DWORD **)(a2 + 16);
  v18 = v17[14];
  v19 = -v18;
  v20 = v17[4];
  v21 = v20 & -v18--;
  LODWORD(v17) = v17[8];
  v22 = v17 & v18 | v21;
  v23 = v20 & v18 | v17 & v19;
  if (v23 >= 0)
    v24 = v23;
  else
    v24 = v23 + 1;
  if (v22 >= 0)
    v25 = v22;
  else
    v25 = v22 + 1;
  if (v22 < v23)
    v23 = v22;
  v26 = (int)(float)(*(float *)&dword_1EFE317C8 * (float)v23);
  if ((int)v26 <= 10)
    v26 = 10;
  v27 = v415;
  *((_BYTE *)v415 + 32) = 0;
  LODWORD(v28) = (v25 >> 1) - (v26 >> 1);
  if ((int)v28 >= 0)
  {
    v29 = (v24 >> 1) - (v26 >> 1);
    if ((v29 & 0x80000000) == 0)
    {
      v30 = v26 >> 1;
      v31 = v30 + (v25 >> 1);
      v32 = v27[7];
      if (v31 < v32)
      {
        v33 = v30 + (v24 >> 1);
        v34 = v27[6];
        if (v33 < v34)
        {
          v35 = 0;
          while (2)
          {
            v36 = 0;
            v37 = v35;
            do
            {
              if (v33 >= v34)
                goto LABEL_52;
              v38 = v36;
              v39 = sub_1D3DB0364((uint64_t)v27, v28, v31, v33++, 0);
              v36 = 1;
            }
            while (v39);
            v33 = v39 + v33 - 1;
            if (v33 < v34)
            {
              do
              {
                if (v31 >= v32)
                  goto LABEL_52;
                v40 = v38;
                v38 = 1;
                v41 = sub_1D3DB0364((uint64_t)v27, v29, v33, v31++, 1);
              }
              while (v41);
              v31 = v41 + v31 - 1;
              if (v31 >= v32 || v29 < 0)
                break;
              do
              {
                v42 = sub_1D3DB0364((uint64_t)v27, v28, v31, v29, 0);
                v29 -= v42;
                if (!v42)
                  break;
                v40 = 1;
              }
              while ((v29 & 0x80000000) == 0);
              if (((v29 | v28) & 0x80000000) != 0)
                break;
              do
              {
                v43 = sub_1D3DB0364((uint64_t)v27, v29, v33, v28, 1);
                v28 = (v28 - v43);
                if (!v43)
                  break;
                v40 = 1;
              }
              while ((v28 & 0x80000000) == 0);
              if ((v28 & 0x80000000) != 0)
                break;
              v35 = 1;
              if ((v40 & 1) != 0)
                continue;
              if ((v37 & 1) == 0)
                break;
              if (v31 - (int)v28 >= v33 - v29)
                v44 = v33 - v29;
              else
                v44 = v31 - v28;
              *(_QWORD *)&v420[0] = 0;
              if (v44 < 2)
              {
LABEL_51:
                sub_1D3D6D834((unsigned int **)v420);
                break;
              }
              v45 = 1;
              while (1)
              {
                sub_1D3DB045C((uint64_t *)&v421, (uint64_t)v27, (float)v29, (float)(v31 - v45), (float)(v45 + v29), (float)v31);
                v46 = v421;
                if ((_QWORD)v421)
                {
                  v47 = (unsigned int *)(v421 + 8);
                  do
                    v48 = __ldxr(v47);
                  while (__stxr(v48 + 1, v47));
                }
                if (*(_QWORD *)&v420[0])
                  sub_1D3D6D13C(*(unsigned int **)&v420[0]);
                *(_QWORD *)&v420[0] = v46;
                sub_1D3D6D834((unsigned int **)&v421);
                if (*(_QWORD *)&v420[0])
                  break;
                if (++v45 == v44)
                  goto LABEL_51;
              }
              v459[0] = 0;
              v55 = 1;
              while (1)
              {
                sub_1D3DB045C((uint64_t *)&v421, (uint64_t)v27, (float)(v55 + v29), (float)(int)v28, (float)v29, (float)(v55 + v28));
                v56 = (unsigned int *)v421;
                if ((_QWORD)v421)
                {
                  v57 = (unsigned int *)(v421 + 8);
                  do
                    v58 = __ldxr(v57);
                  while (__stxr(v58 + 1, v57));
                }
                if (v459[0])
                  sub_1D3D6D13C(v459[0]);
                v459[0] = v56;
                sub_1D3D6D834((unsigned int **)&v421);
                if (v459[0])
                  break;
                if (++v55 == v44)
                {
                  v59 = 0;
                  v60 = 0;
                  goto LABEL_105;
                }
              }
              v458 = 0;
              v61 = 1;
              while (1)
              {
                sub_1D3DB045C((uint64_t *)&v421, (uint64_t)v27, (float)v33, (float)(v61 + v28), (float)(v33 - v61), (float)(int)v28);
                v62 = (unsigned int *)v421;
                if ((_QWORD)v421)
                {
                  v63 = (unsigned int *)(v421 + 8);
                  do
                    v64 = __ldxr(v63);
                  while (__stxr(v64 + 1, v63));
                }
                if (v458)
                  sub_1D3D6D13C(v458);
                v458 = v62;
                sub_1D3D6D834((unsigned int **)&v421);
                if (v458)
                  break;
                if (++v61 == v44)
                {
                  v59 = 0;
                  v60 = 0;
                  goto LABEL_104;
                }
              }
              v457 = 0;
              v65 = 1;
              while (1)
              {
                sub_1D3DB045C((uint64_t *)&v421, (uint64_t)v27, (float)(v33 - v65), (float)v31, (float)v33, (float)(v31 - v65));
                v66 = (unsigned int *)v421;
                if ((_QWORD)v421)
                {
                  v67 = (unsigned int *)(v421 + 8);
                  do
                    v68 = __ldxr(v67);
                  while (__stxr(v68 + 1, v67));
                }
                if (v457)
                  sub_1D3D6D13C(v457);
                v457 = v66;
                sub_1D3D6D834((unsigned int **)&v421);
                v69 = v457;
                if (v457)
                  break;
                if (++v65 == v44)
                {
                  v60 = 0;
                  v59 = 0;
                  goto LABEL_103;
                }
              }
              v60 = 1;
              if (sub_1D3D6D4A0(*((_QWORD **)v27 + 2), v29, v28))
                v59 = 2;
              else
                v59 = 1;
              v70 = v459[0];
              if (v459[0])
              {
                v71 = v459[0] + 2;
                do
                  v72 = __ldxr(v71);
                while (__stxr(v72 + 1, v71));
              }
              v456 = v70;
              v73 = *(unsigned int **)&v420[0];
              if (*(_QWORD *)&v420[0])
              {
                v74 = (unsigned int *)(*(_QWORD *)&v420[0] + 8);
                do
                  v75 = __ldxr(v74);
                while (__stxr(v75 + 1, v74));
              }
              v455 = v73;
              v76 = v69 + 2;
              do
                v77 = __ldxr(v76);
              while (__stxr(v77 + 1, v76));
              v454 = v69;
              v78 = v458;
              if (v458)
              {
                v79 = v458 + 2;
                do
                  v80 = __ldxr(v79);
                while (__stxr(v80 + 1, v79));
              }
              v453 = v78;
              sub_1D3DB05C8((uint64_t *)&v421, &v456, &v455, &v454, &v453);
              sub_1D3DB089C((uint64_t)&v411, (uint64_t)&v421);
              for (i = 24; i != -8; i -= 8)
                sub_1D3D6D834((unsigned int **)((char *)&v421 + i));
              sub_1D3D6D834(&v453);
              sub_1D3D6D834(&v454);
              sub_1D3D6D834(&v455);
              sub_1D3D6D834(&v456);
LABEL_103:
              sub_1D3D6D834(&v457);
LABEL_104:
              sub_1D3D6D834(&v458);
LABEL_105:
              sub_1D3D6D834(v459);
              sub_1D3D6D834((unsigned int **)v420);
              if (!v60)
                break;
              v82 = 0;
              while (v82 != 4)
              {
                v83 = (unsigned int *)*((_QWORD *)&v411 + v82);
                if (v83)
                {
                  v84 = v83 + 2;
                  do
                    v85 = __ldxr(v84);
                  while (__stxr(v85 + 1, v84));
                }
                *(_QWORD *)&v421 = v83;
                v86 = v82 - 3;
                if (v82 <= 2)
                  v86 = v82 + 1;
                v87 = *((_QWORD *)&v411 + v86);
                if (v87)
                {
                  v88 = (unsigned int *)(v87 + 8);
                  do
                    v89 = __ldxr(v88);
                  while (__stxr(v89 + 1, v88));
                }
                *(_QWORD *)&v420[0] = v87;
                v90 = (*(float (**)(unsigned int *))(*(_QWORD *)v83 + 16))(v83);
                v91 = (*(float (**)(_QWORD))(*(_QWORD *)v421 + 24))(v421);
                v92 = (*(float (**)(_QWORD))(**(_QWORD **)&v420[0] + 16))(*(_QWORD *)&v420[0]);
                v93 = (*(float (**)(_QWORD))(**(_QWORD **)&v420[0] + 24))(*(_QWORD *)&v420[0]);
                ++v82;
                v94 = sqrtf((float)((float)(v91 - v93) * (float)(v91 - v93))+ (float)((float)(v90 - v92) * (float)(v90 - v92)));
                sub_1D3D6D834((unsigned int **)v420);
                sub_1D3D6D834((unsigned int **)&v421);
                if (v94 < 8.0)
                  goto LABEL_52;
              }
              v95 = 0;
              v96 = 0xFFFFFFFF00000000;
              while (v95 != 4)
              {
                if (v95)
                  v97 = v96 >> 32;
                else
                  v97 = 3;
                if (v95 == 3)
                  v98 = 0;
                else
                  v98 = v95 + 1;
                v99 = (*(float (**)(_QWORD))(**((_QWORD **)&v411 + v95) + 16))(*((_QWORD *)&v411 + v95));
                v100 = (*(float (**)(_QWORD))(**((_QWORD **)&v411 + v95) + 24))(*((_QWORD *)&v411 + v95));
                v101 = (*(float (**)(_QWORD))(**((_QWORD **)&v411 + v97) + 16))(*((_QWORD *)&v411 + v97));
                v102 = (*(float (**)(_QWORD))(**((_QWORD **)&v411 + v97) + 24))(*((_QWORD *)&v411 + v97));
                v103 = (*(float (**)(_QWORD))(**((_QWORD **)&v411 + v98) + 16))(*((_QWORD *)&v411 + v98));
                v96 += 0x100000000;
                ++v95;
                if ((float)((float)((float)((float)(v101 - v99)
                                           * (float)((*(float (**)(_QWORD))(**((_QWORD **)&v411 + v98) + 24))(*((_QWORD *)&v411 + v98))
                                                   - v100))
                                   - (float)((float)(v103 - v99) * (float)(v102 - v100)))
                           * 0.5) < 8.0)
                  goto LABEL_52;
              }
              v104 = v408;
              if (v408 == v409)
              {
                for (j = 0; j != 32; j += 8)
                {
                  v106 = (unsigned int **)((char *)&v411 + j);
                  if ((unint64_t)v104 >= v410)
                  {
                    v104 = (unsigned int **)sub_1D3D8D0B0((uint64_t)&v408, v106);
                  }
                  else
                  {
                    sub_1D3D8D1BC((unsigned int *)&v408, v106);
                    ++v104;
                  }
                  v409 = v104;
                }
              }
              v107 = (unsigned int *)v411;
              if ((_QWORD)v411)
              {
                v108 = (unsigned int *)(v411 + 8);
                do
                  v109 = __ldxr(v108);
                while (__stxr(v109 + 1, v108));
              }
              v427 = v107;
              v110 = (unsigned int *)v412;
              if ((_QWORD)v412)
              {
                v111 = (unsigned int *)(v412 + 8);
                do
                  v112 = __ldxr(v111);
                while (__stxr(v112 + 1, v111));
              }
              v426 = v110;
              v113 = sub_1D3DCB164(v395, &v427, &v426, 1.0);
              sub_1D3D6D834(&v426);
              sub_1D3D6D834(&v427);
              if (v113 < 0)
                break;
              v114 = (unsigned int *)v411;
              if ((_QWORD)v411)
              {
                v115 = (unsigned int *)(v411 + 8);
                do
                  v116 = __ldxr(v115);
                while (__stxr(v116 + 1, v115));
              }
              v425 = v114;
              v117 = (unsigned int *)v412;
              if ((_QWORD)v412)
              {
                v118 = (unsigned int *)(v412 + 8);
                do
                  v119 = __ldxr(v118);
                while (__stxr(v119 + 1, v118));
              }
              v424 = v117;
              v120 = (*(float (**)(unsigned int *))(*(_QWORD *)v114 + 16))(v114);
              v121 = (*(float (**)(unsigned int *))(*(_QWORD *)v425 + 24))(v425);
              v122 = (*(float (**)(unsigned int *))(*(_QWORD *)v424 + 16))(v424);
              v123 = (*(float (**)(unsigned int *))(*(_QWORD *)v424 + 24))(v424);
              v124 = (float)(sqrtf((float)((float)(v121 - v123) * (float)(v121 - v123))+ (float)((float)(v120 - v122) * (float)(v120 - v122)))* 0.3)/ (float)((float)v113 + 1.0);
              sub_1D3D6D834(&v424);
              sub_1D3D6D834(&v425);
              sub_1D3DCB9B4(&v421, (uint64_t)&v411, v124 * 0.25);
              v125 = 0;
              v126 = 0;
              v127 = 0x7FFFFFFF;
              v128 = -1;
              v129 = -1;
              do
              {
                if (v125 == 3)
                  v130 = 0;
                else
                  v130 = v125 + 1;
                v131 = *((_QWORD *)&v421 + v125);
                if (v131)
                {
                  v132 = (unsigned int *)(v131 + 8);
                  do
                    v133 = __ldxr(v132);
                  while (__stxr(v133 + 1, v132));
                }
                *(_QWORD *)&v420[0] = v131;
                v134 = (unsigned int *)*((_QWORD *)&v421 + v130);
                if (v134)
                {
                  v135 = v134 + 2;
                  do
                    v136 = __ldxr(v135);
                  while (__stxr(v136 + 1, v135));
                }
                v459[0] = v134;
                v137 = sub_1D3DCB164(v395, (unsigned int **)v420, v459, v124);
                v138 = v125 + 1;
                sub_1D3D6D834(v459);
                sub_1D3D6D834((unsigned int **)v420);
                if (v137 <= v126)
                  v139 = v128;
                else
                  v139 = v125;
                if (v137 <= v126)
                  v140 = v126;
                else
                  v140 = v137;
                if (v137 >= v127)
                  v141 = v127;
                else
                  v141 = v137;
                if (v137 >= v127)
                  v142 = v129;
                else
                  v142 = v125;
                if (v137 >= 0)
                {
                  v127 = v141;
                  v129 = v142;
                  v128 = v139;
                  v126 = v140;
                }
                ++v125;
              }
              while (v138 != 4);
              if (v129 < 0 || (v128 & 0x80000000) != 0 || v127 > (int)(v126 >> 1))
                goto LABEL_322;
              v143 = (unsigned int *)*((_QWORD *)&v421 + v128);
              if (v143)
              {
                v144 = v143 + 2;
                do
                  v145 = __ldxr(v144);
                while (__stxr(v145 + 1, v144));
              }
              v458 = v143;
              v146 = v128 - 3;
              if (v128 <= 2)
                v146 = v128 + 1;
              v147 = (unsigned int *)*((_QWORD *)&v421 + v146);
              if (v147)
              {
                v148 = v147 + 2;
                do
                  v149 = __ldxr(v148);
                while (__stxr(v149 + 1, v148));
              }
              v457 = v147;
              v150 = (*(float (**)(unsigned int *))(*(_QWORD *)v143 + 16))(v143);
              v151 = (*(float (**)(unsigned int *))(*(_QWORD *)v458 + 24))(v458);
              v152 = (*(float (**)(unsigned int *))(*(_QWORD *)v457 + 16))(v457);
              v153 = (*(float (**)(unsigned int *))(*(_QWORD *)v457 + 24))(v457);
              v154 = sqrtf((float)((float)(v151 - v153) * (float)(v151 - v153))+ (float)((float)(v150 - v152) * (float)(v150 - v152)))/ (float)(v126 + 1);
              sub_1D3D6D834(&v457);
              sub_1D3D6D834(&v458);
              sub_1D3DCB9B4(v420, (uint64_t)&v411, v154 * 0.25);
              for (k = 0; k != 4; *((_QWORD *)&v421 + k++) = v156)
              {
                v156 = *((_QWORD *)v420 + k);
                if (v156)
                {
                  v157 = (unsigned int *)(v156 + 8);
                  do
                    v158 = __ldxr(v157);
                  while (__stxr(v158 + 1, v157));
                }
                v159 = (unsigned int *)*((_QWORD *)&v421 + k);
                if (v159)
                  sub_1D3D6D13C(v159);
              }
              for (m = 24; m != -8; m -= 8)
                sub_1D3D6D834((unsigned int **)((char *)v420 + m));
              if (v129 <= 4)
                v161 = -1;
              else
                v161 = -5;
              if (v129 < 1)
                v161 = 3;
              if (v129 <= 2)
                v162 = v129 + 1;
              else
                v162 = v129 - 3;
              v163 = v161 + v129;
              if (v129 < 2)
                v164 = 2;
              else
                v164 = -2;
              v165 = *((_QWORD *)&v421 + v129);
              if (v165)
              {
                v166 = (unsigned int *)(v165 + 8);
                do
                  v167 = __ldxr(v166);
                while (__stxr(v167 + 1, v166));
              }
              *(_QWORD *)&v420[0] = v165;
              v168 = (unsigned int *)*((_QWORD *)&v421 + v163);
              if (v168)
              {
                v169 = v168 + 2;
                do
                  v170 = __ldxr(v169);
                while (__stxr(v170 + 1, v169));
              }
              v459[0] = v168;
              v171 = sub_1D3DCB164(v395, (unsigned int **)v420, v459, v154);
              v172 = v164 + v129;
              v173 = v162;
              v174 = v172;
              sub_1D3D6D834(v459);
              sub_1D3D6D834((unsigned int **)v420);
              v175 = (unsigned int *)*((_QWORD *)&v421 + v173);
              if (v175)
              {
                v176 = v175 + 2;
                do
                  v177 = __ldxr(v176);
                while (__stxr(v177 + 1, v176));
              }
              v458 = v175;
              v178 = (unsigned int *)*((_QWORD *)&v421 + v174);
              if (v178)
              {
                v179 = v178 + 2;
                do
                  v180 = __ldxr(v179);
                while (__stxr(v180 + 1, v179));
              }
              v457 = v178;
              v181 = sub_1D3DCB164(v395, &v458, &v457, v154);
              sub_1D3D6D834(&v457);
              sub_1D3D6D834(&v458);
              v182 = v171 >= v181 ? v129 : v163;
              v183 = ((v171 | v181) & 0x80000000) != 0 ? 0xFFFFFFFFLL : v182;
              if ((v183 & 0x80000000) != 0)
                goto LABEL_322;
              if ((v183 & 0xFFFFFFFB) != 0)
              {
                sub_1D3DCBB50((unsigned int **)&v411, (unsigned int **)&v411 + v183, &v413);
                sub_1D3DCBB50((unsigned int **)&v421, (unsigned int **)&v421 + v183, &v424);
              }
              v184 = v421;
              if ((_QWORD)v421)
              {
                v185 = (unsigned int *)(v421 + 8);
                do
                  v186 = __ldxr(v185);
                while (__stxr(v186 + 1, v185));
              }
              *(_QWORD *)&v420[0] = v184;
              v187 = v423;
              if (v423)
              {
                v188 = v423 + 2;
                do
                  v189 = __ldxr(v188);
                while (__stxr(v189 + 1, v188));
              }
              v459[0] = v187;
              v190 = sub_1D3DCB164(v395, (unsigned int **)v420, v459, v154);
              sub_1D3D6D834(v459);
              sub_1D3D6D834((unsigned int **)v420);
              v191 = v422;
              if (v422)
              {
                v192 = v422 + 2;
                do
                  v193 = __ldxr(v192);
                while (__stxr(v193 + 1, v192));
              }
              v458 = v191;
              v194 = v423;
              if (v423)
              {
                v195 = v423 + 2;
                do
                  v196 = __ldxr(v195);
                while (__stxr(v196 + 1, v195));
              }
              v457 = v194;
              v197 = sub_1D3DCB164(v395, &v458, &v457, v154);
              sub_1D3D6D834(&v457);
              sub_1D3D6D834(&v458);
              if (v190 < 0
                || v197 < 0
                || (v198 = v190 + (v190 & 1), (v198 - 143) < 0xFFFFFF79)
                || (v199 = v197 + (v197 & 1) + 2, v199 < 8)
                || v199 > 0x90)
              {
LABEL_322:
                v292 = 0;
                v293 = 0;
                v294 = 0;
                goto LABEL_323;
              }
              v200 = (unsigned int *)*((_QWORD *)&v411 + 1);
              if (*((_QWORD *)&v411 + 1))
              {
                v201 = (unsigned int *)(*((_QWORD *)&v411 + 1) + 8);
                do
                  v202 = __ldxr(v201);
                while (__stxr(v202 + 1, v201));
              }
              v456 = v200;
              v203 = (unsigned int *)v412;
              if ((_QWORD)v412)
              {
                v204 = (unsigned int *)(v412 + 8);
                do
                  v205 = __ldxr(v204);
                while (__stxr(v205 + 1, v204));
              }
              v455 = v203;
              v393 = (*(float (**)(unsigned int *))(*(_QWORD *)v200 + 16))(v200);
              v392 = (*(float (**)(unsigned int *))(*(_QWORD *)v456 + 24))(v456);
              v391 = (*(float (**)(unsigned int *))(*(_QWORD *)v455 + 16))(v455);
              v390 = (*(float (**)(unsigned int *))(*(_QWORD *)v455 + 24))(v455);
              sub_1D3D6D834(&v455);
              sub_1D3D6D834(&v456);
              v206 = (unsigned int *)*((_QWORD *)&v411 + 1);
              if (*((_QWORD *)&v411 + 1))
              {
                v207 = (unsigned int *)(*((_QWORD *)&v411 + 1) + 8);
                do
                  v208 = __ldxr(v207);
                while (__stxr(v208 + 1, v207));
              }
              v454 = v206;
              v209 = (unsigned int *)v411;
              if ((_QWORD)v411)
              {
                v210 = (unsigned int *)(v411 + 8);
                do
                  v211 = __ldxr(v210);
                while (__stxr(v211 + 1, v210));
              }
              v453 = v209;
              v389 = (*(float (**)(unsigned int *))(*(_QWORD *)v206 + 16))(v206);
              v388 = (*(float (**)(unsigned int *))(*(_QWORD *)v454 + 24))(v454);
              v212 = (*(float (**)(unsigned int *))(*(_QWORD *)v453 + 16))(v453);
              v213 = (*(float (**)(unsigned int *))(*(_QWORD *)v453 + 24))(v453);
              sub_1D3D6D834(&v453);
              sub_1D3D6D834(&v454);
              v214 = operator new();
              v215 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 16))(*((_QWORD *)&v412 + 1));
              v216 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 16))(*((_QWORD *)&v412 + 1));
              v217 = (*(float (**)(_QWORD))(*(_QWORD *)v411 + 16))(v411);
              v218 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 24))(*((_QWORD *)&v412 + 1));
              v219 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 24))(*((_QWORD *)&v412 + 1));
              v220 = (*(float (**)(_QWORD))(*(_QWORD *)v411 + 24))(v411);
              v394 = sqrtf((float)((float)(v392 - v390) * (float)(v392 - v390))+ (float)((float)(v393 - v391) * (float)(v393 - v391)))/ (float)(v198 + 2);
              v221 = sqrtf((float)((float)(v388 - v213) * (float)(v388 - v213))+ (float)((float)(v389 - v212) * (float)(v389 - v212)))/ (float)(int)v199;
              *(_DWORD *)(v214 + 8) = 0;
              v222 = (unsigned int *)(v214 + 8);
              *(_QWORD *)v214 = &off_1E95AF250;
              *(float *)(v214 + 12) = (float)(v215 + v216) - v217;
              *(float *)(v214 + 16) = (float)(v218 + v219) - v220;
              do
                v223 = __ldxr(v222);
              while (__stxr(v223 + 1, v222));
              v452 = (unsigned int *)v214;
              v224 = operator new();
              v225 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 16))(*((_QWORD *)&v412 + 1));
              v226 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 16))(*((_QWORD *)&v412 + 1));
              v227 = (*(float (**)(_QWORD))(*(_QWORD *)v412 + 16))(v412);
              v228 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 24))(*((_QWORD *)&v412 + 1));
              v229 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 24))(*((_QWORD *)&v412 + 1));
              v230 = (*(float (**)(_QWORD))(*(_QWORD *)v412 + 24))(v412);
              *(_DWORD *)(v224 + 8) = 0;
              v231 = (unsigned int *)(v224 + 8);
              *(_QWORD *)v224 = &off_1E95AF250;
              *(float *)(v224 + 12) = (float)(v225 + v226) - v227;
              *(float *)(v224 + 16) = (float)(v228 + v229) - v230;
              do
                v232 = __ldxr(v231);
              while (__stxr(v232 + 1, v231));
              v451 = (unsigned int *)v224;
              v233 = (unsigned int *)*((_QWORD *)&v412 + 1);
              if (*((_QWORD *)&v412 + 1))
              {
                v234 = (unsigned int *)(*((_QWORD *)&v412 + 1) + 8);
                do
                  v235 = __ldxr(v234);
                while (__stxr(v235 + 1, v234));
              }
              v449 = v233;
              v236 = v452;
              if (v452)
              {
                v237 = v452 + 2;
                do
                  v238 = __ldxr(v237);
                while (__stxr(v238 + 1, v237));
              }
              v448 = v236;
              sub_1D3DCB3CC((uint64_t *)&v450, &v449, &v448, v394);
              sub_1D3D6D834(&v448);
              sub_1D3D6D834(&v449);
              v239 = (unsigned int *)*((_QWORD *)&v412 + 1);
              if (*((_QWORD *)&v412 + 1))
              {
                v240 = (unsigned int *)(*((_QWORD *)&v412 + 1) + 8);
                do
                  v241 = __ldxr(v240);
                while (__stxr(v241 + 1, v240));
              }
              v446 = v239;
              v242 = v451;
              if (v451)
              {
                v243 = v451 + 2;
                do
                  v244 = __ldxr(v243);
                while (__stxr(v244 + 1, v243));
              }
              v445 = v242;
              sub_1D3DCB3CC((uint64_t *)&v447, &v446, &v445, v221);
              sub_1D3D6D834(&v445);
              sub_1D3D6D834(&v446);
              v245 = v450;
              if (v450)
              {
                v246 = v450 + 2;
                do
                  v247 = __ldxr(v246);
                while (__stxr(v247 + 1, v246));
              }
              v444 = v245;
              v248 = sub_1D3DCB08C(v395, &v444);
              sub_1D3D6D834(&v444);
              v249 = v447;
              if (v248)
              {
                if (v447)
                {
                  v250 = v447 + 2;
                  do
                    v251 = __ldxr(v250);
                  while (__stxr(v251 + 1, v250));
                }
                v442 = v249;
                v252 = sub_1D3DCB08C(v395, &v442);
                sub_1D3D6D834(&v442);
                if (v252)
                {
                  v253 = (unsigned int *)v421;
                  if ((_QWORD)v421)
                  {
                    v254 = (unsigned int *)(v421 + 8);
                    do
                      v255 = __ldxr(v254);
                    while (__stxr(v255 + 1, v254));
                  }
                  v441 = v253;
                  v256 = v450;
                  if (v450)
                  {
                    v257 = v450 + 2;
                    do
                      v258 = __ldxr(v257);
                    while (__stxr(v258 + 1, v257));
                  }
                  v440 = v256;
                  v259 = sub_1D3DCB164(v395, &v441, &v440, v154);
                  sub_1D3D6D834(&v440);
                  sub_1D3D6D834(&v441);
                  v260 = v422;
                  if (v422)
                  {
                    v261 = v422 + 2;
                    do
                      v262 = __ldxr(v261);
                    while (__stxr(v262 + 1, v261));
                  }
                  v439 = v260;
                  v263 = v450;
                  if (v450)
                  {
                    v264 = v450 + 2;
                    do
                      v265 = __ldxr(v264);
                    while (__stxr(v265 + 1, v264));
                  }
                  v438 = v263;
                  v266 = sub_1D3DCB164(v395, &v439, &v438, v154);
                  sub_1D3D6D834(&v438);
                  sub_1D3D6D834(&v439);
                  v267 = v259 - v266;
                  if (v259 - v266 < 0)
                    v267 = v266 - v259;
                  v268 = v266 + v259 - v267;
                  if (v266 < 0)
                    v268 = -1;
                  if (v259 >= 0)
                    v269 = v268;
                  else
                    v269 = -1;
                  v270 = (unsigned int *)v421;
                  if ((_QWORD)v421)
                  {
                    v271 = (unsigned int *)(v421 + 8);
                    do
                      v272 = __ldxr(v271);
                    while (__stxr(v272 + 1, v271));
                  }
                  v437 = v270;
                  v273 = v447;
                  if (v447)
                  {
                    v274 = v447 + 2;
                    do
                      v275 = __ldxr(v274);
                    while (__stxr(v275 + 1, v274));
                  }
                  v436 = v273;
                  v276 = sub_1D3DCB164(v395, &v437, &v436, v154);
                  sub_1D3D6D834(&v436);
                  sub_1D3D6D834(&v437);
                  v277 = v422;
                  if (v422)
                  {
                    v278 = v422 + 2;
                    do
                      v279 = __ldxr(v278);
                    while (__stxr(v279 + 1, v278));
                  }
                  v435 = v277;
                  v280 = v447;
                  if (v447)
                  {
                    v281 = v447 + 2;
                    do
                      v282 = __ldxr(v281);
                    while (__stxr(v282 + 1, v281));
                  }
                  v434 = v280;
                  v283 = sub_1D3DCB164(v395, &v435, &v434, v154);
                  sub_1D3D6D834(&v434);
                  sub_1D3D6D834(&v435);
                  v284 = v276 - v283;
                  if (v276 - v283 < 0)
                    v284 = v283 - v276;
                  v285 = v283 + v276 - v284;
                  if (v283 < 0)
                    v285 = -1;
                  if (v276 >= 0)
                    v286 = v285;
                  else
                    v286 = -1;
                  v384 = v269 <= v286;
                  v287 = &v447;
                  if (!v384)
                    v287 = &v450;
                  v288 = *v287;
                  if (*v287)
                  {
                    v289 = v288 + 2;
                    do
                      v290 = __ldxr(v289);
                    while (__stxr(v290 + 1, v289));
                  }
                  v291 = (unsigned int *)*((_QWORD *)&v412 + 1);
                  if (!*((_QWORD *)&v412 + 1))
                    goto LABEL_389;
                }
                else
                {
                  v288 = v450;
                  if (v450)
                  {
                    v343 = v450 + 2;
                    do
                      v344 = __ldxr(v343);
                    while (__stxr(v344 + 1, v343));
                  }
                  v291 = (unsigned int *)*((_QWORD *)&v412 + 1);
                  if (!*((_QWORD *)&v412 + 1))
                    goto LABEL_389;
                }
              }
              else
              {
                if (v447)
                {
                  v338 = v447 + 2;
                  do
                    v339 = __ldxr(v338);
                  while (__stxr(v339 + 1, v338));
                }
                v443 = v249;
                v340 = sub_1D3DCB08C(v395, &v443);
                sub_1D3D6D834(&v443);
                if (!v340)
                {
                  v294 = 0;
LABEL_411:
                  sub_1D3D6D834(&v447);
                  sub_1D3D6D834(&v450);
                  sub_1D3D6D834(&v451);
                  sub_1D3D6D834(&v452);
                  if (v294)
                  {
                    v366 = (unsigned int *)v421;
                    if ((_QWORD)v421)
                    {
                      v367 = (unsigned int *)(v421 + 8);
                      do
                        v368 = __ldxr(v367);
                      while (__stxr(v368 + 1, v367));
                    }
                    v419 = v366;
                    v369 = v423;
                    if (v423)
                    {
                      v370 = v423 + 2;
                      do
                        v371 = __ldxr(v370);
                      while (__stxr(v371 + 1, v370));
                    }
                    v418 = v369;
                    v292 = sub_1D3DCB164(v395, &v419, &v418, v154);
                    sub_1D3D6D834(&v418);
                    sub_1D3D6D834(&v419);
                    v372 = v422;
                    if (v422)
                    {
                      v373 = v422 + 2;
                      do
                        v374 = __ldxr(v373);
                      while (__stxr(v374 + 1, v373));
                    }
                    v417 = v372;
                    v375 = v423;
                    if (v423)
                    {
                      v376 = v423 + 2;
                      do
                        v377 = __ldxr(v376);
                      while (__stxr(v377 + 1, v376));
                    }
                    v416 = v375;
                    v293 = sub_1D3DCB164(v395, &v417, &v416, v154);
                    sub_1D3D6D834(&v416);
                    sub_1D3D6D834(&v417);
                    v294 = 0;
                    if ((v292 & 0x80000000) == 0 && (v293 & 0x80000000) == 0)
                    {
                      if ((((_BYTE)v292 + 1) & 1) != 0)
                        v378 = v292 + 2;
                      else
                        v378 = v292 + 1;
                      if ((((_BYTE)v293 + 1) & 1) != 0)
                        v379 = v293 + 2;
                      else
                        v379 = v293 + 1;
                      v380 = 7 * v379;
                      v381 = 4 * v379;
                      v382 = 7 * v378;
                      if (v378 <= v379)
                        v383 = v379;
                      else
                        v383 = v378;
                      v384 = v381 < v382;
                      if (v381 >= v382)
                        v385 = v379;
                      else
                        v385 = v383;
                      if (v384)
                        v386 = v383;
                      else
                        v386 = v378;
                      if (v380 > 4 * v378)
                        v293 = v385;
                      else
                        v293 = v379;
                      if (v380 > 4 * v378)
                        v292 = v386;
                      else
                        v292 = v378;
                      v294 = v292 > 9 && v293 > 7;
                    }
                  }
                  else
                  {
                    v292 = 0;
                    v293 = 0;
                  }
LABEL_323:
                  for (n = 24; n != -8; n -= 8)
                    sub_1D3D6D834((unsigned int **)((char *)&v421 + n));
                  if (!v294)
                    break;
                  v296 = (*(float (**)(_QWORD))(*(_QWORD *)v411 + 16))(v411);
                  v297 = (*(float (**)(_QWORD))(*(_QWORD *)v411 + 24))(v411);
                  v298 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 16))(*((_QWORD *)&v412 + 1));
                  v299 = (*(float (**)(_QWORD))(**((_QWORD **)&v412 + 1) + 24))(*((_QWORD *)&v412 + 1));
                  v300 = (*(float (**)(_QWORD))(*(_QWORD *)v412 + 16))(v412);
                  v301 = (*(float (**)(_QWORD))(*(_QWORD *)v412 + 24))(v412);
                  v302 = (*(float (**)(_QWORD))(**((_QWORD **)&v411 + 1) + 16))(*((_QWORD *)&v411 + 1));
                  v303 = (*(float (**)(_QWORD))(**((_QWORD **)&v411 + 1) + 24))(*((_QWORD *)&v411 + 1));
                  sub_1D3DB93EC((uint64_t *)&v421, 0.0, 0.0, (float)v292, 0.0, (float)v292, (float)v293, 0.0, (float)v293, v296, v297, v298, v299, v300, v301, v302, v303);
                  v304 = (unsigned int *)v421;
                  if ((_QWORD)v421)
                  {
                    v305 = (unsigned int *)(v421 + 8);
                    do
                      v306 = __ldxr(v305);
                    while (__stxr(v306 + 1, v305));
                  }
                  if (v407)
                    sub_1D3D6D13C(v407);
                  v407 = v304;
                  sub_1D3D6F2E0((unsigned int **)&v421);
                  v307 = *(unsigned int **)(v395 + 16);
                  if (v307)
                  {
                    v308 = v307 + 2;
                    do
                      v309 = __ldxr(v308);
                    while (__stxr(v309 + 1, v308));
                  }
                  v404 = v307;
                  if (v407)
                  {
                    v310 = v407 + 2;
                    do
                      v311 = __ldxr(v310);
                    while (__stxr(v311 + 1, v310));
                  }
                  v403 = v407;
                  sub_1D3DB5FF8();
                  if (v404)
                  {
                    v312 = v404 + 2;
                    do
                      v313 = __ldxr(v312);
                    while (__stxr(v313 + 1, v312));
                  }
                  *(_QWORD *)&v421 = v404;
                  if (v403)
                  {
                    v314 = v403 + 2;
                    do
                      v315 = __ldxr(v314);
                    while (__stxr(v315 + 1, v314));
                  }
                  *(_QWORD *)&v420[0] = v403;
                  sub_1D3DB5BDC((uint64_t *)v459, (unsigned int **)&v421, v292, v293, v420, v59 == 2);
                  sub_1D3DB45E8((unsigned int **)v420);
                  sub_1D3D6D10C((unsigned int **)&v421);
                  v316 = v459[0];
                  if (v459[0])
                  {
                    v317 = v459[0] + 2;
                    do
                      v318 = __ldxr(v317);
                    while (__stxr(v318 + 1, v317));
                  }
                  if (v406)
                    sub_1D3D6D13C(v406);
                  v406 = v316;
                  sub_1D3D6D10C(v459);
                  sub_1D3D6F2E0(&v403);
                  sub_1D3D6D10C(&v404);
                  v319 = v406;
                  if (v406)
                  {
                    v320 = v406 + 2;
                    do
                      v321 = __ldxr(v320);
                    while (__stxr(v321 + 1, v320));
                  }
                  v402 = v319;
                  sub_1D3DC7D80((unsigned int **)&v421, &v402);
                  v322 = (unsigned int *)v421;
                  if ((_QWORD)v421)
                  {
                    v323 = (unsigned int *)(v421 + 8);
                    do
                      v324 = __ldxr(v323);
                    while (__stxr(v324 + 1, v323));
                  }
                  if (v405)
                    sub_1D3D6D13C(v405);
                  v405 = v322;
                  sub_1D3D7F814((unsigned int **)&v421);
                  sub_1D3D6D10C(&v402);
                  v49 = v59 == 2;
                  if (v405)
                  {
                    v325 = operator new();
                    v326 = v406;
                    if (v406)
                    {
                      v327 = v406 + 2;
                      do
                        v328 = __ldxr(v327);
                      while (__stxr(v328 + 1, v327));
                    }
                    v401 = v326;
                    memset(v400, 0, sizeof(v400));
                    sub_1D3D6D6A8((unsigned int *)v400, (unsigned int **)&v411, &v413, 4uLL);
                    sub_1D3DB4618(v325, (uint64_t *)&v401, v400, v59 == 2);
                    v329 = (unsigned int *)(v325 + 8);
                    do
                      v330 = __ldxr(v329);
                    while (__stxr(v330 + 1, v329));
                    *a1 = v325;
                    *(_QWORD *)&v421 = v400;
                    sub_1D3D6D79C((void ***)&v421);
                    sub_1D3D6D10C(&v401);
                    v331 = v405;
                    if (v405)
                    {
                      v332 = v405 + 2;
                      do
                        v333 = __ldxr(v332);
                      while (__stxr(v333 + 1, v332));
                      do
                        v334 = __ldxr(v332);
                      while (__stxr(v334 + 1, v332));
                      v335 = v331;
                    }
                    else
                    {
                      v335 = 0;
                    }
                    v399 = v335;
                    v336 = *(unsigned int **)(v325 + 80);
                    if (v336)
                      sub_1D3D6D13C(v336);
                    *(_QWORD *)(v325 + 80) = v331;
                    sub_1D3D7F814(&v399);
                    goto LABEL_56;
                  }
                  goto LABEL_53;
                }
                v288 = v447;
                if (v447)
                {
                  v341 = v447 + 2;
                  do
                    v342 = __ldxr(v341);
                  while (__stxr(v342 + 1, v341));
                }
                v291 = (unsigned int *)*((_QWORD *)&v412 + 1);
                if (!*((_QWORD *)&v412 + 1))
                {
LABEL_389:
                  *((_QWORD *)&v412 + 1) = v288;
                  if (v288)
                  {
                    v345 = v288 + 2;
                    do
                      v346 = __ldxr(v345);
                    while (__stxr(v346 + 1, v345));
                  }
                  v432 = v288;
                  v347 = (unsigned int *)v411;
                  if ((_QWORD)v411)
                  {
                    v348 = (unsigned int *)(v411 + 8);
                    do
                      v349 = __ldxr(v348);
                    while (__stxr(v349 + 1, v348));
                  }
                  v431 = v347;
                  v350 = (unsigned int *)v412;
                  if ((_QWORD)v412)
                  {
                    v351 = (unsigned int *)(v412 + 8);
                    do
                      v352 = __ldxr(v351);
                    while (__stxr(v352 + 1, v351));
                  }
                  v430 = v350;
                  v353 = (unsigned int *)*((_QWORD *)&v411 + 1);
                  if (*((_QWORD *)&v411 + 1))
                  {
                    v354 = (unsigned int *)(*((_QWORD *)&v411 + 1) + 8);
                    do
                      v355 = __ldxr(v354);
                    while (__stxr(v355 + 1, v354));
                  }
                  v429 = v353;
                  v356 = (unsigned int *)*((_QWORD *)&v421 + 1);
                  if (*((_QWORD *)&v421 + 1))
                  {
                    v357 = (unsigned int *)(*((_QWORD *)&v421 + 1) + 8);
                    do
                      v358 = __ldxr(v357);
                    while (__stxr(v358 + 1, v357));
                  }
                  v428 = v356;
                  v359 = (*(float (**)(unsigned int *))(*(_QWORD *)v353 + 16))(v353);
                  v360 = (*(float (**)(unsigned int *))(*(_QWORD *)v429 + 24))(v429);
                  v361 = (*(float (**)(unsigned int *))(*(_QWORD *)v428 + 16))(v428);
                  v362 = (*(float (**)(unsigned int *))(*(_QWORD *)v428 + 24))(v428);
                  sub_1D3DCB604((uint64_t *)&v433, &v432, &v431, &v430, sqrtf((float)((float)(v360 - v362) * (float)(v360 - v362))+ (float)((float)(v359 - v361) * (float)(v359 - v361))));
                  v363 = v433;
                  if (v433)
                  {
                    v364 = v433 + 2;
                    do
                      v365 = __ldxr(v364);
                    while (__stxr(v365 + 1, v364));
                  }
                  if (v423)
                    sub_1D3D6D13C(v423);
                  v423 = v363;
                  sub_1D3D6D834(&v433);
                  sub_1D3D6D834(&v428);
                  sub_1D3D6D834(&v429);
                  sub_1D3D6D834(&v430);
                  sub_1D3D6D834(&v431);
                  sub_1D3D6D834(&v432);
                  v294 = 1;
                  goto LABEL_411;
                }
              }
              sub_1D3D6D13C(v291);
              goto LABEL_389;
            }
            break;
          }
        }
      }
    }
  }
LABEL_52:
  v49 = 0;
LABEL_53:
  v50 = operator new();
  v398 = 0;
  memset(v397, 0, sizeof(v397));
  sub_1D3D6D6A8((unsigned int *)v397, v408, v409, v409 - v408);
  sub_1D3DB4618(v50, (uint64_t *)&v398, v397, v49);
  v51 = (unsigned int *)(v50 + 8);
  do
    v52 = __ldxr(v51);
  while (__stxr(v52 + 1, v51));
  *a1 = v50;
  v459[0] = (unsigned int *)v397;
  sub_1D3D6D79C((void ***)v459);
  sub_1D3D6D10C(&v398);
LABEL_56:
  sub_1D3D7F814(&v405);
  sub_1D3D6D10C(&v406);
  sub_1D3D6F2E0(&v407);
  v459[0] = (unsigned int *)&v408;
  sub_1D3D6D79C((void ***)v459);
  for (ii = 24; ii != -8; ii -= 8)
    sub_1D3D6D834((unsigned int **)((char *)&v411 + ii));
  return sub_1D3DCDE04(&v415);
}

void sub_1D3DCD970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,unsigned int *a31,unsigned int *a32,unsigned int *a33,char a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,unsigned int *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52)
{
  uint64_t v52;
  uint64_t i;
  uint64_t j;

  sub_1D3D6D834((unsigned int **)(v52 - 256));
  sub_1D3D6D834((unsigned int **)(v52 - 232));
  sub_1D3D6D834((unsigned int **)(v52 - 224));
  sub_1D3D6D834((unsigned int **)(v52 - 216));
  for (i = 24; i != -8; i -= 8)
    sub_1D3D6D834((unsigned int **)((char *)&a52 + i));
  sub_1D3D7F814(&a31);
  sub_1D3D6D10C(&a32);
  sub_1D3D6F2E0(&a33);
  *(_QWORD *)(v52 - 224) = &a34;
  sub_1D3D6D79C((void ***)(v52 - 224));
  for (j = 24; j != -8; j -= 8)
    sub_1D3D6D834((unsigned int **)(&a37 + j));
  sub_1D3DCDE04(&a43);
  _Unwind_Resume(a1);
}

unsigned int **sub_1D3DCDE04(unsigned int **a1)
{
  unsigned int *v2;

  v2 = *a1;
  if (v2)
    sub_1D3D6D13C(v2);
  return a1;
}

unsigned int **sub_1D3DCDE34(unsigned int **a1, uint64_t *a2, unsigned int **a3, int a4)
{
  unsigned int v6;
  float v7;
  int32x2_t v8;
  int32x4_t v9;
  unint64_t v10;
  int32x4_t *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  __int32 v15;
  int32x2_t v16;
  unsigned int *v17;
  int v18;
  int32x4_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int32x4_t *v24;
  int32x4_t *v25;
  int32x4_t v26;
  unint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  unint64_t v31;
  int32x4_t *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *v41;
  _BOOL4 v42;
  BOOL v43;
  float v44;
  int32x2_t v45;
  signed int v46;
  int32x2_t v47;
  int32x2_t v48;
  int v49;
  float v50;
  unint64_t v51;
  float32x2_t *v52;
  int32x2_t v53;
  float32x2_t v54;
  float32x2_t *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  float32x2_t *v60;
  float32x2_t *v61;
  float32x2_t v62;
  int32x2_t v63;
  int32x2_t v64;
  __int32 v65;
  __int32 v66;
  unsigned int v67;
  unsigned int v68;
  signed int v69;
  int32x2_t v70;
  int32x2_t v71;
  int32x2_t v72;
  int32x2_t v73;
  int32x2_t v74;
  int v75;
  unsigned int v76;
  uint32x2_t v77;
  float32x2_t *v78;
  uint32x2_t v79;
  int v80;
  unsigned __int8 *v81;
  int32x2_t v82;
  unsigned __int8 *v83;
  uint64_t v85;
  char *v86;
  char *v87;
  unsigned int *v88;
  unsigned int *v89;
  unsigned int v90;
  float32x2_t *v91;
  uint64_t v92;
  unsigned int *v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  int v99;
  int v100;
  unsigned int *v101;
  int i;
  unsigned int v103;
  uint64_t v104;
  unsigned int *v105;
  float *v106;
  uint64_t v107;
  uint64_t v108;
  BOOL v109;
  float *v110;
  int v111;
  int v112;
  uint64_t v113;
  unsigned int *v114;
  float *v115;
  uint64_t v116;
  uint64_t v117;
  BOOL v118;
  float *v119;
  int v120;
  int v121;
  uint64_t v122;
  unsigned int *v123;
  float *v124;
  uint64_t v125;
  uint64_t v126;
  BOOL v127;
  float *v128;
  int j;
  int v130;
  uint64_t v131;
  unsigned int *v132;
  float *v133;
  uint64_t v134;
  uint64_t v135;
  BOOL v136;
  uint64_t v137;
  unsigned int v138;
  unsigned int *v139;
  int v140;
  float *v141;
  unsigned int *v142;
  unsigned int v143;
  unsigned __int8 *v144;
  unsigned int *v145;
  unsigned int v146;
  unsigned int *v147;
  unsigned int *v148;
  unsigned int v149;
  float *v150;
  int v151;
  float v152;
  uint64_t v153;
  unsigned int *v154;
  unsigned int v155;
  unsigned int v156;
  float32x2_t *v157;
  _BOOL4 v158;
  char *v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float32x2_t *v166;
  unsigned int *v167;
  unsigned int *v168;
  unsigned int v169;
  int v170;
  float *v171;
  unsigned int *v172;
  unsigned int v173;
  int v174;
  float v175;
  int v176;
  int v177;
  BOOL v178;
  int v179;
  int v180;
  unsigned int v181;
  unsigned int *v183;
  unsigned int *v184;
  unsigned int v185;
  unsigned int *v186;
  unsigned int *v187;
  unsigned int v188;
  unsigned int *v189;
  unsigned int *v190;
  unsigned int v191;
  float *v192;
  unsigned int *v193;
  unsigned int v194;
  unsigned int *v195;
  unsigned int *v196;
  unsigned int v197;
  unsigned int *v198;
  unsigned int *v199;
  unsigned int v200;
  float v201;
  float v202;
  float v203;
  float v204;
  float v205;
  char *v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  float v215;
  float v216;
  float v217;
  unsigned int *v218;
  unsigned int *v219;
  unsigned int v220;
  int v221;
  unint64_t v222;
  unsigned int *v223;
  unsigned int *v224;
  unsigned int v225;
  float v226;
  unint64_t v227;
  unsigned int *v228;
  unsigned int *v229;
  unsigned int v230;
  unint64_t v231;
  unsigned int *v232;
  unsigned int *v233;
  unsigned int v234;
  unint64_t v235;
  float32x2_t *v236;
  float32x2_t *v237;
  uint64_t v238;
  float32x2_t *v239;
  uint64_t v240;
  char *v241;
  float32x2_t *v242;
  uint64_t k;
  float v244;
  float v245;
  float *v246;
  float *v247;
  unsigned int *v248;
  uint64_t v249;
  unint64_t v250;
  uint64_t v251;
  unint64_t v252;
  uint64_t v253;
  unsigned int *v254;
  unsigned int v255;
  float32x2_t *v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  uint64_t v260;
  uint64_t v261;
  _DWORD *v262;
  float v263;
  float v264;
  float *v265;
  unint64_t v266;
  float *v267;
  unsigned int *v268;
  uint64_t v269;
  unint64_t v270;
  unint64_t v271;
  uint64_t v272;
  unsigned int *v273;
  unsigned int v274;
  unint64_t v275;
  float32x2_t *v276;
  float32x2_t *v277;
  uint64_t v278;
  unint64_t v279;
  unint64_t v280;
  uint64_t v281;
  float32x2_t *v282;
  __int32 v283;
  float v284;
  float *v285;
  unsigned int *v286;
  uint64_t v287;
  unint64_t v288;
  unint64_t v289;
  uint64_t v290;
  unsigned int *v291;
  unsigned int v292;
  float32x2_t *v293;
  float32x2_t *v294;
  uint64_t v295;
  unint64_t v296;
  unint64_t v297;
  uint64_t v298;
  float32x2_t *v299;
  __int32 v300;
  float v301;
  float *v302;
  unsigned int *v303;
  uint64_t v304;
  unint64_t v305;
  unint64_t v306;
  uint64_t v307;
  unsigned int *v308;
  unsigned int v309;
  float32x2_t *v310;
  float32x2_t *v311;
  uint64_t v312;
  unint64_t v313;
  unint64_t v314;
  uint64_t v315;
  float32x2_t *v316;
  __int32 v317;
  float v318;
  float *v319;
  unsigned int *v320;
  uint64_t v321;
  unint64_t v322;
  unint64_t v323;
  uint64_t v324;
  unsigned int *v325;
  unsigned int v326;
  float32x2_t *v327;
  float32x2_t *v328;
  uint64_t v329;
  unint64_t v330;
  unint64_t v331;
  uint64_t v332;
  float32x2_t *v333;
  __int32 v334;
  float v335;
  float *v336;
  unsigned int *v337;
  uint64_t v338;
  unint64_t v339;
  unint64_t v340;
  uint64_t v341;
  unsigned int *v342;
  unsigned int v343;
  unsigned int *v344;
  unsigned int *v345;
  unsigned int v346;
  float *v347;
  unsigned int *v348;
  unsigned int v349;
  unsigned int *v350;
  unsigned int *v351;
  unsigned int v352;
  unsigned int *v353;
  unsigned int *v354;
  unsigned int v355;
  float v356;
  float v357;
  float v358;
  float v359;
  float v360;
  float v361;
  float v362;
  float v363;
  unsigned int *v364;
  float v365;
  unsigned int *v366;
  unsigned int v367;
  unint64_t v368;
  unsigned int *v369;
  unsigned int *v370;
  unsigned int v371;
  uint64_t v372;
  unsigned int *v373;
  unsigned int *v374;
  unsigned int v375;
  float *v376;
  unsigned int *v377;
  unsigned int v378;
  unsigned int *v379;
  unsigned int *v380;
  unsigned int v381;
  unsigned int *v382;
  unsigned int *v383;
  unsigned int v384;
  int v385;
  unint64_t v386;
  int v387;
  unsigned int **v388;
  int v391;
  unsigned int v392;
  int32x4_t v393;
  int32x4_t v394;
  int32x2_t v395;
  unint64_t v396;
  unsigned int *v397;
  float *v398;
  unsigned int *v399;
  unsigned int *v400;
  unsigned int *v401;
  void *v402;
  _QWORD v403[2];
  unsigned int *v404;
  float *v405;
  unsigned int *v406;
  unsigned int *v407;
  unsigned int *v408;
  unsigned int *v409;
  unsigned int *v410;
  unsigned int *v411;
  float *v412;
  unsigned int *v413;
  unsigned int *v414;
  unsigned int *v415;
  unsigned int *v416;
  int v417;
  void *__p;
  char *v419;
  unsigned __int8 v420[24];
  unsigned int *v421;
  float *v422;
  float *v423;
  unsigned int *v424;
  float *v425;
  unint64_t v426;
  float32x2_t *v427;
  float32x2_t *v428;
  char *v429;
  unsigned __int8 *v430;
  unsigned __int8 *v431;
  int32x2_t v432;
  uint64_t v433;
  unsigned int *v434[3];

  v434[1] = *(unsigned int **)MEMORY[0x1E0C80C00];
  *a1 = 0;
  sub_1D3DCFF78((uint64_t)v420, a2, a4);
  v392 = COERCE_UNSIGNED_INT64((*(double (**)(unsigned int *))(*(_QWORD *)*a3 + 16))(*a3));
  *(float *)&v6 = (*(float (**)(unsigned int *))(*(_QWORD *)*a3 + 24))(*a3);
  v391 = a4;
  v388 = a3;
  v7 = *((float *)*a3 + 5);
  v8 = vcvt_s32_f32((float32x2_t)__PAIR64__(v6, v392));
  v430 = v420;
  v431 = (unsigned __int8 *)v8;
  v433 = 1;
  v432 = 0;
  if (sub_1D3D6F8DC(v420, 1, *(double *)&v8))
  {
    if (!sub_1D3D6F948((int32x2_t *)&v430, v7))
      goto LABEL_120;
    goto LABEL_61;
  }
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = (int)v7;
  do
  {
    if (v14 >= 1)
    {
      v15 = 0;
      v16 = qword_1D3E6B6D0[v13];
      v17 = v421;
      *(int32x2_t *)v9.i8 = v8;
      v393 = v9;
      v18 = v420[0];
      while (1)
      {
        v19.i64[1] = v393.i64[1];
        *(int32x2_t *)v19.i8 = vadd_s32(*(int32x2_t *)v393.i8, v16);
        v393 = v19;
        if (v18 != sub_1D3D6D4A0(v17, v19.i32[0], v19.i32[1]))
          break;
        if (v14 == ++v15)
          goto LABEL_27;
      }
      v9 = v393;
      v9.i32[2] = v15;
      if ((unint64_t)v11 >= v10)
      {
        v394 = v9;
        v20 = ((uint64_t)v11->i64 - v12) >> 4;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 60)
          sub_1D3D6D4F8();
        if ((uint64_t)(v10 - v12) >> 3 > v21)
          v21 = (uint64_t)(v10 - v12) >> 3;
        if (v10 - v12 >= 0x7FFFFFFFFFFFFFF0)
          v22 = 0xFFFFFFFFFFFFFFFLL;
        else
          v22 = v21;
        if (v22)
          v22 = (unint64_t)sub_1D3D6DB64(v22);
        else
          v23 = 0;
        v24 = (int32x4_t *)(v22 + 16 * v20);
        v9.i64[1] = v394.i64[1];
        *v24 = v394;
        v25 = v24 + 1;
        if (v11 != (int32x4_t *)v12)
        {
          do
          {
            v26 = v11[-1];
            --v11;
            v9.i64[1] = v26.i64[1];
            v24[-1] = v26;
            --v24;
          }
          while (v11 != (int32x4_t *)v12);
          v11 = (int32x4_t *)v12;
        }
        v12 = (uint64_t)v24;
        v10 = v22 + 16 * v23;
        if (v11)
          operator delete(v11);
        v11 = v25;
      }
      else
      {
        *v11++ = v9;
      }
    }
LABEL_27:
    ++v13;
  }
  while (v13 != 8);
  v27 = 126 - 2 * __clz(((uint64_t)v11->i64 - v12) >> 4);
  if (v11 == (int32x4_t *)v12)
    v28 = 0;
  else
    v28 = v27;
  sub_1D3D6FAA0(v12, v11, v28, 1);
  if (v11 == (int32x4_t *)v12)
  {
    v29 = 0;
    v30 = 0;
    if (v11)
LABEL_52:
      operator delete(v11);
  }
  else
  {
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = (int32x4_t *)v12;
    do
    {
      v33 = v32->i64[0];
      if ((unint64_t)v30 >= v31)
      {
        v34 = (v30 - v29) >> 3;
        v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 61)
          sub_1D3D6D4F8();
        if ((uint64_t)(v31 - (_QWORD)v29) >> 2 > v35)
          v35 = (uint64_t)(v31 - (_QWORD)v29) >> 2;
        if (v31 - (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8)
          v36 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v36 = v35;
        if (v36)
          v36 = (unint64_t)sub_1D3D6D8A0(v36);
        else
          v37 = 0;
        v38 = (char *)(v36 + 8 * v34);
        *(_QWORD *)v38 = v33;
        v39 = v38 + 8;
        while (v30 != v29)
        {
          v40 = *((_QWORD *)v30 - 1);
          v30 -= 8;
          *((_QWORD *)v38 - 1) = v40;
          v38 -= 8;
        }
        v31 = v36 + 8 * v37;
        if (v29)
          operator delete(v29);
        v29 = v38;
        v30 = v39;
      }
      else
      {
        *(_QWORD *)v30 = v33;
        v30 += 8;
      }
      ++v32;
    }
    while (v32 != v11);
    v11 = (int32x4_t *)v12;
    if (v12)
      goto LABEL_52;
  }
  if (v29 == v30)
  {
    v42 = 0;
    if (v29)
LABEL_59:
      operator delete(v29);
  }
  else
  {
    v41 = v29 + 8;
    do
    {
      v431 = (unsigned __int8 *)*((_QWORD *)v41 - 1);
      v42 = sub_1D3D6F948((int32x2_t *)&v430, v7);
      if (v42)
        break;
      v43 = v41 == v30;
      v41 += 8;
    }
    while (!v43);
    if (v29)
      goto LABEL_59;
  }
  if (!v42)
  {
LABEL_120:
    v424 = 0;
    v425 = 0;
    v426 = 0;
    return sub_1D3D6D10C(&v421);
  }
LABEL_61:
  v44 = v7 * 7.0;
  v45 = (int32x2_t)v431;
  v432 = (int32x2_t)0x100000000;
  v46 = (int)(float)(v7 * 7.0);
  if (sub_1D3D7055C((int32x2_t *)&v430, 3, v46, (int)(float)(v7 / 5.0), (int)(float)(v7 * 0.5)) == -1)
    goto LABEL_120;
  v48 = (int32x2_t)v431;
  v47.i32[0] = -v432.i32[1];
  v432 = vzip1_s32(v47, v432);
  v427 = 0;
  v428 = 0;
  v429 = 0;
  sub_1D3D6E838((void **)&v427, vcvts_n_u32_f32(v44, 2uLL));
  v49 = 0;
  v50 = v44 * 8.0;
  v52 = v428;
  v51 = (unint64_t)v429;
  v53 = v48;
  do
  {
    v54 = vadd_f32(vcvt_f32_s32(v53), (float32x2_t)0x3F0000003F000000);
    if ((unint64_t)v52 >= v51)
    {
      v55 = v427;
      v56 = v52 - v427;
      v57 = v56 + 1;
      if ((unint64_t)(v56 + 1) >> 61)
        sub_1D3D6D4F8();
      if ((uint64_t)(v51 - (_QWORD)v427) >> 2 > v57)
        v57 = (uint64_t)(v51 - (_QWORD)v427) >> 2;
      if (v51 - (unint64_t)v427 >= 0x7FFFFFFFFFFFFFF8)
        v58 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v58 = v57;
      if (v58)
        v58 = (unint64_t)sub_1D3D6D8A0(v58);
      else
        v59 = 0;
      v60 = (float32x2_t *)(v58 + 8 * v56);
      *v60 = v54;
      v61 = v60 + 1;
      if (v52 != v55)
      {
        do
        {
          v62 = v52[-1];
          --v52;
          v60[-1] = v62;
          --v60;
        }
        while (v52 != v55);
        v52 = v427;
      }
      v51 = v58 + 8 * v59;
      v427 = v60;
      v428 = v61;
      v429 = (char *)v51;
      if (v52)
        operator delete(v52);
      v52 = v61;
    }
    else
    {
      *v52++ = v54;
    }
    v63 = (int32x2_t)v431;
    v64 = vsub_s32((int32x2_t)v431, v45);
    v65 = v64.i32[1];
    v66 = v64.i32[0];
    if (v64.i32[0] >= 0)
      v67 = v64.i32[0];
    else
      v67 = -v64.i32[0];
    if (v64.i32[1] >= 0)
      v68 = v64.u32[1];
    else
      v68 = -v64.i32[1];
    if (v67 <= v68)
      v69 = v68;
    else
      v69 = v67;
    v428 = v52;
    v64.i32[0] = -v432.i32[1];
    v395 = v432;
    v70 = vzip1_s32(v64, v432);
    v71 = vneg_s32(v70);
    v72 = (int32x2_t)v430;
    if (sub_1D3D70784(v430, (int32x2_t)v431, v71) == -1)
    {
      v432 = v71;
    }
    else if (sub_1D3D70784(*(unsigned __int8 **)&v72, v63, v395) == -1)
    {
      v71 = v395;
    }
    else
    {
      v432 = v70;
      if (sub_1D3D70784(*(unsigned __int8 **)&v72, v63, v70) == -1)
      {
        v71 = v70;
      }
      else
      {
        v73.i32[1] = v395.i32[1];
        v73.i32[0] = -v395.i32[0];
        v71 = vzip1_s32(v73, v70);
        v432 = v71;
        if (sub_1D3D70784(*(unsigned __int8 **)&v72, v63, v71) != -1)
          goto LABEL_121;
      }
    }
    v53 = vadd_s32(v71, v63);
    v431 = (unsigned __int8 *)v53;
    if (v53.i32[0] < 0
      || *(_QWORD *)(*(_QWORD *)&v72 + 8) <= (unint64_t)v53.u32[0]
      || v53.i32[1] < 0
      || *(_QWORD *)(*(_QWORD *)&v72 + 16) <= (unint64_t)v53.u32[1])
    {
      goto LABEL_121;
    }
    v74 = vsub_s32(v53, v45);
    v75 = v74.i32[1];
    v76 = v74.i32[0];
    if (v74.i32[0] < 0)
      v76 = -v74.i32[0];
    if (v74.i32[1] < 0)
      v75 = -v74.i32[1];
    if (v76 > v75)
      v75 = v76;
    if (v75 > v46
      || (v77 = (uint32x2_t)vceq_s32(v53, v45), (vpmin_u32(v77, v77).u32[0] & 0x80000000) != 0)
      || (v78 = v427, v50 < (float)(unint64_t)(v52 - v427)))
    {
LABEL_121:
      v78 = v427;
LABEL_122:
      v424 = 0;
      v425 = 0;
      v426 = 0;
      if (v78)
      {
        v83 = (unsigned __int8 *)v78;
        goto LABEL_124;
      }
      return sub_1D3D6D10C(&v421);
    }
    v49 |= 1 << (v66 / v69 + 3 * (v65 / v69) + 4);
    v79 = (uint32x2_t)vceq_s32(v53, v48);
  }
  while ((vpmin_u32(v79, v79).u32[0] & 0x80000000) == 0);
  if (v49 != 495)
    goto LABEL_122;
  v424 = (unsigned int *)v427;
  v425 = (float *)v52;
  v426 = (unint64_t)v429;
  if (v427 == v52)
  {
    v82 = 0;
    v81 = 0;
    v78 = v52;
    v80 = v391;
  }
  else
  {
    sub_1D3D6E8CC((float32x2_t **)&v430, (char **)&v424, vadd_f32(vcvt_f32_s32(v45), (float32x2_t)0x3F0000003F000000));
    v80 = v391;
    v81 = v430;
    v82 = (int32x2_t)v431;
    if (v430 == v431 || !sub_1D3D6F09C((float32x2_t *)v430, (uint64_t)v431, 5))
    {
      if (v81)
      {
        operator delete(v81);
        v81 = 0;
      }
      v82 = 0;
    }
    if (!v78)
      goto LABEL_132;
  }
  v425 = (float *)v78;
  operator delete(v78);
LABEL_132:
  if (v81 == (unsigned __int8 *)v82)
    goto LABEL_270;
  sub_1D3D8D5CC(&__p, 8uLL);
  v85 = 0;
  v86 = (char *)__p;
  do
  {
    v87 = &v86[v85];
    *(_DWORD *)v87 = *(_QWORD *)&v81[v85];
    *((_DWORD *)v87 + 1) = *(_DWORD *)&v81[v85 + 4];
    v85 += 8;
  }
  while (v85 != 32);
  v417 = -1;
  v88 = (unsigned int *)*a2;
  if (*a2)
  {
    v89 = v88 + 2;
    do
      v90 = __ldxr(v89);
    while (__stxr(v90 + 1, v89));
  }
  v415 = v88;
  v91 = (float32x2_t *)operator new(0x20uLL);
  v428 = v91 + 4;
  v429 = (char *)&v91[4];
  *(_OWORD *)v91->f32 = xmmword_1D3E6B66C;
  *(_OWORD *)v91[2].f32 = unk_1D3E6B67C;
  v427 = v91;
  v92 = operator new();
  *(_QWORD *)(v92 + 8) = 0;
  v93 = (unsigned int *)(v92 + 8);
  *(_QWORD *)v92 = &off_1E95AF428;
  *(_OWORD *)(v92 + 12) = xmmword_1D3E82060;
  *(_OWORD *)(v92 + 28) = xmmword_1D3E82060;
  *(_DWORD *)(v92 + 44) = 1065353216;
  do
    v94 = __ldxr(v93);
  while (__stxr(v94 + 1, v93));
  v434[0] = (unsigned int *)v92;
  do
    v95 = __ldxr(v93);
  while (__stxr(v95 + 1, v93));
  v423 = (float *)v92;
  sub_1D3DB9928(&v423, (const void **)&v427, (uint64_t)&__p);
  sub_1D3D6F2E0((unsigned int **)&v423);
  v96 = v415[14];
  v97 = v415[8];
  v98 = v415[4];
  sub_1D3D8D5CC(&v424, 0x14uLL);
  v99 = v98 & (v96 - 1) | v97 & -v96;
  v100 = v97 & (v96 - 1) | v98 & -v96;
  *(_QWORD *)((char *)v403 + 4) = 0;
  v101 = v424 + 1;
  for (i = -4; i != 6; ++i)
  {
    *((float *)v101 - 1) = (float)i;
    *v101 = 1084227584;
    v101 += 2;
  }
  (*(void (**)(unsigned int *, unsigned int **))(*(_QWORD *)v434[0] + 16))(v434[0], &v424);
  v103 = 0;
  v104 = 0;
  v105 = v424;
  do
  {
    v106 = (float *)&v105[v104];
    v107 = (int)*v106;
    v103 *= 2;
    if ((v107 & 0x80000000) == 0)
    {
      v108 = (int)v106[1];
      v109 = v100 <= (int)v108 || v99 <= (int)v107;
      if (!v109 && (v108 & 0x80000000) == 0)
        v103 |= sub_1D3D6D4A0(v415, v107, v108) ^ v80;
    }
    v104 += 2;
  }
  while ((unint64_t)(v104 - 2) < 0x12);
  LODWORD(v402) = v103;
  v110 = (float *)(v105 + 1);
  v111 = 5;
  do
  {
    --v111;
    *(v110 - 1) = 5.0;
    *v110 = (float)v111;
    v110 += 2;
  }
  while (v111 > -5);
  (*(void (**)(unsigned int *, unsigned int **))(*(_QWORD *)v434[0] + 16))(v434[0], &v424);
  v112 = 0;
  v113 = 0;
  v114 = v424;
  do
  {
    v115 = (float *)&v114[v113];
    v116 = (int)*v115;
    v112 *= 2;
    if ((v116 & 0x80000000) == 0)
    {
      v117 = (int)v115[1];
      v118 = v100 <= (int)v117 || v99 <= (int)v116;
      if (!v118 && (v117 & 0x80000000) == 0)
        v112 |= sub_1D3D6D4A0(v415, v116, v117) ^ v80;
    }
    v113 += 2;
  }
  while ((unint64_t)(v113 - 2) < 0x12);
  HIDWORD(v402) = v112;
  v119 = (float *)(v114 + 1);
  v120 = 5;
  do
  {
    *(v119 - 1) = (float)--v120;
    *v119 = -5.0;
    v119 += 2;
  }
  while (v120 > -5);
  (*(void (**)(unsigned int *, unsigned int **))(*(_QWORD *)v434[0] + 16))(v434[0], &v424);
  v121 = 0;
  v122 = 0;
  v123 = v424;
  do
  {
    v124 = (float *)&v123[v122];
    v125 = (int)*v124;
    v121 *= 2;
    if ((v125 & 0x80000000) == 0)
    {
      v126 = (int)v124[1];
      v127 = v100 <= (int)v126 || v99 <= (int)v125;
      if (!v127 && (v126 & 0x80000000) == 0)
        v121 |= sub_1D3D6D4A0(v415, v125, v126) ^ v80;
    }
    v122 += 2;
  }
  while ((unint64_t)(v122 - 2) < 0x12);
  LODWORD(v403[0]) = v121;
  v128 = (float *)(v123 + 1);
  for (j = -4; j != 6; ++j)
  {
    *(v128 - 1) = -5.0;
    *v128 = (float)j;
    v128 += 2;
  }
  (*(void (**)(unsigned int *, unsigned int **))(*(_QWORD *)v434[0] + 16))(v434[0], &v424);
  v130 = 0;
  v131 = 0;
  v132 = v424;
  do
  {
    v133 = (float *)&v132[v131];
    v134 = (int)*v133;
    v130 *= 2;
    if ((v134 & 0x80000000) == 0)
    {
      v135 = (int)v133[1];
      v136 = v100 <= (int)v135 || v99 <= (int)v134;
      if (!v136 && (v135 & 0x80000000) == 0)
        v130 |= sub_1D3D6D4A0(v415, v134, v135) ^ v80;
    }
    v131 += 2;
  }
  while ((unint64_t)(v131 - 2) < 0x12);
  v137 = 0;
  HIDWORD(v403[0]) = v130;
  LODWORD(v403[1]) = v103;
  while (1)
  {
    v138 = v103;
    v103 = *((_DWORD *)&v403[-1] + v137 + 1);
    if (v138)
    {
      if (v103)
      {
        sub_1D3DD8CFC((uint64_t)&v430, (v138 << 7) | (v103 >> 3) & 0x7F);
        if ((_DWORD)v431 != 3)
          break;
      }
    }
    if (++v137 == 4)
    {
      v139 = 0;
      goto LABEL_200;
    }
  }
  v140 = 2 * *(_DWORD *)v430 + 9;
  if ((*(_DWORD *)v430 - 5) < 0xFFFFFFFC)
    v140 = -1;
  v417 = v140;
  sub_1D3DD0000((char *)__p, &v419[-4 * (2 * v137)], v419);
  v141 = (float *)v434[0];
  if (v434[0])
  {
    v142 = v434[0] + 2;
    do
      v143 = __ldxr(v142);
    while (__stxr(v143 + 1, v142));
  }
  v422 = v141;
  v144 = (unsigned __int8 *)operator new(0x20uLL);
  v431 = v144 + 32;
  v432 = (int32x2_t)(v144 + 32);
  *(_OWORD *)v144 = xmmword_1D3E6B68C;
  *((_OWORD *)v144 + 1) = unk_1D3E6B69C;
  v430 = v144;
  sub_1D3DB9928(&v422, (const void **)&v430, (uint64_t)&__p);
  operator delete(v144);
  sub_1D3D6F2E0((unsigned int **)&v422);
  v139 = v434[0];
  if (v434[0])
  {
    v145 = v434[0] + 2;
    do
      v146 = __ldxr(v145);
    while (__stxr(v146 + 1, v145));
  }
LABEL_200:
  v416 = v139;
  if (v424)
  {
    v425 = (float *)v424;
    operator delete(v424);
  }
  sub_1D3D6F2E0(v434);
  operator delete(v91);
  sub_1D3D6D10C(&v415);
  if (v416)
  {
LABEL_253:
    sub_1D3DB5FF8();
    v189 = (unsigned int *)*a2;
    if (*a2)
    {
      v190 = v189 + 2;
      do
        v191 = __ldxr(v190);
      while (__stxr(v191 + 1, v190));
    }
    v413 = v189;
    v192 = (float *)v416;
    if (v416)
    {
      v193 = v416 + 2;
      do
        v194 = __ldxr(v193);
      while (__stxr(v194 + 1, v193));
    }
    v412 = v192;
    v430 = 0;
    v431 = 0;
    v432 = 0;
    v427 = 0;
    v428 = 0;
    v429 = 0;
    v195 = *v388;
    if (*v388)
    {
      v196 = v195 + 2;
      do
        v197 = __ldxr(v196);
      while (__stxr(v197 + 1, v196));
    }
    v411 = v195;
    sub_1D3DD0428(&v424, &v413, &v412, (uint64_t)&v430, &v427, &v411, &v417, v80);
    v198 = v424;
    if (v424)
    {
      v199 = v424 + 2;
      do
        v200 = __ldxr(v199);
      while (__stxr(v200 + 1, v199));
    }
    if (*a1)
      sub_1D3D6D13C(*a1);
    *a1 = v198;
    sub_1D3D7F7E4(&v424);
    sub_1D3DC2944(&v411);
    sub_1D3D6F2E0((unsigned int **)&v412);
    sub_1D3D6D10C(&v413);
    if (*a1)
      goto LABEL_268;
    v201 = *((float *)__p + 2);
    v202 = *((float *)__p + 3);
    v203 = *((float *)__p + 6);
    v204 = *((float *)__p + 7);
    v205 = (float)v417;
    *(float *)&v423 = (float)v417;
    v206 = (char *)operator new(0x10uLL);
    v431 = (unsigned __int8 *)(v206 + 16);
    v432 = (int32x2_t)(v206 + 16);
    *(float *)v206 = v205 + 2.0;
    *(_QWORD *)(v206 + 4) = 0xC0000000C0000000;
    *((float *)v206 + 3) = v205 + 2.0;
    v430 = (unsigned __int8 *)v206;
    (*(void (**)(unsigned int *, unsigned __int8 **))(*(_QWORD *)v416 + 16))(v416, &v430);
    v207 = *(float *)v430;
    v208 = *((float *)v430 + 1);
    v209 = *((float *)v430 + 2);
    v210 = *((float *)v430 + 3);
    v211 = v209 - *(float *)v430;
    v212 = v210 - v208;
    v213 = sqrtf((float)(v212 * v212) + (float)(v211 * v211));
    if (v213 < 0.00001)
      goto LABEL_284;
    v214 = sqrtf((float)((float)(v202 - v204) * (float)(v202 - v204)) + (float)((float)(v201 - v203)
                                                                              * (float)(v201 - v203)))
         / 7.0;
    v215 = v211 / v213;
    v216 = v212 / v213;
    v217 = v214 + v214;
    v218 = (unsigned int *)*a2;
    if (*a2)
    {
      v219 = v218 + 2;
      do
        v220 = __ldxr(v219);
      while (__stxr(v220 + 1, v219));
    }
    v410 = v218;
    v221 = vcvtps_s32_f32(v217 + v217);
    v222 = sub_1D3DD0C4C((uint64_t)v218, v80, v221, v207, v208, v211 / v213, v212 / v213);
    sub_1D3D6D10C(&v410);
    if ((v222 & 0x8000000080000000) != 0)
      goto LABEL_284;
    v223 = (unsigned int *)*a2;
    if (*a2)
    {
      v224 = v223 + 2;
      do
        v225 = __ldxr(v224);
      while (__stxr(v225 + 1, v224));
    }
    v409 = v223;
    v226 = ceilf(v217);
    v227 = sub_1D3DD0D40((uint64_t)&v409, v222, HIDWORD(v222), v80, -v215, -v216, v226);
    sub_1D3D6D10C(&v409);
    v228 = (unsigned int *)*a2;
    if (*a2)
    {
      v229 = v228 + 2;
      do
        v230 = __ldxr(v229);
      while (__stxr(v230 + 1, v229));
    }
    v408 = v228;
    v231 = sub_1D3DD0C4C((uint64_t)v228, v80, v221, v209, v210, -v215, -v216);
    sub_1D3D6D10C(&v408);
    if ((v231 & 0x8000000080000000) != 0)
      goto LABEL_284;
    v232 = (unsigned int *)*a2;
    if (*a2)
    {
      v233 = v232 + 2;
      do
        v234 = __ldxr(v233);
      while (__stxr(v234 + 1, v233));
    }
    v407 = v232;
    v235 = sub_1D3DD0D40((uint64_t)&v407, v231, HIDWORD(v231), v80, v215, v216, v226);
    sub_1D3D6D10C(&v407);
    v236 = (float32x2_t *)operator new(0x20uLL);
    v426 = 0;
    v427 = v236;
    v429 = (char *)&v236[4];
    *(_OWORD *)v236->f32 = xmmword_1D3E6B68C;
    *(_OWORD *)v236[2].f32 = unk_1D3E6B69C;
    v424 = 0;
    v425 = 0;
    sub_1D3D8E528(&v424, __p, (uint64_t)v419, (v419 - (_BYTE *)__p) >> 2);
    v385 = v221;
    v237 = (float32x2_t *)sub_1D3D82278(0x10uLL);
    v239 = v237;
    v240 = v238;
    v396 = HIDWORD(v227);
    v386 = HIDWORD(v235);
    v387 = v235;
    v241 = (char *)v237 + 4 * v238;
    v237[4].i32[0] = 1080033280;
    v242 = (float32x2_t *)((char *)v237 + 36);
    for (k = 7; k != -1; --k)
      v237->i32[k] = v236->i32[k];
    v427 = v237;
    v429 = (char *)v237 + 4 * v238;
    operator delete(v236);
    v428 = v242;
    v244 = (*(float (**)(unsigned int *))(*(_QWORD *)*v388 + 16))(*v388);
    v245 = v244;
    v246 = v425;
    if ((unint64_t)v425 >= v426)
    {
      v248 = v424;
      v249 = ((char *)v425 - (char *)v424) >> 2;
      v250 = v249 + 1;
      if ((unint64_t)(v249 + 1) >> 62)
        sub_1D3D6D4F8();
      v251 = v426 - (_QWORD)v424;
      if ((uint64_t)(v426 - (_QWORD)v424) >> 1 > v250)
        v250 = v251 >> 1;
      if ((unint64_t)v251 >= 0x7FFFFFFFFFFFFFFCLL)
        v252 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v252 = v250;
      if (v252)
        v252 = (unint64_t)sub_1D3D82278(v252);
      else
        v253 = 0;
      v254 = (unsigned int *)(v252 + 4 * v249);
      *(float *)v254 = v245;
      v247 = (float *)(v254 + 1);
      while (v246 != (float *)v248)
      {
        v255 = *((_DWORD *)v246-- - 1);
        *--v254 = v255;
      }
      v424 = v254;
      v426 = v252 + 4 * v253;
      if (v248)
        operator delete(v248);
    }
    else
    {
      *v425 = v244;
      v247 = v246 + 1;
    }
    v425 = v247;
    if (v240 < 10)
    {
      v257 = ((char *)v242 - (char *)v239) >> 2;
      v258 = v257 + 1;
      if ((unint64_t)(v257 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((v241 - (char *)v239) >> 1 > v258)
        v258 = (v241 - (char *)v239) >> 1;
      if ((unint64_t)(v241 - (char *)v239) >= 0x7FFFFFFFFFFFFFFCLL)
        v259 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v259 = v258;
      if (v259)
        v259 = (unint64_t)sub_1D3D82278(v259);
      else
        v260 = 0;
      v261 = 0;
      v262 = (_DWORD *)(v259 + 4 * v257);
      *v262 = 1080033280;
      v256 = (float32x2_t *)(v262 + 1);
      do
      {
        v262[v261 - 1] = v239[4].i32[v261];
        --v261;
      }
      while (v261 != -9);
      v427 = (float32x2_t *)(v262 - 9);
      v428 = (float32x2_t *)(v262 + 1);
      v429 = (char *)(v259 + 4 * v260);
      if (v239)
        operator delete(v239);
    }
    else
    {
      v239[4].i32[1] = 1080033280;
      v256 = v239 + 5;
    }
    v263 = (*(float (**)(unsigned int *))(*(_QWORD *)*v388 + 24))(*v388);
    v264 = v263;
    v265 = v425;
    v266 = v426;
    if ((unint64_t)v425 >= v426)
    {
      v268 = v424;
      v269 = ((char *)v425 - (char *)v424) >> 2;
      v270 = v269 + 1;
      if ((unint64_t)(v269 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((uint64_t)(v426 - (_QWORD)v424) >> 1 > v270)
        v270 = (uint64_t)(v426 - (_QWORD)v424) >> 1;
      if (v426 - (unint64_t)v424 >= 0x7FFFFFFFFFFFFFFCLL)
        v271 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v271 = v270;
      if (v271)
        v271 = (unint64_t)sub_1D3D82278(v271);
      else
        v272 = 0;
      v273 = (unsigned int *)(v271 + 4 * v269);
      v266 = v271 + 4 * v272;
      *(float *)v273 = v264;
      v267 = (float *)(v273 + 1);
      while (v265 != (float *)v268)
      {
        v274 = *((_DWORD *)v265-- - 1);
        *--v273 = v274;
      }
      v424 = v273;
      v425 = v267;
      v426 = v271 + 4 * v272;
      if (v268)
        operator delete(v268);
    }
    else
    {
      *v425 = v263;
      v267 = v265 + 1;
    }
    v275 = (unint64_t)v429;
    if (v256 >= (float32x2_t *)v429)
    {
      v277 = v427;
      v278 = ((char *)v256 - (char *)v427) >> 2;
      v279 = v278 + 1;
      if ((unint64_t)(v278 + 1) >> 62)
        goto LABEL_518;
      if ((v429 - (char *)v427) >> 1 > v279)
        v279 = (v429 - (char *)v427) >> 1;
      if ((unint64_t)(v429 - (char *)v427) >= 0x7FFFFFFFFFFFFFFCLL)
        v280 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v280 = v279;
      if (v280)
        v280 = (unint64_t)sub_1D3D82278(v280);
      else
        v281 = 0;
      v282 = (float32x2_t *)(v280 + 4 * v278);
      v275 = v280 + 4 * v281;
      v282->i32[0] = (int)v423;
      v276 = (float32x2_t *)((char *)v282 + 4);
      while (v256 != v277)
      {
        v283 = v256[-1].i32[1];
        v256 = (float32x2_t *)((char *)v256 - 4);
        v282[-1].i32[1] = v283;
        v282 = (float32x2_t *)((char *)v282 - 4);
      }
      v427 = v282;
      v428 = v276;
      v429 = (char *)(v280 + 4 * v281);
      if (v277)
        operator delete(v277);
    }
    else
    {
      v256->i32[0] = (int)v423;
      v276 = (float32x2_t *)((char *)v256 + 4);
    }
    v284 = (float)(int)v227;
    if ((unint64_t)v267 >= v266)
    {
      v286 = v424;
      v287 = ((char *)v267 - (char *)v424) >> 2;
      v288 = v287 + 1;
      if ((unint64_t)(v287 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((uint64_t)(v266 - (_QWORD)v424) >> 1 > v288)
        v288 = (uint64_t)(v266 - (_QWORD)v424) >> 1;
      if (v266 - (unint64_t)v424 >= 0x7FFFFFFFFFFFFFFCLL)
        v289 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v289 = v288;
      if (v289)
        v289 = (unint64_t)sub_1D3D82278(v289);
      else
        v290 = 0;
      v291 = (unsigned int *)(v289 + 4 * v287);
      v266 = v289 + 4 * v290;
      *(float *)v291 = v284;
      v285 = (float *)(v291 + 1);
      while (v267 != (float *)v286)
      {
        v292 = *((_DWORD *)v267-- - 1);
        *--v291 = v292;
      }
      v424 = v291;
      v425 = v285;
      v426 = v289 + 4 * v290;
      if (v286)
        operator delete(v286);
    }
    else
    {
      *v267 = v284;
      v285 = v267 + 1;
    }
    if ((unint64_t)v276 >= v275)
    {
      v294 = v427;
      v295 = ((char *)v276 - (char *)v427) >> 2;
      v296 = v295 + 1;
      if ((unint64_t)(v295 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((uint64_t)(v275 - (_QWORD)v427) >> 1 > v296)
        v296 = (uint64_t)(v275 - (_QWORD)v427) >> 1;
      if (v275 - (unint64_t)v427 >= 0x7FFFFFFFFFFFFFFCLL)
        v297 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v297 = v296;
      if (v297)
        v297 = (unint64_t)sub_1D3D82278(v297);
      else
        v298 = 0;
      v299 = (float32x2_t *)(v297 + 4 * v295);
      v275 = v297 + 4 * v298;
      v299->i32[0] = 0;
      v293 = (float32x2_t *)((char *)v299 + 4);
      while (v276 != v294)
      {
        v300 = v276[-1].i32[1];
        v276 = (float32x2_t *)((char *)v276 - 4);
        v299[-1].i32[1] = v300;
        v299 = (float32x2_t *)((char *)v299 - 4);
      }
      v427 = v299;
      v428 = v293;
      v429 = (char *)(v297 + 4 * v298);
      if (v294)
        operator delete(v294);
    }
    else
    {
      v276->i32[0] = 0;
      v293 = (float32x2_t *)((char *)v276 + 4);
    }
    v301 = (float)(int)v396;
    if ((unint64_t)v285 >= v266)
    {
      v303 = v424;
      v304 = ((char *)v285 - (char *)v424) >> 2;
      v305 = v304 + 1;
      if ((unint64_t)(v304 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((uint64_t)(v266 - (_QWORD)v424) >> 1 > v305)
        v305 = (uint64_t)(v266 - (_QWORD)v424) >> 1;
      if (v266 - (unint64_t)v424 >= 0x7FFFFFFFFFFFFFFCLL)
        v306 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v306 = v305;
      if (v306)
        v306 = (unint64_t)sub_1D3D82278(v306);
      else
        v307 = 0;
      v308 = (unsigned int *)(v306 + 4 * v304);
      v266 = v306 + 4 * v307;
      *(float *)v308 = v301;
      v302 = (float *)(v308 + 1);
      while (v285 != (float *)v303)
      {
        v309 = *((_DWORD *)v285-- - 1);
        *--v308 = v309;
      }
      v424 = v308;
      v425 = v302;
      v426 = v306 + 4 * v307;
      if (v303)
        operator delete(v303);
    }
    else
    {
      *v285 = v301;
      v302 = v285 + 1;
    }
    if ((unint64_t)v293 >= v275)
    {
      v311 = v427;
      v312 = ((char *)v293 - (char *)v427) >> 2;
      v313 = v312 + 1;
      if ((unint64_t)(v312 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((uint64_t)(v275 - (_QWORD)v427) >> 1 > v313)
        v313 = (uint64_t)(v275 - (_QWORD)v427) >> 1;
      if (v275 - (unint64_t)v427 >= 0x7FFFFFFFFFFFFFFCLL)
        v314 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v314 = v313;
      if (v314)
        v314 = (unint64_t)sub_1D3D82278(v314);
      else
        v315 = 0;
      v316 = (float32x2_t *)(v314 + 4 * v312);
      v275 = v314 + 4 * v315;
      v316->i32[0] = 0;
      v310 = (float32x2_t *)((char *)v316 + 4);
      while (v293 != v311)
      {
        v317 = v293[-1].i32[1];
        v293 = (float32x2_t *)((char *)v293 - 4);
        v316[-1].i32[1] = v317;
        v316 = (float32x2_t *)((char *)v316 - 4);
      }
      v427 = v316;
      v428 = v310;
      v429 = (char *)(v314 + 4 * v315);
      if (v311)
        operator delete(v311);
    }
    else
    {
      v293->i32[0] = 0;
      v310 = (float32x2_t *)((char *)v293 + 4);
    }
    v318 = (float)v387;
    if ((unint64_t)v302 >= v266)
    {
      v320 = v424;
      v321 = ((char *)v302 - (char *)v424) >> 2;
      v322 = v321 + 1;
      if ((unint64_t)(v321 + 1) >> 62)
        sub_1D3D6D4F8();
      if ((uint64_t)(v266 - (_QWORD)v424) >> 1 > v322)
        v322 = (uint64_t)(v266 - (_QWORD)v424) >> 1;
      if (v266 - (unint64_t)v424 >= 0x7FFFFFFFFFFFFFFCLL)
        v323 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v323 = v322;
      if (v323)
        v323 = (unint64_t)sub_1D3D82278(v323);
      else
        v324 = 0;
      v325 = (unsigned int *)(v323 + 4 * v321);
      v266 = v323 + 4 * v324;
      *(float *)v325 = v318;
      v319 = (float *)(v325 + 1);
      while (v302 != (float *)v320)
      {
        v326 = *((_DWORD *)v302-- - 1);
        *--v325 = v326;
      }
      v424 = v325;
      v425 = v319;
      v426 = v323 + 4 * v324;
      if (v320)
        operator delete(v320);
    }
    else
    {
      *v302 = v318;
      v319 = v302 + 1;
    }
    if ((unint64_t)v310 < v275)
    {
      v310->i32[0] = (int)v423;
      v327 = (float32x2_t *)((char *)v310 + 4);
LABEL_455:
      v428 = v327;
      v335 = (float)(int)v386;
      if ((unint64_t)v319 >= v266)
      {
        v337 = v424;
        v338 = ((char *)v319 - (char *)v424) >> 2;
        v339 = v338 + 1;
        if ((unint64_t)(v338 + 1) >> 62)
          sub_1D3D6D4F8();
        if ((uint64_t)(v266 - (_QWORD)v424) >> 1 > v339)
          v339 = (uint64_t)(v266 - (_QWORD)v424) >> 1;
        if (v266 - (unint64_t)v424 >= 0x7FFFFFFFFFFFFFFCLL)
          v340 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v340 = v339;
        if (v340)
          v340 = (unint64_t)sub_1D3D82278(v340);
        else
          v341 = 0;
        v342 = (unsigned int *)(v340 + 4 * v338);
        *(float *)v342 = v335;
        v336 = (float *)(v342 + 1);
        while (v319 != (float *)v337)
        {
          v343 = *((_DWORD *)v319-- - 1);
          *--v342 = v343;
        }
        v424 = v342;
        v426 = v340 + 4 * v341;
        if (v337)
          operator delete(v337);
      }
      else
      {
        *v319 = v335;
        v336 = v319 + 1;
      }
      v425 = v336;
      v344 = (unsigned int *)*a2;
      if (*a2)
      {
        v345 = v344 + 2;
        do
          v346 = __ldxr(v345);
        while (__stxr(v346 + 1, v345));
      }
      v406 = v344;
      v347 = (float *)v416;
      if (v416)
      {
        v348 = v416 + 2;
        do
          v349 = __ldxr(v348);
        while (__stxr(v349 + 1, v348));
      }
      v405 = v347;
      v350 = *v388;
      if (*v388)
      {
        v351 = v350 + 2;
        do
          v352 = __ldxr(v351);
        while (__stxr(v352 + 1, v351));
      }
      v404 = v350;
      sub_1D3DD0428(&v402, &v406, &v405, (uint64_t)&v427, &v424, &v404, &v417, v391);
      v353 = (unsigned int *)v402;
      if (v402)
      {
        v354 = (unsigned int *)((char *)v402 + 8);
        do
          v355 = __ldxr(v354);
        while (__stxr(v355 + 1, v354));
      }
      if (*a1)
        sub_1D3D6D13C(*a1);
      *a1 = v353;
      sub_1D3D7F7E4((unsigned int **)&v402);
      sub_1D3DC2944(&v404);
      sub_1D3D6F2E0((unsigned int **)&v405);
      sub_1D3D6D10C(&v406);
      if (!*a1)
      {
        *(float *)v434 = *(float *)&v423 + 2.0;
        *((float *)v434 + 1) = *(float *)&v423 + 2.0;
        sub_1D3DC6C5C(&v402, v434, 2uLL);
        (*(void (**)(unsigned int *, void **))(*(_QWORD *)v416 + 16))(v416, &v402);
        v356 = *(float *)v402;
        v357 = *((float *)v402 + 1);
        v358 = (*(float (**)(unsigned int *))(*(_QWORD *)*v388 + 16))(*v388);
        v359 = (*(float (**)(unsigned int *))(*(_QWORD *)*v388 + 24))(*v388);
        v360 = v358 - v356;
        v361 = v359 - v357;
        v362 = sqrtf((float)(v361 * v361) + (float)(v360 * v360));
        if (v362 >= 0.00001)
        {
          v363 = v360 / v362;
          v364 = (unsigned int *)*a2;
          v365 = v361 / v362;
          if (*a2)
          {
            v366 = v364 + 2;
            do
              v367 = __ldxr(v366);
            while (__stxr(v367 + 1, v366));
          }
          v401 = v364;
          v368 = sub_1D3DD0C4C((uint64_t)v364, v391, v385, v356, v357, v363, v365);
          sub_1D3D6D10C(&v401);
          if ((v368 & 0x8000000080000000) == 0)
          {
            v369 = (unsigned int *)*a2;
            if (*a2)
            {
              v370 = v369 + 2;
              do
                v371 = __ldxr(v370);
              while (__stxr(v371 + 1, v370));
            }
            v400 = v369;
            v372 = sub_1D3DD0D40((uint64_t)&v400, v368, HIDWORD(v368), v391, -v363, -v365, v226);
            sub_1D3D6D10C(&v400);
            sub_1D3DD1034((uint64_t)&v427, &v423);
            *(float *)v434 = (float)(int)v372;
            sub_1D3DD1034((uint64_t)&v424, v434);
            sub_1D3DD1034((uint64_t)&v427, &v423);
            *(float *)v434 = (float)SHIDWORD(v372);
            sub_1D3DD1034((uint64_t)&v424, v434);
            v373 = (unsigned int *)*a2;
            if (*a2)
            {
              v374 = v373 + 2;
              do
                v375 = __ldxr(v374);
              while (__stxr(v375 + 1, v374));
            }
            v399 = v373;
            v376 = (float *)v416;
            if (v416)
            {
              v377 = v416 + 2;
              do
                v378 = __ldxr(v377);
              while (__stxr(v378 + 1, v377));
            }
            v398 = v376;
            v379 = *v388;
            if (*v388)
            {
              v380 = v379 + 2;
              do
                v381 = __ldxr(v380);
              while (__stxr(v381 + 1, v380));
            }
            v397 = v379;
            sub_1D3DD0428(v434, &v399, &v398, (uint64_t)&v427, &v424, &v397, &v417, v391);
            v382 = v434[0];
            if (v434[0])
            {
              v383 = v434[0] + 2;
              do
                v384 = __ldxr(v383);
              while (__stxr(v384 + 1, v383));
            }
            if (*a1)
              sub_1D3D6D13C(*a1);
            *a1 = v382;
            sub_1D3D7F7E4(v434);
            sub_1D3DC2944(&v397);
            sub_1D3D6F2E0((unsigned int **)&v398);
            sub_1D3D6D10C(&v399);
          }
        }
        if (v402)
        {
          v403[0] = v402;
          operator delete(v402);
        }
      }
      if (v424)
        operator delete(v424);
      if (v427)
        operator delete(v427);
LABEL_284:
      if (v430)
      {
        v431 = v430;
        operator delete(v430);
      }
      sub_1D3D6F2E0(&v416);
      if (__p)
      {
        v419 = (char *)__p;
        operator delete(__p);
      }
      if (v81)
        operator delete(v81);
      return sub_1D3D6D10C(&v421);
    }
    v328 = v427;
    v329 = ((char *)v310 - (char *)v427) >> 2;
    v330 = v329 + 1;
    if (!((unint64_t)(v329 + 1) >> 62))
    {
      if ((uint64_t)(v275 - (_QWORD)v427) >> 1 > v330)
        v330 = (uint64_t)(v275 - (_QWORD)v427) >> 1;
      if (v275 - (unint64_t)v427 >= 0x7FFFFFFFFFFFFFFCLL)
        v331 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v331 = v330;
      if (v331)
        v331 = (unint64_t)sub_1D3D82278(v331);
      else
        v332 = 0;
      v333 = (float32x2_t *)(v331 + 4 * v329);
      v333->i32[0] = (int)v423;
      v327 = (float32x2_t *)((char *)v333 + 4);
      while (v310 != v328)
      {
        v334 = v310[-1].i32[1];
        v310 = (float32x2_t *)((char *)v310 - 4);
        v333[-1].i32[1] = v334;
        v333 = (float32x2_t *)((char *)v333 - 4);
      }
      v427 = v333;
      v429 = (char *)(v331 + 4 * v332);
      if (v328)
        operator delete(v328);
      goto LABEL_455;
    }
LABEL_518:
    sub_1D3D6D4F8();
  }
  v147 = (unsigned int *)*a2;
  if (*a2)
  {
    v148 = v147 + 2;
    do
      v149 = __ldxr(v148);
    while (__stxr(v149 + 1, v148));
  }
  v414 = v147;
  v422 = 0;
  v430 = 0;
  v431 = 0;
  v432 = 0;
  sub_1D3D8E528(&v430, __p, (uint64_t)v419, (v419 - (_BYTE *)__p) >> 2);
  v150 = 0;
  v151 = 0;
  v152 = 1.0;
  while (2)
  {
    v153 = operator new();
    *(_QWORD *)(v153 + 8) = 0;
    v154 = (unsigned int *)(v153 + 8);
    *(_QWORD *)v153 = &off_1E95AF428;
    *(_OWORD *)(v153 + 12) = xmmword_1D3E82060;
    *(_OWORD *)(v153 + 28) = xmmword_1D3E82060;
    *(_DWORD *)(v153 + 44) = 1065353216;
    do
      v155 = __ldxr(v154);
    while (__stxr(v155 + 1, v154));
    v424 = (unsigned int *)v153;
    do
      v156 = __ldxr(v154);
    while (__stxr(v156 + 1, v154));
    v402 = (void *)v153;
    v157 = (float32x2_t *)operator new(0x20uLL);
    v428 = v157 + 4;
    v429 = (char *)&v157[4];
    *(_OWORD *)v157->f32 = xmmword_1D3E6B68C;
    *(_OWORD *)v157[2].f32 = unk_1D3E6B69C;
    v427 = v157;
    v158 = sub_1D3DB9928((float **)&v402, (const void **)&v427, (uint64_t)&v430);
    operator delete(v157);
    sub_1D3D6F2E0((unsigned int **)&v402);
    v159 = (char *)v430;
    if (v158)
    {
      v160 = *(float *)v430;
      v161 = *((float *)v430 + 1);
      v162 = *((float *)v430 + 2);
      v163 = *((float *)v430 + 3);
      v164 = *((float *)v430 + 6);
      v165 = *((float *)v430 + 7);
      v166 = (float32x2_t *)operator new(0x20uLL);
      v428 = v166 + 4;
      v429 = (char *)&v166[4];
      *(_OWORD *)v166->f32 = xmmword_1D3E6B6AC;
      *(_OWORD *)v166[2].f32 = unk_1D3E6B6BC;
      v427 = v166;
      (*(void (**)(unsigned int *, float32x2_t **))(*(_QWORD *)v424 + 16))(v424, &v427);
      v167 = v414;
      if (v414)
      {
        v168 = v414 + 2;
        do
          v169 = __ldxr(v168);
        while (__stxr(v169 + 1, v168));
      }
      v434[0] = v167;
      v170 = sub_1D3DD0144((uint64_t)v167, v391, sqrtf((float)((float)(v161 - v163) * (float)(v161 - v163))+ (float)((float)(v160 - v162) * (float)(v160 - v162)))/ 7.0, v427->f32[0], v427->f32[1], v427[1].f32[0], v427[1].f32[1]);
      sub_1D3D6D10C(v434);
      if ((v170 - 7) < 0xFFFFFFFA)
        goto LABEL_220;
      v171 = (float *)v414;
      if (v414)
      {
        v172 = v414 + 2;
        do
          v173 = __ldxr(v172);
        while (__stxr(v173 + 1, v172));
      }
      v423 = v171;
      v174 = sub_1D3DD0144((uint64_t)v171, v391, sqrtf((float)((float)(v161 - v165) * (float)(v161 - v165))+ (float)((float)(v160 - v164) * (float)(v160 - v164)))/ 7.0, v427[2].f32[0], v427[2].f32[1], v427[3].f32[0], v427[3].f32[1]);
      sub_1D3D6D10C((unsigned int **)&v423);
      if ((v174 - 7) >= 0xFFFFFFFA)
      {
        v176 = 2 * v170 + 7;
        v177 = 2 * v174 + 7;
        v179 = v176 - v177;
        v178 = v176 - v177 < 0;
        if (v176 <= v177)
          v176 = 2 * v174 + 7;
        if (v178)
          v180 = -v179;
        else
          v180 = v179;
        v175 = (float)v180 / (float)v176;
        v181 = v176 - 11;
        if (v175 >= v152)
        {
          if (v181 > 6)
            goto LABEL_220;
          if (v175 != v152 || v176 <= v417)
            goto LABEL_220;
        }
        else if (v181 > 6)
        {
          goto LABEL_220;
        }
        v183 = (unsigned int *)v150;
        v417 = v176;
        v150 = (float *)v424;
        if (v424)
        {
          v184 = v424 + 2;
          do
            v185 = __ldxr(v184);
          while (__stxr(v185 + 1, v184));
        }
        if (v183)
        {
          sub_1D3D6D13C(v183);
          v159 = (char *)v430;
        }
        v422 = v150;
        sub_1D3DD0324((char *)&__p, v159, (uint64_t)v431, (v431 - (unsigned __int8 *)v159) >> 2);
      }
      else
      {
LABEL_220:
        v175 = v152;
      }
      if (v427)
      {
        v428 = v427;
        operator delete(v427);
      }
      v152 = v175;
    }
    sub_1D3D6F2E0(&v424);
    sub_1D3DD0000(v159, v159 + 8, (char *)v431);
    if (++v151 != 4)
      continue;
    break;
  }
  if (v159)
  {
    v431 = (unsigned __int8 *)v159;
    operator delete(v159);
  }
  v186 = (unsigned int *)v422;
  v80 = v391;
  if (v422)
  {
    v187 = (unsigned int *)(v422 + 2);
    do
      v188 = __ldxr(v187);
    while (__stxr(v188 + 1, v187));
  }
  if (v416)
    sub_1D3D6D13C(v416);
  v416 = v186;
  sub_1D3D6F2E0((unsigned int **)&v422);
  sub_1D3D6D10C(&v414);
  if (v416)
    goto LABEL_253;
LABEL_268:
  sub_1D3D6F2E0(&v416);
  if (__p)
  {
    v419 = (char *)__p;
    operator delete(__p);
  }
LABEL_270:
  if (v81)
  {
    v83 = v81;
LABEL_124:
    operator delete(v83);
  }
  return sub_1D3D6D10C(&v421);
}

void sub_1D3DCFCB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unsigned int *a19, unsigned int *a20,unsigned int *a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,unsigned int *a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,unsigned int *a47)
{
  void *v47;
  uint64_t v48;
  void *v50;
  void *v51;
  void *v52;

  sub_1D3D7F7E4((unsigned int **)(v48 - 168));
  sub_1D3DC2944(&a19);
  sub_1D3D6F2E0(&a20);
  sub_1D3D6D10C(&a21);
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  v50 = *(void **)(v48 - 248);
  if (v50)
    operator delete(v50);
  v51 = *(void **)(v48 - 224);
  if (v51)
    operator delete(v51);
  v52 = *(void **)(v48 - 200);
  if (v52)
  {
    *(_QWORD *)(v48 - 192) = v52;
    operator delete(v52);
  }
  sub_1D3D6F2E0(&a39);
  if (a41)
  {
    a42 = (uint64_t)a41;
    operator delete(a41);
  }
  if (v47)
    operator delete(v47);
  sub_1D3D6D10C(&a47);
  sub_1D3D7F7E4(a14);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DCFF78(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *v12;

  v4 = *(_QWORD *)(*a2 + 56);
  v5 = -v4;
  v6 = *(_QWORD *)(*a2 + 32);
  v7 = v6 & -v4--;
  v8 = *(_QWORD *)(*a2 + 16);
  *(_BYTE *)a1 = a3;
  *(_QWORD *)(a1 + 8) = v8 & v4 | v7;
  *(_QWORD *)(a1 + 16) = v6 & v4 | v8 & v5;
  *(_QWORD *)(a1 + 24) = 0;
  v9 = *a2;
  if (*a2)
  {
    v10 = (unsigned int *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    v12 = *(unsigned int **)(a1 + 24);
    if (v12)
      sub_1D3D6D13C(v12);
  }
  *(_QWORD *)(a1 + 24) = v9;
  return a1;
}

char *sub_1D3DD0000(char *__src, char *a2, char *a3)
{
  _DWORD *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  int v7;
  BOOL v8;
  int v9;
  int64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int v16;
  int v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  BOOL v22;
  char v23;
  uint64_t v24;

  if (__src != a2 && a2 != a3)
  {
    v3 = __src;
    if (__src + 4 == a2)
    {
      v9 = *(_DWORD *)__src;
      v10 = a3 - a2;
      __src = (char *)memmove(__src, a2, a3 - a2);
      *(_DWORD *)((char *)v3 + v10) = v9;
    }
    else if (a2 + 4 == a3)
    {
      v11 = *((_DWORD *)a3 - 1);
      if (a3 - 4 != __src)
        __src = (char *)memmove(__src + 4, __src, a3 - 4 - __src);
      *v3 = v11;
    }
    else
    {
      v4 = (a2 - __src) >> 2;
      if (v4 == (a3 - a2) >> 2)
      {
        v5 = __src + 4;
        v6 = a2 + 4;
        do
        {
          v7 = *((_DWORD *)v5 - 1);
          *((_DWORD *)v5 - 1) = *((_DWORD *)v6 - 1);
          *((_DWORD *)v6 - 1) = v7;
          if (v5 == a2)
            break;
          v5 += 4;
          v8 = v6 == a3;
          v6 += 4;
        }
        while (!v8);
      }
      else
      {
        v12 = (a3 - a2) >> 2;
        v13 = (a2 - __src) >> 2;
        do
        {
          v14 = v13;
          v13 = v12;
          v12 = v14 % v12;
        }
        while (v12);
        if (v13)
        {
          v15 = &__src[4 * v13];
          do
          {
            v16 = *((_DWORD *)v15 - 1);
            v15 -= 4;
            v17 = v16;
            v18 = &v15[4 * v4];
            v19 = v15;
            do
            {
              v20 = v18;
              *(_DWORD *)v19 = *(_DWORD *)v18;
              v21 = &v18[4 * v4];
              v22 = __OFSUB__(v4, (a3 - v18) >> 2);
              v24 = v4 - ((a3 - v18) >> 2);
              v23 = (v24 < 0) ^ v22;
              v18 = &__src[4 * v24];
              if (v23)
                v18 = v21;
              v19 = v20;
            }
            while (v18 != v15);
            *(_DWORD *)v20 = v17;
          }
          while (v15 != __src);
        }
      }
    }
  }
  return __src;
}

uint64_t sub_1D3DD0144(uint64_t a1, int a2, float a3, float a4, float a5, float a6, float a7)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v15;
  uint64_t result;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  float v26;
  float v27;
  int v28;
  unsigned __int8 v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  BOOL v34;
  char v35;
  int v36;
  int v37;
  _BOOL4 v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;

  v7 = a5;
  v8 = a4;
  v9 = a6 - a4;
  v10 = a7 - a5;
  v11 = sqrtf((float)(v10 * v10) + (float)(v9 * v9));
  if (v11 < 0.00001)
    return 0xFFFFFFFFLL;
  v12 = (int)(float)(a3 * 0.5);
  if (v12 <= 1)
    v12 = 1;
  v43 = v12;
  v13 = (int)v8;
  if ((int)v8 < 0)
    return 0xFFFFFFFFLL;
  v15 = (int)v7;
  result = 0xFFFFFFFFLL;
  if ((v15 & 0x80000000) == 0)
  {
    v17 = *(_DWORD *)(a1 + 56);
    v18 = -v17;
    v19 = *(_DWORD *)(a1 + 32);
    v20 = v17 - 1;
    v21 = *(_DWORD *)(a1 + 16);
    v22 = v21 & v20 | v19 & v18;
    if (v13 < v22)
    {
      v23 = v19 & v20 | v21 & v18;
      if ((int)v15 < v23)
      {
        result = 0;
        v24 = (int)v11;
        if ((int)v11 >= 1)
        {
          v42 = (int)(float)((float)(a3 * 2.0) + 0.5);
          if ((v42 & 0x80000000) == 0)
          {
            v26 = v9 / v11;
            v27 = v10 / v11;
            LOBYTE(v28) = sub_1D3D6D4A0((_QWORD *)a1, (int)v8, v15);
            v29 = v28;
            v30 = 0;
            v31 = 0;
            v32 = 1;
            do
            {
              v33 = (int)v7;
              v34 = (int)v33 < v23 && v13 < v22;
              if (!v34 || (v33 & 0x80000000) != 0)
                break;
              v28 = sub_1D3D6D4A0((_QWORD *)a1, v13, v33);
              v35 = v29 ^ v28;
              v36 = v28 ^ a2;
              if (v30 < v43)
                v36 = 0;
              v37 = v31 + v36;
              if (((v29 ^ v28) & 1) != 0)
              {
                v29 = v28;
                v30 = 1;
              }
              else
              {
                ++v30;
              }
              if ((v35 & 1) != 0)
                v31 = v37;
              if (v32 >= v24)
                break;
              if (v30 > v42)
                break;
              v8 = v26 + v8;
              v7 = v27 + v7;
              v13 = (int)v8;
              ++v32;
            }
            while (((int)v8 & 0x80000000) == 0);
            v39 = v30 < v43 || v30 > v42;
            v40 = v31 - v39;
            if (((v28 ^ a2) & 1) != 0)
              v41 = v40;
            else
              v41 = v31;
            if (v31 >= 1)
              return v41;
            else
              return v31;
          }
        }
      }
    }
  }
  return result;
}

char *sub_1D3DD0324(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      sub_1D3D6D4F8();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = sub_1D3D8223C(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

unsigned int **sub_1D3DD0428(_QWORD *a1, unsigned int **a2, float **a3, uint64_t a4, _QWORD *a5, unsigned int **a6, int *a7, int a8)
{
  float *v15;
  unsigned int *v16;
  unsigned int v17;
  _BOOL4 v18;
  unsigned int *v19;
  unsigned int *v20;
  unsigned int v21;
  int v22;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  int v34;
  int v35;
  char *v36;
  int32x2_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v45;
  float v46;
  uint64_t v47;
  unsigned int *v48;
  float v49;
  float v50;
  float v51;
  uint64_t v52;
  float v53;
  float v54;
  float v55;
  unsigned int *v56;
  unsigned int **v57;
  unsigned int v58;
  unsigned int **v59;
  unsigned int **v60;
  unsigned int *v61;
  unsigned int *v62;
  unsigned int v63;
  unsigned int *v64;
  unsigned int *v65;
  unsigned int v66;
  unsigned int *v67;
  unsigned int *v68;
  unsigned int v69;
  unsigned int *v70;
  unsigned int **v71;
  unsigned int *v72;
  unsigned int *v73;
  unsigned int v74;
  unsigned int **v75;
  unsigned int *v76;
  unsigned int *v77;
  unsigned int v78;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  unsigned int *v85;
  unsigned int *v86;
  unsigned int *v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t *v90;
  unsigned int *v91;
  unsigned int v92;
  unsigned int *v93;
  unsigned int v94;
  _QWORD v95[3];
  unsigned int **v96[3];
  uint64_t (**v97)(_QWORD);
  int v98;
  uint64_t *v99;
  unsigned int *v100;
  unsigned int **v101;
  unsigned int **v102;
  unint64_t v103;
  void *__p;
  _BYTE *v105;
  char *v106;
  unsigned int *v107;
  uint64_t **v108;
  unsigned int *v109;
  unsigned int *v110;
  unsigned int *v111;
  float *v112;
  unsigned int *v113;
  unsigned int *v114[2];
  unsigned int *v115;
  unint64_t v116;
  unint64_t *v117;

  v113 = 0;
  if ((*a7 - 18) < 0xFFFFFFF9 || (*a7 & 1) == 0)
    goto LABEL_77;
  if (*(_QWORD *)a4 != *(_QWORD *)(a4 + 8) || *a5 != a5[1])
  {
    v15 = *a3;
    if (*a3)
    {
      v16 = (unsigned int *)(v15 + 2);
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
LABEL_10:
    v112 = v15;
    v18 = sub_1D3DB9928(&v112, (const void **)a4, (uint64_t)a5);
    sub_1D3D6F2E0((unsigned int **)&v112);
    if (!v18)
      goto LABEL_77;
    goto LABEL_11;
  }
  v15 = *a3;
  if (!*a3)
    goto LABEL_10;
LABEL_11:
  v111 = 0;
  v19 = *a2;
  if (*a2)
  {
    v20 = v19 + 2;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v110 = v19;
  v22 = *a7;
  v23 = (unsigned int *)*a3;
  if (*a3)
  {
    v24 = v23 + 2;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  v109 = v23;
  sub_1D3DB5B40((uint64_t *)v114, v19, v22, &v109, a8);
  v26 = v114[0];
  if (v114[0])
  {
    v27 = v114[0] + 2;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  if (v111)
    sub_1D3D6D13C(v111);
  v111 = v26;
  sub_1D3D6D10C(v114);
  sub_1D3DB45E8(&v109);
  sub_1D3D6D10C(&v110);
  v29 = v111;
  if (v111)
  {
    v30 = v111 + 2;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
    v107 = v29;
    sub_1D3E163D8(&v108, (uint64_t)v29);
    sub_1D3D6D10C(&v107);
    if (v108)
    {
      v32 = *((_DWORD *)sub_1D3D7F308(v108 + 12, 12, &dword_1D3E7565C) + 8);
      v33 = v32 - 5;
      v34 = 2 * v32 + 9;
      if (v33 < 0xFFFFFFFC)
        v35 = -1;
      else
        v35 = v34;
      *a7 = v35;
      v36 = (char *)operator new(0x20uLL);
      *(float *)v37.i32 = (float)v35;
      v105 = v36 + 32;
      v106 = v36 + 32;
      *(_QWORD *)v36 = 0;
      *((_DWORD *)v36 + 2) = 0;
      *(int32x4_t *)(v36 + 12) = vdupq_lane_s32(v37, 0);
      *((_DWORD *)v36 + 7) = 0;
      __p = v36;
      (*(void (**)(float *, void **))(*(_QWORD *)*a3 + 16))(*a3, &__p);
      v38 = *((_QWORD *)*a2 + 7);
      v39 = *((_QWORD *)*a2 + 4);
      v40 = *((_QWORD *)*a2 + 2);
      v101 = 0;
      v102 = 0;
      v103 = 0;
      if (v105 != __p)
      {
        v41 = 0;
        v42 = -v38;
        v43 = v39 & -v38;
        v44 = v38 - 1;
        v45 = (float)(v40 & v44 | (unint64_t)v43);
        v46 = (float)(v39 & v44 | v40 & (unint64_t)v42);
        do
        {
          v47 = operator new();
          v48 = (unsigned int *)v47;
          v49 = *((float *)__p + v41);
          if (v49 > 0.0)
            v50 = *((float *)__p + v41);
          else
            v50 = 0.0;
          if (v49 < v45)
            v51 = v50;
          else
            v51 = v45;
          v52 = (4 * v41) | 4;
          v53 = *(float *)((char *)__p + v52);
          if (v53 > 0.0)
            v54 = *(float *)((char *)__p + v52);
          else
            v54 = 0.0;
          if (v53 < v46)
            v55 = v54;
          else
            v55 = v46;
          *(_DWORD *)(v47 + 8) = 0;
          v56 = (unsigned int *)(v47 + 8);
          *(_QWORD *)v47 = &off_1E95AF250;
          *(float *)(v47 + 12) = v51;
          *(float *)(v47 + 16) = v55;
          v114[0] = (unsigned int *)v47;
          v57 = v102;
          if ((unint64_t)v102 >= v103)
          {
            v59 = (unsigned int **)sub_1D3DD1D5C((uint64_t)&v101, v114);
          }
          else
          {
            *v102 = 0;
            do
              v58 = __ldxr(v56);
            while (__stxr(v58 + 1, v56));
            if (*v57)
              sub_1D3D6D13C(*v57);
            *v57 = v48;
            v59 = v57 + 1;
          }
          v102 = v59;
          v41 += 2;
        }
        while (v41 < (v105 - (_BYTE *)__p) >> 2);
      }
      if (*((_DWORD *)sub_1D3D7F308(v108 + 12, 14, &dword_1D3E75664) + 8))
      {
        v60 = v101;
        v61 = v101[1];
        if (v61)
        {
          v62 = v61 + 2;
          do
            v63 = __ldxr(v62);
          while (__stxr(v63 + 1, v62));
        }
        v114[0] = v61;
        v64 = v60[3];
        if (v64)
        {
          v65 = v64 + 2;
          do
            v66 = __ldxr(v65);
          while (__stxr(v66 + 1, v65));
        }
        v67 = v60[1];
        if (v67)
        {
          sub_1D3D6D13C(v67);
          v61 = v114[0];
        }
        v60[1] = v64;
        if (v61)
        {
          v68 = v61 + 2;
          do
            v69 = __ldxr(v68);
          while (__stxr(v69 + 1, v68));
        }
        v70 = v60[3];
        if (v70)
          sub_1D3D6D13C(v70);
        v60[3] = v61;
        sub_1D3D6D834(v114);
      }
      v71 = v102;
      if ((unint64_t)v102 >= v103)
      {
        v80 = v102 - v101;
        if ((unint64_t)(v80 + 1) >> 61)
          sub_1D3D6D4F8();
        v81 = (uint64_t)(v103 - (_QWORD)v101) >> 2;
        if (v81 <= v80 + 1)
          v81 = v80 + 1;
        if (v103 - (unint64_t)v101 >= 0x7FFFFFFFFFFFFFF8)
          v82 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v82 = v81;
        v117 = &v103;
        if (v82)
          v82 = (unint64_t)sub_1D3D6D8A0(v82);
        else
          v83 = 0;
        v84 = (unsigned int *)(v82 + 8 * v80);
        v114[0] = (unsigned int *)v82;
        v114[1] = v84;
        v115 = v84;
        v116 = v82 + 8 * v83;
        *(_QWORD *)v84 = 0;
        v85 = *a6;
        v86 = v84;
        if (v85)
        {
          v87 = v85 + 2;
          do
            v88 = __ldxr(v87);
          while (__stxr(v88 + 1, v87));
          v86 = v84;
          if (*(_QWORD *)v84)
          {
            sub_1D3D6D13C(*(unsigned int **)v84);
            v86 = v115;
          }
        }
        *(_QWORD *)v84 = v85;
        v115 = v86 + 2;
        sub_1D3D8D220((unsigned int *)&v101, v114);
        v75 = v102;
        sub_1D3D8D31C((uint64_t)v114);
      }
      else
      {
        *v102 = 0;
        v72 = *a6;
        if (v72)
        {
          v73 = v72 + 2;
          do
            v74 = __ldxr(v73);
          while (__stxr(v74 + 1, v73));
          if (*v71)
            sub_1D3D6D13C(*v71);
        }
        *v71 = v72;
        v75 = v71 + 1;
      }
      v102 = v75;
      *((_DWORD *)sub_1D3D7F308(v108 + 12, 9, (unsigned int *)&unk_1D3E80D00) + 8) = a8;
      v89 = operator new();
      v99 = 0;
      v100 = 0;
      v98 = 0;
      v97 = &off_1E95AF9B0;
      v90 = v108[4];
      if (v90)
      {
        v91 = (unsigned int *)(v90 + 1);
        do
          v92 = __ldxr(v91);
        while (__stxr(v92 + 1, v91));
      }
      v99 = v90;
      memset(v96, 0, sizeof(v96));
      sub_1D3D6D6A8((unsigned int *)v96, v101, v102, v102 - v101);
      sub_1D3D7F3AC((uint64_t)v95, v108 + 12);
      sub_1D3E17B10(v89, (uint64_t *)&v100, (uint64_t)&v97, v96, 11, v95);
      v93 = (unsigned int *)(v89 + 8);
      do
        v94 = __ldxr(v93);
      while (__stxr(v94 + 1, v93));
      *a1 = v89;
      sub_1D3D7F520((_QWORD *)v95[1]);
      v114[0] = (unsigned int *)v96;
      sub_1D3D6D79C((void ***)v114);
      sub_1D3D7F558(&v97);
      sub_1D3D7F598(&v100);
      v114[0] = (unsigned int *)&v101;
      sub_1D3D6D79C((void ***)v114);
      if (__p)
      {
        v105 = __p;
        operator delete(__p);
      }
      sub_1D3D7F814((unsigned int **)&v108);
      sub_1D3D6D10C(&v111);
      return sub_1D3D7F7E4(&v113);
    }
    sub_1D3D7F814((unsigned int **)&v108);
  }
  sub_1D3D6D10C(&v111);
LABEL_77:
  *a1 = 0;
  v76 = v113;
  if (v113)
  {
    v77 = v113 + 2;
    do
      v78 = __ldxr(v77);
    while (__stxr(v78 + 1, v77));
  }
  *a1 = v76;
  return sub_1D3D7F7E4(&v113);
}

void sub_1D3DD0A80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,char a28,int a29,unsigned int *a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,int a38,unsigned int *a39)
{
  uint64_t v39;

  *(_QWORD *)(v39 - 152) = &a20;
  sub_1D3D6D79C((void ***)(v39 - 152));
  if (__p)
  {
    a26 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1D3D7F814(&a30);
  sub_1D3D6D10C(&a39);
  sub_1D3D7F7E4((unsigned int **)(v39 - 160));
  _Unwind_Resume(a1);
}

unint64_t sub_1D3DD0C4C(uint64_t a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;

  if (a3 < 1)
  {
    v21 = -1;
    v22 = 0xFFFFFFFFLL;
  }
  else
  {
    v7 = a3;
    v14 = *(_DWORD *)(a1 + 56);
    v15 = -v14;
    v16 = *(_DWORD *)(a1 + 32);
    v17 = v16 & -v14--;
    v18 = *(_DWORD *)(a1 + 16);
    v19 = v18 & v14 | v17;
    v20 = v16 & v14 | v18 & v15;
    while (1)
    {
      a4 = a4 + a6;
      a5 = a5 + a7;
      v21 = (int)a4;
      if (((int)a4 & 0x80000000) == 0)
      {
        v22 = (int)a5;
        if ((int)v22 < v20
          && (v22 & 0x80000000) == 0
          && (int)v21 < v19
          && sub_1D3D6D4A0((_QWORD *)a1, (int)a4, (int)a5) != a2)
        {
          break;
        }
      }
      if (!--v7)
      {
        v21 = -1;
        v22 = 0xFFFFFFFFLL;
        return v21 | (unint64_t)(v22 << 32);
      }
    }
  }
  return v21 | (unint64_t)(v22 << 32);
}

uint64_t sub_1D3DD0D40(uint64_t a1, int a2, unsigned int a3, int a4, float a5, float a6, float a7)
{
  int *v10;
  int *v11;
  int *v12;
  int *v13;
  int i;
  int j;
  float v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  int *v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  _QWORD *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  int v37;
  int *v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  int v47;

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  for (i = -1; i != 2; ++i)
  {
    for (j = -1; j != 2; ++j)
    {
      v16 = (float)((float)j * a6) + (float)((float)i * a5);
      if (v16 >= 0.00001)
      {
        if (v13 >= v12)
        {
          v17 = 0xAAAAAAAAAAAAAAABLL * (v13 - v10);
          v18 = v17 + 1;
          if (v17 + 1 > 0x1555555555555555)
            sub_1D3D6D4F8();
          if (0x5555555555555556 * (v12 - v10) > v18)
            v18 = 0x5555555555555556 * (v12 - v10);
          if (0xAAAAAAAAAAAAAAABLL * (v12 - v10) >= 0xAAAAAAAAAAAAAAALL)
            v19 = 0x1555555555555555;
          else
            v19 = v18;
          if (v19)
          {
            if (v19 > 0x1555555555555555)
              sub_1D3D6D50C();
            v20 = (char *)operator new(12 * v19);
            v13 = v11;
          }
          else
          {
            v20 = 0;
          }
          v21 = &v20[12 * v17];
          *(_DWORD *)v21 = i;
          *((_DWORD *)v21 + 1) = j;
          *((float *)v21 + 2) = v16;
          v22 = (int *)v21;
          while (v13 != v10)
          {
            v23 = *(_QWORD *)(v13 - 3);
            v13 -= 3;
            v24 = v13[2];
            *(_QWORD *)(v22 - 3) = v23;
            v22 -= 3;
            v22[2] = v24;
          }
          v12 = (int *)&v20[12 * v19];
          v11 = (int *)(v21 + 12);
          if (v10)
            operator delete(v10);
          v10 = v22;
        }
        else
        {
          *v13 = i;
          v13[1] = j;
          *((float *)v13 + 2) = v16;
          v11 = v13 + 3;
        }
        v13 = v11;
      }
    }
  }
  v25 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v13 - v10));
  if (v13 == v10)
    v26 = 0;
  else
    v26 = v25;
  sub_1D3DD110C((uint64_t)v10, (unint64_t)v13, v26, 1);
  if (a7 <= 0.0)
    goto LABEL_44;
  v27 = 0;
  v28 = *(_QWORD **)a1;
  v29 = *(_DWORD *)(*(_QWORD *)a1 + 56);
  v30 = -v29;
  v31 = *(_DWORD *)(*(_QWORD *)a1 + 32);
  v32 = v31 & -v29--;
  v33 = *(_DWORD *)(*(_QWORD *)a1 + 16);
  v34 = v33 & v29 | v32;
  v35 = v31 & v29 | v33 & v30;
  v37 = a2;
  v36 = a3;
LABEL_30:
  if (v10 == v11)
  {
LABEL_44:
    LODWORD(v39) = a2;
    v41 = a3;
LABEL_45:
    if (v10)
LABEL_46:
      operator delete(v10);
  }
  else
  {
    v47 = v27;
    v38 = v10;
    do
    {
      v39 = (*v38 + v37);
      if (*v38 + v37 >= 0)
      {
        v40 = v38[1];
        v41 = v40 + v36;
        v42 = (int)(v40 + v36) < v35 && (int)v39 < v34;
        if (v42 && (v41 & 0x80000000) == 0 && sub_1D3D6D4A0(v28, v39, v40 + v36) != a4)
        {
          v27 = v47 + 1;
          v37 = v39;
          v36 = v41;
          if ((float)(v47 + 1) < a7)
            goto LABEL_30;
          goto LABEL_45;
        }
      }
      v38 += 3;
    }
    while (v38 != v11);
    v41 = v36;
    LODWORD(v39) = v37;
    if (v10)
      goto LABEL_46;
  }
  if (a6 <= 0.0)
    v43 = v41;
  else
    v43 = v41 + 1;
  if (a5 <= 0.0)
    v44 = v39;
  else
    v44 = (v39 + 1);
  return v44 | (v43 << 32);
}

void sub_1D3DD1014(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void sub_1D3DD1034(uint64_t a1, _DWORD *a2)
{
  unint64_t v4;
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  unint64_t v15;
  int v16;

  v5 = *(_DWORD **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    v7 = *(_DWORD **)a1;
    v8 = ((uint64_t)v5 - *(_QWORD *)a1) >> 2;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62)
      sub_1D3D6D4F8();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 1 > v9)
      v9 = v10 >> 1;
    v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL;
    v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11)
      v12 = v9;
    if (v12)
    {
      v12 = (unint64_t)sub_1D3D82278(v12);
      v7 = *(_DWORD **)a1;
      v5 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = (_DWORD *)(v12 + 4 * v8);
    v15 = v12 + 4 * v13;
    *v14 = *a2;
    v6 = v14 + 1;
    while (v5 != v7)
    {
      v16 = *--v5;
      *--v14 = v16;
    }
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = v15;
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }
  *(_QWORD *)(a1 + 8) = v6;
}

uint64_t sub_1D3DD110C(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  float *v14;
  float *v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  float *v22;
  float v23;
  unint64_t v24;
  float v25;
  float *v26;
  float v27;
  int v28;
  int v29;
  float v30;
  float v31;
  BOOL v32;
  uint64_t v33;
  float v34;
  unint64_t v35;
  float v36;
  float *v37;
  unint64_t v38;
  float v39;
  uint64_t v40;
  float v41;
  int v42;
  int v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  int v49;
  float v50;
  float v51;
  int v52;
  int v53;
  float v54;
  float v55;
  int v56;
  int v57;
  uint64_t v58;
  float v59;
  uint64_t v60;
  float v61;
  uint64_t v62;
  _QWORD *v63;
  BOOL v65;
  uint64_t v66;
  _QWORD *v67;
  float v68;
  float v69;
  uint64_t v70;
  uint64_t v71;
  float *v72;
  int v73;
  uint64_t v74;
  int64_t v75;
  int64_t v76;
  int64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  float v81;
  float v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int64_t v87;
  int64_t v88;
  float v89;
  int v90;
  float v91;
  unint64_t v92;
  _DWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  float v99;
  uint64_t v100;
  unint64_t v101;
  _DWORD *v103;
  float v104;
  float v105;
  uint64_t v106;
  _DWORD *v107;
  int v108;
  float v109;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = a2 - v8;
    v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v8) >> 2);
    switch(v10)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v46 = *(float *)(a2 - 4);
        v47 = *(float *)(v8 + 8);
        if (v46 > v47)
        {
          v48 = *(float *)v8;
          *(_DWORD *)v8 = *(_DWORD *)(a2 - 12);
          *(float *)(a2 - 12) = v48;
          v49 = *(_DWORD *)(v8 + 4);
          *(_DWORD *)(v8 + 4) = *(_DWORD *)(a2 - 8);
          *(_DWORD *)(a2 - 8) = v49;
          *(float *)(v8 + 8) = v46;
          *(float *)(a2 - 4) = v47;
        }
        return result;
      case 3:
        return (uint64_t)sub_1D3DD1938((float *)v8, (float *)(v8 + 12), (float *)(a2 - 12));
      case 4:
        return (uint64_t)sub_1D3DD1A44(v8, v8 + 12, v8 + 24, a2 - 12);
      case 5:
        result = (uint64_t)sub_1D3DD1A44(v8, v8 + 12, v8 + 24, v8 + 36);
        v50 = *(float *)(a2 - 4);
        v51 = *(float *)(v8 + 44);
        if (v50 > v51)
        {
          v52 = *(_DWORD *)(v8 + 36);
          *(_DWORD *)(v8 + 36) = *(_DWORD *)(a2 - 12);
          *(_DWORD *)(a2 - 12) = v52;
          v53 = *(_DWORD *)(v8 + 40);
          *(_DWORD *)(v8 + 40) = *(_DWORD *)(a2 - 8);
          *(_DWORD *)(a2 - 8) = v53;
          *(float *)(v8 + 44) = v50;
          *(float *)(a2 - 4) = v51;
          v54 = *(float *)(v8 + 44);
          v55 = *(float *)(v8 + 32);
          if (v54 > v55)
          {
            v56 = *(_DWORD *)(v8 + 36);
            v57 = *(_DWORD *)(v8 + 40);
            v58 = *(_QWORD *)(v8 + 24);
            *(_DWORD *)(v8 + 24) = v56;
            *(_DWORD *)(v8 + 28) = v57;
            *(_QWORD *)(v8 + 36) = v58;
            *(float *)(v8 + 32) = v54;
            *(float *)(v8 + 44) = v55;
            v59 = *(float *)(v8 + 20);
            if (v54 > v59)
            {
              v60 = *(_QWORD *)(v8 + 12);
              *(_DWORD *)(v8 + 12) = v56;
              *(_DWORD *)(v8 + 16) = v57;
              *(_QWORD *)(v8 + 24) = v60;
              *(float *)(v8 + 20) = v54;
              *(float *)(v8 + 32) = v59;
              v61 = *(float *)(v8 + 8);
              if (v54 > v61)
              {
                v62 = *(_QWORD *)v8;
                *(_DWORD *)v8 = v56;
                *(_DWORD *)(v8 + 4) = v57;
                *(_QWORD *)(v8 + 12) = v62;
                *(float *)(v8 + 8) = v54;
                *(float *)(v8 + 20) = v61;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 287)
        {
          v63 = (_QWORD *)(v8 + 12);
          v65 = v8 == a2 || v63 == (_QWORD *)a2;
          if ((a4 & 1) != 0)
          {
            if (!v65)
            {
              v66 = 0;
              v67 = (_QWORD *)v8;
              do
              {
                v68 = *((float *)v67 + 5);
                v69 = *((float *)v67 + 2);
                v67 = v63;
                if (v68 > v69)
                {
                  v70 = *v63;
                  v71 = v66;
                  while (1)
                  {
                    v72 = (float *)(v8 + v71);
                    v73 = *(_DWORD *)(v8 + v71 + 4);
                    v72[3] = *(float *)(v8 + v71);
                    *((_DWORD *)v72 + 4) = v73;
                    v72[5] = *(float *)(v8 + v71 + 8);
                    if (!v71)
                      break;
                    v71 -= 12;
                    if (v68 <= *(v72 - 1))
                    {
                      v74 = v8 + v71 + 12;
                      goto LABEL_80;
                    }
                  }
                  v74 = v8;
LABEL_80:
                  *(_QWORD *)v74 = v70;
                  *(float *)(v74 + 8) = v68;
                }
                v63 = (_QWORD *)((char *)v67 + 12);
                v66 += 12;
              }
              while ((_QWORD *)((char *)v67 + 12) != (_QWORD *)a2);
            }
          }
          else if (!v65)
          {
            v103 = (_DWORD *)(v8 + 8);
            do
            {
              v104 = *(float *)(v7 + 20);
              v105 = *(float *)(v7 + 8);
              v7 = (uint64_t)v63;
              if (v104 > v105)
              {
                v106 = *v63;
                v107 = v103;
                do
                {
                  v108 = *(v107 - 1);
                  v107[1] = *(v107 - 2);
                  v107[2] = v108;
                  v107[3] = *v107;
                  v109 = *((float *)v107 - 3);
                  v107 -= 3;
                }
                while (v104 > v109);
                *(_QWORD *)(v107 + 1) = v106;
                *((float *)v107 + 3) = v104;
              }
              v63 = (_QWORD *)(v7 + 12);
              v103 += 3;
            }
            while (v7 + 12 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 == a2)
            return result;
          v75 = (unint64_t)(v10 - 2) >> 1;
          v76 = v75;
          do
          {
            v77 = v76;
            if (v75 >= v76)
            {
              v78 = (2 * v76) | 1;
              v79 = v8 + 12 * v78;
              if (2 * v77 + 2 < v10 && *(float *)(v79 + 8) > *(float *)(v79 + 20))
              {
                v79 += 12;
                v78 = 2 * v77 + 2;
              }
              v80 = v8 + 12 * v77;
              v81 = *(float *)(v79 + 8);
              v82 = *(float *)(v80 + 8);
              if (v81 <= v82)
              {
                v83 = *(_QWORD *)v80;
                do
                {
                  v84 = v80;
                  v80 = v79;
                  *(_DWORD *)v84 = *(_DWORD *)v79;
                  *(_DWORD *)(v84 + 4) = *(_DWORD *)(v79 + 4);
                  *(float *)(v84 + 8) = v81;
                  if (v75 < v78)
                    break;
                  v85 = 2 * v78;
                  v78 = (2 * v78) | 1;
                  v79 = v8 + 12 * v78;
                  v86 = v85 + 2;
                  if (v86 < v10 && *(float *)(v79 + 8) > *(float *)(v79 + 20))
                  {
                    v79 += 12;
                    v78 = v86;
                  }
                  v81 = *(float *)(v79 + 8);
                }
                while (v81 <= v82);
                *(_QWORD *)v80 = v83;
                *(float *)(v80 + 8) = v82;
              }
            }
            v76 = v77 - 1;
          }
          while (v77);
          v87 = v9 / 0xCuLL;
          while (2)
          {
            v88 = 0;
            v89 = *(float *)v8;
            v90 = *(_DWORD *)(v8 + 4);
            v91 = *(float *)(v8 + 8);
            v92 = v8;
            do
            {
              v93 = (_DWORD *)v92;
              v92 += 12 * v88 + 12;
              v94 = 2 * v88;
              result = (2 * v88) | 1;
              v88 = result;
              v95 = v94 + 2;
              if (v95 < v87 && *(float *)(v92 + 8) > *(float *)(v92 + 20))
              {
                v92 += 12;
                v88 = v95;
              }
              *v93 = *(_DWORD *)v92;
              v93[1] = *(_DWORD *)(v92 + 4);
              v93[2] = *(_DWORD *)(v92 + 8);
            }
            while (v88 <= (uint64_t)((unint64_t)(v87 - 2) >> 1));
            if (v92 != a2 - 12)
            {
              *(_DWORD *)v92 = *(_DWORD *)(a2 - 12);
              *(_DWORD *)(v92 + 4) = *(_DWORD *)(a2 - 8);
              *(_DWORD *)(v92 + 8) = *(_DWORD *)(a2 - 4);
              *(float *)(a2 - 12) = v89;
              *(_DWORD *)(a2 - 8) = v90;
              *(float *)(a2 - 4) = v91;
              v96 = v92 - v8 + 12;
              if (v96 >= 13)
              {
                v97 = (v96 / 0xCuLL - 2) >> 1;
                v98 = v8 + 12 * v97;
                v99 = *(float *)(v98 + 8);
                v91 = *(float *)(v92 + 8);
                if (v99 > v91)
                {
                  v100 = *(_QWORD *)v92;
                  do
                  {
                    v101 = v92;
                    v92 = v98;
                    *(_DWORD *)v101 = *(_DWORD *)v98;
                    *(_DWORD *)(v101 + 4) = *(_DWORD *)(v98 + 4);
                    *(float *)(v101 + 8) = v99;
                    if (!v97)
                      break;
                    v97 = (v97 - 1) >> 1;
                    v98 = v8 + 12 * v97;
                    v99 = *(float *)(v98 + 8);
                  }
                  while (v99 > v91);
                  *(_QWORD *)v92 = v100;
LABEL_112:
                  *(float *)(v92 + 8) = v91;
                }
              }
              a2 -= 12;
              if (v87-- <= 2)
                return result;
              continue;
            }
            break;
          }
          *(float *)v92 = v89;
          *(_DWORD *)(v92 + 4) = v90;
          goto LABEL_112;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = v8 + 12 * ((unint64_t)v10 >> 1);
        if ((unint64_t)v9 < 0x601)
        {
          result = (uint64_t)sub_1D3DD1938((float *)(v7 + 12 * v11), (float *)v7, (float *)(a2 - 12));
        }
        else
        {
          sub_1D3DD1938((float *)v7, (float *)(v7 + 12 * v11), (float *)(a2 - 12));
          v13 = 3 * v11;
          v14 = (float *)(v7 + 12 * v11 - 12);
          sub_1D3DD1938((float *)(v7 + 12), v14, (float *)(a2 - 24));
          v15 = (float *)(v7 + 12 + 4 * v13);
          sub_1D3DD1938((float *)(v7 + 24), v15, (float *)(a2 - 36));
          result = (uint64_t)sub_1D3DD1938(v14, (float *)v12, v15);
          v16 = *(_QWORD *)v7;
          *(_QWORD *)v7 = *(_QWORD *)v12;
          *(_QWORD *)v12 = v16;
          LODWORD(v16) = *(_DWORD *)(v7 + 8);
          *(_DWORD *)(v7 + 8) = *(_DWORD *)(v12 + 8);
          *(_DWORD *)(v12 + 8) = v16;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v17 = *(float *)(v7 + 8);
          if (*(float *)(v7 - 4) > v17)
            goto LABEL_12;
          if (v17 <= *(float *)(a2 - 4))
          {
            v35 = v7 + 12;
            do
            {
              v8 = v35;
              if (v35 >= a2)
                break;
              v36 = *(float *)(v35 + 8);
              v35 += 12;
            }
            while (v17 <= v36);
          }
          else
          {
            v33 = v7;
            do
            {
              v8 = v33 + 12;
              v34 = *(float *)(v33 + 20);
              v33 += 12;
            }
            while (v17 <= v34);
          }
          v37 = (float *)a2;
          if (v8 < a2)
          {
            v38 = a2;
            do
            {
              v37 = (float *)(v38 - 12);
              v39 = *(float *)(v38 - 4);
              v38 -= 12;
            }
            while (v17 > v39);
          }
          v40 = *(_QWORD *)v7;
          while (v8 < (unint64_t)v37)
          {
            v41 = *(float *)v8;
            *(float *)v8 = *v37;
            *v37 = v41;
            v42 = *(_DWORD *)(v8 + 4);
            *(float *)(v8 + 4) = v37[1];
            *((_DWORD *)v37 + 1) = v42;
            v43 = *(_DWORD *)(v8 + 8);
            *(float *)(v8 + 8) = v37[2];
            *((_DWORD *)v37 + 2) = v43;
            do
            {
              v44 = *(float *)(v8 + 20);
              v8 += 12;
            }
            while (v17 <= v44);
            do
            {
              v45 = *(v37 - 1);
              v37 -= 3;
            }
            while (v17 > v45);
          }
          if (v8 - 12 != v7)
          {
            *(_DWORD *)v7 = *(_DWORD *)(v8 - 12);
            *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 8);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(v8 - 4);
          }
          a4 = 0;
          *(_QWORD *)(v8 - 12) = v40;
          *(float *)(v8 - 4) = v17;
          continue;
        }
        v17 = *(float *)(v7 + 8);
LABEL_12:
        v18 = *(_QWORD *)v7;
        v19 = v7;
        do
        {
          v20 = v19;
          v19 += 12;
        }
        while (*(float *)(v20 + 20) > v17);
        v21 = a2;
        if (v20 == v7)
        {
          v24 = a2;
          while (v19 < v24)
          {
            v22 = (float *)(v24 - 12);
            v25 = *(float *)(v24 - 4);
            v24 -= 12;
            if (v25 > v17)
              goto LABEL_22;
          }
          v22 = (float *)v24;
        }
        else
        {
          do
          {
            v22 = (float *)(v21 - 12);
            v23 = *(float *)(v21 - 4);
            v21 -= 12;
          }
          while (v23 <= v17);
        }
LABEL_22:
        v8 = v19;
        if (v19 < (unint64_t)v22)
        {
          v26 = v22;
          do
          {
            v27 = *(float *)v8;
            *(float *)v8 = *v26;
            *v26 = v27;
            v28 = *(_DWORD *)(v8 + 4);
            *(float *)(v8 + 4) = v26[1];
            *((_DWORD *)v26 + 1) = v28;
            v29 = *(_DWORD *)(v8 + 8);
            *(float *)(v8 + 8) = v26[2];
            *((_DWORD *)v26 + 2) = v29;
            do
            {
              v30 = *(float *)(v8 + 20);
              v8 += 12;
            }
            while (v30 > v17);
            do
            {
              v31 = *(v26 - 1);
              v26 -= 3;
            }
            while (v31 <= v17);
          }
          while (v8 < (unint64_t)v26);
        }
        if (v8 - 12 != v7)
        {
          *(_DWORD *)v7 = *(_DWORD *)(v8 - 12);
          *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 8);
          *(_DWORD *)(v7 + 8) = *(_DWORD *)(v8 - 4);
        }
        *(_QWORD *)(v8 - 12) = v18;
        *(float *)(v8 - 4) = v17;
        if (v19 < (unint64_t)v22)
        {
LABEL_33:
          result = sub_1D3DD110C(v7, v8 - 12, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v32 = sub_1D3DD1B20(v7, v8 - 12);
        result = sub_1D3DD1B20(v8, a2);
        if (!(_DWORD)result)
        {
          if (v32)
            continue;
          goto LABEL_33;
        }
        a2 = v8 - 12;
        if (!v32)
          goto LABEL_2;
        return result;
    }
  }
}

float *sub_1D3DD1938(float *result, float *a2, float *a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  int v7;
  float v8;
  int v9;
  float v10;
  float v11;
  float v12;
  int v13;
  int v14;
  float v15;
  float v16;
  int v17;

  v3 = a2[2];
  v4 = result[2];
  v5 = a3[2];
  if (v3 <= v4)
  {
    if (v5 > v3)
    {
      v8 = *a2;
      *a2 = *a3;
      *a3 = v8;
      v9 = *((_DWORD *)a2 + 1);
      a2[1] = a3[1];
      *((_DWORD *)a3 + 1) = v9;
      a2[2] = v5;
      a3[2] = v3;
      v10 = a2[2];
      v11 = result[2];
      if (v10 > v11)
      {
        v12 = *result;
        *result = *a2;
        *a2 = v12;
        v13 = *((_DWORD *)result + 1);
        result[1] = a2[1];
        *((_DWORD *)a2 + 1) = v13;
        result[2] = v10;
        a2[2] = v11;
      }
    }
  }
  else
  {
    v6 = *result;
    if (v5 <= v3)
    {
      *result = *a2;
      *a2 = v6;
      v14 = *((_DWORD *)result + 1);
      result[1] = a2[1];
      *((_DWORD *)a2 + 1) = v14;
      result[2] = v3;
      a2[2] = v4;
      v15 = a3[2];
      if (v15 <= v4)
        return result;
      v16 = *a2;
      *a2 = *a3;
      *a3 = v16;
      v17 = *((_DWORD *)a2 + 1);
      a2[1] = a3[1];
      *((_DWORD *)a3 + 1) = v17;
      a2[2] = v15;
    }
    else
    {
      *result = *a3;
      *a3 = v6;
      v7 = *((_DWORD *)result + 1);
      result[1] = a3[1];
      *((_DWORD *)a3 + 1) = v7;
      result[2] = v5;
    }
    a3[2] = v4;
  }
  return result;
}

float *sub_1D3DD1A44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float *result;
  float v9;
  float v10;
  float v11;
  int v12;
  float v13;
  float v14;
  float v15;
  int v16;
  float v17;
  float v18;
  float v19;
  int v20;

  result = sub_1D3DD1938((float *)a1, (float *)a2, (float *)a3);
  v9 = *(float *)(a4 + 8);
  v10 = *(float *)(a3 + 8);
  if (v9 > v10)
  {
    v11 = *(float *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(float *)a4 = v11;
    v12 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 4) = v12;
    *(float *)(a3 + 8) = v9;
    *(float *)(a4 + 8) = v10;
    v13 = *(float *)(a3 + 8);
    v14 = *(float *)(a2 + 8);
    if (v13 > v14)
    {
      v15 = *(float *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v15;
      v16 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 4) = v16;
      *(float *)(a2 + 8) = v13;
      *(float *)(a3 + 8) = v14;
      v17 = *(float *)(a2 + 8);
      v18 = *(float *)(a1 + 8);
      if (v17 > v18)
      {
        v19 = *(float *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(float *)a2 = v19;
        v20 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v20;
        *(float *)(a1 + 8) = v17;
        *(float *)(a2 + 8) = v18;
      }
    }
  }
  return result;
}

BOOL sub_1D3DD1B20(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  float v6;
  float v7;
  float v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  float v20;
  float v21;
  int v22;
  int v23;
  float v24;
  float v25;
  int v26;
  int v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  float v31;
  uint64_t v32;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 2);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = *(float *)(a2 - 4);
      v7 = *(float *)(a1 + 8);
      if (v6 > v7)
      {
        v8 = *(float *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 12);
        *(float *)(a2 - 12) = v8;
        v9 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v9;
        *(float *)(a1 + 8) = v6;
        *(float *)(a2 - 4) = v7;
      }
      return result;
    case 3uLL:
      sub_1D3DD1938((float *)a1, (float *)(a1 + 12), (float *)(a2 - 12));
      return 1;
    case 4uLL:
      sub_1D3DD1A44(a1, a1 + 12, a1 + 24, a2 - 12);
      return 1;
    case 5uLL:
      sub_1D3DD1A44(a1, a1 + 12, a1 + 24, a1 + 36);
      v20 = *(float *)(a2 - 4);
      v21 = *(float *)(a1 + 44);
      if (v20 > v21)
      {
        v22 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 - 12);
        *(_DWORD *)(a2 - 12) = v22;
        v23 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v23;
        *(float *)(a1 + 44) = v20;
        *(float *)(a2 - 4) = v21;
        v24 = *(float *)(a1 + 44);
        v25 = *(float *)(a1 + 32);
        if (v24 > v25)
        {
          v26 = *(_DWORD *)(a1 + 36);
          v27 = *(_DWORD *)(a1 + 40);
          v28 = *(_QWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 24) = v26;
          *(_DWORD *)(a1 + 28) = v27;
          *(_QWORD *)(a1 + 36) = v28;
          *(float *)(a1 + 32) = v24;
          *(float *)(a1 + 44) = v25;
          v29 = *(float *)(a1 + 20);
          if (v24 > v29)
          {
            v30 = *(_QWORD *)(a1 + 12);
            *(_DWORD *)(a1 + 12) = v26;
            *(_DWORD *)(a1 + 16) = v27;
            *(_QWORD *)(a1 + 24) = v30;
            *(float *)(a1 + 20) = v24;
            *(float *)(a1 + 32) = v29;
            v31 = *(float *)(a1 + 8);
            if (v24 > v31)
            {
              v32 = *(_QWORD *)a1;
              *(_DWORD *)a1 = v26;
              *(_DWORD *)(a1 + 4) = v27;
              *(_QWORD *)(a1 + 12) = v32;
              *(float *)(a1 + 8) = v24;
              *(float *)(a1 + 20) = v31;
            }
          }
        }
      }
      return 1;
    default:
      v10 = a1 + 24;
      sub_1D3DD1938((float *)a1, (float *)(a1 + 12), (float *)(a1 + 24));
      v11 = a1 + 36;
      if (a1 + 36 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    v14 = *(float *)(v11 + 8);
    if (v14 > *(float *)(v10 + 8))
    {
      v15 = *(_QWORD *)v11;
      v16 = v12;
      while (1)
      {
        v17 = a1 + v16;
        v18 = *(_DWORD *)(a1 + v16 + 28);
        *(_DWORD *)(v17 + 36) = *(_DWORD *)(a1 + v16 + 24);
        *(_DWORD *)(v17 + 40) = v18;
        *(_DWORD *)(v17 + 44) = *(_DWORD *)(a1 + v16 + 32);
        if (v16 == -24)
          break;
        v16 -= 12;
        if (v14 <= *(float *)(v17 + 20))
        {
          v19 = a1 + v16 + 36;
          goto LABEL_13;
        }
      }
      v19 = a1;
LABEL_13:
      *(_QWORD *)v19 = v15;
      *(float *)(v19 + 8) = v14;
      if (++v13 == 8)
        return v11 + 12 == a2;
    }
    v10 = v11;
    v12 += 12;
    v11 += 12;
    if (v11 == a2)
      return 1;
  }
}

uint64_t sub_1D3DD1D5C(uint64_t a1, unsigned int **a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int **v10;
  unsigned int *v11;
  unsigned int **v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD v17[2];
  unsigned int **v18;
  unint64_t v19;
  uint64_t v20;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61)
    sub_1D3D6D4F8();
  v6 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
  if (v7 >> 2 > v3)
    v3 = v7 >> 2;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8)
    v8 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v8 = v3;
  v20 = v6;
  if (v8)
    v8 = (unint64_t)sub_1D3D6D8A0(v8);
  else
    v9 = 0;
  v10 = (unsigned int **)(v8 + 8 * v2);
  v17[0] = v8;
  v17[1] = v10;
  v18 = v10;
  v19 = v8 + 8 * v9;
  v11 = *a2;
  *v10 = 0;
  v12 = v10;
  if (v11)
  {
    v13 = v11 + 2;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    v12 = v10;
    if (*v10)
    {
      sub_1D3D6D13C(*v10);
      v12 = v18;
    }
  }
  *v10 = v11;
  v18 = v12 + 1;
  sub_1D3D8D220((unsigned int *)a1, v17);
  v15 = *(_QWORD *)(a1 + 8);
  sub_1D3D8D31C((uint64_t)v17);
  return v15;
}

void sub_1D3DD1E54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1D3D8D31C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1D3DD1E68(uint64_t result)
{
  float v1;
  int v2;
  float v3;
  int v4;
  unint64_t v5;
  float v6;
  int v7;
  float v8;

  v1 = *(float *)(result + 28) * *(float *)(result + 24);
  v2 = *(_DWORD *)(result + 124);
  v3 = (float)*(int *)(result + 120);
  v4 = (int)fmaxf(v3 - v1, 0.0);
  v5 = *(_QWORD *)(result + 48);
  v6 = v1 + v3;
  if (v6 >= (float)((float)*(unint64_t *)(result + 40) + -1.0))
    v6 = (float)*(unint64_t *)(result + 40) + -1.0;
  *(_DWORD *)(result + 128) = v4;
  *(_DWORD *)(result + 132) = (int)v6;
  v7 = (int)fmaxf((float)v2 - v1, 0.0);
  v8 = v1 + (float)v2;
  if (v8 >= (float)((float)v5 + -1.0))
    v8 = (float)v5 + -1.0;
  *(_DWORD *)(result + 136) = v7;
  *(_DWORD *)(result + 140) = (int)v8;
  return result;
}

int32x4_t *sub_1D3DD1EDC(int32x4_t *result, int32x4_t *a2, uint64_t a3, char a4)
{
  int32x4_t *v7;
  int32x4_t *v8;
  int32x4_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int32x4_t *v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  __int8 v17;
  int32x4_t v18;
  int32x4_t v19;
  __int8 v20;
  int32x4_t v21;
  int32x4_t v22;
  unint64_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  __int8 v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t *v31;
  int32x4_t *v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int32x4_t v36;
  __int8 v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  __int8 v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t *v46;
  int32x4_t *v47;
  int32x4_t *v48;
  int32x4_t *v49;
  int v50;
  int32x4_t *v51;
  int v52;
  int32x4_t *v53;
  int32x4_t *v54;
  int32x4_t v55;
  int v56;
  BOOL v57;
  int32x4_t *v58;
  int v59;
  int32x4_t *v60;
  int v61;
  int32x4_t *v62;
  int32x4_t *v63;
  int v64;
  int32x4_t v65;
  int v66;
  int v67;
  int32x4_t *v68;
  int32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  __int8 v73;
  int32x4_t *v74;
  int32x4_t v75;
  int32x4_t *v76;
  int32x4_t v77;
  int32x4_t v78;
  __int8 v79;
  int32x4_t *v80;
  BOOL v82;
  uint64_t v83;
  int32x4_t *v84;
  int32x4_t v85;
  int v86;
  uint64_t v87;
  int v88;
  int32x4_t *v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  uint64_t v93;
  int32x4_t *v94;
  __int32 v95;
  __int32 v96;
  int32x4_t *v97;
  int32x4_t v98;
  int v99;
  int32x4_t *v100;
  uint64_t v101;
  uint64_t v102;
  __int32 v103;
  __int32 v104;
  uint64_t v105;
  uint64_t v106;
  int32x4_t v107;
  _OWORD *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  uint64_t v114;
  unint64_t v115;
  int32x4_t *v116;
  int32x4_t v117;
  __int32 v118;
  int32x4_t *v119;
  int32x4_t v121;
  int32x4_t *v122;
  int32x4_t v123;
  int v124;
  int32x4_t *v125;
  int32x4_t v126;
  int32x4_t v127;
  int32x4_t v128;

  v7 = result;
LABEL_2:
  v8 = a2 - 1;
  v9 = v7;
  while (2)
  {
    v7 = v9;
    v10 = (char *)a2 - (char *)v9;
    v11 = a2 - v9;
    switch(v11)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v69 = *v9;
        if ((vmovn_s32(vcgtq_s32(*v9, *v8)).i32[1] & 1) != 0)
        {
          *v9 = *v8;
          *v8 = v69;
        }
        return result;
      case 3:
        v70 = *v9;
        v71 = v9[1];
        v72 = *v8;
        v73 = vmovn_s32(vcgtq_s32(v71, *v8)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v9, v71)).i32[1] & 1) != 0)
        {
          if ((v73 & 1) != 0)
          {
            *v9 = v72;
          }
          else
          {
            *v9 = v71;
            v9[1] = v70;
            if ((vmovn_s32(vcgtq_s32(v70, *v8)).i32[1] & 1) == 0)
              return result;
            v9[1] = *v8;
          }
          *v8 = v70;
        }
        else if ((v73 & 1) != 0)
        {
          v9[1] = v72;
          *v8 = v71;
          v121 = v9[1];
          goto LABEL_180;
        }
        return result;
      case 4:
        v74 = v9 + 1;
        v75 = v9[1];
        v76 = v9 + 2;
        v77 = v9[2];
        v78 = *v9;
        v79 = vmovn_s32(vcgtq_s32(v75, v77)).i8[4];
        if ((vmovn_s32(vcgtq_s32(*v9, v75)).i32[1] & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            *v9 = v77;
          }
          else
          {
            *v9 = v75;
            v9[1] = v78;
            if ((vmovn_s32(vcgtq_s32(v78, v77)).i32[1] & 1) == 0)
              goto LABEL_177;
            *v74 = v77;
          }
          v122 = v9 + 2;
          v75 = v78;
          goto LABEL_175;
        }
        if ((v79 & 1) == 0)
          goto LABEL_177;
        *v74 = v77;
        *v76 = v75;
        if ((vmovn_s32(vcgtq_s32(v78, v77)).i32[1] & 1) != 0)
        {
          *v9 = v77;
          v122 = v9 + 1;
LABEL_175:
          *v122 = v78;
        }
        v77 = v75;
LABEL_177:
        if ((vmovn_s32(vcgtq_s32(v77, *v8)).i32[1] & 1) != 0)
        {
          *v76 = *v8;
          *v8 = v77;
          v121 = *v76;
          v127 = *v74;
          if ((vmovn_s32(vcgtq_s32(*v74, *v76)).i32[1] & 1) != 0)
          {
            v9[1] = v121;
            v9[2] = v127;
LABEL_180:
            v128 = *v9;
            if ((vmovn_s32(vcgtq_s32(*v9, v121)).i32[1] & 1) != 0)
            {
              *v9 = v121;
              v9[1] = v128;
            }
          }
        }
        return result;
      case 5:
        return sub_1D3DD2890(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
      default:
        if (v10 > 383)
        {
          if (!a3)
          {
            if (v9 != a2)
            {
              v90 = (unint64_t)(v11 - 2) >> 1;
              v91 = v90;
              do
              {
                v92 = v91;
                if (v90 >= v91)
                {
                  v93 = (2 * v91) | 1;
                  v94 = &v9[v93];
                  if (2 * v92 + 2 < v11)
                  {
                    v95 = v94->i32[2];
                    v96 = v94[1].i32[2];
                    v94 += v95 < v96;
                    if (v95 < v96)
                      v93 = 2 * v92 + 2;
                  }
                  v97 = &v9[v92];
                  v98 = *v97;
                  v99 = v97->i64[1];
                  if (v94->i32[2] >= v99)
                  {
                    do
                    {
                      v100 = v94;
                      *v97 = *v94;
                      if (v90 < v93)
                        break;
                      v101 = (2 * v93) | 1;
                      v94 = &v9[v101];
                      v102 = 2 * v93 + 2;
                      if (v102 < v11)
                      {
                        v103 = v94->i32[2];
                        v104 = v94[1].i32[2];
                        v94 += v103 < v104;
                        if (v103 < v104)
                          v101 = v102;
                      }
                      result = (int32x4_t *)v94->u32[2];
                      v97 = v100;
                      v93 = v101;
                    }
                    while ((int)result >= v99);
                    *v100 = v98;
                  }
                }
                v91 = v92 - 1;
              }
              while (v92);
              v105 = (unint64_t)v10 >> 4;
              do
              {
                v106 = 0;
                v107 = *v9;
                v108 = v9;
                do
                {
                  v109 = (uint64_t)&v108[v106 + 1];
                  v110 = (2 * v106) | 1;
                  v111 = 2 * v106 + 2;
                  if (v111 < v105)
                  {
                    v112 = *(_DWORD *)(v109 + 8);
                    v113 = *(_DWORD *)(v109 + 24);
                    v109 += 16 * (v112 < v113);
                    if (v112 < v113)
                      v110 = v111;
                  }
                  *v108 = *(_OWORD *)v109;
                  v108 = (_OWORD *)v109;
                  v106 = v110;
                }
                while (v110 <= (uint64_t)((unint64_t)(v105 - 2) >> 1));
                if ((int32x4_t *)v109 == --a2)
                {
                  *(int32x4_t *)v109 = v107;
                }
                else
                {
                  *(int32x4_t *)v109 = *a2;
                  *a2 = v107;
                  v114 = v109 - (_QWORD)v9 + 16;
                  if (v114 >= 17)
                  {
                    v115 = (((unint64_t)v114 >> 4) - 2) >> 1;
                    v116 = &v9[v115];
                    v117 = *(int32x4_t *)v109;
                    v118 = *(_QWORD *)(v109 + 8);
                    if (v116->i32[2] < v118)
                    {
                      do
                      {
                        v119 = v116;
                        *(int32x4_t *)v109 = *v116;
                        if (!v115)
                          break;
                        v115 = (v115 - 1) >> 1;
                        v116 = &v9[v115];
                        v109 = (uint64_t)v119;
                      }
                      while (v116->i32[2] < v118);
                      *v119 = v117;
                    }
                  }
                }
              }
              while (v105-- > 2);
            }
            return result;
          }
          v12 = (unint64_t)v11 >> 1;
          v13 = &v9[(unint64_t)v11 >> 1];
          v14 = *v8;
          if ((unint64_t)v10 >= 0x801)
          {
            v15 = *v13;
            v16 = *v9;
            v17 = vmovn_s32(vcgtq_s32(*v13, v14)).i8[4];
            if ((vmovn_s32(vcgtq_s32(*v9, *v13)).i32[1] & 1) != 0)
            {
              if ((v17 & 1) != 0)
              {
                *v9 = v14;
              }
              else
              {
                *v9 = v15;
                *v13 = v16;
                if ((vmovn_s32(vcgtq_s32(v16, *v8)).i32[1] & 1) == 0)
                  goto LABEL_22;
                *v13 = *v8;
              }
              *v8 = v16;
            }
            else if ((v17 & 1) != 0)
            {
              *v13 = v14;
              *v8 = v15;
              v21 = *v9;
              if ((vmovn_s32(vcgtq_s32(*v9, *v13)).i32[1] & 1) != 0)
              {
                *v9 = *v13;
                *v13 = v21;
              }
            }
LABEL_22:
            v23 = v12 - 1;
            v24 = v9[v12 - 1];
            v25 = v9[1];
            v26 = a2[-2];
            v27 = vmovn_s32(vcgtq_s32(v24, v26)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v25, v24)).i32[1] & 1) != 0)
            {
              if ((v27 & 1) != 0)
              {
                v9[1] = v26;
              }
              else
              {
                v9[1] = v24;
                v9[v23] = v25;
                v30 = a2[-2];
                if ((vmovn_s32(vcgtq_s32(v25, v30)).i32[1] & 1) == 0)
                  goto LABEL_34;
                v9[v23] = v30;
              }
              a2[-2] = v25;
            }
            else if ((v27 & 1) != 0)
            {
              v9[v23] = v26;
              a2[-2] = v24;
              v28 = v9[v23];
              v29 = v9[1];
              if ((vmovn_s32(vcgtq_s32(v29, v28)).i32[1] & 1) != 0)
              {
                v9[1] = v28;
                v9[v23] = v29;
              }
            }
LABEL_34:
            v31 = &v9[v12];
            v33 = v31[1];
            v32 = v31 + 1;
            v34 = v33;
            v35 = v9[2];
            v36 = a2[-3];
            v37 = vmovn_s32(vcgtq_s32(v33, v36)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v35, v33)).i32[1] & 1) != 0)
            {
              if ((v37 & 1) != 0)
              {
                v9[2] = v36;
              }
              else
              {
                v9[2] = v34;
                *v32 = v35;
                v39 = a2[-3];
                if ((vmovn_s32(vcgtq_s32(v35, v39)).i32[1] & 1) == 0)
                  goto LABEL_43;
                *v32 = v39;
              }
              a2[-3] = v35;
            }
            else if ((v37 & 1) != 0)
            {
              *v32 = v36;
              a2[-3] = v34;
              v38 = v9[2];
              if ((vmovn_s32(vcgtq_s32(v38, *v32)).i32[1] & 1) != 0)
              {
                v9[2] = *v32;
                *v32 = v38;
              }
            }
LABEL_43:
            v40 = *v13;
            v41 = v9[v23];
            v42 = *v32;
            v43 = vmovn_s32(vcgtq_s32(*v13, *v32)).i8[4];
            if ((vmovn_s32(vcgtq_s32(v41, *v13)).i32[1] & 1) != 0)
            {
              if ((v43 & 1) != 0)
              {
                v9[v23] = v42;
              }
              else
              {
                v9[v23] = v40;
                *v13 = v41;
                if ((vmovn_s32(vcgtq_s32(v41, v42)).i32[1] & 1) == 0)
                {
                  v40 = v41;
                  goto LABEL_52;
                }
                *v13 = v42;
                v40 = v42;
              }
            }
            else
            {
              if ((v43 & 1) == 0)
              {
LABEL_52:
                v44 = *v9;
                *v9 = v40;
                *v13 = v44;
                goto LABEL_53;
              }
              *v13 = v42;
              *v32 = v40;
              if ((vmovn_s32(vcgtq_s32(v41, v42)).i32[1] & 1) == 0)
              {
                v40 = v42;
                goto LABEL_52;
              }
              v9[v23] = v42;
              v32 = v13;
              v40 = v41;
            }
            *v32 = v41;
            goto LABEL_52;
          }
          v18 = *v9;
          v19 = *v13;
          v20 = vmovn_s32(vcgtq_s32(*v9, v14)).i8[4];
          if ((vmovn_s32(vcgtq_s32(*v13, *v9)).i32[1] & 1) != 0)
          {
            if ((v20 & 1) != 0)
            {
              *v13 = v14;
            }
            else
            {
              *v13 = v18;
              *v9 = v19;
              if ((vmovn_s32(vcgtq_s32(v19, *v8)).i32[1] & 1) == 0)
                goto LABEL_53;
              *v9 = *v8;
            }
            *v8 = v19;
          }
          else if ((v20 & 1) != 0)
          {
            *v9 = v14;
            *v8 = v18;
            v22 = *v13;
            if ((vmovn_s32(vcgtq_s32(*v13, *v9)).i32[1] & 1) != 0)
            {
              *v13 = *v9;
              *v9 = v22;
            }
          }
LABEL_53:
          --a3;
          if ((a4 & 1) == 0)
          {
            v45 = *v9;
            if (v9[-1].i32[2] < v9->i32[2])
              goto LABEL_56;
            if (v45.i32[2] >= a2[-1].i32[2])
            {
              v60 = v9 + 1;
              do
              {
                v9 = v60;
                if (v60 >= a2)
                  break;
                v61 = v60->i32[2];
                ++v60;
              }
              while (v45.i32[2] >= v61);
            }
            else
            {
              v58 = v9;
              do
              {
                v9 = v58 + 1;
                v59 = v58[1].i32[2];
                ++v58;
              }
              while (v45.i32[2] >= v59);
            }
            v62 = a2;
            if (v9 < a2)
            {
              v63 = a2;
              do
              {
                v62 = v63 - 1;
                v64 = v63[-1].i32[2];
                --v63;
              }
              while (v45.i32[2] < v64);
            }
            while (v9 < v62)
            {
              v65 = *v9;
              *v9 = *v62;
              *v62 = v65;
              do
              {
                v66 = v9[1].i32[2];
                ++v9;
              }
              while (v45.i32[2] >= v66);
              do
              {
                v67 = v62[-1].i32[2];
                --v62;
              }
              while (v45.i32[2] < v67);
            }
            v68 = v9 - 1;
            if (&v9[-1] != v7)
              *v7 = *v68;
            a4 = 0;
            *v68 = v45;
            continue;
          }
          v45 = *v9;
LABEL_56:
          v46 = v9;
          do
            v47 = v46++;
          while (v47[1].i32[2] < v45.i32[2]);
          v48 = a2;
          if (v47 == v9)
          {
            v51 = a2;
            while (v46 < v51)
            {
              v49 = v51 - 1;
              v52 = v51[-1].i32[2];
              --v51;
              if (v52 < v45.i32[2])
                goto LABEL_66;
            }
            v49 = v51;
          }
          else
          {
            do
            {
              v49 = v48 - 1;
              v50 = v48[-1].i32[2];
              --v48;
            }
            while (v50 >= v45.i32[2]);
          }
LABEL_66:
          if (v46 < v49)
          {
            v53 = v46;
            v54 = v49;
            do
            {
              v55 = *v53;
              *v53 = *v54;
              *v54 = v55;
              do
                v47 = v53++;
              while (v47[1].i32[2] < v45.i32[2]);
              do
              {
                v56 = v54[-1].i32[2];
                --v54;
              }
              while (v56 >= v45.i32[2]);
            }
            while (v53 < v54);
          }
          if (v47 != v9)
            *v9 = *v47;
          *v47 = v45;
          if (v46 < v49)
            goto LABEL_77;
          v57 = sub_1D3DD2A08(v9, v47);
          v9 = v47 + 1;
          result = (int32x4_t *)sub_1D3DD2A08(v47 + 1, a2);
          if (!(_DWORD)result)
          {
            if (v57)
              continue;
LABEL_77:
            result = (int32x4_t *)sub_1D3DD1EDC(v7, v47, a3, a4 & 1);
            a4 = 0;
            v9 = v47 + 1;
            continue;
          }
          a2 = v47;
          if (v57)
            return result;
          goto LABEL_2;
        }
        v80 = v9 + 1;
        v82 = v9 == a2 || v80 == a2;
        if ((a4 & 1) != 0)
        {
          if (!v82)
          {
            v83 = 0;
            v84 = v9;
            do
            {
              v85 = v84[1];
              v86 = v84->i32[2];
              v84 = v80;
              if (v85.i32[2] < v86)
              {
                v87 = v83;
                while (1)
                {
                  *(int32x4_t *)((char *)&v9[1] + v87) = *(int32x4_t *)((char *)v9 + v87);
                  if (!v87)
                    break;
                  v88 = *(__int32 *)((char *)&v9->i32[-2] + v87);
                  v87 -= 16;
                  if (v85.i32[2] >= v88)
                  {
                    v89 = (int32x4_t *)((char *)v9 + v87 + 16);
                    goto LABEL_125;
                  }
                }
                v89 = v9;
LABEL_125:
                *v89 = v85;
              }
              v80 = v84 + 1;
              v83 += 16;
            }
            while (&v84[1] != a2);
          }
        }
        else if (!v82)
        {
          do
          {
            v123 = v7[1];
            v124 = v7->i32[2];
            v7 = v80;
            if (v123.i32[2] < v124)
            {
              do
              {
                v125 = v80;
                v126 = v80[-1];
                --v80;
                *v125 = v126;
              }
              while (v123.i32[2] < v125[-2].i32[2]);
              *v80 = v123;
            }
            v80 = v7 + 1;
          }
          while (&v7[1] != a2);
        }
        return result;
    }
  }
}

int32x4_t *sub_1D3DD2890(int32x4_t *result, int32x4_t *a2, int32x4_t *a3, int32x4_t *a4, int32x4_t *a5)
{
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  __int8 v8;
  int32x4_t v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;

  v5 = *a2;
  v6 = *result;
  v7 = *a3;
  v8 = vmovn_s32(vcgtq_s32(*a2, *a3)).i8[4];
  if ((vmovn_s32(vcgtq_s32(*result, *a2)).i32[1] & 1) != 0)
  {
    if ((v8 & 1) != 0)
    {
      *result = v7;
LABEL_9:
      *a3 = v6;
      v5 = v6;
      goto LABEL_11;
    }
    *result = v5;
    *a2 = v6;
    v5 = *a3;
    if ((vmovn_s32(vcgtq_s32(v6, *a3)).i32[1] & 1) != 0)
    {
      *a2 = v5;
      goto LABEL_9;
    }
  }
  else if ((v8 & 1) != 0)
  {
    *a2 = v7;
    *a3 = v5;
    v9 = *result;
    if ((vmovn_s32(vcgtq_s32(*result, *a2)).i32[1] & 1) != 0)
    {
      *result = *a2;
      *a2 = v9;
      v5 = *a3;
    }
  }
  else
  {
    v5 = *a3;
  }
LABEL_11:
  if ((vmovn_s32(vcgtq_s32(v5, *a4)).i32[1] & 1) != 0)
  {
    *a3 = *a4;
    *a4 = v5;
    v10 = *a2;
    if ((vmovn_s32(vcgtq_s32(*a2, *a3)).i32[1] & 1) != 0)
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *result;
      if ((vmovn_s32(vcgtq_s32(*result, *a2)).i32[1] & 1) != 0)
      {
        *result = *a2;
        *a2 = v11;
      }
    }
  }
  v12 = *a4;
  if ((vmovn_s32(vcgtq_s32(*a4, *a5)).i32[1] & 1) != 0)
  {
    *a4 = *a5;
    *a5 = v12;
    v13 = *a3;
    if ((vmovn_s32(vcgtq_s32(*a3, *a4)).i32[1] & 1) != 0)
    {
      *a3 = *a4;
      *a4 = v13;
      v14 = *a2;
      if ((vmovn_s32(vcgtq_s32(*a2, *a3)).i32[1] & 1) != 0)
      {
        *a2 = *a3;
        *a3 = v14;
        v15 = *result;
        if ((vmovn_s32(vcgtq_s32(*result, *a2)).i32[1] & 1) != 0)
        {
          *result = *a2;
          *a2 = v15;
        }
      }
    }
  }
  return result;
}

BOOL sub_1D3DD2A08(int32x4_t *a1, int32x4_t *a2)
{
  uint64_t v2;
  int32x4_t v3;
  int32x4_t v4;
  int32x4_t *v5;
  int32x4_t v6;
  int32x4_t *v7;
  int32x4_t v8;
  int32x4_t v9;
  __int8 v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  __int8 v14;
  int32x4_t *v15;
  int32x4_t v16;
  int32x4_t *v17;
  int32x4_t v18;
  int32x4_t v19;
  __int8 v20;
  int32x4_t v21;
  int32x4_t *v22;
  int32x4_t *v23;
  uint64_t v24;
  int v25;
  int32x4_t v26;
  __int32 v27;
  uint64_t v28;
  __int32 v29;
  int32x4_t *v30;
  int32x4_t v31;
  int32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;

  v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      v3 = a2[-1];
      v4 = *a1;
      if ((vmovn_s32(vcgtq_s32(*a1, v3)).i32[1] & 1) != 0)
      {
        *a1 = v3;
        a2[-1] = v4;
      }
      return 1;
    case 3:
      v11 = *a1;
      v12 = a1[1];
      v13 = a2[-1];
      v14 = vmovn_s32(vcgtq_s32(v12, v13)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v12)).i32[1] & 1) == 0)
      {
        if ((v14 & 1) == 0)
          return 1;
        a1[1] = v13;
        a2[-1] = v12;
        v21 = a1[1];
        goto LABEL_48;
      }
      if ((v14 & 1) != 0)
      {
        *a1 = v13;
      }
      else
      {
        *a1 = v12;
        a1[1] = v11;
        v31 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v11, v31)).i32[1] & 1) == 0)
          return 1;
        a1[1] = v31;
      }
      a2[-1] = v11;
      return 1;
    case 4:
      v15 = a1 + 1;
      v16 = a1[1];
      v17 = a1 + 2;
      v18 = a1[2];
      v19 = *a1;
      v20 = vmovn_s32(vcgtq_s32(v16, v18)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v16)).i32[1] & 1) != 0)
      {
        if ((v20 & 1) != 0)
        {
          *a1 = v18;
        }
        else
        {
          *a1 = v16;
          a1[1] = v19;
          if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) == 0)
            goto LABEL_45;
          *v15 = v18;
        }
        v22 = a1 + 2;
        v16 = v19;
        goto LABEL_43;
      }
      if ((v20 & 1) == 0)
        goto LABEL_45;
      *v15 = v18;
      *v17 = v16;
      if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) != 0)
      {
        *a1 = v18;
        v22 = a1 + 1;
LABEL_43:
        *v22 = v19;
      }
      v18 = v16;
LABEL_45:
      v32 = a2[-1];
      if ((vmovn_s32(vcgtq_s32(v18, v32)).i32[1] & 1) != 0)
      {
        *v17 = v32;
        a2[-1] = v18;
        v21 = *v17;
        v33 = *v15;
        if ((vmovn_s32(vcgtq_s32(*v15, *v17)).i32[1] & 1) != 0)
        {
          a1[1] = v21;
          a1[2] = v33;
LABEL_48:
          v34 = *a1;
          if ((vmovn_s32(vcgtq_s32(*a1, v21)).i32[1] & 1) != 0)
          {
            *a1 = v21;
            a1[1] = v34;
          }
        }
      }
      return 1;
    case 5:
      sub_1D3DD2890(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v5 = a1 + 2;
      v6 = a1[2];
      v7 = a1 + 1;
      v8 = a1[1];
      v9 = *a1;
      v10 = vmovn_s32(vcgtq_s32(v8, v6)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v8)).i32[1] & 1) != 0)
      {
        if ((v10 & 1) != 0)
        {
          *a1 = v6;
        }
        else
        {
          *a1 = v8;
          a1[1] = v9;
          if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) == 0)
            goto LABEL_26;
          *v7 = v6;
        }
        v7 = a1 + 2;
        goto LABEL_25;
      }
      if ((v10 & 1) != 0)
      {
        *v7 = v6;
        *v5 = v8;
        if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) != 0)
        {
          *a1 = v6;
LABEL_25:
          *v7 = v9;
        }
      }
LABEL_26:
      v23 = a1 + 3;
      if (&a1[3] == a2)
        return 1;
      v24 = 0;
      v25 = 0;
      while (1)
      {
        v26 = *v23;
        v27 = v23->i64[1];
        if (v27 < v5->i32[2])
        {
          v28 = v24;
          while (1)
          {
            *(int32x4_t *)((char *)&a1[3] + v28) = *(int32x4_t *)((char *)&a1[2] + v28);
            if (v28 == -32)
              break;
            v29 = *(__int32 *)((char *)&a1[1].i32[2] + v28);
            v28 -= 16;
            if (v27 >= v29)
            {
              v30 = (int32x4_t *)((char *)a1 + v28 + 48);
              goto LABEL_34;
            }
          }
          v30 = a1;
LABEL_34:
          *v30 = v26;
          if (++v25 == 8)
            return &v23[1] == a2;
        }
        v5 = v23;
        v24 += 16;
        if (++v23 == a2)
          return 1;
      }
  }
}

uint64_t sub_1D3DD2CEC(uint64_t a1, int a2, __n128 a3, int32x2_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  unsigned __int8 *v11;
  _QWORD *v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  __n128 v17;
  unsigned __int32 v18;
  unsigned __int32 v19;
  BOOL v20;
  int v21;
  BOOL v22;
  __n128 v27;

  v4 = 0;
  v5 = 128;
  if (a4.i32[0] > 0)
    v5 = 132;
  v6 = 136;
  if (a4.i32[1] > 0)
    v6 = 140;
  if (a2 >= 1)
  {
    v7 = *(_DWORD *)(a1 + v5);
    v8 = *(_DWORD *)(a1 + v6);
    v9 = a3.n128_u32[0] == v7 || a3.n128_u32[1] == v8;
    v27 = a3;
    if (!v9)
    {
      v11 = *(unsigned __int8 **)(a1 + 32);
      v12 = (_QWORD *)*((_QWORD *)v11 + 3);
      v13 = sub_1D3D6D4A0(v12, a3.n128_i32[0], a3.n128_i32[1]);
      LODWORD(v4) = 0;
      v14 = *v11;
      v15 = v14 != v13;
      v16 = 1;
      do
      {
        v17.n128_u64[1] = v27.n128_u64[1];
        v17.n128_u64[0] = (unint64_t)vadd_s32((int32x2_t)v27.n128_u64[0], a4);
        v4 = (v4 + 1);
        v18 = v17.n128_u32[0];
        v19 = v17.n128_u32[1];
        v27 = v17;
        v20 = v14 != sub_1D3D6D4A0(v12, v17.n128_i32[0], v17.n128_i32[1]);
        v21 = (v15 ^ v20) & 1;
        if (((v15 ^ v20) & 1) != 0)
          v15 = v20;
        v16 -= v21;
        if (v16)
          v22 = (int)v4 < a2;
        else
          v22 = 0;
      }
      while (v22 && v18 != v7 && v19 != v8);
    }
  }
  return v4;
}

uint64_t sub_1D3DD2E08(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  int v15;
  _BOOL4 v16;
  int v17;
  int v18;
  _BOOL4 v19;
  int v20;
  int v21;
  _BOOL4 v22;
  uint64_t result;
  int v26;
  int v27;
  _QWORD *v28;

  v4 = 128;
  if (a3 > 0)
    v4 = 132;
  v5 = *(_DWORD *)(a1 + v4);
  v6 = 136;
  if (a4 > 0)
    v6 = 140;
  v7 = *(_DWORD *)(a1 + v6);
  v8 = *(_DWORD *)(a1 + 124);
  v9 = *(int *)(a1 + 120);
  if ((_DWORD)v9 == v5 || v8 == v7)
  {
LABEL_24:
    result = 0;
    *(_QWORD *)a2 = -1;
    return result;
  }
  v11 = v8;
  v12 = *(unsigned __int8 **)(a1 + 32);
  v28 = (_QWORD *)*((_QWORD *)v12 + 3);
  v13 = sub_1D3D6D4A0(v28, v9, v8);
  v14 = 0;
  v15 = 0;
  v26 = *v12;
  v27 = *(unsigned __int8 *)(a1 + 13);
  v16 = v27 == (v26 != v13);
  v17 = v5 - (v9 + a3);
  v18 = v7 - (v11 + a4);
  while (1)
  {
    v19 = v16;
    v20 = v18;
    v16 = v27 == (v26 != sub_1D3D6D4A0(v28, v9 + a3, v11 + a4));
    if (((v19 ^ v16) & 1) != 0)
      v21 = 0;
    else
      v21 = v14;
    if (((v19 ^ v16) & 1) != 0)
      v22 = v16;
    else
      v22 = v19;
    if (!v19 || ((v19 ^ v16) & 1) == 0)
    {
      v16 = v22;
      if (!v17)
        goto LABEL_24;
      goto LABEL_23;
    }
    if (v14 >= *(_DWORD *)(a1 + 20) && ++v15 == *(_DWORD *)(a1 + 16))
      break;
    v21 = 0;
    if (!v17)
      goto LABEL_24;
LABEL_23:
    v14 = v21 + 1;
    v17 -= a3;
    v18 = v20 - a4;
    v9 += a3;
    v11 += a4;
    if (!v20)
      goto LABEL_24;
  }
  *(_DWORD *)a2 = v9;
  *(_DWORD *)(a2 + 4) = v11;
  return 1;
}

uint64_t sub_1D3DD2FB4(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;

  v2 = *(unsigned __int8 *)(a1 + 1);
  v3 = a1 + 64;
  v4 = a1 + 72;
  v5 = a1 + 80;
  v6 = -v2;
  v7 = sub_1D3DD2E08(a1, a1 + 56, -1, -v2);
  LODWORD(v3) = sub_1D3DD2E08(a1, v3, v2, -1);
  v8 = v3 + sub_1D3DD2E08(a1, v4, 1, v2) + v7;
  return v8 + sub_1D3DD2E08(a1, v5, v6, 1);
}

uint64_t sub_1D3DD305C(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;

  v4 = *a2;
  v5 = v4 + a3;
  if (*(_DWORD *)(a1 + 128) > (int)v4 + a3)
    return 0;
  v6 = 0;
  v9 = a4;
  v10 = a3;
  do
  {
    if (v5 > *(_DWORD *)(a1 + 132))
      break;
    v11 = *(unsigned __int8 **)(a1 + 32);
    v12 = a2[1];
    v13 = (_QWORD *)*((_QWORD *)v11 + 3);
    v14 = sub_1D3D6D4A0(v13, v5, v12);
    v15 = *v11;
    v16 = *(unsigned __int8 *)(a1 + 13);
    if (v16 != (v15 != v14))
      break;
    v4 += v10;
    *a2 = v4;
    v6 = (v6 + 1);
    if (*(_DWORD *)(a1 + 136) <= (int)v12 + a4)
    {
      v17 = v9 + v12;
      do
      {
        if ((int)v17 > *(_DWORD *)(a1 + 140))
          break;
        if (v16 != (v15 != sub_1D3D6D4A0(v13, v4, (int)v17)))
          break;
        a2[1] = v17;
        v6 = (v6 + 1);
        v17 += v9;
      }
      while (v17 >= *(int *)(a1 + 136));
    }
    v5 = v4 + v10;
  }
  while (v4 + v10 >= *(int *)(a1 + 128));
  return v6;
}

uint64_t sub_1D3DD3190(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;

  v4 = a2[1];
  v5 = v4 + a4;
  if (*(_DWORD *)(a1 + 136) > (int)v4 + a4)
    return 0;
  v6 = 0;
  v9 = a3;
  v10 = a4;
  do
  {
    if (v5 > *(_DWORD *)(a1 + 140))
      break;
    v11 = *(unsigned __int8 **)(a1 + 32);
    v12 = *a2;
    v13 = (_QWORD *)*((_QWORD *)v11 + 3);
    v14 = sub_1D3D6D4A0(v13, v12, v5);
    v15 = *v11;
    v16 = *(unsigned __int8 *)(a1 + 13);
    if (v16 != (v15 != v14))
      break;
    v4 += v10;
    a2[1] = v4;
    v6 = (v6 + 1);
    if (*(_DWORD *)(a1 + 128) <= (int)v12 + a3)
    {
      v17 = v9 + v12;
      do
      {
        if ((int)v17 > *(_DWORD *)(a1 + 132))
          break;
        if (v16 != (v15 != sub_1D3D6D4A0(v13, (int)v17, v4)))
          break;
        *a2 = v17;
        v6 = (v6 + 1);
        v17 += v9;
      }
      while (v17 >= *(int *)(a1 + 128));
    }
    v5 = v4 + v10;
  }
  while (v4 + v10 >= *(int *)(a1 + 136));
  return v6;
}

uint64_t sub_1D3DD32C4(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;

  if (a3)
  {
    v6 = *a2;
    if (*(_DWORD *)(a1 + 128) <= (int)v6 + a3)
    {
      v7 = 0;
      v8 = a2[1];
      v9 = a3;
      v10 = v6 + a3;
      do
      {
        if ((int)v10 > *(_DWORD *)(a1 + 132))
          break;
        v11 = *(unsigned __int8 **)(a1 + 32);
        if (*(_BYTE *)(a1 + 13) != (*v11 != sub_1D3D6D4A0(*((_QWORD **)v11 + 3), (int)v10, v8)))
          break;
        *a2 = v10;
        v7 = (v7 + 1);
        v10 += v9;
      }
      while (v10 >= *(int *)(a1 + 128));
      return v7;
    }
    return 0;
  }
  if (!a4)
    return 0;
  v12 = a2[1];
  if (*(_DWORD *)(a1 + 136) > (int)v12 + a4)
    return 0;
  v7 = 0;
  v14 = *a2;
  v15 = a4;
  v16 = v12 + a4;
  do
  {
    if ((int)v16 > *(_DWORD *)(a1 + 140))
      break;
    v17 = *(unsigned __int8 **)(a1 + 32);
    if (*(_BYTE *)(a1 + 13) != (*v17 != sub_1D3D6D4A0(*((_QWORD **)v17 + 3), v14, (int)v16)))
      break;
    a2[1] = v16;
    v7 = (v7 + 1);
    v16 += v15;
  }
  while (v16 >= *(int *)(a1 + 136));
  return v7;
}

float sub_1D3DD3404(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7)
{
  int v7;
  uint64_t (*v9)(uint64_t, int *, int, int);
  uint64_t (*v10)(uint64_t, int *, int, int);
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  int v27;
  int v28;
  int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t (*i)(uint64_t, int *, int, int);
  int v39;
  int v40;
  NSObject *log;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  unint64_t v50;
  uint8_t buf[4];
  int v52;
  __int16 v53;
  unsigned int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if ((a2 & 0x8000000080000000) != 0)
    return NAN;
  v7 = a3;
  v9 = sub_1D3DD3190;
  v50 = a2;
  if (a3 == 1)
    v9 = sub_1D3DD32C4;
  if (a3 >= 1)
    v10 = v9;
  else
    v10 = sub_1D3DD305C;
  v11 = (int)a6;
  v12 = (int)a7;
  v39 = a4;
  v40 = a5;
  for (i = v10; ; v10 = i)
  {
    v10(a1, (int *)&v50, a4, a5);
    if (qword_1EDB89E50 != -1)
      dispatch_once(&qword_1EDB89E50, &unk_1E95B3568);
    log = qword_1EDB89E58;
    if (os_log_type_enabled((os_log_t)qword_1EDB89E58, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67240448;
      v52 = v50;
      v53 = 1026;
      v54 = HIDWORD(v50);
      _os_log_debug_impl(&dword_1D3D6B000, log, OS_LOG_TYPE_DEBUG, "(%{public}d, %{public}d)", buf, 0xEu);
    }
    if (v7 == 1)
    {
      v13 = 0;
      *(_DWORD *)(a1 + 8) = 0;
      if (!a6)
        goto LABEL_17;
      goto LABEL_30;
    }
    v13 = *(_DWORD *)(a1 + 8);
    if (v7 > 1)
    {
      if (v13 < 0)
        break;
LABEL_17:
      v14 = 0;
      v15 = *(int *)(a1 + 4);
      v35 = v50;
      v44 = v12 + SHIDWORD(v50);
      v46 = (int)v50;
      while ((int)v15 < 1)
      {
LABEL_27:
        v21 = v14++ < v13;
        if (!v21)
        {
          v27 = v35;
          v7 = a3;
          goto LABEL_43;
        }
      }
      v48 = v13;
      v16 = 0;
      v17 = v44;
      v18 = v46 + v14 * v11;
      v19 = *(int *)(a1 + 128);
      while (1)
      {
        if (v18 >= v19 && v18 <= *(int *)(a1 + 132) && v17 >= *(int *)(a1 + 136) && v17 <= *(int *)(a1 + 140))
        {
          v20 = *(unsigned __int8 **)(a1 + 32);
          if (*(_BYTE *)(a1 + 13) == (*v20 != sub_1D3D6D4A0(*((_QWORD **)v20 + 3), v18, v17)))
            goto LABEL_42;
        }
        ++v16;
        v17 += v12;
        if (v16 >= v15)
        {
          v13 = v48;
          goto LABEL_27;
        }
      }
    }
    if (v13 < 0)
      break;
LABEL_30:
    v22 = 0;
    v23 = *(int *)(a1 + 4);
    v36 = v50;
    v45 = v11 + (int)v50;
    v47 = SHIDWORD(v50);
    while ((int)v23 < 1)
    {
LABEL_40:
      v21 = v22++ < v13;
      if (!v21)
      {
        v7 = a3;
        v27 = v36;
        goto LABEL_43;
      }
    }
    v49 = v13;
    v24 = 0;
    v18 = v45;
    v17 = v47 + v22 * v12;
    v25 = *(int *)(a1 + 128);
    while (1)
    {
      if (v18 >= v25 && v18 <= *(int *)(a1 + 132) && v17 >= *(int *)(a1 + 136) && v17 <= *(int *)(a1 + 140))
      {
        v26 = *(unsigned __int8 **)(a1 + 32);
        if (*(_BYTE *)(a1 + 13) == (*v26 != sub_1D3D6D4A0(*((_QWORD **)v26 + 3), v18, v17)))
          break;
      }
      ++v24;
      v18 += v11;
      if (v24 >= v23)
      {
        v13 = v49;
        goto LABEL_40;
      }
    }
LABEL_42:
    v50 = __PAIR64__(v17, v18);
    v7 = a3;
    a4 = v39;
    a5 = v40;
  }
  v27 = v50;
LABEL_43:
  if (v27 == *(_DWORD *)(a1 + 128))
    return NAN;
  if (v27 == *(_DWORD *)(a1 + 132))
    return NAN;
  v28 = HIDWORD(v50);
  if (HIDWORD(v50) == *(_DWORD *)(a1 + 136) || HIDWORD(v50) == *(_DWORD *)(a1 + 140))
    return NAN;
  if (v39 <= 0)
    v30 = v27;
  else
    v30 = v27 + 1;
  if (v40 > 0)
    v28 = HIDWORD(v50) + 1;
  v31 = a6 >> 31;
  if (v7 != 1)
    v31 = 0;
  v32 = v30 + v31;
  if (v7 == 1)
    v33 = a7 >> 31;
  else
    v33 = 0;
  v34 = v28 + v33;
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67240448;
    v52 = v32;
    v53 = 1026;
    v54 = v34;
    _os_log_debug_impl(&dword_1D3D6B000, log, OS_LOG_TYPE_DEBUG, "(%{public}d, %{public}d)", buf, 0xEu);
  }
  return (float)v32;
}

void sub_1D3DD3828(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  uint8_t v16[16];
  uint8_t buf[16];

  if (*(_BYTE *)(a1 + 1))
    v7 = (char *)&unk_1D3E6B710 + 8 * a2;
  else
    v7 = (char *)&unk_1D3E6B730 + 8 * a2;
  v9 = *(unsigned int *)v7;
  v8 = *((unsigned int *)v7 + 1);
  if (*(_BYTE *)(a1 + 1))
    v10 = 1;
  else
    v10 = ~(2 * a2) & 2;
  if (qword_1EDB89E50 != -1)
    dispatch_once(&qword_1EDB89E50, &unk_1E95B3568);
  v11 = qword_1EDB89E58;
  if (os_log_type_enabled((os_log_t)qword_1EDB89E58, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_DEBUG, "===== corner1 =====", buf, 2u);
  }
  *(float *)a3 = sub_1D3DD3404(a1, *(_QWORD *)(a1 + 56 + 8 * a2), v10, v9, v8, -(int)v8, v9);
  *(_DWORD *)(a3 + 4) = v12;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v16 = 0;
    _os_log_debug_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_DEBUG, "===== corner2 =====", v16, 2u);
  }
  v13 = (a2 + 1) & 3;
  if (a2 + 1 <= 0)
    v13 = -(-(a2 + 1) & 3);
  *(float *)a4 = sub_1D3DD3404(a1, *(_QWORD *)(a1 + 56 + 8 * v13), 2 - v10, v9, v8, v8, -(int)v9);
  *(_DWORD *)(a4 + 4) = v14;
}

float sub_1D3DD39C4(uint64_t a1, float *a2, float *a3, uint64_t a4)
{
  float result;
  float v5;
  float v6;
  float v7;
  uint64_t v8;
  float v9;
  float v10;
  uint64_t *v11;

  result = *a2;
  if (*a2 < 0.0
    || (v5 = a2[1], v5 < 0.0)
    || (v6 = *a3, *a3 < 0.0)
    || (v7 = a3[1], v7 < 0.0)
    || (float)((float)((float)(v5 - v7) * (float)(v5 - v7)) + (float)((float)(result - v6) * (float)(result - v6))) > (float)(*(float *)(a1 + 28) * *(float *)(a1 + 28)))
  {
    v8 = 0x7FC000007FC00000;
LABEL_7:
    *(_QWORD *)a4 = v8;
    return result;
  }
  if (!*(_BYTE *)(a1 + 1))
  {
    v9 = (float)*(int *)(a1 + 120);
    v10 = (float)*(int *)(a1 + 124);
    result = (float)((float)(v5 - v10) * (float)(v5 - v10)) + (float)((float)(result - v9) * (float)(result - v9));
    if (result <= (float)((float)((float)(v7 - v10) * (float)(v7 - v10)) + (float)((float)(v6 - v9) * (float)(v6 - v9))))
      v11 = (uint64_t *)a3;
    else
      v11 = (uint64_t *)a2;
    v8 = *v11;
    goto LABEL_7;
  }
  result = (float)(result + v6) * 0.5;
  *(float *)a4 = result;
  *(float *)(a4 + 4) = (float)(v5 + v7) * 0.5;
  return result;
}

void sub_1D3DD3A98(_QWORD *a1, uint64_t a2, int a3, int a4)
{
  _QWORD *v7;
  char *v8;
  unsigned __int8 *v9;
  int32x4_t v10;
  int32x4_t *v11;
  int32x4_t *v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  __int32 v16;
  int32x2_t v17;
  unsigned __int8 *v18;
  _QWORD *v19;
  int v20;
  int32x4_t v21;
  int32x4_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int32x4_t *v27;
  int32x4_t *v28;
  int32x4_t v29;
  unint64_t v30;
  uint64_t v31;
  __n128 v32;
  char *v33;
  char *v34;
  unint64_t v35;
  int32x4_t *v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  float v45;
  int v46;
  int v47;
  unint64_t *v48;
  int v49;
  int v50;
  int v51;
  __n128 v52;
  int v53;
  int v54;
  int v55;
  int v56;
  __n128 v58;
  int v59;
  int v60;
  int v61;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  BOOL v76;
  float v77;
  float v78;
  float v79;
  float v80;
  uint64_t i;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  _DWORD *v90;
  int v91;
  _QWORD *v92;
  int32x4_t v93;
  __n128 v94;
  __n128 v95;
  int32x4_t v96;
  int32x4_t v97;
  __n128 v98;
  uint64_t v99;
  uint64_t v100;

  v7 = a1;
  sub_1D3D8D5CC(a1, 8uLL);
  v8 = (char *)(a2 + 88);
  memset_pattern16((void *)(a2 + 88), &unk_1D3E82240, 0x20uLL);
  *(_DWORD *)(a2 + 120) = a3;
  *(_DWORD *)(a2 + 124) = a4;
  sub_1D3DD1E68(a2);
  v9 = *(unsigned __int8 **)(a2 + 32);
  if (*v9 != sub_1D3D6D4A0(*((_QWORD **)v9 + 3), a3, a4))
  {
LABEL_73:
    if (*(_BYTE *)(a2 + 1))
      goto LABEL_95;
    sub_1D3DD2FB4(a2);
    v63 = 0;
    v64 = (uint64_t)v8;
    do
    {
      v99 = 0;
      v100 = 0;
      v65 = v63 + *(_DWORD *)(a2 + 144);
      v66 = v65 & 3;
      v67 = -v65;
      v76 = v67 < 0;
      v68 = v67 & 3;
      if (v76)
        v69 = v66;
      else
        v69 = -v68;
      sub_1D3DD3828(a2, v69, (uint64_t)&v100, (uint64_t)&v99);
      if (!*(_BYTE *)a2 && *(float *)&v100 >= 0.0 && *((float *)&v100 + 1) >= 0.0)
      {
        v70 = (float)*(int *)(a2 + 120);
        v71 = (float)*(int *)(a2 + 124);
        v72 = vabds_f32(*(float *)&v100, v70);
        v73 = vabds_f32(*((float *)&v100 + 1), v71);
        v74 = v72 * 0.41421;
        v75 = v72 * 2.4142;
        v76 = v74 < v73 && v73 < v75;
        if (!v76 && *(float *)&v99 >= 0.0 && *((float *)&v99 + 1) >= 0.0)
        {
          v77 = vabds_f32(*(float *)&v99, v70);
          v78 = vabds_f32(*((float *)&v99 + 1), v71);
          v79 = v77 * 0.41421;
          v80 = v77 * 2.4142;
          if (v79 >= v78 || v78 >= v80)
          {
            *(_BYTE *)(a2 + 1) = 1;
            memset_pattern16(v8, &unk_1D3E82240, 0x20uLL);
            goto LABEL_95;
          }
        }
      }
      sub_1D3DD39C4(a2, (float *)&v100, (float *)&v99, v64);
      ++v63;
      v64 += 8;
    }
    while (v63 != 4);
    if (*(_BYTE *)(a2 + 1))
    {
LABEL_95:
      if (sub_1D3DD2FB4(a2) == 4)
      {
        for (i = 0; i != 4; ++i)
        {
          v99 = 0;
          v100 = 0;
          v83 = i + *(_DWORD *)(a2 + 144);
          v84 = v83 & 3;
          v85 = -v83;
          v76 = v85 < 0;
          v86 = v85 & 3;
          if (v76)
            v87 = v84;
          else
            v87 = -v86;
          sub_1D3DD3828(a2, v87, (uint64_t)&v100, (uint64_t)&v99);
          sub_1D3DD39C4(a2, (float *)&v100, (float *)&v99, (uint64_t)v8);
          v8 += 8;
        }
      }
    }
    goto LABEL_101;
  }
  v92 = v7;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v10.i64[0] = __PAIR64__(a4, a3);
  v93 = v10;
  v15 = (int)*(float *)(a2 + 28);
  do
  {
    if (v15 >= 1)
    {
      v16 = 0;
      v17 = qword_1D3E6B6D0[v14];
      v18 = *(unsigned __int8 **)(a2 + 32);
      v19 = (_QWORD *)*((_QWORD *)v18 + 3);
      v20 = *v18;
      v96 = v93;
      while (1)
      {
        v21.i64[1] = v96.i64[1];
        *(int32x2_t *)v21.i8 = vadd_s32(*(int32x2_t *)v96.i8, v17);
        v96 = v21;
        if (v20 != sub_1D3D6D4A0(v19, v21.i32[0], v21.i32[1]))
          break;
        if (v15 == ++v16)
          goto LABEL_25;
      }
      v22 = v96;
      v22.i32[2] = v16;
      if ((unint64_t)v12 >= v13)
      {
        v97 = v22;
        v23 = v12 - v11;
        v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 60)
          sub_1D3D6D4F8();
        if ((uint64_t)(v13 - (_QWORD)v11) >> 3 > v24)
          v24 = (uint64_t)(v13 - (_QWORD)v11) >> 3;
        if (v13 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
          v25 = 0xFFFFFFFFFFFFFFFLL;
        else
          v25 = v24;
        if (v25)
          v25 = (unint64_t)sub_1D3D6DB64(v25);
        else
          v26 = 0;
        v27 = (int32x4_t *)(v25 + 16 * v23);
        *v27 = v97;
        v28 = v27 + 1;
        while (v12 != v11)
        {
          v29 = v12[-1];
          --v12;
          v27[-1] = v29;
          --v27;
        }
        v13 = v25 + 16 * v26;
        if (v11)
          operator delete(v11);
        v11 = v27;
        v12 = v28;
      }
      else
      {
        *v12++ = v22;
      }
    }
LABEL_25:
    ++v14;
  }
  while (v14 != 8);
  v30 = 126 - 2 * __clz(v12 - v11);
  if (v12 == v11)
    v31 = 0;
  else
    v31 = v30;
  sub_1D3DD1EDC(v11, v12, v31, 1);
  if (v12 == v11)
  {
    v33 = 0;
    v38 = 0;
    if (v11)
LABEL_50:
      operator delete(v11);
  }
  else
  {
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = v11;
    do
    {
      v37 = v36->i64[0];
      if ((unint64_t)v34 >= v35)
      {
        v39 = (v34 - v33) >> 3;
        v40 = v39 + 1;
        if ((unint64_t)(v39 + 1) >> 61)
          sub_1D3D6D4F8();
        if ((uint64_t)(v35 - (_QWORD)v33) >> 2 > v40)
          v40 = (uint64_t)(v35 - (_QWORD)v33) >> 2;
        if (v35 - (unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
          v41 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v41 = v40;
        if (v41)
          v41 = (unint64_t)sub_1D3D6D8A0(v41);
        else
          v42 = 0;
        v43 = (char *)(v41 + 8 * v39);
        *(_QWORD *)v43 = v37;
        v38 = v43 + 8;
        while (v34 != v33)
        {
          v44 = *((_QWORD *)v34 - 1);
          v34 -= 8;
          *((_QWORD *)v43 - 1) = v44;
          v43 -= 8;
        }
        v35 = v41 + 8 * v42;
        if (v33)
          operator delete(v33);
        v33 = v43;
      }
      else
      {
        *(_QWORD *)v34 = v37;
        v38 = v34 + 8;
      }
      ++v36;
      v34 = v38;
    }
    while (v36 != v12);
    if (v11)
      goto LABEL_50;
  }
  if (v33 == v38)
  {
LABEL_69:
    v91 = 0;
  }
  else
  {
    v45 = *(float *)(a2 + 28);
    v46 = (int)(float)(v45 + v45);
    v47 = (int)(float)(v45 * 0.5);
    v48 = (unint64_t *)v33;
    while (1)
    {
      v32.n128_u64[0] = *v48;
      v98 = v32;
      v49 = sub_1D3DD2CEC(a2, v46, v32, (int32x2_t)0xFFFFFFFFLL);
      if (v49)
      {
        v50 = v49;
        v51 = sub_1D3DD2CEC(a2, v46, v98, (int32x2_t)1);
        if (v51)
        {
          v52 = v98;
          v52.n128_u32[0] = (int)(float)((float)(v98.n128_u32[0] - v50 + 1) + (float)((float)(v50 + v51 - 1) * 0.5));
          v94 = v52;
          v53 = sub_1D3DD2CEC(a2, v46, v52, (int32x2_t)0xFFFFFFFF00000000);
          if (v53)
          {
            v54 = v53;
            v55 = sub_1D3DD2CEC(a2, v46, v94, (int32x2_t)0x100000000);
            if (v55)
            {
              v56 = v55 + v54 - 1;
              if (v55 + v54 <= v46 && v56 > v47)
              {
                v58 = v94;
                v58.n128_u32[1] = (int)(float)((float)(v98.n128_u32[1] - v54 + 1) + (float)((float)v56 * 0.5));
                v95 = v58;
                v59 = sub_1D3DD2CEC(a2, v46, v58, (int32x2_t)0xFFFFFFFFLL);
                if (v59)
                {
                  v60 = v59;
                  v61 = sub_1D3DD2CEC(a2, v46, v95, (int32x2_t)1);
                  if (v61)
                  {
                    if (v61 + v60 <= v46 && v61 + v60 - 1 > v47)
                      break;
                  }
                }
              }
            }
          }
        }
      }
      if (++v48 == (unint64_t *)v38)
        goto LABEL_69;
    }
    *(_QWORD *)(a2 + 120) = v95.n128_u64[0];
    sub_1D3DD1E68(a2);
    v91 = 1;
  }
  v8 = (char *)(a2 + 88);
  v7 = v92;
  if (v33)
    operator delete(v33);
  if (v91)
    goto LABEL_73;
LABEL_101:
  v88 = 0;
  v89 = *v7;
  do
  {
    v90 = (_DWORD *)(v89 + v88);
    *v90 = *(_DWORD *)(a2 + v88 + 88);
    v90[1] = *(_DWORD *)(a2 + v88 + 92);
    v88 += 8;
  }
  while (v88 != 32);
}

void sub_1D3DD40E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;
  void *v12;

  if (v10)
    operator delete(v10);
  v12 = *(void **)a10;
  if (*(_QWORD *)a10)
  {
    *(_QWORD *)(a10 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

size_t sub_1D3DD4144(uint64_t a1, uint64_t a2, char *a3, std::string::size_type a4)
{
  size_t v4;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  int v29;
  unsigned __int8 *v30;
  int v31;
  std::string::value_type v32;
  int v33;
  int v34;
  unsigned __int8 *v35;
  int v36;
  std::string *v37;
  std::string::size_type size;
  unsigned int v39;
  int v40;
  uint64_t v41;
  const std::string::value_type *v42;
  int v43;
  std::string *v44;
  std::string::size_type v45;
  int v46;
  std::string *v47;
  std::string::size_type v48;
  int v49;
  std::string *v50;
  std::string::size_type v51;
  int v52;
  int v53;
  int v54;
  std::string *v55;
  const std::string::value_type *v57;
  std::string::size_type v58;
  const std::string::value_type *v59;
  std::string::size_type v60;
  void *v61;
  _BYTE *v62;
  std::string v63;
  std::string __p;
  std::string v65;
  unsigned __int8 v66;
  int v67;
  int v68[2];

  v4 = 0;
  if (!a1 || !a2)
    return v4;
  memset(&v63, 0, sizeof(v63));
  v65.__r_.__value_.__s.__data_[0] = 0;
  sub_1D3D81DF8(&v61, (int)a2, &v65);
  v9 = 0;
  do
  {
    if (((*(unsigned __int16 *)(a1 + 2 * (v9 >> 4)) << (v9 & 0xF)) & 0x8000) != 0)
    {
      if (v62 - (_BYTE *)v61 <= v9)
        sub_1D3DB6E04();
      *((_BYTE *)v61 + v9) = 1;
    }
    ++v9;
  }
  while (a2 != v9);
  v10 = (char *)v61;
  v11 = v62 - (_BYTE *)v61;
  if (v62 == v61)
    goto LABEL_153;
  if (!*(_BYTE *)v61)
  {
    LODWORD(v12) = 1;
    goto LABEL_123;
  }
  if (v11 < 2)
    goto LABEL_153;
  if (*((_BYTE *)v61 + 1))
  {
    if ((int)v11 < 13)
    {
      LODWORD(v12) = 2;
      goto LABEL_123;
    }
    std::string::append(&v63, "90", 2uLL);
    v13 = v62 - (_BYTE *)v61;
    if ((unint64_t)(v62 - (_BYTE *)v61) >= 3)
    {
      if (*((_BYTE *)v61 + 2))
      {
        if (v13 < 4)
          goto LABEL_153;
        if (*((_BYTE *)v61 + 3))
          v14 = 3;
        else
          v14 = 0;
        v15 = 4;
      }
      else
      {
        v14 = 1;
        v15 = 3;
      }
      if (v13 > v15)
      {
        v17 = v15;
        v18 = v15 + 1;
        if (!*((_BYTE *)v61 + v17))
        {
          v20 = 0;
          goto LABEL_38;
        }
        if (v13 > v18)
        {
          v19 = v17 + 2;
          if (*((_BYTE *)v61 + v18))
            v20 = 2;
          else
            v20 = 1;
          LODWORD(v18) = v19;
LABEL_38:
          if ((int)v13 - (int)v18 >= 5)
            v21 = 5;
          else
            v21 = v13 - v18;
          if ((int)v13 - (int)v18 <= 0)
          {
            v22 = 0;
            LODWORD(v12) = v18 + 5;
          }
          else
          {
            v22 = 0;
            v23 = (unsigned __int8 *)v61 + v18;
            do
            {
              v24 = *v23++;
              v22 = (v24 != 0) | (2 * v22);
              --v21;
            }
            while (v21);
            LODWORD(v12) = v18 + 5;
            if (v22 > 30)
            {
              v25 = v18 + 20;
              if ((int)v18 + 20 > (int)v13)
                goto LABEL_123;
              v22 = 0;
              v26 = 5;
              do
                v22 = (*((_BYTE *)v61 + v18 + v26++) != 0) | (2 * v22);
              while ((_DWORD)v26 != 15);
              v27 = 0;
              v28 = (v18 + 15);
              v29 = v13 - v28;
              if (v29 >= 5)
                v29 = 5;
              v30 = (unsigned __int8 *)v61 + v28;
              do
              {
                v31 = *v30++;
                v27 = (v31 != 0) | (2 * v27);
                --v29;
              }
              while (v29);
              v32 = v27 + 65;
LABEL_60:
              std::to_string(&v65, v22);
              if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v37 = &v65;
              else
                v37 = (std::string *)v65.__r_.__value_.__r.__words[0];
              if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                size = HIBYTE(v65.__r_.__value_.__r.__words[2]);
              else
                size = v65.__r_.__value_.__l.__size_;
              std::string::append(&v63, (const std::string::value_type *)v37, size);
              if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v65.__r_.__value_.__l.__data_);
              std::string::push_back(&v63, v32);
              v68[0] = v25;
              v68[1] = v14;
              LODWORD(__p.__r_.__value_.__r.__words[2]) = 0;
              *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 3) = 0;
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
              *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
              sub_1D3DC19D4((uint64_t)&v65, v68, (uint64_t *)&v61, &__p);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
              if (LODWORD(v65.__r_.__value_.__l.__data_) == 0x7FFFFFFF)
              {
                v39 = -1;
                LODWORD(v12) = v25;
              }
              else
              {
                if ((v66 & 0x80u) == 0)
                  v57 = &v65.__r_.__value_.__s.__data_[8];
                else
                  v57 = (const std::string::value_type *)v65.__r_.__value_.__l.__size_;
                if ((v66 & 0x80u) == 0)
                  v58 = v66;
                else
                  v58 = v65.__r_.__value_.__r.__words[2];
                std::string::append(&v63, v57, v58);
                LODWORD(v12) = v65.__r_.__value_.__l.__data_;
                if (v67 < 0)
                  v39 = -1;
                else
                  v39 = v67;
              }
              if ((char)v66 < 0)
                operator delete((void *)v65.__r_.__value_.__l.__size_);
              if (v20)
              {
                if (v20 == 1)
                {
                  v59 = "21";
                  v60 = 2;
                }
                else
                {
                  v59 = "8004";
                  v60 = 4;
                }
                std::string::append(&v63, v59, v60);
                if (v39 <= 9)
                  std::string::push_back(&v63, v39 + 48);
              }
              goto LABEL_123;
            }
          }
          if ((int)v18 + 9 > (int)v13)
            goto LABEL_123;
          v33 = 0;
          v34 = v13 - v12;
          if (v34 >= 4)
            v34 = 4;
          v35 = (unsigned __int8 *)v61 + v12;
          do
          {
            v36 = *v35++;
            v33 = (v36 != 0) | (2 * v33);
            --v34;
          }
          while (v34);
          v25 = v12 + 4;
          v32 = aBdhijklnpqrstv[v33];
          goto LABEL_60;
        }
      }
    }
LABEL_153:
    sub_1D3DB6E04();
  }
  if (v11 < 3)
    goto LABEL_153;
  if (*((_BYTE *)v61 + 2))
  {
    if (v11 < 4)
      goto LABEL_153;
    if (*((_BYTE *)v61 + 3))
    {
      LODWORD(v12) = 2;
      std::string::append(&v63, "10", 2uLL);
      goto LABEL_123;
    }
  }
  if ((int)v11 >= 19)
  {
    v40 = 0;
    v41 = 2;
    do
      v40 = (*((_BYTE *)v61 + v41++) != 0) | (2 * v40);
    while ((_DWORD)v41 != 18);
    if (v11 <= 0x12)
      goto LABEL_153;
    if (v40 <= 38399)
    {
      if (*((_BYTE *)v61 + 18))
        v42 = "17";
      else
        v42 = "11";
      std::string::append(&v63, v42, 2uLL);
      if (v40 >= 0)
        v43 = v40;
      else
        v43 = v40 + 31;
      if ((v40 + 3839) <= 0x1DFE)
        std::string::push_back(&v63, 48);
      std::to_string(&v65, v40 / 384);
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v44 = &v65;
      else
        v44 = (std::string *)v65.__r_.__value_.__r.__words[0];
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v45 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
      else
        v45 = v65.__r_.__value_.__l.__size_;
      std::string::append(&v63, (const std::string::value_type *)v44, v45);
      v46 = (v43 >> 5) % 12;
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v65.__r_.__value_.__l.__data_);
      if ((v46 + 10) <= 0x12)
        std::string::push_back(&v63, 48);
      std::to_string(&v65, v46 + 1);
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v47 = &v65;
      else
        v47 = (std::string *)v65.__r_.__value_.__r.__words[0];
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v48 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
      else
        v48 = v65.__r_.__value_.__l.__size_;
      std::string::append(&v63, (const std::string::value_type *)v47, v48);
      v49 = v40 - (v43 & 0xFFFFFFE0);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v65.__r_.__value_.__l.__data_);
      if ((v49 + 9) <= 0x12)
        std::string::push_back(&v63, 48);
      std::to_string(&v65, v49);
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v50 = &v65;
      else
        v50 = (std::string *)v65.__r_.__value_.__r.__words[0];
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v51 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
      else
        v51 = v65.__r_.__value_.__l.__size_;
      std::string::append(&v63, (const std::string::value_type *)v50, v51);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v65.__r_.__value_.__l.__data_);
      v10 = (char *)v61;
      LODWORD(v11) = (_DWORD)v62 - (_DWORD)v61;
    }
    v16 = 19;
  }
  else
  {
    v16 = 2;
  }
  v12 = v16;
  if ((int)(v16 + 7) > (int)v11)
    goto LABEL_122;
  v52 = v11 - v16;
  v53 = (int)v11 - (int)v12 >= 7 ? 7 : v11 - v12;
  if (v52 < 1)
    goto LABEL_122;
  v54 = 0;
  do
  {
    v54 = (v10[v12] != 0) | (2 * v54);
    ++v10;
    --v53;
  }
  while (v53);
  if (v54 < 108)
LABEL_122:
    std::string::append(&v63, "10", 2uLL);
LABEL_123:
  sub_1D3DC24A0((uint64_t *)&v61, v12, &v63);
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v63.__r_.__value_.__l.__size_ < a4)
    {
      v55 = (std::string *)v63.__r_.__value_.__r.__words[0];
      goto LABEL_128;
    }
LABEL_129:
    v4 = 0;
    goto LABEL_130;
  }
  if (HIBYTE(v63.__r_.__value_.__r.__words[2]) >= a4)
    goto LABEL_129;
  v55 = &v63;
LABEL_128:
  v4 = strlcpy(a3, (const char *)v55, a4);
LABEL_130:
  if (v61)
  {
    v62 = v61;
    operator delete(v61);
  }
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v63.__r_.__value_.__l.__data_);
  return v4;
}

void sub_1D3DD47F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,void *a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34)
{
  if (a30 < 0)
    operator delete(__p);
  if (a10)
    operator delete(a10);
  if (a18 < 0)
    operator delete(a13);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1D3DD48A0(unint64_t *a1, char a2, uint64_t a3)
{
  __CVBuffer *v5;
  CVReturn v6;
  CVReturn v7;
  NSObject *v8;
  uint64_t result;
  NSObject *v10;
  const __CFString *v11;
  uint8_t buf[8];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (atomic_load(a1))
  {
    v5 = (__CVBuffer *)atomic_load(a1);
    v6 = CVPixelBufferLockBaseAddress(v5, a2 & 1);
    if (v6)
    {
      v7 = v6;
      if (qword_1EFE31850 != -1)
        dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
      v8 = qword_1EFE31848;
      if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&buf[4] = v7;
        _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", buf, 8u);
      }
      v11 = CFSTR("CVPixelBufferLockBaseAddress failed.");
      *(_QWORD *)buf = -2002;
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v11);
      result = 0;
      *(_DWORD *)(a3 + 24) = v7;
      *(_BYTE *)(a3 + 28) = 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v10 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_ERROR, "Invalid pixel buffer", buf, 2u);
    }
    v11 = CFSTR("Invalid pixel buffer.");
    *(_QWORD *)buf = -2002;
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v11);
    return 0;
  }
  return result;
}

uint64_t sub_1D3DD4A58(unint64_t *a1, char a2, uint64_t a3)
{
  __CVBuffer *v5;
  CVReturn v6;
  CVReturn v7;
  NSObject *v8;
  uint64_t result;
  NSObject *v10;
  const __CFString *v11;
  uint8_t buf[8];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (atomic_load(a1))
  {
    v5 = (__CVBuffer *)atomic_load(a1);
    v6 = CVPixelBufferUnlockBaseAddress(v5, a2 & 1);
    if (v6)
    {
      v7 = v6;
      if (qword_1EFE31850 != -1)
        dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
      v8 = qword_1EFE31848;
      if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&buf[4] = v7;
        _os_log_error_impl(&dword_1D3D6B000, v8, OS_LOG_TYPE_ERROR, "CVPixelBufferUnlockBaseAddress failed: %{public}d", buf, 8u);
      }
      v11 = CFSTR("CVPixelBufferUnlockBaseAddress failed.");
      *(_QWORD *)buf = -2002;
      sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v11);
      result = 0;
      *(_DWORD *)(a3 + 24) = v7;
      *(_BYTE *)(a3 + 28) = 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v10 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_ERROR, "Invalid pixel buffer", buf, 2u);
    }
    v11 = CFSTR("Invalid pixel buffer.");
    *(_QWORD *)buf = -2002;
    sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v11);
    return 0;
  }
  return result;
}

uint64_t sub_1D3DD4C10(unint64_t *a1, uint64_t a2, char a3, uint64_t a4)
{
  int v6;
  __IOSurface *v7;
  kern_return_t v8;
  kern_return_t v9;
  NSObject *v10;
  const __CFString *v11;
  NSObject *v12;
  uint64_t result;
  kern_return_t v14;
  NSObject *v15;
  const __CFString *v16;
  uint8_t buf[8];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (atomic_load(a1))
  {
    v6 = *(unsigned __int8 *)(a2 + 8);
    v7 = (__IOSurface *)atomic_load(a1);
    if (v6)
    {
      v8 = IOSurfaceLockPlane();
      if (v8)
      {
        v9 = v8;
        if (qword_1EFE31850 != -1)
          dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
        v10 = qword_1EFE31848;
        if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = v9;
          _os_log_error_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_ERROR, "IOSurfaceLockPlane failed: %{public}d", buf, 8u);
        }
        *(_QWORD *)buf = -2010;
        v11 = CFSTR("IOSurfaceLockPlane failed.");
LABEL_20:
        v16 = v11;
        sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)&v16);
        result = 0;
        *(_DWORD *)(a4 + 56) = v9;
        *(_BYTE *)(a4 + 60) = 1;
        return result;
      }
    }
    else
    {
      v14 = IOSurfaceLock(v7, a3 & 1, 0);
      if (v14)
      {
        v9 = v14;
        if (qword_1EFE31850 != -1)
          dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
        v15 = qword_1EFE31848;
        if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = v9;
          _os_log_error_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", buf, 8u);
        }
        *(_QWORD *)buf = -2010;
        v11 = CFSTR("IOSurfaceLock failed.");
        goto LABEL_20;
      }
    }
    return 1;
  }
  else
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v12 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "Invalid IOSurface", buf, 2u);
    }
    v16 = CFSTR("Invalid IOSurface.");
    *(_QWORD *)buf = -2010;
    sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)&v16);
    return 0;
  }
}

uint64_t sub_1D3DD4E7C(unint64_t *a1, uint64_t a2, char a3, uint64_t a4)
{
  int v6;
  __IOSurface *v7;
  kern_return_t v8;
  kern_return_t v9;
  NSObject *v10;
  const __CFString *v11;
  NSObject *v12;
  uint64_t result;
  kern_return_t v14;
  NSObject *v15;
  const __CFString *v16;
  uint8_t buf[8];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (atomic_load(a1))
  {
    v6 = *(unsigned __int8 *)(a2 + 8);
    v7 = (__IOSurface *)atomic_load(a1);
    if (v6)
    {
      v8 = IOSurfaceUnlockPlane();
      if (v8)
      {
        v9 = v8;
        if (qword_1EFE31850 != -1)
          dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
        v10 = qword_1EFE31848;
        if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = v9;
          _os_log_error_impl(&dword_1D3D6B000, v10, OS_LOG_TYPE_ERROR, "IOSurfaceUnlockPlane failed: %{public}d", buf, 8u);
        }
        *(_QWORD *)buf = -2010;
        v11 = CFSTR("IOSurfaceUnlockPlane failed.");
LABEL_20:
        v16 = v11;
        sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)&v16);
        result = 0;
        *(_DWORD *)(a4 + 56) = v9;
        *(_BYTE *)(a4 + 60) = 1;
        return result;
      }
    }
    else
    {
      v14 = IOSurfaceUnlock(v7, a3 & 1, 0);
      if (v14)
      {
        v9 = v14;
        if (qword_1EFE31850 != -1)
          dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
        v15 = qword_1EFE31848;
        if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = v9;
          _os_log_error_impl(&dword_1D3D6B000, v15, OS_LOG_TYPE_ERROR, "IOSurfaceUnlock failed: %{public}d", buf, 8u);
        }
        *(_QWORD *)buf = -2010;
        v11 = CFSTR("IOSurfaceUnlock failed.");
        goto LABEL_20;
      }
    }
    return 1;
  }
  else
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v12 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "Invalid IOSurface", buf, 2u);
    }
    v16 = CFSTR("Invalid IOSurface.");
    *(_QWORD *)buf = -2010;
    sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)&v16);
    return 0;
  }
}

unint64_t *sub_1D3DD50E8(CFDictionaryRef *a1, uint64_t *a2, unint64_t *a3)
{
  const __CFAllocator *v6;
  const __CFDictionary *v9;
  void *v10;
  __CFDictionary *v11;
  uint64_t v12;
  CFNumberRef v13;
  const void *v14;
  const void *v15;
  __CFDictionary *v16;
  uint64_t v17;
  CFNumberRef v18;
  const void *v19;
  const void *v20;
  __CFDictionary *v21;
  uint64_t v22;
  CFNumberRef v23;
  const void *v24;
  const void *v25;
  __CFDictionary *v26;
  uint64_t v27;
  CFNumberRef v28;
  const void *v29;
  const void *v30;
  __CFDictionary *v31;
  uint64_t v32;
  CFNumberRef v33;
  const void *v34;
  const void *v35;
  __CFDictionary *v36;
  uint64_t v37;
  CFNumberRef v38;
  const void *v39;
  const void *v40;
  __CFDictionary *v41;
  CFNumberRef v42;
  const void *v43;
  const void *v44;
  __CFDictionary *v45;
  CFTypeRef *v46;
  CFTypeRef v47;
  const void *v48;
  const void *v49;
  __CFDictionary *v50;
  CFNumberRef v51;
  const void *v52;
  const void *v53;
  __CFDictionary *v55;
  const void *v56;
  const void *v57;
  const __CFDictionary *v58;
  CFDictionaryRef Copy;
  NSObject *v60;
  CFNumberRef v62;
  CFMutableDictionaryRef Mutable;
  unint64_t valuePtr;
  uint64_t v65;

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (atomic_load((unint64_t *)&Mutable))
  {
    if (atomic_load(a3))
    {
      v9 = (const __CFDictionary *)atomic_load(a3);
      v10 = (void *)atomic_load((unint64_t *)&Mutable);
      CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)sub_1D3DD5580, v10);
    }
    if (*((_BYTE *)a2 + 8))
    {
      v11 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v12 = *a2;
      valuePtr = 0;
      v65 = v12;
      v13 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v14 = (const void *)*MEMORY[0x1E0CBBEE0];
      v62 = v13;
      v15 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v11, v14, v15);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (*((_BYTE *)a2 + 24))
    {
      v16 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v17 = a2[2];
      valuePtr = 0;
      v65 = v17;
      v18 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v19 = (const void *)*MEMORY[0x1E0CBC1E0];
      v62 = v18;
      v20 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v16, v19, v20);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (*((_BYTE *)a2 + 40))
    {
      v21 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v22 = a2[4];
      valuePtr = 0;
      v65 = v22;
      v23 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v24 = (const void *)*MEMORY[0x1E0CBC008];
      v62 = v23;
      v25 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v21, v24, v25);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (*((_BYTE *)a2 + 56))
    {
      v26 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v27 = a2[6];
      valuePtr = 0;
      v65 = v27;
      v28 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v29 = (const void *)*MEMORY[0x1E0CBBF08];
      v62 = v28;
      v30 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v26, v29, v30);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (*((_BYTE *)a2 + 72))
    {
      v31 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v32 = a2[8];
      valuePtr = 0;
      v65 = v32;
      v33 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v34 = (const void *)*MEMORY[0x1E0CBBF00];
      v62 = v33;
      v35 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v31, v34, v35);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (*((_BYTE *)a2 + 88))
    {
      v36 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v37 = a2[10];
      valuePtr = 0;
      v65 = v37;
      v38 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v39 = (const void *)*MEMORY[0x1E0CBC058];
      v62 = v38;
      v40 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v36, v39, v40);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (*((_BYTE *)a2 + 100))
    {
      v41 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      valuePtr = *((unsigned int *)a2 + 24);
      v42 = CFNumberCreate(v6, kCFNumberSInt64Type, &valuePtr);
      v43 = (const void *)*MEMORY[0x1E0CBBF10];
      v62 = v42;
      v44 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v41, v43, v44);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (*((_BYTE *)a2 + 105))
    {
      v45 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v46 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      if (!*((_BYTE *)a2 + 104))
        v46 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
      v47 = CFRetain(*v46);
      v48 = (const void *)*MEMORY[0x1E0CBC018];
      valuePtr = (unint64_t)v47;
      v49 = (const void *)atomic_load(&valuePtr);
      CFDictionarySetValue(v45, v48, v49);
      sub_1D3DD5594(&valuePtr);
    }
    if (*((_BYTE *)a2 + 112))
    {
      v50 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      valuePtr = *((unsigned int *)a2 + 27);
      v51 = CFNumberCreate(v6, kCFNumberSInt64Type, &valuePtr);
      v52 = (const void *)*MEMORY[0x1E0CBC070];
      v62 = v51;
      v53 = (const void *)atomic_load((unint64_t *)&v62);
      CFDictionarySetValue(v50, v52, v53);
      sub_1D3D74100((unint64_t *)&v62);
    }
    if (atomic_load((unint64_t *)a2 + 15))
    {
      v55 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v56 = (const void *)*MEMORY[0x1E0CBC048];
      v57 = (const void *)atomic_load((unint64_t *)a2 + 15);
      CFDictionarySetValue(v55, v56, v57);
    }
    v58 = (const __CFDictionary *)atomic_load((unint64_t *)&Mutable);
    Copy = CFDictionaryCreateCopy(v6, v58);
  }
  else
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v60 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      LOWORD(valuePtr) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v60, OS_LOG_TYPE_ERROR, "CFDictionaryCreateMutable failed", (uint8_t *)&valuePtr, 2u);
    }
    Copy = 0;
  }
  *a1 = Copy;
  return sub_1D3D740C8((unint64_t *)&Mutable);
}

void sub_1D3DD5508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10)
{
  sub_1D3D74100(&a9);
  sub_1D3D740C8(&a10);
  _Unwind_Resume(a1);
}

void sub_1D3DD5580(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

unint64_t *sub_1D3DD5594(unint64_t *a1)
{
  const void *v2;

  do
    v2 = (const void *)__ldaxr(a1);
  while (__stlxr(0, a1));
  if (v2)
    CFRelease(v2);
  return a1;
}

unint64_t *sub_1D3DD55CC(CFDictionaryRef *a1, uint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  const __CFAllocator *v8;
  const __CFDictionary *v11;
  void *v12;
  __CFDictionary *v13;
  uint64_t v14;
  CFNumberRef v15;
  const void *v16;
  const void *v17;
  __CFDictionary *v18;
  uint64_t v19;
  CFNumberRef v20;
  const void *v21;
  const void *v22;
  __CFDictionary *v23;
  CFNumberRef v24;
  const void *v25;
  const void *v26;
  __CFDictionary *v27;
  uint64_t v28;
  CFNumberRef v29;
  const void *v30;
  const void *v31;
  __CFDictionary *v32;
  uint64_t v33;
  CFNumberRef v34;
  const void *v35;
  const void *v36;
  CFTypeRef *v37;
  CFTypeRef *v38;
  __CFDictionary *v39;
  CFTypeRef *v40;
  const __CFDictionary *v41;
  const void *v42;
  const void *v43;
  __CFDictionary *v44;
  CFTypeRef *v45;
  const __CFDictionary *v46;
  const void *v47;
  const void *v48;
  __CFDictionary *v49;
  CFTypeRef *v50;
  const __CFDictionary *v51;
  const void *v52;
  const void *v53;
  __CFDictionary *v54;
  const void *v55;
  const void *v56;
  NSObject *v57;
  CFDictionaryRef Copy;
  __CFDictionary *v60;
  const void *v61;
  const void *v62;
  __CFDictionary *v63;
  CFTypeRef *v64;
  const __CFDictionary *v65;
  const void *v66;
  const void *v67;
  const __CFDictionary *v68;
  CFNumberRef v70;
  CFMutableDictionaryRef Mutable;
  unint64_t valuePtr;
  uint64_t v73;

  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (atomic_load((unint64_t *)&Mutable))
  {
    if (atomic_load(a3))
    {
      v11 = (const __CFDictionary *)atomic_load(a3);
      v12 = (void *)atomic_load((unint64_t *)&Mutable);
      CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)sub_1D3DD5AC4, v12);
    }
    if (*((_BYTE *)a2 + 8))
    {
      v13 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v14 = *a2;
      valuePtr = 0;
      v73 = v14;
      v15 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v16 = (const void *)*MEMORY[0x1E0CA90E0];
      v70 = v15;
      v17 = (const void *)atomic_load((unint64_t *)&v70);
      CFDictionarySetValue(v13, v16, v17);
      sub_1D3D74100((unint64_t *)&v70);
    }
    if (*((_BYTE *)a2 + 24))
    {
      v18 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v19 = a2[2];
      valuePtr = 0;
      v73 = v19;
      v20 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v21 = (const void *)*MEMORY[0x1E0CA8FD8];
      v70 = v20;
      v22 = (const void *)atomic_load((unint64_t *)&v70);
      CFDictionarySetValue(v18, v21, v22);
      sub_1D3D74100((unint64_t *)&v70);
    }
    if (*((_BYTE *)a2 + 36))
    {
      v23 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      valuePtr = *((unsigned int *)a2 + 8);
      v24 = CFNumberCreate(v8, kCFNumberSInt64Type, &valuePtr);
      v25 = (const void *)*MEMORY[0x1E0CA9040];
      v70 = v24;
      v26 = (const void *)atomic_load((unint64_t *)&v70);
      CFDictionarySetValue(v23, v25, v26);
      sub_1D3D74100((unint64_t *)&v70);
    }
    if (*((_BYTE *)a2 + 48))
    {
      v27 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v28 = a2[5];
      valuePtr = 0;
      v73 = v28;
      v29 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v30 = (const void *)*MEMORY[0x1E0CA8F68];
      v70 = v29;
      v31 = (const void *)atomic_load((unint64_t *)&v70);
      CFDictionarySetValue(v27, v30, v31);
      sub_1D3D74100((unint64_t *)&v70);
    }
    if (*((_BYTE *)a2 + 64))
    {
      v32 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v33 = a2[7];
      valuePtr = 0;
      v73 = v33;
      v34 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      v35 = (const void *)*MEMORY[0x1E0CA9048];
      v70 = v34;
      v36 = (const void *)atomic_load((unint64_t *)&v70);
      CFDictionarySetValue(v32, v35, v36);
      sub_1D3D74100((unint64_t *)&v70);
    }
    v37 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
    v38 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
    if (*((_BYTE *)a2 + 73))
    {
      v39 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      if (*((_BYTE *)a2 + 72))
        v40 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      else
        v40 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
      v41 = (const __CFDictionary *)CFRetain(*v40);
      v42 = (const void *)*MEMORY[0x1E0CA8F70];
      valuePtr = (unint64_t)v41;
      v43 = (const void *)atomic_load(&valuePtr);
      CFDictionarySetValue(v39, v42, v43);
      sub_1D3DD5594(&valuePtr);
    }
    if (*((_BYTE *)a2 + 75))
    {
      v44 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      if (*((_BYTE *)a2 + 74))
        v45 = v37;
      else
        v45 = v38;
      v46 = (const __CFDictionary *)CFRetain(*v45);
      v47 = (const void *)*MEMORY[0x1E0CA8F78];
      valuePtr = (unint64_t)v46;
      v48 = (const void *)atomic_load(&valuePtr);
      CFDictionarySetValue(v44, v47, v48);
      sub_1D3DD5594(&valuePtr);
    }
    if (*((_BYTE *)a2 + 77))
    {
      v49 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      if (*((_BYTE *)a2 + 76))
        v50 = v37;
      else
        v50 = v38;
      v51 = (const __CFDictionary *)CFRetain(*v50);
      v52 = (const void *)*MEMORY[0x1E0CA9010];
      valuePtr = (unint64_t)v51;
      v53 = (const void *)atomic_load(&valuePtr);
      CFDictionarySetValue(v49, v52, v53);
      sub_1D3DD5594(&valuePtr);
    }
    if (*((_BYTE *)a2 + 208))
    {
      v54 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      sub_1D3DD50E8((CFDictionaryRef *)&valuePtr, a2 + 10, a4);
      v55 = (const void *)*MEMORY[0x1E0CA8FF0];
      v56 = (const void *)atomic_load(&valuePtr);
      CFDictionarySetValue(v54, v55, v56);
      sub_1D3D8BAAC(&valuePtr);
    }
    else if (atomic_load(a4))
    {
      v60 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v61 = (const void *)*MEMORY[0x1E0CA8FF0];
      v62 = (const void *)atomic_load(a4);
      CFDictionarySetValue(v60, v61, v62);
    }
    if (*((_BYTE *)a2 + 217))
    {
      v63 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      if (*((_BYTE *)a2 + 216))
        v64 = v37;
      else
        v64 = v38;
      v65 = (const __CFDictionary *)CFRetain(*v64);
      v66 = (const void *)*MEMORY[0x1E0CA8FE8];
      valuePtr = (unint64_t)v65;
      v67 = (const void *)atomic_load(&valuePtr);
      CFDictionarySetValue(v63, v66, v67);
      sub_1D3DD5594(&valuePtr);
    }
    v68 = (const __CFDictionary *)atomic_load((unint64_t *)&Mutable);
    Copy = CFDictionaryCreateCopy(v8, v68);
  }
  else
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v57 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      LOWORD(valuePtr) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v57, OS_LOG_TYPE_ERROR, "CFDictionaryCreateMutable failed", (uint8_t *)&valuePtr, 2u);
    }
    Copy = 0;
  }
  *a1 = Copy;
  return sub_1D3D740C8((unint64_t *)&Mutable);
}

void sub_1D3DD5A38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  unint64_t v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  sub_1D3DD5594((unint64_t *)va1);
  sub_1D3D740C8((unint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D3DD5AC4(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

unint64_t *sub_1D3DD5AD8(CFDictionaryRef *a1, uint64_t *a2, unint64_t *a3)
{
  const __CFAllocator *v6;
  const __CFDictionary *v9;
  void *v10;
  __CFDictionary *v11;
  uint64_t v12;
  CFNumberRef v13;
  const void *v14;
  const void *v15;
  __CFDictionary *v16;
  CFNumberRef v17;
  const void *v18;
  const void *v19;
  const __CFDictionary *v20;
  CFDictionaryRef Copy;
  NSObject *v22;
  CFNumberRef v24;
  CFMutableDictionaryRef Mutable;
  _QWORD valuePtr[2];

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (atomic_load((unint64_t *)&Mutable))
  {
    if (atomic_load(a3))
    {
      v9 = (const __CFDictionary *)atomic_load(a3);
      v10 = (void *)atomic_load((unint64_t *)&Mutable);
      CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)sub_1D3DD5CC8, v10);
    }
    if (*((_BYTE *)a2 + 8))
    {
      v11 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      v12 = *a2;
      valuePtr[0] = 0;
      valuePtr[1] = v12;
      v13 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, valuePtr);
      v14 = (const void *)*MEMORY[0x1E0CA9060];
      v24 = v13;
      v15 = (const void *)atomic_load((unint64_t *)&v24);
      CFDictionarySetValue(v11, v14, v15);
      sub_1D3D74100((unint64_t *)&v24);
    }
    if (*((_BYTE *)a2 + 24))
    {
      v16 = (__CFDictionary *)atomic_load((unint64_t *)&Mutable);
      valuePtr[0] = a2[2];
      v17 = CFNumberCreate(v6, kCFNumberDoubleType, valuePtr);
      v18 = (const void *)*MEMORY[0x1E0CA9058];
      v24 = v17;
      v19 = (const void *)atomic_load((unint64_t *)&v24);
      CFDictionarySetValue(v16, v18, v19);
      sub_1D3D74100((unint64_t *)&v24);
    }
    v20 = (const __CFDictionary *)atomic_load((unint64_t *)&Mutable);
    Copy = CFDictionaryCreateCopy(v6, v20);
  }
  else
  {
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v22 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      LOWORD(valuePtr[0]) = 0;
      _os_log_error_impl(&dword_1D3D6B000, v22, OS_LOG_TYPE_ERROR, "CFDictionaryCreateMutable failed", (uint8_t *)valuePtr, 2u);
    }
    Copy = 0;
  }
  *a1 = Copy;
  return sub_1D3D740C8((unint64_t *)&Mutable);
}

void sub_1D3DD5C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10)
{
  sub_1D3D74100(&a9);
  sub_1D3D740C8(&a10);
  _Unwind_Resume(a1);
}

void sub_1D3DD5CC8(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

uint64_t sub_1D3DD5CDC(CVPixelBufferPoolRef *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  const __CFAllocator *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  uint64_t result;
  int v10;
  NSObject *v11;
  CVPixelBufferPoolRef v12;
  const __CFString *v13;
  CVPixelBufferPoolRef poolOut;
  uint8_t buf[8];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  poolOut = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = (const __CFDictionary *)atomic_load(a2);
  v8 = (const __CFDictionary *)atomic_load(a3);
  result = CVPixelBufferPoolCreate(v6, v7, v8, &poolOut);
  if ((_DWORD)result)
  {
    v10 = result;
    if (qword_1EFE31850 != -1)
      dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
    v11 = qword_1EFE31848;
    if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&buf[4] = v10;
      _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "CVPixelBufferPoolCreate failed: %{public}d", buf, 8u);
    }
    *(_QWORD *)buf = -2003;
    v13 = CFSTR("CVPixelBufferPoolCreate failed.");
    result = sub_1D3D73E0C((unint64_t *)a4, (uint64_t *)buf, (CFTypeRef *)&v13);
    v12 = 0;
    *(_DWORD *)(a4 + 24) = v10;
    *(_BYTE *)(a4 + 28) = 1;
  }
  else
  {
    v12 = poolOut;
  }
  *a1 = v12;
  return result;
}

unint64_t *sub_1D3DD5E18(CVPixelBufferPoolRef *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  CFDictionaryRef v10;
  unint64_t v11;
  CFDictionaryRef v12;

  v11 = 0;
  sub_1D3DD5AD8(&v12, a2, &v11);
  v8 = 0;
  v9 = 0;
  sub_1D3DD55CC(&v10, a3, &v9, &v8);
  sub_1D3DD5CDC(a1, (unint64_t *)&v12, (unint64_t *)&v10, a4);
  sub_1D3D8BAAC((unint64_t *)&v10);
  sub_1D3D8BAAC(&v8);
  sub_1D3D8BAAC(&v9);
  sub_1D3D8BAAC((unint64_t *)&v12);
  return sub_1D3D8BAAC(&v11);
}

void sub_1D3DD5EB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  unint64_t v3;
  va_list va;
  unint64_t v5;
  va_list va1;
  unint64_t v7;
  va_list va2;
  unint64_t v9;
  va_list va3;
  va_list va4;

  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v5 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v7 = va_arg(va3, _QWORD);
  va_copy(va4, va3);
  v9 = va_arg(va4, _QWORD);
  sub_1D3D8BAAC((unint64_t *)va2);
  sub_1D3D8BAAC((unint64_t *)va);
  sub_1D3D8BAAC((unint64_t *)va1);
  sub_1D3D8BAAC((unint64_t *)va4);
  sub_1D3D8BAAC((unint64_t *)va3);
  _Unwind_Resume(a1);
}

unint64_t *sub_1D3DD5EF4(CVPixelBufferPoolRef *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  CFDictionaryRef v8;
  unint64_t v9;

  v9 = 0;
  v6 = 0;
  v7 = 0;
  sub_1D3DD55CC(&v8, a2, &v7, &v6);
  sub_1D3DD5CDC(a1, &v9, (unint64_t *)&v8, a3);
  sub_1D3D8BAAC((unint64_t *)&v8);
  sub_1D3D8BAAC(&v6);
  sub_1D3D8BAAC(&v7);
  return sub_1D3D8BAAC(&v9);
}

void sub_1D3DD5F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11, unint64_t a12)
{
  sub_1D3D8BAAC(&a11);
  sub_1D3D8BAAC(&a9);
  sub_1D3D8BAAC(&a10);
  sub_1D3D8BAAC(&a12);
  _Unwind_Resume(a1);
}

unint64_t *sub_1D3DD5F9C(CVPixelBufferRef *a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v6;
  const __CFAllocator *v7;
  __CVPixelBufferPool *v8;
  const __CFDictionary *v9;
  CVReturn PixelBufferWithAuxAttributes;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  CVPixelBufferRef v14;
  unint64_t v16;
  const __CFString *v17;
  CVPixelBufferRef pixelBufferOut[2];
  uint8_t buf[8];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  if (atomic_load(a2))
  {
    pixelBufferOut[0] = 0;
    v6 = atomic_load(&v16);
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = (__CVPixelBufferPool *)atomic_load(a2);
    if (v6)
    {
      v9 = (const __CFDictionary *)atomic_load(&v16);
      PixelBufferWithAuxAttributes = CVPixelBufferPoolCreatePixelBufferWithAuxAttributes(v7, v8, v9, pixelBufferOut);
      if (PixelBufferWithAuxAttributes)
      {
        if (qword_1EFE31850 != -1)
          dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
        v11 = qword_1EFE31848;
        if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = PixelBufferWithAuxAttributes;
          _os_log_error_impl(&dword_1D3D6B000, v11, OS_LOG_TYPE_ERROR, "CVPixelBufferPoolCreatePixelBufferWithAuxAttributes failed: %{public}d", buf, 8u);
        }
        *(_QWORD *)buf = -2003;
        v17 = CFSTR("CVPixelBufferPoolCreatePixelBufferWithAuxAttributes failed.");
        sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v17);
LABEL_20:
        v14 = 0;
        *(_DWORD *)(a3 + 24) = PixelBufferWithAuxAttributes;
        *(_BYTE *)(a3 + 28) = 1;
LABEL_22:
        *a1 = v14;
        return sub_1D3D8BAAC(&v16);
      }
    }
    else
    {
      PixelBufferWithAuxAttributes = CVPixelBufferPoolCreatePixelBuffer(v7, v8, pixelBufferOut);
      if (PixelBufferWithAuxAttributes)
      {
        if (qword_1EFE31850 != -1)
          dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
        v13 = qword_1EFE31848;
        if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = PixelBufferWithAuxAttributes;
          _os_log_error_impl(&dword_1D3D6B000, v13, OS_LOG_TYPE_ERROR, "CVPixelBufferPoolCreatePixelBuffer failed: %{public}d", buf, 8u);
        }
        *(_QWORD *)buf = -2003;
        v17 = CFSTR("CVPixelBufferPoolCreatePixelBuffer failed.");
        sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)buf, (CFTypeRef *)&v17);
        goto LABEL_20;
      }
    }
    v14 = pixelBufferOut[0];
    goto LABEL_22;
  }
  if (qword_1EFE31850 != -1)
    dispatch_once(&qword_1EFE31850, &unk_1E95B04D0);
  v12 = qword_1EFE31848;
  if (os_log_type_enabled((os_log_t)qword_1EFE31848, OS_LOG_TYPE_ERROR))
  {
    LOWORD(pixelBufferOut[0]) = 0;
    _os_log_error_impl(&dword_1D3D6B000, v12, OS_LOG_TYPE_ERROR, "Invalid pixel buffer pool", (uint8_t *)pixelBufferOut, 2u);
  }
  pixelBufferOut[0] = (CVPixelBufferRef)-2003;
  *(_QWORD *)buf = CFSTR("Invalid pixel buffer pool.");
  sub_1D3D73E0C((unint64_t *)a3, (uint64_t *)pixelBufferOut, (CFTypeRef *)buf);
  *a1 = 0;
  return sub_1D3D8BAAC(&v16);
}

