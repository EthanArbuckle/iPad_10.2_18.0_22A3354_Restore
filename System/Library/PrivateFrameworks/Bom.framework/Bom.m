uint64_t BOMCFArrayMaxRange(const __CFArray *a1)
{
  CFArrayGetCount(a1);
  return 0;
}

const __CFString *BOMCFStringGetUTF8String(CFStringRef theString)
{
  const __CFString *v1;
  const char *CStringPtr;
  char *v3;
  size_t v4;
  __CFString *v5;
  char *v6;
  size_t v7;
  size_t v8;
  char buffer[1024];
  uint64_t v11;

  v1 = theString;
  v11 = *MEMORY[0x24BDAC8D0];
  if (theString)
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
    if (!CStringPtr || (v3 = (char *)CStringPtr, !*CStringPtr))
    {
      if (!CFStringGetCString(v1, buffer, 1024, 0x8000100u))
        return 0;
      v8 = strlen(buffer) + 1;
      v5 = (__CFString *)BOM_malloc(v8);
      if (!v5)
        return 0;
      v1 = v5;
      v6 = buffer;
      v7 = v8;
      goto LABEL_9;
    }
    v4 = strlen(CStringPtr) + 1;
    v5 = (__CFString *)BOM_malloc(v4);
    v1 = v5;
    if (v5)
    {
      v6 = v3;
      v7 = v4;
LABEL_9:
      memmove(v5, v6, v7);
    }
  }
  return v1;
}

CFPropertyListRef BOMCFPropertyListReadFromPath(uint64_t a1, CFOptionFlags a2)
{
  return BOMCFPropertyListReadFromPathWithSys(a1, a2, 0);
}

CFPropertyListRef BOMCFPropertyListReadFromPathWithSys(uint64_t a1, CFOptionFlags a2, void *a3)
{
  void *v3;
  CFIndex v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFData *v12;
  const __CFData *v13;
  CFPropertyListRef v14;
  _OWORD v16[6];
  __int128 v17;
  __int128 v18;
  __int128 v19;

  if (!a1)
    return 0;
  v3 = a3;
  if (!a3)
    v3 = BomSys_default();
  v18 = 0u;
  v19 = 0u;
  v17 = 0u;
  memset(v16, 0, sizeof(v16));
  if ((*((unsigned int (**)(_QWORD, uint64_t, _OWORD *))v3 + 10))(*((_QWORD *)v3 + 1), a1, v16))
    return 0;
  v6 = v17;
  v7 = BOM_malloc(v17);
  if (!v7)
    return 0;
  v8 = v7;
  v9 = (*((uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))v3 + 2))(*((_QWORD *)v3 + 1), a1, 0, 0);
  if ((_DWORD)v9 == -1
    || (v10 = v9,
        v11 = (*((uint64_t (**)(_QWORD, uint64_t, void *, CFIndex))v3 + 6))(*((_QWORD *)v3 + 1), v9, v8, v6),
        (*((void (**)(_QWORD, uint64_t))v3 + 4))(*((_QWORD *)v3 + 1), v10),
        v11 != v6)
    || (v12 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v8, v6, (CFAllocatorRef)*MEMORY[0x24BDBD248])) == 0)
  {
    free(v8);
    return 0;
  }
  v13 = v12;
  v14 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x24BDBD240], v12, a2, 0, 0);
  CFRelease(v13);
  return v14;
}

BOOL BOMCFPropertyListWriteToPath(const void *a1, uint64_t a2)
{
  return BOMCFPropertyListWriteToPathWithSys(a1, a2, 0);
}

BOOL BOMCFPropertyListWriteToPathWithSys(CFPropertyListRef propertyList, uint64_t a2, uint64_t (**a3)(_QWORD, uint64_t, uint64_t, uint64_t))
{
  _BOOL8 v3;
  CFDataRef Data;
  const __CFData *v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex Length;
  uint64_t (*v11)(_QWORD, uint64_t, const UInt8 *, CFIndex);
  uint64_t (*v12)(_QWORD, uint64_t, uint64_t, uint64_t);
  const UInt8 *BytePtr;

  v3 = 1;
  if (propertyList)
  {
    if (a2)
    {
      Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x24BDBD240], propertyList, kCFPropertyListXMLFormat_v1_0, 0, 0);
      if (Data)
      {
        v7 = Data;
        if (!a3)
          a3 = (uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))BomSys_default();
        v8 = a3[2](a3[1], a2, 513, 420);
        if ((_DWORD)v8 != -1)
        {
          v9 = v8;
          Length = CFDataGetLength(v7);
          v11 = (uint64_t (*)(_QWORD, uint64_t, const UInt8 *, CFIndex))a3[7];
          v12 = a3[1];
          BytePtr = CFDataGetBytePtr(v7);
          v3 = v11(v12, v9, BytePtr, Length) != Length;
          ((void (*)(uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t), uint64_t))a3[4])(a3[1], v9);
        }
        CFRelease(v7);
      }
    }
  }
  return v3;
}

const __CFBoolean *BOMCFGetBoolValue(const __CFBoolean *result)
{
  const __CFBoolean *v1;
  CFTypeID v2;
  CFTypeID v3;
  CFTypeID v4;
  const char *UTF8String;
  char *v6;
  char v7;
  int valuePtr;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFBooleanGetTypeID())
    {
      return (const __CFBoolean *)CFBooleanGetValue(v1);
    }
    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFNumberGetTypeID())
      {
        valuePtr = 0;
        CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
        return (const __CFBoolean *)(valuePtr != 0);
      }
      else
      {
        v4 = CFGetTypeID(v1);
        if (v4 == CFStringGetTypeID())
        {
          UTF8String = (const char *)BOMCFStringGetUTF8String((CFStringRef)v1);
          v6 = (char *)UTF8String;
          do
          {
            v7 = __tolower(*v6);
            *v6++ = v7;
          }
          while (v7);
          return (const __CFBoolean *)(strcmp(UTF8String, "yes") == 0);
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t BOMCFGetIntValue(const void *a1)
{
  CFTypeID TypeID;
  unsigned int valuePtr;

  if (!a1)
    return 0xFFFFFFFFLL;
  TypeID = CFNumberGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    return 0xFFFFFFFFLL;
  valuePtr = 0;
  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr))
    return valuePtr;
  else
    return 0xFFFFFFFFLL;
}

void *BOM_malloc(size_t a1)
{
  void *v1;
  int *v2;
  char *v3;
  char *v4;
  int *v5;

  v1 = malloc_type_malloc(a1, 0x5414152EuLL);
  if (!v1)
  {
    v2 = __error();
    v3 = strerror(*v2);
    v4 = BOMExceptionHandlerMessage("malloc: %s\n", v3);
    v5 = __error();
    _BOMExceptionHandlerCall((uint64_t)v4, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 27, *v5);
  }
  return v1;
}

void *BOM_malloczero(size_t size)
{
  void *v2;
  void *v3;
  int *v4;
  char *v5;
  char *v6;
  int *v7;

  v2 = malloc_type_calloc(1uLL, size, 0xA378B4FEuLL);
  v3 = v2;
  if (v2)
  {
    bzero(v2, size);
  }
  else
  {
    v4 = __error();
    v5 = strerror(*v4);
    v6 = BOMExceptionHandlerMessage("calloc: %s\n", v5);
    v7 = __error();
    _BOMExceptionHandlerCall((uint64_t)v6, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 38, *v7);
  }
  return v3;
}

void *BOM_calloc(size_t a1, size_t a2)
{
  void *v2;
  int *v3;
  char *v4;
  char *v5;
  int *v6;

  v2 = malloc_type_calloc(a1, a2, 0xC024D4AuLL);
  if (!v2)
  {
    v3 = __error();
    v4 = strerror(*v3);
    v5 = BOMExceptionHandlerMessage("calloc: %s\n", v4);
    v6 = __error();
    _BOMExceptionHandlerCall((uint64_t)v5, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 52, *v6);
  }
  return v2;
}

void *BOM_realloc(void *a1, size_t a2)
{
  void *v2;
  int *v3;
  char *v4;
  char *v5;
  int *v6;

  v2 = reallocf(a1, a2);
  if (!v2)
  {
    v3 = __error();
    v4 = strerror(*v3);
    v5 = BOMExceptionHandlerMessage("reallocf: %s\n", v4);
    v6 = __error();
    _BOMExceptionHandlerCall((uint64_t)v5, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 66, *v6);
  }
  return v2;
}

char *BOM_realloczero(void *a1, unint64_t a2, size_t __size)
{
  char *v5;
  char *v6;
  int *v7;
  char *v8;
  char *v9;
  int *v10;

  v5 = (char *)reallocf(a1, __size);
  v6 = v5;
  if (v5)
  {
    if (__size > a2)
      bzero(&v5[a2], __size - a2);
  }
  else
  {
    v7 = __error();
    v8 = strerror(*v7);
    v9 = BOMExceptionHandlerMessage("reallocf: %s\n", v8);
    v10 = __error();
    _BOMExceptionHandlerCall((uint64_t)v9, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 80, *v10);
  }
  return v6;
}

uint64_t BOM_strrncmp(const char *a1, const char *a2, size_t a3)
{
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;

  v6 = strlen(a1);
  v7 = strlen(a2);
  if (v6 >= v7)
    v8 = v7;
  else
    v8 = v6;
  if (v8 >= a3)
    v9 = a3;
  else
    v9 = v8;
  return strncmp(&a1[v6 - v8], &a2[v7 - v8], v9);
}

uint64_t pkzip_crypto_init(int *a1, char *__s)
{
  char *v2;
  uint64_t result;
  uint64_t v5;
  unsigned int v6;

  v2 = __s;
  *(_QWORD *)a1 = 0x2345678912345678;
  a1[2] = 878082192;
  result = strlen(__s);
  if (result)
  {
    v5 = result;
    do
    {
      v6 = *v2++;
      result = pkzip_crypto_update(a1, v6);
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t pkzip_crypto_update(int *a1, uint64_t a2)
{
  int v2;
  unsigned int v3;

  v2 = PKZip_crctab[(*a1 ^ a2)] ^ (*a1 >> 8);
  v3 = 134775813 * (a1[1] + v2) + 1;
  *a1 = v2;
  a1[1] = v3;
  a1[2] = PKZip_crctab[a1[2] ^ HIBYTE(v3)] ^ (a1[2] >> 8);
  return a2;
}

uint64_t pkzip_crypto_decrypt_buffer(int *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  int v6;
  unsigned int v7;
  int v8;

  if (a3)
  {
    v3 = a3;
    do
    {
      v6 = *a2;
      v7 = (a1[2] & 0xFFFD ^ 3) * (a1[2] | 2);
      v8 = v6 ^ (v7 >> 8);
      pkzip_crypto_update(a1, (char)(v6 ^ BYTE1(v7)));
      *a2++ = v8;
      --v3;
    }
    while (v3);
  }
  return 0;
}

void **BOMStackNew()
{
  void **v0;
  void **v1;
  void *v2;

  v0 = (void **)BOM_calloc(1uLL, 0x18uLL);
  v1 = v0;
  if (v0)
  {
    v0[1] = (void *)1024;
    v2 = BOM_malloczero(0x2000uLL);
    *v1 = v2;
    if (!v2)
    {
      BOMStackFree(v1);
      return 0;
    }
  }
  return v1;
}

void BOMStackFree(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      free(v2);
    free(a1);
  }
}

uint64_t *BOMStackPop(uint64_t *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = *result;
    if (*result && (v2 = result[2]) != 0)
    {
      v3 = v2 - 1;
      result[2] = v3;
      result = *(uint64_t **)(v1 + 8 * v3);
      *(_QWORD *)(v1 + 8 * v3) = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *BOMStackPeek(_QWORD *result)
{
  uint64_t v1;

  if (result)
  {
    if (*result && (v1 = result[2]) != 0)
      return *(_QWORD **)(*result + 8 * v1 - 8);
    else
      return 0;
  }
  return result;
}

_QWORD *BOMStackPoke(_QWORD *result, uint64_t a2)
{
  uint64_t v2;

  if (result && *result)
  {
    v2 = result[2];
    if (v2)
      *(_QWORD *)(*result + 8 * v2 - 8) = a2;
  }
  return result;
}

char *BOMStackPush(char *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v2 = result;
    result = *(char **)result;
    if (result)
    {
      v5 = v2[1];
      v4 = v2[2];
      v6 = v4 + 1;
      if (v4 + 1 < v5)
      {
LABEL_9:
        v2[2] = v6;
        *(_QWORD *)&result[8 * v4] = a2;
        return result;
      }
      if (v5 != 0xFFFFFFF)
      {
        v7 = 2 * v5;
        if (2 * v5 >= 0xFFFFFFF)
          v7 = 0xFFFFFFFLL;
        v2[1] = v7;
        result = BOM_realloczero(result, 8 * v5, 8 * v7);
        *v2 = result;
        if (result)
        {
          v4 = v2[2];
          v6 = v4 + 1;
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

BOOL BOMStackIsEmpty(uint64_t a1)
{
  return !a1 || !*(_QWORD *)a1 || *(_DWORD *)(a1 + 16) < 1;
}

uint64_t BOMStackCount(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)result)
      return *(unsigned int *)(result + 16);
    else
      return 0;
  }
  return result;
}

_QWORD *darc_format_entry_new(uint64_t a1, uint64_t a2)
{
  _QWORD *result;

  if (a2)
    return 0;
  result = platform_calloc(a1, 1uLL, 0x48uLL);
  if (result)
  {
    *(_DWORD *)result = 1853125241;
    result[1] = a1;
    *((_DWORD *)result + 16) = 2037544037;
  }
  return result;
}

void darc_format_entry_free(_QWORD *__b)
{
  char *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  if (__b && *(_DWORD *)__b == 1853125241 && *((_DWORD *)__b + 16) == 2037544037)
  {
    v2 = (char *)__b[5];
    if (v2)
    {
      if (*((_DWORD *)__b + 8))
      {
        v3 = 0;
        v4 = 0;
        do
        {
          if (*(_QWORD *)&v2[v3])
          {
            platform_free(__b[1], *(void **)&v2[v3]);
            v2 = (char *)__b[5];
            *(_QWORD *)&v2[v3] = 0;
          }
          *(_QWORD *)&v2[v3 + 8] = 0;
          if (*(_QWORD *)&v2[v3 + 16])
          {
            platform_free(__b[1], *(void **)&v2[v3 + 16]);
            v2 = (char *)__b[5];
            *(_QWORD *)&v2[v3 + 16] = 0;
          }
          *(_QWORD *)&v2[v3 + 24] = 0;
          ++v4;
          v3 += 32;
        }
        while (v4 < *((unsigned int *)__b + 8));
      }
      platform_free(__b[1], v2);
    }
    v5 = __b[1];
    platform_memset(v5, __b, 0, 0x48uLL);
    platform_free(v5, __b);
  }
}

uint64_t darc_format_entry_set_type(_DWORD *a1, int a2)
{
  uint64_t result;

  if (!a1 || *a1 != 1853125241 || a1[16] != 2037544037)
    return 0xFFFFFFFFLL;
  result = 0;
  a1[4] = a2;
  return result;
}

_DWORD *darc_format_entry_get_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1853125241 && result[16] == 2037544037)
      return (_DWORD *)result[4];
    else
      return 0;
  }
  return result;
}

uint64_t darc_format_entry_set_size(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!a1 || *(_DWORD *)a1 != 1853125241 || *(_DWORD *)(a1 + 64) != 2037544037)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_QWORD *)(a1 + 24) = a2;
  return result;
}

uint64_t darc_format_entry_set_attribute(uint64_t a1, char *__s, void *a3, size_t a4)
{
  uint64_t result;
  size_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  void *v17;
  unsigned int v18;
  void *v19;
  char *v20;
  char **v21;
  void *v22;
  void *v23;
  uint64_t v24;
  FILE *v25;
  int *v26;
  FILE *v27;
  int *v28;
  FILE *v29;
  int *v30;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != 1853125241)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 64) == 2037544037)
    {
      v9 = strlen(__s);
      result = 0xFFFFFFFFLL;
      if (a4)
      {
        if (a3 && v9)
        {
          v10 = *(_DWORD *)(a1 + 32);
          if (v10)
          {
            v11 = 0;
            v12 = 0;
            LODWORD(v13) = 0;
            do
            {
              v14 = *(_QWORD *)(a1 + 40);
              if (v9 == *(_QWORD *)(v14 + v11 + 8))
              {
                v15 = platform_strncmp(*(_QWORD *)(a1 + 8), __s, *(char **)(v14 + v11), v9);
                v16 = v15 == 0;
                if (!v15)
                  LODWORD(v13) = v12;
                v10 = *(_DWORD *)(a1 + 32);
              }
              else
              {
                v16 = 0;
              }
              if (++v12 >= (unint64_t)v10)
                break;
              v11 += 32;
            }
            while (!v16);
            if (v16)
            {
              v17 = *(void **)(*(_QWORD *)(a1 + 40) + 32 * v13 + 16);
              if (v17)
                platform_free(*(_QWORD *)(a1 + 8), v17);
              goto LABEL_24;
            }
          }
          v18 = v10 + 1;
          v19 = platform_realloc(*(_QWORD *)(a1 + 8), *(void **)(a1 + 40), 32 * (v10 + 1));
          if (v19)
          {
            v13 = *(unsigned int *)(a1 + 32);
            *(_DWORD *)(a1 + 32) = v18;
            *(_QWORD *)(a1 + 40) = v19;
            v20 = platform_strdup(*(_QWORD *)(a1 + 8), __s);
            if (v20)
            {
              v21 = (char **)(*(_QWORD *)(a1 + 40) + 32 * v13);
              *v21 = v20;
              v21[1] = (char *)v9;
LABEL_24:
              v22 = platform_malloc(*(_QWORD *)(a1 + 8), a4);
              if (v22)
              {
                v23 = v22;
                platform_memcpy(*(_QWORD *)(a1 + 8), v22, a3, a4);
                result = 0;
                v24 = *(_QWORD *)(a1 + 40) + 32 * v13;
                *(_QWORD *)(v24 + 16) = v23;
                *(_QWORD *)(v24 + 24) = a4;
                return result;
              }
              v27 = (FILE *)*MEMORY[0x24BDAC8D8];
              v28 = __error();
              strerror(*v28);
              fprintf(v27, "Could not allocate %ld bytes for value: %s\n");
              return 0xFFFFFFFFLL;
            }
            v29 = (FILE *)*MEMORY[0x24BDAC8D8];
            v30 = __error();
            strerror(*v30);
            fprintf(v29, "Could not duplicate key %s: %s\n");
          }
          else
          {
            v25 = (FILE *)*MEMORY[0x24BDAC8D8];
            v26 = __error();
            strerror(*v26);
            fprintf(v25, "Could not re-allocate the entry list: %s\n");
          }
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return result;
}

uint64_t darc_format_entry_get_attribute(uint64_t a1, char *__s, void *a3)
{
  uint64_t v5;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (!a1 || *(_DWORD *)a1 != 1853125241)
    return -1;
  v5 = -1;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 64) == 2037544037)
    {
      v7 = platform_strlen(*(_QWORD *)(a1 + 8), __s);
      if (v7)
      {
        if (*(_DWORD *)(a1 + 32))
        {
          v8 = v7;
          v9 = 0;
          v10 = 0;
          do
          {
            v11 = *(_QWORD *)(a1 + 40);
            if (v8 == *(_QWORD *)(v11 + v9 + 8)
              && !platform_strncmp(*(_QWORD *)(a1 + 8), __s, *(char **)(v11 + v9), v8))
            {
              v12 = *(_QWORD *)(a1 + 40) + v9;
              v5 = *(_QWORD *)(v12 + 24);
              if (a3)
                platform_memcpy(*(_QWORD *)(a1 + 8), a3, *(void **)(v12 + 16), *(_QWORD *)(v12 + 24));
            }
            ++v10;
            v9 += 32;
          }
          while (v10 < *(unsigned int *)(a1 + 32));
        }
      }
    }
  }
  return v5;
}

uint64_t darc_format_entry_set_range(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (!a1 || *(_DWORD *)a1 != 1853125241 || *(_DWORD *)(a1 + 64) != 2037544037)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 56) = a3;
  return result;
}

CFMutableArrayRef BOMPatternListNew()
{
  return CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0);
}

void BOMPatternListFree(const __CFArray *a1)
{
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v4;
  CFIndex i;
  void *ValueAtIndex;
  void *v7;

  if (a1)
  {
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      Count = CFArrayGetCount(a1);
      if (Count >= 1)
      {
        v4 = Count;
        for (i = 0; i != v4; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
          if (ValueAtIndex)
          {
            v7 = ValueAtIndex;
            MEMORY[0x20BCF4398]();
            free(v7);
          }
        }
      }
      CFRelease(a1);
    }
  }
}

void BOMPatternFree(void *a1)
{
  if (a1)
  {
    MEMORY[0x20BCF4398]();
    free(a1);
  }
}

regex_t *BOMPatternCompileString(const char *a1)
{
  regex_t *v2;
  regex_t *v3;
  char *v4;
  int *v5;

  v2 = (regex_t *)BOM_malloc(0x20uLL);
  v3 = v2;
  if (v2 && regcomp(v2, a1, 5))
  {
    v4 = BOMExceptionHandlerMessage("**** WARNING **** Can't compile pattern: %s\n", a1);
    v5 = __error();
    _BOMExceptionHandlerCall((uint64_t)v4, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMPatternList.c", 47, *v5);
    free(v3);
    return 0;
  }
  return v3;
}

BOOL BOMPatternMatch(regex_t *a1, const char *a2)
{
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    if (a2)
      return regexec(a1, a2, 0, 0, 0) == 0;
  }
  return result;
}

uint64_t BOMPatternListMatch(const __CFArray *a1, const char *a2)
{
  uint64_t result;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const regex_t *ValueAtIndex;

  result = 0;
  if (a1 && a2)
  {
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1) && (Count = CFArrayGetCount(a1), Count >= 1))
    {
      v7 = Count;
      v8 = 0;
      while (1)
      {
        ValueAtIndex = (const regex_t *)CFArrayGetValueAtIndex(a1, v8);
        if (ValueAtIndex)
        {
          if (!regexec(ValueAtIndex, a2, 0, 0, 0))
            break;
        }
        if (v7 == ++v8)
          return 0;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFArray *BOMPatternListFromStringList(const void *a1)
{
  CFTypeID TypeID;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const char *ValueAtIndex;
  regex_t *v8;

  if (!a1)
    return 0;
  TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    return 0;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0);
  if (Mutable)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = (const char *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        if (ValueAtIndex)
        {
          v8 = BOMPatternCompileString(ValueAtIndex);
          if (v8)
            CFArrayAppendValue(Mutable, v8);
        }
      }
    }
  }
  return Mutable;
}

__CFArray *BOMPatternListExtractFromFile(const char *a1)
{
  FILE *v2;
  FILE *v3;
  __CFArray *Mutable;
  size_t v5;
  size_t v6;
  size_t v7;
  regex_t *v8;
  int *v9;
  char *v10;
  char *v11;
  int *v12;
  char __s[1025];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = fopen(a1, "r");
  if (v2)
  {
    v3 = v2;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0);
    if (Mutable)
    {
      while (1)
      {
        do
        {
          if (!fgets(__s, 1025, v3))
            goto LABEL_11;
          v5 = strlen(__s);
        }
        while (!v5);
        v6 = v5 - 1;
        if (__s[v5 - 1] == 10)
          break;
LABEL_7:
        v7 = strlen(__s);
        if (v7)
        {
          v6 = v7 - 1;
          if (__s[v7 - 1] == 47)
            break;
        }
        v8 = BOMPatternCompileString(__s);
        if (v8)
          CFArrayAppendValue(Mutable, v8);
      }
      __s[v6] = 0;
      goto LABEL_7;
    }
LABEL_11:
    fclose(v3);
  }
  else
  {
    v9 = __error();
    v10 = strerror(*v9);
    v11 = BOMExceptionHandlerMessage("can't open %s for reading: %s\n", a1, v10);
    v12 = __error();
    _BOMExceptionHandlerCall((uint64_t)v11, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMPatternList.c", 130, *v12);
    return 0;
  }
  return Mutable;
}

__CFArray *BOMPatternListExtractFromStrings(int a1, uint64_t a2)
{
  __CFArray *Mutable;
  BOOL v5;
  uint64_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  regex_t *v10;
  char __dst[1025];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0);
  if (Mutable)
    v5 = a1 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = 0;
    while (1)
    {
      strncpy(__dst, *(const char **)(a2 + 8 * v6), 0x400uLL);
      v7 = strlen(__dst);
      if (v7)
        break;
LABEL_13:
      if (++v6 == a1)
        return Mutable;
    }
    v8 = v7 - 1;
    if (__dst[v7 - 1] != 10)
      goto LABEL_9;
    while (1)
    {
      __dst[v8] = 0;
LABEL_9:
      v9 = strlen(__dst);
      if (v9)
      {
        v8 = v9 - 1;
        if (__dst[v9 - 1] == 47)
          continue;
      }
      v10 = BOMPatternCompileString(__dst);
      if (v10)
        CFArrayAppendValue(Mutable, v10);
      goto LABEL_13;
    }
  }
  return Mutable;
}

uint64_t BOMFileNewFromFD(_QWORD *a1, uint64_t a2, char a3, unsigned __int8 *a4)
{
  return BOMFileNewFromFDWithSys(a1, a2, a3, a4, 0);
}

uint64_t BOMFileNewFromFDWithSys(_QWORD *a1, uint64_t a2, char a3, unsigned __int8 *a4, void (**a5)(_QWORD, uint64_t, uint64_t, uint64_t))
{
  _DWORD *v10;
  _DWORD *v11;
  _QWORD *v12;
  uint64_t result;
  _QWORD *v14;
  _QWORD *v15;
  int v16;

  v10 = BOM_malloczero(0x118uLL);
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = v10;
  if (a5)
  {
    if ((a3 & 0x10) == 0)
      goto LABEL_5;
    goto LABEL_4;
  }
  a5 = (void (**)(_QWORD, uint64_t, uint64_t, uint64_t))BomSys_default();
  if ((a3 & 0x10) != 0)
LABEL_4:
    a5[5](a5[1], a2, 48, 1);
LABEL_5:
  *v11 = *a4 == 119;
  v11[2] = a2;
  if (_BOMFileInit(v11, a3 & 0xF, a5))
  {
LABEL_6:
    v12 = v11;
LABEL_7:
    _freeBOMFile(v12);
    return 0xFFFFFFFFLL;
  }
  if ((a3 & 0x20) != 0)
  {
    if (getenv("BOM_ASYNC_DEBUG"))
    {
      gBOMAsyncDebug = 1;
    }
    else if (gBOMAsyncDebug != 1)
    {
LABEL_17:
      v14 = BOM_malloczero(0x118uLL);
      if (!v14)
        goto LABEL_6;
      v15 = v14;
      if (*v11 == 1)
        v16 = 6;
      else
        v16 = 5;
      *(_DWORD *)v14 = v16;
      v14[1] = v11;
      if (_BOMFileInit(v14, 0, a5))
      {
        v12 = v15;
        goto LABEL_7;
      }
      v11 = v15;
      goto LABEL_12;
    }
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "async compression enabled for %d\n", a2);
    goto LABEL_17;
  }
LABEL_12:
  result = 0;
  *a1 = v11;
  return result;
}

uint64_t _BOMFileInit(_DWORD *a1, int a2, void *a3)
{
  void *v5;
  int v6;
  size_t Raw;
  int v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t result;
  _QWORD *v12;
  qos_class_t v13;
  int v14;
  const pthread_attr_t *v15;
  pthread_t *v16;
  void *(__cdecl *v17)(void *);
  _QWORD *v18;
  int v19;
  qos_class_t v20;
  int v21;
  pthread_attr_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    a3 = BomSys_default();
  *((_QWORD *)a1 + 34) = a3;
  v5 = malloc_type_malloc(0x20000uLL, 0xEE4BF368uLL);
  *((_QWORD *)a1 + 11) = v5;
  if (!v5)
    return 0xFFFFFFFFLL;
  switch(a2)
  {
    case 8:
      v6 = 4;
      goto LABEL_10;
    case 2:
      v6 = 2;
      a1[8] = 2;
      goto LABEL_12;
    case 1:
      v6 = 1;
LABEL_10:
      a1[8] = v6;
      a1[60] = -1;
      goto LABEL_12;
  }
  v6 = 0;
  a1[8] = 0;
LABEL_12:
  switch(*a1)
  {
    case 0:
    case 3:
      if (((1 << v6) & 0x16) == 0)
        goto LABEL_58;
      *(_DWORD *)((char *)&v22.__sig + 7) = 0;
      v22.__sig = 0;
      Raw = _BOMFileReadRaw((uint64_t)a1, (UInt8 *)&v22, 11);
      if (Raw == -1)
        return 0xFFFFFFFFLL;
      v8 = a1[8];
      if (v8 == 1)
      {
        if (LOBYTE(v22.__sig) != 31)
          goto LABEL_56;
        goto LABEL_47;
      }
      if (v8 == 4 && LOBYTE(v22.__sig) == 31)
      {
LABEL_47:
        if (BYTE1(v22.__sig) == 139 && BYTE2(v22.__sig) == 8)
        {
          v19 = 1;
          goto LABEL_57;
        }
        goto LABEL_56;
      }
      if ((v8 == 2 || v8 == 4) && LOBYTE(v22.__sig) == 66 && BYTE1(v22.__sig) == 90 && BYTE2(v22.__sig) == 104)
      {
        v19 = 2;
        goto LABEL_57;
      }
LABEL_56:
      v19 = 0;
LABEL_57:
      a1[8] = v19;
      *((_QWORD *)a1 + 9) = Raw;
      a1[20] = 1;
      memcpy(*((void **)a1 + 11), &v22, Raw);
      v6 = a1[8];
LABEL_58:
      if (v6 == 2)
      {
        result = _BOMFileSetupBzip2((uint64_t)a1, 0);
      }
      else if (v6 == 1)
      {
        result = _BOMFileSetupGzip((uint64_t)a1, 0, 1);
      }
      else
      {
LABEL_61:
        result = 0;
      }
      break;
    case 1:
    case 2:
      if (v6 == 1)
        goto LABEL_22;
      if (v6 == 2)
        return _BOMFileSetupBzip2((uint64_t)a1, 1);
      if (v6 != 4)
        goto LABEL_61;
      a1[8] = 1;
LABEL_22:
      *(_DWORD *)((char *)&v22.__sig + 7) = 196608;
      v22.__sig = 559903;
      if (!_BOMFileSetupGzip((uint64_t)a1, 1, 1))
      {
        if (_BOMFileWriteRaw((uint64_t)a1, (UInt8 *)&v22, 10) > 9)
          goto LABEL_61;
        deflateEnd(*((z_streamp *)a1 + 5));
      }
      return 0xFFFFFFFFLL;
    case 4:
      v9 = BOM_malloczero(8uLL);
      if (!v9)
        return 0xFFFFFFFFLL;
      v10 = v9;
      result = 0;
      *v10 = 0;
      *((_QWORD *)a1 + 1) = v10;
      return result;
    case 5:
      result = pthread_once(&gBufferPoolOnce, (void (*)(void))_initBufferPool);
      if ((_DWORD)result)
        return result;
      v12 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v12)
        return 0xFFFFFFFFLL;
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v12);
      *((_QWORD *)a1 + 12) = BOMBufferFIFOCreate();
      *((_QWORD *)a1 + 13) = 0;
      *((_QWORD *)a1 + 29) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 42), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 30), 0))
        return 1;
      memset(&v22, 0, sizeof(v22));
      v13 = qos_class_self();
      v14 = pthread_attr_init(&v22);
      if (!v14)
        v14 = pthread_attr_set_qos_class_np(&v22, v13, 0);
      if (v14)
        v15 = 0;
      else
        v15 = &v22;
      v16 = (pthread_t *)(a1 + 28);
      v17 = (void *(__cdecl *)(void *))_asyncReadThread;
      return pthread_create(v16, v15, v17, a1) != 0;
    case 6:
      result = pthread_once(&gBufferPoolOnce, (void (*)(void))_initBufferPool);
      if ((_DWORD)result)
        return result;
      v18 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v18)
        return 0xFFFFFFFFLL;
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v18);
      *((_QWORD *)a1 + 12) = BOMBufferFIFOCreate();
      *((_QWORD *)a1 + 13) = 0;
      *((_QWORD *)a1 + 29) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 42), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 30), 0))
        return 1;
      memset(&v22, 0, sizeof(v22));
      v20 = qos_class_self();
      v21 = pthread_attr_init(&v22);
      if (!v21)
        v21 = pthread_attr_set_qos_class_np(&v22, v20, 0);
      if (v21)
        v15 = 0;
      else
        v15 = &v22;
      v16 = (pthread_t *)(a1 + 28);
      v17 = (void *(__cdecl *)(void *))_asyncWriteThread;
      return pthread_create(v16, v15, v17, a1) != 0;
    default:
      return 0xFFFFFFFFLL;
  }
  return result;
}

void _freeBOMFile(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;

  if (*(_DWORD *)a1 == 4)
  {
    v2 = (void *)a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0;
    }
  }
  v3 = (void *)a1[5];
  if (v3)
  {
    free(v3);
    a1[5] = 0;
  }
  v4 = (void *)a1[6];
  if (v4)
  {
    free(v4);
    a1[6] = 0;
  }
  v5 = a1[12];
  if (v5)
  {
    BOMBufferFIFODestroy(v5);
    a1[12] = 0;
  }
  v6 = (void *)a1[11];
  if (v6)
    free(v6);
  free(a1);
}

uint64_t BOMFileNewFromCFWriteStream(_QWORD *a1, const void *a2, char a3)
{
  CFTypeID TypeID;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t result;

  if (!a2)
    return 0xFFFFFFFFLL;
  TypeID = CFWriteStreamGetTypeID();
  if (TypeID != CFGetTypeID(a2))
    return 0xFFFFFFFFLL;
  v7 = BOM_malloczero(0x118uLL);
  if (!v7)
    return 0xFFFFFFFFLL;
  v8 = v7;
  *(_DWORD *)v7 = 2;
  v7[1] = a2;
  result = _BOMFileInit(v7, a3 & 0xF, 0);
  if ((_DWORD)result)
  {
    _freeBOMFile(v8);
    return 0xFFFFFFFFLL;
  }
  *a1 = v8;
  return result;
}

uint64_t BOMFileNewFromCFReadStream(_QWORD *a1, const void *a2, char a3)
{
  CFTypeID TypeID;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t result;

  if (!a2)
    return 0xFFFFFFFFLL;
  TypeID = CFReadStreamGetTypeID();
  if (TypeID != CFGetTypeID(a2))
    return 0xFFFFFFFFLL;
  v7 = BOM_malloczero(0x118uLL);
  if (!v7)
    return 0xFFFFFFFFLL;
  v8 = v7;
  *(_DWORD *)v7 = 3;
  v7[1] = a2;
  result = _BOMFileInit(v7, a3 & 0xF, 0);
  if ((_DWORD)result)
  {
    _freeBOMFile(v8);
    return 0xFFFFFFFFLL;
  }
  *a1 = v8;
  return result;
}

uint64_t BOMFileNewMirror(_QWORD *a1)
{
  return BOMFileNewMirrorWithSys(a1, 0);
}

uint64_t BOMFileNewMirrorWithSys(_QWORD *a1, void *a2)
{
  _DWORD *v4;
  _QWORD *v5;
  uint64_t result;

  v4 = BOM_malloczero(0x118uLL);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = v4;
  *v4 = 4;
  result = _BOMFileInit(v4, 0, a2);
  if ((_DWORD)result)
  {
    _freeBOMFile(v5);
    return 0xFFFFFFFFLL;
  }
  *a1 = v5;
  return result;
}

uint64_t BOMFileOpen(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  return BOMFileOpenWithSys(a1, a2, a3, a4, a5, 0);
}

uint64_t BOMFileOpenWithSys(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, void (**a6)(_QWORD, uint64_t, uint64_t, uint64_t))
{
  void (**v6)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t result;
  uint64_t v13;
  int v14;
  __int16 v15;
  _OWORD v16[2];
  _OWORD v17[6];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;
  _OWORD v22[4];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v6 = a6;
  v51 = *MEMORY[0x24BDAC8D0];
  if (!a6)
    v6 = (void (**)(_QWORD, uint64_t, uint64_t, uint64_t))BomSys_default();
  v21 = 25202;
  result = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t))v6[2])(v6[1], a2, a3, a4);
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  memset(v17, 0, sizeof(v17));
  if ((_DWORD)result != -1)
  {
    v13 = result;
    result = ((uint64_t (*)(void (*)(_QWORD, uint64_t, uint64_t, uint64_t), uint64_t, _OWORD *))v6[11])(v6[1], result, v17);
    if ((_DWORD)result != -1)
    {
      v14 = WORD2(v17[0]) & 0xF000;
      if (v14 == 0x8000)
      {
        v49 = 0u;
        v50 = 0u;
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v31 = 0u;
        v32 = 0u;
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v25 = 0u;
        v26 = 0u;
        v23 = 0u;
        v24 = 0u;
        memset(v22, 0, sizeof(v22));
        if (!((unsigned int (*)(void (*)(_QWORD, uint64_t, uint64_t, uint64_t), uint64_t, _OWORD *))v6[14])(v6[1], v13, v22)&& !(DWORD2(v23) ^ 0x73666361 | BYTE12(v23)))
        {
          v16[0] = 0u;
          DWORD1(v16[0]) = 3;
          v16[1] = (unint64_t)v18;
          v6[5](v6[1], v13, 42, (uint64_t)v16);
        }
      }
      else if (v14 == 0x4000)
      {
        *__error() = 21;
        return 0xFFFFFFFFLL;
      }
      if ((a3 & 1) != 0)
      {
        BYTE2(v21) = 0;
        v15 = 25207;
      }
      else
      {
        if ((a3 & 2) == 0)
        {
LABEL_16:
          result = BOMFileNewFromFDWithSys(a1, v13, a5, (unsigned __int8 *)&v21, v6);
          if (!(_DWORD)result)
            return result;
          ((void (*)(void (*)(_QWORD, uint64_t, uint64_t, uint64_t), uint64_t))v6[4])(v6[1], v13);
          return 0xFFFFFFFFLL;
        }
        BYTE2(v21) = 0;
        v15 = 25185;
      }
      LOWORD(v21) = v15;
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t BOMFileOpenSTDIN(_QWORD *a1, char a2)
{
  return BOMFileNewFromFDWithSys(a1, 0, a2 & 0xF, "rb", 0);
}

uint64_t BOMFileOpenSTDOUT(_QWORD *a1, char a2)
{
  return BOMFileNewFromFDWithSys(a1, 1, a2 & 0xF, "wb", 0);
}

uint64_t BOMFileClose(uint64_t a1)
{
  int v2;
  int v3;
  bz_stream *v4;
  BOOL v5;
  int v7;
  void *v8;
  uint64_t v9;
  size_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v20;
  CFIndex v21;
  UInt8 *v22;
  uint64_t v23;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) <= 1)
  {
    v3 = *(_DWORD *)(a1 + 32);
    if (v3 == 1)
    {
      if (_BOMFileFinishGzipCompression((_QWORD *)a1, 1))
        return 0xFFFFFFFFLL;
    }
    else if (v3 == 2)
    {
      v4 = *(bz_stream **)(a1 + 40);
      if (v4->avail_out)
        goto LABEL_73;
      v5 = 0;
      while (1)
      {
        v21 = 0x20000 - v4->avail_out;
        v22 = *(UInt8 **)(a1 + 48);
        while (v21)
        {
          v23 = _BOMFileWriteRaw(a1, v22, v21);
          v21 -= v23;
          v22 += v23;
          if (v23 == -1)
            return 0xFFFFFFFFLL;
        }
        v4->next_out = *(char **)(a1 + 48);
        v4->avail_out = 0x20000;
        if (v5)
          break;
LABEL_73:
        v20 = BZ2_bzCompress(v4, 2);
        v5 = 1;
        if (v20 != 4)
        {
          v5 = 0;
          if (v20 != 3)
          {
            if (v20)
              return 0xFFFFFFFFLL;
            v5 = v4->avail_out != 0;
          }
        }
      }
      BZ2_bzCompressEnd(v4);
    }
    v2 = *(_DWORD *)a1;
  }
  if (v2 == 3 || v2 == 0)
  {
    v7 = *(_DWORD *)(a1 + 32);
    if (v7 == 2)
    {
      v9 = *(_QWORD *)(a1 + 40);
      v8 = *(void **)(a1 + 48);
      v10 = *(unsigned int *)(v9 + 8);
      *(_QWORD *)(a1 + 72) = v10;
      *(_DWORD *)(a1 + 80) = 0;
      memmove(v8, *(const void **)v9, v10);
      if (BZ2_bzDecompressEnd(*(bz_stream **)(a1 + 40)))
        return 0xFFFFFFFFLL;
    }
    else
    {
      if (v7 != 1)
        goto LABEL_20;
      if (_BOMFileFinishGzipDecompression(a1))
        return 0xFFFFFFFFLL;
    }
    v2 = *(_DWORD *)a1;
  }
LABEL_20:
  if ((v2 - 5) > 1)
    goto LABEL_60;
  if (v2 != 5)
  {
    if (v2 != 6)
      goto LABEL_60;
    v11 = *(_QWORD **)(a1 + 104);
    if (v11)
    {
      *(_QWORD *)(a1 + 104) = 0;
    }
    else
    {
      v11 = BOMBufferPoolRequestBuffer(gBufferPool);
      v11[1] = 0;
      v11[2] = 0;
    }
    *((_DWORD *)v11 + 12) |= 1u;
    BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 96), (uint64_t)v11);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
      return 0xFFFFFFFFLL;
    v16 = *(_DWORD *)(a1 + 232);
    if (!v16)
    {
      v16 = 1;
      *(_DWORD *)(a1 + 232) = 1;
    }
    if (gBOMAsyncDebug == 1)
    {
      fwrite("waiting for async write thread to finish...", 0x2BuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      v16 = *(_DWORD *)(a1 + 232);
    }
    if (v16 != 2)
    {
      while (!pthread_cond_wait((pthread_cond_t *)(a1 + 120), (pthread_mutex_t *)(a1 + 168)))
      {
        if (*(_DWORD *)(a1 + 232) == 2)
          goto LABEL_52;
      }
      return 0xFFFFFFFFLL;
    }
LABEL_52:
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)) || pthread_join(*(pthread_t *)(a1 + 112), 0))
      return 0xFFFFFFFFLL;
    if (gBOMAsyncDebug == 1)
      fwrite("async write thread terminated. Draining FIFO...", 0x2FuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
    {
      v17 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
      BOMBufferPoolReturnBuffer(gBufferPool, v17);
    }
    if ((gBOMAsyncDebug & 1) == 0)
      goto LABEL_60;
    goto LABEL_59;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
    return 0xFFFFFFFFLL;
  v12 = *(_QWORD *)(a1 + 104);
  if (v12)
  {
    BOMBufferPoolReturnBuffer(gBufferPool, v12);
    *(_QWORD *)(a1 + 104) = 0;
  }
  while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
  {
    v13 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    BOMBufferPoolReturnBuffer(gBufferPool, v13);
  }
  v14 = *(_DWORD *)(a1 + 232);
  if (!v14)
  {
    v14 = 1;
    *(_DWORD *)(a1 + 232) = 1;
  }
  if (gBOMAsyncDebug == 1)
  {
    fwrite("waiting for async read thread to finish...", 0x2AuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    v14 = *(_DWORD *)(a1 + 232);
  }
  if (v14 != 2)
  {
    while (!pthread_cond_wait((pthread_cond_t *)(a1 + 120), (pthread_mutex_t *)(a1 + 168)))
    {
      if (*(_DWORD *)(a1 + 232) == 2)
        goto LABEL_37;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_37:
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)) || pthread_join(*(pthread_t *)(a1 + 112), 0))
    return 0xFFFFFFFFLL;
  while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
  {
    v15 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    BOMBufferPoolReturnBuffer(gBufferPool, v15);
  }
  if (gBOMAsyncDebug == 1)
LABEL_59:
    fwrite("done\n", 5uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
LABEL_60:
  if (*(_DWORD *)(a1 + 32) == 3)
  {
    if (!CloseStreamCompressor())
    {
      *(_QWORD *)(a1 + 40) = 0;
      goto LABEL_63;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_63:
  v18 = 0;
  switch(*(_DWORD *)a1)
  {
    case 0:
    case 1:
      v18 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 272) + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), *(unsigned int *)(a1 + 8));
      *(_DWORD *)(a1 + 8) = -1;
      break;
    case 2:
      CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 8));
      goto LABEL_68;
    case 3:
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 8));
LABEL_68:
      v18 = 0;
      goto LABEL_69;
    case 5:
    case 6:
      v18 = BOMFileClose(*(_QWORD *)(a1 + 8));
LABEL_69:
      *(_QWORD *)(a1 + 8) = 0;
      break;
    default:
      break;
  }
  _freeBOMFile((_QWORD *)a1);
  return v18;
}

unint64_t BOMFileRead(int *a1, char *a2, unint64_t a3)
{
  int v3;

  if (!a1)
    return -1;
  v3 = *a1;
  if (!*a1)
    return _BOMFileDirectRead((uint64_t)a1, a2, a3);
  if (v3 != 5)
  {
    if (v3 == 3)
      return _BOMFileDirectRead((uint64_t)a1, a2, a3);
    return -1;
  }
  return _BOMFileAsyncRead((uint64_t)a1, a2, a3);
}

uint64_t _BOMFileDirectRead(uint64_t a1, char *__dst, unint64_t a3)
{
  unint64_t v4;
  int v6;
  z_stream *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t avail_out;
  bz_stream *v15;
  uint64_t Raw;
  int v17;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  UInt8 *v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  FILE *v26;
  const char *v27;
  size_t v28;
  unint64_t v29;

  if (a3)
  {
    if (!__dst)
      return -1;
    v4 = a3;
    v6 = *(_DWORD *)(a1 + 32);
    if (v6)
    {
      if (v6 == 2)
      {
        v15 = *(bz_stream **)(a1 + 40);
        v15->next_out = __dst;
        v15->avail_out = a3;
        do
        {
          if (!v15->avail_in && !*(_BYTE *)(a1 + 64))
          {
            Raw = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 48), 0x20000);
            v8 = Raw;
            if (Raw)
            {
              if (Raw == -1)
                return v8;
            }
            else
            {
              *(_BYTE *)(a1 + 64) = 1;
            }
            v15->avail_in = Raw;
            v15->next_in = *(char **)(a1 + 48);
          }
          v17 = BZ2_bzDecompress(v15);
          if (v17)
          {
            if (v17 != 4)
              return -1;
            *(_BYTE *)(a1 + 64) = 1;
          }
          avail_out = v15->avail_out;
        }
        while ((_DWORD)avail_out && !*(_BYTE *)(a1 + 65) && !*(_BYTE *)(a1 + 64));
        goto LABEL_46;
      }
      if (v6 == 1)
      {
        v7 = *(z_stream **)(a1 + 40);
        v7->next_out = (Bytef *)__dst;
        v7->avail_out = a3;
        do
        {
          LODWORD(v8) = v7->avail_in;
          if (!(_DWORD)v8)
          {
            if (*(_BYTE *)(a1 + 64))
            {
              LODWORD(v8) = 0;
            }
            else
            {
              v9 = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 48), 0x20000);
              v8 = v9;
              if (v9)
              {
                if (v9 == -1)
                  return v8;
              }
              else
              {
                *(_BYTE *)(a1 + 64) = 1;
              }
              *(_DWORD *)(a1 + 264) = v9;
              v7->avail_in = v9;
              v7->next_in = *(Bytef **)(a1 + 48);
            }
          }
          if (*(_BYTE *)(a1 + 256))
          {
            v10 = *(_DWORD *)(a1 + 264);
            if (v10)
            {
              v11 = *(_DWORD *)(a1 + 260);
              if (v8 >= v11)
                v12 = *(_DWORD *)(a1 + 260);
              else
                v12 = v8;
              *(_DWORD *)(a1 + 260) = v11 - v12;
              *(_DWORD *)(a1 + 264) = v10 - v12;
              decrypt_buffer((uint64_t)v7->next_in, v12, (int *)(a1 + 244));
            }
          }
          v13 = inflate(v7, 0);
          if (v13)
          {
            if (v13 != 1)
              return -1;
            *(_BYTE *)(a1 + 64) = 1;
          }
          avail_out = v7->avail_out;
        }
        while ((_DWORD)avail_out && (avail_out == v4 || !*(_BYTE *)(a1 + 65)) && !*(_BYTE *)(a1 + 64));
LABEL_46:
        v8 = v4 - avail_out;
        goto LABEL_47;
      }
      return -1;
    }
    if (*(_BYTE *)(a1 + 67) == 1)
    {
      v8 = 0;
      *(_WORD *)(a1 + 66) = 0;
LABEL_47:
      *(_QWORD *)(a1 + 24) += v8;
      return v8;
    }
    v8 = *(_QWORD *)(a1 + 72);
    if (v8)
    {
      v19 = 88;
      if (!*(_DWORD *)(a1 + 80))
        v19 = 48;
      v20 = *(char **)(a1 + v19);
      if (*(_BYTE *)(a1 + 66) == 1)
      {
        v29 = 0;
        if (search_for_data_descriptor((uint64_t)v20, v8, &v29))
        {
          *(_BYTE *)(a1 + 67) = 1;
          v4 = v29;
          if (!v29)
          {
            v8 = 0;
            goto LABEL_47;
          }
        }
      }
      if (v4 < v8)
        v8 = v4;
      if (v8 >= 1)
      {
        memcpy(__dst, v20, v8);
        v21 = *(_QWORD *)(a1 + 72);
        v4 -= v8;
        *(_DWORD *)(a1 + 264) -= v8;
        v22 = (UInt8 *)&__dst[v8];
        *(_QWORD *)(a1 + 72) = v21 - v8;
        if (v21 != v8)
          memmove(v20, &v20[v8], v21 - v8);
        if (!v4)
          goto LABEL_70;
        goto LABEL_65;
      }
      v8 = 0;
    }
    v22 = (UInt8 *)__dst;
LABEL_65:
    v23 = _BOMFileReadRaw(a1, v22, v4);
    if (v23 == -1)
    {
      v8 = -1;
      goto LABEL_47;
    }
    if (v23)
      v8 += v23;
    else
      *(_BYTE *)(a1 + 64) = 1;
LABEL_70:
    if (*(_BYTE *)(a1 + 66) != 1
      || (v29 = 0, !search_for_data_descriptor((uint64_t)__dst, v8, &v29))
      || (*(_BYTE *)(a1 + 67) = 1, v24 = v29, v25 = v8 - v29, v8 == v29))
    {
LABEL_73:
      if (*(_BYTE *)(a1 + 256) == 1)
        decrypt_buffer((uint64_t)__dst, v8, (int *)(a1 + 244));
      goto LABEL_47;
    }
    if (*(_QWORD *)(a1 + 72))
    {
      v26 = (FILE *)*MEMORY[0x24BDAC8D8];
      v27 = "The extra buffer is not empty";
      v28 = 29;
    }
    else
    {
      if (v25 <= 0x20000)
      {
        *(_QWORD *)(a1 + 72) = v25;
        *(_DWORD *)(a1 + 80) = 1;
        memcpy(*(void **)(a1 + 88), &v22[v24], v25);
        v8 = v24;
        goto LABEL_73;
      }
      v26 = (FILE *)*MEMORY[0x24BDAC8D8];
      v27 = "The extra buffer is not large enough";
      v28 = 36;
    }
    fwrite(v27, v28, 1uLL, v26);
    v8 = -1;
    goto LABEL_47;
  }
  return 0;
}

unint64_t _BOMFileAsyncRead(uint64_t a1, char *__dst, size_t a3)
{
  size_t v4;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  size_t v11;
  int v12;
  int v13;

  if (!a3)
  {
    v6 = 0;
    goto LABEL_17;
  }
  v4 = a3;
  v6 = 0;
  while (1)
  {
    v7 = *(_QWORD **)(a1 + 104);
    if (!v7)
    {
      v7 = (_QWORD *)BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
      *(_QWORD *)(a1 + 104) = v7;
    }
    v8 = v7[1];
    if (v4 >= v7[2] - v8)
      v9 = v7[2] - v8;
    else
      v9 = v4;
    memcpy(__dst, (const void *)(v7[3] + v8), v9);
    v10 = v7[2];
    v11 = v7[1] + v9;
    v7[1] = v11;
    v6 += v9;
    if (v10 != v11)
      goto LABEL_14;
    if (!v11)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
        goto LABEL_17;
      v13 = *(_DWORD *)(a1 + 232);
      v12 = *(_DWORD *)(a1 + 236);
      if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)))
        goto LABEL_17;
      if ((v13 - 1) <= 1)
        break;
    }
    BOMBufferPoolReturnBuffer(gBufferPool, (uint64_t)v7);
    *(_QWORD *)(a1 + 104) = 0;
LABEL_14:
    __dst += v9;
    v4 -= v9;
    if (!v4)
      goto LABEL_17;
  }
  if (v12)
  {
    *__error() = v12;
    return -1;
  }
LABEL_17:
  *(int64x2_t *)(a1 + 16) = vaddq_s64(*(int64x2_t *)(a1 + 16), vdupq_n_s64(v6));
  return v6;
}

CFIndex BOMFileWrite(uint64_t a1, UInt8 *a2, CFIndex a3)
{
  size_t v3;
  UInt8 *v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  size_t v13;
  int64x2_t v14;
  int v15;
  int v16;

  if (!a1)
    return -1;
  v3 = a3;
  v4 = a2;
  v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) < 2)
    return _BOMFileDirectWrite(a1, a2, a3);
  if (v6 != 6)
  {
    if (v6 != 4)
      return -1;
    if (!**(_QWORD **)(a1 + 8))
      return v3;
    v7 = 8;
    while (BOMFileWrite() == v3)
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + v7);
      v7 += 8;
      if (!v8)
        return v3;
    }
    return -1;
  }
  v10 = 0;
  if (!a3)
    goto LABEL_24;
  while (1)
  {
    v11 = *(_QWORD **)(a1 + 104);
    if (v11)
    {
      v12 = v11[1];
    }
    else
    {
      v11 = BOMBufferPoolRequestBuffer(gBufferPool);
      v12 = 0;
      v11[1] = 0;
      v11[2] = 0;
      *(_QWORD *)(a1 + 104) = v11;
    }
    if (v3 >= *v11 - v12)
      v13 = *v11 - v12;
    else
      v13 = v3;
    memcpy((void *)(v11[3] + v12), v4, v13);
    v14 = vaddq_s64(*(int64x2_t *)(v11 + 1), vdupq_n_s64(v13));
    *(int64x2_t *)(v11 + 1) = v14;
    v10 += v13;
    if (*v11 != v14.i64[0])
      goto LABEL_23;
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
      goto LABEL_24;
    v16 = *(_DWORD *)(a1 + 232);
    v15 = *(_DWORD *)(a1 + 236);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)))
      goto LABEL_24;
    if ((v16 - 1) <= 1)
      break;
    BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 96), (uint64_t)v11);
    *(_QWORD *)(a1 + 104) = 0;
LABEL_23:
    v4 += v13;
    v3 -= v13;
    if (!v3)
      goto LABEL_24;
  }
  if (v15)
  {
    *__error() = v15;
    return -1;
  }
LABEL_24:
  *(int64x2_t *)(a1 + 16) = vaddq_s64(*(int64x2_t *)(a1 + 16), vdupq_n_s64(v10));
  return v10;
}

CFIndex _BOMFileDirectWrite(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  CFIndex v3;
  CFIndex v6;
  uint64_t v7;
  z_stream *v8;
  uInt avail_out;
  bz_stream *v10;
  unsigned int v11;
  uint64_t v12;
  CFIndex v13;
  UInt8 *v14;
  uint64_t v15;
  CFIndex v17;
  UInt8 *v18;
  uint64_t v19;

  v3 = bufferLength;
  if (bufferLength)
  {
    if (buffer)
    {
      switch(*(_DWORD *)(a1 + 32))
      {
        case 0:
          v6 = 0;
          while (v3)
          {
            v7 = _BOMFileWriteRaw(a1, buffer, v3);
            v6 += v7;
            v3 -= v7;
            if (v7 < 0)
              return -1;
          }
          goto LABEL_18;
        case 1:
          v8 = *(z_stream **)(a1 + 40);
          v8->next_in = buffer;
          v8->avail_in = bufferLength;
          if (!(_DWORD)bufferLength)
            goto LABEL_27;
          avail_out = v8->avail_out;
          if (!avail_out)
            goto LABEL_22;
          while (!deflate(v8, 0))
          {
            avail_out = v8->avail_out;
LABEL_22:
            v13 = 0x20000 - avail_out;
            v14 = *(UInt8 **)(a1 + 48);
            while (v13)
            {
              v15 = _BOMFileWriteRaw(a1, v14, v13);
              v14 += v15;
              v13 -= v15;
              if (v15 < 0)
                return -1;
            }
            v8->avail_out = 0x20000;
            v8->next_out = *(Bytef **)(a1 + 48);
            if (!v8->avail_in)
            {
LABEL_27:
              *(_QWORD *)(a1 + 56) = crc32(*(_QWORD *)(a1 + 56), buffer, v3);
              goto LABEL_28;
            }
          }
          return -1;
        case 2:
          v10 = *(bz_stream **)(a1 + 40);
          v10->next_in = (char *)buffer;
          v10->avail_in = bufferLength;
          if (!(_DWORD)bufferLength)
            goto LABEL_28;
          v11 = v10->avail_out;
          if (!v11)
            goto LABEL_32;
          while (BZ2_bzCompress(v10, 0) <= 1)
          {
            v11 = v10->avail_out;
LABEL_32:
            v17 = 0x20000 - v11;
            v18 = *(UInt8 **)(a1 + 48);
            while (v17)
            {
              v19 = _BOMFileWriteRaw(a1, v18, v17);
              v18 += v19;
              v17 -= v19;
              if (v19 < 0)
                return -1;
            }
            v10->avail_out = 0x20000;
            v10->next_out = *(char **)(a1 + 48);
            if (!v10->avail_in)
              goto LABEL_28;
          }
          return -1;
        case 3:
          v6 = 0;
          break;
        default:
          return -1;
      }
      while (v3)
      {
        v12 = WriteToStreamCompressor();
        v6 += v12;
        v3 -= v12;
        if (v12 < 0)
          return -1;
      }
LABEL_18:
      v3 = v6;
LABEL_28:
      *(_QWORD *)(a1 + 24) += v3;
    }
    else
    {
      return -1;
    }
  }
  return v3;
}

uint64_t BOMFileSeek()
{
  int64x2_t *v0;
  int64_t v1;
  uint64_t v2;
  int64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  CFIndex v7;
  CFIndex v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  int64_t v13;
  uint64_t v14;
  unint64_t v15;
  int64x2_t v16;
  char __dst[131072];
  uint64_t v18;

  v0 = (int64x2_t *)MEMORY[0x24BDAC7A8]();
  v18 = *MEMORY[0x24BDAC8D0];
  v3 = v1;
  v4 = (uint64_t)v0;
  switch(v0->i32[0])
  {
    case 0:
      if (!v0[2].i32[0])
        goto LABEL_44;
      goto LABEL_3;
    case 1:
      if (v0[2].i32[0])
        goto LABEL_14;
LABEL_44:
      result = (*(uint64_t (**)(_QWORD, _QWORD, int64_t, uint64_t))(v0[17].i64[0] + 64))(*(_QWORD *)(v0[17].i64[0] + 8), v0->u32[2], v1, v2);
      *(_QWORD *)(v4 + 16) = result;
      *(_QWORD *)(v4 + 24) = result;
      return result;
    case 2:
    case 6:
LABEL_14:
      if ((_DWORD)v2 == 1)
        goto LABEL_17;
      if ((_DWORD)v2)
        return -1;
      v3 = v1 - v0[1].i64[0];
LABEL_17:
      if (v3 < 1)
        return -1;
      bzero(__dst, 0x20000uLL);
      while (v3)
      {
        if (v3 >= 0x20000)
          v7 = 0x20000;
        else
          v7 = v3;
        v8 = _BOMFileDirectWrite(v4, (UInt8 *)__dst, v7);
        v3 -= v8;
        if (v8 < 0)
          return -1;
      }
      return *(_QWORD *)(v4 + 16);
    case 3:
LABEL_3:
      if ((_DWORD)v2 == 1)
        goto LABEL_6;
      if ((_DWORD)v2)
        return -1;
      v3 = v1 - v0[1].i64[0];
LABEL_6:
      if (v3 < 1)
        return -1;
      do
      {
        if (v3 < 1)
          return *(_QWORD *)(v4 + 16);
        if (v3 >= 0x20000)
          v5 = 0x20000;
        else
          v5 = v3;
        v6 = _BOMFileDirectRead(v4, __dst, v5);
        v3 -= v6;
      }
      while (v6 > 0);
      return -1;
    case 4:
      result = -1;
      if (v1 < 0 || (_DWORD)v2 != 1)
        return result;
      if (!**(_QWORD **)(v4 + 8))
        goto LABEL_31;
      v10 = 8;
      break;
    case 5:
      if ((_DWORD)v2 == 1)
        goto LABEL_35;
      if ((_DWORD)v2)
      {
        v3 = -1;
      }
      else
      {
        v3 = v1 - v0[1].i64[0];
LABEL_35:
        if ((v3 & 0x8000000000000000) == 0)
        {
          if (!v3)
            return -1;
          do
          {
            if (v3 < 1)
              return *(_QWORD *)(v4 + 16);
            if (v3 >= 0x20000)
              v12 = 0x20000;
            else
              v12 = v3;
            v13 = _BOMFileAsyncRead(v4, __dst, v12);
            v3 -= v13;
          }
          while (v13 > 0);
          return -1;
        }
      }
      v14 = v0[6].i64[1];
      if (v14)
      {
        v15 = *(_QWORD *)(v14 + 24);
        if (v15)
        {
          if (*(_QWORD *)(v14 + 8) + v3 != 0 && v15 + *(_QWORD *)(v14 + 8) + v3 >= v15)
          {
            *(_QWORD *)(v14 + 8) += v3;
            v16 = vaddq_s64(v0[1], vdupq_n_s64(v3));
            v0[1] = v16;
            return v16.i64[0];
          }
        }
      }
      return -1;
    default:
      return -1;
  }
  while (1)
  {
    result = BOMFileSeek();
    if (result == -1)
      break;
    v11 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + v10);
    v10 += 8;
    if (!v11)
    {
LABEL_31:
      result = *(_QWORD *)(v4 + 16) + v3;
      *(_QWORD *)(v4 + 16) = result;
      return result;
    }
  }
  return result;
}

uint64_t BOMFileOffset(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t BOMFileUncompressedOffset(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t BOMFileSetPartialRead(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 65) = a2;
  return result;
}

uint64_t BOMFileSetDataDescriptor(uint64_t result, char a2)
{
  if (result)
  {
    *(_BYTE *)(result + 66) = a2;
    *(_BYTE *)(result + 67) = 0;
  }
  return result;
}

uint64_t BOMFileSetCompression(uint64_t result, int a2, int a3, int a4)
{
  if (result)
  {
    if (*(_DWORD *)(result + 32) == (a2 == 0))
    {
      *(_DWORD *)(result + 240) = a4;
      *(_DWORD *)(result + 32) = a2 != 0;
      if (a2)
      {
        if (_BOMFileSetupGzip(result, a3 == 0, 0))
          return 0xFFFFFFFFLL;
        else
          return 0;
      }
      else if (a3)
      {
        return _BOMFileFinishGzipDecompression(result);
      }
      else
      {
        return _BOMFileFinishGzipCompression((_QWORD *)result, 0);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _BOMFileSetupGzip(uint64_t a1, int a2, int a3)
{
  z_stream *v6;
  z_streamp *v7;
  void *v8;
  _QWORD *v9;
  size_t v10;
  uint64_t v11;
  uint64_t result;
  int v13;
  uLong v14;

  v7 = (z_streamp *)(a1 + 40);
  v6 = *(z_stream **)(a1 + 40);
  if (!v6)
  {
    v6 = (z_stream *)BOM_malloc(0x70uLL);
    *v7 = v6;
    if (!v6)
      return 0xFFFFFFFFLL;
  }
  v8 = *(void **)(a1 + 48);
  if (!v8)
  {
    v8 = BOM_malloc(0x20000uLL);
    *(_QWORD *)(a1 + 48) = v8;
    v6 = *(z_stream **)(a1 + 40);
    if (!v8)
    {
      free(*(void **)(a1 + 40));
      goto LABEL_13;
    }
  }
  v6->zalloc = 0;
  (*v7)->zfree = 0;
  (*v7)->opaque = 0;
  v9 = *v7;
  if (a2)
  {
    *v9 = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) = v8;
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 8) = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 32) = 0x20000;
    if (deflateInit2_(*(z_streamp *)(a1 + 40), *(_DWORD *)(a1 + 240), 8, -15, 8, 0, "1.2.12", 112))
    {
LABEL_7:
      free(*(void **)(a1 + 40));
      free(*(void **)(a1 + 48));
      v7[1] = 0;
LABEL_13:
      *v7 = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *v9 = v8;
    v10 = *(_QWORD *)(a1 + 72);
    if (v10)
    {
      v11 = 88;
      if (!*(_DWORD *)(a1 + 80))
        v11 = 48;
      memcpy(**(void ***)(a1 + 40), *(const void **)(a1 + v11), v10);
      *(_DWORD *)(*(_QWORD *)(a1 + 40) + 8) = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(a1 + 72) = 0;
    }
    else
    {
      (*v7)->avail_in = 0;
    }
    (*v7)->next_out = 0;
    (*v7)->avail_out = 0;
    if (a3)
      v13 = 47;
    else
      v13 = -15;
    if (inflateInit2_(*v7, v13, "1.2.12", 112))
      goto LABEL_7;
  }
  v14 = crc32(0, 0, 0);
  result = 0;
  *(_QWORD *)(a1 + 56) = v14;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

uint64_t _BOMFileFinishGzipDecompression(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  size_t v4;

  v3 = *(_QWORD *)(a1 + 40);
  v2 = *(void **)(a1 + 48);
  v4 = *(unsigned int *)(v3 + 8);
  *(_QWORD *)(a1 + 72) = v4;
  *(_DWORD *)(a1 + 80) = 0;
  memmove(v2, *(const void **)v3, v4);
  return inflateEnd(*(z_streamp *)(a1 + 40));
}

uint64_t _BOMFileFinishGzipCompression(_QWORD *a1, int a2)
{
  z_stream *v4;
  uInt avail_out;
  BOOL v6;
  int v7;
  CFIndex v8;
  UInt8 *v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uLong total_in;
  uint64_t v17;
  UInt8 v18[4];
  UInt8 buffer[4];

  v4 = (z_stream *)a1[5];
  avail_out = v4->avail_out;
  if (avail_out)
    goto LABEL_3;
  v6 = 0;
  while (1)
  {
    v8 = 0x20000 - avail_out;
    v9 = (UInt8 *)a1[6];
    while (v8)
    {
      v10 = _BOMFileWriteRaw((uint64_t)a1, v9, v8);
      v8 -= v10;
      v9 += v10;
      if (v10 == -1)
        return 0xFFFFFFFFLL;
    }
    v4->next_out = (Bytef *)a1[6];
    v4->avail_out = 0x20000;
    if (v6)
      break;
LABEL_3:
    v7 = deflate(v4, 4);
    if (v7)
    {
      if (v7 != 1)
        return 0xFFFFFFFFLL;
      avail_out = v4->avail_out;
      v6 = 1;
    }
    else
    {
      avail_out = v4->avail_out;
      v6 = avail_out != 0;
    }
  }
  if (a2)
  {
    v12 = 0;
    v13 = a1[7];
    a1[7] = v13;
    *(_DWORD *)buffer = v13;
    while (v12 != 4)
    {
      v14 = _BOMFileWriteRaw((uint64_t)a1, buffer, 4 - v12);
      v12 += v14;
      if (v14 < 0)
        return 0xFFFFFFFFLL;
    }
    v15 = 0;
    total_in = v4->total_in;
    v4->total_in = total_in;
    *(_DWORD *)v18 = total_in;
    while (v15 != 4)
    {
      v17 = _BOMFileWriteRaw((uint64_t)a1, v18, 4 - v15);
      v15 += v17;
      if (v17 < 0)
        return 0xFFFFFFFFLL;
    }
  }
  deflateEnd(v4);
  return 0;
}

BOOL BOMFileEndOfCompressionStream(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 64) != 0;
  return result;
}

uint64_t BOMFileSetAFSCCompression(uint64_t a1)
{
  uint64_t result;
  uint64_t StreamCompressor;
  uint64_t v4;

  if (*(_DWORD *)a1 != 1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 32))
    return 0xFFFFFFFFLL;
  StreamCompressor = CreateStreamCompressor();
  if (!StreamCompressor)
    return 0xFFFFFFFFLL;
  v4 = StreamCompressor;
  result = 0;
  *(_DWORD *)(a1 + 32) = 3;
  *(_QWORD *)(a1 + 40) = v4;
  return result;
}

uint64_t BOMFileSetKeys(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;

  v2 = a1 + 244;
  *(_BYTE *)(a1 + 256) = a2 != 0;
  if (a2)
    init_keys(a1 + 244, a2);
  return v2;
}

uint64_t BOMFileSetEncryptedRemainder(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 260) = a2;
  return result;
}

uint64_t BOMFileClearEncrypted(uint64_t result)
{
  if (result)
    *(_BYTE *)(result + 256) = 0;
  return result;
}

uint64_t BOMFileGetFileDescriptor(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t _BOMFileReadRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6;
  CFIndex v7;
  uint64_t v8;

  v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 3)
    {
      v7 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1)
    {
      v7 = -1;
    }
    else
    {
      v7 = (*(uint64_t (**)(_QWORD, _QWORD, UInt8 *, CFIndex))(*(_QWORD *)(a1 + 272) + 48))(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1)
      break;
    if (*(_BYTE *)(a1 + 65))
      break;
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(_QWORD *)(a1 + 16) += v6;
  if (v7 < 0)
    return -1;
  else
    return v6;
}

uint64_t _BOMFileSetupBzip2(uint64_t a1, int a2)
{
  bz_stream *v4;
  bz_stream **v5;
  char *v6;
  bz_stream *v7;
  size_t v8;
  uint64_t v9;
  uint64_t result;
  uLong v11;

  v5 = (bz_stream **)(a1 + 40);
  v4 = *(bz_stream **)(a1 + 40);
  if (!v4)
  {
    v4 = (bz_stream *)BOM_malloc(0x50uLL);
    *v5 = v4;
    if (!v4)
      return 0xFFFFFFFFLL;
  }
  v6 = *(char **)(a1 + 48);
  if (!v6)
  {
    v6 = (char *)BOM_malloc(0x20000uLL);
    *(_QWORD *)(a1 + 48) = v6;
    v4 = *(bz_stream **)(a1 + 40);
    if (!v6)
    {
      free(*(void **)(a1 + 40));
      goto LABEL_13;
    }
  }
  v4->bzalloc = 0;
  (*v5)->bzfree = 0;
  (*v5)->opaque = 0;
  v7 = *v5;
  if (a2)
  {
    v7->next_in = 0;
    (*v5)->next_out = v6;
    (*v5)->avail_in = 0;
    (*v5)->avail_out = 0x20000;
    if (BZ2_bzCompressInit(*v5, 9, 0, 0))
    {
LABEL_7:
      free(*(void **)(a1 + 40));
      free(*(void **)(a1 + 48));
      v5[1] = 0;
LABEL_13:
      *v5 = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v7->next_in = v6;
    v8 = *(_QWORD *)(a1 + 72);
    if (v8)
    {
      v9 = 88;
      if (!*(_DWORD *)(a1 + 80))
        v9 = 48;
      memcpy(**(void ***)(a1 + 40), *(const void **)(a1 + v9), v8);
      *(_DWORD *)(*(_QWORD *)(a1 + 40) + 8) = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(a1 + 72) = 0;
    }
    else
    {
      (*v5)->avail_in = 0;
    }
    (*v5)->next_out = 0;
    (*v5)->avail_out = 0;
    if (BZ2_bzDecompressInit(*v5, 0, 0))
      goto LABEL_7;
  }
  v11 = crc32(0, 0, 0);
  result = 0;
  *(_QWORD *)(a1 + 56) = v11;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

uint64_t _BOMFileWriteRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6;
  CFIndex v7;
  uint64_t v8;

  v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 2)
    {
      v7 = CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1 == 1)
    {
      v7 = (*(uint64_t (**)(_QWORD, _QWORD, UInt8 *, CFIndex))(*(_QWORD *)(a1 + 272) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    else
    {
      v7 = -1;
    }
    v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1)
      break;
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(_QWORD *)(a1 + 16) += v6;
  if (v7 < 0)
    return -1;
  else
    return v6;
}

_QWORD *_initBufferPool()
{
  _QWORD *result;
  char *v1;
  int *v2;

  result = BOMBufferPoolAllocate(gBOMAsyncBufferSize, gBOMAsyncBufferCount);
  if (!result)
  {
    v1 = BOMExceptionHandlerMessage("Unable to allocate BOM buffer pool gBOMAsyncBufferSize=%lu gBOMAsyncBufferCount=%u!\n", gBOMAsyncBufferSize, gBOMAsyncBufferCount);
    v2 = __error();
    _BOMFatalException((uint64_t)v1, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMFile.c", 2825, *v2);
  }
  gBufferPool = (uint64_t)result;
  return result;
}

uint64_t _asyncWriteThread(uint64_t a1)
{
  FILE **v2;
  int v3;
  uint64_t v4;
  CFIndex v5;
  int v6;
  int v7;
  FILE *v8;
  int *v9;

  v2 = (FILE **)MEMORY[0x24BDAC8D8];
  if (gBOMAsyncDebug == 1)
    fwrite("async write thread starting\n", 0x1CuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  v3 = 0;
  do
  {
    v4 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    v5 = BOMFileWrite(*(_QWORD *)(a1 + 8), *(UInt8 **)(v4 + 24), *(_QWORD *)(v4 + 16));
    v6 = *(_DWORD *)(v4 + 48);
    if ((v6 & 1) != 0 && gBOMAsyncDebug == 1)
      fwrite("async write thread asked to finish\n", 0x23uLL, 1uLL, *v2);
    if (v5 == -1)
    {
      if (gBOMAsyncDebug == 1)
      {
        v8 = *v2;
        v9 = __error();
        fprintf(v8, "async write thread finished file (errno=%d)\n", *v9);
      }
      v3 = *__error();
      v7 = 1;
    }
    else
    {
      v7 = v6 & 1;
    }
    ++*(_QWORD *)(v4 + 40);
    BOMBufferPoolReturnBuffer(gBufferPool, v4);
  }
  while (!v7);
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
  {
    *(_DWORD *)(a1 + 232) = 2;
    *(_DWORD *)(a1 + 236) = v3;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 120))
      && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))
      && gBOMAsyncDebug == 1)
    {
      fwrite("async write thread terminating\n", 0x1FuLL, 1uLL, *v2);
    }
  }
  return 0;
}

uint64_t _asyncReadThread(uint64_t a1)
{
  unint64_t *i;
  int v3;
  unint64_t v4;
  int v5;
  FILE *v6;
  int *v7;

  if (gBOMAsyncDebug == 1)
    fwrite("async read thread starting\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  for (i = BOMBufferPoolRequestBuffer(gBufferPool); ; i = BOMBufferPoolRequestBuffer(gBufferPool))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))
      || (v3 = *(_DWORD *)(a1 + 232), pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))))
    {
      v5 = 0;
      goto LABEL_20;
    }
    if (v3 == 1)
    {
      if (gBOMAsyncDebug == 1)
      {
        fwrite("async read thread asked to finish\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
LABEL_13:
        if (gBOMAsyncDebug == 1)
          fwrite("async read thread finished file\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      }
      v5 = 0;
      goto LABEL_19;
    }
    v4 = BOMFileRead(*(int **)(a1 + 8), (char *)i[3], *i);
    if (v4 == -1)
      break;
    if (!v4)
      goto LABEL_13;
    i[1] = 0;
    i[2] = v4;
    ++i[5];
    BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 96), (uint64_t)i);
  }
  if (gBOMAsyncDebug == 1)
  {
    v6 = (FILE *)*MEMORY[0x24BDAC8D8];
    v7 = __error();
    fprintf(v6, "async read thread finished file (errno=%d)\n", *v7);
  }
  v5 = *__error();
LABEL_19:
  i[1] = 0;
  i[2] = 0;
  ++i[5];
LABEL_20:
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
  {
    *(_DWORD *)(a1 + 232) = 2;
    *(_DWORD *)(a1 + 236) = v5;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 120)) && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)))
    {
      if (i)
        BOMBufferFIFOEnqueue(*(_QWORD *)(a1 + 96), (uint64_t)i);
      if (gBOMAsyncDebug == 1)
        fwrite("async read thread terminating\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
  }
  return 0;
}

uint64_t decrypt_buffer(uint64_t result, int a2, int *a3)
{
  int v4;
  unsigned __int8 *v5;
  unsigned __int8 v6;

  if (a2)
  {
    v4 = a2;
    v5 = (unsigned __int8 *)result;
    do
    {
      --v4;
      v6 = *v5 ^ decrypt_byte((uint64_t)a3);
      *v5++ = v6;
      result = update_keys(a3, v6);
    }
    while (v4);
  }
  return result;
}

uint64_t search_for_data_descriptor(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;

  *a3 = 0;
  if (a2 <= 4)
    return 0;
  v3 = 0;
  v4 = a1 + 1;
  while (*(_BYTE *)(a1 + v3) != 80
       || *(_BYTE *)(v4 + v3) != 75
       || *(_BYTE *)(v4 + v3 + 1) != 7
       || *(_BYTE *)(v4 + v3 + 2) != 8)
  {
    if (a2 - 4 == ++v3)
      return 0;
  }
  *a3 = v3;
  return 1;
}

uint64_t BOMExceptionHandlerSet(uint64_t result)
{
  gHandler = result;
  return result;
}

void _BOMFatalException(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t (*v4)(uint64_t);
  uint64_t v5;
  const char *v6;
  _QWORD v7[3];
  int v8;
  int v9;

  v4 = (uint64_t (*)(uint64_t))gHandler;
  if (!gHandler)
    v4 = _defaultHandler;
  v5 = gMessage;
  if (a1)
    v5 = a1;
  v7[0] = v5;
  v7[1] = 1;
  if (a2)
    v6 = a2;
  else
    v6 = "";
  v7[2] = v6;
  v8 = a3;
  v9 = a4;
  v4((uint64_t)v7);
  abort();
}

uint64_t _defaultHandler(uint64_t a1)
{
  int v2;
  FILE *v3;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 24);
  v3 = (FILE *)*MEMORY[0x24BDAC8D8];
  if (v2)
    result = fprintf(v3, "[%s:%u] %s\n");
  else
    result = fprintf(v3, "%s\n");
  if (*(_BYTE *)(a1 + 8))
    abort();
  return result;
}

uint64_t _BOMExceptionHandlerCall(uint64_t a1, unsigned __int8 a2, const char *a3, int a4, int a5)
{
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  const char *v7;
  _QWORD v9[3];
  int v10;
  int v11;

  v5 = (uint64_t (*)(uint64_t))gHandler;
  if (!gHandler)
    v5 = _defaultHandler;
  v6 = gMessage;
  if (a1)
    v6 = a1;
  v9[0] = v6;
  v7 = "";
  v9[1] = a2;
  if (a3)
    v7 = a3;
  v9[2] = v7;
  v10 = a4;
  v11 = a5;
  return v5((uint64_t)v9);
}

char *BOMExceptionHandlerMessage(char *__format, ...)
{
  char *result;
  va_list va;

  va_start(va, __format);
  result = (char *)gMessage;
  if (!gMessage)
  {
    result = (char *)malloc_type_malloc(0x1000uLL, 0x100004077774924uLL);
    gMessage = (uint64_t)result;
    if (!result)
      return result;
    *result = 0;
  }
  vsnprintf(result, 0x1000uLL, __format, va);
  return (char *)gMessage;
}

uint64_t BOMCRC32ForFile(const char *a1, _DWORD *a2, off_t *a3)
{
  uint64_t v3;
  int *v7;
  char *v8;
  char *v9;
  int v10;
  uint64_t v11;
  int v12;
  off_t st_size;
  int v15;
  int v16;
  int *v17;
  char *v18;
  char *v19;
  stat v20;

  v3 = 1;
  if (a1 && a2)
  {
    memset(&v20, 0, sizeof(v20));
    if (stat(a1, &v20))
    {
      v7 = __error();
      v8 = strerror(*v7);
      v9 = BOMExceptionHandlerMessage("stat: %s\n", v8);
      v10 = *__error();
      v11 = (uint64_t)v9;
      v12 = 213;
LABEL_5:
      _BOMExceptionHandlerCall(v11, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMCRC32.c", v12, v10);
      return v3;
    }
    st_size = v20.st_size;
    v15 = open(a1, 0, 0);
    if (v15 == -1)
    {
      v17 = __error();
      v18 = strerror(*v17);
      v19 = BOMExceptionHandlerMessage("open: %s\n", v18);
      v10 = *__error();
      v11 = (uint64_t)v19;
      v12 = 220;
      goto LABEL_5;
    }
    v16 = v15;
    v3 = posix_checksum(v15, a2, st_size);
    close(v16);
    if (a3)
      *a3 = st_size;
  }
  return v3;
}

uint64_t posix_checksum(int a1, _DWORD *a2, uint64_t a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  BOOL v10;
  FILE *v12;
  int *v13;
  char *v14;
  FILE *v15;
  int *v16;
  char *v17;

  v6 = malloc_type_malloc(0x20000uLL, 0x1D38C244uLL);
  if (v6)
  {
    v7 = v6;
    CNCRCInit();
    if (a3)
    {
      v8 = 0;
      do
      {
        if ((unint64_t)(a3 - v8) >= 0x20000)
          v9 = 0x20000;
        else
          v9 = a3 - v8;
        if (read(a1, v7, v9) != v9)
        {
          v15 = (FILE *)*MEMORY[0x24BDAC8D8];
          v16 = __error();
          v17 = strerror(*v16);
          fprintf(v15, "Could not read: %s", v17);
          free(v7);
          return 0xFFFFFFFFLL;
        }
        CNCRCUpdate();
        v8 += v9;
      }
      while (v8 != a3);
      do
      {
        CNCRCUpdate();
        v10 = (unint64_t)a3 > 0xFF;
        a3 >>= 8;
      }
      while (v10);
    }
    CNCRCFinal();
    *a2 = 0;
    free(v7);
    CNCRCRelease();
    return 0;
  }
  else
  {
    v12 = (FILE *)*MEMORY[0x24BDAC8D8];
    v13 = __error();
    v14 = strerror(*v13);
    fprintf(v12, "Could not allocate buffer: %s", v14);
    return 0xFFFFFFFFLL;
  }
}

uint64_t BOMCRC32ForFileDesc(int a1, _DWORD *a2, uint64_t a3)
{
  if ((a1 - 1) > 0xFFFFFFFD || a2 == 0)
    return 1;
  else
    return posix_checksum(a1, a2, a3);
}

uint64_t BOMCRC32ForBuffer(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  uint64_t v5;
  BOOL v6;

  if (CNCRCInit() || CNCRCUpdate())
    return 1;
  if (!a3)
  {
LABEL_6:
    if (!CNCRCFinal())
    {
      CNCRCRelease();
      v5 = 0;
      *a2 = 0;
      return v5;
    }
    return 1;
  }
  while (1)
  {
    v5 = 1;
    if (CNCRCUpdate())
      return v5;
    v6 = a3 >= 0x100;
    a3 >>= 8;
    if (!v6)
      goto LABEL_6;
  }
}

uint64_t BOMCRC32ForBufferSegment(unsigned __int8 *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int i;
  int v5;

  v3 = 1;
  if (a1 && a2)
  {
    for (i = *a2; a3; --a3)
    {
      v5 = *a1++;
      i = crctab[v5 ^ HIBYTE(i)] ^ (i << 8);
    }
    v3 = 0;
    *a2 = i;
  }
  return v3;
}

uint64_t BOMCRC32ForBufferSegmentFinal(unsigned __int8 *a1, unsigned int *a2, uint64_t a3, unint64_t a4)
{
  BOOL v4;
  int v5;
  uint64_t v6;
  unsigned int i;
  int v8;
  BOOL v9;

  if (a1)
    v4 = 1;
  else
    v4 = a3 == 0;
  v5 = v4;
  v6 = 1;
  if (a2 && v5)
  {
    for (i = *a2; a3; --a3)
    {
      v8 = *a1++;
      i = crctab[v8 ^ HIBYTE(i)] ^ (i << 8);
    }
    if (a4)
    {
      do
      {
        i = crctab[a4 ^ (unint64_t)HIBYTE(i)] ^ (i << 8);
        v9 = a4 > 0xFF;
        a4 >>= 8;
      }
      while (v9);
    }
    v6 = 0;
    *a2 = ~i;
  }
  return v6;
}

_DWORD *_BOMBomGetFSObjectWithBlockID(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v10;
  unsigned int v11;

  v4 = BOMStreamWithBlockID(*(_QWORD *)(a1 + 8), a2, 0, 0);
  if (v4)
  {
    v5 = v4;
    v6 = BOMFSObjectUnarchive(v4);
    BOMStreamFree(v5);
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_QWORD *)(a1 + 40);
  if (v7)
  {
    v11 = bswap32(a2);
    v10 = 0;
    if (BOMTreeGetValueSize(v7, &v11, 4uLL, &v10))
      v8 = 0;
    else
      v8 = v10 == 8;
    if (v8 && BOMTreeGetValue(*(_QWORD *)(a1 + 40), &v11, 4uLL))
    {
      __memcpy_chk();
      BOMFSObjectSetSize((uint64_t)v6, bswap64(0));
    }
  }
  return v6;
}

uint64_t BOMBomPathsTree(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

char *BOMBomOpen(char *a1, int a2)
{
  return BOMBomOpenWithSys(a1, a2, 0);
}

char *BOMBomOpenWithSys(char *a1, int a2, void *a3)
{
  void *v3;
  uint64_t v6;
  uint64_t v8;
  _DWORD *v9;
  unsigned int NamedBlock;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int UInt32;
  int ArchInfo;
  int v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;

  v3 = a3;
  if (!a3)
    v3 = BomSys_default();
  if (a1)
  {
    if (a2)
      v6 = 6;
    else
      v6 = 4;
    if (!(*((unsigned int (**)(_QWORD, char *, uint64_t))v3 + 23))(*((_QWORD *)v3 + 1), a1, v6))
    {
      v8 = BOMStorageOpenWithSys(a1, a2, v3);
      if (v8)
      {
        v9 = (_DWORD *)v8;
        NamedBlock = BOMStorageGetNamedBlock(v8, "BomInfo");
        if (NamedBlock)
        {
          v11 = NamedBlock;
          a1 = (char *)BOM_malloczero(0x48uLL);
          if (!a1)
          {
            BOMStorageFree(v9);
            return a1;
          }
          v12 = BOMStreamWithBlockID((uint64_t)v9, v11, 0, 0);
          if (!v12
            || (v13 = v12,
                BOMStreamReadUInt32(v12),
                UInt32 = BOMStreamReadUInt32(v13),
                ArchInfo = _readArchInfo((uint64_t)a1, v13),
                v16 = BOMStreamFree(v13),
                ArchInfo)
            || v16)
          {
            BOMStorageFree(v9);
            free(a1);
          }
          else
          {
            *(_DWORD *)a1 = UInt32;
            *((_QWORD *)a1 + 1) = v9;
            *((_QWORD *)a1 + 2) = BOMTreeOpenWithName((uint64_t)v9, "Paths", a2);
            *((_QWORD *)a1 + 3) = BOMBomHLIndexOpen((uint64_t)v9, a2);
            v17 = BOMBomVIndexOpen((uint64_t)v9, a2);
            *((_QWORD *)a1 + 4) = v17;
            if (*((_QWORD *)a1 + 2))
            {
              if (*((_QWORD *)a1 + 3))
              {
                if (v17)
                {
                  v18 = BOMTreeOpenWithName((uint64_t)v9, "Size64", a2);
                  *((_QWORD *)a1 + 5) = v18;
                  if (a2 != 1
                    || v18
                    || (v19 = BOMTreeNewWithName((uint64_t)v9, "Size64"), (*((_QWORD *)a1 + 5) = v19) != 0))
                  {
                    a1[65] = a2;
                    return a1;
                  }
                }
              }
            }
            BOMBomFree((uint64_t)a1);
          }
        }
        else
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "file %s is not a bom file\n", a1);
        }
      }
    }
    return 0;
  }
  return a1;
}

uint64_t _readArchInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void *v5;
  uint64_t v6;
  unint64_t v7;

  result = BOMStreamReadUInt32(a2);
  *(_DWORD *)(a1 + 48) = result;
  if ((_DWORD)result)
  {
    v5 = BOM_malloczero(24 * result);
    *(_QWORD *)(a1 + 56) = v5;
    if (v5)
    {
      if (*(_DWORD *)(a1 + 48))
      {
        v6 = 0;
        v7 = 0;
        do
        {
          *(_DWORD *)(*(_QWORD *)(a1 + 56) + v6) = BOMStreamReadUInt32(a2);
          *(_DWORD *)(*(_QWORD *)(a1 + 56) + v6 + 4) = BOMStreamReadUInt32(a2);
          *(_QWORD *)(*(_QWORD *)(a1 + 56) + v6 + 8) = BOMStreamReadUInt32(a2);
          *(_DWORD *)(*(_QWORD *)(a1 + 56) + v6 + 16) = BOMStreamReadUInt32(a2);
          ++v7;
          v6 += 24;
        }
        while (v7 < *(unsigned int *)(a1 + 48));
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMBomFree(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  _DWORD *v7;

  if (!a1)
    return 1;
  if (*(_BYTE *)(a1 + 64) && BOMBomCommit(a1))
    return 1;
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    BOMTreeFree(v3);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
  {
    BOMBomHLIndexFree(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v5 = *(_BYTE **)(a1 + 32);
  if (v5)
  {
    BOMBomVIndexFree(v5);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v6 = *(_QWORD *)(a1 + 40);
  if (v6)
  {
    BOMTreeFree(v6);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v7 = *(_DWORD **)(a1 + 8);
  if (v7)
  {
    result = BOMStorageFree(v7);
    if ((_DWORD)result)
      return result;
    *(_QWORD *)(a1 + 8) = 0;
  }
  free(*(void **)(a1 + 56));
  free((void *)a1);
  return 0;
}

_DWORD *BOMBomOpenWithStorage(_DWORD *a1, int a2)
{
  unsigned int NamedBlock;
  unsigned int v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int UInt32;
  int ArchInfo;
  int v11;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;

  NamedBlock = BOMStorageGetNamedBlock(a1, "BomInfo");
  if (NamedBlock)
  {
    v5 = NamedBlock;
    v6 = BOM_malloczero(0x48uLL);
    if (!v6)
    {
      BOMStorageFree(a1);
      return v6;
    }
    v7 = BOMStreamWithBlockID((uint64_t)a1, v5, 0, 0);
    if (!v7
      || (v8 = v7,
          BOMStreamReadUInt32(v7),
          UInt32 = BOMStreamReadUInt32(v8),
          ArchInfo = _readArchInfo((uint64_t)v6, v8),
          v11 = BOMStreamFree(v8),
          ArchInfo)
      || v11)
    {
      BOMStorageFree(a1);
      free(v6);
    }
    else
    {
      *v6 = UInt32;
      *((_QWORD *)v6 + 1) = a1;
      *((_QWORD *)v6 + 2) = BOMTreeOpenWithName((uint64_t)a1, "Paths", a2);
      *((_QWORD *)v6 + 3) = BOMBomHLIndexOpen((uint64_t)a1, a2);
      v13 = BOMBomVIndexOpen((uint64_t)a1, a2);
      *((_QWORD *)v6 + 4) = v13;
      if (*((_QWORD *)v6 + 2))
      {
        if (*((_QWORD *)v6 + 3))
        {
          if (v13)
          {
            v14 = BOMTreeOpenWithName((uint64_t)a1, "Size64", a2);
            *((_QWORD *)v6 + 5) = v14;
            if (a2 != 1 || v14 || (v15 = BOMTreeNewWithName((uint64_t)a1, "Size64"), (*((_QWORD *)v6 + 5) = v15) != 0))
            {
              *((_BYTE *)v6 + 65) = a2;
              return v6;
            }
          }
        }
      }
      BOMBomFree((uint64_t)v6);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "file %s is not a bom file\n", "<storage>");
  }
  return 0;
}

_QWORD *BOMBomNewWithStorage(_DWORD *a1)
{
  _DWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  _QWORD *v8;

  if (a1)
  {
    v1 = a1;
    v2 = BOM_malloczero(0x48uLL);
    if (!v2)
      return v2;
  }
  else
  {
    v3 = BOMStorageNewInRAM();
    if (!v3)
      return 0;
    v1 = (_DWORD *)v3;
    v2 = BOM_malloczero(0x48uLL);
    if (!v2)
    {
      BOMStorageFree(v1);
      return v2;
    }
  }
  *(_DWORD *)v2 = 1;
  v2[1] = v1;
  v4 = BOMStorageNewNamedBlock((uint64_t)v1, "BomInfo");
  if (!v4)
    goto LABEL_13;
  v5 = BOMStreamWithBlockID(v2[1], v4, (16 * *((unsigned int *)v2 + 12)) | 0xC, 1);
  if (!v5)
    goto LABEL_13;
  v6 = v5;
  BOMStreamWriteUInt32(v5, 1u);
  BOMStreamWriteUInt32(v6, *(_DWORD *)v2);
  _writeArchInfo((uint64_t)v2, v6);
  BOMStreamFree(v6);
  v2[2] = BOMTreeNewWithName((uint64_t)v1, "Paths");
  v2[3] = BOMBomHLIndexNew((uint64_t)v1);
  v7 = BOMBomVIndexNew((uint64_t)v1);
  v2[4] = v7;
  if (!v2[2] || !v2[3] || !v7 || (v8 = BOMTreeNewWithName((uint64_t)v1, "Size64"), (v2[5] = v8) == 0))
  {
LABEL_13:
    BOMBomFree((uint64_t)v2);
    return 0;
  }
  *((_WORD *)v2 + 32) = 257;
  return v2;
}

uint64_t _writeArchInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;

  result = BOMStreamWriteUInt32(a2, *(_DWORD *)(a1 + 48));
  if (*(_DWORD *)(a1 + 48))
  {
    v5 = 0;
    v6 = 0;
    do
    {
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(_QWORD *)(a1 + 56) + v5));
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(_QWORD *)(a1 + 56) + v5 + 4));
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(_QWORD *)(a1 + 56) + v5 + 8));
      result = BOMStreamWriteUInt32(a2, *(_DWORD *)(*(_QWORD *)(a1 + 56) + v5 + 16));
      ++v6;
      v5 += 24;
    }
    while (v6 < *(unsigned int *)(a1 + 48));
  }
  return result;
}

_QWORD *BOMBomNew(const char *a1)
{
  return BOMBomNewWithSys(a1, 0);
}

_QWORD *BOMBomNewWithSys(const char *a1, uint64_t (**a2)(_QWORD, const char *, uint64_t, uint64_t))
{
  uint64_t (**v2)(_QWORD, const char *, uint64_t, uint64_t);
  _DWORD *v4;

  v2 = a2;
  if (!a2)
  {
    v2 = (uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t))BomSys_default();
    if (a1)
      goto LABEL_3;
LABEL_7:
    v4 = 0;
    return BOMBomNewWithStorage(v4);
  }
  if (!a1)
    goto LABEL_7;
LABEL_3:
  if (((unsigned int (*)(uint64_t (*)(_QWORD, const char *, uint64_t, uint64_t), const char *, uint64_t))v2[23])(v2[1], a1, 6)|| !((unsigned int (*)(uint64_t (*)(_QWORD, const char *, uint64_t, uint64_t), const char *))v2[28])(v2[1], a1))
  {
    v4 = (_DWORD *)BOMStorageNewWithSys(a1, v2);
    if (!v4)
      return 0;
    return BOMBomNewWithStorage(v4);
  }
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't unlink %s\n", a1);
  return 0;
}

BOOL BOMBomFSObjectExistsAtPath(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    if (a2)
      return _valueAtPath(a1) != 0;
  }
  return result;
}

unsigned int *_valueAtPath(uint64_t a1)
{
  char *v2;
  char *v3;
  unsigned int v4;
  char *v5;
  char *v6;
  unsigned int *Value;
  size_t v9;
  char *__stringp;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v9 = 0;
  __stringp = &v11;
  __strlcpy_chk();
  v2 = strsep(&__stringp, "/");
  if (v2)
  {
    v3 = v2;
    v4 = 0;
    while (1)
    {
      v5 = BOMNewPathKey(v4, v3, &v9);
      if (!v5)
        break;
      v6 = v5;
      Value = (unsigned int *)BOMTreeGetValue(*(_QWORD *)(a1 + 16), v5, v9);
      free(v6);
      if (Value)
      {
        v4 = BOMPathIDFromPathKey(Value);
        v3 = strsep(&__stringp, "/");
        if (v3)
          continue;
      }
      return Value;
    }
  }
  return 0;
}

uint64_t BOMBomNewFromBom(const char *a1, uint64_t a2)
{
  uint64_t (**Sys)(_QWORD, const char *, uint64_t, uint64_t);
  _QWORD *v5;
  uint64_t v6;
  const void **v7;
  const void **v8;
  char *v9;
  char *v10;
  size_t v11;
  void *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  const UInt8 *v16;
  size_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  _DWORD *v22;
  _QWORD *v23;
  const void *v24;
  size_t v25;
  int v26;
  FILE *v27;
  const char *v28;
  size_t v29;
  void *v30;
  uint64_t v31;
  size_t v32;
  void *v33;
  char *v35;
  int *v36;
  size_t v37;
  uint64_t v38;
  UInt8 bytes[4];
  _BYTE v40[1024];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  Sys = (uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t))BOMStorageGetSys(*(_QWORD *)(a2 + 8));
  v5 = BOMBomNewWithSys(a1, Sys);
  v6 = (uint64_t)v5;
  if (!a2 || !v5)
    goto LABEL_43;
  BOMTreeSetDensePacking(v5[2], 1);
  v7 = (const void **)BOMHardLinkTableNew();
  if (!v7)
    goto LABEL_44;
  v8 = v7;
  *(_DWORD *)bytes = 0;
  v38 = 0;
  v9 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a2 + 16), 0, 0, 0);
  if (!v9)
  {
    BOMHardLinkTableFree(v8);
    goto LABEL_44;
  }
  v10 = v9;
  if (BOMTreeIteratorIsAtEnd((uint64_t)v9))
  {
    BOMHardLinkTableFree(v8);
    BOMTreeIteratorFree(v10);
    goto LABEL_37;
  }
  v11 = 0;
  v12 = 0;
  while (1)
  {
    v13 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v10);
    v14 = BOMBlockIDFromPathValue((uint64_t)v13);
    v15 = BOMPathIDFromPathKey(v13);
    v16 = BOMHardLinkTableGet((CFDictionaryRef *)v8, 0, v14);
    if (v16)
    {
      *(_DWORD *)bytes = *(_DWORD *)v16;
      goto LABEL_22;
    }
    v17 = BOMStorageSizeOfBlock(*(_QWORD *)(a2 + 8), v14);
    if (v17 > v11)
    {
      if (v12)
        free(v12);
      v12 = BOM_malloc(v17);
      v11 = v17;
    }
    if (BOMStorageCopyFromBlock(*(_QWORD *)(a2 + 8), v14, v12))
    {
      v35 = BOMExceptionHandlerMessage("_copyFilesFromBomToBomInOrder failed while getting data (pid=%u bid=%u)", v15, v14);
      v36 = __error();
      _BOMFatalException((uint64_t)v35, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 985, *v36);
    }
    v18 = BOMStorageNewBlock(*(_QWORD *)(v6 + 8));
    *(_DWORD *)bytes = v18;
    if (BOMStorageSetBlockData(*(_QWORD *)(v6 + 8), v18, v12, v17))
      break;
    v19 = BOMBomHLIndexCount(*(_QWORD *)(a2 + 24), v14);
    if (v19 >= 2)
    {
      v20 = v19;
      v37 = 0;
      BOMHardLinkTableSet((CFDictionaryRef *)v8, 0, v14, bytes, 4);
      v21 = 0;
      while (1)
      {
        if (BOMBomHLIndexGet(*(_QWORD *)(a2 + 24), v14, v21, v40, &v37))
        {
          v27 = (FILE *)*MEMORY[0x24BDAC8D8];
          v28 = "can't get hardlink data\n";
          v29 = 24;
          goto LABEL_33;
        }
        if (BOMBomHLIndexSet(*(_QWORD *)(v6 + 24), *(unsigned int *)bytes, v40, v37))
          break;
        if (v20 == ++v21)
          goto LABEL_22;
      }
      v27 = (FILE *)*MEMORY[0x24BDAC8D8];
      v28 = "can't set hardlink index\n";
      goto LABEL_32;
    }
LABEL_22:
    v22 = BOMNewPathValue(v15, *(unsigned int *)bytes, &v38);
    v23 = *(_QWORD **)(v6 + 16);
    v24 = (const void *)BOMTreeIteratorKey((uint64_t)v10);
    v25 = BOMTreeIteratorKeySize((uint64_t)v10);
    if (BOMTreeSetValue(v23, v24, v25, (uint64_t)v22, v38))
    {
      if (v22)
        free(v22);
      v27 = (FILE *)*MEMORY[0x24BDAC8D8];
      v28 = "can't set new path value\n";
LABEL_32:
      v29 = 25;
      goto LABEL_33;
    }
    if (v22)
      free(v22);
    BOMTreeIteratorNext((uint64_t)v10);
    if (BOMTreeIteratorIsAtEnd((uint64_t)v10))
    {
      v26 = 1;
      goto LABEL_34;
    }
  }
  v27 = (FILE *)*MEMORY[0x24BDAC8D8];
  v28 = "can't set file data\n";
  v29 = 20;
LABEL_33:
  fwrite(v28, v29, 1uLL, v27);
  v26 = 0;
LABEL_34:
  if (v12)
    free(v12);
  BOMHardLinkTableFree(v8);
  BOMTreeIteratorFree(v10);
  if (!v26)
  {
LABEL_43:
    if (!v6)
      return v6;
LABEL_44:
    BOMBomFree(v6);
    return 0;
  }
LABEL_37:
  BOMTreeSetDensePacking(*(_QWORD *)(v6 + 16), 0);
  if (BOMBomVIndexCopyFromVIndex(*(_QWORD *)(v6 + 32), *(_QWORD *)(a2 + 32)))
    goto LABEL_44;
  v30 = *(void **)(v6 + 56);
  if (v30)
    free(v30);
  v31 = *(unsigned int *)(a2 + 48);
  *(_DWORD *)(v6 + 48) = v31;
  v32 = 24 * v31;
  v33 = BOM_malloczero(24 * v31);
  *(_QWORD *)(v6 + 56) = v33;
  if (v33)
    memmove(v33, *(const void **)(a2 + 56), v32);
  *(_DWORD *)v6 = *(_DWORD *)a2;
  return v6;
}

uint64_t BOMBomNewFromPath(char *a1, char *a2)
{
  return BOMBomNewFromPathWithSys(a1, a2, 0);
}

uint64_t BOMBomNewFromPathWithSys(char *__s1, char *__s2, void *a3)
{
  char *v6;
  uint64_t v7;
  FILE *v8;
  int *v9;
  FILE *v10;
  int *v11;
  _OWORD v13[9];
  _OWORD v14[9];

  if (!__s2 || __s1 && !strcmp(__s1, __s2))
    return 0;
  if (!a3)
    a3 = BomSys_default();
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  if (!__s1)
    goto LABEL_9;
  if ((*((unsigned int (**)(_QWORD, char *, _OWORD *))a3 + 12))(*((_QWORD *)a3 + 1), __s1, v14))
  {
    if (*__error() == 2)
      goto LABEL_9;
    v10 = (FILE *)*MEMORY[0x24BDAC8D8];
    v11 = __error();
    strerror(*v11);
    fprintf(v10, "can't stat %s: %s\n");
    return 0;
  }
  if ((*((unsigned int (**)(_QWORD, char *, _OWORD *))a3 + 12))(*((_QWORD *)a3 + 1), __s2, v13))
  {
    v8 = (FILE *)*MEMORY[0x24BDAC8D8];
    v9 = __error();
    strerror(*v9);
    fprintf(v8, "can't stat %s: %s\n");
    return 0;
  }
  if (LODWORD(v14[0]) == LODWORD(v13[0]) && *((_QWORD *)&v14[0] + 1) == *((_QWORD *)&v13[0] + 1))
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s and %s are identical.\n");
    return 0;
  }
LABEL_9:
  v6 = BOMBomOpenWithSys(__s2, 0, a3);
  v7 = BOMBomNewFromBom(__s1, (uint64_t)v6);
  if (v6)
    BOMBomFree((uint64_t)v6);
  return v7;
}

unsigned int *BOMBomNewFromBomWithStripping(const char *a1, uint64_t *a2, const char **a3, const char **a4)
{
  return BOMBomNewFromBomWithOptions(a1, a2, 3, a3, a4);
}

unsigned int *BOMBomNewFromBomWithOptions(const char *a1, uint64_t *a2, char a3, const char **a4, const char **a5)
{
  uint64_t Sys;
  uint64_t v11;
  unsigned int *v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFArray *v20;
  const __CFArray *v21;
  unsigned int *RootFSObject;
  char *v23;
  CFIndex Count;
  unsigned int *v25;
  unsigned int *v26;
  _BOOL4 v27;
  uint64_t v28;
  const char *v29;
  CFIndex v30;
  regex_t *ValueAtIndex;
  __CFArray *v32;
  size_t v33;
  uint64_t v34;
  uint64_t v36;
  _DWORD *v37;
  char *v38;
  int *v39;
  const char *v40;
  char **v41;
  int v42;
  char **v43;
  int v44;
  int v45;
  int v46;
  BOOL v47;
  char v48;
  int v49;
  BOOL v51;
  int v52;
  char v53;
  int v54;
  unsigned int *v55;
  char *v56;
  unsigned int *v57;
  unsigned int *v58;
  int v59;
  int v60;
  unsigned int v61;
  int Arch;
  int ArchSubtype;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  _QWORD *v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  char *v72;
  uint64_t v73;
  _DWORD *v74;
  uint64_t v75;
  __int128 v76;
  const char **v78;
  char v79;
  char __s[1025];
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return 0;
  Sys = BOMStorageGetSys(a2[1]);
  v11 = Sys;
  if (a1
    && !(*(unsigned int (**)(_QWORD, const char *, uint64_t))(Sys + 184))(*(_QWORD *)(Sys + 8), a1, 6)
    && (*(unsigned int (**)(_QWORD, const char *))(v11 + 224))(*(_QWORD *)(v11 + 8), a1))
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't unlink %s\n", a1);
    return 0;
  }
  v12 = (unsigned int *)BOMBomNewWithSys(a1, (uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t))v11);
  if (v12)
  {
    __s[0] = 0;
    v13 = strlen(__s);
    _copyFilesFromBomToBom(a2, v12, 0, __s, &__s[v13], 0, 0, 0, 1);
    _copyVariantsFromBomToBom((uint64_t)a2, (uint64_t)v12, v14, v15, v16, v17, v18, v19);
    if ((a3 & 1) != 0)
    {
      v20 = _patternListForArchAndLangs((uint64_t)a2, a4, a5, 1);
      v21 = v20;
      if (v20)
      {
        if (CFArrayGetCount(v20))
        {
          RootFSObject = (unsigned int *)BOMBomGetRootFSObject((uint64_t)v12);
          v23 = BOMBomEnumeratorNew((uint64_t)v12, RootFSObject);
          BOMFSObjectFree((uint64_t)RootFSObject);
          if (v23)
          {
            v78 = a5;
            v79 = a3;
            Count = CFArrayGetCount(v21);
            v25 = BOMBomEnumeratorNext((uint64_t)v23);
            if (v25)
            {
              v26 = v25;
              v27 = 0;
              while (1)
              {
                v28 = BOMFSObjectPathName((uint64_t)v26);
                if (Count >= 1)
                  break;
LABEL_16:
                if (v27)
                  goto LABEL_17;
LABEL_18:
                BOMFSObjectFree((uint64_t)v26);
                v26 = BOMBomEnumeratorNext((uint64_t)v23);
                if (!v26)
                  goto LABEL_19;
              }
              v29 = (const char *)v28;
              v30 = 0;
              while (1)
              {
                ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(v21, v30);
                if (ValueAtIndex)
                {
                  v27 = BOMPatternMatch(ValueAtIndex, v29);
                  if (v27)
                    break;
                }
                if (Count == ++v30)
                  goto LABEL_16;
              }
LABEL_17:
              BOMBomRemoveFSObject((unint64_t)v12, v26);
              goto LABEL_18;
            }
LABEL_19:
            BOMBomEnumeratorFree(v23);
            a3 = v79;
            a5 = v78;
          }
        }
      }
      BOMPatternListFree(v21);
      __s[0] = 0;
      v32 = _patternListForArchAndLangs((uint64_t)a2, a4, a5, 0);
      v33 = strlen(__s);
      _copyFilesFromBomToBom(a2, v12, v32, __s, &__s[v33], 0, 0, 0, 1);
      BOMPatternListFree(v32);
    }
    if ((a3 & 2) != 0 && a4 && *a4)
    {
      v34 = 0;
      while (a4[++v34])
        ;
      v36 = v34;
      v37 = BOM_malloczero(32 * v34);
      v38 = (char *)v37;
      if ((_DWORD)v34)
      {
        v39 = v37 + 2;
        while (1)
        {
          v40 = *a4;
          v41 = BOMGetArchInfoFromName((char *)*a4);
          if (!v41)
            break;
          v42 = *((_DWORD *)v41 + 3);
          v43 = BOMGetArchInfoFromCpuType(*((_DWORD *)v41 + 2), -1);
          if (!v43)
            break;
          v45 = *((_DWORD *)v43 + 2);
          v44 = *((_DWORD *)v43 + 3);
          v46 = 16777228;
          v47 = v45 == 16777228 && v42 == 0;
          if (v47)
          {
            v48 = 0;
          }
          else
          {
            v46 = *((_DWORD *)v43 + 2);
            v48 = 1;
          }
          if (v47)
            v49 = 0;
          else
            v49 = -1;
          if (v45 == 16777223 && v42 == 3)
          {
            v46 = 16777223;
            v48 = 0;
            v49 = 3;
          }
          v51 = v42 == v44;
          if (v42 == v44)
            v52 = v46;
          else
            v52 = *((_DWORD *)v43 + 2);
          if (v51)
            v53 = v48;
          else
            v53 = 0;
          if (v51)
            v54 = v49;
          else
            v54 = v42;
          *(v39 - 2) = v52;
          *((_BYTE *)v39 - 4) = v53;
          *v39 = v54;
          v39 += 8;
          ++a4;
          if (!--v36)
            goto LABEL_54;
        }
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't get arch info for '%s'", v40);
      }
      else
      {
LABEL_54:
        v55 = (unsigned int *)BOMBomGetRootFSObject((uint64_t)v12);
        v56 = BOMBomEnumeratorNew((uint64_t)v12, v55);
        BOMFSObjectFree((uint64_t)v55);
        if (v56)
        {
          v57 = BOMBomEnumeratorNext((uint64_t)v56);
          if (v57)
          {
            v58 = v57;
            do
            {
              if (BOMFSObjectType(v58) == 1 && BOMFSObjectIsBinaryObject((uint64_t)v58))
              {
                v59 = BOMFSObjectArchCount((uint64_t)v58);
                if (v59)
                {
                  v60 = v59;
                  v61 = 0;
                  while (1)
                  {
                    Arch = BOMFSObjectGetArch((uint64_t)v58, v61);
                    ArchSubtype = BOMFSObjectGetArchSubtype((uint64_t)v58, v61);
                    if ((_DWORD)v34)
                      break;
LABEL_67:
                    if (++v61 == v60)
                      goto LABEL_68;
                  }
                  v64 = 0;
                  while (Arch != *(_DWORD *)&v38[v64]
                       || !v38[v64 + 4] && ((*(_DWORD *)&v38[v64 + 8] ^ ArchSubtype) & 0xFFFFFF) != 0)
                  {
                    v64 += 32;
                    if (32 * v34 == v64)
                      goto LABEL_67;
                  }
                  if (!BOMFSObjectThinKeepingArchsAndSubArchs((uint64_t)v58, (uint64_t)v38, v34))
                  {
                    v65 = BOMFSObjectBlockID((uint64_t)v58);
                    if (!_BOMBomSetFSObjectWithBlockID((uint64_t)v12, (uint64_t)v58, v65))
                      *((_BYTE *)v12 + 64) = 1;
                  }
                }
                else
                {
LABEL_68:
                  BOMBomRemoveFSObject((unint64_t)v12, v58);
                }
              }
              BOMFSObjectFree((uint64_t)v58);
              v58 = BOMBomEnumeratorNext((uint64_t)v56);
            }
            while (v58);
          }
          BOMBomEnumeratorFree(v56);
          if (*((_BYTE *)v12 + 64))
          {
            v66 = v12[12];
            v67 = (_QWORD *)*((_QWORD *)v12 + 7);
            v68 = BOM_malloczero(24 * (v66 + 1));
            *((_QWORD *)v12 + 7) = v68;
            v69 = v67[2];
            *(_OWORD *)v68 = *(_OWORD *)v67;
            v68[2] = v69;
            if (v66 < 2)
            {
              v71 = 1;
            }
            else
            {
              v70 = 1;
              v71 = 1;
              do
              {
                if ((_DWORD)v34)
                {
                  v72 = (char *)&v67[3 * v70];
                  v73 = v34;
                  v74 = v38 + 8;
                  while (*(_DWORD *)v72 != *(v74 - 2)
                       || !*((_BYTE *)v74 - 4) && ((*v74 ^ *((_DWORD *)v72 + 1)) & 0xFFFFFF) != 0)
                  {
                    v74 += 8;
                    if (!--v73)
                      goto LABEL_84;
                  }
                  v75 = *((_QWORD *)v12 + 7) + 24 * v71++;
                  v76 = *(_OWORD *)v72;
                  *(_QWORD *)(v75 + 16) = *((_QWORD *)v72 + 2);
                  *(_OWORD *)v75 = v76;
                }
LABEL_84:
                ++v70;
              }
              while (v70 != v66);
            }
            v12[12] = v71;
            free(v67);
          }
        }
      }
      free(v38);
    }
  }
  return v12;
}

uint64_t _copyFilesFromBomToBom(uint64_t *a1, unsigned int *a2, const __CFArray *a3, const char *a4, char *a5, unsigned int a6, unsigned int a7, CFDictionaryRef *a8, char a9)
{
  CFDictionaryRef *v9;
  char *v17;
  char *v18;
  char *v19;
  void *v20;
  unsigned __int8 v21;
  unsigned int *v23;
  uint64_t v24;
  const char *v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  size_t v29;
  unsigned int *v30;
  uint64_t v31;
  CFDictionaryRef *v32;
  unsigned int *v33;
  char *v34;
  int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int *v39;
  CFIndex Count;
  CFIndex v41;
  CFIndex v42;
  regex_t *ValueAtIndex;
  _BOOL4 v44;
  _BOOL4 v45;
  const __CFArray *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  _DWORD *FSObjectWithBlockID;
  uint64_t v53;
  size_t v54;
  _DWORD *v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  char *v59;
  char *v60;
  _DWORD *v61;
  int v62;
  uint64_t v63;
  size_t v64;
  size_t v65;
  uint64_t v66;
  CFDictionaryRef *v67;
  char *v68;
  size_t v69;
  uint64_t v70;
  unsigned int v71;
  CFDictionaryRef *v72;
  int v73;
  unsigned int v74;
  _BOOL4 v75;
  uint64_t __size;
  char v77;
  char v78;
  size_t v79;
  unsigned int v80;
  int v81;
  uint64_t v82;
  char *__dst;
  unsigned int v84;
  CFDictionaryRef *v85;
  unsigned int v86;
  const char *v87;
  size_t v88;
  const __CFArray *theArray;
  unsigned __int8 v90;
  unsigned int *v91;
  unsigned int v92;
  uint64_t v93;
  size_t v94;
  char __s[1025];
  uint64_t v96;

  v9 = a8;
  v96 = *MEMORY[0x24BDAC8D0];
  v85 = a8;
  if (!a8)
    v85 = (CFDictionaryRef *)BOMHardLinkTableNew();
  v93 = 0;
  v94 = 0;
  v92 = 0;
  v91 = 0;
  v17 = BOMNewPathKey(a6, "", &v94);
  if (!v17)
    goto LABEL_9;
  v18 = v17;
  v19 = (char *)BOMTreeIteratorNew(a1[2], v17, v94, 0);
  free(v18);
  if (!v19)
    goto LABEL_9;
  __dst = (char *)a4;
  if (a4 != a5)
  {
    *a5 = 47;
    __dst = a5 + 1;
  }
  if (BOMTreeIteratorIsAtEnd((uint64_t)v19))
  {
    BOMTreeIteratorFree(v19);
LABEL_9:
    v20 = 0;
    v21 = 0;
    goto LABEL_10;
  }
  v88 = 0;
  theArray = a3;
  v71 = a7;
  v20 = 0;
  v73 = 0;
  __size = a4 - __dst + 1025;
  v87 = a4;
  v72 = v9;
  v86 = a6;
  do
  {
    v23 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v19);
    if (BOMPathIDFromPathKey(v23) != a6)
      break;
    v24 = (uint64_t)a2;
    v25 = (const char *)BOMShortNameFromPathKey((uint64_t)v23);
    v26 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v19);
    v27 = BOMBlockIDFromPathValue((uint64_t)v26);
    v28 = BOMPathIDFromPathKey(v26);
    v29 = BOMStorageSizeOfBlock(a1[1], v27);
    if (v29 > v88)
    {
      if (v20)
        free(v20);
      v20 = BOM_malloc(v29);
      v88 = v29;
    }
    if (BOMStorageCopyFromBlock(a1[1], v27, v20))
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't unarchive %s. skipping...\n");
LABEL_23:
      a2 = (unsigned int *)v24;
      goto LABEL_24;
    }
    v80 = v28;
    v84 = BOMFSObjectTypeFromRawData((unsigned __int8 *)v20);
    strlcpy(__dst, v25, __size);
    v79 = strlen(v25);
    v92 = 0;
    if (!a9)
    {
      v78 = 0;
      v81 = 0;
      LODWORD(v82) = 1;
      a2 = (unsigned int *)v24;
      goto LABEL_39;
    }
    a2 = (unsigned int *)v24;
    v30 = _valueAtPath(v24);
    if (!v30)
    {
      v78 = 0;
      v81 = 0;
      LODWORD(v82) = 1;
      goto LABEL_39;
    }
    v31 = (uint64_t)v30;
    v32 = v9;
    v33 = BOMPathIDFromPathKey(v30);
    v92 = BOMBlockIDFromPathValue(v31);
    if (BOMStorageCopyFromBlockRange(*(_QWORD *)(v24 + 8), v92, 0, 1uLL, &v90))
    {
      v34 = BOMExceptionHandlerMessage("BOMStorageCopyFromBlockRange(storage=%p, bid=%u, location=%u, length=%u, data=%p) failed!", *(const void **)(v24 + 8), v92, 0, 1, &v90);
      v35 = __error();
      _BOMExceptionHandlerCall((uint64_t)v34, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 743, *v35);
    }
    v36 = BOMFSObjectTypeFromRawData(&v90);
    v81 = v36;
    if (BOMBomHLIndexCount(*(_QWORD *)(v24 + 24), v92))
    {
      if (v36 == 1)
      {
        v37 = v33;
        v78 = 1;
        LODWORD(v82) = 0;
        HIDWORD(v82) = v92;
        v81 = 1;
        v9 = v32;
        a4 = v87;
      }
      else
      {
        LODWORD(v82) = 0;
        v78 = 1;
        v9 = v32;
        a4 = v87;
LABEL_39:
        HIDWORD(v82) = 0;
        v37 = (unsigned int *)*a2;
        *a2 = (_DWORD)v37 + 1;
      }
      if (v84 == 1 && BOMBomHLIndexCount(a1[3], v27))
      {
        v91 = 0;
        BOMHardLinkTableGetPathAndData(v85, 0, v27, __s, &v91);
        if (v91)
        {
          v38 = *v91;
          v75 = 1;
        }
        else
        {
          v38 = BOMStorageNewBlock(*((_QWORD *)a2 + 1));
          v75 = 0;
        }
        v77 = 0;
        v92 = v38;
      }
      else
      {
        v75 = 0;
        v92 = BOMStorageNewBlock(*((_QWORD *)a2 + 1));
        v77 = 1;
      }
      goto LABEL_50;
    }
    v37 = v33;
    if (v84 == 1)
    {
      v9 = v32;
      if (BOMBomHLIndexCount(a1[3], v27))
      {
        v91 = 0;
        BOMHardLinkTableGetPathAndData(v85, 0, v27, __s, &v91);
        v82 = 0;
        v75 = v91 != 0;
        v77 = 0;
        v78 = 1;
      }
      else
      {
        v82 = 0;
        v75 = 0;
        v77 = 1;
        v78 = 1;
      }
    }
    else
    {
      v82 = 0;
      v75 = 0;
      v77 = 1;
      v78 = 1;
      v9 = v32;
    }
    a4 = v87;
LABEL_50:
    if (!v92 || !(_DWORD)v37)
      goto LABEL_24;
    if (theArray)
    {
      v39 = v37;
      Count = CFArrayGetCount(theArray);
      if (Count < 1)
      {
        v45 = 0;
      }
      else
      {
        v41 = Count;
        v42 = 0;
        while (1)
        {
          ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(theArray, v42);
          if (ValueAtIndex)
          {
            v44 = BOMPatternMatch(ValueAtIndex, v87);
            if (v44)
              break;
          }
          if (v41 == ++v42)
          {
            v45 = 0;
            goto LABEL_63;
          }
        }
        v45 = v44;
LABEL_63:
        v9 = v72;
      }
      v37 = v39;
      if (v84 == 2)
      {
        if (v45)
          v46 = 0;
        else
          v46 = theArray;
        LOBYTE(v70) = v78;
        a4 = v87;
        v47 = _copyFilesFromBomToBom(a1, v24, v46, v87, &__dst[v79], v80, v37, v85, v70);
      }
      else
      {
        v47 = 0;
        a4 = v87;
      }
      v48 = v47 | v45;
      a2 = (unsigned int *)v24;
      if (!v48)
        goto LABEL_24;
    }
    else if (v84 == 2)
    {
      LOBYTE(v70) = v78;
      _copyFilesFromBomToBom(a1, a2, 0, a4, &__dst[v79], v80, v37, v85, v70);
    }
    v74 = v37;
    v49 = v82;
    if (v81 == 2)
      v50 = v82;
    else
      v50 = 1;
    if (v50 == 1)
    {
      if ((v82 & 1) == 0)
      {
        if (HIDWORD(v82))
          v51 = HIDWORD(v82);
        else
          v51 = v92;
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID((uint64_t)a2, v51);
        if (FSObjectWithBlockID)
        {
          v53 = (uint64_t)FSObjectWithBlockID;
          _removeArchInfoForFSObject((unint64_t)a2, (uint64_t)FSObjectWithBlockID);
          BOMFSObjectFree(v53);
        }
        v49 = v82;
        if (HIDWORD(v82))
        {
          v54 = strlen(a4) + 1;
          v49 = v82;
          BOMBomHLIndexRemove(*((_QWORD *)a2 + 3), HIDWORD(v82), a4, v54);
          if (!BOMBomHLIndexCount(*((_QWORD *)a2 + 3), HIDWORD(v82)))
            BOMStorageFreeBlock(*((_QWORD *)a2 + 1), HIDWORD(v82));
        }
      }
      if (BOMStorageSetBlockData(*((_QWORD *)a2 + 1), v92, v20, v29))
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't archive %s. skipping...\n", a4);
        goto LABEL_24;
      }
      v55 = _BOMBomGetFSObjectWithBlockID((uint64_t)a2, v92);
      if (v55)
      {
        v56 = (uint64_t)v55;
        _addArchInfoForFSObject((uint64_t)a2, (uint64_t)v55);
        BOMFSObjectFree(v56);
      }
    }
    if (HIDWORD(v82))
      v57 = 1;
    else
      v57 = v49;
    if (v57 == 1)
    {
      v58 = BOMTreeIteratorKey((uint64_t)v19);
      v59 = (char *)BOMShortNameFromPathKey(v58);
      v60 = BOMNewPathKey(v71, v59, &v94);
      v61 = BOMNewPathValue(v74, v92, &v93);
      v62 = BOMTreeSetValue(*((_QWORD **)a2 + 2), v60, v94, (uint64_t)v61, v93);
      free(v60);
      free(v61);
      if (v62)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't set path info for %s. skipping...\n");
        goto LABEL_23;
      }
      v73 = 1;
      a2 = (unsigned int *)v24;
    }
    if ((v77 & 1) == 0)
    {
      if (v75)
      {
        v63 = *((_QWORD *)a2 + 3);
        if (!__s[0])
        {
          v69 = strlen(a4);
          BOMBomHLIndexSet(v63, v92, a4, v69 + 1);
          goto LABEL_24;
        }
        v64 = strlen(__s);
        BOMBomHLIndexSet(v63, v92, __s, v64 + 1);
        v65 = strlen(a4);
        BOMBomHLIndexSet(*((_QWORD *)a2 + 3), v92, a4, v65 + 1);
        v66 = v27;
        v67 = v85;
        v68 = "";
      }
      else
      {
        v66 = v27;
        v67 = v85;
        v68 = (char *)a4;
      }
      BOMHardLinkTableSetPathAndData(v67, 0, v66, v68, &v92, 4uLL);
    }
LABEL_24:
    BOMTreeIteratorNext((uint64_t)v19);
    a6 = v86;
  }
  while (!BOMTreeIteratorIsAtEnd((uint64_t)v19));
  BOMTreeIteratorFree(v19);
  v21 = v73;
  if (v73)
    *((_BYTE *)a2 + 64) = 1;
LABEL_10:
  if (!v9)
    BOMHardLinkTableFree((const void **)v85);
  if (v20)
    free(v20);
  return v21;
}

uint64_t _copyVariantsFromBomToBom(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int i;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int j;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unsigned int k;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  char v39[1025];
  char v40[100];
  char v41[100];
  char v42[100];
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    v9 = result;
    result = BOMBomVIndexCount(*(_QWORD *)(result + 32), 0, 0, 0, a5, a6, a7, a8);
    v37 = result;
    if ((int)result >= 1)
    {
      v11 = 0;
      v38 = 0;
      do
      {
        BOMBomVIndexGet(*(_QWORD *)(v9 + 32), 0, 0, 0, v11, v42, 0x64uLL, v10);
        result = BOMBomVIndexCount(*(_QWORD *)(v9 + 32), v42, 0, 0, v12, v13, v14, v15);
        if ((int)result >= 1)
        {
          v16 = result;
          for (i = 0; i != v16; ++i)
          {
            BOMBomVIndexGet(*(_QWORD *)(v9 + 32), v42, 0, 0, i, v41, 0x64uLL, v10);
            result = BOMBomVIndexCount(*(_QWORD *)(v9 + 32), v42, (uint64_t)v41, 0, v18, v19, v20, v21);
            if ((int)result >= 1)
            {
              v22 = result;
              for (j = 0; j != v22; ++j)
              {
                BOMBomVIndexGet(*(_QWORD *)(v9 + 32), v42, (uint64_t)v41, 0, j, v40, 0x64uLL, v10);
                v28 = BOMBomVIndexCount(*(_QWORD *)(v9 + 32), v42, (uint64_t)v41, (uint64_t)v40, v24, v25, v26, v27);
                if (v28 >= 1)
                {
                  v32 = v28;
                  for (k = 0; k != v32; ++k)
                  {
                    v34 = BOMBomVIndexGet(*(_QWORD *)(v9 + 32), v42, (uint64_t)v41, (uint64_t)v40, k, v39, 0x64uLL, v31);
                    if (a2
                      && !v34
                      && !BOMBomVIndexSet(*(_QWORD *)(a2 + 32), v42, (uint64_t)v41, (uint64_t)v40, v39, v29, v30, v31))
                    {
                      *(_BYTE *)(a2 + 64) = 1;
                    }
                  }
                }
                result = BOMBomVIndexGetApproxDiskSpace(*(_QWORD *)(a2 + 32), v42, (uint64_t)v41, (uint64_t)v40, &v38, v29, v30, v31);
                if (!(_DWORD)result)
                  result = BOMBomVIndexSetApproxDiskSpace(*(_QWORD *)(a2 + 32), v42, (uint64_t)v41, (uint64_t)v40, v38, v35, v36, v10);
              }
            }
          }
        }
        ++v11;
      }
      while (v11 != v37);
    }
  }
  return result;
}

__CFArray *_patternListForArchAndLangs(uint64_t a1, const char **a2, const char **a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  __CFArray *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  char *ValueAtIndex;
  regex_t *v18;

  v10 = BOMPatternListNew();
  if (!v10)
    return v10;
  if (!a2)
    goto LABEL_5;
  if (a4)
  {
    _addPathsToList(a1, "arch", v10, a2, 1, 1, v8, v9);
    _addPathsToList(a1, "arch", v10, a2, 0, 0, v11, v12);
LABEL_5:
    if (!a3)
      goto LABEL_12;
    if (a4)
    {
      _addPathsToList(a1, "lang", v10, a3, 1, 1, v8, v9);
      v13 = 0;
    }
    else
    {
      v13 = 1;
    }
    goto LABEL_11;
  }
  v13 = 1;
  _addPathsToList(a1, "arch", v10, a2, 1, 0, v8, v9);
  if (a3)
LABEL_11:
    _addPathsToList(a1, "lang", v10, a3, v13, 0, v8, v9);
LABEL_12:
  Count = CFArrayGetCount(v10);
  if (Count >= 1)
  {
    v15 = Count;
    for (i = 0; i != v15; ++i)
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(v10, i);
      v18 = BOMPatternCompileString(ValueAtIndex);
      CFArraySetValueAtIndex(v10, i, v18);
      free(ValueAtIndex);
    }
  }
  return v10;
}

char *BOMBomNewFromDirectory(char *a1, char *a2, uint64_t a3)
{
  return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
}

char *BOMBomNewFromDirectoryWithSys(char *a1, char *a2, uint64_t a3, unsigned int (**a4)(_QWORD, char *, __int128 *))
{
  char *v8;
  const char *v9;
  FILE *v10;
  int *v11;
  const char *v12;
  int *v13;
  FILE *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  uint64_t v17;
  dispatch_queue_global_t global_queue;
  NSObject *v19;
  dispatch_group_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  _QWORD *v34;
  _QWORD *v35;
  char *v36;
  _QWORD *v37;
  int Type;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  _DWORD *v46;
  uint64_t *v47;
  _DWORD *v48;
  _DWORD *v49;
  const char *ActualPath;
  NSObject *v51;
  int Device;
  uint64_t Inode;
  char *Path;
  char *v55;
  const void **v56;
  const void **v57;
  size_t v58;
  FILE *v60;
  const char *v61;
  size_t v62;
  FILE *v63;
  const char *Message;
  uint64_t v65;
  uint64_t v66;
  _DWORD *v67;
  _DWORD *v68;
  void *v69;
  void *v70;
  _QWORD *v71;
  char *v72;
  uint64_t v73;
  _QWORD **v74;
  int v75;
  int v76;
  char *v77;
  unsigned int v78;
  char *Name;
  char *v80;
  char *v81;
  _DWORD *v82;
  void *v83;
  int v84;
  size_t v85;
  size_t v86;
  uint64_t v87;
  FILE *v88;
  int *v89;
  const char *v90;
  int *v91;
  char *v92;
  char *v93;
  char *v94;
  __int128 block;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  int v104;
  _DWORD *v105;
  void *v106;
  char __s[8];
  char *v108;
  uint64_t v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  stat v115;
  void *values;
  void *keys[4];

  keys[1] = *(void **)MEMORY[0x24BDAC8D0];
  v8 = getenv("BOMBomNewFromDirectory_parallel");
  if (v8 && (v9 = v8, strcmp(v8, "1")) && !strcmp(v9, "0"))
  {
    v102 = 0u;
    v103 = 0u;
    v100 = 0u;
    v101 = 0u;
    v98 = 0u;
    v99 = 0u;
    v96 = 0u;
    v97 = 0u;
    block = 0u;
    if (!a4)
      a4 = (unsigned int (**)(_QWORD, char *, __int128 *))BomSys_default();
    if (a4[10](a4[1], a2, &block))
    {
      v10 = (FILE *)*MEMORY[0x24BDAC8D8];
      v13 = __error();
      v92 = a2;
      v94 = strerror(*v13);
      v12 = "can't stat %s (%s)\n";
      goto LABEL_14;
    }
    if ((WORD2(block) & 0xF000) != 0x4000)
      goto LABEL_53;
    a1 = (char *)BOMBomNewWithSys(a1, (uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t))a4);
    if (a1)
    {
      v56 = (const void **)BOMHardLinkTableNew();
      if (v56)
      {
        v57 = v56;
        a4[38](a4[1], (char *)&v115, (__int128 *)1025);
        if (!((unsigned int (*)(unsigned int (*)(_QWORD, char *, __int128 *), char *))a4[39])(a4[1], a2))
        {
          __strlcpy_chk();
          v58 = strlen(__s);
          if (!_visitDir((unsigned int *)a1, __s, &__s[v58], 0, (CFDictionaryRef *)v57, a3))
          {
            BOMHardLinkTableFree(v57);
            ((void (*)(unsigned int (*)(_QWORD, char *, __int128 *), stat *))a4[39])(a4[1], &v115);
            return a1;
          }
        }
      }
      BOMBomFree((uint64_t)a1);
      return 0;
    }
  }
  else
  {
    if (a1)
    {
      if (!a2)
      {
        fwrite("directory_path is NULL\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
        return 0;
      }
      memset(&v115, 0, sizeof(v115));
      if (stat(a2, &v115))
      {
        v10 = (FILE *)*MEMORY[0x24BDAC8D8];
        v11 = __error();
        v92 = a2;
        v94 = strerror(*v11);
        v12 = "Could not stat %s: %s\n";
LABEL_14:
        v14 = v10;
LABEL_54:
        fprintf(v14, v12, v92, v94, block, v96, v97, v98, v99, v100, v101, v102, v103);
        return 0;
      }
      if ((v115.st_mode & 0xF000) == 0x4000)
      {
        *(_QWORD *)__s = 0;
        v108 = __s;
        v109 = 0x6000000000;
        v110 = 0u;
        v111 = 0u;
        v112 = 0u;
        v113 = 0u;
        v114 = 0;
        values = (void *)*MEMORY[0x24BDBD270];
        keys[0] = CFSTR("disableLexicographicSort");
        v15 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (const void **)keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        if (!v15
          || (v16 = v15,
              v17 = BOMCopierSourceNew(a2, v15, 0, 0),
              *((_QWORD *)v108 + 3) = v17,
              CFRelease(v16),
              !*((_QWORD *)v108 + 3)))
        {
          v60 = (FILE *)*MEMORY[0x24BDAC8D8];
          v61 = "Could not create BOMCopierSource\n";
          v62 = 33;
          goto LABEL_58;
        }
        global_queue = dispatch_get_global_queue(0, 0);
        if (!global_queue)
        {
          v60 = (FILE *)*MEMORY[0x24BDAC8D8];
          v61 = "Could not get the global queue\n";
          v62 = 31;
          goto LABEL_58;
        }
        v19 = global_queue;
        v20 = dispatch_group_create();
        *((_QWORD *)v108 + 6) = v20;
        if (!v20)
        {
          v60 = (FILE *)*MEMORY[0x24BDAC8D8];
          v61 = "Could not create dispatch group\n";
          v62 = 32;
          goto LABEL_58;
        }
        *((_QWORD *)v108 + 7) = BOMStackNew();
        v21 = BOMHardLinkTableNew();
        *((_QWORD *)v108 + 9) = v21;
        if (v21)
        {
          v22 = malloc_type_calloc(1uLL, 0x400uLL, 0x488F247BuLL);
          v29 = v108;
          *((_QWORD *)v108 + 10) = v22;
          if (!v22)
          {
            v60 = (FILE *)*MEMORY[0x24BDAC8D8];
            v61 = "Could not create empty hardlink path\n";
            v62 = 37;
            goto LABEL_58;
          }
          v106 = 0;
          v30 = BOMCopierSourceNext(*((_QWORD *)v29 + 3), &v106, v23, v24, v25, v26, v27, v28);
          if (v30)
          {
            v31 = v30;
            v32 = MEMORY[0x24BDAC760];
            v33 = 1;
            while (1)
            {
              v34 = malloc_type_calloc(1uLL, 0x50uLL, 0x1030040C9A1E1CFuLL);
              if (!v34)
              {
                v60 = (FILE *)*MEMORY[0x24BDAC8D8];
                v61 = "Could not allocate entry node\n";
                v62 = 30;
                goto LABEL_58;
              }
              v35 = v34;
              *v34 = v31;
              v36 = v108;
              if (*((_QWORD *)v108 + 4))
              {
                v37 = v108 + 40;
                *(_QWORD *)(*((_QWORD *)v108 + 5) + 72) = v34;
              }
              else
              {
                *((_QWORD *)v108 + 4) = v34;
                v37 = v36 + 40;
              }
              *v37 = v34;
              Type = BOMCopierSourceEntryGetType((uint64_t)v31);
              v45 = v108;
              v46 = (_DWORD *)*((_QWORD *)v108 + 8);
              if (v46)
              {
                *((_DWORD *)v35 + 4) = *v46;
                if (Type == 13)
                {
                  free(v46);
                  v45 = v108;
                  *((_QWORD *)v108 + 8) = 0;
LABEL_32:
                  v47 = BOMStackPop(*((uint64_t **)v45 + 7));
                  *((_QWORD *)v108 + 8) = v47;
                  goto LABEL_41;
                }
                *((_DWORD *)v35 + 5) = v33;
                v48 = (_DWORD *)v35 + 5;
                ++v33;
                if (Type != 6)
                  goto LABEL_40;
                BOMStackPush(*((char **)v45 + 7), (uint64_t)v46);
                *((_QWORD *)v108 + 8) = 0;
              }
              else
              {
                if (Type == 13)
                  goto LABEL_32;
                *((_DWORD *)v35 + 5) = v33;
                v48 = (_DWORD *)v35 + 5;
                ++v33;
                if (Type != 6)
                {
LABEL_40:
                  switch(Type)
                  {
                    case 4:
                    case 10:
                      goto LABEL_41;
                    case 6:
                      goto LABEL_38;
                    case 8:
                      if (BOMCopierSourceEntryGetHardlinkCount(*v35) < 2)
                        goto LABEL_39;
                      Device = BOMCopierSourceEntryGetDevice(*v35);
                      Inode = BOMCopierSourceEntryGetInode(*v35);
                      *((_DWORD *)v35 + 8) = Device;
                      v35[5] = Inode;
                      v105 = 0;
                      if (BOMHardLinkTableGetPathAndData(*((CFDictionaryRef **)v108 + 9), Device, Inode, *((char **)v108 + 10), &v105))
                      {
                        Path = (char *)BOMCopierSourceEntryGetPath((uint64_t)v31);
                        v104 = 1;
                        BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v108 + 9), Device, Inode, Path, &v104, 4uLL);
                        *((_BYTE *)v35 + 24) = 1;
                        *((_DWORD *)v35 + 7) = v104;
                        v32 = MEMORY[0x24BDAC760];
                        goto LABEL_39;
                      }
                      *((_BYTE *)v35 + 25) = 1;
                      v55 = (char *)BOMCopierSourceEntryGetPath((uint64_t)v31);
                      v104 = 0;
                      v104 = *v105 + 1;
                      BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v108 + 9), Device, Inode, v55, &v104, 4uLL);
                      *((_DWORD *)v35 + 7) = v104;
                      v32 = MEMORY[0x24BDAC760];
                      break;
                    default:
                      goto LABEL_39;
                  }
                  goto LABEL_41;
                }
              }
              v49 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
              *((_QWORD *)v108 + 8) = v49;
              if (!v49)
              {
                v88 = (FILE *)*MEMORY[0x24BDAC8D8];
                v91 = __error();
                v93 = strerror(*v91);
                v90 = "Could not create parent element: %s\n";
                goto LABEL_112;
              }
              *v49 = *v48;
LABEL_38:
              ActualPath = (const char *)BOMCopierSourceEntryGetActualPath((uint64_t)v31);
              if (access(ActualPath, 1))
              {
                v88 = (FILE *)*MEMORY[0x24BDAC8D8];
                v89 = __error();
                v93 = (char *)ActualPath;
                v94 = strerror(*v89);
                v90 = "Could not access %s: %s\n";
LABEL_112:
                fprintf(v88, v90, v93, v94);
                goto LABEL_59;
              }
LABEL_39:
              dispatch_group_enter(*((dispatch_group_t *)v108 + 6));
              v51 = *((_QWORD *)v108 + 6);
              *(_QWORD *)&block = v32;
              *((_QWORD *)&block + 1) = 0x40000000;
              *(_QWORD *)&v96 = __BOMBomNewFromDirectory_parallel_block_invoke;
              *((_QWORD *)&v96 + 1) = &unk_24BF06C58;
              LOWORD(v99) = a3;
              *(_QWORD *)&v98 = a4;
              *((_QWORD *)&v98 + 1) = v35;
              *(_QWORD *)&v97 = __s;
              *((_QWORD *)&v97 + 1) = v31;
              dispatch_group_async(v51, v19, &block);
LABEL_41:
              v106 = 0;
              v31 = BOMCopierSourceNext(*((_QWORD *)v108 + 3), &v106, v39, v40, v41, v42, v43, v44);
              if (!v31)
                goto LABEL_68;
            }
          }
          v33 = 1;
LABEL_68:
          if (v106)
          {
            v63 = (FILE *)*MEMORY[0x24BDAC8D8];
            Message = (const char *)BOMCopierErrorGetMessage((uint64_t)v106);
            fprintf(v63, "Could not get next entry: %s\n", Message);
            BOMCopierErrorFree(v106);
            goto LABEL_59;
          }
          dispatch_group_wait(*((dispatch_group_t *)v108 + 6), 0xFFFFFFFFFFFFFFFFLL);
          v65 = *((_QWORD *)v108 + 4);
          while (v65)
          {
            v66 = v65;
            v65 = *(_QWORD *)(v65 + 72);
            if (!*(_QWORD *)(v66 + 8) && *(_BYTE *)(v66 + 52) && *(_QWORD *)(v66 + 56) && *(_QWORD *)(v66 + 64))
            {
              v67 = BOMFSObjectNewFromPathWithSys(*(char **)(v66 + 56), a3, a4);
              if (!v67)
              {
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not make second attempt to create BOMFSObject for %s\n");
                goto LABEL_59;
              }
              v68 = v67;
              BOMFSObjectSetPathName((uint64_t)v67, *(char **)(v66 + 64), 1);
              *(_QWORD *)(v66 + 8) = v68;
              v69 = *(void **)(v66 + 64);
              if (v69)
              {
                free(v69);
                *(_QWORD *)(v66 + 64) = 0;
              }
              v70 = *(void **)(v66 + 56);
              if (v70)
              {
                free(v70);
                *(_QWORD *)(v66 + 56) = 0;
              }
              *(_BYTE *)(v66 + 52) = 0;
            }
          }
          v71 = BOMBomNewWithSys(a1, 0);
          v72 = v108;
          *((_QWORD *)v108 + 11) = v71;
          if (!v71)
          {
            v60 = (FILE *)*MEMORY[0x24BDAC8D8];
            v61 = "Could not create empty bom\n";
            v62 = 27;
            goto LABEL_58;
          }
          v73 = *((_QWORD *)v72 + 4);
          if (v73)
          {
            while (1)
            {
              v74 = (_QWORD **)v73;
              v73 = *(_QWORD *)(v73 + 72);
              if (v74[1] || *((_BYTE *)v74 + 25))
              {
                v75 = BOMCopierSourceEntryGetType((uint64_t)*v74);
                if (v75 != 13)
                {
                  v76 = v75;
                  v77 = (char *)BOMCopierSourceEntryGetPath((uint64_t)*v74);
                  v104 = 0;
                  if (*((_BYTE *)v74 + 25))
                  {
                    v106 = 0;
                    if (BOMHardLinkTableGetPathAndData(*((CFDictionaryRef **)v108 + 9), *((_DWORD *)v74 + 8), (uint64_t)v74[5], *((char **)v108 + 10), &v106))
                    {
                      v60 = (FILE *)*MEMORY[0x24BDAC8D8];
                      v61 = "Could not get entry for hardlink node\n";
                      goto LABEL_64;
                    }
                    v104 = *(_DWORD *)v106;
                  }
                  else
                  {
                    v78 = BOMStorageNewBlock(*(_QWORD *)(*((_QWORD *)v108 + 11) + 8));
                    v104 = v78;
                    if (!v78)
                    {
                      v60 = (FILE *)*MEMORY[0x24BDAC8D8];
                      v61 = "Could not get storage block for fso\n";
                      v62 = 36;
                      goto LABEL_58;
                    }
                    *((_DWORD *)v74 + 12) = v78;
                    if (_BOMBomSetFSObjectWithBlockID(*((_QWORD *)v108 + 11), (uint64_t)v74[1], v78))
                    {
                      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not archive fso for %s\n");
                      goto LABEL_59;
                    }
                    if ((v76 & 0xFFFFFFFE) == 8)
                      _addArchInfoForFSObject(*((_QWORD *)v108 + 11), (uint64_t)v74[1]);
                    if (*((_BYTE *)v74 + 24))
                    {
                      v106 = 0;
                      if (BOMHardLinkTableGetPathAndData(*((CFDictionaryRef **)v108 + 9), *((_DWORD *)v74 + 8), (uint64_t)v74[5], *((char **)v108 + 10), &v106))
                      {
                        v60 = (FILE *)*MEMORY[0x24BDAC8D8];
                        v61 = "Could not lookup count for hardlink origin\n";
                        v62 = 43;
                        goto LABEL_58;
                      }
                      BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v108 + 9), *((_DWORD *)v74 + 8), (uint64_t)v74[5], v77, &v104, 4uLL);
                    }
                  }
                  Name = BOMCopierSourceEntryGetName(*v74);
                  v106 = 0;
                  v80 = BOMNewPathKey(*((_DWORD *)v74 + 4), Name, &v106);
                  if (!v80)
                  {
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not create path key for %u %s\n");
                    goto LABEL_59;
                  }
                  v81 = v80;
                  v105 = 0;
                  v82 = BOMNewPathValue(*((_DWORD *)v74 + 5), v104, &v105);
                  if (!v82)
                  {
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not create path value for %u %u\n", *((_DWORD *)v74 + 5), v104);
                    free(v81);
                    goto LABEL_59;
                  }
                  v83 = v82;
                  v84 = BOMTreeSetValue(*(_QWORD **)(*((_QWORD *)v108 + 11) + 16), v81, (size_t)v106, (uint64_t)v82, (uint64_t)v105);
                  free(v81);
                  free(v83);
                  if (v84)
                  {
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not set path info for %s\n");
                    goto LABEL_59;
                  }
                  if (*((_BYTE *)v74 + 25))
                  {
                    if (*((_DWORD *)v74 + 7) == 2)
                    {
                      v85 = strlen(*((const char **)v108 + 10));
                      BOMBomHLIndexSet(*(_QWORD *)(*((_QWORD *)v108 + 11) + 24), v104, *((const void **)v108 + 10), v85 + 1);
                    }
                    v86 = strlen(v77);
                    BOMBomHLIndexSet(*(_QWORD *)(*((_QWORD *)v108 + 11) + 24), v104, v77, v86 + 1);
                  }
                }
              }
              if (!v73)
              {
                v71 = (_QWORD *)*((_QWORD *)v108 + 11);
                break;
              }
            }
          }
          *(_DWORD *)v71 = v33;
          v87 = (uint64_t)(v108 + 24);
          a1 = (char *)*((_QWORD *)v108 + 11);
          *((_QWORD *)v108 + 11) = 0;
          release_discovery_state(v87);
        }
        else
        {
          v60 = (FILE *)*MEMORY[0x24BDAC8D8];
          v61 = "Could not create empty hardlink table\n";
LABEL_64:
          v62 = 38;
LABEL_58:
          fwrite(v61, v62, 1uLL, v60);
LABEL_59:
          release_discovery_state((uint64_t)(v108 + 24));
          a1 = 0;
        }
        _Block_object_dispose(__s, 8);
        return a1;
      }
LABEL_53:
      v14 = (FILE *)*MEMORY[0x24BDAC8D8];
      v92 = a2;
      v12 = "%s is not a directory\n";
      goto LABEL_54;
    }
    fwrite("bom_path is NULL\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return a1;
}

char *BOMBomNewFromDirectoryWithOptions(char *a1, char *a2, uint64_t a3, char a4)
{
  char *v8;
  rlim_t rlim_max_low;
  rlimit v10;
  size_t v11;
  int rlim_max;
  rlimit v13;
  int v14[2];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v13.rlim_cur = 0;
  v13.rlim_max = 0;
  if ((a4 & 1) == 0)
    return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
  if (getrlimit(8, &v13))
    return 0;
  *(_QWORD *)v14 = 0x1D00000001;
  rlim_max = 0;
  v11 = 4;
  if (sysctl(v14, 2u, &rlim_max, &v11, 0, 0))
    return 0;
  rlim_max_low = rlim_max;
  if (v13.rlim_max < rlim_max)
  {
    rlim_max = v13.rlim_max;
    rlim_max_low = SLODWORD(v13.rlim_max);
  }
  if (v13.rlim_cur >= rlim_max_low)
    goto LABEL_14;
  v10 = v13;
  if (v13.rlim_cur + 2304 < rlim_max_low)
    rlim_max_low = v13.rlim_cur + 2304;
  v10.rlim_cur = rlim_max_low;
  if (setrlimit(8, &v10))
    return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
LABEL_14:
  v8 = BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
  setrlimit(8, &v13);
  return v8;
}

uint64_t _visitDir(unsigned int *a1, const char *a2, char *a3, unsigned int a4, CFDictionaryRef *a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t Sys;
  _DWORD *v14;
  uint64_t v15;
  unsigned int v16;
  char *v18;
  int v19;
  char *v20;
  char *v21;
  _DWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  int v30;
  _DWORD *v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  char *v35;
  _DWORD *v36;
  int v37;
  int v38;
  uint64_t v39;
  CFDictionaryRef *v40;
  char *v41;
  uint64_t v42;
  size_t v43;
  size_t v44;
  size_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  size_t v49;
  unsigned int *v50;
  unsigned int v51;
  int v52[4];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  char __s[1025];
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  *(_OWORD *)v52 = 0u;
  v49 = 0;
  v50 = 0;
  v48 = 0;
  v12 = *a1;
  *a1 = v12 + 1;
  Sys = BOMStorageGetSys(*((_QWORD *)a1 + 1));
  if ((*(unsigned int (**)(_QWORD, const char *, int *))(Sys + 80))(*(_QWORD *)(Sys + 8), ".", v52))
    goto LABEL_46;
  v14 = BOMFSObjectNewFromPathWithSys(".", a6, (unsigned int (**)(_QWORD, char *, __int128 *))Sys);
  if (!v14)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't read %s. skipping...\n");
    return 0;
  }
  v15 = (uint64_t)v14;
  v16 = BOMStorageNewBlock(*((_QWORD *)a1 + 1));
  v51 = v16;
  if (!v16)
    return 1;
  if (_BOMBomSetFSObjectWithBlockID((uint64_t)a1, v15, v16))
  {
LABEL_5:
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't archive %s. skipping...\n", a2);
    return 1;
  }
  BOMFSObjectFree(v15);
  v18 = a3;
  do
  {
    if (v18 <= a2)
      break;
    v19 = *--v18;
  }
  while (v19 != 47);
  if (v18 <= a2)
    v20 = v18;
  else
    v20 = v18 + 1;
  v21 = BOMNewPathKey(a4, v20, &v49);
  v22 = BOMNewPathValue(v12, v51, &v48);
  v23 = BOMTreeSetValue(*((_QWORD **)a1 + 2), v21, v49, (uint64_t)v22, v48);
  free(v21);
  free(v22);
  if (v23)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't set path info for %s. skipping...\n");
    return 0;
  }
  v24 = (*(uint64_t (**)(_QWORD, const char *))(Sys + 272))(*(_QWORD *)(Sys + 8), ".");
  if (!v24)
  {
LABEL_46:
    perror(a2);
    return 1;
  }
  v25 = v24;
  *a3 = 47;
  v26 = a3 + 1;
  v27 = (*(uint64_t (**)(_QWORD, uint64_t))(Sys + 288))(*(_QWORD *)(Sys + 8), v24);
  if (!v27)
  {
LABEL_48:
    (*(void (**)(_QWORD, uint64_t))(Sys + 280))(*(_QWORD *)(Sys + 8), v25);
    return 0;
  }
  v28 = v27;
  v47 = v25;
  while (1)
  {
    if (_ignore_readdir_entry(v28))
      goto LABEL_36;
    v29 = (char *)(v28 + 21);
    strlcpy(v26, (const char *)(v28 + 21), a2 - v26 + 1025);
    if ((*(unsigned int (**)(_QWORD, uint64_t, int *))(Sys + 96))(*(_QWORD *)(Sys + 8), v28 + 21, v52))
      goto LABEL_49;
    v30 = v52[1] & 0xF000;
    if (v30 == 0x4000)
      break;
    v50 = 0;
    if (v30 == 0x8000
      && HIWORD(v52[1]) >= 2u
      && (__s[0] = 0, BOMHardLinkTableGetPathAndData(a5, v52[0], *(uint64_t *)&v52[2], __s, &v50), v50))
    {
      v46 = 0;
      v51 = *v50;
    }
    else
    {
      v31 = BOMFSObjectNewFromPathWithSys((char *)(v28 + 21), a6, (unsigned int (**)(_QWORD, char *, __int128 *))Sys);
      if (!v31)
        goto LABEL_36;
      v32 = (uint64_t)v31;
      v33 = BOMStorageNewBlock(*((_QWORD *)a1 + 1));
      v51 = v33;
      if (!v33)
        goto LABEL_50;
      if (_BOMBomSetFSObjectWithBlockID((uint64_t)a1, v32, v33))
        goto LABEL_5;
      _addArchInfoForFSObject((uint64_t)a1, v32);
      BOMFSObjectFree(v32);
      v46 = 1;
    }
    v34 = (*a1)++;
    v35 = BOMNewPathKey(v12, v29, &v49);
    v36 = BOMNewPathValue(v34, v51, &v48);
    v37 = BOMTreeSetValue(*((_QWORD **)a1 + 2), v35, v49, (uint64_t)v36, v48);
    free(v35);
    free(v36);
    if (v37)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't set path info for %s. skipping...\n", a2);
      v25 = v47;
    }
    else
    {
      v25 = v47;
      if ((v52[1] & 0xF000) != 0x8000 || HIWORD(v52[1]) < 2u)
        goto LABEL_36;
      if (v46)
      {
        v38 = v52[0];
        v39 = *(_QWORD *)&v52[2];
        v40 = a5;
        v41 = (char *)a2;
      }
      else
      {
        v42 = *((_QWORD *)a1 + 3);
        if (!__s[0])
        {
          v45 = strlen(a2);
          BOMBomHLIndexSet(v42, v51, a2, v45 + 1);
          goto LABEL_36;
        }
        v43 = strlen(__s);
        BOMBomHLIndexSet(v42, v51, __s, v43 + 1);
        v44 = strlen(a2) + 1;
        v25 = v47;
        BOMBomHLIndexSet(*((_QWORD *)a1 + 3), v51, a2, v44);
        v38 = v52[0];
        v39 = *(_QWORD *)&v52[2];
        v40 = a5;
        v41 = "";
      }
      BOMHardLinkTableSetPathAndData(v40, v38, v39, v41, &v51, 4uLL);
    }
LABEL_36:
    v28 = (*(uint64_t (**)(_QWORD, uint64_t))(Sys + 288))(*(_QWORD *)(Sys + 8), v25);
    if (!v28)
      goto LABEL_48;
  }
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(Sys + 312))(*(_QWORD *)(Sys + 8), v28 + 21))
  {
    if (_visitDir(a1, a2, &v26[*(unsigned __int16 *)(v28 + 18)], v12, a5, a6))
      goto LABEL_50;
    if (!(*(unsigned int (**)(_QWORD, const char *))(Sys + 312))(*(_QWORD *)(Sys + 8), ".."))
      goto LABEL_36;
  }
LABEL_49:
  perror(a2);
LABEL_50:
  (*(void (**)(_QWORD, uint64_t))(Sys + 280))(*(_QWORD *)(Sys + 8), v25);
  return 1;
}

uint64_t BOMBomCommit(uint64_t a1)
{
  unsigned int NamedBlock;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
    return 1;
  if (!*(_BYTE *)(a1 + 65))
    return 0;
  NamedBlock = BOMStorageGetNamedBlock(*(_QWORD *)(a1 + 8), "BomInfo");
  if (!NamedBlock)
    return 1;
  v3 = 1;
  v4 = BOMStreamWithBlockID(*(_QWORD *)(a1 + 8), NamedBlock, (16 * *(unsigned int *)(a1 + 48)) | 0xC, 1);
  if (v4)
  {
    v5 = v4;
    BOMStreamWriteUInt32(v4, 1u);
    BOMStreamWriteUInt32(v5, *(_DWORD *)a1);
    _writeArchInfo(a1, v5);
    if (!BOMStreamFree(v5))
    {
      v6 = *(_QWORD *)(a1 + 16);
      if (v6)
        BOMTreeCommit(v6);
      v7 = *(_QWORD *)(a1 + 24);
      if (v7)
        BOMBomHLIndexCommit(v7);
      v8 = *(_QWORD *)(a1 + 32);
      if (v8)
        BOMBomVIndexCommit(v8);
      v9 = *(_QWORD *)(a1 + 40);
      if (v9)
        BOMTreeCommit(v9);
      if (!BOMStorageCommit(*(_QWORD *)(a1 + 8)))
      {
        v3 = 0;
        *(_BYTE *)(a1 + 64) = 0;
      }
    }
  }
  return v3;
}

void *BOMBomPathIDForKey(uint64_t a1, unsigned int a2, char *a3)
{
  return BOMBomPathIDAndArchsForKey(a1, a2, a3, 0);
}

void *BOMBomPathIDAndArchsForKey(uint64_t a1, unsigned int a2, char *__s, uint64_t a4)
{
  void *v4;
  unsigned int *Value;
  unsigned int v8;
  unsigned int *FSObjectWithBlockID;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  size_t v15;

  v4 = 0;
  if (a1)
  {
    if (__s)
    {
      v15 = 0;
      v4 = BOMNewPathKey(a2, __s, &v15);
      if (v4)
      {
        Value = (unsigned int *)BOMTreeGetValue(*(_QWORD *)(a1 + 16), v4, v15);
        free(v4);
        if (!Value)
          return 0;
        v4 = BOMPathIDFromPathKey(Value);
        if (!a4)
          return v4;
        v8 = BOMBlockIDFromPathValue((uint64_t)Value);
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v8);
        if (!FSObjectWithBlockID)
          return 0;
        v10 = (uint64_t)FSObjectWithBlockID;
        if (BOMFSObjectType(FSObjectWithBlockID) == 1)
        {
          v11 = BOMFSObjectArchCount(v10);
          if (v11)
          {
            v12 = 0;
            v13 = v11;
            do
            {
              *(_DWORD *)(a4 + 4 * v12) = BOMFSObjectGetArch(v10, v12);
              ++v12;
            }
            while (v13 != v12);
          }
          else
          {
            v13 = 0;
          }
          *(_DWORD *)(a4 + 4 * v13) = 0;
        }
        BOMFSObjectFree(v10);
      }
    }
  }
  return v4;
}

uint64_t BOMBomFSObjectCount(uint64_t result)
{
  if (result)
    return BOMTreeCount(*(_QWORD *)(result + 16));
  return result;
}

char *BOMBomGetRootFSObject(uint64_t a1)
{
  char *v2;
  void *v3;
  unint64_t Value;
  unint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  int v8;
  int v9;
  char *v10;
  char *FSObjectWithBlockID;
  char *v12;
  size_t v14;

  if (!a1)
    return 0;
  v14 = 0;
  v2 = BOMNewPathKey(0, ".", &v14);
  if (!v2)
    return 0;
  v3 = v2;
  Value = BOMTreeGetValue(*(_QWORD *)(a1 + 16), v2, v14);
  v5 = Value;
  if (Value)
  {
    v6 = (unsigned int *)Value;
  }
  else
  {
    v12 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a1 + 16), v3, v14, 0);
    free(v3);
    if (!v12)
      return v12;
    v3 = (void *)BOMTreeIteratorKey((uint64_t)v12);
    v14 = BOMTreeIteratorKeySize((uint64_t)v12);
    v6 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v12);
    BOMTreeIteratorFree(v12);
    v12 = 0;
    if (!v3 || !v14 || !v6)
      return v12;
  }
  v7 = BOMBlockIDFromPathValue((uint64_t)v6);
  v8 = BOMPathIDFromPathKey(v6);
  v9 = BOMPathIDFromPathKey((unsigned int *)v3);
  v10 = (char *)BOMShortNameFromPathKey((uint64_t)v3);
  FSObjectWithBlockID = (char *)_BOMBomGetFSObjectWithBlockID(a1, v7);
  v12 = FSObjectWithBlockID;
  if (FSObjectWithBlockID)
  {
    BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, v10, 1);
    BOMFSObjectSetShortName((uint64_t)v12, v10, 1);
    BOMFSObjectSetPathID((uint64_t)v12, v8);
    BOMFSObjectSetParentPathID((uint64_t)v12, v9);
    BOMFSObjectSetBlockID((uint64_t)v12, v7);
  }
  if (v5)
    free(v3);
  return v12;
}

uint64_t BOMBomGetFSObjectAtPath(uint64_t a1, char *__s)
{
  uint64_t v2;
  size_t v5;
  char *v6;
  char *v7;
  char *v8;
  unsigned int v9;
  int v10;
  char *v11;
  char *v12;
  char *v13;
  unsigned int *Value;
  unsigned int v15;
  _DWORD *FSObjectWithBlockID;
  size_t v18;
  char *__stringp;

  v2 = 0;
  v18 = 0;
  if (a1 && __s)
  {
    v5 = strlen(__s) + 1;
    v6 = (char *)BOM_malloc(v5);
    __stringp = v6;
    if (v6)
    {
      v7 = v6;
      memmove(v6, __s, v5);
      v8 = strsep(&__stringp, "/");
      if (v8)
      {
        v9 = 0;
        while (1)
        {
          v10 = v9;
          v11 = v8;
          v12 = BOMNewPathKey(v9, v8, &v18);
          if (!v12)
            break;
          v13 = v12;
          Value = (unsigned int *)BOMTreeGetValue(*(_QWORD *)(a1 + 16), v12, v18);
          free(v13);
          if (!Value)
            break;
          v9 = BOMPathIDFromPathKey(Value);
          v8 = strsep(&__stringp, "/");
          if (!v8)
          {
            v15 = BOMBlockIDFromPathValue((uint64_t)Value);
            FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v15);
            v2 = (uint64_t)FSObjectWithBlockID;
            if (FSObjectWithBlockID)
            {
              BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, __s, 1);
              BOMFSObjectSetShortName(v2, v11, 1);
              BOMFSObjectSetPathID(v2, v9);
              BOMFSObjectSetParentPathID(v2, v10);
              BOMFSObjectSetBlockID(v2, v15);
            }
            goto LABEL_12;
          }
        }
      }
      v2 = 0;
LABEL_12:
      free(v7);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t BOMBomInsertFSObject(unint64_t a1, unsigned int *a2, int a3)
{
  uint64_t result;
  const char *v7;
  char *v8;
  unsigned int *v9;
  unsigned int v10;
  char *v11;
  unsigned int *v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  char *v19;
  _DWORD *v20;
  int v21;
  _DWORD *FSObjectWithBlockID;
  uint64_t v23;
  size_t v24;
  char *v25;
  int *v26;
  unsigned __int8 __dst;
  uint64_t v28;
  size_t v29;
  char __s[1025];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v28 = 0;
  v29 = 0;
  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    v7 = (const char *)BOMFSObjectPathName((uint64_t)a2);
    __strlcpy_chk();
    v8 = strrchr(__s, 47);
    if (v8)
    {
      *v8 = 0;
      v9 = _valueAtPath(a1);
      if (!v9)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "parent directory %s does not exist\n", __s);
        return 401;
      }
      v10 = BOMPathIDFromPathKey(v9);
    }
    else
    {
      v10 = 0;
    }
    v11 = (char *)BOMFSObjectShortName((uint64_t)a2);
    v12 = _valueAtPath(a1);
    if (v12)
    {
      if (!a3)
        return 0;
      v13 = (uint64_t)v12;
      v14 = BOMPathIDFromPathKey(v12);
      v15 = BOMBlockIDFromPathValue(v13);
      if (BOMStorageCopyFromBlockRange(*(_QWORD *)(a1 + 8), v15, 0, 1uLL, &__dst))
      {
        v25 = BOMExceptionHandlerMessage("BOMBomInsertFSObject failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)", v11, v10, v14, v15);
        v26 = __error();
        _BOMFatalException((uint64_t)v25, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3022, *v26);
      }
      v16 = BOMFSObjectTypeFromRawData(&__dst);
      v17 = BOMFSObjectType(a2);
      if (v17 == 2 && v16 != 2)
        return 402;
      if (v17 != 2 && v16 == 2)
        return 403;
      FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v15);
      if (FSObjectWithBlockID)
      {
        v23 = (uint64_t)FSObjectWithBlockID;
        _removeArchInfoForFSObject(a1, (uint64_t)FSObjectWithBlockID);
        BOMFSObjectFree(v23);
      }
      if (!BOMBomHLIndexCount(*(_QWORD *)(a1 + 24), v15)
        || (v24 = strlen(v7),
            BOMBomHLIndexRemove(*(_QWORD *)(a1 + 24), v15, v7, v24 + 1),
            !BOMBomHLIndexCount(*(_QWORD *)(a1 + 24), v15)))
      {
        v18 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      v14 = (*(_DWORD *)a1)++;
    }
    v15 = BOMStorageNewBlock(*(_QWORD *)(a1 + 8));
    v18 = 1;
LABEL_15:
    if (_BOMBomSetFSObjectWithBlockID(a1, (uint64_t)a2, v15))
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't archive %s\n", v7);
      return 404;
    }
    _addArchInfoForFSObject(a1, (uint64_t)a2);
    if (v18)
    {
      v19 = BOMNewPathKey(v10, v11, &v29);
      v20 = BOMNewPathValue(v14, v15, &v28);
      v21 = BOMTreeSetValue(*(_QWORD **)(a1 + 16), v19, v29, (uint64_t)v20, v28);
      free(v19);
      free(v20);
      if (v21)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't set path info for %s.\n", v7);
        return 405;
      }
    }
    *(_BYTE *)(a1 + 64) = 1;
    BOMBomVIndexInvalidateDiskSpace(*(_QWORD *)(a1 + 32));
    return 0;
  }
  return result;
}

unint64_t _removeArchInfoForFSObject(unint64_t result, uint64_t a2)
{
  unint64_t v2;
  int v4;
  unsigned int i;
  int Arch;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;

  if (*(_DWORD *)(result + 48))
  {
    v2 = result;
    if (*(_QWORD *)(result + 56))
    {
      if (BOMFSObjectIsBinaryObject(a2))
      {
        result = BOMFSObjectArchCount(a2);
        if ((_DWORD)result)
        {
          v4 = result;
          for (i = 0; i != v4; ++i)
          {
            Arch = BOMFSObjectGetArch(a2, i);
            result = BOMFSObjectGetArchSize(a2, i);
            v7 = *(unsigned int *)(v2 + 48);
            if (v7 >= 2)
            {
              v8 = (_QWORD *)(*(_QWORD *)(v2 + 56) + 32);
              v9 = v7 - 1;
              while (*((_DWORD *)v8 - 2) != Arch)
              {
                v8 += 3;
                if (!--v9)
                  goto LABEL_14;
              }
              v10 = *v8 - result;
              if (*v8 < (unint64_t)result)
                v10 = 0;
              *v8 = v10;
            }
LABEL_14:
            ;
          }
        }
      }
      else
      {
        result = BOMFSObjectSize(a2);
        v11 = *(_QWORD *)(v2 + 56);
        v12 = *(_QWORD *)(v11 + 8);
        v13 = v12 >= result;
        v14 = v12 - result;
        if (!v13)
          v14 = 0;
        *(_QWORD *)(v11 + 8) = v14;
      }
    }
  }
  return result;
}

uint64_t _BOMBomSetFSObjectWithBlockID(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v7;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  int64_t v11;
  unint64_t v13;
  unsigned int v14;

  v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    v7 = BOMStorageSizeOfBlock(*(_QWORD *)(a1 + 8), a3);
    v8 = BOMFSObjectArchiveLength(a2);
    if (v8 < 1)
    {
      return 0;
    }
    else
    {
      v9 = BOMStreamWithBlockID(*(_QWORD *)(a1 + 8), a3, v8, 1);
      v10 = v9;
      if (v9 && !BOMFSObjectArchive(v9, a2))
        v3 = 0;
      BOMStreamFree(v10);
      if (*(_QWORD *)(a1 + 40))
      {
        v14 = bswap32(a3);
        v11 = BOMFSObjectSize(a2);
        if (v11 < 0x100000000)
        {
          if (v7)
            BOMTreeRemoveValue(*(_QWORD *)(a1 + 40), &v14, 4uLL);
        }
        else
        {
          v13 = bswap64(v11);
          BOMTreeSetValue(*(_QWORD **)(a1 + 40), &v14, 4uLL, (uint64_t)&v13, 8);
        }
      }
    }
  }
  return v3;
}

uint64_t _addArchInfoForFSObject(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  unsigned int i;
  int Arch;
  unsigned int ArchSize;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unsigned int v12;
  _DWORD *v13;

  if (!*(_DWORD *)(a1 + 48) || !*(_QWORD *)(a1 + 56))
  {
    *(_DWORD *)(a1 + 48) = 1;
    result = (uint64_t)BOM_malloczero(0x18uLL);
    *(_QWORD *)(a1 + 56) = result;
    if (!result)
      return result;
    *(_DWORD *)result = 0;
  }
  if (BOMFSObjectIsBinaryObject(a2))
  {
    result = BOMFSObjectArchCount(a2);
    if ((_DWORD)result)
    {
      v5 = result;
      for (i = 0; i != v5; ++i)
      {
        Arch = BOMFSObjectGetArch(a2, i);
        ArchSize = BOMFSObjectGetArchSize(a2, i);
        v9 = *(unsigned int *)(a1 + 48);
        result = *(_QWORD *)(a1 + 56);
        if (v9 < 2)
        {
LABEL_12:
          result = (uint64_t)BOM_realloczero((void *)result, 24 * v9, 24 * (v9 + 1));
          *(_QWORD *)(a1 + 56) = result;
          if (!result)
            return result;
          v12 = *(_DWORD *)(a1 + 48);
          *(_DWORD *)(a1 + 48) = v12 + 1;
          v13 = (_DWORD *)(result + 24 * v12);
          *v13 = Arch;
          v10 = v13 + 2;
        }
        else
        {
          v10 = (_QWORD *)(result + 32);
          v11 = v9 - 1;
          while (*((_DWORD *)v10 - 2) != Arch)
          {
            v10 += 3;
            if (!--v11)
              goto LABEL_12;
          }
        }
        *v10 += ArchSize;
      }
    }
  }
  else
  {
    result = BOMFSObjectSize(a2);
    *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) += result;
  }
  return result;
}

uint64_t BOMBomRemoveFSObject(unint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  char *v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  unsigned int v8;
  const char *v9;
  size_t v10;
  unsigned int v11;
  char *v12;
  char *v13;
  char *v14;
  size_t v16;

  v2 = 0;
  if (a1 && a2)
  {
    v16 = 0;
    v4 = BOMBomEnumeratorNewWithOptions(a1, a2, 2);
    v5 = BOMBomEnumeratorNext((uint64_t)v4);
    if (v5)
    {
      v6 = v5;
      v7 = 1;
      while (1)
      {
        v8 = BOMFSObjectBlockID((uint64_t)v6);
        if (!v8)
        {
          v8 = _BOMBlockIDForFSObject(a1, (uint64_t)v6);
          if (!v8)
            break;
        }
        if (BOMFSObjectGetHardlinkCount(a1, (uint64_t)v6))
        {
          v9 = (const char *)BOMFSObjectPathName((uint64_t)v6);
          v10 = strlen(v9);
          BOMBomHLIndexRemove(*(_QWORD *)(a1 + 24), v8, v9, v10 + 1);
        }
        v11 = BOMFSObjectParentPathID((uint64_t)v6);
        v12 = (char *)BOMFSObjectShortName((uint64_t)v6);
        v13 = BOMNewPathKey(v11, v12, &v16);
        if (!v13)
          break;
        v14 = v13;
        if (BOMTreeRemoveValue(*(_QWORD *)(a1 + 16), v13, v16))
        {
          free(v14);
          break;
        }
        if (!BOMBomHLIndexCount(*(_QWORD *)(a1 + 24), v8))
          BOMStorageFreeBlock(*(_QWORD *)(a1 + 8), v8);
        _removeArchInfoForFSObject(a1, (uint64_t)v6);
        *(_BYTE *)(a1 + 64) = 1;
        BOMBomVIndexInvalidateDiskSpace(*(_QWORD *)(a1 + 32));
        BOMFSObjectFree((uint64_t)v6);
        free(v14);
        v6 = BOMBomEnumeratorNext((uint64_t)v4);
        v7 = 0;
        v2 = 0;
        if (!v6)
          goto LABEL_18;
      }
      v2 = v7;
    }
    else
    {
      v2 = 1;
    }
LABEL_18:
    BOMBomEnumeratorFree(v4);
  }
  return v2;
}

unsigned int *_BOMBlockIDForFSObject(uint64_t a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  size_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  unsigned int v10;
  char *v11;
  char *v12;
  unsigned int *Value;
  size_t v15;
  char *__stringp;

  v3 = (const char *)BOMFSObjectPathName(a2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = strlen(v3) + 1;
  v6 = (char *)BOM_malloc(v5);
  __stringp = v6;
  if (!v6)
    return 0;
  v7 = v6;
  v15 = 0;
  memmove(v6, v4, v5);
  v8 = strsep(&__stringp, "/");
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    while (1)
    {
      v11 = BOMNewPathKey(v10, v9, &v15);
      if (!v11)
        break;
      v12 = v11;
      Value = (unsigned int *)BOMTreeGetValue(*(_QWORD *)(a1 + 16), v11, v15);
      free(v12);
      if (Value)
      {
        v10 = BOMPathIDFromPathKey(Value);
        Value = (unsigned int *)BOMBlockIDFromPathValue((uint64_t)Value);
        v9 = strsep(&__stringp, "/");
        if (v9)
          continue;
      }
      goto LABEL_11;
    }
  }
  Value = 0;
LABEL_11:
  free(v7);
  return Value;
}

BOOL BOMFSObjectIsHardlink(uint64_t a1, uint64_t a2)
{
  return BOMFSObjectGetHardlinkCount(a1, a2) != 0;
}

uint64_t BOMBomMergeInto(uint64_t *a1, uint64_t a2)
{
  return BOMBomMergeIntoBomWithPatternList(a1, a2, 0);
}

uint64_t BOMBomMergeIntoBomWithPatternList(uint64_t *a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v3;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char __s[1025];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  __s[0] = 0;
  v3 = 1;
  if (a1 && a2)
  {
    if (a1 == (uint64_t *)a2)
    {
      v3 = 1;
      fwrite("boms are identical.\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
    else
    {
      v7 = strlen(__s);
      _copyFilesFromBomToBom(a1, (unsigned int *)a2, a3, __s, &__s[v7], 0, 0, 0, 1);
      _copyVariantsFromBomToBom((uint64_t)a1, a2, v8, v9, v10, v11, v12, v13);
      BOMBomVIndexInvalidateDiskSpace(*(_QWORD *)(a2 + 32));
      return 0;
    }
  }
  return v3;
}

uint64_t BOMBomMergeIntoBom(uint64_t *a1, uint64_t a2)
{
  return BOMBomMergeIntoBomWithPatternList(a1, a2, 0);
}

uint64_t BOMBomMaskWithBom(unint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v4[1025];
  char v5[1025];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  result = 1;
  if (a1)
  {
    if (a2)
    {
      v5[0] = 0;
      v4[0] = 0;
      _maskWithBom(a1, v5, v5, 0, a2, v4, v4, 0);
      BOMBomVIndexInvalidateDiskSpace(*(_QWORD *)(a1 + 32));
      return 0;
    }
  }
  return result;
}

BOOL _maskWithBom(unint64_t a1, char *a2, char *a3, unsigned int a4, uint64_t a5, char *a6, char *a7, unsigned int a8)
{
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  int v24;
  _BOOL8 v25;
  char *v26;
  char *v27;
  const char *v28;
  unsigned int *v29;
  const char *v30;
  size_t v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int v35;
  int v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int *v40;
  char *v42;
  int *v43;
  char *__s2;
  uint64_t v45;
  char *v46;
  int v47;
  unsigned int *v48;
  char *__dst;
  uint64_t v50;
  unsigned int v51;
  int v52;
  unsigned __int8 v53;
  size_t v54;

  v54 = 0;
  v16 = BOMNewPathKey(a4, "", &v54);
  if (v16)
  {
    v17 = v16;
    v18 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a1 + 16), v16, v54, 0);
    free(v17);
    if (v18)
    {
      v19 = BOMNewPathKey(a8, "", &v54);
      if (!v19
        || (v20 = v19, v50 = a5, v21 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a5 + 16), v19, v54, 0), free(v20), !v21))
      {
        v25 = 0;
        v21 = v18;
LABEL_39:
        BOMTreeIteratorFree(v21);
        return v25;
      }
      v22 = a2;
      if (a2 != a3)
      {
        *a3 = 47;
        v22 = a3 + 1;
      }
      __dst = v22;
      v23 = a6;
      if (a6 != a7)
      {
        *a7 = 47;
        v23 = a7 + 1;
      }
      if (BOMTreeIteratorIsAtEnd((uint64_t)v18))
      {
        v24 = 0;
LABEL_38:
        v25 = v24 == 0;
        BOMTreeIteratorFree(v18);
        goto LABEL_39;
      }
      v26 = v23;
      v24 = 0;
      v47 = 0;
      v27 = a6;
      v28 = 0;
      v46 = v26;
      __s2 = v27;
      v45 = v27 - v26 + 1025;
      while (2)
      {
        if (BOMTreeIteratorIsAtEnd((uint64_t)v21)
          || (v29 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v18), BOMPathIDFromPathKey(v29) != a4))
        {
LABEL_36:
          if (v47)
            *(_BYTE *)(a1 + 64) = 1;
          goto LABEL_38;
        }
        v52 = v24;
        v30 = (const char *)BOMShortNameFromPathKey((uint64_t)v29);
        v31 = strlen(v30);
        v32 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v18);
        v48 = BOMPathIDFromPathKey(v32);
        v33 = BOMBlockIDFromPathValue((uint64_t)v32);
        if (BOMStorageCopyFromBlockRange(*(_QWORD *)(a1 + 8), v33, 0, 1uLL, &v53))
        {
          v42 = BOMExceptionHandlerMessage("_maskWithBom failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)", v30, a4, (_DWORD)v48, v33);
          v43 = __error();
          _BOMFatalException((uint64_t)v42, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3363, *v43);
        }
        v51 = BOMFSObjectTypeFromRawData(&v53);
        while (1)
        {
          if (BOMTreeIteratorIsAtEnd((uint64_t)v21))
          {
            v35 = 0;
            goto LABEL_23;
          }
          v34 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v21);
          if (BOMPathIDFromPathKey(v34) != a8)
            goto LABEL_35;
          v28 = (const char *)BOMShortNameFromPathKey((uint64_t)v34);
          if ((strcmp(v28, v30) & 0x80000000) == 0)
            break;
          BOMTreeIteratorNext((uint64_t)v21);
        }
        v37 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v21);
        v35 = BOMPathIDFromPathKey(v37);
LABEL_23:
        if (BOMTreeIteratorIsAtEnd((uint64_t)v21))
        {
LABEL_35:
          v24 = v52 + 1;
          goto LABEL_36;
        }
        if (!v28 || strcmp(v28, v30))
          goto LABEL_26;
        strlcpy(__dst, v30, a2 - __dst + 1025);
        strlcpy(v46, v28, v45);
        if (v51 == 2)
        {
          v36 = _maskWithBom(a1, a2, &__dst[v31], v48, v50, __s2, &v46[v31], v35);
          __dst[v31] = 0;
          if (!v36)
            goto LABEL_26;
        }
        else if (strcmp(a2, __s2))
        {
LABEL_26:
          v24 = v52 + 1;
          goto LABEL_27;
        }
        v38 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v18);
        v39 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v18);
        v40 = (unsigned int *)_BOMGetFSObject(a1, v38, v39, a2);
        BOMBomRemoveFSObject(a1, v40);
        BOMFSObjectFree((uint64_t)v40);
        v47 = 1;
        v24 = v52;
LABEL_27:
        BOMTreeIteratorNext((uint64_t)v18);
        if (!BOMTreeIteratorIsAtEnd((uint64_t)v18))
          continue;
        goto LABEL_36;
      }
    }
  }
  return 0;
}

CFIndex BOMBomMaskWithPatternList(unint64_t a1, CFArrayRef theArray)
{
  CFIndex result;
  char v5[1025];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  result = 1;
  if (a1 && theArray)
  {
    result = CFArrayGetCount(theArray);
    if (result)
    {
      v5[0] = 0;
      _maskWithPatternList(a1, theArray, v5, v5, 0);
      BOMBomVIndexInvalidateDiskSpace(*(_QWORD *)(a1 + 32));
      return 0;
    }
  }
  return result;
}

char *_maskWithPatternList(unint64_t a1, const __CFArray *a2, char *a3, char *a4, unsigned int a5)
{
  char *result;
  char *v10;
  char *v11;
  int v12;
  unsigned int v13;
  unsigned int *v14;
  const char *v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  size_t v20;
  CFIndex Count;
  CFIndex v22;
  CFIndex v23;
  regex_t *ValueAtIndex;
  unsigned int *v25;
  unsigned int *v26;
  unsigned int *v27;
  int v28;
  char *v29;
  int *v30;
  int v31;
  char *__dst;
  unsigned __int8 v34;
  size_t v35;

  v35 = 0;
  result = BOMNewPathKey(a5, "", &v35);
  if (!result)
    return result;
  v10 = result;
  v11 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a1 + 16), result, v35, 0);
  free(v10);
  if (!v11)
    return 0;
  __dst = a3;
  if (a3 != a4)
  {
    *a4 = 47;
    __dst = a4 + 1;
  }
  if (BOMTreeIteratorIsAtEnd((uint64_t)v11))
  {
    BOMTreeIteratorFree(v11);
    v12 = 0;
    v13 = 0;
    goto LABEL_23;
  }
  v12 = 0;
  v31 = 0;
  do
  {
    v14 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v11);
    if (BOMPathIDFromPathKey(v14) != a5)
      break;
    v15 = (const char *)BOMShortNameFromPathKey((uint64_t)v14);
    v16 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v11);
    v17 = BOMPathIDFromPathKey(v16);
    v18 = BOMBlockIDFromPathValue((uint64_t)v16);
    if (BOMStorageCopyFromBlockRange(*(_QWORD *)(a1 + 8), v18, 0, 1uLL, &v34))
    {
      v29 = BOMExceptionHandlerMessage("_maskWithPatternList failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)", v15, a5, (_DWORD)v17, v18);
      v30 = __error();
      _BOMFatalException((uint64_t)v29, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3252, *v30);
    }
    v19 = BOMFSObjectTypeFromRawData(&v34);
    strlcpy(__dst, v15, a3 - __dst + 1025);
    v20 = strlen(v15);
    Count = CFArrayGetCount(a2);
    if (Count < 1)
    {
LABEL_16:
      if (v19 != 2 || !_maskWithPatternList(a1, a2, a3, &__dst[v20], v17))
      {
        v28 = 1;
        goto LABEL_20;
      }
    }
    else
    {
      v22 = Count;
      v23 = 0;
      while (1)
      {
        ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(a2, v23);
        if (ValueAtIndex)
        {
          if (BOMPatternMatch(ValueAtIndex, a3))
            break;
        }
        if (v22 == ++v23)
          goto LABEL_16;
      }
    }
    v25 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v11);
    v26 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v11);
    v27 = (unsigned int *)_BOMGetFSObject(a1, v25, v26, a3);
    BOMBomRemoveFSObject(a1, v27);
    BOMFSObjectFree((uint64_t)v27);
    v28 = 0;
    v31 = 1;
LABEL_20:
    v12 += v28;
    BOMTreeIteratorNext((uint64_t)v11);
  }
  while (!BOMTreeIteratorIsAtEnd((uint64_t)v11));
  BOMTreeIteratorFree(v11);
  v13 = v31;
  if (v31)
  {
    v13 = 1;
    *(_BYTE *)(a1 + 64) = 1;
  }
LABEL_23:
  if (v12)
    return 0;
  else
    return (char *)v13;
}

CFDictionaryRef *BOMBomApproximateBytesRepresentedWithBlockSize(CFDictionaryRef *a1, unsigned int a2)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, a2);
}

CFDictionaryRef *BOMBomApproximateBytesRepresentedWithBlockSize64(CFDictionaryRef *result, unsigned int a2)
{
  uint64_t v3;
  const void **v4;
  uint64_t v5;
  char v6[1025];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5 = 0;
  if (result)
  {
    v3 = (uint64_t)result;
    result = (CFDictionaryRef *)BOMHardLinkTableNew();
    if (result)
    {
      v4 = (const void **)result;
      v6[0] = 0;
      _sizeBom(v3, result, v6, v6, 0, a2, &v5);
      BOMHardLinkTableFree(v4);
      return (CFDictionaryRef *)v5;
    }
  }
  return result;
}

void _sizeBom(uint64_t a1, CFDictionaryRef *a2, char *a3, char *a4, unsigned int a5, unsigned int a6, _QWORD *a7)
{
  char *v14;
  char *v15;
  char *v16;
  unsigned int *v17;
  const char *v18;
  size_t v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int *FSObjectWithBlockID;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _QWORD *v28;
  char *__dst;
  UInt8 bytes[4];
  size_t v31;

  v31 = 0;
  *(_DWORD *)bytes = 0;
  v14 = BOMNewPathKey(a5, "", &v31);
  if (v14)
  {
    v15 = v14;
    v16 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a1 + 16), v14, v31, 0);
    free(v15);
    if (v16)
    {
      v27 = a6;
      v28 = a7;
      __dst = a3;
      if (a3 != a4)
      {
        *a4 = 47;
        __dst = a4 + 1;
      }
      while (!BOMTreeIteratorIsAtEnd((uint64_t)v16))
      {
        v17 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v16);
        if (BOMPathIDFromPathKey(v17) != a5)
          break;
        v18 = (const char *)BOMShortNameFromPathKey((uint64_t)v17);
        v19 = strlen(v18);
        v20 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v16);
        v21 = BOMPathIDFromPathKey(v20);
        *(_DWORD *)bytes = BOMBlockIDFromPathValue((uint64_t)v20);
        if (!BOMHardLinkTableGet(a2, 0, *(unsigned int *)bytes))
        {
          BOMHardLinkTableSet(a2, 0, *(unsigned int *)bytes, bytes, 4);
          FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, *(unsigned int *)bytes);
          v23 = BOMFSObjectType(FSObjectWithBlockID);
          if (v23 != 4)
          {
            v24 = v23;
            strlcpy(__dst, v18, a3 - __dst + 1025);
            if (v24 == 2)
              _sizeBom(a1, a2, a3, &__dst[v19], v21, v27, v28);
            v25 = BOMFSObjectSize((uint64_t)FSObjectWithBlockID);
            if (v25 % v27)
              v26 = v27 - v25 % v27;
            else
              v26 = 0;
            *v28 += v25 + v26;
            BOMFSObjectFree((uint64_t)FSObjectWithBlockID);
          }
        }
        BOMTreeIteratorNext((uint64_t)v16);
      }
      BOMTreeIteratorFree(v16);
    }
  }
}

CFDictionaryRef *BOMBomApproximateBytesRepresented(CFDictionaryRef *a1)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, 0x200u);
}

CFDictionaryRef *BOMBomApproximateBytesRepresented64(CFDictionaryRef *a1)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, 0x200u);
}

uint64_t BOMFSObjectGetHardlinkCount(uint64_t a1, uint64_t a2)
{
  unsigned int v4;

  if (a1 && a2 && ((v4 = BOMFSObjectBlockID(a2)) != 0 || (v4 = _BOMBlockIDForFSObject(a1, a2)) != 0))
    return BOMBomHLIndexCount(*(_QWORD *)(a1 + 24), v4);
  else
    return 0;
}

uint64_t BOMFSObjectGetHardlinkPath(uint64_t a1, uint64_t a2, unsigned int a3, char *a4)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v9;
  size_t v10;
  char __source[1024];
  uint64_t v12;

  result = 0;
  v12 = *MEMORY[0x24BDAC8D0];
  if (a1 && a4)
  {
    v7 = *(_QWORD *)(a1 + 24);
    if (v7)
    {
      result = BOMFSObjectBlockID(a2);
      if (!(_DWORD)result)
        return result;
      v9 = result;
      if (BOMBomHLIndexCount(v7, result) > a3)
      {
        v10 = 0;
        if (!BOMBomHLIndexGet(v7, v9, a3, __source, &v10))
        {
          strlcpy(a4, __source, 0x400uLL);
          return 1;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t BOMBomLinkToPathFromPath(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t FSObjectAtPath;

  FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, a2);
  return BOMBomLinkToFSObjectFromPath(a1, FSObjectAtPath, a3);
}

uint64_t BOMBomLinkToFSObjectFromPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t FSObjectAtPath;
  char *v10;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  char *v14;
  unsigned int v16;
  unsigned int v17;
  char *v18;
  _DWORD *v19;
  int v20;
  size_t v21;
  const char *v22;
  size_t v23;
  uint64_t v24;
  size_t v25;
  char __s[1024];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v3 = 1;
  if (!a2 || !a1 || !a3)
    return v3;
  v5 = (unsigned int *)a2;
  v24 = 0;
  v25 = 0;
  v6 = BOMFSObjectBlockID(a2);
  v7 = v6;
  if (v6)
  {
    v8 = v6;
LABEL_6:
    if (BOMFSObjectType(v5) != 1 || _valueAtPath(a1))
    {
      FSObjectAtPath = 0;
      goto LABEL_9;
    }
    __strlcpy_chk();
    v13 = strrchr(__s, 47);
    v14 = v13;
    if (v13)
    {
      *v13 = 0;
      FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, __s);
      *v14++ = 47;
      if (!FSObjectAtPath)
      {
LABEL_9:
        v3 = 1;
        if (v7)
          goto LABEL_10;
        goto LABEL_19;
      }
    }
    else
    {
      FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, __s);
      if (!FSObjectAtPath)
        goto LABEL_9;
    }
    v16 = BOMFSObjectPathID(FSObjectAtPath);
    v17 = (*(_DWORD *)a1)++;
    v18 = BOMNewPathKey(v16, v14, &v25);
    v19 = BOMNewPathValue(v17, v8, &v24);
    v20 = BOMTreeSetValue(*(_QWORD **)(a1 + 16), v18, v25, (uint64_t)v19, v24);
    free(v18);
    free(v19);
    if (!v20)
    {
      v21 = strlen(__s);
      BOMBomHLIndexSet(*(_QWORD *)(a1 + 24), v8, __s, v21 + 1);
      v22 = (const char *)BOMFSObjectPathName((uint64_t)v5);
      v23 = strlen(v22);
      BOMBomHLIndexSet(*(_QWORD *)(a1 + 24), v8, v22, v23 + 1);
      v3 = 0;
      if (v7)
      {
LABEL_10:
        if (!FSObjectAtPath)
          return v3;
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    goto LABEL_9;
  }
  v10 = (char *)BOMFSObjectPathName((uint64_t)v5);
  v11 = BOMBomGetFSObjectAtPath(a1, v10);
  if (!v11)
    return v3;
  v5 = (unsigned int *)v11;
  v12 = BOMFSObjectBlockID(v11);
  if (v12)
  {
    v8 = v12;
    goto LABEL_6;
  }
  FSObjectAtPath = 0;
LABEL_19:
  BOMFSObjectFree((uint64_t)v5);
  if (FSObjectAtPath)
LABEL_20:
    BOMFSObjectFree(FSObjectAtPath);
  return v3;
}

uint64_t BOMBomDumpLinks(uint64_t result)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int i;
  size_t v7;
  char v8[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    if (v1)
    {
      result = BOMBomHLIndexCount(*(_QWORD *)(result + 24), 0);
      if ((_DWORD)result)
      {
        v2 = result;
        v3 = 0;
        v7 = 0;
        do
        {
          result = BOMBomHLIndexBlock(v1, v3);
          if ((_DWORD)result)
          {
            v4 = result;
            v5 = BOMBomHLIndexCount(v1, result);
            result = printf("hardlink group #%d: (%d links)\n", v4, v5);
            if (v5)
            {
              for (i = 0; i != v5; ++i)
              {
                result = BOMBomHLIndexGet(v1, v4, i, v8, &v7);
                if (!(_DWORD)result)
                  result = printf("    %s\n", v8);
              }
            }
          }
          ++v3;
        }
        while (v3 != v2);
      }
    }
  }
  return result;
}

uint64_t BOMBomVariantAdd(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = 1;
  if (a1 && a2 && a3 && a4 && a5)
  {
    result = BOMBomVIndexSet(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      *(_BYTE *)(a1 + 64) = 1;
  }
  return result;
}

uint64_t BOMBomVariantGetList(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, CFMutableArrayRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2 && a3 && a4)
    return BOMBomVIndexGetList(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  else
    return 1;
}

uint64_t BOMBomVariantCount(uint64_t result, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
    return BOMBomVIndexCount(*(_QWORD *)(result + 32), a2, a3, a4, a5, a6, a7, a8);
  return result;
}

uint64_t BOMBomVariantGet(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, uint64_t a7, uint64_t a8)
{
  if (a1)
    return BOMBomVIndexGet(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, 0x64uLL, a8);
  else
    return 1;
}

uint64_t BOMBomVariantRemove(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
    return BOMBomVIndexRemove(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  else
    return 1;
}

uint64_t BOMBomApproximateBytesRepresentedByVariantWithBlockSize(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, unsigned int *a5, unsigned int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFMutableDictionaryRef Mutable;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  char *v20;
  int *v21;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __CFArray *v44;
  CFIndex Count;
  const void **v46;
  _QWORD *v47;
  _DWORD *v48;
  _DWORD *v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const __CFDictionary *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const void *v66;
  const __CFDictionary *v67;
  uint64_t v68;
  unsigned int *v69;
  char *v70;
  uint64_t v71;
  int v72;
  char *v73;
  const __CFDictionary *theDict;
  CFTypeRef cf;
  void *value;
  char v77[100];
  char v78[100];
  char v79[100];
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (!BOMBomVIndexDiskSpaceInfoIsValid(a1[4]))
  {
    value = 0;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0, 0);
    if (Mutable)
    {
      theDict = Mutable;
      v70 = a2;
      v17 = BOMBomVIndexCount(a1[4], 0, 0, 0, v16, v12, v13, v14);
      v19 = v17;
      v71 = a3;
      if (v17 < 101)
      {
        if (v17 < 1)
        {
LABEL_19:
          v68 = a4;
          v69 = a5;
          Count = CFDictionaryGetCount(theDict);
          v46 = (const void **)BOM_malloczero(8 * Count + 8);
          CFDictionaryGetKeysAndValues(theDict, v46, 0);
          v47 = BOM_malloczero(8 * Count + 8);
          v73 = BOMBomEnumeratorNew((uint64_t)a1, 0);
          v48 = BOMBomEnumeratorNext((uint64_t)v73);
          if (v48)
          {
            v49 = v48;
            v50 = a6;
            do
            {
              v51 = (const char *)BOMFSObjectPathName((uint64_t)v49);
              v52 = BOMFSObjectSize((uint64_t)v49);
              if (v52 % v50)
                v53 = v50 - v52 % v50;
              else
                v53 = 0;
              v54 = v53 + v52;
              if (Count < 1)
                goto LABEL_33;
              v55 = 0;
              v56 = 1;
              do
              {
                while (BOMPatternListMatch((const __CFArray *)v46[v55], v51))
                {
                  v56 = 0;
                  v47[v55] += v54;
                  if (Count - 1 == v55++)
                    goto LABEL_34;
                }
                ++v55;
              }
              while (Count != v55);
              if ((v56 & 1) != 0)
LABEL_33:
                v47[Count] += v54;
LABEL_34:
              BOMFSObjectFree((uint64_t)v49);
              v49 = BOMBomEnumeratorNext((uint64_t)v73);
            }
            while (v49);
          }
          BOMBomEnumeratorFree(v73);
          if (Count < 1)
          {
            BOMBomVIndexSetApproxDiskSpace(a1[4], 0, 0, 0, v47[Count], v58, v59, v60);
            free(v47);
            a4 = v68;
            a5 = v69;
            v62 = theDict;
          }
          else
          {
            v61 = 0;
            a4 = v68;
            a5 = v69;
            v62 = theDict;
            do
            {
              value = (void *)CFDictionaryGetValue(theDict, v46[v61]);
              BOMBomVIndexSetApproxDiskSpaceWithKey(a1[4], (char *)value, v47[v61++]);
            }
            while (Count != v61);
            BOMBomVIndexSetApproxDiskSpace(a1[4], 0, 0, 0, v47[Count], v63, v64, v65);
            free(v47);
            do
            {
              value = (void *)CFDictionaryGetValue(theDict, *v46);
              free(value);
              v66 = *v46++;
              CFRelease(v66);
              --Count;
            }
            while (Count);
          }
          v67 = v62;
LABEL_44:
          CFRelease(v67);
          a2 = v70;
          a3 = v71;
          return BOMBomVIndexGetApproxDiskSpace(a1[4], a2, a3, a4, a5, v12, v13, v14);
        }
      }
      else
      {
        v20 = BOMExceptionHandlerMessage("_computeVariantSizes(bom=%p, blockSize=%u): catcnt(%d) > catmax(%d)!", a1, a6, v17, 100);
        v21 = __error();
        _BOMExceptionHandlerCall((uint64_t)v20, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3818, *v21);
      }
      v23 = 0;
      v72 = v19;
      while (1)
      {
        BOMBomVIndexGet(a1[4], 0, 0, 0, v23, v79, 0x64uLL, v18);
        v28 = BOMBomVIndexCount(a1[4], v79, 0, 0, v24, v25, v26, v27);
        if (v28 >= 1)
          break;
LABEL_18:
        if (++v23 == v72)
          goto LABEL_19;
      }
      v29 = v28;
      v30 = 0;
      while (1)
      {
        BOMBomVIndexGet(a1[4], v79, 0, 0, v30, v78, 0x64uLL, v18);
        v35 = BOMBomVIndexCount(a1[4], v79, (uint64_t)v78, 0, v31, v32, v33, v34);
        if (v35 >= 1)
          break;
LABEL_17:
        if (++v30 == v29)
          goto LABEL_18;
      }
      v36 = v35;
      v37 = 0;
      while (1)
      {
        cf = 0;
        BOMBomVIndexGet(a1[4], v79, (uint64_t)v78, 0, v37, v77, 0x64uLL, v18);
        if (BOMBomVIndexDiskSpaceKey(a1[4], v79, (uint64_t)v78, (uint64_t)v77, &value, v38, v39, v40))
          break;
        if (BOMBomVIndexGetList(a1[4], v79, (uint64_t)v78, (uint64_t)v77, (CFMutableArrayRef *)&cf, v41, v42, v43))break;
        v44 = BOMPatternListFromStringList(cf);
        CFRelease(cf);
        if (!v44)
          break;
        CFDictionarySetValue(theDict, v44, value);
        if (v36 == ++v37)
          goto LABEL_17;
      }
      v67 = theDict;
      goto LABEL_44;
    }
  }
  return BOMBomVIndexGetApproxDiskSpace(a1[4], a2, a3, a4, a5, v12, v13, v14);
}

uint64_t BOMBomApproximateBytesRepresentedByVariantWithBlockSize64(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, _QWORD *a5, unsigned int a6)
{
  uint64_t result;
  unsigned int v8;

  v8 = 0;
  result = BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, &v8, a6);
  *a5 = v8;
  return result;
}

uint64_t BOMBomApproximateBytesRepresentedByVariant(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  return BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, a5, 0x200u);
}

uint64_t BOMBomApproximateBytesRepresentedByVariant64(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t result;
  unsigned int v7;

  v7 = 0;
  result = BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, &v7, 0x200u);
  if (!(_DWORD)result)
    *a5 = v7;
  return result;
}

uint64_t BOMBomApproximateBytesRepresentedByVariantIsValid(uint64_t result)
{
  if (result)
    return BOMBomVIndexDiskSpaceInfoIsValid(*(_QWORD *)(result + 32));
  return result;
}

uint64_t BOMBomEInsertFSObject(unint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v4;
  const char *v9;
  char *v10;
  char *v11;
  char *v12;
  unsigned int *Value;
  uint64_t v14;
  const char *v15;
  unsigned int v16;
  unsigned int v17;
  _DWORD *FSObjectWithBlockID;
  uint64_t v19;
  unsigned int v20;
  _DWORD *v21;
  unsigned int *v23;
  uint64_t v24;
  size_t v25;

  v4 = 1;
  if (!a1 || !a2)
    return v4;
  v24 = 0;
  v25 = 0;
  v9 = (const char *)BOMFSObjectPathName(a2);
  v10 = (char *)BOMFSObjectShortName(a2);
  v11 = BOMNewPathKey(a3, v10, &v25);
  if (!v11)
    return 1;
  v12 = v11;
  Value = (unsigned int *)BOMTreeGetValue(*(_QWORD *)(a1 + 16), v11, v25);
  v14 = (uint64_t)Value;
  if (Value)
  {
    v23 = a4;
    v15 = v9;
    v16 = BOMPathIDFromPathKey(Value);
    v17 = BOMBlockIDFromPathValue(v14);
    FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v17);
    if (FSObjectWithBlockID)
    {
      v19 = (uint64_t)FSObjectWithBlockID;
      _removeArchInfoForFSObject(a1, (uint64_t)FSObjectWithBlockID);
      BOMFSObjectFree(v19);
    }
    v20 = v16;
    v9 = v15;
    a4 = v23;
  }
  else
  {
    v20 = (*(_DWORD *)a1)++;
    v17 = BOMStorageNewBlock(*(_QWORD *)(a1 + 8));
  }
  if (_BOMBomSetFSObjectWithBlockID(a1, a2, v17))
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't archive %s\n", v9);
    v21 = 0;
    v4 = 1;
LABEL_17:
    free(v12);
    goto LABEL_18;
  }
  _addArchInfoForFSObject(a1, a2);
  if (v14)
  {
    v21 = 0;
    goto LABEL_14;
  }
  free(v12);
  v12 = BOMNewPathKey(a3, v10, &v25);
  v21 = BOMNewPathValue(v20, v17, &v24);
  if (!BOMTreeSetValue(*(_QWORD **)(a1 + 16), v12, v25, (uint64_t)v21, v24))
  {
LABEL_14:
    *(_BYTE *)(a1 + 64) = 1;
    v4 = 0;
    if (a4)
      *a4 = v20;
    if (!v12)
      goto LABEL_18;
    goto LABEL_17;
  }
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't set path info for %s.\n", v9);
  v4 = 1;
  if (v12)
    goto LABEL_17;
LABEL_18:
  if (v21)
    free(v21);
  return v4;
}

uint64_t BOMBomELinkFromPathToPath(uint64_t a1, const char *a2, char *a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  unint64_t Value;
  unint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  unsigned int v20;
  size_t v21;
  size_t v22;
  uint64_t v24;
  size_t v25;

  v4 = 1;
  if (a2)
  {
    if (a1)
    {
      if (a3)
      {
        v9 = _valueAtPath(a1);
        if (v9)
        {
          v10 = BOMBlockIDFromPathValue((uint64_t)v9);
          if (v10)
          {
            v11 = v10;
            v24 = 0;
            v25 = 0;
            v12 = strrchr(a3, 47);
            if (v12)
              v13 = v12 + 1;
            else
              v13 = a3;
            v14 = BOMNewPathKey(a4, v13, &v25);
            if (v14)
            {
              v15 = v14;
              Value = BOMTreeGetValue(*(_QWORD *)(a1 + 16), v14, v25);
              v17 = Value;
              if (Value)
              {
                v18 = 8;
                v24 = 8;
                v19 = (_DWORD *)Value;
              }
              else
              {
                v20 = (*(_DWORD *)a1)++;
                v19 = BOMNewPathValue(v20, v11, &v24);
                v18 = v24;
              }
              if (BOMTreeSetValue(*(_QWORD **)(a1 + 16), v15, v25, (uint64_t)v19, v18))
              {
                v4 = 1;
              }
              else
              {
                v21 = strlen(a3);
                BOMBomHLIndexSet(*(_QWORD *)(a1 + 24), v11, a3, v21 + 1);
                v22 = strlen(a2);
                BOMBomHLIndexSet(*(_QWORD *)(a1 + 24), v11, a2, v22 + 1);
                v4 = 0;
              }
              free(v15);
              if (!v17)
                free(v19);
            }
            else
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t BOMBomEInvalidateCachedData(uint64_t a1)
{
  BOMBomVIndexInvalidateDiskSpace(*(_QWORD *)(a1 + 32));
  return 0;
}

uint64_t _BOMBomPrintDiagnostics(uint64_t result)
{
  uint64_t *v1;
  FILE **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result)
  {
    v1 = (uint64_t *)result;
    v2 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Tree: %s\n", "Paths");
    _BOMTreePrintDiagnostics(v1[2]);
    _BOMBomHLIndexPrintDiagnostics(v1[3]);
    _BOMBomVIndexPrintDiagnostics(v1[4], v3, v4, v5, v6, v7, v8, v9);
    fwrite("Storage:\n", 9uLL, 1uLL, *v2);
    return _BOMStoragePrintDiagnostics(v1[1]);
  }
  return result;
}

uint64_t BOMBomVerifyBom(uint64_t a1, unsigned __int8 a2)
{
  uint64_t v4;
  int v5;
  char *v6;
  int v7;
  int v9;
  const char *v10;
  unsigned __int8 v11;
  int v12;

  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4)
    {
      if (!BOMTreeVerifyLeaves(v4))
      {
        v9 = *__error();
        v10 = "BOMBomVerifyBom: leaves do not verify.\n";
        v11 = a2;
        v12 = 4300;
        goto LABEL_12;
      }
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = BOMTreeCount(v4);
    v6 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a1 + 16), 0, 0, 0);
    v7 = 0;
    while (!BOMTreeIteratorIsAtEnd((uint64_t)v6))
    {
      ++v7;
      BOMTreeIteratorNext((uint64_t)v6);
    }
    BOMTreeIteratorFree(v6);
    if (v7 == v5)
      return 1;
    v9 = *__error();
    v10 = "BOMBomVerifyBom: count is wrong.\n";
    v11 = a2;
    v12 = 4316;
  }
  else
  {
    v9 = *__error();
    v10 = "BOMBomVerifyBom: bom is NULL.\n";
    v11 = a2;
    v12 = 4293;
  }
LABEL_12:
  _BOMExceptionHandlerCall((uint64_t)v10, v11, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", v12, v9);
  return 0;
}

void _addPathsToList(uint64_t a1, char *a2, __CFArray *a3, const char **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  char **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char **v22;
  const char *v23;
  const __CFArray *v24;
  CFIndex v25;
  CFTypeRef cf;
  char __s2[100];
  uint64_t v28;
  CFRange v29;

  v8 = a6;
  v9 = a5;
  v28 = *MEMORY[0x24BDAC8D0];
  v14 = BOMBomVIndexCount(*(_QWORD *)(a1 + 32), a2, 0, 0, a5, a6, a7, a8);
  if (v14)
  {
    v16 = v14;
    v17 = 0;
    v18 = kBOMBomVariantExtra;
    cf = 0;
    if (!v9)
      v18 = &kBOMBomVariantException;
    v19 = (uint64_t)*v18;
    do
    {
      if (!BOMBomVIndexGet(*(_QWORD *)(a1 + 32), a2, 0, 0, v17, __s2, 0x64uLL, v15))
      {
        if (a4)
        {
          v22 = a4;
          while (1)
          {
            v23 = *v22;
            if (!*v22)
              break;
            ++v22;
            if (!strcmp(v23, __s2))
            {
              if (v8)
                goto LABEL_6;
              goto LABEL_15;
            }
          }
        }
        if (v8)
        {
LABEL_15:
          cf = 0;
          if (!BOMBomVIndexGetList(*(_QWORD *)(a1 + 32), a2, (uint64_t)__s2, v19, (CFMutableArrayRef *)&cf, v20, v21, v15))
          {
            v24 = (const __CFArray *)cf;
            v29.location = BOMCFArrayMaxRange((const __CFArray *)cf);
            v29.length = v25;
            CFArrayAppendArray(a3, v24, v29);
            CFRelease(cf);
          }
        }
      }
LABEL_6:
      ++v17;
    }
    while (v17 != v16);
  }
}

void release_discovery_state(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  const void **v4;
  uint64_t v5;
  void *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a1)
  {
    v2 = *(NSObject **)(a1 + 24);
    if (v2)
    {
      dispatch_group_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(*(dispatch_object_t *)(a1 + 24));
      *(_QWORD *)(a1 + 24) = 0;
    }
    v3 = *(void **)(a1 + 56);
    if (v3)
    {
      free(v3);
      *(_QWORD *)(a1 + 56) = 0;
    }
    v4 = *(const void ***)(a1 + 48);
    if (v4)
    {
      BOMHardLinkTableFree(v4);
      *(_QWORD *)(a1 + 48) = 0;
    }
    v5 = *(_QWORD *)(a1 + 64);
    if (v5)
    {
      BOMBomFree(v5);
      *(_QWORD *)(a1 + 64) = 0;
    }
    v6 = *(void **)(a1 + 40);
    if (v6)
    {
      free(v6);
      *(_QWORD *)(a1 + 40) = 0;
    }
    v7 = *(uint64_t **)(a1 + 32);
    if (v7)
    {
      while (1)
      {
        v8 = BOMStackPop(v7);
        if (!v8)
          break;
        free(v8);
        v7 = *(uint64_t **)(a1 + 32);
      }
      BOMStackFree(*(void ***)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0;
    }
    v9 = *(_QWORD *)(a1 + 8);
    if (v9)
    {
      do
      {
        v10 = *(_QWORD *)(v9 + 72);
        v11 = *(_QWORD *)(v9 + 8);
        if (v11)
        {
          BOMFSObjectFree(v11);
          *(_QWORD *)(v9 + 8) = 0;
        }
        BOMCopierSourceEntryFree(*(unsigned int **)v9);
        free((void *)v9);
        v9 = v10;
      }
      while (v10);
    }
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    if (*(_QWORD *)a1)
    {
      BOMCopierSourceFree(*(void **)a1);
      *(_QWORD *)a1 = 0;
    }
  }
}

uint64_t _BOMGetFSObject(uint64_t a1, unsigned int *a2, unsigned int *a3, char *a4)
{
  unsigned int v8;
  int v9;
  int v10;
  char *v11;
  _DWORD *FSObjectWithBlockID;
  uint64_t v13;

  v8 = BOMBlockIDFromPathValue((uint64_t)a3);
  v9 = BOMPathIDFromPathKey(a3);
  v10 = BOMPathIDFromPathKey(a2);
  v11 = (char *)BOMShortNameFromPathKey((uint64_t)a2);
  FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v8);
  v13 = (uint64_t)FSObjectWithBlockID;
  if (FSObjectWithBlockID)
  {
    BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, a4, 1);
    BOMFSObjectSetShortName(v13, v11, 1);
    BOMFSObjectSetPathID(v13, v9);
    BOMFSObjectSetParentPathID(v13, v10);
    BOMFSObjectSetBlockID(v13, v8);
  }
  return v13;
}

void *BOMHardLinkTableNew()
{
  return BOM_malloczero(8uLL);
}

void BOMHardLinkTableFree(const void **a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      CFRelease(v2);
    free(a1);
  }
}

void BOMHardLinkTableSet(CFDictionaryRef *a1, int a2, uint64_t a3, UInt8 *bytes, CFIndex length)
{
  CFDataRef v8;
  CFDataRef v9;
  FILE *v10;
  int *v11;
  char *v12;

  if (a1)
  {
    if (bytes)
    {
      v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, length);
      if (v8)
      {
        v9 = v8;
        BOMHardLinkTableSetCFData(a1, a2, a3, v8);
        CFRelease(v9);
      }
      else
      {
        v10 = (FILE *)*MEMORY[0x24BDAC8D8];
        v11 = __error();
        v12 = strerror(*v11);
        fprintf(v10, "CFDataCreate: %s\n", v12);
      }
    }
    else
    {
      BOMHardLinkTableSetCFData(a1, a2, a3, 0);
    }
  }
}

void BOMHardLinkTableSetCFData(CFDictionaryRef *a1, int a2, uint64_t a3, const void *a4)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  CFNumberRef v8;
  CFNumberRef v9;
  void *Value;
  CFMutableDictionaryRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  FILE *v14;
  int *v15;
  FILE *v16;
  int *v17;
  uint64_t v18;
  int valuePtr;

  valuePtr = a2;
  v18 = a3;
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (!*a1)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (!Mutable)
      goto LABEL_15;
    *a1 = Mutable;
  }
  v8 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  if (!v8)
  {
LABEL_11:
    v14 = (FILE *)*MEMORY[0x24BDAC8D8];
    v15 = __error();
    strerror(*v15);
    fprintf(v14, "CFNumberCreate: %s\n");
    return;
  }
  v9 = v8;
  Value = (void *)CFDictionaryGetValue(*a1, v8);
  if (!Value)
  {
    v11 = CFDictionaryCreateMutable(v6, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (v11)
    {
      Value = v11;
      CFDictionarySetValue(*a1, v9, v11);
      CFRelease(Value);
      goto LABEL_8;
    }
    CFRelease(v9);
LABEL_15:
    v16 = (FILE *)*MEMORY[0x24BDAC8D8];
    v17 = __error();
    strerror(*v17);
    fprintf(v16, "CFDictionaryCreateMutable: %s\n");
    return;
  }
LABEL_8:
  CFRelease(v9);
  v12 = CFNumberCreate(v6, kCFNumberSInt64Type, &v18);
  if (!v12)
    goto LABEL_11;
  v13 = v12;
  if (a4)
    CFDictionarySetValue((CFMutableDictionaryRef)Value, v12, a4);
  else
    CFDictionaryRemoveValue((CFMutableDictionaryRef)Value, v12);
  CFRelease(v13);
}

const UInt8 *BOMHardLinkTableGet(CFDictionaryRef *a1, int a2, uint64_t a3)
{
  const __CFData *CFData;

  if (a1 && (CFData = (const __CFData *)BOMHardLinkTableGetCFData(a1, a2, a3)) != 0)
    return CFDataGetBytePtr(CFData);
  else
    return 0;
}

const void *BOMHardLinkTableGetCFData(CFDictionaryRef *a1, int a2, uint64_t a3)
{
  const __CFAllocator *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  const __CFDictionary *Value;
  CFNumberRef v8;
  CFNumberRef v9;
  const void *v10;
  uint64_t v12;
  int valuePtr;

  valuePtr = a2;
  v12 = a3;
  if (!*a1)
    return 0;
  v4 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
  if (!v5)
    return 0;
  v6 = v5;
  Value = (const __CFDictionary *)CFDictionaryGetValue(*a1, v5);
  CFRelease(v6);
  if (!Value)
    return 0;
  v8 = CFNumberCreate(v4, kCFNumberSInt64Type, &v12);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = CFDictionaryGetValue(Value, v8);
  CFRelease(v9);
  return v10;
}

void BOMHardLinkTableSetPathAndData(CFDictionaryRef *a1, int a2, uint64_t a3, char *__s, const void *a5, size_t a6)
{
  size_t v12;
  size_t v13;
  char *v14;
  UInt8 *v15;
  CFDataRef v16;
  CFDataRef v17;
  FILE *v18;
  int *v19;
  char *v20;

  if (a1)
  {
    if (__s && a5)
    {
      v12 = strlen(__s) + 1;
      v13 = v12 + a6;
      v14 = (char *)BOM_malloc(v12 + a6);
      if (v14)
      {
        v15 = (UInt8 *)v14;
        strlcpy(v14, __s, v13);
        memmove(&v15[v12], a5, a6);
        v16 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], v15, v13, (CFAllocatorRef)*MEMORY[0x24BDBD248]);
        if (v16)
        {
          v17 = v16;
          BOMHardLinkTableSetCFData(a1, a2, a3, v16);
          CFRelease(v17);
        }
        else
        {
          free(v15);
          v18 = (FILE *)*MEMORY[0x24BDAC8D8];
          v19 = __error();
          v20 = strerror(*v19);
          fprintf(v18, "CFDataCreate: %s\n", v20);
        }
      }
    }
    else
    {
      BOMHardLinkTableSetCFData(a1, a2, a3, 0);
    }
  }
}

uint64_t BOMHardLinkTableGetPathAndData(CFDictionaryRef *a1, int a2, uint64_t a3, char *a4, _QWORD *a5)
{
  uint64_t result;
  const __CFData *CFData;
  const __CFData *v10;
  const char *BytePtr;
  size_t Length;
  char *v13;
  size_t v14;

  result = 1;
  if (a1 && a4 && a5)
  {
    CFData = (const __CFData *)BOMHardLinkTableGetCFData(a1, a2, a3);
    if (CFData)
    {
      v10 = CFData;
      BytePtr = (const char *)CFDataGetBytePtr(CFData);
      Length = CFDataGetLength(v10);
      v13 = strncpy(a4, BytePtr, Length);
      v14 = strlen(v13);
      result = 0;
      *a5 = &BytePtr[v14 + 1];
    }
    else
    {
      return 1;
    }
  }
  return result;
}

_QWORD *BOMFSEnumeratorNew(uint64_t a1, __int16 a2, char a3)
{
  return BOMFSEnumeratorNewWithSys(a1, a2, a3, 0);
}

_QWORD *BOMFSEnumeratorNewWithSys(uint64_t a1, __int16 a2, char a3, void (**a4)(_QWORD, uint64_t, uint64_t))
{
  _QWORD *v8;
  int *v9;
  char *v10;
  char *v11;
  int *v12;
  FTS *v14;
  char *v15[3];

  v15[2] = *(char **)MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0;
  v8 = BOM_malloczero(0x420uLL);
  if (v8)
  {
    if (!a4)
      a4 = (void (**)(_QWORD, uint64_t, uint64_t))BomSys_default();
    v8[2] = a4;
    if (((unsigned int (*)(void (*)(_QWORD, uint64_t, uint64_t), uint64_t))a4[39])(a4[1], a1))
    {
      v9 = __error();
      v10 = strerror(*v9);
      v11 = BOMExceptionHandlerMessage("chdir: %s\n", v10);
      v12 = __error();
      _BOMExceptionHandlerCall((uint64_t)v11, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMFSEnumerator.c", 56, *v12);
    }
    else
    {
      *((_WORD *)v8 + 4) = a2;
      *((_BYTE *)v8 + 10) = a3;
      a4[38](a4[1], (uint64_t)(v8 + 3), 1025);
      v15[0] = ".";
      v15[1] = 0;
      v14 = fts_open(v15, 92, (int (__cdecl *)(const FTSENT **, const FTSENT **))_sort);
      *v8 = v14;
      if (v14)
        return v8;
    }
    free(v8);
    return 0;
  }
  return v8;
}

uint64_t _sort(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(*(_QWORD *)a1 + 104), (const char *)(*(_QWORD *)a2 + 104));
}

FTSENT *BOMFSEnumeratorNext(FTSENT *result)
{
  FTSENT *v1;
  int fts_info;
  int fts_errno;
  int *v4;
  char *v5;
  char *v6;
  int *v7;
  __int16 v8;
  _OWORD v9[9];

  if (result)
  {
    v1 = result;
    memset(v9, 0, sizeof(v9));
    do
    {
      result = fts_read((FTS *)v1->fts_cycle);
      if (!result)
        return result;
      fts_info = result->fts_info;
    }
    while (fts_info == 6);
    fts_errno = result->fts_errno;
    if (fts_errno)
    {
      *__error() = fts_errno;
      v4 = __error();
      v5 = strerror(*v4);
      v6 = BOMExceptionHandlerMessage("fts_read: %s\n", v5);
      v7 = __error();
      _BOMExceptionHandlerCall((uint64_t)v6, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMFSEnumerator.c", 94, *v7);
      return 0;
    }
    if (!BYTE2(v1->fts_parent))
      return (FTSENT *)BOMFSObjectNewFromPathWithSys(result->fts_path, (__int16)v1->fts_parent, v1->fts_link);
    if (result->fts_info > 7u)
    {
      if (fts_info == 8)
      {
        v8 = 0x8000;
        goto LABEL_19;
      }
      if (fts_info == 12)
      {
        v8 = -24576;
        goto LABEL_19;
      }
    }
    else
    {
      if (fts_info == 1)
      {
        v8 = 0x4000;
        goto LABEL_19;
      }
      if (fts_info == 3)
      {
        v8 = 24576;
LABEL_19:
        WORD2(v9[0]) = v8;
        return (FTSENT *)BOMFSObjectNewFromPathDeferredWithSys((uint64_t)v9, result->fts_path, (__int16)v1->fts_parent, (const char *)&v1->fts_number, 0, v1->fts_link);
      }
    }
    v8 = 0;
    goto LABEL_19;
  }
  return result;
}

void BOMFSEnumeratorFree(FTS **a1)
{
  FTS *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      fts_close(v2);
    free(a1);
  }
}

_DWORD *BOMBomVIndexNew(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  int *v9;

  v2 = BOM_malloczero(0x30uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = 1;
    v4 = BOMStorageNewNamedBlock(a1, "VIndex");
    if (!v4)
      goto LABEL_7;
    *((_QWORD *)v3 + 2) = a1;
    v3[6] = v4;
    v5 = BOMStorageNewBlock(a1);
    if (!v5)
      goto LABEL_7;
    v6 = v5;
    v7 = BOMTreeNewWithOptions(a1, v5, "VIndex", 0x80u, 0);
    if (!v7)
      goto LABEL_7;
    *((_QWORD *)v3 + 1) = v7;
    v8 = BOMStreamWithBlockID(*((_QWORD *)v3 + 2), v3[6], 0xDuLL, 1);
    if (v8
      && (v9 = (int *)v8,
          BOMStreamWriteUInt32(v8, *v3),
          BOMStreamWriteUInt32((uint64_t)v9, v6),
          BOMStreamWriteUInt32((uint64_t)v9, v3[7]),
          BOMStreamWriteUInt8((uint64_t)v9, *((_BYTE *)v3 + 33)),
          !BOMStreamFlush(v9)))
    {
      BOMStreamFree((uint64_t)v9);
    }
    else
    {
LABEL_7:
      BOMBomVIndexFree(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t BOMBomVIndexFree(_BYTE *a1)
{
  uint64_t v3;
  const void *v4;

  if (!a1)
    return 1;
  if (a1[32] && BOMBomVIndexCommit((uint64_t)a1))
    return 1;
  v3 = *((_QWORD *)a1 + 1);
  if (v3)
    BOMTreeFree(v3);
  v4 = (const void *)*((_QWORD *)a1 + 5);
  if (v4)
    CFRelease(v4);
  free(a1);
  return 0;
}

_QWORD *BOMBomVIndexOpen(uint64_t a1, char a2)
{
  _QWORD *v4;
  unsigned int NamedBlock;
  uint64_t v6;
  uint64_t v7;
  unsigned int UInt32;
  uint64_t v9;

  v4 = BOM_malloczero(0x30uLL);
  if (v4)
  {
    NamedBlock = BOMStorageGetNamedBlock(a1, "VIndex");
    if (!NamedBlock)
      goto LABEL_5;
    v4[2] = a1;
    *((_DWORD *)v4 + 6) = NamedBlock;
    v6 = BOMStreamWithBlockID(a1, NamedBlock, 0xDuLL, 0);
    if (!v6)
      goto LABEL_5;
    v7 = v6;
    *(_DWORD *)v4 = BOMStreamReadUInt32(v6);
    UInt32 = BOMStreamReadUInt32(v7);
    *((_DWORD *)v4 + 7) = BOMStreamReadUInt32(v7);
    *((_BYTE *)v4 + 33) = BOMStreamReadUInt8(v7);
    BOMStreamFree(v7);
    v9 = BOMTreeOpen(a1, UInt32, a2);
    v4[1] = v9;
    if (!v9)
    {
LABEL_5:
      BOMBomVIndexFree(v4);
      return 0;
    }
  }
  return v4;
}

uint64_t BOMBomVIndexCommit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int *v4;

  if (!a1)
    return 1;
  if (!*(_BYTE *)(a1 + 32))
    return 0;
  result = BOMStorageIsOpenForWriting(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
  {
    BOMTreeCommit(*(_QWORD *)(a1 + 8));
    v3 = BOMStreamWithBlockID(*(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), 0xDuLL, 2);
    if (v3
      && (v4 = (int *)v3,
          BOMStreamReadUInt32(v3),
          BOMStreamReadUInt32((uint64_t)v4),
          BOMStreamWriteUInt32((uint64_t)v4, *(_DWORD *)(a1 + 28)),
          BOMStreamWriteUInt8((uint64_t)v4, *(_BYTE *)(a1 + 33)),
          !BOMStreamFlush(v4)))
    {
      BOMStreamFree((uint64_t)v4);
      result = 0;
      *(_BYTE *)(a1 + 32) = 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMBomVIndexCopyFromVIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  _QWORD *v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  unsigned int *Value;
  unsigned int v27;
  _QWORD *v28;
  unsigned int v29;
  char __s[1024];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (a1 && a2)
  {
    if (BOMTreeCount(*(_QWORD *)(a1 + 8)) || BOMCKTreeBuildKey(__s, v4, v5, v6, v7, v8, v9, v10, "path"))
    {
      v11 = 0;
    }
    else
    {
      v17 = strlen(__s);
      v18 = *(_QWORD *)(a1 + 16);
      v19 = *(_QWORD *)(a2 + 16);
      v11 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a2 + 8), 0, 0, 0);
      if (v11)
      {
        BOMTreeSetDensePacking(*(_QWORD *)(a1 + 8), 1);
        while (!BOMTreeIteratorIsAtEnd((uint64_t)v11))
        {
          v20 = (const void *)BOMTreeIteratorKey((uint64_t)v11);
          if (BOM_strrncmp((const char *)v20, __s, v17))
          {
            v21 = *(_QWORD **)(a1 + 8);
            v22 = BOMTreeIteratorKeySize((uint64_t)v11);
            v23 = BOMTreeIteratorValue((uint64_t)v11);
            v24 = BOMTreeIteratorValueSize((uint64_t)v11);
            if (BOMTreeSetValue(v21, v20, v22, v23, v24))
              goto LABEL_6;
          }
          else
          {
            v29 = 0;
            v25 = strlen((const char *)v20) + 1;
            Value = (unsigned int *)BOMTreeGetValue(*(_QWORD *)(a2 + 8), v20, v25);
            if (!Value)
            {
              v13 = 0;
              v12 = 0;
              goto LABEL_8;
            }
            v12 = BOMTreeOpen(v19, bswap32(*Value), 0);
            if (!v12)
              goto LABEL_7;
            v27 = BOMStorageNewBlock(v18);
            v29 = v27;
            if (!v27)
              goto LABEL_7;
            v28 = BOMTreeNewWithOptions(v18, v27, 0, 0x80u, 0);
            v13 = (uint64_t)v28;
            if (!v28)
              goto LABEL_8;
            BOMTreeSetDensePacking((uint64_t)v28, 1);
            if (BOMTreeCopyToTree(v12, v13))
              goto LABEL_8;
            BOMTreeFree(v12);
            BOMTreeFree(v13);
            v29 = bswap32(v29);
            BOMTreeSetValue(*(_QWORD **)(a1 + 8), v20, v25, (uint64_t)&v29, 4);
          }
          BOMTreeIteratorNext((uint64_t)v11);
        }
        v14 = 0;
        v12 = 0;
        v13 = 0;
        *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
        *(_BYTE *)(a1 + 32) = 1;
        goto LABEL_11;
      }
    }
LABEL_6:
    v12 = 0;
LABEL_7:
    v13 = 0;
LABEL_8:
    v14 = 1;
  }
  else
  {
    v14 = 1;
    if (!a1)
      return v14;
    v11 = 0;
    v12 = 0;
    v13 = 0;
  }
LABEL_11:
  v15 = *(_QWORD *)(a1 + 8);
  if (v15)
    BOMTreeSetDensePacking(v15, 0);
  if (v12)
    BOMTreeFree(v12);
  if (v13)
    BOMTreeFree(v13);
  if (v11)
    BOMTreeIteratorFree(v11);
  return v14;
}

uint64_t BOMBomVIndexSet(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t TreeFor;
  _QWORD *v12;
  size_t v13;

  v8 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            TreeFor = _v_findTreeFor(a1, 1, 1, a2, a3, a4, a7, a8);
            if (TreeFor)
            {
              v12 = (_QWORD *)TreeFor;
              v13 = strlen(a5);
              v8 = BOMTreeSetValue(v12, a5, v13 + 1, 0, 0);
              BOMTreeFree((uint64_t)v12);
              if (!(_DWORD)v8)
                *(_WORD *)(a1 + 32) = 1;
            }
          }
        }
      }
    }
  }
  return v8;
}

uint64_t _v_findTreeFor(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  int v9;
  char v10;
  uint64_t v12;
  size_t v13;
  unsigned int *Value;
  unsigned int v15;
  unsigned int v16;
  unsigned int v18;
  char __s[1024];
  uint64_t v20;

  v8 = 0;
  v20 = *MEMORY[0x24BDAC8D0];
  if (a4)
  {
    if (a5)
    {
      if (a6)
      {
        v9 = a3;
        v10 = a2;
        v12 = *(_QWORD *)(a1 + 16);
        v8 = 0;
        if (!BOMCKTreeBuildKey(__s, a2, a3, (uint64_t)a4, a5, a6, a7, a8, a4))
        {
          v13 = strlen(__s) + 1;
          Value = (unsigned int *)BOMTreeGetValue(*(_QWORD *)(a1 + 8), __s, v13);
          if (Value)
          {
            return BOMTreeOpen(v12, bswap32(*Value), v10);
          }
          else if (v9 && (v15 = BOMStorageNewBlock(v12)) != 0)
          {
            v16 = v15;
            v8 = BOMTreeNewWithOptions(v12, v15, 0, 0x80u, 0);
            if (v8)
            {
              v18 = bswap32(v16);
              BOMTreeSetValue(*(_QWORD **)(a1 + 8), __s, v13, (uint64_t)&v18, 4);
            }
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return (uint64_t)v8;
}

uint64_t BOMBomVIndexCount(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t TreeFor;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!a1)
    return 0;
  TreeFor = _v_findTreeFor(a1, 0, 0, a2, a3, a4, a7, a8);
  if (TreeFor)
  {
    v18 = TreeFor;
    v19 = BOMTreeCount(TreeFor);
    if (v18 != *(_QWORD *)(a1 + 8))
      BOMTreeFree(v18);
    return v19;
  }
  return BOMCKTreeCount(*(_QWORD *)(a1 + 8), v11, v12, v13, v14, v15, v16, v17, a2);
}

uint64_t BOMBomVIndexGet(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, size_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t TreeFor;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *i;
  const char *v24;
  char *v25;

  result = 1;
  if (a1 && a6)
  {
    *a6 = 0;
    TreeFor = _v_findTreeFor(a1, 0, 0, a2, a3, a4, a7, a8);
    if (TreeFor)
    {
      v21 = TreeFor;
      if (BOMTreeCount(TreeFor) <= a5)
        return 1;
      v22 = (char *)BOMTreeIteratorNew(v21, 0, 0, 0);
      if (!v22)
        return 1;
      for (i = v22; a5; --a5)
        BOMTreeIteratorNext((uint64_t)i);
      v24 = (const char *)BOMTreeIteratorKey((uint64_t)i);
      strlcpy(a6, v24, a7);
      BOMTreeIteratorFree(i);
      BOMTreeFree(v21);
    }
    else
    {
      v25 = BOMCKTreeGet(*(_QWORD *)(a1 + 8), a5, v15, v16, v17, v18, v19, v20, a2);
      strlcpy(a6, v25, a7);
    }
    return 0;
  }
  return result;
}

uint64_t BOMBomVIndexGetList(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, CFMutableArrayRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  CFMutableArrayRef Mutable;
  uint64_t TreeFor;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char *i;
  const char *v26;
  const char *v27;
  size_t v28;
  char *v29;
  char *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  char *v40;
  const char *v41;
  size_t v42;
  char *v43;
  char *v44;

  v8 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (*a5
              || (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0), (*a5 = Mutable) != 0))
            {
              TreeFor = _v_findTreeFor(a1, 0, 0, a2, a3, a4, a7, a8);
              v23 = TreeFor;
              if (TreeFor)
              {
                v24 = (char *)BOMTreeIteratorNew(TreeFor, 0, 0, 0);
                if (!v24)
                  goto LABEL_27;
                for (i = v24; ; BOMTreeIteratorNext((uint64_t)i))
                {
                  if (BOMTreeIteratorIsAtEnd((uint64_t)i))
                  {
                    v8 = 0;
                    goto LABEL_25;
                  }
                  v26 = (const char *)BOMTreeIteratorKey((uint64_t)i);
                  if (!v26)
                    break;
                  v27 = v26;
                  v28 = strlen(v26) + 1;
                  v29 = (char *)BOM_malloc(v28);
                  if (!v29)
                    break;
                  v30 = v29;
                  strlcpy(v29, v27, v28);
                  CFArrayAppendValue(*a5, v30);
                }
                v8 = 1;
LABEL_25:
                BOMTreeIteratorFree(i);
LABEL_26:
                if (v23)
LABEL_27:
                  BOMTreeFree(v23);
              }
              else
              {
                v31 = BOMCKTreeCount(*(_QWORD *)(a1 + 8), v16, v17, v18, v19, v20, v21, v22, a2);
                if (v31 < 1)
                {
                  return 0;
                }
                else
                {
                  v38 = v31;
                  v39 = 0;
                  while (1)
                  {
                    v40 = BOMCKTreeGet(*(_QWORD *)(a1 + 8), v39, v32, v33, v34, v35, v36, v37, a2);
                    if (!v40)
                      return 1;
                    v41 = v40;
                    v42 = strlen(v40) + 1;
                    v43 = (char *)BOM_malloc(v42);
                    if (!v43)
                      return 1;
                    v44 = v43;
                    strlcpy(v43, v41, v42);
                    CFArrayAppendValue(*a5, v44);
                    if (v38 == ++v39)
                    {
                      v8 = 0;
                      v23 = 0;
                      goto LABEL_26;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v8;
}

uint64_t BOMBomVIndexRemove(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t TreeFor;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  char __s[1024];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v8 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          TreeFor = _v_findTreeFor(a1, 1, 0, a2, a3, a4, a7, a8);
          if (TreeFor)
          {
            v15 = TreeFor;
            while (a5)
            {
              v16 = strlen(a5);
              v17 = BOMTreeRemoveValue(v15, a5, v16 + 1);
              if ((_DWORD)v17)
                return v17;
              v18 = BOMTreeCount(v15);
              BOMTreeFree(v15);
              if (v18)
                goto LABEL_16;
              v8 = 1;
              *(_WORD *)(a1 + 32) = 1;
              v15 = _v_findTreeFor(a1, 1, 0, a2, a3, a4, v19, v20);
              a5 = 0;
              if (!v15)
                return v8;
            }
            BOMTreeRemoveAndFree(v15);
            if (BOMCKTreeBuildKey(__s, v21, v22, v23, v24, v25, v26, v27, a2))
              return 1;
            v28 = strlen(__s);
            v8 = BOMTreeRemoveValue(*(_QWORD *)(a1 + 8), __s, (v28 + 1));
            if (!(_DWORD)v8)
            {
LABEL_16:
              v8 = 0;
              *(_WORD *)(a1 + 32) = 1;
            }
          }
        }
      }
    }
  }
  return v8;
}

uint64_t BOMBomVIndexGetApproxDiskSpace(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned int v11;
  size_t v12;
  CFDataRef v13;
  CFDataRef v14;
  FILE *v15;
  int *v16;
  char *v17;
  unint64_t v18;
  unsigned int *v19;
  void *value;
  char __s[1024];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (!a2 && !a3 && !a4)
  {
    result = 0;
    v11 = *(_DWORD *)(a1 + 28);
LABEL_6:
    *a5 = v11;
    return result;
  }
  result = 1;
  if (a4 && a2 && a3 && a5)
  {
    *a5 = 0;
    if (BOMCKTreeBuildKey(__s, (uint64_t)a2, a3, a4, (uint64_t)a5, a6, a7, a8, a2))
      return 1;
    v12 = strlen(__s) + 1;
    if (*(_QWORD *)(a1 + 40))
    {
      value = 0;
      v13 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)__s, v12);
      if (!v13)
      {
        v15 = (FILE *)*MEMORY[0x24BDAC8D8];
        v16 = __error();
        v17 = strerror(*v16);
        fprintf(v15, "CFDataCreate: %s\n", v17);
        return 1;
      }
      v14 = v13;
      if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 40), v13, (const void **)&value))
      {
        *a5 = value;
        CFRelease(v14);
        return 0;
      }
      CFRelease(v14);
    }
    v18 = BOMTreeGetValue(*(_QWORD *)(a1 + 8), __s, v12);
    if (v18)
    {
      v19 = (unsigned int *)v18;
      result = 0;
      v11 = bswap32(*v19);
      goto LABEL_6;
    }
    return 1;
  }
  return result;
}

uint64_t BOMBomVIndexSetApproxDiskSpace(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t result;
  char __s[1024];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  v8 = a5;
  if (!a2 && !a3 && !a4)
  {
    result = 0;
    *(_DWORD *)(a1 + 28) = a5;
    *(_WORD *)(a1 + 32) = 257;
    return result;
  }
  result = 1;
  if (a2 && a3 && a4)
  {
    if (!BOMCKTreeBuildKey(__s, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a2))
      return BOMBomVIndexSetApproxDiskSpaceWithKey(a1, __s, v8);
    return 1;
  }
  return result;
}

uint64_t BOMBomVIndexSetApproxDiskSpaceWithKey(uint64_t a1, char *__s, unsigned int a3)
{
  uint64_t result;
  size_t v7;
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  CFDataRef v10;
  CFDataRef v11;
  FILE *v12;
  int *v13;
  char *v14;
  unsigned int v15;

  result = 1;
  if (a1 && __s)
  {
    v7 = strlen(__s) + 1;
    if (BOMStorageIsOpenForWriting(*(_QWORD *)(a1 + 16)))
    {
      v15 = bswap32(a3);
      result = BOMTreeSetValue(*(_QWORD **)(a1 + 8), __s, v7, (uint64_t)&v15, 4);
      if (!(_DWORD)result)
      {
        *(_WORD *)(a1 + 32) = 257;
        return result;
      }
    }
    else
    {
      v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      if (*(_QWORD *)(a1 + 40)
        || (Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], 0),
            (*(_QWORD *)(a1 + 40) = Mutable) != 0))
      {
        v10 = CFDataCreate(v8, (const UInt8 *)__s, v7);
        if (v10)
        {
          v11 = v10;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v10, (const void *)a3);
          CFRelease(v11);
          result = 0;
          *(_BYTE *)(a1 + 33) = 1;
          return result;
        }
        v12 = (FILE *)*MEMORY[0x24BDAC8D8];
        v13 = __error();
        v14 = strerror(*v13);
        fprintf(v12, "CFDataCreate: %s\n", v14);
      }
    }
    return 1;
  }
  return result;
}

uint64_t BOMBomVIndexDiskSpaceKey(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  size_t v11;
  void *v12;
  char __s[1024];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  result = 1;
  if (a1 && a2 && a3 && a4)
  {
    if (BOMCKTreeBuildKey(__s, (uint64_t)a2, a3, a4, (uint64_t)a5, a6, a7, a8, a2))
      return 1;
    v11 = strlen(__s) + 1;
    v12 = BOM_malloc(v11);
    *a5 = v12;
    if (!v12)
    {
      return 1;
    }
    else
    {
      memmove(v12, __s, v11);
      return 0;
    }
  }
  return result;
}

uint64_t BOMBomVIndexDiskSpaceInfoIsValid(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 33);
  return result;
}

uint64_t BOMBomVIndexInvalidateDiskSpace(uint64_t result)
{
  *(_WORD *)(result + 32) = 1;
  return result;
}

uint64_t _BOMBomVIndexPrintDiagnostics(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;
  FILE **v10;
  int v11;
  char *v12;
  int v13;
  const char *v14;
  int v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  char __s[1024];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    v8 = result;
    result = BOMCKTreeBuildKey(__s, a2, a3, a4, a5, a6, a7, a8, "path");
    if (!(_DWORD)result)
    {
      v9 = strlen(__s);
      v10 = (FILE **)MEMORY[0x24BDAC8D8];
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Tree: %s\n", "VIndex");
      v11 = BOMTreeCount(*(_QWORD *)(v8 + 8));
      result = (uint64_t)BOMTreeIteratorNew(*(_QWORD *)(v8 + 8), 0, 0, 0);
      if (result)
      {
        v12 = (char *)result;
        v13 = 0;
        while (!BOMTreeIteratorIsAtEnd((uint64_t)v12))
        {
          v14 = (const char *)BOMTreeIteratorKey((uint64_t)v12);
          if (!BOM_strrncmp(v14, __s, v9))
          {
            v15 = strlen(v14);
            result = BOMTreeGetValue(*(_QWORD *)(v8 + 8), v14, (v15 + 1));
            if (!result)
              return result;
            v16 = (unsigned int *)result;
            v17 = BOMTreeStorage(*(_QWORD *)(v8 + 8));
            result = BOMTreeOpen(v17, bswap32(*v16), 0);
            if (!result)
              return result;
            v18 = result;
            v13 += BOMTreeCount(result);
            BOMTreeFree(v18);
          }
          BOMTreeIteratorNext((uint64_t)v12);
        }
        BOMTreeIteratorFree(v12);
        fprintf(*v10, " i # records: %d\n", v11);
        fprintf(*v10, " i # pages  : %d (%d)\n", 0, 0);
        fprintf(*v10, "   i leaf   : %d (%d)\n", 0, 0);
        fprintf(*v10, "   i branch : %d (%d)\n", 0, 0);
        fprintf(*v10, " i key size : %zd\n", 0);
        fprintf(*v10, " i data size: %zd\n", 0);
        fprintf(*v10, "   # records: %d\n", v13);
        fprintf(*v10, "   # pages  : %d (%d)\n", 0, 0);
        fprintf(*v10, "     leaf   : %d (%d)\n", 0, 0);
        fprintf(*v10, "     branch : %d (%d)\n", 0, 0);
        fprintf(*v10, "   key size : %zd\n", 0);
        return fprintf(*v10, "   data size: %zd\n", 0);
      }
    }
  }
  return result;
}

double byte_stream_new(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  double result;

  if (!a2)
  {
    v3 = platform_calloc(a1, 1uLL, 0x50uLL);
    if (v3)
    {
      *(_DWORD *)v3 = 1651733613;
      v3[1] = a1;
      *(_QWORD *)&result = 0x200000002;
      v3[2] = 0x200000002;
      *((_DWORD *)v3 + 18) = 1836348258;
    }
  }
  return result;
}

void byte_stream_free(_QWORD *__b)
{
  void *v2;
  uint64_t v3;

  if (__b && *(_DWORD *)__b == 1651733613 && *((_DWORD *)__b + 18) == 1836348258)
  {
    v2 = (void *)__b[7];
    if (v2)
      platform_free(__b[1], v2);
    v3 = __b[1];
    platform_memset(v3, __b, 0, 0x50uLL);
    platform_free(v3, __b);
  }
}

uint64_t byte_stream_attach(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (result && *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258)
  {
    if (a3 < 0xE8D4A51001)
    {
      *(_BYTE *)(result + 24) = 0;
      *(_QWORD *)(result + 40) = a3;
      *(_QWORD *)(result + 48) = 0;
      *(_QWORD *)(result + 32) = a2;
    }
    else
    {
      *(_BYTE *)(result + 24) = 1;
    }
  }
  return result;
}

BOOL byte_stream_exception(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258 && *(_BYTE *)(result + 24) != 0;
  return result;
}

_DWORD *byte_stream_set_byte_order(_DWORD *result, int a2)
{
  if (result && *result == 1651733613 && result[18] == 1836348258)
    result[5] = a2;
  return result;
}

uint64_t byte_stream_read_uint8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (a1 && *(_DWORD *)a1 == 1651733613 && *(_DWORD *)(a1 + 72) == 1836348258 && !*(_BYTE *)(a1 + 24))
  {
    v1 = *(_QWORD *)(a1 + 48);
    v2 = v1 + 1;
    if ((unint64_t)(v1 + 1) <= *(_QWORD *)(a1 + 40))
    {
      v3 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + v1);
      *(_QWORD *)(a1 + 48) = v2;
      return v3;
    }
    *(_BYTE *)(a1 + 24) = 1;
  }
  return 255;
}

uint64_t byte_stream_read_uint16(uint64_t a1)
{
  uint64_t v2;
  unsigned int v5;
  unsigned __int16 __dst;

  if (a1)
  {
    if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24))
      return (unsigned __int16)-1;
    v2 = *(_QWORD *)(a1 + 48);
    if ((unint64_t)(v2 + 2) > *(_QWORD *)(a1 + 40))
    {
      *(_BYTE *)(a1 + 24) = 1;
      return (unsigned __int16)-1;
    }
    __dst = 0;
    platform_memcpy(*(_QWORD *)(a1 + 8), &__dst, (void *)(*(_QWORD *)(a1 + 32) + v2), 2uLL);
    *(_QWORD *)(a1 + 48) += 2;
    v5 = bswap32(__dst) >> 16;
    if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20))
      return __dst;
    else
      return (unsigned __int16)v5;
  }
  else
  {
    return (unsigned __int16)-1;
  }
}

uint64_t byte_stream_read_uint32(uint64_t a1)
{
  uint64_t v2;
  unsigned int v4;
  unsigned int __dst;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24))
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 48);
  if ((unint64_t)(v2 + 4) > *(_QWORD *)(a1 + 40))
  {
    *(_BYTE *)(a1 + 24) = 1;
    return 0xFFFFFFFFLL;
  }
  __dst = 0;
  platform_memcpy(*(_QWORD *)(a1 + 8), &__dst, (void *)(*(_QWORD *)(a1 + 32) + v2), 4uLL);
  *(_QWORD *)(a1 + 48) += 4;
  v4 = bswap32(__dst);
  if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20))
    return __dst;
  else
    return v4;
}

unint64_t byte_stream_read_uint64(uint64_t a1)
{
  uint64_t v2;
  unint64_t v4;
  unint64_t __dst;

  if (!a1)
    return -1;
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24))
    return -1;
  v2 = *(_QWORD *)(a1 + 48);
  if ((unint64_t)(v2 + 8) > *(_QWORD *)(a1 + 40))
  {
    *(_BYTE *)(a1 + 24) = 1;
    return -1;
  }
  __dst = 0;
  platform_memcpy(*(_QWORD *)(a1 + 8), &__dst, (void *)(*(_QWORD *)(a1 + 32) + v2), 8uLL);
  *(_QWORD *)(a1 + 48) += 8;
  v4 = bswap64(__dst);
  if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20))
    return __dst;
  else
    return v4;
}

uint64_t *byte_stream_read_buffer(uint64_t *result, void *a2, size_t __n)
{
  uint64_t *v3;
  uint64_t v5;

  if (result)
  {
    v3 = result;
    if (*(_DWORD *)result == 1651733613 && *((_DWORD *)result + 18) == 1836348258 && !*((_BYTE *)result + 24))
    {
      if (!a2)
        goto LABEL_8;
      if (!__n)
        return result;
      v5 = result[6];
      if (v5 + __n <= result[5])
      {
        result = (uint64_t *)platform_memcpy(result[1], a2, (void *)(result[4] + v5), __n);
        v3[6] += __n;
      }
      else
      {
LABEL_8:
        *((_BYTE *)result + 24) = 1;
      }
    }
  }
  return result;
}

uint64_t byte_stream_read_string(uint64_t a1, size_t a2, uint64_t a3)
{
  uint64_t result;
  size_t v7;
  size_t v8;
  void *v9;
  void *v10;
  char *__endptr;

  if (!a1)
    return -1;
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24))
    return -1;
  if (*(_QWORD *)(a1 + 48) + a2 > *(_QWORD *)(a1 + 40))
    goto LABEL_6;
  v7 = a2 + 1;
  v8 = *(_QWORD *)(a1 + 64);
  if (v8 >= a2 + 1)
  {
    platform_memset(*(_QWORD *)(a1 + 8), *(void **)(a1 + 56), 0, v8);
    v10 = *(void **)(a1 + 56);
  }
  else
  {
    v9 = *(void **)(a1 + 56);
    if (v9)
      platform_free(*(_QWORD *)(a1 + 8), v9);
    *(_QWORD *)(a1 + 64) = v7;
    v10 = platform_calloc(*(_QWORD *)(a1 + 8), a2 + 1, 1uLL);
    *(_QWORD *)(a1 + 56) = v10;
    if (!v10)
    {
      *(_BYTE *)(a1 + 24) = 1;
      return -1;
    }
  }
  byte_stream_read_buffer((uint64_t *)a1, v10, a2);
  if (*(_BYTE *)(a1 + 24))
    return -1;
  __endptr = 0;
  result = platform_strtoq(*(_QWORD *)(a1 + 8), *(char **)(a1 + 56), &__endptr, a3);
  if (!result)
  {
    if (!*__error())
      return 0;
LABEL_6:
    *(_BYTE *)(a1 + 24) = 1;
    return -1;
  }
  return result;
}

uint64_t byte_stream_remaining(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1651733613 && *(_DWORD *)(a1 + 72) == 1836348258)
    return *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 48);
  else
    return -1;
}

uint64_t byte_stream_advance(uint64_t result, uint64_t a2)
{
  unint64_t v2;

  if (result && *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258 && !*(_BYTE *)(result + 24))
  {
    v2 = *(_QWORD *)(result + 48) + a2;
    if (v2 <= *(_QWORD *)(result + 40))
      *(_QWORD *)(result + 48) = v2;
    else
      *(_BYTE *)(result + 24) = 1;
  }
  return result;
}

_QWORD *data_archive_decoder_new(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v5;
  uint64_t v6;

  if (!a2)
  {
    v5 = platform_calloc(a1, 1uLL, 0x60uLL);
    v2 = v5;
    if (!v5)
      return v2;
    *(_DWORD *)v5 = 1919315316;
    v5[1] = a1;
    byte_stream_new(a1, 0);
    v2[3] = v6;
    if (v6)
    {
      *((_DWORD *)v2 + 23) = 1953326706;
      return v2;
    }
    free(v2);
  }
  return 0;
}

void data_archive_decoder_free(_QWORD *__b)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  if (__b && *(_DWORD *)__b == 1919315316 && *((_DWORD *)__b + 23) == 1953326706)
  {
    v2 = (void *)__b[5];
    if (v2)
      platform_free(__b[1], v2);
    v3 = (_QWORD *)__b[3];
    if (v3)
      byte_stream_free(v3);
    v4 = __b[1];
    platform_memset(v4, __b, 0, 0x60uLL);
    platform_free(v4, __b);
  }
}

uint64_t data_archive_decoder_set_stream(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  _QWORD *v11;
  int v12;
  int *v13;
  unsigned __int8 v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  _QWORD *v21;
  int v22;
  char v23;
  _BYTE v24[2];
  _BYTE __s1[6];

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != 1919315316)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (a2 && *(_DWORD *)(a1 + 92) == 1953326706)
  {
    *(_QWORD *)(a1 + 16) = a2;
    *(_QWORD *)(a1 + 32) = 0x20000;
    v6 = platform_valloc(*(_QWORD *)(a1 + 8), 0x20000uLL);
    *(_QWORD *)(a1 + 40) = v6;
    if (!v6)
    {
      v13 = __error();
      v14 = strerror(*v13);
      v10 = "Could not allocate read buffer: %s";
      v23 = v14;
      v11 = a3;
      v12 = 409;
      goto LABEL_10;
    }
    *(_QWORD *)(a1 + 48) = v6;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
    if (populate_read_buffer(a1, *(_QWORD *)(a1 + 32), a3))
    {
      v10 = "Could not populate the read buffer";
      v11 = a3;
      v12 = 425;
LABEL_10:
      capture_error(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v12, (uint64_t)"data_archive_decoder_set_stream", v10, v7, v8, v9, v23);
      return 0xFFFFFFFFLL;
    }
    if (!*(_QWORD *)(a1 + 72))
      return 0;
    v15 = *(_QWORD *)(a1 + 48);
    v16 = *(_QWORD *)(a1 + 64);
    if (v16 < 0x200)
    {
LABEL_15:
      if (!*(_DWORD *)(a1 + 84))
      {
        if (check_cpio_header(a1, v15, v16, a3))
        {
          v10 = "Could not check for a cpio header";
          v11 = a3;
          v12 = 461;
          goto LABEL_10;
        }
        if (!*(_DWORD *)(a1 + 84))
        {
          result = is_pkzip_header(a1, v15, v16);
          if ((_DWORD)result)
          {
            result = 0;
            *(_DWORD *)(a1 + 84) = 9;
          }
          return result;
        }
      }
      return 0;
    }
    byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 64));
    byte_stream_advance(*(_QWORD *)(a1 + 24), 257);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not advance to the magic offset";
      v21 = a3;
      v22 = 805;
    }
    else
    {
      byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __s1, 6uLL);
      if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
      {
        v20 = "Could not read the potential magic value";
        v21 = a3;
        v22 = 815;
      }
      else
      {
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v24, 2uLL);
        if (!byte_stream_exception(*(_QWORD *)(a1 + 24)))
        {
          if (!platform_memcmp(*(_QWORD *)(a1 + 8), __s1, "ustar", 6uLL)
            && !platform_memcmp(*(_QWORD *)(a1 + 8), v24, "00", 2uLL))
          {
            *(_DWORD *)(a1 + 84) = 2;
          }
          goto LABEL_15;
        }
        v20 = "Could not read the potential version value";
        v21 = a3;
        v22 = 825;
      }
    }
    capture_error(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v22, (uint64_t)"check_tar_posix_header", v20, v17, v18, v19, v23);
    v10 = "Could not check for a tar POSIX header";
    v11 = a3;
    v12 = 445;
    goto LABEL_10;
  }
  return result;
}

uint64_t populate_read_buffer(uint64_t a1, size_t a2, _QWORD *a3)
{
  size_t v4;
  void *v6;
  uint64_t v7;
  size_t v8;
  unint64_t v9;
  int64x2_t v10;
  uint64_t result;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v4 = *(_QWORD *)(a1 + 64);
  if (v4 >= a2)
    return 0;
  v6 = *(void **)(a1 + 40);
  if (v4)
  {
    memmove(v6, *(const void **)(a1 + 48), v4);
    v6 = *(void **)(a1 + 40);
    *(_QWORD *)(a1 + 48) = v6;
    v7 = *(_QWORD *)(a1 + 64);
  }
  else
  {
    v7 = 0;
    *(_QWORD *)(a1 + 48) = v6;
  }
  v8 = *(_QWORD *)(a1 + 32) - v7;
  v9 = data_stream_read(*(_QWORD *)(a1 + 16), (char *)v6 + v7, v8);
  if (v9 == -1)
  {
    v12 = __error();
    strerror(*v12);
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 4061, (uint64_t)"populate_read_buffer", "Could not read additional %ld bytes onto read buffer: %s\n", v13, v14, v15, v8);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v10 = vaddq_s64(*(int64x2_t *)(a1 + 64), vdupq_n_s64(v9));
    *(int64x2_t *)(a1 + 64) = v10;
    if (v10.i64[0])
      return 0;
    result = 0;
    *(_BYTE *)(a1 + 80) = 1;
  }
  return result;
}

uint64_t check_cpio_header(uint64_t a1, uint64_t a2, unint64_t a3, _QWORD *a4)
{
  char v4;
  uint64_t result;
  int uint16;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t string;

  if (a3 < 2)
    return 0;
  byte_stream_attach(*(_QWORD *)(a1 + 24), a2, a3);
  uint16 = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
  if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 867, (uint64_t)"check_cpio_header", "Could not read the potential binary magic value", v11, v12, v13, v4);
    return 0xFFFFFFFFLL;
  }
  if (uint16 == 51057)
  {
    result = 0;
    v14 = 8;
    goto LABEL_9;
  }
  if (uint16 == 29127)
  {
    result = 0;
    v14 = 7;
LABEL_9:
    *(_DWORD *)(a1 + 84) = v14;
    return result;
  }
  if (a3 < 6)
    return 0;
  byte_stream_attach(*(_QWORD *)(a1 + 24), a2, a3);
  string = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
  if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    return 0;
  result = 0;
  if (string > 29126)
  {
    if (string == 29143)
    {
      result = 0;
      v14 = 4;
      goto LABEL_9;
    }
    if (string == 29127)
    {
      result = 0;
      v14 = 3;
      goto LABEL_9;
    }
  }
  else
  {
    if (string == 29121)
    {
      result = 0;
      v14 = 6;
      goto LABEL_9;
    }
    if (string == 29122)
    {
      result = 0;
      v14 = 5;
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t is_pkzip_header(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;
  int uint32;
  BOOL v6;
  int v7;

  if (a3 < 4)
    return 0;
  byte_stream_attach(*(_QWORD *)(a1 + 24), a2, a3);
  uint32 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
  result = 1;
  if (uint32 <= 101075791)
  {
    v6 = uint32 == 67324752;
    v7 = 101010256;
  }
  else
  {
    v6 = uint32 == 101075792 || uint32 == 134695760;
    v7 = 808471376;
  }
  if (!v6 && uint32 != v7)
    return 0;
  return result;
}

uint64_t data_archive_decoder_get_type(_DWORD *a1)
{
  if (a1 && *a1 == 1919315316 && a1[23] == 1953326706)
    return a1[21];
  puts("Invalid decoder?");
  return 0;
}

_QWORD *data_archive_decoder_read_entry(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  _QWORD *v11;
  int v12;
  _QWORD *v13;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  _QWORD *v25;
  int v26;
  int v27;
  char v28;

  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    v10 = "Invalid decoder";
    v11 = a2;
    v12 = 527;
    goto LABEL_7;
  }
  if (*(_BYTE *)(a1 + 89))
  {
    v10 = "End of archive";
    v11 = a2;
    v12 = 537;
LABEL_7:
    capture_error(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v12, (uint64_t)"data_archive_decoder_read_entry", v10, a6, a7, a8, v28);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 64) && populate_read_buffer(a1, *(_QWORD *)(a1 + 32), a2))
  {
    v10 = "Could not populate the read buffer";
    v11 = a2;
    v12 = 550;
    goto LABEL_7;
  }
  v15 = darc_format_entry_new(*(_QWORD *)(a1 + 8), 0);
  v13 = v15;
  if (!v15)
  {
    capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 562, (uint64_t)"data_archive_decoder_read_entry", "Could not create empty data format entry", v18, v19, v20, v28);
    return v13;
  }
  if (*(_BYTE *)(a1 + 80))
  {
    if (!darc_format_entry_set_type(v15, 1))
    {
      *(_BYTE *)(a1 + 89) = 1;
      return v13;
    }
    v24 = "Could not set EoA entry type";
    v25 = a2;
    v26 = 575;
    goto LABEL_15;
  }
  v27 = *(_DWORD *)(a1 + 84);
  if (v27 == 9)
  {
    if (!parse_entry_pkzip(a1, v15, a2))
      return v13;
    v24 = "Could not parse PKZip entry";
    v25 = a2;
    v26 = 620;
    goto LABEL_15;
  }
  if (v27 == 3)
  {
    if (!parse_entry_cpio(a1, v15, a2, v16, v17, v18, v19, v20))
      return v13;
    v24 = "Could not parse CPIO ASCII entry";
    v25 = a2;
    v26 = 609;
    goto LABEL_15;
  }
  if (v27 != 2)
  {
    capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 628, (uint64_t)"data_archive_decoder_read_entry", "Unknown data format: %d", v18, v19, v20, *(_DWORD *)(a1 + 84));
    return v13;
  }
  if (parse_entry_posix_ustar(a1, v15, a2))
  {
    v24 = "Could not parse POSIX ustar entry";
    v25 = a2;
    v26 = 598;
LABEL_15:
    capture_error(v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v26, (uint64_t)"data_archive_decoder_read_entry", v24, v21, v22, v23, v28);
    darc_format_entry_free(v13);
    return 0;
  }
  return v13;
}

uint64_t parse_entry_posix_ustar(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  _QWORD *v11;
  int v12;
  uint64_t result;
  _DWORD *v14;
  _DWORD *v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  _QWORD *v21;
  int v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v29;
  size_t v30;
  __int16 string;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  __int16 v38;
  __int16 v39;
  int v40;
  size_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  size_t v45;
  size_t v46;
  int v47;
  int v48;
  size_t v49;
  size_t v50;
  size_t v51;
  uint64_t v52;
  char v53;
  char v54;
  __int16 v55;
  int __s1;
  __int16 v57;
  char v58;
  char __str[8];
  int v60;
  char v61[16];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  _BYTE v69[28];
  _OWORD v70[2];
  _OWORD v71[2];
  _BYTE v72[101];
  _BYTE v73[8];
  _BYTE __s[101];
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 56);
  if (require_minimum_amount(a1, 0x200uLL, (char)"POSIX ustar header", a3))
  {
    v10 = "Minimum amount necessary for POSIX ustar header is unavailable";
    v11 = a3;
    v12 = 1022;
LABEL_3:
    capture_error(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v12, (uint64_t)"parse_entry_posix_ustar", v10, v7, v8, v9, v53);
    return 0xFFFFFFFFLL;
  }
  v14 = platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x28uLL);
  if (!v14)
  {
    v23 = __error();
    strerror(*v23);
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1030, (uint64_t)"parse_entry_posix_ustar", "Could not allocate %ld bytes for POSIX ustar header: %s", v24, v25, v26, 40);
    return 0xFFFFFFFFLL;
  }
  v15 = v14;
  v16 = *(_BYTE **)(a1 + 48);
  if (*v16)
  {
LABEL_8:
    *v14 = 2;
    byte_stream_attach(*(_QWORD *)(a1 + 24), (uint64_t)v16, 0x200uLL);
    memset(__s, 0, sizeof(__s));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __s, 0x64uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar name field";
      v21 = a3;
      v22 = 1113;
      goto LABEL_101;
    }
    v30 = strlen(__s);
    if (darc_format_entry_set_attribute((uint64_t)a2, "name", __s, v30 + 1))
    {
      v20 = "Could not set name attribute";
      v21 = a3;
      v22 = 1123;
      goto LABEL_101;
    }
    string = byte_stream_read_string(*(_QWORD *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar mode field";
      v21 = a3;
      v22 = 1134;
      goto LABEL_101;
    }
    *((_WORD *)v15 + 2) = string | 0x8000;
    v32 = byte_stream_read_string(*(_QWORD *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar uid field";
      v21 = a3;
      v22 = 1148;
      goto LABEL_101;
    }
    v15[2] = v32;
    v33 = byte_stream_read_string(*(_QWORD *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar gid field";
      v21 = a3;
      v22 = 1161;
      goto LABEL_101;
    }
    v15[3] = v33;
    v34 = byte_stream_read_string(*(_QWORD *)(a1 + 24), 0xCuLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar size field";
      v21 = a3;
      v22 = 1174;
      goto LABEL_101;
    }
    *((_QWORD *)v15 + 2) = v34;
    v35 = byte_stream_read_string(*(_QWORD *)(a1 + 24), 0xCuLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar mtime field";
      v21 = a3;
      v22 = 1187;
      goto LABEL_101;
    }
    *((_QWORD *)v15 + 3) = v35;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v73, 8uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar checksum field";
      v21 = a3;
      v22 = 1202;
      goto LABEL_101;
    }
    v58 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &v58, 1uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar type flag field";
      v21 = a3;
      v22 = 1215;
      goto LABEL_101;
    }
    if (v58 > 102)
    {
      if (v58 == 103)
      {
        v36 = 0;
        v37 = 1;
      }
      else
      {
        if (v58 != 120)
        {
LABEL_43:
          if ((v58 - 65) > 0x19)
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1302, (uint64_t)"parse_entry_posix_ustar_header_decode", "Unrecognize tar type flag value: %c", v17, v18, v19, v58);
LABEL_102:
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1037, (uint64_t)"parse_entry_posix_ustar", "Could not decode POSIX ustar header", v42, v43, v44, v54);
            platform_free(*(_QWORD *)(a1 + 8), v15);
            return 0xFFFFFFFFLL;
          }
          *__error() = 45;
          v20 = "Vendor specific extensions (POSIX.1-1988)";
          v21 = a3;
          v22 = 1298;
LABEL_101:
          capture_error(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v22, (uint64_t)"parse_entry_posix_ustar_header_decode", v20, v17, v18, v19, v53);
          goto LABEL_102;
        }
        v37 = 0;
        v36 = 1;
      }
    }
    else
    {
      v36 = 0;
      v37 = 0;
      switch(v58)
      {
        case '0':
        case '1':
          break;
        case '2':
          v36 = 0;
          v37 = 0;
          v38 = *((_WORD *)v15 + 2) | 0xA000;
          goto LABEL_50;
        case '3':
          v36 = 0;
          v37 = 0;
          v38 = v15[1] & 0x5FFF | 0x2000;
          goto LABEL_50;
        case '4':
          v36 = 0;
          v37 = 0;
          v39 = v15[1] & 0x1FFF | 0x6000;
          goto LABEL_48;
        case '5':
          v36 = 0;
          v37 = 0;
          v39 = v15[1] & 0x3FFF | 0x4000;
LABEL_48:
          *((_WORD *)v15 + 2) = v39;
          break;
        case '6':
          v36 = 0;
          v37 = 0;
          v38 = v15[1] & 0x6FFF | 0x1000;
LABEL_50:
          *((_WORD *)v15 + 2) = v38;
          break;
        case '7':
          *__error() = 45;
          v20 = "I do not support contiguous files";
          v21 = a3;
          v22 = 1277;
          goto LABEL_101;
        default:
          v37 = 0;
          if (v58)
            goto LABEL_43;
          break;
      }
    }
    memset(v72, 0, sizeof(v72));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v72, 0x64uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar linkname field";
      v21 = a3;
      v22 = 1316;
      goto LABEL_101;
    }
    v40 = v37;
    v41 = strlen(v72);
    if (v41 && darc_format_entry_set_attribute((uint64_t)a2, "tar linkname", v72, v41 + 1))
    {
      v20 = "Could not set linkname attribute";
      v21 = a3;
      v22 = 1328;
      goto LABEL_101;
    }
    v57 = 0;
    __s1 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &__s1, 6uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the POSIX ustar magic field";
      v21 = a3;
      v22 = 1342;
      goto LABEL_101;
    }
    if (platform_memcmp(*(_QWORD *)(a1 + 8), &__s1, "ustar", 6uLL))
    {
      v20 = "Invalid magic for POSIX ustar archive";
      v21 = a3;
      v22 = 1348;
      goto LABEL_101;
    }
    v55 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &v55, 2uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the tar version field";
      v21 = a3;
      v22 = 1361;
      goto LABEL_101;
    }
    if (platform_memcmp(*(_QWORD *)(a1 + 8), &v55, "00", 2uLL))
    {
      v20 = "Invalid version for POSIX ustar archive";
      v21 = a3;
      v22 = 1367;
      goto LABEL_101;
    }
    memset(v71, 0, sizeof(v71));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v71, 0x20uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the POSIX ustar uname field";
      v21 = a3;
      v22 = 1380;
      goto LABEL_101;
    }
    v45 = strlen((const char *)v71);
    if (v45 && darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar user name", v71, v45 + 1))
    {
      v20 = "Could not set POSIX ustar user name attribute";
      v21 = a3;
      v22 = 1392;
      goto LABEL_101;
    }
    memset(v70, 0, sizeof(v70));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v70, 0x20uLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the POSIX ustar group name field";
      v21 = a3;
      v22 = 1406;
      goto LABEL_101;
    }
    v46 = strlen((const char *)v70);
    if (v46 && darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar group name", v70, v46 + 1))
    {
      v20 = "Could not set POSIX ustar group name attribute";
      v21 = a3;
      v22 = 1418;
      goto LABEL_101;
    }
    v47 = byte_stream_read_string(*(_QWORD *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the POSIX ustar devmajor field";
      v21 = a3;
      v22 = 1430;
      goto LABEL_101;
    }
    v15[8] = v47;
    v48 = byte_stream_read_string(*(_QWORD *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the POSIX ustar devminor field";
      v21 = a3;
      v22 = 1443;
      goto LABEL_101;
    }
    v15[9] = v48;
    v68 = 0u;
    memset(v69, 0, sizeof(v69));
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    *(_OWORD *)v61 = 0u;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v61, 0x9BuLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the POSIX ustar prefix field";
      v21 = a3;
      v22 = 1458;
      goto LABEL_101;
    }
    v49 = strlen(v61);
    if (v49)
    {
      v50 = v49;
      bzero(__str, 0x400uLL);
      if (v61[v50] == 47)
        snprintf(__str, 0x400uLL, "%s%s");
      else
        snprintf(__str, 0x400uLL, "%s/%s");
      v51 = strlen(__str);
      if (darc_format_entry_set_attribute((uint64_t)a2, "name", __str, v51 + 1))
      {
        v20 = "Could not reset POSIX ustar name attribute";
        v21 = a3;
        v22 = 1482;
        goto LABEL_101;
      }
    }
    v60 = 0;
    *(_QWORD *)__str = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __str, 0xCuLL);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v20 = "Could not parse the POSIX ustar padding field";
      v21 = a3;
      v22 = 1496;
      goto LABEL_101;
    }
    *(_QWORD *)(a1 + 48) += 512;
    *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF720);
    if (v40)
    {
      *v15 = 3;
      *__error() = 45;
      v20 = "This entry has global extended metadata";
      v21 = a3;
      v22 = 1512;
      goto LABEL_101;
    }
    if (v36)
    {
      *v15 = 4;
      if (parse_entry_posix_ustar_extended_metadata(a1, *((_QWORD *)v15 + 2), a3))
      {
        v20 = "Could not parse the POSIX ustar extended metadata";
        v21 = a3;
        v22 = 1527;
        goto LABEL_101;
      }
    }
    else
    {
      v52 = *((_QWORD *)v15 + 2);
      if (v52 >= 1 && darc_format_entry_set_size((uint64_t)a2, v52))
      {
        v20 = "Could not set entry size";
        v21 = a3;
        v22 = 1543;
        goto LABEL_101;
      }
    }
    if (darc_format_entry_set_type(a2, 2))
    {
      v20 = "Could not set entry type";
      v21 = a3;
      v22 = 1553;
      goto LABEL_101;
    }
  }
  else
  {
    v27 = 1;
    while (v27 != 512)
    {
      if (v16[v27++])
      {
        if ((unint64_t)(v27 - 2) < 0x1FF)
          goto LABEL_8;
        break;
      }
    }
    darc_format_entry_set_type(a2, 3);
    *v15 = 1;
    *(_QWORD *)(a1 + 48) += 512;
    *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF720);
  }
  v29 = darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar header", v15, 0x28uLL);
  platform_free(*(_QWORD *)(a1 + 8), v15);
  if (v29)
  {
    v10 = "Could not set POSIX ustar header attribute";
    v11 = a3;
    v12 = 1052;
    goto LABEL_3;
  }
  result = darc_format_entry_set_range((uint64_t)a2, v6, *(_QWORD *)(a1 + 56) - v6);
  if ((_DWORD)result)
  {
    v10 = "Could not set entry range";
    v11 = a3;
    v12 = 1065;
    goto LABEL_3;
  }
  return result;
}

uint64_t parse_entry_cpio(uint64_t a1, _DWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  _QWORD *v18;
  int v19;
  uint64_t result;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  _QWORD *v27;
  int v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  size_t v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  char v52;

  v11 = *(_QWORD *)(a1 + 56);
  if (!*(_BYTE *)(a1 + 88))
  {
    if (require_minimum_amount(a1, 0x4CuLL, (char)"cpio header", a3))
    {
      v16 = "parse_entry_cpio_header";
      v17 = "Minimum amount necessary for CPIO header is unavailable";
      v18 = a3;
      v19 = 1655;
LABEL_12:
      capture_error(v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v19, (uint64_t)v16, v17, a6, a7, a8, v51);
      return 0xFFFFFFFFLL;
    }
    v21 = (uint64_t *)platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x48uLL);
    if (!v21)
    {
      v29 = __error();
      strerror(*v29);
      capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1663, (uint64_t)"parse_entry_cpio_header", "Could not allocate %ld bytes for cpio_header: %s", v30, v31, v32, 72);
      return 0xFFFFFFFFLL;
    }
    v22 = v21;
    byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 0x4CuLL);
    *v22 = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 2) = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    v22[2] = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    *((_WORD *)v22 + 12) = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 7) = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 8) = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    *((_WORD *)v22 + 18) = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 10) = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    v22[6] = byte_stream_read_string(*(_QWORD *)(a1 + 24), 0xBuLL, 8);
    v22[7] = byte_stream_read_string(*(_QWORD *)(a1 + 24), 6uLL, 8);
    v22[8] = byte_stream_read_string(*(_QWORD *)(a1 + 24), 0xBuLL, 8);
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v26 = "Could not parse the CPIO header";
      v27 = a3;
      v28 = 1743;
    }
    else if (*v22 == 29127)
    {
      *(_QWORD *)(a1 + 48) += 76;
      *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF730);
      v33 = v22[8];
      if (v33 < 1 || !darc_format_entry_set_size((uint64_t)a2, v33))
      {
        v37 = v22[7];
        if (v37)
        {
          if (require_minimum_amount(a1, v37, (char)"cpio entry name", a3))
          {
            v26 = "Minimum amount necessary for CPIO name is unavailable";
            v27 = a3;
            v28 = 1785;
            goto LABEL_26;
          }
          byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), v22[7]);
          v38 = platform_calloc(*(_QWORD *)(a1 + 8), v22[7], 1uLL);
          if (!v38)
          {
            v43 = v22[7];
            v44 = __error();
            strerror(*v44);
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1794, (uint64_t)"parse_entry_cpio_header_decode", "Could not allocate %ld bytes: %s", v45, v46, v47, v43);
            goto LABEL_27;
          }
          v39 = v38;
          byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v38, v22[7]);
          if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1802, (uint64_t)"parse_entry_cpio_header_decode", "Could not parse the CPIO name", v40, v41, v42, v51);
            free(v39);
            goto LABEL_27;
          }
          if (darc_format_entry_set_attribute((uint64_t)a2, "name", v39, v22[7]))
          {
            v26 = "Could not set name attribute";
            v27 = a3;
            v28 = 1815;
            goto LABEL_26;
          }
          if (platform_strlen(*(_QWORD *)(a1 + 8), (char *)v39) == 10
            && !platform_strncmp(*(_QWORD *)(a1 + 8), (char *)v39, "TRAILER!!!", 0xAuLL))
          {
            *(_BYTE *)(a1 + 88) = 1;
          }
          platform_free(*(_QWORD *)(a1 + 8), v39);
          v48 = v22[7];
          v49 = *(_QWORD *)(a1 + 56) + v48;
          *(_QWORD *)(a1 + 48) += v48;
          *(_QWORD *)(a1 + 56) = v49;
          *(_QWORD *)(a1 + 64) -= v48;
        }
        v50 = darc_format_entry_set_attribute((uint64_t)a2, "cpio header", v22, 0x48uLL);
        platform_free(*(_QWORD *)(a1 + 8), v22);
        if (v50)
        {
          v16 = "parse_entry_cpio_header";
          v17 = "Could not set cpio header attribute";
          v18 = a3;
          v19 = 1685;
        }
        else if (darc_format_entry_set_type(a2, 4))
        {
          v16 = "parse_entry_cpio_header";
          v17 = "Could not set entry type";
          v18 = a3;
          v19 = 1696;
        }
        else
        {
          result = darc_format_entry_set_range((uint64_t)a2, v11, *(_QWORD *)(a1 + 56) - v11);
          if (!(_DWORD)result)
            return result;
          v16 = "parse_entry_cpio_header";
          v17 = "Could not set entry range";
          v18 = a3;
          v19 = 1705;
        }
        goto LABEL_12;
      }
      v26 = "Could not set entry size";
      v27 = a3;
      v28 = 1764;
    }
    else
    {
      v26 = "Invalid CPIO magic: %lld";
      v51 = *v22;
      v27 = a3;
      v28 = 1749;
    }
LABEL_26:
    capture_error(v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v28, (uint64_t)"parse_entry_cpio_header_decode", v26, v23, v24, v25, v51);
LABEL_27:
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1670, (uint64_t)"parse_entry_cpio_header", "Could not decode CPIO header", v34, v35, v36, v52);
    platform_free(*(_QWORD *)(a1 + 8), v22);
    return 0xFFFFFFFFLL;
  }
  while (!*(_BYTE *)(a1 + 80))
  {
    v12 = *(_QWORD *)(a1 + 64);
    if (v12)
    {
      v13 = v12 - 1;
      v14 = *(_QWORD *)(a1 + 48) + 1;
      while (!*(_BYTE *)(v14 - 1))
      {
        v15 = *(_QWORD *)(a1 + 56) + 1;
        *(_QWORD *)(a1 + 48) = v14;
        *(_QWORD *)(a1 + 56) = v15;
        *(_QWORD *)(a1 + 64) = v13--;
        ++v14;
        if (v13 == -1)
          goto LABEL_7;
      }
      v16 = "parse_entry_cpio_padding";
      v17 = "Could not populate the read buffer";
      v18 = a3;
      v19 = 1857;
      goto LABEL_12;
    }
LABEL_7:
    if (populate_read_buffer(a1, *(_QWORD *)(a1 + 32), a3))
    {
      v16 = "parse_entry_cpio_padding";
      v17 = "Could not populate the read buffer";
      v18 = a3;
      v19 = 1867;
      goto LABEL_12;
    }
  }
  if (darc_format_entry_set_type(a2, 5))
  {
    v16 = "parse_entry_cpio_padding";
    v17 = "Could not set entry type";
    v18 = a3;
    v19 = 1879;
    goto LABEL_12;
  }
  result = darc_format_entry_set_range((uint64_t)a2, v11, *(_QWORD *)(a1 + 56) - v11);
  if ((_DWORD)result)
  {
    v16 = "parse_entry_cpio_padding";
    v17 = "Could not set entry range";
    v18 = a3;
    v19 = 1888;
    goto LABEL_12;
  }
  return result;
}

uint64_t parse_entry_pkzip(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t result;
  int uint32;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int64x2_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  _QWORD *v17;
  int v18;
  int v19;
  unsigned int v20;
  _QWORD *v21;
  _QWORD *v22;
  const char *v23;
  const char *v24;
  _QWORD *v25;
  int v26;
  _QWORD *v27;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v33;
  uint64_t v34;
  int v35;
  unsigned int uint16;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _DWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  size_t v67;
  void *v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  const char *v74;
  _QWORD *v75;
  int v76;
  uint64_t v77;
  size_t v78;
  void *v79;
  __int16 v80;
  int *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  __int16 v85;
  int *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  size_t v92;
  void *v93;
  __int16 v94;
  int *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  _DWORD *v104;
  _QWORD *v105;

  v6 = *(_QWORD *)(a1 + 56);
  if (require_minimum_amount(a1, 4uLL, (char)"PKZip signature", a3))
    return 0xFFFFFFFFLL;
  v104 = a2;
  v105 = a3;
  while (1)
  {
    byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 4uLL);
    uint32 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
    if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
    {
      v15 = "parse_entry_pkzip";
      v16 = "Could not parse the PKZip entry";
      v17 = a3;
      v18 = 1936;
      goto LABEL_61;
    }
    if (uint32 > 101075791)
    {
      if (uint32 <= 134630223)
      {
        if (uint32 == 101075792)
        {
          v31 = a3;
          if (require_minimum_amount(a1, 0x38uLL, (char)"PKZip ZIP64 end of central directory read", a3))
            return 0xFFFFFFFFLL;
          v30 = platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x40uLL);
          if (!v30)
          {
            v48 = __error();
            strerror(*v48);
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3041, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_record", "Could not allocate %ld bytes for PKZip ZIP64 central directory header: %s", v49, v50, v51, 64);
            return 0xFFFFFFFFLL;
          }
          v22 = v30;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 0x38uLL);
          *(_DWORD *)v22 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          v22[1] = byte_stream_read_uint64(*(_QWORD *)(a1 + 24));
          *((_WORD *)v22 + 8) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
          *((_WORD *)v22 + 9) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
          *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          v22[4] = byte_stream_read_uint64(*(_QWORD *)(a1 + 24));
          v22[5] = byte_stream_read_uint64(*(_QWORD *)(a1 + 24));
          v22[6] = byte_stream_read_uint64(*(_QWORD *)(a1 + 24));
          v22[7] = byte_stream_read_uint64(*(_QWORD *)(a1 + 24));
          if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
          {
            v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
            v24 = "Could not parse the PKZip ZIP64 end of central directory record";
            v25 = a3;
            v26 = 3062;
            goto LABEL_97;
          }
          if (*(_DWORD *)v22 != 101075792)
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3069, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_record", "Invalid PKZip ZIP64 end of central directory record signature: %04x", v9, v10, v11, *(_DWORD *)v22);
            goto LABEL_98;
          }
          v61 = *(_QWORD *)(a1 + 48);
          v62 = *(_QWORD *)(a1 + 56);
          *(_QWORD *)(a1 + 48) = v61 + 56;
          *(_QWORD *)(a1 + 56) = v62 + 56;
          v63 = *(_QWORD *)(a1 + 64) - 56;
          *(_QWORD *)(a1 + 64) = v63;
          v64 = v22[1];
          if (v64 - 56 >= 1)
          {
            *(_QWORD *)(a1 + 48) = v61 + v64;
            *(_QWORD *)(a1 + 56) = v64 + v62;
            *(_QWORD *)(a1 + 64) = v63 - (v64 - 56);
            v15 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
            v16 = "TODO: parse ZIP64 extensible data";
            v17 = a3;
            v18 = 3087;
            goto LABEL_61;
          }
          v34 = (uint64_t)a2;
          if (!darc_format_entry_set_type(a2, 12))
          {
            if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip ZIP64 end of central directory record", v22, 0x40uLL))
            {
              v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
              v24 = "Could not set PKZip ZIP64 end of central directory record attribute";
              v25 = v105;
              v26 = 3110;
              goto LABEL_97;
            }
            goto LABEL_124;
          }
          v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
          v24 = "Could not set entry type";
          v25 = v105;
          v26 = 3098;
          goto LABEL_97;
        }
        if (uint32 == 117853008)
        {
          v31 = a3;
          if (require_minimum_amount(a1, 0x14uLL, (char)"PKZip ZIP64 end of central directory locator read", a3))return 0xFFFFFFFFLL;
          v33 = platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x18uLL);
          if (!v33)
          {
            v52 = __error();
            strerror(*v52);
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3155, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_locator", "Could not allocate %ld bytes for PKZip ZIP64 central directory locator: %s", v53, v54, v55, 24);
            return 0xFFFFFFFFLL;
          }
          v22 = v33;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 0x14uLL);
          *(_DWORD *)v22 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          *((_DWORD *)v22 + 1) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          v22[1] = byte_stream_read_uint64(*(_QWORD *)(a1 + 24));
          *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          v34 = (uint64_t)a2;
          if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
          {
            v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            v24 = "Could not parse the PKZip ZIP64 end of central directory locator";
            v25 = v105;
            v26 = 3170;
            goto LABEL_97;
          }
          if (*(_DWORD *)v22 != 117853008)
          {
            capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3177, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_locator", "Invalid PKZip ZIP64 end of central directory record signature: %04x", v9, v10, v11, *(_DWORD *)v22);
            goto LABEL_98;
          }
          *(_QWORD *)(a1 + 48) += 20;
          *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF750);
          if (darc_format_entry_set_type(a2, 13))
          {
            v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            v24 = "Could not set entry type";
            v25 = v105;
            v26 = 3191;
          }
          else
          {
            if (!darc_format_entry_set_attribute((uint64_t)a2, "pkzip ZIP64 end of central directory locator", v22, 0x18uLL))goto LABEL_124;
            v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            v24 = "Could not set PKZip ZIP64 end of central directory locator attribute";
            v25 = v105;
            v26 = 3203;
          }
          goto LABEL_97;
        }
      }
      else
      {
        if (uint32 == 134630224)
        {
          v31 = a3;
          if (require_minimum_amount(a1, 8uLL, (char)"PKZip archive extra data", a3))
            return 0xFFFFFFFFLL;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 8uLL);
          v19 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          v20 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
          if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
          {
            v15 = "parse_entry_pkzip_archive_extra_data";
            v16 = "Could not parse the PKZip data descriptor";
            v17 = a3;
            v18 = 2516;
            goto LABEL_61;
          }
          if (v19 == 134630224)
          {
            *(_QWORD *)(a1 + 48) += 8;
            *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF770);
            if (!v20)
            {
              v34 = (uint64_t)a2;
              if (!darc_format_entry_set_type(a2, 9))
                goto LABEL_59;
              v15 = "parse_entry_pkzip_archive_extra_data";
              v16 = "Could not set entry type";
              v17 = v105;
              v18 = 2554;
              goto LABEL_61;
            }
            if (!require_minimum_amount(a1, v20, (char)"PKZip extra data", a3))
            {
              v38 = *(_QWORD *)(a1 + 56) + v20;
              *(_QWORD *)(a1 + 48) += v20;
              *(_QWORD *)(a1 + 56) = v38;
              *(_QWORD *)(a1 + 64) -= v20;
              v15 = "parse_entry_pkzip_archive_extra_data";
              v16 = "TODO: parse extra field";
              v17 = a3;
              v18 = 2543;
              goto LABEL_61;
            }
          }
          else
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2522, (uint64_t)"parse_entry_pkzip_archive_extra_data", "Invalid PKZip archive extra signature: %04x", v9, v10, v11, v19);
          }
          return 0xFFFFFFFFLL;
        }
        if (uint32 == 134695760 || uint32 == 808471376)
          goto LABEL_55;
      }
      goto LABEL_21;
    }
    if (uint32 <= 84233039)
    {
      if (uint32 != 33639248)
      {
        if (uint32 != 67324752)
          goto LABEL_21;
        v27 = a3;
        if (require_minimum_amount(a1, 0x1EuLL, (char)"PKZip local header", a3))
          return 0xFFFFFFFFLL;
        v29 = platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x20uLL);
        if (!v29)
        {
          v44 = __error();
          strerror(*v44);
          capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2159, (uint64_t)"parse_entry_pkzip_local_header", "Could not allocate %ld bytes for PKZip local header: %s\n", v45, v46, v47, 32);
          return 0xFFFFFFFFLL;
        }
        v22 = v29;
        byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 0x1EuLL);
        *(_DWORD *)v22 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
        *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
        *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
        *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
        *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
        *((_WORD *)v22 + 6) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
        *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
        *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
        *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
        *((_WORD *)v22 + 14) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
        *((_WORD *)v22 + 15) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
        if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
        {
          v23 = "parse_entry_pkzip_local_header";
          v24 = "Could not parse the PKZip local header";
          v25 = a3;
          v26 = 2179;
          goto LABEL_97;
        }
        if (*(_DWORD *)v22 != 67324752)
        {
          capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2186, (uint64_t)"parse_entry_pkzip_local_header", "Invalid PKZip local header signature: %04x", v9, v10, v11, *(_DWORD *)v22);
          goto LABEL_98;
        }
        *(_QWORD *)(a1 + 48) += 30;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF780);
        if (darc_format_entry_set_attribute((uint64_t)v104, "pkzip local header", v22, 0x20uLL))
        {
          v23 = "parse_entry_pkzip_local_header";
          v24 = "Could not set PKZip local header attribute";
          v25 = a3;
          v26 = 2204;
          goto LABEL_97;
        }
        v77 = *((unsigned int *)v22 + 5);
        if ((_DWORD)v77 && darc_format_entry_set_size((uint64_t)v104, v77))
        {
          v23 = "parse_entry_pkzip_local_header";
          v24 = "Could not set entry size";
          v25 = a3;
          v26 = 2215;
          goto LABEL_97;
        }
        if (*((_WORD *)v22 + 14))
        {
          if (require_minimum_amount(a1, *((unsigned __int16 *)v22 + 14), (char)"PKZip file name", a3))
            goto LABEL_98;
          byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), *((unsigned __int16 *)v22 + 14));
          v78 = *((unsigned __int16 *)v22 + 14) + 1;
          v79 = platform_calloc(*(_QWORD *)(a1 + 8), v78, 1uLL);
          if (!v79)
          {
            v85 = *((_WORD *)v22 + 14);
            v86 = __error();
            strerror(*v86);
            capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2247, (uint64_t)"parse_entry_pkzip_local_header", "Could not allocate %d bytes: %s", v87, v88, v89, v85);
            goto LABEL_98;
          }
          v69 = v79;
          byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v79, *((unsigned __int16 *)v22 + 14));
          if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
          {
            v73 = "parse_entry_pkzip_local_header";
            v74 = "Could not parse the PKZip file name";
            v75 = a3;
            v76 = 2256;
            goto LABEL_143;
          }
          if (darc_format_entry_set_attribute((uint64_t)v104, "name", v69, v78))
          {
            v73 = "parse_entry_pkzip_local_header";
            v74 = "Could not set entry name";
            v75 = a3;
            v76 = 2270;
            goto LABEL_143;
          }
          free(v69);
          v99 = *((unsigned __int16 *)v22 + 14);
          v100 = *(_QWORD *)(a1 + 56) + v99;
          *(_QWORD *)(a1 + 48) += v99;
          *(_QWORD *)(a1 + 56) = v100;
          *(_QWORD *)(a1 + 64) -= v99;
          v27 = a3;
        }
        if (*((_WORD *)v22 + 15)
          && parse_entry_pkzip_extra_field((uint64_t *)a1, (uint64_t)v104, *((unsigned __int16 *)v22 + 15), 1, v27))
        {
          v23 = "parse_entry_pkzip_local_header";
          v24 = "Could not parse local header extra field";
          v25 = v27;
          v26 = 2290;
        }
        else
        {
          if ((*((_WORD *)v22 + 3) & 8) != 0)
          {
            if (darc_format_entry_get_attribute((uint64_t)v104, "pkzip extra field ZIP64", 0) < 1)
              *(_BYTE *)(a1 + 90) = 1;
            else
              *(_BYTE *)(a1 + 91) = 1;
          }
          else
          {
            *(_WORD *)(a1 + 90) = 0;
          }
          v34 = (uint64_t)v104;
          if (!darc_format_entry_set_type(v104, 6))
          {
            free(v22);
            v31 = v105;
            goto LABEL_59;
          }
          v23 = "parse_entry_pkzip_local_header";
          v24 = "Could not set entry type";
          v25 = v105;
          v26 = 2326;
        }
        goto LABEL_97;
      }
      v31 = a3;
      if (require_minimum_amount(a1, 0x2EuLL, (char)"PKZip central directory header", a3))
        return 0xFFFFFFFFLL;
      v21 = platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x30uLL);
      if (!v21)
      {
        v40 = __error();
        strerror(*v40);
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2610, (uint64_t)"parse_entry_pkzip_central_directory_header", "Could not allocate %ld bytes for PKZip central directory header: %s", v41, v42, v43, 48);
        return 0xFFFFFFFFLL;
      }
      v22 = v21;
      byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
      byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 0x2EuLL);
      *(_DWORD *)v22 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 6) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 7) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 14) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 15) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 16) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 17) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 18) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_DWORD *)v22 + 10) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_DWORD *)v22 + 11) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
      {
        v23 = "parse_entry_pkzip_central_directory_header";
        v24 = "Could not parse the PKZip data descriptor";
        v25 = a3;
        v26 = 2638;
        goto LABEL_97;
      }
      if (*(_DWORD *)v22 != 33639248)
      {
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2645, (uint64_t)"parse_entry_pkzip_central_directory_header", "Invalid PKZip central directory header signature: %04x", v9, v10, v11, *(_DWORD *)v22);
        goto LABEL_98;
      }
      *(_QWORD *)(a1 + 48) += 46;
      *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF760);
      v60 = a2;
      if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip central directory header", v22, 0x30uLL))
      {
        v23 = "parse_entry_pkzip_central_directory_header";
        v24 = "Could not set PKZip central directory header attribute";
        v25 = v105;
        v26 = 2663;
        goto LABEL_97;
      }
      if (*((_WORD *)v22 + 14))
      {
        if (require_minimum_amount(a1, *((unsigned __int16 *)v22 + 14), (char)"PKZip file name", v105))
          goto LABEL_98;
        byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), *((unsigned __int16 *)v22 + 14));
        v67 = *((unsigned __int16 *)v22 + 14) + 1;
        v68 = platform_calloc(*(_QWORD *)(a1 + 8), v67, 1uLL);
        if (!v68)
        {
          v80 = *((_WORD *)v22 + 14);
          v81 = __error();
          strerror(*v81);
          capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2694, (uint64_t)"parse_entry_pkzip_central_directory_header", "Could not allocate %d bytes: %s", v82, v83, v84, v80);
          goto LABEL_98;
        }
        v69 = v68;
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v68, *((unsigned __int16 *)v22 + 14));
        if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
        {
          v73 = "parse_entry_pkzip_central_directory_header";
          v74 = "Could not parse the PKZip file name";
          v75 = v105;
          v76 = 2703;
LABEL_143:
          capture_error(v75, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v76, (uint64_t)v73, v74, v70, v71, v72, v103);
          free(v69);
          goto LABEL_98;
        }
        if (darc_format_entry_set_attribute((uint64_t)a2, "name", v69, v67))
        {
          v73 = "parse_entry_pkzip_central_directory_header";
          v74 = "Could not set entry name";
          v75 = v105;
          v76 = 2717;
          goto LABEL_143;
        }
        free(v69);
        v90 = *((unsigned __int16 *)v22 + 14);
        v91 = *(_QWORD *)(a1 + 56) + v90;
        *(_QWORD *)(a1 + 48) += v90;
        *(_QWORD *)(a1 + 56) = v91;
        *(_QWORD *)(a1 + 64) -= v90;
        v31 = v105;
        v60 = a2;
      }
      if (*((_WORD *)v22 + 15)
        && parse_entry_pkzip_extra_field((uint64_t *)a1, (uint64_t)v60, *((unsigned __int16 *)v22 + 15), 0, v31))
      {
        v23 = "parse_entry_pkzip_central_directory_header";
        v24 = "Could not parse central directory header extra field";
        v25 = v31;
        v26 = 2737;
        goto LABEL_97;
      }
      if (*((_WORD *)v22 + 16))
      {
        if (require_minimum_amount(a1, *((unsigned __int16 *)v22 + 16), (char)"PKZip file comment", v31))
          goto LABEL_98;
        byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), *((unsigned __int16 *)v22 + 16));
        v92 = *((unsigned __int16 *)v22 + 16);
        v93 = platform_calloc(*(_QWORD *)(a1 + 8), v92, 1uLL);
        if (!v93)
        {
          v94 = *((_WORD *)v22 + 16);
          v95 = __error();
          strerror(*v95);
          capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2769, (uint64_t)"parse_entry_pkzip_central_directory_header", "Could not allocate %d bytes: %s", v96, v97, v98, v94);
          goto LABEL_98;
        }
        v69 = v93;
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v93, *((unsigned __int16 *)v22 + 16));
        if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
        {
          v73 = "parse_entry_pkzip_central_directory_header";
          v74 = "Could not parse the PKZip file comment";
          v75 = v105;
          v76 = 2778;
          goto LABEL_143;
        }
        if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip central directory file comment", v69, v92))
        {
          v73 = "parse_entry_pkzip_central_directory_header";
          v74 = "Could not set entry file comment";
          v75 = v105;
          v76 = 2787;
          goto LABEL_143;
        }
        free(v69);
        v101 = *((unsigned __int16 *)v22 + 16);
        v102 = *(_QWORD *)(a1 + 56) + v101;
        *(_QWORD *)(a1 + 48) += v101;
        *(_QWORD *)(a1 + 56) = v102;
        *(_QWORD *)(a1 + 64) -= v101;
        v31 = v105;
        v60 = a2;
      }
      if (darc_format_entry_set_type(v60, 10))
      {
        v23 = "parse_entry_pkzip_central_directory_header";
        v24 = "Could not set entry type";
        v25 = v31;
        v26 = 2805;
        goto LABEL_97;
      }
      free(v22);
LABEL_58:
      v34 = (uint64_t)a2;
      goto LABEL_59;
    }
    if (uint32 == 84233040)
      break;
    if (uint32 == 101010256)
    {
      v31 = a3;
      if (require_minimum_amount(a1, 0x16uLL, (char)"PKZip end of central directory read", a3))
        return 0xFFFFFFFFLL;
      v37 = platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x18uLL);
      if (!v37)
      {
        v56 = __error();
        strerror(*v56);
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2920, (uint64_t)"parse_entry_pkzip_end_of_central_directory_record", "Could not allocate %ld bytes for PKZip central directory header: %s", v57, v58, v59, 24);
        return 0xFFFFFFFFLL;
      }
      v22 = v37;
      byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
      byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 0x16uLL);
      *(_DWORD *)v22 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      *((_DWORD *)v22 + 3) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
      *((_WORD *)v22 + 10) = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
      if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
      {
        v23 = "parse_entry_pkzip_end_of_central_directory_record";
        v24 = "Could not parse the PKZip data descriptor";
        v25 = a3;
        v26 = 2939;
        goto LABEL_97;
      }
      if (*(_DWORD *)v22 == 101010256)
      {
        *(_QWORD *)(a1 + 48) += 22;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF740);
        if (*((_WORD *)v22 + 10))
        {
          if (!require_minimum_amount(a1, *((unsigned __int16 *)v22 + 10), (char)".ZIP file comment", a3))
          {
            v65 = *((unsigned __int16 *)v22 + 10);
            v66 = *(_QWORD *)(a1 + 56) + v65;
            *(_QWORD *)(a1 + 48) += v65;
            *(_QWORD *)(a1 + 56) = v66;
            *(_QWORD *)(a1 + 64) -= v65;
            v15 = "parse_entry_pkzip_end_of_central_directory_record";
            v16 = "TODO: parse .ZIP file comment";
            v17 = a3;
            v18 = 2969;
            goto LABEL_61;
          }
LABEL_98:
          free(v22);
          return 0xFFFFFFFFLL;
        }
        v34 = (uint64_t)a2;
        if (darc_format_entry_set_type(a2, 14))
        {
          v23 = "parse_entry_pkzip_end_of_central_directory_record";
          v24 = "Could not set entry type";
          v25 = v105;
          v26 = 2980;
          goto LABEL_97;
        }
        if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip end of central directory record", v22, 0x18uLL))
        {
          v23 = "parse_entry_pkzip_end_of_central_directory_record";
          v24 = "Could not set PKZip end of central directory record attribute";
          v25 = v105;
          v26 = 2992;
          goto LABEL_97;
        }
LABEL_124:
        free(v22);
        goto LABEL_59;
      }
      v23 = "parse_entry_pkzip_end_of_central_directory_record";
      v24 = "Invalid PKZip end of central directory record signature: %04x";
      v103 = *(_DWORD *)v22;
      v25 = a3;
      v26 = 2946;
LABEL_97:
      capture_error(v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v26, (uint64_t)v23, v24, v9, v10, v11, v103);
      goto LABEL_98;
    }
LABEL_21:
    if ((~uint32 & 0x3000000) != 0)
    {
      if (*(unsigned __int8 *)(a1 + 91) | *(unsigned __int8 *)(a1 + 90))
      {
        uint32 = 0;
LABEL_55:
        v34 = (uint64_t)a2;
        v31 = v105;
        if (parse_entry_pkzip_data_descriptor(a1, a2, uint32, v105))
          return 0xFFFFFFFFLL;
LABEL_59:
        result = darc_format_entry_set_range(v34, v6, *(_QWORD *)(a1 + 56) - v6);
        if (!(_DWORD)result)
          return result;
        v15 = "parse_entry_pkzip";
        v16 = "Could not set entry range\n";
        v17 = v31;
        v18 = 2109;
LABEL_61:
        capture_error(v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v18, (uint64_t)v15, v16, v9, v10, v11, v103);
        return 0xFFFFFFFFLL;
      }
      v13 = *(_QWORD *)(a1 + 56) + 1;
      ++*(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 56) = v13;
      v14 = *(_QWORD *)(a1 + 64) - 1;
      *(_QWORD *)(a1 + 64) = v14;
      if (!v14)
      {
        v31 = a3;
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2080, (uint64_t)"parse_entry_pkzip", "Could not find a PKZip signature", v9, v10, v11, v103);
        *(_BYTE *)(a1 + 80) = 1;
        goto LABEL_58;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 48) += 2;
      v12 = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF790);
      *(int64x2_t *)(a1 + 56) = v12;
      v13 = v12.i64[0];
    }
    v6 = v13;
    if (require_minimum_amount(a1, 4uLL, (char)"PKZip signature", a3))
      return 0xFFFFFFFFLL;
  }
  v31 = a3;
  if (require_minimum_amount(a1, 6uLL, (char)"PKZip archive digital signature", a3))
    return 0xFFFFFFFFLL;
  byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
  byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), 6uLL);
  v35 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
  uint16 = byte_stream_read_uint16(*(_QWORD *)(a1 + 24));
  if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
  {
    v15 = "parse_entry_pkzip_digital_signature";
    v16 = "Could not parse the PKZip digital signature";
    v17 = a3;
    v18 = 2858;
    goto LABEL_61;
  }
  if (v35 != 84233040)
  {
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2864, (uint64_t)"parse_entry_pkzip_digital_signature", "Invalid PKZip archive digital signature signature: %04x", v9, v10, v11, v35);
    return 0xFFFFFFFFLL;
  }
  if (!require_minimum_amount(a1, uint16, (char)"PKZip archive digital signature", a3))
  {
    v39 = *(_QWORD *)(a1 + 56) + uint16;
    *(_QWORD *)(a1 + 48) += uint16;
    *(_QWORD *)(a1 + 56) = v39;
    *(_QWORD *)(a1 + 64) -= uint16;
    goto LABEL_58;
  }
  return 0xFFFFFFFFLL;
}

size_t data_archive_decoder_read_data(uint64_t a1, void *__dst, size_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v12;
  size_t v13;
  size_t v14;
  const char *v15;
  _QWORD *v16;
  int v17;
  char v19;

  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    v15 = "Invalid decoder";
    v16 = a4;
    v17 = 648;
    goto LABEL_13;
  }
  if (!__dst)
  {
    v15 = "Invalid read buffer";
    v16 = a4;
    v17 = 654;
    goto LABEL_13;
  }
  if (!a3)
  {
    v15 = "Invalid bytes to read";
    v16 = a4;
    v17 = 660;
    goto LABEL_13;
  }
  v12 = *(_QWORD *)(a1 + 64);
  if (!v12)
  {
    if (!populate_read_buffer(a1, *(_QWORD *)(a1 + 32), a4))
    {
      v12 = *(_QWORD *)(a1 + 64);
      goto LABEL_7;
    }
    v15 = "Could not populate the read buffer";
    v16 = a4;
    v17 = 673;
LABEL_13:
    capture_error(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v17, (uint64_t)"data_archive_decoder_read_data", v15, a6, a7, a8, v19);
    return -1;
  }
LABEL_7:
  if (v12 >= a3)
    v13 = a3;
  else
    v13 = v12;
  if (v13)
  {
    platform_memcpy(*(_QWORD *)(a1 + 8), __dst, *(void **)(a1 + 48), v13);
    v14 = *(_QWORD *)(a1 + 56) + v13;
    *(_QWORD *)(a1 + 48) += v13;
    *(_QWORD *)(a1 + 56) = v14;
    *(_QWORD *)(a1 + 64) -= v13;
  }
  return v13;
}

uint64_t data_archive_decoder_rewind_data(uint64_t a1, void *__s2, size_t __n, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t result;
  const char *v15;
  _QWORD *v16;
  int v17;
  char v18;

  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    v15 = "Invalid decoder";
    v16 = a4;
    v17 = 710;
    goto LABEL_9;
  }
  if (!__s2)
  {
    v15 = "Invalid rewind buffer";
    v16 = a4;
    v17 = 716;
    goto LABEL_9;
  }
  if (!__n)
  {
    v15 = "Invalid bytes to rewind";
    v16 = a4;
    v17 = 722;
    goto LABEL_9;
  }
  v11 = *(_QWORD *)(a1 + 56);
  v12 = (void *)(*(_QWORD *)(a1 + 48) - __n);
  v13 = *(_QWORD *)(a1 + 64);
  result = platform_memcmp(*(_QWORD *)(a1 + 8), v12, __s2, __n);
  if ((_DWORD)result)
  {
    v15 = "Bytes don't match";
    v16 = a4;
    v17 = 732;
LABEL_9:
    capture_error(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v17, (uint64_t)"data_archive_decoder_rewind_data", v15, a6, a7, a8, v18);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 48) = v12;
  *(_QWORD *)(a1 + 56) = v11 - __n;
  *(_QWORD *)(a1 + 64) = v13 + __n;
  return result;
}

uint64_t require_minimum_amount(uint64_t a1, size_t a2, char a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;

  if (populate_read_buffer(a1, a2, a4))
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 4001, (uint64_t)"require_minimum_amount", "Could not populate read buffer for %s", v8, v9, v10, a3);
    return 0xFFFFFFFFLL;
  }
  v11 = *(_QWORD *)(a1 + 64);
  if (v11 < a2)
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 4007, (uint64_t)"require_minimum_amount", "Not enough data remaining (%ld) for %s (%ld)", v8, v9, v10, v11);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t parse_entry_posix_ustar_extended_metadata(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  if (!require_minimum_amount(a1, 0x200uLL, (char)"POSIX ustar extended metadata", a3))
  {
    v6 = platform_strnlen(*(_QWORD *)(a1 + 8), *(char **)(a1 + 48), 0x200uLL);
    if (v6 < 0x201)
    {
      if (v6 == a2)
      {
        printf("DALLAS: string_length = %lu\n", a2);
        result = 0;
        *(_QWORD *)(a1 + 48) += 512;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_2063CF720);
        return result;
      }
      capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1607, (uint64_t)"parse_entry_posix_ustar_extended_metadata", "POSIX ustar extended metadata string length %lu does not match expected size %lu", v7, v8, v9, v6);
    }
    else
    {
      capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1601, (uint64_t)"parse_entry_posix_ustar_extended_metadata", "POSIX ustar extended metadata string length %lu is larger than TAR record size %lu", v7, v8, v9, v6);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t parse_entry_pkzip_data_descriptor(uint64_t a1, _DWORD *a2, int a3, _QWORD *a4)
{
  BOOL v8;
  int v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  size_t v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  unint64_t uint64;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  _QWORD *v26;
  int v27;
  size_t v28;
  int v30;

  v8 = a3 == 134695760 || a3 == 808471376;
  v9 = *(unsigned __int8 *)(a1 + 91);
  v10 = 4;
  if (v8)
    v10 = 8;
  v11 = v10 + 8;
  v12 = v10 | 0x10;
  if (*(_BYTE *)(a1 + 91))
    v13 = v12;
  else
    v13 = v11;
  if (require_minimum_amount(a1, v13, (char)"PKZip data descriptor", a4))
    return 0xFFFFFFFFLL;
  v14 = platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x18uLL);
  if (!v14)
  {
    v18 = __error();
    strerror(*v18);
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2409, (uint64_t)"parse_entry_pkzip_data_descriptor", "Could not allocate %ld bytes for PKZip data descriptor: %s", v19, v20, v21, 24);
    return 0xFFFFFFFFLL;
  }
  v15 = v14;
  byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
  byte_stream_attach(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), v13);
  *v15 = 134695760;
  if (a3 == 808471376 || a3 == 134695760)
    *v15 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
  v15[1] = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
  v16 = *(_QWORD *)(a1 + 24);
  if (v9)
  {
    *((_QWORD *)v15 + 1) = byte_stream_read_uint64(v16);
    uint64 = byte_stream_read_uint64(*(_QWORD *)(a1 + 24));
  }
  else
  {
    *((_QWORD *)v15 + 1) = byte_stream_read_uint32(v16);
    uint64 = byte_stream_read_uint32(*(_QWORD *)(a1 + 24));
  }
  *((_QWORD *)v15 + 2) = uint64;
  if (byte_stream_exception(*(_QWORD *)(a1 + 24)))
  {
    v25 = "Could not parse the PKZip data descriptor";
    v26 = a4;
    v27 = 2438;
LABEL_24:
    capture_error(v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v27, (uint64_t)"parse_entry_pkzip_data_descriptor", v25, v22, v23, v24, v30);
    free(v15);
    return 0xFFFFFFFFLL;
  }
  if (*v15 != 134695760)
  {
    v25 = "Invalid PKZip data descriptor signature: %04x";
    v30 = *v15;
    v26 = a4;
    v27 = 2445;
    goto LABEL_24;
  }
  v28 = *(_QWORD *)(a1 + 56) + v13;
  *(_QWORD *)(a1 + 48) += v13;
  *(_QWORD *)(a1 + 56) = v28;
  *(_QWORD *)(a1 + 64) -= v13;
  if (darc_format_entry_set_type(a2, 7))
  {
    v25 = "Could not set entry type";
    v26 = a4;
    v27 = 2459;
    goto LABEL_24;
  }
  if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip data descriptor", v15, 0x18uLL))
  {
    v25 = "Could not set PKZip data descriptor attribute";
    v26 = a4;
    v27 = 2471;
    goto LABEL_24;
  }
  *(_WORD *)(a1 + 90) = 0;
  free(v15);
  return 0;
}

uint64_t parse_entry_pkzip_extra_field(uint64_t *a1, uint64_t a2, size_t a3, int a4, _QWORD *a5)
{
  _QWORD *v5;
  uint64_t v10;
  int uint16;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int uint8;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  char v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  char *v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  int v70;
  uint64_t result;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  size_t v75;
  const char *v76;
  _QWORD *v77;
  int v78;
  const char *v79;
  _QWORD *v80;
  int v81;
  const char *v82;
  _QWORD *v83;
  int v84;
  const char *v85;
  _QWORD *v86;
  int v87;
  const char *v88;
  _QWORD *v89;
  int v90;
  const char *v91;
  _QWORD *v92;
  int v93;
  char v94;
  _QWORD *v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;

  v5 = a5;
  if (require_minimum_amount((uint64_t)a1, a3, (char)"PKZip extra field", a5))
    return 0xFFFFFFFFLL;
  byte_stream_attach(a1[3], a1[6], a3);
  if (!a3)
  {
LABEL_78:
    result = byte_stream_remaining(a1[3]);
    if (result)
    {
      capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3394, (uint64_t)"parse_entry_pkzip_extra_field", "%ld bytes remaining after parsing %s extra field", v72, v73, v74, result);
      return 0xFFFFFFFFLL;
    }
    v75 = a1[7] + a3;
    a1[6] += a3;
    a1[7] = v75;
    a1[8] -= a3;
    return result;
  }
  v10 = 0;
  v95 = v5;
  while (1)
  {
    uint16 = byte_stream_read_uint16(a1[3]);
    v12 = byte_stream_read_uint16(a1[3]);
    if (byte_stream_exception(a1[3]))
    {
      v76 = "Exceed byte stream when parsing extra field";
      v77 = v5;
      v78 = 3268;
      goto LABEL_106;
    }
    v16 = v10 + 4;
    if (uint16 > 21588)
    {
      if (uint16 != 21589)
      {
        if (uint16 != 22613)
        {
          if (uint16 != 30837)
            goto LABEL_83;
          v17 = a1[6];
          byte_stream_new(a1[1], 0);
          if (v18)
          {
            v22 = (_QWORD *)v18;
            v23 = v17 + v16;
            v24 = v12;
            byte_stream_attach(v18, v23, v12);
            DWORD2(v96) = 0;
            *(_QWORD *)&v96 = 0;
            LOBYTE(v96) = byte_stream_read_uint8((uint64_t)v22);
            uint8 = byte_stream_read_uint8((uint64_t)v22);
            v29 = uint8;
            if (uint8 == 4)
            {
              DWORD1(v96) = byte_stream_read_uint32((uint64_t)v22);
            }
            else
            {
              capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3858, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3", "Unrecognized uid size: %d", v26, v27, v28, uint8);
              byte_stream_advance((uint64_t)v22, v29);
            }
            if (byte_stream_read_uint8((uint64_t)v22) == 4)
            {
              DWORD2(v96) = byte_stream_read_uint32((uint64_t)v22);
            }
            else
            {
              capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3869, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3", "Unrecognized uid size: %d", v64, v65, v66, v29);
              byte_stream_advance((uint64_t)v22, v29);
            }
            if (byte_stream_exception((_BOOL8)v22))
            {
              v79 = "Could not parse the PKZip Info-ZIP UNIX v3";
              v80 = v5;
              v81 = 3875;
            }
            else
            {
              if (!darc_format_entry_set_attribute(a2, "pkzip extra field InfoZIP UNIX v3", &v96, 0xCuLL))
                goto LABEL_72;
              v79 = "Could not set ctime";
              v80 = v5;
              v81 = 3886;
            }
          }
          else
          {
            v79 = "Could not create extra byte stream";
            v80 = v5;
            v81 = 3801;
          }
          capture_error(v80, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v81, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3", v79, v19, v20, v21, v94);
          v76 = "Could not parse extended timestamp";
          v77 = v5;
          v78 = 3349;
          goto LABEL_106;
        }
        v49 = a1[6];
        byte_stream_new(a1[1], 0);
        if (v50)
        {
          v22 = (_QWORD *)v50;
          v54 = v49 + v16;
          v24 = v12;
          byte_stream_attach(v50, v54, v12);
          v97 = 0uLL;
          *(_QWORD *)&v96 = byte_stream_read_uint32((uint64_t)v22);
          *((_QWORD *)&v96 + 1) = byte_stream_read_uint32((uint64_t)v22);
          if (v12 >= 0xA)
          {
            LOBYTE(v97) = 1;
            DWORD1(v97) = byte_stream_read_uint16((uint64_t)v22);
            if (v12 == 12)
            {
              BYTE8(v97) = 1;
              HIDWORD(v97) = byte_stream_read_uint16((uint64_t)v22);
            }
          }
          if (byte_stream_exception((_BOOL8)v22))
          {
            v82 = "Could not parse the PKZip Info-ZIP extra block for UNIX";
            v83 = v5;
            v84 = 3769;
          }
          else
          {
            if (!darc_format_entry_set_attribute(a2, "pkzip extra field InfoZIP UNIX v1", &v96, 0x20uLL))
            {
LABEL_72:
              byte_stream_free(v22);
              goto LABEL_73;
            }
            v82 = "Could not set ctime";
            v83 = v5;
            v84 = 3780;
          }
        }
        else
        {
          v82 = "Could not create extra byte stream";
          v83 = v5;
          v84 = 3721;
        }
        capture_error(v83, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v84, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v1", v82, v51, v52, v53, v94);
        v76 = "Could not parse extended timestamp";
        v77 = v5;
        v78 = 3329;
        goto LABEL_106;
      }
      v40 = a1[6];
      byte_stream_new(a1[1], 0);
      if (!v41)
      {
        v91 = "Could not create extra byte stream";
        v92 = v5;
        v93 = 3567;
        goto LABEL_103;
      }
      v45 = (_QWORD *)v41;
      v46 = v40 + v16;
      v24 = v12;
      byte_stream_attach(v41, v46, v12);
      v47 = byte_stream_read_uint8((uint64_t)v45);
      v48 = v47;
      if (!a4)
      {
        v96 = 0uLL;
        v67 = v12;
        *(_QWORD *)&v97 = 0;
        if (v12 >= 4)
        {
          v67 = v12;
          if ((v47 & 1) != 0)
          {
            *(_QWORD *)&v96 = byte_stream_read_uint32((uint64_t)v45);
            v67 = v12 - 4;
          }
        }
        if ((v48 & 2) != 0)
        {
          v68 = v67 - 4;
          if (v67 >= 4)
          {
            *((_QWORD *)&v96 + 1) = byte_stream_read_uint32((uint64_t)v45);
            v67 = v68;
          }
        }
        if ((v48 & 4) != 0 && v67 >= 4)
          *(_QWORD *)&v97 = byte_stream_read_uint32((uint64_t)v45);
        if (byte_stream_exception((_BOOL8)v45))
        {
          v91 = "Could not parse the PKZip extended-timestamp extra block";
          v5 = v95;
          v92 = v95;
          v93 = 3688;
          goto LABEL_103;
        }
        if (darc_format_entry_set_attribute(a2, "pkzip extra field extended timestamp", &v96, 0x18uLL))
        {
          v91 = "Could not set timestamp";
          v5 = v95;
          v92 = v95;
          v93 = 3699;
          goto LABEL_103;
        }
LABEL_53:
        byte_stream_free(v45);
        v5 = v95;
        goto LABEL_73;
      }
      v96 = 0uLL;
      *(_QWORD *)&v97 = 0;
      if ((v47 & 1) != 0)
      {
        *(_QWORD *)&v96 = byte_stream_read_uint32((uint64_t)v45);
        if ((v48 & 2) == 0)
        {
LABEL_23:
          if ((v48 & 4) == 0)
            goto LABEL_25;
          goto LABEL_24;
        }
      }
      else if ((v47 & 2) == 0)
      {
        goto LABEL_23;
      }
      *((_QWORD *)&v96 + 1) = byte_stream_read_uint32((uint64_t)v45);
      if ((v48 & 4) == 0)
      {
LABEL_25:
        if (byte_stream_exception((_BOOL8)v45))
        {
          v91 = "Could not parse the PKZip extended-timestamp extra block";
          v5 = v95;
          v92 = v95;
          v93 = 3625;
          goto LABEL_103;
        }
        if (darc_format_entry_set_attribute(a2, "pkzip extra field extended timestamp", &v96, 0x18uLL))
        {
          v91 = "Could not set extended timestamp";
          v5 = v95;
          v92 = v95;
          v93 = 3636;
LABEL_103:
          capture_error(v92, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v93, (uint64_t)"parse_entry_pkzip_extra_field_extended_timestamp", v91, v42, v43, v44, v94);
          v76 = "Could not parse extended timestamp";
          v77 = v5;
          v78 = 3309;
          goto LABEL_106;
        }
        goto LABEL_53;
      }
LABEL_24:
      *(_QWORD *)&v97 = byte_stream_read_uint32((uint64_t)v45);
      goto LABEL_25;
    }
    if (uint16 != 1)
      break;
    v55 = a1[6];
    byte_stream_new(a1[1], 0);
    if (!v56)
    {
      v88 = "Could not create extra byte stream";
      v89 = v5;
      v90 = 3416;
      goto LABEL_105;
    }
    v60 = (_QWORD *)v56;
    v61 = v55 + v16;
    v24 = v12;
    byte_stream_attach(v56, v61, v12);
    if (a4)
    {
      v62 = "pkzip local header";
      if (darc_format_entry_get_attribute(a2, "pkzip local header", 0) != 32)
      {
        v88 = "Could not extract PKZip local header from entry";
        v89 = v5;
        v90 = 3465;
        goto LABEL_105;
      }
      v63 = 0uLL;
    }
    else
    {
      v62 = "pkzip central directory header";
      if (darc_format_entry_get_attribute(a2, "pkzip central directory header", 0) != 48)
      {
        v88 = "Could not extract PKZip central directory header from entry";
        v89 = v5;
        v90 = 3483;
        goto LABEL_105;
      }
      v63 = 0uLL;
      v98 = 0u;
    }
    v96 = v63;
    v97 = v63;
    darc_format_entry_get_attribute(a2, v62, &v96);
    v70 = DWORD1(v97);
    v69 = DWORD2(v97);
    *(_QWORD *)&v98 = 0;
    v96 = 0u;
    v97 = 0u;
    if (v69 == -1)
    {
      LOBYTE(v96) = 1;
      *((_QWORD *)&v96 + 1) = byte_stream_read_uint64((uint64_t)v60);
    }
    if (v70 == -1)
    {
      BYTE1(v96) = 1;
      *(_QWORD *)&v97 = byte_stream_read_uint64((uint64_t)v60);
    }
    if ((a4 & 1) == 0)
    {
      if ((unint64_t)byte_stream_remaining((uint64_t)v60) >= 8)
        *((_QWORD *)&v97 + 1) = byte_stream_read_uint64((uint64_t)v60);
      if ((unint64_t)byte_stream_remaining((uint64_t)v60) >= 4)
        LODWORD(v98) = byte_stream_read_uint32((uint64_t)v60);
    }
    if (byte_stream_exception((_BOOL8)v60))
    {
      v88 = "Could not parse the PKZip ZIP64 extra block";
      v89 = v5;
      v90 = 3523;
      goto LABEL_105;
    }
    if (darc_format_entry_set_attribute(a2, "pkzip extra field ZIP64", &v96, 0x28uLL))
    {
      v88 = "Could not set ZIP64";
      v89 = v5;
      v90 = 3534;
      goto LABEL_105;
    }
    byte_stream_free(v60);
    if (darc_format_entry_set_size(a2, *((uint64_t *)&v96 + 1)))
    {
      v88 = "Could not reset pkzip entry size";
      v89 = v5;
      v90 = 3547;
LABEL_105:
      capture_error(v89, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v90, (uint64_t)"parse_entry_pkzip_extra_field_zip64", v88, v57, v58, v59, v94);
      v76 = "Could not parse extended timestamp";
      v77 = v5;
      v78 = 3288;
      goto LABEL_106;
    }
LABEL_73:
    byte_stream_advance(a1[3], v24);
    v10 = v16 + v24;
    if (v10 == a3)
      goto LABEL_78;
  }
  if (uint16 != 10)
  {
LABEL_83:
    capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3378, (uint64_t)"parse_entry_pkzip_extra_field", "Unrecognized extra field header ID: 0x%04x %d %d", v13, v14, v15, uint16);
    byte_stream_advance(a1[3], v12);
    return 0xFFFFFFFFLL;
  }
  v30 = a1[6];
  byte_stream_new(a1[1], 0);
  if (!v31)
  {
    v85 = "Could not create extra byte stream";
    v86 = v5;
    v87 = 3907;
    goto LABEL_96;
  }
  v22 = (_QWORD *)v31;
  v35 = v30 + v16;
  v24 = v12;
  byte_stream_attach(v31, v35, v12);
  LODWORD(v96) = byte_stream_read_uint32((uint64_t)v22);
  v36 = byte_stream_read_uint16((uint64_t)v22);
  WORD2(v96) = v36;
  WORD3(v96) = byte_stream_read_uint16((uint64_t)v22);
  if (v36 != 1)
  {
    capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3960, (uint64_t)"parse_entry_pkzip_extra_field_ntfs", "Unknown NTFS tag value: %u", v37, v38, v39, v36);
    goto LABEL_97;
  }
  *((_QWORD *)&v96 + 1) = byte_stream_read_uint64((uint64_t)v22);
  *(_QWORD *)&v97 = byte_stream_read_uint64((uint64_t)v22);
  *((_QWORD *)&v97 + 1) = byte_stream_read_uint64((uint64_t)v22);
  if (!byte_stream_exception((_BOOL8)v22))
  {
    if (darc_format_entry_set_attribute(a2, "pkzip extra field NTFS", &v96, 0x20uLL))
    {
      v85 = "Could not set NTFS extra field";
      v86 = v5;
      v87 = 3981;
      goto LABEL_96;
    }
    goto LABEL_72;
  }
  v85 = "Could not parse the PKZip NTFS extra field";
  v86 = v5;
  v87 = 3970;
LABEL_96:
  capture_error(v86, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v87, (uint64_t)"parse_entry_pkzip_extra_field_ntfs", v85, v32, v33, v34, v94);
LABEL_97:
  v76 = "Could not parse NFTS extra field";
  v77 = v5;
  v78 = 3369;
LABEL_106:
  capture_error(v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v78, (uint64_t)"parse_entry_pkzip_extra_field", v76, v13, v14, v15, v94);
  return 0xFFFFFFFFLL;
}

_QWORD *data_source_new(uint64_t a1, uint64_t a2)
{
  _QWORD *result;

  if (a2)
    return 0;
  result = platform_calloc(a1, 1uLL, 0x48uLL);
  if (result)
  {
    *(_DWORD *)result = 1936876321;
    result[1] = a1;
    *((_DWORD *)result + 4) = -1;
    *((_DWORD *)result + 16) = 560165491;
  }
  return result;
}

void data_source_free(_QWORD *__b)
{
  uint64_t v2;

  if (__b && *(_DWORD *)__b == 1936876321 && *((_DWORD *)__b + 16) == 560165491)
  {
    v2 = __b[1];
    platform_memset(v2, __b, 0, 0x48uLL);
    platform_free(v2, __b);
  }
}

_DWORD *data_source_set_fd(_DWORD *result, int a2)
{
  if (result && *result == 1936876321 && result[16] == 560165491)
    result[4] = a2;
  return result;
}

uint64_t data_source_set_handler(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && *(_DWORD *)result == 1936876321 && *(_DWORD *)(result + 64) == 560165491)
  {
    *(_QWORD *)(result + 48) = a2;
    *(_QWORD *)(result + 56) = a3;
  }
  return result;
}

size_t data_source_read(uint64_t a1, void *a2, size_t a3)
{
  uint64_t (*v4)(_QWORD, _QWORD, void *, size_t);
  size_t v6;
  uint64_t v7;
  uint64_t v8;

  if (!a1 || *(_DWORD *)a1 != 1936876321 || *(_DWORD *)(a1 + 64) != 560165491)
    return -1;
  v4 = *(uint64_t (**)(_QWORD, _QWORD, void *, size_t))(a1 + 56);
  if (v4)
    return v4(*(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 16), a2, a3);
  v7 = *(_QWORD *)(a1 + 24);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (*(_QWORD *)(a1 + 32) - v8 >= a3)
      v6 = a3;
    else
      v6 = *(_QWORD *)(a1 + 32) - v8;
    if (v6)
    {
      platform_memcpy(*(_QWORD *)(a1 + 8), a2, (void *)(v7 + v8), v6);
      *(_QWORD *)(a1 + 40) += v6;
    }
    return v6;
  }
  return platform_read(*(_QWORD *)(a1 + 8), *(unsigned int *)(a1 + 16), a2, a3);
}

_DWORD *data_archive_new(uint64_t a1)
{
  _DWORD *result;
  void *v2;

  if (a1)
    return 0;
  result = platform_toolbox_new(0);
  if (result)
  {
    v2 = result;
    result = platform_calloc((uint64_t)result, 1uLL, 0xD0uLL);
    if (result)
    {
      *result = 1684107875;
      *((_QWORD *)result + 1) = v2;
      result[5] = -1;
      result[50] = 1668440420;
    }
    else
    {
      platform_toolbox_free(v2);
      return 0;
    }
  }
  return result;
}

void data_archive_free(unsigned int *__b)
{
  void *v2;
  z_stream *v3;
  void *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;

  if (__b && *__b == 1684107875 && __b[50] == 1668440420)
  {
    v2 = (void *)*((_QWORD *)__b + 20);
    if (v2)
      platform_free(*((_QWORD *)__b + 1), v2);
    v3 = (z_stream *)*((_QWORD *)__b + 15);
    if (v3)
    {
      inflateEnd(v3);
      platform_free(*((_QWORD *)__b + 1), *((void **)__b + 15));
    }
    v4 = (void *)*((_QWORD *)__b + 12);
    if (v4)
      platform_free(*((_QWORD *)__b + 1), v4);
    v5 = (_QWORD *)*((_QWORD *)__b + 5);
    if (v5)
      data_archive_decoder_free(v5);
    v6 = (void *)*((_QWORD *)__b + 4);
    if (v6)
      data_read_stream_free(v6);
    v7 = (_QWORD *)*((_QWORD *)__b + 3);
    if (v7 && *((_BYTE *)__b + 16))
      data_source_free(v7);
    v8 = __b[5];
    if ((_DWORD)v8 != -1)
    {
      if (*((_BYTE *)__b + 17))
        platform_close(*((_QWORD *)__b + 1), v8);
    }
    v9 = (void *)*((_QWORD *)__b + 1);
    platform_memset((uint64_t)v9, __b, 0, 0xD0uLL);
    platform_free((uint64_t)v9, __b);
    platform_toolbox_free(v9);
  }
}

uint64_t data_archive_set_passphrase_callback(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  _QWORD *v10;
  int v11;
  char vars0;

  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    v9 = "Invalid data archive";
    v10 = a4;
    v11 = 264;
LABEL_7:
    capture_error(v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v11, (uint64_t)"data_archive_set_passphrase_callback", v9, a6, a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    v9 = "Invalid passphrase callback";
    v10 = a4;
    v11 = 270;
    goto LABEL_7;
  }
  v8 = 0;
  *(_QWORD *)(a1 + 128) = a2;
  *(_QWORD *)(a1 + 136) = a3;
  return v8;
}

uint64_t data_archive_open_source(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *stream_new;
  int stream_set_source;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  _QWORD *v17;
  int v18;
  _QWORD *v20;
  int v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int type;
  char v27;

  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    v16 = "Invalid data archive";
    v17 = a3;
    v18 = 292;
LABEL_9:
    capture_error(v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v18, (uint64_t)"data_archive_open_source", v16, a6, a7, a8, v27);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    v16 = "Invalid data source";
    v17 = a3;
    v18 = 298;
    goto LABEL_9;
  }
  *(_QWORD *)(a1 + 24) = a2;
  stream_new = data_read_stream_new(*(_QWORD *)(a1 + 8), 0);
  *(_QWORD *)(a1 + 32) = stream_new;
  if (!stream_new)
  {
    data_source_free(*(_QWORD **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
    v16 = "Could not create data read stream";
    v17 = a3;
    v18 = 310;
    goto LABEL_9;
  }
  stream_set_source = data_read_stream_set_source((uint64_t)stream_new, *(_QWORD *)(a1 + 24));
  if (stream_set_source)
  {
    v12 = stream_set_source;
    data_read_stream_free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    data_source_free(*(_QWORD **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 323, (uint64_t)"data_archive_open_source", "Could not set source for read stream: %d", v13, v14, v15, v12);
    return 0xFFFFFFFFLL;
  }
  v20 = data_archive_decoder_new(*(_QWORD *)(a1 + 8), 0);
  *(_QWORD *)(a1 + 40) = v20;
  if (!v20)
  {
    data_read_stream_free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    data_source_free(*(_QWORD **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
    v16 = "Could not create data decoder";
    v17 = a3;
    v18 = 336;
    goto LABEL_9;
  }
  v21 = data_archive_decoder_set_stream((uint64_t)v20, *(_QWORD *)(a1 + 32), a3);
  v22 = *(_QWORD **)(a1 + 40);
  if (v21)
  {
    data_archive_decoder_free(v22);
    *(_QWORD *)(a1 + 40) = 0;
    data_read_stream_free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    data_source_free(*(_QWORD **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 352, (uint64_t)"data_archive_open_source", "Could not set read stream for decoder: %d", v23, v24, v25, v21);
    return 0xFFFFFFFFLL;
  }
  type = data_archive_decoder_get_type(v22);
  *(_DWORD *)(a1 + 48) = type;
  if (!type)
  {
    data_archive_decoder_free(*(_QWORD **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0;
    data_read_stream_free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    data_source_free(*(_QWORD **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
    v16 = "Unknown archive format";
    v17 = a3;
    v18 = 368;
    goto LABEL_9;
  }
  return 0;
}

uint64_t data_archive_open_fd(uint64_t a1, int a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v19;
  _QWORD *v20;
  int v21;
  char v22;

  if (a1 && *(_DWORD *)a1 == 1684107875 && *(_DWORD *)(a1 + 200) == 1668440420)
  {
    if (a2 == -1)
    {
      v19 = "Invalid file descriptor";
      v20 = a3;
      v21 = 393;
    }
    else
    {
      *(_BYTE *)(a1 + 16) = 1;
      v11 = data_source_new(*(_QWORD *)(a1 + 8), 0);
      if (v11)
      {
        v12 = (uint64_t)v11;
        data_source_set_fd(v11, a2);
        return data_archive_open_source(a1, v12, a3, v13, v14, v15, v16, v17);
      }
      v19 = "Could not create data source";
      v20 = a3;
      v21 = 407;
    }
  }
  else
  {
    v19 = "Invalid data archive";
    v20 = a3;
    v21 = 387;
  }
  capture_error(v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v21, (uint64_t)"data_archive_open_fd", v19, a6, a7, a8, v22);
  return 0xFFFFFFFFLL;
}

uint64_t data_archive_open(uint64_t a1, char *__s, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v18;
  _QWORD *v19;
  int v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;

  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    v18 = "Invalid data archive";
    v19 = a3;
    v20 = 428;
LABEL_9:
    capture_error(v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v20, (uint64_t)"data_archive_open", v18, a6, a7, a8, v25);
    return 0xFFFFFFFFLL;
  }
  if (!__s)
  {
    v18 = "Invalid path";
    v19 = a3;
    v20 = 434;
    goto LABEL_9;
  }
  if ((unint64_t)platform_strlen(*(_QWORD *)(a1 + 8), __s) <= 0x3FF)
  {
    v11 = open(__s, 0);
    if (v11 != -1)
    {
      *(_BYTE *)(a1 + 17) = 1;
      return data_archive_open_fd(a1, v11, a3, v12, v13, v14, v15, v16);
    }
    v21 = __error();
    strerror(*v21);
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 447, (uint64_t)"data_archive_open", "Could not open %s: %s", v22, v23, v24, (char)__s);
  }
  return 0xFFFFFFFFLL;
}

uint64_t data_archive_open_custom(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v20;
  _QWORD *v21;
  int v22;
  char v23;

  if (a1 && *(_DWORD *)a1 == 1684107875 && *(_DWORD *)(a1 + 200) == 1668440420)
  {
    if (a3)
    {
      *(_BYTE *)(a1 + 16) = 1;
      v12 = data_source_new(*(_QWORD *)(a1 + 8), 0);
      if (v12)
      {
        v13 = (uint64_t)v12;
        data_source_set_handler((uint64_t)v12, a2, a3);
        return data_archive_open_source(a1, v13, a4, v14, v15, v16, v17, v18);
      }
      v20 = "Could not create data source";
      v21 = a4;
      v22 = 537;
    }
    else
    {
      v20 = "Invalid read handler";
      v21 = a4;
      v22 = 523;
    }
  }
  else
  {
    v20 = "Invalid data archive";
    v21 = a4;
    v22 = 517;
  }
  capture_error(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v22, (uint64_t)"data_archive_open_custom", v20, a6, a7, a8, v23);
  return 0xFFFFFFFFLL;
}

_DWORD *data_archive_read_entry(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  _QWORD *v16;
  int v17;
  _DWORD *v18;
  _QWORD *entry;
  _QWORD *v21;
  _QWORD *v22;
  unsigned int (*v23)(uint64_t, _QWORD *, _QWORD, _QWORD *);
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v45;

  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    v15 = "Invalid data archive";
    v16 = a2;
    v17 = 557;
LABEL_11:
    capture_error(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v17, (uint64_t)"data_archive_read_entry", v15, a6, a7, a8, v45);
    return 0;
  }
  if (*(_DWORD *)(a1 + 48) == 2)
  {
    v10 = *(_QWORD *)(a1 + 152);
    if (v10 >= 1)
    {
      v11 = *(void **)(a1 + 160);
      if (!v11)
      {
        v11 = platform_malloc(*(_QWORD *)(a1 + 8), 0x200uLL);
        *(_QWORD *)(a1 + 160) = v11;
        if (!v11)
        {
          v40 = __error();
          v41 = strerror(*v40);
          capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 943, (uint64_t)"consume_padding", "Could not allocate padding buffer: %s", v42, v43, v44, v41);
          goto LABEL_38;
        }
      }
      if ((unint64_t)v10 >= 0x201)
      {
        capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 950, (uint64_t)"consume_padding", "padding amount %lld is larger than buffer %lld", a6, a7, a8, v10);
LABEL_38:
        capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 574, (uint64_t)"data_archive_read_entry", "Could not consume padding %llu", v12, v13, v14, *(_QWORD *)(a1 + 152));
        return 0;
      }
      if (data_archive_decoder_read_data(*(_QWORD *)(a1 + 40), v11, v10, 0, a5, a6, a7, a8) == -1)
      {
        capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 957, (uint64_t)"consume_padding", "Could not consume %lld bytes of padding", a6, a7, a8, v10);
        goto LABEL_38;
      }
      *(_QWORD *)(a1 + 152) = 0;
    }
  }
  entry = data_archive_decoder_read_entry(*(_QWORD *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
  if (!entry)
  {
LABEL_31:
    v15 = "Could not read next decoder entry";
    v16 = a2;
    v17 = 596;
    goto LABEL_11;
  }
  v21 = entry;
  v22 = (_QWORD *)(a1 + 52);
  while (2)
  {
    v23 = *(unsigned int (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(a1 + 184);
    if (v23 && v23(a1, v21, *(_QWORD *)(a1 + 192), a2))
    {
      v15 = "Format entry callback failed";
      v16 = a2;
      v17 = 605;
      goto LABEL_11;
    }
    v24 = data_archive_entry_new(*(_QWORD *)(a1 + 8), 0);
    v18 = v24;
    if (!v24)
    {
      capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 613, (uint64_t)"data_archive_read_entry", "Could not create empty archive entry", v25, v26, v27, v45);
      darc_format_entry_free(v21);
      return v18;
    }
    if (!data_archive_entry_set_format_entry((uint64_t)v24, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 144), v21, a2, v25, v26, v27))
    {
      *(_DWORD *)(a1 + 144) = darc_format_entry_get_type(v21);
      v31 = *(_DWORD *)(a1 + 48);
      if (v31 == 2)
      {
        v32 = data_archive_entry_size((uint64_t)v18);
        v33 = 512 - v32;
        if (v32 >= 513)
          v33 = v32 & 0x1FF;
        *(_QWORD *)(a1 + 152) = v33;
        v31 = *(_DWORD *)(a1 + 48);
      }
      if (v31 == 9)
      {
        *(_DWORD *)(a1 + 148) = (data_archive_entry_crc32(v18) << 16) & 0xFF000000;
        *(_BYTE *)(a1 + 168) = 0;
      }
      darc_format_entry_free(v21);
      *v22 = 0;
      *(_QWORD *)(a1 + 60) = 0;
      *(_QWORD *)(a1 + 73) = 0;
      *(_QWORD *)(a1 + 68) = 0;
      switch(data_archive_entry_get_type(v18))
      {
        case 0u:
          capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 698, (uint64_t)"data_archive_read_entry", "Unknown entry type", v37, v38, v39, v45);
          data_archive_entry_free(v18);
          return 0;
        case 1u:
        case 3u:
          *(_DWORD *)v22 = 1;
          return v18;
        case 2u:
          *(_DWORD *)(a1 + 52) = data_archive_entry_get_data_type(v18);
          *(_QWORD *)(a1 + 56) = data_archive_entry_compressed_size((uint64_t)v18);
          *(_QWORD *)(a1 + 64) = data_archive_entry_size((uint64_t)v18);
          return v18;
        case 4u:
          *(_DWORD *)v22 = 1;
          data_archive_entry_free(v18);
          goto LABEL_30;
        default:
LABEL_30:
          v21 = data_archive_decoder_read_entry(*(_QWORD *)(a1 + 40), a2, v34, v35, v36, v37, v38, v39);
          if (!v21)
            goto LABEL_31;
          continue;
      }
    }
    break;
  }
  capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 627, (uint64_t)"data_archive_read_entry", "Could not set format entry", v28, v29, v30, v45);
  data_archive_entry_free(v18);
  darc_format_entry_free(v21);
  return 0;
}

size_t data_archive_read_data(uint64_t a1, void *a2, size_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v13;
  const char *v14;
  _QWORD *v15;
  int v16;
  int64_t v17;
  void *v18;
  size_t v19;
  char *v20;
  uint64_t streamed_data;
  int64_t data_direct;
  void *v23;
  size_t v24;
  char *v25;
  int *v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  z_stream *v31;
  int v32;
  z_stream *v33;
  int v34;
  size_t v35;
  size_t data;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  z_stream *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  size_t v49;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  size_t v55;
  size_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  z_stream *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  size_t v69;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int *v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  char v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  char v103;

  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    v13 = "data_archive_read_data";
    v14 = "Invalid data archive";
    v15 = a4;
    v16 = 771;
    goto LABEL_9;
  }
  if (!a2)
  {
    v13 = "data_archive_read_data";
    v14 = "Invalid read buffer";
    v15 = a4;
    v16 = 777;
    goto LABEL_9;
  }
  if (!a3)
  {
    v13 = "data_archive_read_data";
    v14 = "Invalid read size";
    v15 = a4;
    v16 = 783;
LABEL_9:
    capture_error(v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v16, (uint64_t)v13, v14, a6, a7, a8, v103);
    return -1;
  }
  switch(*(_DWORD *)(a1 + 52))
  {
    case 1:
      return 0;
    case 2:
      return read_data_direct((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    case 3:
      if (*(_BYTE *)(a1 + 80))
        return 0;
      if (*(_QWORD *)(a1 + 96))
        goto LABEL_18;
      *(_QWORD *)(a1 + 88) = 0x20000;
      v18 = platform_valloc(*(_QWORD *)(a1 + 8), 0x20000uLL);
      *(_QWORD *)(a1 + 96) = v18;
      if (!v18)
      {
        v75 = *(_QWORD *)(a1 + 88);
        v76 = __error();
        strerror(*v76);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1027, (uint64_t)"decompress_data", "Could not allocate %ld for read buffer: %s", v77, v78, v79, v75);
        return -1;
      }
      platform_memset(*(_QWORD *)(a1 + 8), v18, 0, *(_QWORD *)(a1 + 88));
      *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 96);
      *(_QWORD *)(a1 + 112) = 0;
LABEL_18:
      if (*(_QWORD *)(a1 + 120))
        goto LABEL_19;
      v31 = (z_stream *)platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x70uLL);
      *(_QWORD *)(a1 + 120) = v31;
      if (!v31)
      {
        v85 = __error();
        v86 = strerror(*v85);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1043, (uint64_t)"decompress_data", "Could not allocate zlib stream: %s", v87, v88, v89, v86);
        return -1;
      }
      v32 = inflateInit2_(v31, -15, "1.2.12", 112);
      if (v32)
      {
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1050, (uint64_t)"decompress_data", "Could not inflateInit2: %d", a6, a7, a8, v32);
        return -1;
      }
LABEL_19:
      v19 = *(_QWORD *)(a1 + 112);
      if (v19)
      {
        v20 = *(char **)(a1 + 104);
      }
      else
      {
        if (*(_QWORD *)(a1 + 88) >= *(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 72))
          v35 = *(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 72);
        else
          v35 = *(_QWORD *)(a1 + 88);
        data = data_archive_decoder_read_data(*(_QWORD *)(a1 + 40), *(void **)(a1 + 96), v35, 0, a5, a6, a7, a8);
        if (!data)
        {
          v13 = "decompress_data";
          v14 = "End of decoder";
          v15 = a4;
          v16 = 1082;
          goto LABEL_9;
        }
        v19 = data;
        if (data == -1 && *__error() != 35)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1075, (uint64_t)"decompress_data", "Could not read %ld bytes from decoder", v37, v38, v39, v35);
          return -1;
        }
        v20 = *(char **)(a1 + 96);
        *(_QWORD *)(a1 + 104) = v20;
        *(_QWORD *)(a1 + 112) = v19;
        *(_QWORD *)(a1 + 72) += v19;
      }
      v40 = 0;
      v41 = 0;
      v42 = *(z_stream **)(a1 + 120);
      do
      {
        v42->next_in = (Bytef *)&v20[v40];
        v42->avail_in = v19 - v40;
        v42->next_out = (Bytef *)a2;
        v42->avail_out = a3;
        v43 = inflate(v42, 0);
        if (v43)
        {
          if (v43 != 1)
          {
            capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1134, (uint64_t)"decompress_data", "Could not inflate: %d", v45, v46, v47, v43);
            return -1;
          }
          v41 = 1;
          *(_BYTE *)(a1 + 80) = 1;
        }
        v48 = *(_QWORD *)(a1 + 112);
        v42 = *(z_stream **)(a1 + 120);
        v49 = v19 - v40 - v42->avail_in;
        v20 = (char *)(*(_QWORD *)(a1 + 104) + v49);
        *(_QWORD *)(a1 + 104) = v20;
        *(_QWORD *)(a1 + 112) = v48 - v49;
        v17 = a3 - v42->avail_out;
        if ((v41 & 1) != 0)
          break;
        v40 += v49;
      }
      while (!v17 && v19 != v40);
      if ((v41 & 1) == 0)
        return v17;
      if (v48 != v49)
      {
        v51 = data_archive_decoder_rewind_data(*(_QWORD *)(a1 + 40), v20, v48 - v49, 0, v44, v45, v46, v47);
        if (v51)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1163, (uint64_t)"decompress_data", "Could not rewind remaining data: %d", v52, v53, v54, v51);
          return -1;
        }
        *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 96);
        *(_QWORD *)(a1 + 112) = 0;
        v42 = *(z_stream **)(a1 + 120);
      }
      v95 = inflateEnd(v42);
      if (!v95)
        goto LABEL_107;
      capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1178, (uint64_t)"decompress_data", "Could not inflateEnd: %d", v96, v97, v98, v95);
      return -1;
    case 4:
      if (!*(_BYTE *)(a1 + 168) && init_pkzip_cipher(a1, a4, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        v13 = "decrypt_data";
        v14 = "Could not initialize the PKZip cipher";
        v15 = a4;
        v16 = 1206;
        goto LABEL_9;
      }
      if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
      {
        v17 = 0;
        goto LABEL_33;
      }
      data_direct = read_data_direct((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
      if (data_direct <= 0)
      {
        v26 = __error();
        v27 = strerror(*v26);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1222, (uint64_t)"decrypt_data", "Could not read ciphertext: %s", v28, v29, v30, v27);
        return -1;
      }
      v17 = data_direct;
      pkzip_crypto_decrypt_buffer((int *)(a1 + 172), (unsigned __int8 *)a2, data_direct);
      if (*(_QWORD *)(a1 + 64) != *(_QWORD *)(a1 + 72))
        return v17;
      goto LABEL_33;
    case 5:
      return read_streamed_data(a1, (char *)a2, a3, a4, a5, a6, a7, a8);
    case 6:
      if (*(_BYTE *)(a1 + 80))
        return 0;
      if (*(_QWORD *)(a1 + 96))
        goto LABEL_39;
      *(_QWORD *)(a1 + 88) = 0x20000;
      v23 = platform_valloc(*(_QWORD *)(a1 + 8), 0x20000uLL);
      *(_QWORD *)(a1 + 96) = v23;
      if (!v23)
      {
        v80 = *(_QWORD *)(a1 + 88);
        v81 = __error();
        strerror(*v81);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1378, (uint64_t)"decompress_streamed_data", "Could not allocate %ld for read buffer: %s", v82, v83, v84, v80);
        return -1;
      }
      platform_memset(*(_QWORD *)(a1 + 8), v23, 0, *(_QWORD *)(a1 + 88));
      *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 96);
      *(_QWORD *)(a1 + 112) = 0;
LABEL_39:
      if (*(_QWORD *)(a1 + 120))
        goto LABEL_40;
      v33 = (z_stream *)platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x70uLL);
      *(_QWORD *)(a1 + 120) = v33;
      if (!v33)
      {
        v90 = __error();
        v91 = strerror(*v90);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1394, (uint64_t)"decompress_streamed_data", "Could not allocate zlib stream: %s", v92, v93, v94, v91);
        return -1;
      }
      v34 = inflateInit2_(v33, -15, "1.2.12", 112);
      if (v34)
      {
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1401, (uint64_t)"decompress_streamed_data", "Could not inflateInit2: %d", a6, a7, a8, v34);
        return -1;
      }
LABEL_40:
      v24 = *(_QWORD *)(a1 + 112);
      if (v24)
      {
        v25 = *(char **)(a1 + 104);
      }
      else
      {
        v55 = *(_QWORD *)(a1 + 88);
        v56 = data_archive_decoder_read_data(*(_QWORD *)(a1 + 40), *(void **)(a1 + 96), v55, 0, a5, a6, a7, a8);
        if (!v56)
        {
          v13 = "decompress_streamed_data";
          v14 = "End of decoder";
          v15 = a4;
          v16 = 1427;
          goto LABEL_9;
        }
        v24 = v56;
        if (v56 == -1 && *__error() != 35)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1420, (uint64_t)"decompress_streamed_data", "Could not read %ld bytes from decoder", v57, v58, v59, v55);
          return -1;
        }
        v25 = *(char **)(a1 + 96);
        *(_QWORD *)(a1 + 104) = v25;
        *(_QWORD *)(a1 + 112) = v24;
      }
      v60 = 0;
      v61 = 0;
      v62 = *(z_stream **)(a1 + 120);
      do
      {
        v62->next_in = (Bytef *)&v25[v60];
        v62->avail_in = v24 - v60;
        v62->next_out = (Bytef *)a2;
        v62->avail_out = a3;
        v63 = inflate(v62, 0);
        if (v63)
        {
          if (v63 != 1)
          {
            capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1476, (uint64_t)"decompress_streamed_data", "Could not inflate: %d", v65, v66, v67, v63);
            return -1;
          }
          v61 = 1;
          *(_BYTE *)(a1 + 80) = 1;
        }
        v68 = *(_QWORD *)(a1 + 112);
        v62 = *(z_stream **)(a1 + 120);
        v69 = v24 - v60 - v62->avail_in;
        v25 = (char *)(*(_QWORD *)(a1 + 104) + v69);
        *(_QWORD *)(a1 + 104) = v25;
        *(_QWORD *)(a1 + 112) = v68 - v69;
        v17 = a3 - v62->avail_out;
        if ((v61 & 1) != 0)
          break;
        v60 += v69;
      }
      while (!v17 && v24 != v60);
      if ((v61 & 1) == 0)
        return v17;
      if (v68 != v69)
      {
        v71 = data_archive_decoder_rewind_data(*(_QWORD *)(a1 + 40), v25, v68 - v69, 0, v64, v65, v66, v67);
        if (v71)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1505, (uint64_t)"decompress_streamed_data", "Could not rewind remaining data: %d", v72, v73, v74, v71);
          return -1;
        }
        *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 96);
        *(_QWORD *)(a1 + 112) = 0;
        v62 = *(z_stream **)(a1 + 120);
      }
      v99 = inflateEnd(v62);
      if (v99)
      {
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1520, (uint64_t)"decompress_streamed_data", "Could not inflateEnd: %d", v100, v101, v102, v99);
        return -1;
      }
LABEL_107:
      platform_free(*(_QWORD *)(a1 + 8), *(void **)(a1 + 120));
      *(_QWORD *)(a1 + 120) = 0;
      return v17;
    case 7:
      if (!*(_BYTE *)(a1 + 168) && init_pkzip_cipher(a1, a4, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        v13 = "decrypt_streamed_data";
        v14 = "Could not initialize the PKZip cipher";
        v15 = a4;
        v16 = 1548;
        goto LABEL_9;
      }
      streamed_data = read_streamed_data(a1, (char *)a2, a3, a4, a5, a6, a7, a8);
      if (streamed_data < 0)
      {
        v13 = "decrypt_streamed_data";
        v14 = "Could not read encrypted data";
        v15 = a4;
        v16 = 1561;
        goto LABEL_9;
      }
      v17 = streamed_data;
      if (streamed_data)
        pkzip_crypto_decrypt_buffer((int *)(a1 + 172), (unsigned __int8 *)a2, streamed_data);
      else
LABEL_33:
        *(_BYTE *)(a1 + 168) = 0;
      break;
    default:
      return -1;
  }
  return v17;
}

size_t read_data_direct(uint64_t *a1, void *a2, size_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10;
  size_t data;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;

  if (a1[8] - a1[9] >= a3)
    v10 = a3;
  else
    v10 = a1[8] - a1[9];
  data = data_archive_decoder_read_data(a1[5], a2, v10, 0, a5, a6, a7, a8);
  v15 = data;
  if (data == -1)
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 983, (uint64_t)"read_data_direct", "Could not read %ld from data decoder", v12, v13, v14, v10);
  else
    a1[9] += data;
  return v15;
}

uint64_t read_streamed_data(uint64_t a1, char *a2, size_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  char v10;
  size_t data;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  const char *v22;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  int uint32;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  char v34;

  if (*(_BYTE *)(a1 + 80))
    return 0;
  v10 = a3;
  data = data_archive_decoder_read_data(*(_QWORD *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
  if (!data)
  {
    v22 = "End of decoder";
    v23 = a4;
    v24 = 1276;
LABEL_18:
    capture_error(v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v24, (uint64_t)"read_streamed_data", v22, v14, v15, v16, v34);
    return -1;
  }
  v8 = data;
  if (data == -1 && *__error() != 35)
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1269, (uint64_t)"read_streamed_data", "Could not read %ld bytes from decoder", v17, v18, v19, v10);
    return -1;
  }
  byte_stream_new(*(_QWORD *)(a1 + 8), 0);
  if (!v20)
  {
    v22 = "Could not create byte stream";
    v23 = a4;
    v24 = 1292;
    goto LABEL_18;
  }
  v21 = v20;
  if (v8 < 5)
  {
    byte_stream_free(v20);
    return v8;
  }
  v25 = 0;
  v26 = v8;
  do
  {
    byte_stream_attach((uint64_t)v21, (uint64_t)&a2[v25], v26);
    uint32 = byte_stream_read_uint32((uint64_t)v21);
    v26 -= uint32 != 134695760;
    if (uint32 == 134695760)
      break;
    ++v25;
  }
  while (v26 > 4);
  byte_stream_free(v21);
  if (uint32 == 134695760)
  {
    *(_BYTE *)(a1 + 80) = 1;
    v32 = data_archive_decoder_rewind_data(*(_QWORD *)(a1 + 40), &a2[v25], v26, a4, v28, v29, v30, v31);
    if (!v32)
    {
      v8 -= v26;
      return v8;
    }
    v22 = "Could not rewind remaining data: %d";
    v34 = v32;
    v23 = a4;
    v24 = 1334;
    goto LABEL_18;
  }
  return v8;
}

uint64_t init_pkzip_cipher(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t (*v10)(uint64_t, _QWORD, _QWORD *);
  char *v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  int64_t data;
  int64_t v17;
  uint64_t result;
  const char *v19;
  _QWORD *v20;
  int v21;
  int *v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  _BYTE __dst[12];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  v9 = (int *)(a1 + 172);
  *(_DWORD *)(a1 + 180) = 0;
  v10 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD *))(a1 + 128);
  if (v10)
  {
    v12 = (char *)v10(a1, *(_QWORD *)(a1 + 136), a2);
    if (v12)
    {
      pkzip_crypto_init(v9, v12);
      v14 = 0;
      v15 = __dst;
      do
      {
        data = data_archive_decoder_read_data(*(_QWORD *)(a1 + 40), v15, 12 - v14, a2, v13, a6, a7, a8);
        if (data <= 0)
        {
          v22 = __error();
          v23 = strerror(*v22);
          capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1626, (uint64_t)"init_pkzip_cipher", "Could not read initial ciphertext: %s", v24, v25, v26, v23);
          return 0xFFFFFFFFLL;
        }
        v17 = data;
        pkzip_crypto_decrypt_buffer(v9, v15, data);
        v15 += v17;
        v14 += v17;
      }
      while (v14 != 12);
      if (*(unsigned __int8 *)(a1 + 151) == __dst[11])
      {
        result = 0;
        *(_BYTE *)(a1 + 168) = 1;
        return result;
      }
      v19 = "Decryption passphrase appears to be incorrect";
      v20 = a2;
      v21 = 1641;
    }
    else
    {
      v19 = "Client did not provide passphrase";
      v20 = a2;
      v21 = 1606;
    }
  }
  else
  {
    v19 = "No passphrase callback";
    v20 = a2;
    v21 = 1596;
  }
  capture_error(v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v21, (uint64_t)"init_pkzip_cipher", v19, a6, a7, a8, v27);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceNew(char *a1, const __CFDictionary *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v8;
  uint64_t v9;
  gid_t v10;
  NSObject *v11;
  gid_t v12;
  int32_t v13;
  CFTypeID TypeID;
  const void *Value;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  CFTypeID v33;
  const __CFNumber *v34;
  const __CFNumber *v35;
  CFTypeID v36;
  __CFReadStream *v37;
  __CFReadStream *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  const void *v56;
  const void *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  const void *v64;
  const __CFNumber *v65;
  const __CFNumber *v66;
  const void *v67;
  const void *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  const void *v75;
  const void *v76;
  const void *v77;
  const void *v78;
  CFTypeID v79;
  const __CFString *v80;
  const __CFString *v81;
  CFIndex v82;
  char *v83;
  const void *v84;
  const void *v85;
  const __CFString *v86;
  const __CFString *v87;
  CFIndex v88;
  char *v89;
  const void *v90;
  const void *v91;
  const void *v92;
  const void *v93;
  const __CFString *v94;
  const __CFString *v95;
  CFIndex v96;
  char *v97;
  const void *v98;
  const void *v99;
  const void *v100;
  const void *v101;
  const void *v102;
  const void *v103;
  int v104;
  NSObject *v105;
  char *v106;
  const char *v107;
  int v108;
  int (__cdecl *v109)(const FTSENT **, const FTSENT **);
  int *v110;
  char *v111;
  NSObject *v112;
  char *v113;
  const char *v114;
  statfs *p_buf;
  NSObject *v116;
  uint32_t v117;
  uint64_t v118;
  int support_filter_all;
  _DWORD *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  AAByteStream v126;
  NSObject *v127;
  const char *v128;
  NSObject *v129;
  uint32_t v130;
  int v131;
  int *v132;
  int v133;
  int *v134;
  int v135;
  int v136;
  AAByteStream_impl *v137;
  NSObject *v138;
  int support_format_all;
  int v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  FTS *v146;
  int v147;
  int *v148;
  int v149;
  int *v150;
  int v151;
  int *v152;
  int v153;
  AAByteStream v154;
  AAByteStream_impl *v155;
  AAArchiveStream v156;
  int v157;
  int *v158;
  int set_options;
  uint64_t v160;
  int set_passphrase_callback;
  int v162;
  int add_passphrase;
  int v164;
  int v165;
  int v166;
  int v167;
  NSObject *v168;
  void *v169;
  int open;
  int v171;
  int open_fd;
  int v173;
  int *v174;
  stat v176;
  int v177;
  uint64_t v178;
  statfs buf;
  char *v180[3];

  v180[2] = *(char **)MEMORY[0x24BDAC8D0];
  if (!((unint64_t)a1 | (unint64_t)a2))
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 577, (uint64_t)"BOMCopierSourceNew", "path and options are NULL");
    return 0;
  }
  v8 = malloc_type_calloc(1uLL, 0x180uLL, 0x10B00405CB9951FuLL);
  v9 = (uint64_t)v8;
  if (!v8)
  {
    v110 = __error();
    BOMCopierErrorCapture(a4, *v110, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 590, (uint64_t)"BOMCopierSourceNew", "Could not allocate empty BOMCopierSource");
    return v9;
  }
  v8[3] = a3;
  *((_DWORD *)v8 + 8) = geteuid();
  v10 = getegid();
  *(_DWORD *)(v9 + 36) = v10;
  *(_DWORD *)(v9 + 40) = -1;
  *(_DWORD *)(v9 + 100) = 0;
  *(_BYTE *)(v9 + 64) = 1;
  *(_QWORD *)(v9 + 232) = 0x4000000;
  *(_BYTE *)(v9 + 160) = 1;
  v11 = *(NSObject **)(v9 + 24);
  if (v11)
  {
    v12 = v10;
    if (os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_DWORD *)(v9 + 32);
      buf.f_bsize = 67109376;
      buf.f_iosize = v13;
      LOWORD(buf.f_blocks) = 1024;
      *(_DWORD *)((char *)&buf.f_blocks + 2) = v12;
      _os_log_impl(&dword_206367000, v11, OS_LOG_TYPE_DEFAULT, "euid: %u egid: %u", (uint8_t *)&buf, 0xEu);
    }
  }
  if (a2)
  {
    TypeID = CFBooleanGetTypeID();
    Value = CFDictionaryGetValue(a2, CFSTR("useFilesystemCache"));
    if (Value)
    {
      v16 = Value;
      if (TypeID != CFGetTypeID(Value))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1536, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionUseFilesystemCacheKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(_BYTE *)(v9 + 64) = CFEqual(v16, (CFTypeRef)*MEMORY[0x24BDBD270]) != 0;
    }
    v17 = CFDictionaryGetValue(a2, CFSTR("useEnumerationBom"));
    if (v17)
    {
      v18 = v17;
      if (TypeID != CFGetTypeID(v17))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1548, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionUseEnumerationBomKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(_BYTE *)(v9 + 65) = CFEqual(v18, (CFTypeRef)*MEMORY[0x24BDBD270]) != 0;
    }
    v19 = CFDictionaryGetValue(a2, CFSTR("applyBomOwnership"));
    if (v19)
    {
      v20 = v19;
      if (TypeID != CFGetTypeID(v19))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1560, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionApplyBomOwnershipKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(_BYTE *)(v9 + 208) = CFEqual(v20, (CFTypeRef)*MEMORY[0x24BDBD270]) != 0;
    }
    v21 = CFDictionaryGetValue(a2, CFSTR("allowAccessFailures"));
    if (v21)
    {
      v22 = v21;
      if (TypeID != CFGetTypeID(v21))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1572, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceAllowAccessFailuresKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      if (CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v22) == 1)
        *(_BYTE *)(v9 + 209) = 1;
    }
    v23 = CFDictionaryGetValue(a2, CFSTR("crossDevices"));
    if (v23)
    {
      v24 = v23;
      if (TypeID != CFGetTypeID(v23))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1587, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionCrossDevicesKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(_BYTE *)(v9 + 160) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v24) != 0;
    }
    v25 = CFDictionaryGetValue(a2, CFSTR("extractLibarchive"));
    if (v25)
    {
      v26 = v25;
      if (TypeID != CFGetTypeID(v25))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1599, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractLibarchiveKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      if (CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v26) == 1)
        *(_DWORD *)(v9 + 100) = 2;
    }
    v27 = CFDictionaryGetValue(a2, CFSTR("extractDataArchive"));
    if (!v27)
    {
LABEL_33:
      v29 = CFDictionaryGetValue(a2, CFSTR("enforceArchiveEntryPermissions"));
      if (v29)
      {
        v30 = v29;
        if (TypeID != CFGetTypeID(v29))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1629, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionEnforceArchiveEntryPermissionsKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 264) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v30) != 0;
      }
      v31 = CFDictionaryGetValue(a2, CFSTR("extractAppleArchive"));
      if (v31)
      {
        v32 = v31;
        if (TypeID != CFGetTypeID(v31))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1641, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        if (CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v32) == 1)
          *(_DWORD *)(v9 + 100) = 4;
      }
      v33 = CFNumberGetTypeID();
      v34 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("inputFD"));
      if (v34)
      {
        v35 = v34;
        if (v33 != CFGetTypeID(v34))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1658, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFNumberRef");
          goto LABEL_313;
        }
        buf.f_bsize = -1;
        if (!CFNumberGetValue(v35, kCFNumberSInt32Type, &buf))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1666, (uint64_t)"parse_copier_source_options", "Could not convert the input file descriptor number to kCFNumberSInt32Type");
          goto LABEL_313;
        }
        *(_DWORD *)(v9 + 40) = buf.f_bsize;
      }
      v36 = CFReadStreamGetTypeID();
      v37 = (__CFReadStream *)CFDictionaryGetValue(a2, CFSTR("inputStream"));
      if (v37)
      {
        v38 = v37;
        if (v36 != CFGetTypeID(v37))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1680, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFReadStreamRef");
          goto LABEL_313;
        }
        if (CFReadStreamGetStatus(v38) != kCFStreamStatusOpen)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1687, (uint64_t)"parse_copier_source_options", "CFReadStream is not open");
          goto LABEL_313;
        }
        *(_QWORD *)(v9 + 48) = v38;
      }
      v39 = CFDictionaryGetValue(a2, CFSTR("synthesizeResourceForks"));
      if (v39)
      {
        v40 = v39;
        if (TypeID != CFGetTypeID(v39))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1699, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionSynthesizeResourceForksKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 66) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v40) != 0;
      }
      v41 = CFDictionaryGetValue(a2, CFSTR("synthesizeAppleDoubles"));
      if (v41)
      {
        v42 = v41;
        if (TypeID != CFGetTypeID(v41))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1711, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 67) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v42) != 0;
      }
      v43 = CFDictionaryGetValue(a2, CFSTR("appleDoublesCaptureResourceAttributes"));
      if (v43)
      {
        v44 = v43;
        if (TypeID != CFGetTypeID(v43))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1725, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleCaptureResourceAttributesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 68) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v44) != 0;
      }
      v45 = CFDictionaryGetValue(a2, CFSTR("appleDoublesCaptureExtendedAttributes"));
      if (v45)
      {
        v46 = v45;
        if (TypeID != CFGetTypeID(v45))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1737, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleCaptureExtendedAttributesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 69) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v46) != 0;
      }
      v47 = CFDictionaryGetValue(a2, CFSTR("appleDoublesCaptureACLs"));
      if (v47)
      {
        v48 = v47;
        if (TypeID != CFGetTypeID(v47))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1749, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleCaptureACLsKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 70) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v48) != 0;
      }
      v49 = CFDictionaryGetValue(a2, CFSTR("deferAppleDoubles"));
      if (v49)
      {
        v50 = v49;
        if (TypeID != CFGetTypeID(v49))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1761, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDeferAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 71) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v50) != 0;
      }
      v51 = CFDictionaryGetValue(a2, CFSTR("replayAppleDoubles"));
      if (v51)
      {
        v52 = v51;
        if (TypeID != CFGetTypeID(v51))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1773, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 72) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v52) != 0;
      }
      v53 = CFDictionaryGetValue(a2, CFSTR("replaySymlinks"));
      if (v53)
      {
        v54 = v53;
        if (TypeID != CFGetTypeID(v53))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1785, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplaySymlinksKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 91) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v54) != 0;
      }
      v55 = CFDictionaryGetValue(a2, CFSTR("replayDirectories"));
      if (v55)
      {
        v56 = v55;
        if (TypeID != CFGetTypeID(v55))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1797, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayDirectoriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 92) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v56) != 0;
      }
      v57 = CFDictionaryGetValue(a2, CFSTR("excludeRootDirectory"));
      if (v57)
      {
        v58 = v57;
        if (TypeID != CFGetTypeID(v57))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1809, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExcludeRootDirectoryKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 93) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v58) != 0;
      }
      v59 = CFDictionaryGetValue(a2, CFSTR("skipRootDirectory"));
      if (v59)
      {
        v60 = v59;
        if (TypeID != CFGetTypeID(v59))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1821, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionSkipRootDirectoryKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 94) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v60) != 0;
      }
      v61 = CFDictionaryGetValue(a2, CFSTR("sequesterAppleDoubles"));
      if (v61)
      {
        v62 = v61;
        if (TypeID != CFGetTypeID(v61))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1833, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionSequesterAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 95) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v62) != 0;
      }
      v63 = CFDictionaryGetValue(a2, CFSTR("unsequesterAppleDoubles"));
      if (v63)
      {
        v64 = v63;
        if (TypeID != CFGetTypeID(v63))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1845, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionUnsequesterAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 96) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v64) != 0;
      }
      v65 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("libarchiveReadBlockSize"));
      if (v65)
      {
        v66 = v65;
        if (v33 != CFGetTypeID(v65))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1857, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionLibarchiveReadBlockSize must be a CFNumberRef");
          goto LABEL_313;
        }
        *(_QWORD *)&buf.f_bsize = 0;
        if (!CFNumberGetValue(v66, kCFNumberSInt64Type, &buf))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1865, (uint64_t)"parse_copier_source_options", "Could not convert the read block size number to kCFNumberSInt64Type");
          goto LABEL_313;
        }
        *(_QWORD *)(v9 + 232) = *(_QWORD *)&buf.f_bsize;
      }
      v67 = CFDictionaryGetValue(a2, CFSTR("discoverBinaries"));
      if (v67)
      {
        v68 = v67;
        if (TypeID != CFGetTypeID(v67))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1877, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverBinaries must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 360) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v68) != 0;
      }
      v69 = CFDictionaryGetValue(a2, CFSTR("discoverResourceAttribute"));
      if (v69)
      {
        v70 = v69;
        if (TypeID != CFGetTypeID(v69))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1889, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverResourceAttribute must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 361) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v70) != 0;
      }
      v71 = CFDictionaryGetValue(a2, CFSTR("discoverExtendedAttributes"));
      if (v71)
      {
        v72 = v71;
        if (TypeID != CFGetTypeID(v71))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1901, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverExtendedAttributes must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 362) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v72) != 0;
      }
      v73 = CFDictionaryGetValue(a2, CFSTR("discoverCompressionAttributes"));
      if (v73)
      {
        v74 = v73;
        if (TypeID != CFGetTypeID(v73))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1913, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverCompressionAttributes must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 363) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v74) != 0;
      }
      v75 = CFDictionaryGetValue(a2, CFSTR("discoverACLs"));
      if (v75)
      {
        v76 = v75;
        if (TypeID != CFGetTypeID(v75))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1925, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverACLs must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 364) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v76) != 0;
      }
      v77 = CFDictionaryGetValue(a2, CFSTR("discoverQuarantine"));
      if (v77)
      {
        v78 = v77;
        if (TypeID != CFGetTypeID(v77))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1937, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverQuarantine must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 365) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v78) != 0;
      }
      v79 = CFStringGetTypeID();
      v80 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("replayQuarantineFromPath"));
      if (v80)
      {
        v81 = v80;
        if (v79 != CFGetTypeID(v80))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1951, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayQuarantineFromPath must be a CFBooleanRef");
          goto LABEL_313;
        }
        v82 = CFStringGetLength(v81) + 1;
        v83 = (char *)malloc_type_calloc(1uLL, v82, 0x7DB4F0CAuLL);
        *(_QWORD *)(v9 + 368) = v83;
        if (!v83)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1963, (uint64_t)"parse_copier_source_options", "Could not allocate %ld bytes for path_size");
          goto LABEL_313;
        }
        if (!CFStringGetCString(v81, v83, v82, 0x8000100u))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1970, (uint64_t)"parse_copier_source_options", "Could not convert quarantine source path string to C string");
          goto LABEL_313;
        }
      }
      v84 = CFDictionaryGetValue(a2, CFSTR("keepParent"));
      if (v84)
      {
        v85 = v84;
        if (TypeID != CFGetTypeID(v84))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1980, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionKeepParent must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 376) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v85) != 0;
      }
      v86 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("passphrase"));
      if (v86)
      {
        v87 = v86;
        if (v79 != CFGetTypeID(v86))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1992, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionPassphraseKey must be a CFStringRef");
          goto LABEL_313;
        }
        v88 = CFStringGetLength(v87) + 1;
        v89 = (char *)malloc_type_calloc(1uLL, v88, 0x8F28313BuLL);
        *(_QWORD *)(v9 + 240) = v89;
        if (!v89)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2002, (uint64_t)"parse_copier_source_options", "Could not allocate %ld bytes for passphrase_size");
          goto LABEL_313;
        }
        if (!CFStringGetCString(v87, v89, v88, 0x8000100u))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2009, (uint64_t)"parse_copier_source_options", "Could not convert passphrase string to C string");
          goto LABEL_313;
        }
      }
      v90 = CFDictionaryGetValue(a2, CFSTR("discoverSegmentedFiles"));
      if (v90)
      {
        v91 = v90;
        if (TypeID != CFGetTypeID(v90))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2019, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverSegmentedFilesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 265) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v91) != 0;
      }
      v92 = CFDictionaryGetValue(a2, CFSTR("ignoreAppleDoubles"));
      if (v92)
      {
        v93 = v92;
        if (TypeID != CFGetTypeID(v92))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2031, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionIgnoreAppleDoubles must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 88) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v93) != 0;
      }
      v94 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("appleDoubleSuffix"));
      if (v94)
      {
        v95 = v94;
        if (v79 != CFGetTypeID(v94))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2043, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleSuffix must be a CFStringRef");
          goto LABEL_313;
        }
        v96 = CFStringGetLength(v95) + 1;
        v97 = (char *)malloc_type_calloc(1uLL, v96, 0x97E3DC56uLL);
        *(_QWORD *)(v9 + 80) = v97;
        if (!v97)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2053, (uint64_t)"parse_copier_source_options", "Could not allocate %ld bytes for suffix_size");
          goto LABEL_313;
        }
        if (!CFStringGetCString(v95, v97, v96, 0x8000100u))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2060, (uint64_t)"parse_copier_source_options", "Could not convert AppleDouble suffix string to C string");
          goto LABEL_313;
        }
      }
      v98 = CFDictionaryGetValue(a2, CFSTR("reorderExtraEntries"));
      if (v98)
      {
        v99 = v98;
        if (TypeID != CFGetTypeID(v98))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2070, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReorderExtraEntriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 89) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v99) != 0;
      }
      v100 = CFDictionaryGetValue(a2, CFSTR("replayExtraAppleDoubles"));
      if (v100)
      {
        v101 = v100;
        if (TypeID != CFGetTypeID(v100))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2082, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayExtraAppleDoubleEntriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 90) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v101) != 0;
      }
      v102 = CFDictionaryGetValue(a2, CFSTR("disableLexicographicSort"));
      if (v102)
      {
        v103 = v102;
        if (TypeID != CFGetTypeID(v102))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2094, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDisableLexicographicSortKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(_BYTE *)(v9 + 97) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v103) != 0;
      }
      goto LABEL_139;
    }
    v28 = v27;
    if (TypeID == CFGetTypeID(v27))
    {
      if (CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v28) == 1)
        *(_DWORD *)(v9 + 100) = 3;
      goto LABEL_33;
    }
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1614, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractDataArchiveKey must be a CFBooleanRef");
LABEL_313:
    BOMCopierSourceFree((void *)v9);
    return 0;
  }
LABEL_139:
  v104 = *(_DWORD *)(v9 + 100);
  if ((v104 - 2) >= 3 && *(_BYTE *)(v9 + 65))
  {
    *(_DWORD *)(v9 + 100) = 1;
    v105 = *(NSObject **)(v9 + 24);
    if (!v105 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
    {
LABEL_157:
      v111 = realpath_DARWIN_EXTSN(a1, 0);
      *(_QWORD *)(v9 + 176) = v111;
      if (v111)
      {
        v112 = *(NSObject **)(v9 + 24);
        if (v112)
        {
          v113 = v111;
          if (os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
          {
            buf.f_bsize = 136315138;
            *(_QWORD *)&buf.f_iosize = v113;
            v114 = "Source path: %s";
            goto LABEL_161;
          }
        }
        return v9;
      }
      v131 = *__error();
      v132 = __error();
      strerror(*v132);
      BOMCopierErrorCapture(a4, v131, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 803, (uint64_t)"BOMCopierSourceNew", "Could not resolve the path: %s");
      goto LABEL_313;
    }
    LOWORD(buf.f_bsize) = 0;
    _os_log_impl(&dword_206367000, v105, OS_LOG_TYPE_DEFAULT, "Using an enumeration bom", (uint8_t *)&buf, 2u);
    v104 = *(_DWORD *)(v9 + 100);
  }
  switch(v104)
  {
    case 0:
      v106 = realpath_DARWIN_EXTSN(a1, 0);
      *(_QWORD *)(v9 + 128) = v106;
      if (!v106)
      {
        v133 = *__error();
        v134 = __error();
        strerror(*v134);
        BOMCopierErrorCapture(a4, v133, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 716, (uint64_t)"BOMCopierSourceNew", "Could not resolve %s: %s");
        goto LABEL_313;
      }
      v107 = v106;
      if (!*(_BYTE *)(v9 + 376))
        goto LABEL_149;
      if (!basename_r(v106, (char *)&buf))
      {
        v151 = *__error();
        v152 = __error();
        strerror(*v152);
        BOMCopierErrorCapture(a4, v151, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 727, (uint64_t)"BOMCopierSourceNew", "Could not basename_r %s: %s");
        goto LABEL_313;
      }
      *(_QWORD *)(v9 + 136) = strlen((const char *)&buf) + 1;
      v107 = *(const char **)(v9 + 128);
LABEL_149:
      *(_QWORD *)(v9 + 144) = strlen(v107);
      v180[0] = (char *)v107;
      v180[1] = 0;
      if (*(_BYTE *)(v9 + 160))
        v108 = 21;
      else
        v108 = 85;
      if (*(_BYTE *)(v9 + 97))
        v109 = 0;
      else
        v109 = (int (__cdecl *)(const FTSENT **, const FTSENT **))fts_compare;
      v146 = fts_open(v180, v108, v109);
      *(_QWORD *)(v9 + 152) = v146;
      if (!v146)
      {
        v149 = *__error();
        v150 = __error();
        strerror(*v150);
        BOMCopierErrorCapture(a4, v149, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 758, (uint64_t)"BOMCopierSourceNew", "Could not open the FTS handle for %s: %s");
        goto LABEL_313;
      }
      memset(&v176, 0, sizeof(v176));
      if (stat(*(const char **)(v9 + 128), &v176))
      {
        v147 = *__error();
        v148 = __error();
        strerror(*v148);
        BOMCopierErrorCapture(a4, v147, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 771, (uint64_t)"BOMCopierSourceNew", "Could not stat %s: %s");
        goto LABEL_313;
      }
      *(_DWORD *)(v9 + 164) = v176.st_dev;
      bzero(&buf, 0x878uLL);
      if (statfs(*(const char **)(v9 + 128), &buf))
      {
        v157 = *__error();
        v158 = __error();
        strerror(*v158);
        BOMCopierErrorCapture(a4, v157, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 782, (uint64_t)"BOMCopierSourceNew", "Could not statfs %s: %s");
        goto LABEL_313;
      }
      *(_BYTE *)(v9 + 168) = (buf.f_flags & 8) == 0;
      v112 = *(NSObject **)(v9 + 24);
      if (!v112 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
        return v9;
      v160 = *(_QWORD *)(v9 + 128);
      v177 = 136315138;
      v178 = v160;
      v114 = "Opened FTS from %s";
      p_buf = (statfs *)&v177;
      goto LABEL_162;
    case 1:
      goto LABEL_157;
    case 2:
      v118 = archive_read_new();
      *(_QWORD *)(v9 + 224) = v118;
      if (!v118)
      {
        v135 = *__error();
        BOMCopierErrorCapture(a4, v135, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 823, (uint64_t)"BOMCopierSourceNew", "Could not create archive object");
        goto LABEL_313;
      }
      support_filter_all = archive_read_support_filter_all();
      if (support_filter_all)
      {
        BOMCopierErrorCapture(a4, support_filter_all, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 832, (uint64_t)"BOMCopierSourceNew", "Could not enable read support for all filter types");
LABEL_234:
        archive_read_free();
        *(_QWORD *)(v9 + 224) = 0;
        goto LABEL_313;
      }
      support_format_all = archive_read_support_format_all();
      if (support_format_all)
      {
        BOMCopierErrorCapture(a4, support_format_all, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 842, (uint64_t)"BOMCopierSourceNew", "Could not enable read support for all format types");
        goto LABEL_234;
      }
      set_options = archive_read_set_options();
      if (set_options)
      {
        BOMCopierErrorCapture(a4, set_options, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 852, (uint64_t)"BOMCopierSourceNew", "Could not disable __MACOSX support\n");
        goto LABEL_234;
      }
      set_passphrase_callback = archive_read_set_passphrase_callback();
      if (set_passphrase_callback)
      {
        BOMCopierErrorCapture(a4, set_passphrase_callback, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 866, (uint64_t)"BOMCopierSourceNew", "Could not set the passphrase callback\n");
        goto LABEL_234;
      }
      if (*(_QWORD *)(v9 + 240))
      {
        add_passphrase = archive_read_add_passphrase();
        if (add_passphrase)
        {
          v164 = add_passphrase;
          v165 = archive_errno();
          strerror(v165);
          BOMCopierErrorCapture(a4, v164, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 878, (uint64_t)"BOMCopierSourceNew", "Could not add passphrase: %s\n");
          goto LABEL_234;
        }
      }
      if (prepare_archive_source(a1, v9, a4))
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 894, (uint64_t)"BOMCopierSourceNew", "Could not prepare archive source");
        goto LABEL_234;
      }
      if (a1)
      {
        if (archive_read_open_filename())
        {
          archive_error_string();
          BOMCopierErrorCapture(a4, 3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 969, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %s for reading: %s");
          goto LABEL_234;
        }
        v112 = *(NSObject **)(v9 + 24);
        if (v112 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
        {
          buf.f_bsize = 136315138;
          *(_QWORD *)&buf.f_iosize = a1;
          v114 = "Opened archive from %s";
LABEL_161:
          p_buf = &buf;
LABEL_162:
          v116 = v112;
          v117 = 12;
          goto LABEL_163;
        }
        return v9;
      }
      if (*(_QWORD *)(v9 + 48))
      {
        v169 = malloc_type_valloc(*(_QWORD *)(v9 + 232), 0x138B50F5uLL);
        *(_QWORD *)(v9 + 56) = v169;
        if (!v169)
        {
          v174 = __error();
          strerror(*v174);
          BOMCopierErrorCapture(a4, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 920, (uint64_t)"BOMCopierSourceNew", "Could not allocate libarchive buffer: %s");
          goto LABEL_234;
        }
        open = archive_read_open();
        if (open)
        {
          v171 = open;
          archive_error_string();
          BOMCopierErrorCapture(a4, v171, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 935, (uint64_t)"BOMCopierSourceNew", "Could not open the archive_read_open2 for reading: %s");
          goto LABEL_234;
        }
        v168 = *(NSObject **)(v9 + 24);
        if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
          return v9;
        LOWORD(buf.f_bsize) = 0;
        v114 = "Opened archive from CFReadStream";
LABEL_263:
        p_buf = &buf;
        v116 = v168;
        v117 = 2;
LABEL_163:
        _os_log_impl(&dword_206367000, v116, OS_LOG_TYPE_DEFAULT, v114, (uint8_t *)p_buf, v117);
        return v9;
      }
      if (*(_DWORD *)(v9 + 40) != -1)
      {
        open_fd = archive_read_open_fd();
        if (open_fd)
        {
          v173 = open_fd;
          archive_error_string();
          BOMCopierErrorCapture(a4, v173, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 954, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %d for reading: %s");
          goto LABEL_234;
        }
        v168 = *(NSObject **)(v9 + 24);
        if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
          return v9;
        LOWORD(buf.f_bsize) = 0;
        v114 = "Opened archive from file descriptor";
        goto LABEL_263;
      }
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 947, (uint64_t)"BOMCopierSourceNew", "No input file descriptor\n");
      return 0;
    case 3:
      v120 = data_archive_new(0);
      *(_QWORD *)(v9 + 280) = v120;
      if (!v120)
      {
        v136 = *__error();
        BOMCopierErrorCapture(a4, v136, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 986, (uint64_t)"BOMCopierSourceNew", "Could not create data_archive object");
        goto LABEL_313;
      }
      *(_QWORD *)&v176.st_dev = 0;
      v125 = data_archive_set_passphrase_callback((uint64_t)v120, (uint64_t)data_archive_passphrase_callback_handler, v9, &v176, v121, v122, v123, v124);
      if (v125)
      {
        BOMCopierErrorCapture(a4, v125, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 999, (uint64_t)"BOMCopierSourceNew", "Could not set the passphrase callback: %s");
        goto LABEL_172;
      }
      v140 = prepare_archive_source(a1, v9, a4);
      if (v140)
      {
        BOMCopierErrorCapture(a4, v140, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1013, (uint64_t)"BOMCopierSourceNew", "Could not prepare archive source");
        goto LABEL_313;
      }
      if (!a1)
      {
        if (*(_QWORD *)(v9 + 48))
        {
          v162 = data_archive_open_custom(*(_QWORD *)(v9 + 280), v9, (uint64_t)data_source_read_callback, &v176, v142, v143, v144, v145);
          if (!v162)
          {
            v168 = *(NSObject **)(v9 + 24);
            if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
              return v9;
            LOWORD(buf.f_bsize) = 0;
            v114 = "Opened data archive from CFReadStream";
            goto LABEL_263;
          }
          BOMCopierErrorCapture(a4, v162, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1030, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %d for custom reading: %s");
        }
        else
        {
          v166 = *(_DWORD *)(v9 + 40);
          if (v166 == -1)
          {
            BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1041, (uint64_t)"BOMCopierSourceNew", "No input file descriptor\n");
            goto LABEL_313;
          }
          v167 = data_archive_open_fd(*(_QWORD *)(v9 + 280), v166, &v176, v141, v142, v143, v144, v145);
          if (!v167)
          {
            v168 = *(NSObject **)(v9 + 24);
            if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
              return v9;
            LOWORD(buf.f_bsize) = 0;
            v114 = "Opened data archive from file descriptor";
            goto LABEL_263;
          }
          BOMCopierErrorCapture(a4, v167, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1049, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %d for reading: %s");
        }
LABEL_172:
        release_error(*(_QWORD **)&v176.st_dev);
        goto LABEL_313;
      }
      if (data_archive_open(*(_QWORD *)(v9 + 280), a1, &v176, v141, v142, v143, v144, v145))
      {
        BOMCopierErrorCapture(a4, 3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1063, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %s for reading: %s");
        goto LABEL_172;
      }
      v112 = *(NSObject **)(v9 + 24);
      if (v112 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
      {
        buf.f_bsize = 136315138;
        *(_QWORD *)&buf.f_iosize = a1;
        v114 = "Opened data archive from %s";
        goto LABEL_161;
      }
      return v9;
    case 4:
      if (a1)
      {
        v126 = AAFileStreamOpenWithPath(a1, 0, 0);
        *(_QWORD *)(v9 + 288) = v126;
        if (!v126)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1116, (uint64_t)"BOMCopierSourceNew", "Could not open AppleArchive byte stream at %s");
          goto LABEL_313;
        }
        v127 = *(NSObject **)(v9 + 24);
        if (v127 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
        {
          buf.f_bsize = 136315138;
          *(_QWORD *)&buf.f_iosize = a1;
          v128 = "Opened AppleArchive from %s";
          v129 = v127;
          v130 = 12;
LABEL_209:
          _os_log_impl(&dword_206367000, v129, OS_LOG_TYPE_DEFAULT, v128, (uint8_t *)&buf, v130);
        }
LABEL_210:
        v155 = AADecompressionInputStreamOpen(*(AAByteStream *)(v9 + 288), 0, 0);
        *(_QWORD *)(v9 + 296) = v155;
        if (v155)
        {
          v156 = AADecodeArchiveInputStreamOpen(v155, 0, 0, 0, 0);
          *(_QWORD *)(v9 + 304) = v156;
          if (v156)
            return v9;
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1135, (uint64_t)"BOMCopierSourceNew", "Could not create AppleArchive decoder");
        }
        else
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1127, (uint64_t)"BOMCopierSourceNew", "Could not open AppleArchive decompression stream at %s");
        }
        goto LABEL_313;
      }
      if (*(_QWORD *)(v9 + 48))
      {
        v137 = AACustomByteStreamOpen();
        *(_QWORD *)(v9 + 288) = v137;
        if (!v137)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1082, (uint64_t)"BOMCopierSourceNew", "Could not create custom AppleArchive byte stream at %s\n");
          goto LABEL_313;
        }
        AACustomByteStreamSetData(v137, (void *)v9);
        AACustomByteStreamSetCloseProc(*(AAByteStream *)(v9 + 288), (AAByteStreamCloseProc)apple_archive_close_callback);
        AACustomByteStreamSetReadProc(*(AAByteStream *)(v9 + 288), (AAByteStreamReadProc)apple_archive_read_callback);
        v138 = *(NSObject **)(v9 + 24);
        if (!v138 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
          goto LABEL_210;
        LOWORD(buf.f_bsize) = 0;
        v128 = "Opened AppleArchive from CFReadStream";
      }
      else
      {
        v153 = *(_DWORD *)(v9 + 40);
        if (v153 == -1)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1096, (uint64_t)"BOMCopierSourceNew", "No input file descriptor\n");
          goto LABEL_313;
        }
        v154 = AAFileStreamOpenWithFD(v153, 0);
        *(_QWORD *)(v9 + 288) = v154;
        if (!v154)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1104, (uint64_t)"BOMCopierSourceNew", "Could not open AppleArchive byte stream from file descriptor");
          goto LABEL_313;
        }
        v138 = *(NSObject **)(v9 + 24);
        if (!v138 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
          goto LABEL_210;
        LOWORD(buf.f_bsize) = 0;
        v128 = "Opened AppleArchive from file descriptor";
      }
      v129 = v138;
      v130 = 2;
      goto LABEL_209;
    default:
      return v9;
  }
}

void BOMCopierSourceFree(void *a1)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  void *v16;
  AAArchiveStream_impl *v17;
  AAByteStream_impl *v18;
  AAByteStream_impl *v19;
  unsigned int *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  FTS *v24;
  void *v25;
  void *v26;

  if (a1)
  {
    v2 = (void *)*((_QWORD *)a1 + 7);
    if (v2)
      free(v2);
    v3 = (void *)*((_QWORD *)a1 + 34);
    if (v3)
      free(v3);
    v4 = (void *)*((_QWORD *)a1 + 46);
    if (v4)
      free(v4);
    v5 = *((_QWORD *)a1 + 43);
    if (v5)
      path_tree_node_release(v5);
    v6 = *((_QWORD *)a1 + 44);
    if (v6)
    {
      while (!BOMStackIsEmpty(v6))
      {
        v7 = BOMStackPop(*((uint64_t **)a1 + 44));
        BOMCopierSourceEntryFree((unsigned int *)v7);
        v6 = *((_QWORD *)a1 + 44);
      }
      BOMStackFree(*((void ***)a1 + 44));
    }
    v8 = *((_QWORD *)a1 + 42);
    if (v8)
    {
      while (!BOMStackIsEmpty(v8))
      {
        v9 = BOMStackPop(*((uint64_t **)a1 + 42));
        BOMCopierSourceEntryFree((unsigned int *)v9);
        v8 = *((_QWORD *)a1 + 42);
      }
      BOMStackFree(*((void ***)a1 + 42));
    }
    v10 = *((_QWORD *)a1 + 41);
    if (v10)
    {
      while (!BOMStackIsEmpty(v10))
      {
        v11 = BOMStackPop(*((uint64_t **)a1 + 41));
        BOMCopierSourceEntryFree((unsigned int *)v11);
        v10 = *((_QWORD *)a1 + 41);
      }
      BOMStackFree(*((void ***)a1 + 41));
    }
    v12 = *((_QWORD *)a1 + 40);
    if (v12)
    {
      while (!BOMStackIsEmpty(v12))
      {
        v13 = BOMStackPop(*((uint64_t **)a1 + 40));
        BOMCopierSourceEntryFree((unsigned int *)v13);
        v12 = *((_QWORD *)a1 + 40);
      }
      BOMStackFree(*((void ***)a1 + 40));
    }
    v14 = *((_QWORD *)a1 + 39);
    if (v14)
    {
      while (!BOMStackIsEmpty(v14))
      {
        v15 = BOMStackPop(*((uint64_t **)a1 + 39));
        BOMCopierSourceEntryFree((unsigned int *)v15);
        v14 = *((_QWORD *)a1 + 39);
      }
      BOMStackFree(*((void ***)a1 + 39));
    }
    v16 = (void *)*((_QWORD *)a1 + 30);
    if (v16)
      free(v16);
    v17 = (AAArchiveStream_impl *)*((_QWORD *)a1 + 38);
    if (v17 && AAArchiveStreamClose(v17))
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not close AppleArchive decoder: %d\n");
    }
    else
    {
      v18 = (AAByteStream_impl *)*((_QWORD *)a1 + 37);
      if (v18 && AAByteStreamClose(v18))
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not close AppleArchive decompression stream: %d\n");
      }
      else
      {
        v19 = (AAByteStream_impl *)*((_QWORD *)a1 + 36);
        if (v19 && AAByteStreamClose(v19))
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not close AppleArchive byte stream: %d\n");
        }
        else
        {
          v20 = (unsigned int *)*((_QWORD *)a1 + 35);
          if (v20)
            data_archive_free(v20);
          if (*((_QWORD *)a1 + 28))
            archive_read_free();
          v21 = (void *)*((_QWORD *)a1 + 25);
          if (v21)
            BOMBomEnumeratorFree(v21);
          v22 = *((_QWORD *)a1 + 24);
          if (v22)
            BOMFSObjectFree(v22);
          v23 = (void *)*((_QWORD *)a1 + 22);
          if (v23)
            free(v23);
          v24 = (FTS *)*((_QWORD *)a1 + 19);
          if (v24)
            fts_close(v24);
          v25 = (void *)*((_QWORD *)a1 + 16);
          if (v25)
            free(v25);
          v26 = (void *)*((_QWORD *)a1 + 10);
          if (v26)
            free(v26);
          free(a1);
        }
      }
    }
  }
}

uint64_t fts_compare(uint64_t a1, uint64_t a2)
{
  size_t v2;

  if (*(unsigned __int16 *)(*(_QWORD *)a2 + 66) <= *(unsigned __int16 *)(*(_QWORD *)a1 + 66))
    v2 = *(unsigned __int16 *)(*(_QWORD *)a1 + 66);
  else
    v2 = *(unsigned __int16 *)(*(_QWORD *)a2 + 66);
  return strncmp((const char *)(*(_QWORD *)a1 + 104), (const char *)(*(_QWORD *)a2 + 104), v2);
}

uint64_t libarchive_passphrase_callback_handler(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t (*v3)(_QWORD *, _QWORD, uint64_t *);
  uint64_t v4;

  result = a2[30];
  if (!result)
  {
    v3 = (uint64_t (*)(_QWORD *, _QWORD, uint64_t *))a2[31];
    if (v3)
    {
      v4 = 0;
      return v3(a2, a2[32], &v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t prepare_archive_source(const char *a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  int *v5;
  stat v7;

  if (a1)
  {
    memset(&v7, 0, sizeof(v7));
    if (stat(a1, &v7))
    {
      v4 = *__error();
      v5 = __error();
      strerror(*v5);
      BOMCopierErrorCapture(a3, v4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2131, (uint64_t)"prepare_archive_source", "Could not stat the archive %s: %s");
      return 1;
    }
    if (!v7.st_size)
    {
      BOMCopierErrorCapture(a3, 3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2137, (uint64_t)"prepare_archive_source", "%s is empty: Unrecognized archive format");
      return 1;
    }
  }
  else if (!*(_QWORD *)(a2 + 48) && *(_DWORD *)(a2 + 40) == -1)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2117, (uint64_t)"prepare_archive_source", "No input file descriptor\n");
    return 1;
  }
  return 0;
}

uint64_t libarchive_open_callback()
{
  return 0;
}

uint64_t libarchive_read_callback(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFIndex v4;

  if (!a2)
    return -1;
  *a3 = *(_QWORD *)(a2 + 56);
  while (1)
  {
    v4 = CFReadStreamRead(*(CFReadStreamRef *)(a2 + 48), *(UInt8 **)(a2 + 56), *(_QWORD *)(a2 + 232));
    if ((v4 & 0x8000000000000000) == 0)
      break;
    if (*__error() != 4)
    {
      __error();
      archive_set_error();
      return v4;
    }
  }
  return v4;
}

uint64_t libarchive_close_callback()
{
  return 0;
}

uint64_t data_archive_passphrase_callback_handler(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t (*v3)(_QWORD *, _QWORD, uint64_t *);
  uint64_t v4;

  result = a2[30];
  if (!result)
  {
    v3 = (uint64_t (*)(_QWORD *, _QWORD, uint64_t *))a2[31];
    if (v3)
    {
      v4 = 0;
      return v3(a2, a2[32], &v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFIndex data_source_read_callback(uint64_t a1, int a2, UInt8 *buffer, CFIndex bufferLength)
{
  if (a1)
    return CFReadStreamRead(*(CFReadStreamRef *)(a1 + 48), buffer, bufferLength);
  else
    return -1;
}

uint64_t apple_archive_close_callback()
{
  return 0;
}

CFIndex apple_archive_read_callback(uint64_t a1, UInt8 *a2, CFIndex a3)
{
  if (a1)
    return CFReadStreamRead(*(CFReadStreamRef *)(a1 + 48), a2, a3);
  else
    return -1;
}

void path_tree_node_release(uint64_t a1)
{
  unint64_t v2;
  void *v3;

  if (*(_DWORD *)(a1 + 8))
  {
    v2 = 0;
    do
      path_tree_node_release(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v2++));
    while (v2 < *(unsigned int *)(a1 + 8));
  }
  v3 = *(void **)(a1 + 16);
  if (v3)
    free(v3);
  if (*(_QWORD *)a1)
    free(*(void **)a1);
  free((void *)a1);
}

uint64_t BOMCopierSourceSetErrorHandler(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;

  if (a1)
  {
    v4 = 0;
    *a1 = a2;
    a1[1] = a3;
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1329, (uint64_t)"BOMCopierSourceSetErrorHandler", "copier_source is NULL");
  }
  return v4;
}

uint64_t BOMCopierSourceSetEnumerationBom(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int *RootFSObject;
  char *v6;
  uint64_t v7;

  if (!a1)
  {
    v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1348, (uint64_t)"BOMCopierSourceSetEnumerationBom", "copier_source is NULL");
    return v7;
  }
  if (!a2)
  {
    v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1354, (uint64_t)"BOMCopierSourceSetEnumerationBom", "enumeration_bom is NULL");
    return v7;
  }
  if (*(_DWORD *)(a1 + 100) != 1)
  {
    v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1360, (uint64_t)"BOMCopierSourceSetEnumerationBom", "The copier source is not BOMCopierSourceIndexBom");
    return v7;
  }
  if (!*(_BYTE *)(a1 + 65))
  {
    v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1366, (uint64_t)"BOMCopierSourceSetEnumerationBom", "The copier source is not configured to use an enumeration bom");
    return v7;
  }
  *(_QWORD *)(a1 + 184) = a2;
  RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a2);
  *(_QWORD *)(a1 + 192) = RootFSObject;
  if (!RootFSObject)
  {
    v7 = 1;
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1375, (uint64_t)"BOMCopierSourceSetEnumerationBom", "Could not get the root fso for the enumeration bom");
LABEL_15:
    BOMCopierSourceFree((void *)a1);
    return v7;
  }
  v6 = BOMBomEnumeratorNew(*(_QWORD *)(a1 + 184), RootFSObject);
  *(_QWORD *)(a1 + 200) = v6;
  if (!v6)
  {
    v7 = 1;
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1390, (uint64_t)"BOMCopierSourceSetEnumerationBom", "Could not create enumerator for the enumeration bom");
    goto LABEL_15;
  }
  return 0;
}

uint64_t BOMCopierSourceSetAllowBom(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  if (a1)
  {
    v3 = 0;
    *(_QWORD *)(a1 + 216) = a2;
  }
  else
  {
    v3 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1410, (uint64_t)"BOMCopierSourceSetAllowBom", "copier_source is NULL");
  }
  return v3;
}

uint64_t BOMCopierSourceSetRedirectCallback(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;

  if (a1)
  {
    v4 = 0;
    *(_QWORD *)(a1 + 112) = a2;
    *(_QWORD *)(a1 + 120) = a3;
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1433, (uint64_t)"BOMCopierSourceSetRedirectCallback", "copier_source is NULL");
  }
  return v4;
}

uint64_t BOMCopierSourceSetPassphraseCallback(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;

  if (a1)
  {
    v4 = 0;
    *(_QWORD *)(a1 + 248) = a2;
    *(_QWORD *)(a1 + 256) = a3;
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1453, (uint64_t)"BOMCopierSourceSetPassphraseCallback", "copier_source is NULL");
  }
  return v4;
}

uint64_t *BOMCopierSourceNext(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  _BYTE *v10;
  int *v11;
  uint64_t *v12;
  NSObject *v13;
  unsigned int *filesystem_entry;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  const char *Path;
  uint64_t v19;
  _BOOL4 v20;
  NSObject *v21;
  int v22;
  unsigned int *v23;
  int *v24;
  int Type;
  unsigned int v26;
  const char *v27;
  const char *v28;
  size_t v29;
  int v30;
  size_t v31;
  const char *v32;
  NSObject *v33;
  uint64_t v34;
  const char *v35;
  NSObject *v36;
  const char *v37;
  const char *v38;
  _QWORD *v39;
  NSObject *v40;
  const char *v41;
  const char *v42;
  size_t v43;
  uint64_t v44;
  size_t v45;
  const char *v46;
  const char *v47;
  uint64_t v48;
  _DWORD *v49;
  uint64_t v50;
  __int16 v51;
  __int16 v52;
  int v53;
  int v54;
  __int16 v55;
  int next_header;
  uint64_t v57;
  AAArchiveStream_impl *v58;
  char v59;
  unsigned __int8 v60;
  int Header;
  int v62;
  int v63;
  int v64;
  int *v65;
  NSObject *v66;
  const char *v67;
  const char *v68;
  size_t v69;
  char *v70;
  char *v71;
  char *v72;
  char *v73;
  int v74;
  int v75;
  NSObject *v76;
  const char *v77;
  char *v78;
  NSObject *v79;
  uint64_t v80;
  const char *v81;
  _BOOL4 v82;
  int *v83;
  int *v84;
  NSObject *v85;
  NSObject *v86;
  char *v87;
  char *SymlinkTarget;
  size_t v89;
  uint64_t *v90;
  uint64_t *v91;
  NSObject *v92;
  char *v93;
  uint64_t *v94;
  int v95;
  unsigned int *v96;
  unsigned int *v97;
  NSObject *v98;
  int v99;
  int *v100;
  char *v101;
  _QWORD *v102;
  uint64_t v103;
  int v104;
  NSObject *v105;
  BOOL v106;
  void *v107;
  NSObject *v108;
  uint64_t *v109;
  NSObject *v110;
  uint64_t *v111;
  uint64_t *v112;
  const char *v113;
  const char *v114;
  void *v115;
  NSObject *v116;
  char *v117;
  int v118;
  int *v119;
  char *v120;
  char *v121;
  uint64_t v122;
  uint64_t v123;
  unsigned int *v124;
  unsigned int *v125;
  NSObject *v126;
  NSObject *v127;
  uint64_t v129;
  uint64_t v130;
  const char *v131;
  _QWORD *v132;
  uint64_t v133;
  void *v134;
  void *v135;
  void *v136;
  char *v137;
  _QWORD v138[4];
  char *v139[4];
  char *__s;
  _BYTE buf[24];
  void *v142;
  char **v143;
  _QWORD *v144;
  uint64_t v145;
  void **v146;
  unsigned int *v147;
  uint64_t v148;

  v8 = a2;
  v148 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v10 = (_BYTE *)(a1 + 104);
    v133 = a1 + 112;
    v11 = &dword_206367000;
    while (1)
    {
      v134 = 0;
      v12 = *(uint64_t **)(a1 + 312);
      if (v12)
      {
        v13 = *(NSObject **)(a1 + 24);
        if (v13 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(v11, v13, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the pre-empt stack", buf, 2u);
          v12 = *(uint64_t **)(a1 + 312);
        }
        filesystem_entry = (unsigned int *)BOMStackPop(v12);
        v136 = 0;
        if (filesystem_entry)
          break;
      }
      else
      {
        v136 = 0;
      }
      if (*v10)
      {
LABEL_11:
        filesystem_entry = 0;
      }
      else
      {
        v16 = *(NSObject **)(a1 + 24);
        if (v16 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(v11, v16, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the source", buf, 2u);
        }
        switch(*(_DWORD *)(a1 + 100))
        {
          case 0:
            v139[0] = 0;
            if (*(_QWORD *)v133)
            {
              (*(void (**)(uint64_t, char **, _QWORD))v133)(a1, v139, *(_QWORD *)(a1 + 120));
              *(_QWORD *)v133 = 0;
              *(_QWORD *)(v133 + 8) = 0;
              v17 = *(NSObject **)(a1 + 24);
              if (v17)
              {
                if (os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  *(char **)&buf[4] = v139[0];
                  _os_log_impl(v11, v17, OS_LOG_TYPE_DEFAULT, "Redirected to %s", buf, 0xCu);
                }
              }
            }
            filesystem_entry = (unsigned int *)next_filesystem_entry(a1, v139[0], v10, (uint64_t *)&v136);
            if (v139[0])
              free(v139[0]);
            break;
          case 1:
            v48 = *(_QWORD *)(a1 + 200);
            if (!v48)
            {
              BOMCopierErrorCapture(&v136, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2837, (uint64_t)"next_enumeration_bom_entry", "The BOMCopierSource does not have an index bom enumerator", v129);
              goto LABEL_11;
            }
            v49 = BOMBomEnumeratorNext(v48);
            if (v49)
            {
              v50 = (uint64_t)v49;
              v51 = *(_BYTE *)(a1 + 64) == 0;
              if (*(_BYTE *)(a1 + 360))
                v51 |= 2u;
              if (*(_BYTE *)(a1 + 361))
                v51 |= 8u;
              if (*(_BYTE *)(a1 + 362))
                v51 |= 4u;
              if (*(_BYTE *)(a1 + 363))
                v51 |= 0x10u;
              if (*(_BYTE *)(a1 + 364))
                v51 |= 0x20u;
              if (*(_BYTE *)(a1 + 365))
                v51 |= 0x40u;
              if (*(_BYTE *)(a1 + 209))
                v51 |= 0x100u;
              if (*(_BYTE *)(a1 + 208))
                v52 = v51 | 0x80;
              else
                v52 = v51;
              filesystem_entry = (unsigned int *)BOMCopierSourceEntryNewFromFSObject(*(const char **)(a1 + 176), (uint64_t)v49, v52, &v136);
              if (filesystem_entry)
              {
                v53 = BOMFSObjectParentPathID(v50);
                v54 = BOMFSObjectPathID(v50);
                if (!v53 && v54 == 1)
                  BOMCopierSourceEntrySetRoot((uint64_t)filesystem_entry, 1);
                BOMFSObjectFree(v50);
                if (synthesize_filesystem_stuff())
                {
                  BOMCopierErrorCapture(&v136, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2918, (uint64_t)"next_enumeration_bom_entry", "Could not synthesize filesystem stuff");
                  BOMCopierSourceEntryFree(filesystem_entry);
                  goto LABEL_11;
                }
              }
              else
              {
                BOMCopierErrorCapture(&v136, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2900, (uint64_t)"next_enumeration_bom_entry", "Could not synthesize filesystem stuff");
                BOMFSObjectFree(v50);
              }
            }
            else
            {
              filesystem_entry = 0;
              *v10 = 1;
            }
            break;
          case 2:
            if (!*(_QWORD *)(a1 + 224))
            {
              BOMCopierErrorCapture(&v136, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2942, (uint64_t)"next_libarchive_entry", "copier_source->archive is NULL", v129);
              goto LABEL_11;
            }
            if (*(_BYTE *)(a1 + 360))
              v55 = (*(unsigned __int8 *)(a1 + 264) << 9) | 2;
            else
              v55 = *(unsigned __int8 *)(a1 + 264) << 9;
            *(_QWORD *)buf = 0;
            next_header = archive_read_next_header();
            if (archive_read_has_encrypted_entries() == 1
              && !*(_QWORD *)(a1 + 240)
              && !*(_QWORD *)(a1 + 248))
            {
              BOMCopierErrorCapture(&v136, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2973, (uint64_t)"next_libarchive_entry", "archive has encrypted entries");
              goto LABEL_11;
            }
            if (next_header == -30)
            {
              v81 = (const char *)archive_error_string();
              if (!v81 || strcmp(v81, "Invalid central directory signature"))
              {
                BOMCopierErrorCapture(&v136, -30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3010, (uint64_t)"next_libarchive_entry", "Could not read archive header: ARCHIVE_FATAL: %s");
                goto LABEL_11;
              }
              goto LABEL_186;
            }
            if (next_header == 1)
              goto LABEL_186;
            if (next_header)
            {
              archive_error_string();
              BOMCopierErrorCapture(&v136, next_header, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3018, (uint64_t)"next_libarchive_entry", "Could not read archive header: %d: %s");
              goto LABEL_11;
            }
            v57 = BOMCopierSourceEntryNewFromLibarchive(*(_QWORD *)(a1 + 224), *(uint64_t *)buf, v55, &v136);
LABEL_122:
            filesystem_entry = (unsigned int *)v57;
            break;
          case 3:
            v57 = next_data_archive_entry(a1, v10, &v136, a4, a5, a6, a7, a8);
            goto LABEL_122;
          case 4:
            v58 = *(AAArchiveStream_impl **)(a1 + 304);
            if (!v58)
            {
              BOMCopierErrorCapture(&v136, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3114, (uint64_t)"next_apple_archive_entry", "copier_source->aa_decoder is NULL", v129);
              goto LABEL_11;
            }
            if (*(_BYTE *)(a1 + 360))
              v59 = 2;
            else
              v59 = 0;
            if (*(_BYTE *)(a1 + 362))
              v59 |= 4u;
            if (*(_BYTE *)(a1 + 364))
              v60 = v59 | 0x20;
            else
              v60 = v59;
            *(_QWORD *)buf = 0;
            Header = AAArchiveStreamReadHeader(v58, (AAHeader *)buf);
            if (Header < 0)
            {
              v62 = 3146;
              goto LABEL_155;
            }
            if (Header == 1)
            {
              filesystem_entry = (unsigned int *)BOMCopierSourceEntryNewFromAppleArchive(*(_QWORD *)(a1 + 304), *(AAHeader *)buf, v60, &v136);
              AAHeaderDestroy(*(AAHeader *)buf);
            }
            else
            {
              if (Header)
              {
                v62 = 3154;
LABEL_155:
                BOMCopierErrorCapture(&v136, Header, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", v62, (uint64_t)"next_apple_archive_entry", "Could not read AppleArchive header: %d");
                goto LABEL_11;
              }
LABEL_186:
              filesystem_entry = 0;
              *v10 = 1;
            }
            break;
          default:
            goto LABEL_11;
        }
      }
      if (v136)
      {
        if (*(_DWORD *)(a1 + 16) == 1)
        {
          BOMCopierErrorFree(v136);
          *(_DWORD *)(a1 + 16) = 1;
          v15 = *(NSObject **)(a1 + 24);
          if (v15 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(v11, v15, OS_LOG_TYPE_DEFAULT, "Swallowing error", buf, 2u);
          }
        }
        else
        {
          v134 = v136;
          BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2354, (uint64_t)"next_source_entry", "Could not get the next source entry");
        }
        goto LABEL_318;
      }
      if (filesystem_entry)
        break;
LABEL_283:
      if (!*v10)
        goto LABEL_318;
      if (*(_QWORD *)(a1 + 344))
      {
        if (!*(_QWORD *)(a1 + 352))
        {
          v121 = (char *)BOMStackNew();
          *(_QWORD *)(a1 + 352) = v121;
          if (!v121)
          {
            BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4823, (uint64_t)"populate_sequester_stack", "Could not create empty sequester stack");
            goto LABEL_317;
          }
          v122 = *(_QWORD *)(a1 + 344);
          if (*(_BYTE *)(a1 + 93))
          {
            if (path_tree_node_push(*(_QWORD *)(a1 + 344), 0, v121, &v134))
            {
              BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4844, (uint64_t)"populate_sequester_stack", "Could not push root node %s onto the stack\n");
LABEL_317:
              BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2400, (uint64_t)"next_source_entry", "Could not populate sequester stack");
              goto LABEL_318;
            }
          }
          else if (*(_DWORD *)(v122 + 8))
          {
            v123 = 0;
            while (!path_tree_node_push(*(_QWORD *)(*(_QWORD *)(v122 + 16) + 8 * v123), ".", *(char **)(a1 + 352), &v134))
            {
              if (++v123 >= (unint64_t)*(unsigned int *)(v122 + 8))
                goto LABEL_286;
            }
            BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4860, (uint64_t)"populate_sequester_stack", "Could not push child %s of %s onto the stack\n");
            goto LABEL_317;
          }
        }
LABEL_286:
        v108 = *(NSObject **)(a1 + 24);
        if (v108 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(v11, v108, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the sequester stack", buf, 2u);
        }
        v91 = BOMStackPop(*(uint64_t **)(a1 + 352));
        if (v91)
          goto LABEL_302;
      }
      v109 = *(uint64_t **)(a1 + 320);
      if (v109 || *(_QWORD *)(a1 + 328) || *(_QWORD *)(a1 + 336))
      {
        v110 = *(NSObject **)(a1 + 24);
        if (v110 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(v11, v110, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the replay stacks", buf, 2u);
          v109 = *(uint64_t **)(a1 + 320);
        }
        if (v109)
        {
          v91 = BOMStackPop(v109);
          if (v91)
            goto LABEL_302;
        }
        v111 = *(uint64_t **)(a1 + 328);
        if (v111)
        {
          v91 = BOMStackPop(v111);
          if (v91)
            goto LABEL_302;
        }
        v112 = *(uint64_t **)(a1 + 336);
        if (v112)
        {
          v91 = BOMStackPop(v112);
          if (v91)
            goto LABEL_302;
        }
      }
LABEL_318:
      v107 = v134;
      if (v134)
      {
LABEL_352:
        v91 = 0;
        if (v8)
          *v8 = v107;
        return v91;
      }
      if (*v10)
        return 0;
    }
    v135 = 0;
    if ((*(_DWORD *)(a1 + 100) - 2) <= 2 && *(_QWORD *)(a1 + 216))
    {
      Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (!Path)
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3181, (uint64_t)"filter_next_source_entry", "Could not get entry path for source entry", v129);
LABEL_49:
        v23 = filesystem_entry;
LABEL_50:
        BOMCopierSourceEntryFree(v23);
        goto LABEL_282;
      }
      *(_QWORD *)buf = 0;
      if (*Path == 46)
      {
        v19 = (uint64_t)Path;
      }
      else if (asprintf((char **)buf, "./%s", Path) == -1 || (v19 = *(_QWORD *)buf) == 0)
      {
        v63 = *__error();
        BOMCopierErrorCapture(&v135, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3194, (uint64_t)"filter_next_source_entry", "Could not construct lookup path for skip bom from %s");
        goto LABEL_49;
      }
      v20 = BOMBomFSObjectExistsAtPath(*(_QWORD *)(a1 + 216), v19);
      if (*(_QWORD *)buf)
        free(*(void **)buf);
      if (!v20)
      {
        if (consume_source_entry(filesystem_entry, &v135))
        {
          v22 = 3216;
          goto LABEL_48;
        }
LABEL_282:
        v107 = v135;
        if (v135)
          goto LABEL_352;
        goto LABEL_283;
      }
    }
    if ((*(_BYTE *)(a1 + 93) || *(_BYTE *)(a1 + 94)) && BOMCopierSourceEntryIsRoot((uint64_t)filesystem_entry))
    {
      v21 = *(NSObject **)(a1 + 24);
      if (v21 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(v11, v21, OS_LOG_TYPE_DEFAULT, "Consuming root entry", buf, 2u);
      }
      if (consume_source_entry(filesystem_entry, &v135))
      {
        v22 = 3240;
LABEL_48:
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", v22, (uint64_t)"filter_next_source_entry", "Could not consume the source entry", v129);
        goto LABEL_49;
      }
      goto LABEL_282;
    }
    v24 = v11;
    Type = BOMCopierSourceEntryGetType((uint64_t)filesystem_entry);
    if (*(_BYTE *)(a1 + 96))
    {
      v26 = BOMCopierSourceEntryGetType((uint64_t)filesystem_entry);
      if (v26 <= 0xE && ((1 << v26) & 0x6040) != 0)
      {
        v27 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
        if (v27)
        {
          v28 = v27;
          v29 = strlen(v27);
          v30 = *(unsigned __int8 *)v28;
          v31 = v30 == 46 ? 10 : 8;
          if (v29 >= v31)
          {
            v32 = v30 == 46 ? "./__MACOSX" : "__MACOSX";
            if (!strncmp(v28, v32, v31))
            {
              v66 = *(NSObject **)(a1 + 24);
              v11 = v24;
              if (v66 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(v24, v66, OS_LOG_TYPE_DEFAULT, "Consuming __MACOSX directory entry", buf, 2u);
              }
              if (consume_source_entry(filesystem_entry, &v135))
              {
                v22 = 3268;
                goto LABEL_48;
              }
              goto LABEL_282;
            }
          }
        }
      }
    }
    if (!is_apple_double(filesystem_entry))
      goto LABEL_203;
    if (*(_BYTE *)(a1 + 95))
    {
      v33 = *(NSObject **)(a1 + 24);
      if (v33 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(v24, v33, OS_LOG_TYPE_DEFAULT, "Sequestering __MACOSX entry", buf, 2u);
      }
      v34 = BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (v34)
      {
        v35 = (const char *)v34;
        v36 = *(NSObject **)(a1 + 24);
        if (v36 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v35;
          _os_log_impl(v24, v36, OS_LOG_TYPE_DEFAULT, "Sequestering AppleDouble from %s", buf, 0xCu);
        }
        v37 = "./__MACOSX";
        if (*(_BYTE *)(a1 + 93))
          v37 = "__MACOSX";
        v38 = &v35[2 * (*v35 == 46)];
        v137 = 0;
        if (asprintf(&v137, "%s/%s", v37, v38) != -1 && v137)
        {
          if (BOMCopierSourceEntrySetPath(filesystem_entry, v137))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4393, (uint64_t)"sequester_apple_double", "Could not create set sequester path entry for %s", v35);
LABEL_269:
            BOMCopierSourceEntryFree(filesystem_entry);
            goto LABEL_270;
          }
          free(v137);
          v67 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
          v68 = v67;
          v139[0] = 0;
          v139[1] = (char *)v139;
          v139[2] = (char *)0x2000000000;
          v139[3] = 0;
          v138[0] = 0;
          v138[1] = v138;
          v138[2] = 0x2000000000;
          v138[3] = 0;
          *(_QWORD *)buf = MEMORY[0x24BDAC760];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = __add_sequester_entry_block_invoke;
          v142 = &unk_24BF06CA0;
          v145 = a1;
          v146 = &v135;
          v143 = v139;
          v144 = v138;
          v147 = filesystem_entry;
          if (v67)
          {
            v69 = strlen(v67);
            __s = 0;
            if (v69 == asprintf(&__s, "%s", v68))
            {
              v70 = __s;
              if (__s)
              {
                v131 = v68;
                v132 = v8;
                v71 = strchr(__s, 47);
                v72 = v70;
                v73 = v70;
                if (v71)
                {
                  while (1)
                  {
                    *v71 = 0;
                    v74 = (*(uint64_t (**)(_BYTE *, char *, _QWORD))&buf[16])(buf, v72, 0);
                    if (v74)
                      break;
                    *v71 = 47;
                    v72 = v71 + 1;
                    v73 = __s;
                    if (v71 + 1 - __s < v69)
                    {
                      v71 = strchr(v71 + 1, 47);
                      if (v71)
                        continue;
                    }
                    goto LABEL_163;
                  }
                  v75 = v74;
                  v73 = __s;
                }
                else
                {
LABEL_163:
                  if (v72 == &v70[v69]
                    || (v75 = (*(uint64_t (**)(_BYTE *, char *, uint64_t))&buf[16])(buf, v72, 1),
                        v73 = __s,
                        !v75))
                  {
                    free(v73);
                    v8 = v132;
LABEL_267:
                    _Block_object_dispose(v138, 8);
                    _Block_object_dispose(v139, 8);
                    goto LABEL_281;
                  }
                }
                free(v73);
                v106 = v75 == -1;
                v68 = v131;
                v8 = v132;
                if (!v106)
                  goto LABEL_267;
              }
            }
          }
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4806, (uint64_t)"add_sequester_entry", "Could not add sequester entry for %s", v68);
          _Block_object_dispose(v138, 8);
          _Block_object_dispose(v139, 8);
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4408, (uint64_t)"sequester_apple_double", "Could not create set sequester path entry for %s", v35);
          goto LABEL_269;
        }
        v64 = *__error();
        v65 = __error();
        strerror(*v65);
        BOMCopierErrorCapture(&v135, v64, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4385, (uint64_t)"sequester_apple_double", "Could not create sequester path for %s: %s");
      }
      else
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4359, (uint64_t)"sequester_apple_double", "Could not retrieve entry path for AppleDouble entry");
      }
LABEL_270:
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3300, (uint64_t)"filter_next_source_entry", "Could not sequester AppleDouble entry", v130);
      goto LABEL_281;
    }
    v39 = v8;
    if (*(_BYTE *)(a1 + 96))
    {
      v40 = *(NSObject **)(a1 + 24);
      if (v40 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(v24, v40, OS_LOG_TYPE_DEFAULT, "Unsequestering __MACOSX entry", buf, 2u);
      }
      v41 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (v41)
      {
        v42 = v41;
        v43 = strlen(v41);
        if (*v42 == 46)
        {
          v44 = 0;
          v45 = 10;
          v46 = "./__MACOSX";
          v47 = ".";
        }
        else
        {
          v45 = 8;
          v46 = "__MACOSX";
          v47 = "";
          v44 = 1;
        }
        if (v43 < v45 || strncmp(v42, v46, v45))
          goto LABEL_169;
        *(_QWORD *)buf = 0;
        if (asprintf((char **)buf, "%s%s", v47, &v42[v45 + v44]) == -1 || !*(_QWORD *)buf)
        {
          v99 = *__error();
          v100 = __error();
          v101 = strerror(*v100);
          BOMCopierErrorCapture(&v135, v99, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4466, (uint64_t)"unsequester_apple_double", "Could not created adjusted path for %s: %s", v42, v101);
          v8 = v39;
        }
        else
        {
          v82 = BOMCopierSourceEntrySetPath(filesystem_entry, *(char **)buf);
          free(*(void **)buf);
          if (!v82)
            goto LABEL_169;
          v8 = v39;
          v83 = __error();
          strerror(*v83);
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4476, (uint64_t)"unsequester_apple_double", "Could not set adjusted path %s: %s");
        }
      }
      else
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4429, (uint64_t)"unsequester_apple_double", "Could not retrieve entry path for AppleDouble entry");
      }
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3317, (uint64_t)"filter_next_source_entry", "Could not unsequester AppleDouble file");
LABEL_151:
      BOMCopierSourceEntryFree(filesystem_entry);
      goto LABEL_281;
    }
LABEL_169:
    v8 = v39;
    if (*(_BYTE *)(a1 + 71))
    {
      v76 = *(NSObject **)(a1 + 24);
      v11 = v24;
      if (v76 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(v24, v76, OS_LOG_TYPE_DEFAULT, "Deferring AppleDouble entry", buf, 2u);
      }
      if (push_replay_stack((_QWORD *)a1, (uint64_t)filesystem_entry, 2, &v135))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3331, (uint64_t)"filter_next_source_entry", "Could not push AppleDouble onto the replay stack", v129);
        goto LABEL_49;
      }
      goto LABEL_282;
    }
    if (*(_QWORD *)(a1 + 80))
    {
      v77 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      v139[0] = 0;
      asprintf(v139, "%s%s", v77, *(const char **)(a1 + 80));
      v78 = v139[0];
      if (!v139[0])
      {
        v84 = __error();
        strerror(*v84);
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3353, (uint64_t)"filter_next_source_entry", "Could not constructed adjusted AppleDouble path: %s");
        goto LABEL_281;
      }
      v79 = *(NSObject **)(a1 + 24);
      if (v79 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        v80 = *(_QWORD *)(a1 + 80);
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v80;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v77;
        _os_log_impl(v24, v79, OS_LOG_TYPE_DEFAULT, "Appending suffix %s to %s", buf, 0x16u);
        v78 = v139[0];
      }
      if (BOMCopierSourceEntrySetPath(filesystem_entry, v78))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3362, (uint64_t)"filter_next_source_entry", "Could not set appended entry path for AppleDouble file", v129);
        goto LABEL_281;
      }
      free(v139[0]);
    }
    if (Type == 8)
    {
      if (*(_BYTE *)(a1 + 72))
      {
        v85 = *(NSObject **)(a1 + 24);
        if (v85 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(v24, v85, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble replay entry", buf, 2u);
        }
        if (synthesize_replay_apple_double(a1, filesystem_entry, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3382, (uint64_t)"filter_next_source_entry", "Could not replay AppleDouble file");
          goto LABEL_151;
        }
      }
      goto LABEL_219;
    }
LABEL_203:
    if (*(_BYTE *)(a1 + 91) && Type == 9)
    {
      v86 = *(NSObject **)(a1 + 24);
      if (v86 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(v24, v86, OS_LOG_TYPE_DEFAULT, "Synthesizing replay symlink entry", buf, 2u);
      }
      v87 = (char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      SymlinkTarget = (char *)BOMCopierSourceEntryGetSymlinkTarget((uint64_t)filesystem_entry);
      v89 = strlen(SymlinkTarget);
      v90 = (uint64_t *)BOMCopierSourceEntryNew(8, &v135);
      if (v90)
      {
        v91 = v90;
        if (BOMCopierSourceEntrySetPath(v90, v87))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4115, (uint64_t)"synthesize_replay_symlink", "Could not set the path for the regular file entry");
LABEL_279:
          v96 = (unsigned int *)v91;
          goto LABEL_280;
        }
        if (BOMCopierSourceEntrySetData((uint64_t)v91, SymlinkTarget, v89))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4123, (uint64_t)"synthesize_replay_symlink", "Could not set the data for the regular file entry");
          goto LABEL_279;
        }
        if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v91, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4131, (uint64_t)"synthesize_replay_symlink", "Could not copy metadata from the symlink entry to its regular file doppleganger");
          goto LABEL_279;
        }
        if (BOMCopierSourceEntrySetMode((uint64_t)v91, 33188))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4139, (uint64_t)"synthesize_replay_symlink", "Could not set the mode for the regular file entry");
          goto LABEL_279;
        }
        v102 = BOMCopierSourceEntryNew(18, &v135);
        if (!v102)
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4155, (uint64_t)"synthesize_replay_symlink", "Could create a post order symlink entry");
          goto LABEL_279;
        }
        v103 = (uint64_t)v102;
        if (BOMCopierSourceEntrySetPath(v102, v87))
        {
          v104 = 4163;
LABEL_258:
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", v104, (uint64_t)"synthesize_replay_symlink", "Could not set the path for the post order symlink entry");
          goto LABEL_279;
        }
        if (copy_entry_metadata((uint64_t)filesystem_entry, v103, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4171, (uint64_t)"synthesize_replay_symlink", "Could not copy metadata from the symlink entry to its replay symlink");
          goto LABEL_279;
        }
        if (BOMCopierSourceEntrySetSymlinkTarget(v103, SymlinkTarget))
        {
          v104 = 4179;
          goto LABEL_258;
        }
        if (push_replay_stack((_QWORD *)a1, v103, 1, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4187, (uint64_t)"synthesize_replay_symlink", "Could not push the synthetic post-order symlink");
          goto LABEL_279;
        }
        v126 = *(NSObject **)(a1 + 24);
        if (v126 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v87;
          _os_log_impl(v24, v126, OS_LOG_TYPE_DEFAULT, "Synthesizing replay symlink from %s", buf, 0xCu);
        }
        if (!consume_source_entry(filesystem_entry, &v135))
          goto LABEL_220;
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4202, (uint64_t)"synthesize_replay_symlink", "Could not consume the symlink entry");
        v96 = filesystem_entry;
      }
      else
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4107, (uint64_t)"synthesize_replay_symlink", "Could create a regular file entry");
        v96 = 0;
      }
LABEL_280:
      BOMCopierSourceEntryFree(v96);
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3411, (uint64_t)"filter_next_source_entry", "Could not synthesize replay symlink", v129);
      goto LABEL_281;
    }
    if (!*(_BYTE *)(a1 + 92) || Type != 6)
    {
LABEL_219:
      v91 = (uint64_t *)filesystem_entry;
LABEL_220:
      if (!*(_BYTE *)(a1 + 89)
        || (v95 = BOMCopierSourceEntryGetType((uint64_t)v91), v95 != 14)
        && v95 != 16
        && (v95 != 15 || !is_apple_double(v91)))
      {
LABEL_246:
        v11 = v24;
LABEL_302:
        if (!*(_BYTE *)(a1 + 265))
          return v91;
        v113 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v91);
        v114 = v113;
        v115 = *(void **)(a1 + 272);
        if (v115)
        {
          if (!strcmp(v113, *(const char **)(a1 + 272)))
          {
            v116 = *(NSObject **)(a1 + 24);
            if (v116 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(v11, v116, OS_LOG_TYPE_DEFAULT, "Marking segmented file entry", buf, 2u);
            }
            BOMCopierSourceEntrySetSegmentedFile((uint64_t)v91, 1);
            v115 = *(void **)(a1 + 272);
          }
          free(v115);
        }
        v117 = strdup(v114);
        *(_QWORD *)(a1 + 272) = v117;
        if (v117)
          return v91;
        v118 = *__error();
        v119 = __error();
        v120 = strerror(*v119);
        BOMCopierErrorCapture(&v134, v118, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2493, (uint64_t)"next_source_entry", "Could not duplicate entry path: %s", v120);
        BOMCopierSourceEntryFree((unsigned int *)v91);
        goto LABEL_318;
      }
      switch(Type)
      {
        case 16:
          v11 = v24;
          if (push_replay_stack((_QWORD *)a1, (uint64_t)v91, 1, &v135))
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3486, (uint64_t)"filter_next_source_entry", "Could not push the extra symlink entry onto the replay stack");
          goto LABEL_282;
        case 15:
          if (!*(_BYTE *)(a1 + 90))
            goto LABEL_246;
          v98 = *(NSObject **)(a1 + 24);
          v11 = v24;
          if (v98 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(v24, v98, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble replay entry from extra AppleDouble entry", buf, 2u);
          }
          if (synthesize_replay_apple_double(a1, v91, &v135))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3503, (uint64_t)"filter_next_source_entry", "Could not replay AppleDouble file");
          }
          else
          {
            v105 = *(NSObject **)(a1 + 24);
            if (v105 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(v24, v105, OS_LOG_TYPE_DEFAULT, "Consuming extra AppleDouble entry", buf, 2u);
            }
            if (!consume_source_entry((unsigned int *)v91, &v135))
              goto LABEL_282;
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3513, (uint64_t)"filter_next_source_entry", "Could not consume the source entry");
          }
          v23 = (unsigned int *)v91;
          goto LABEL_50;
        case 14:
          v11 = v24;
          if (push_replay_stack((_QWORD *)a1, (uint64_t)v91, 3, &v135))
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3473, (uint64_t)"filter_next_source_entry", "Could not push the extra directory entry onto the replay stack");
          goto LABEL_282;
      }
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3525, (uint64_t)"filter_next_source_entry", "Cannot convert %u to replay entry");
LABEL_281:
      v11 = v24;
      goto LABEL_282;
    }
    v92 = *(NSObject **)(a1 + 24);
    if (v92 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(v24, v92, OS_LOG_TYPE_DEFAULT, "Synthesizing replay directory entry", buf, 2u);
    }
    v93 = (char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
    v94 = (uint64_t *)BOMCopierSourceEntryNew(6, &v135);
    if (v94)
    {
      v91 = v94;
      if (BOMCopierSourceEntrySetPath(v94, v93))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4239, (uint64_t)"synthesize_replay_directory", "Could not set the path for the directory entry");
      }
      else if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v91, &v135))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4248, (uint64_t)"synthesize_replay_directory", "Could not copy metadata from the source entry to its directory doppleganger");
      }
      else if (BOMCopierSourceEntrySetMode((uint64_t)v91, 16877))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4257, (uint64_t)"synthesize_replay_directory", "Could not set the mode for the directory entry");
      }
      else if (BOMCopierSourceEntrySetUserID((uint64_t)v91, *(_DWORD *)(a1 + 32)))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4266, (uint64_t)"synthesize_replay_directory", "Could not set the user ID for the directory entry");
      }
      else if (BOMCopierSourceEntrySetGroupID((uint64_t)v91, *(_DWORD *)(a1 + 36)))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4275, (uint64_t)"synthesize_replay_directory", "Could not set the group ID for the directory entry");
      }
      else
      {
        v124 = BOMCopierSourceEntryNew(19, &v135);
        if (v124)
        {
          v125 = v124;
          if (BOMCopierSourceEntrySetPath(v124, v93))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4300, (uint64_t)"synthesize_replay_directory", "Could not copy entry path from the source entry to its replay directory");
          }
          else if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v125, &v135))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4310, (uint64_t)"synthesize_replay_directory", "Could not copy metadata from the source entry to its replay directory");
          }
          else
          {
            if (!push_replay_stack((_QWORD *)a1, (uint64_t)v125, 3, &v135))
            {
              v127 = *(NSObject **)(a1 + 24);
              if (v127 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = v93;
                _os_log_impl(v24, v127, OS_LOG_TYPE_DEFAULT, "Synthesized replay directory from %s", buf, 0xCu);
              }
              if (!consume_source_entry(filesystem_entry, &v135))
                goto LABEL_220;
              BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4337, (uint64_t)"synthesize_replay_directory", "Could not consume the source entry");
LABEL_275:
              BOMCopierSourceEntryFree(filesystem_entry);
              BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3440, (uint64_t)"filter_next_source_entry", "Could not synthesize replay directory", v129);
              goto LABEL_281;
            }
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4320, (uint64_t)"synthesize_replay_directory", "Could not push the synthetic replay directory onto the replay stack");
          }
          BOMCopierSourceEntryFree(v125);
        }
        else
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4291, (uint64_t)"synthesize_replay_directory", "Could not create BOMCopierSourceEntry for replay directory");
        }
      }
      v97 = (unsigned int *)v91;
    }
    else
    {
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4230, (uint64_t)"synthesize_replay_directory", "Could create a directory entry");
      v97 = 0;
    }
    BOMCopierSourceEntryFree(v97);
    goto LABEL_275;
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1471, (uint64_t)"BOMCopierSourceNext", "copier_source is NULL");
  return 0;
}

uint64_t next_filesystem_entry(uint64_t a1, char *a2, _BYTE *a3, uint64_t *a4)
{
  FTS *v6;
  char v8;
  char v9;
  unsigned int *v10;
  unsigned int *v11;
  FTSENT *v14;
  uint64_t v15;
  int v16;
  int *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  unsigned int *v26;
  unsigned int *v27;
  NSObject *v28;
  int v29;
  char *v30;
  int v31;
  NSObject *v32;
  NSObject *v33;
  uint8_t buf[16];
  statfs v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v6 = *(FTS **)(a1 + 152);
  if (!v6)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2519, (uint64_t)"next_filesystem_entry", "The BOMCopierSource does not have an open FTS handle");
    return 0;
  }
  v8 = *(_BYTE *)(a1 + 64) == 0;
  if (*(_BYTE *)(a1 + 360))
    v8 |= 2u;
  if (*(_BYTE *)(a1 + 361))
    v8 |= 8u;
  if (*(_BYTE *)(a1 + 362))
    v8 |= 4u;
  if (*(_BYTE *)(a1 + 363))
    v8 |= 0x10u;
  if (*(_BYTE *)(a1 + 364))
    v8 |= 0x20u;
  if (*(_BYTE *)(a1 + 365))
    v9 = v8 | 0x40;
  else
    v9 = v8;
  if (a2)
  {
    v10 = (unsigned int *)BOMCopierSourceEntryNewFromPath(a2, v9, a4);
    if (!v10)
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2574, (uint64_t)"next_filesystem_entry", "Could not create BOMCopierSourceEntry from redirect path %s", a2);
      return (uint64_t)v10;
    }
    if (synthesize_filesystem_stuff())
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2582, (uint64_t)"next_filesystem_entry", "Could not synthesize filesystem stuff");
LABEL_19:
      v11 = v10;
LABEL_20:
      BOMCopierSourceEntryFree(v11);
      return 0;
    }
    v18 = *(NSObject **)(a1 + 24);
    if (v18 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
    {
      v35.f_bsize = 136315138;
      *(_QWORD *)&v35.f_iosize = a2;
      _os_log_impl(&dword_206367000, v18, OS_LOG_TYPE_DEFAULT, "Entry created from redirect path %s", (uint8_t *)&v35, 0xCu);
    }
  }
  else
  {
    v14 = fts_read(v6);
    if (v14)
    {
      v15 = (uint64_t)v14;
      if (v14->fts_statp->st_dev != *(_DWORD *)(a1 + 164))
      {
        bzero(&v35, 0x878uLL);
        if (statfs(*(const char **)(v15 + 48), &v35))
        {
          v16 = *__error();
          v17 = __error();
          strerror(*v17);
          BOMCopierErrorCapture(a4, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2627, (uint64_t)"next_filesystem_entry", "Could not statfs %s: %s");
          return 0;
        }
        *(_BYTE *)(a1 + 168) = (v35.f_flags & 8) == 0;
        *(_DWORD *)(a1 + 164) = **(_DWORD **)(v15 + 96);
      }
      v20 = *(NSObject **)(a1 + 24);
      if (v20 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v35.f_bsize) = 0;
        _os_log_impl(&dword_206367000, v20, OS_LOG_TYPE_DEFAULT, "Creating source entry from FTS entry", (uint8_t *)&v35, 2u);
      }
      v21 = BOMCopierSourceEntryNewFromFTSENT(v15, v9, a4);
      if (!v21)
      {
        if (*(_QWORD *)a1)
        {
          v22 = *(_QWORD *)(v15 + 48);
          *(_QWORD *)&v35.f_bsize = 0;
          v35.f_blocks = v22;
          v35.f_bfree = 0;
          LODWORD(v35.f_bfree) = *__error();
          if (a4)
          {
            v23 = *a4;
            *(_QWORD *)&v35.f_bsize = v23;
            if (v23)
              LODWORD(v35.f_bfree) = BOMCopierErrorGetCode(v23);
          }
          v24 = *(NSObject **)(a1 + 24);
          if (v24 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_206367000, v24, OS_LOG_TYPE_DEFAULT, "Could not create FTS entry. Calling error handler", buf, 2u);
          }
          *(_DWORD *)(a1 + 16) = (*(uint64_t (**)(uint64_t, _QWORD, statfs *))a1)(a1, *(_QWORD *)(a1 + 8), &v35);
        }
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2676, (uint64_t)"next_filesystem_entry", "Could not create BOMCopierSourceEntry from FTS entry");
        return 0;
      }
      v10 = (unsigned int *)v21;
      BOMCopierSourceEntrySetHonorsSetuid(v21, *(_BYTE *)(a1 + 168));
      if (*(_WORD *)(v15 + 86))
      {
        if (adjust_filesystem_entry_path(a1, v15, v10, a4))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2780, (uint64_t)"next_filesystem_entry", "Could not adjust entry path");
          goto LABEL_19;
        }
        if (!*(_BYTE *)(a1 + 88) || !is_apple_double(v10))
        {
          if (!synthesize_filesystem_stuff())
            return (uint64_t)v10;
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2812, (uint64_t)"next_filesystem_entry", "Could not synthesize filesystem stuff");
          goto LABEL_19;
        }
        v28 = *(NSObject **)(a1 + 24);
        if (v28 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35.f_bsize) = 0;
          _os_log_impl(&dword_206367000, v28, OS_LOG_TYPE_DEFAULT, "Consuming AppleDouble entry", (uint8_t *)&v35, 2u);
        }
        if (consume_source_entry(v10, a4))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2796, (uint64_t)"next_filesystem_entry", "Could not consume the source entry");
          goto LABEL_19;
        }
        v33 = *(NSObject **)(a1 + 24);
        if (v33 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35.f_bsize) = 0;
          _os_log_impl(&dword_206367000, v33, OS_LOG_TYPE_DEFAULT, "Ignored AppleDouble", (uint8_t *)&v35, 2u);
        }
        return next_filesystem_entry(a1, 0, a3, a4);
      }
      else
      {
        if (*(_BYTE *)(a1 + 376))
        {
          v25 = *(NSObject **)(a1 + 24);
          if (v25 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v35.f_bsize) = 0;
            _os_log_impl(&dword_206367000, v25, OS_LOG_TYPE_DEFAULT, "Synthesizing parent entry from FTS root entry", (uint8_t *)&v35, 2u);
          }
          v26 = (unsigned int *)BOMCopierSourceEntryNewFromFTSENT(v15, v9, a4);
          if (!v26)
          {
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2702, (uint64_t)"next_filesystem_entry", "Could not create parent from FTS entry");
            goto LABEL_19;
          }
          v27 = v26;
          if (adjust_filesystem_entry_path(a1, v15, v26, a4))
          {
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2711, (uint64_t)"next_filesystem_entry", "Could not adjust entry path");
            v11 = v27;
            goto LABEL_20;
          }
        }
        else
        {
          v27 = 0;
        }
        v29 = *(unsigned __int16 *)(v15 + 88);
        if (v29 == 6 || v29 == 1)
        {
          v30 = ".";
        }
        else
        {
          memset(&v35, 0, 255);
          basename_r(*(const char **)(v15 + 48), (char *)&v35);
          v30 = (char *)&v35;
        }
        BOMCopierSourceEntrySetPath(v10, v30);
        BOMCopierSourceEntrySetRoot((uint64_t)v10, 1);
        if (v27)
        {
          v31 = *(unsigned __int16 *)(v15 + 88);
          v32 = *(NSObject **)(a1 + 24);
          if (v31 == 1)
          {
            if (v32 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v35.f_bsize) = 0;
              _os_log_impl(&dword_206367000, v32, OS_LOG_TYPE_DEFAULT, "Pushing entry onto the pre-empt stack", (uint8_t *)&v35, 2u);
            }
            if (!push_preempt_stack(a1, (uint64_t)v27, a4))
              return (uint64_t)v10;
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2751, (uint64_t)"next_filesystem_entry", "Could not push parent entry onto the preempty stack");
          }
          else
          {
            if (v32 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v35.f_bsize) = 0;
              _os_log_impl(&dword_206367000, v32, OS_LOG_TYPE_DEFAULT, "Pushing root entry onto the pre-empt stack", (uint8_t *)&v35, 2u);
            }
            if (!push_preempt_stack(a1, (uint64_t)v10, a4))
              return (uint64_t)v27;
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2764, (uint64_t)"next_filesystem_entry", "Could not push parent entry onto the preempty stack");
          }
          BOMCopierSourceEntryFree(v27);
          goto LABEL_19;
        }
      }
    }
    else
    {
      fts_close(*(FTS **)(a1 + 152));
      *(_QWORD *)(a1 + 152) = 0;
      free(*(void **)(a1 + 128));
      *(_QWORD *)(a1 + 128) = 0;
      v19 = *(NSObject **)(a1 + 24);
      if (v19 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v35.f_bsize) = 0;
        _os_log_impl(&dword_206367000, v19, OS_LOG_TYPE_DEFAULT, "FTS exhausted", (uint8_t *)&v35, 2u);
      }
      v10 = 0;
      *a3 = 1;
    }
  }
  return (uint64_t)v10;
}

uint64_t next_data_archive_entry(uint64_t a1, _BYTE *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  __int16 v12;
  _DWORD *v13;
  _QWORD *v14;
  unsigned int type;
  NSObject *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  void *v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a1 + 280);
  if (!v10)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3042, (uint64_t)"next_data_archive_entry", "copier_source->data_archive is NULL");
    return 0;
  }
  if (*(_BYTE *)(a1 + 360))
    v12 = (*(unsigned __int8 *)(a1 + 264) << 9) | 2;
  else
    v12 = *(unsigned __int8 *)(a1 + 264) << 9;
  v21 = 0;
  v13 = data_archive_read_entry(v10, &v21, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!v13)
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3064, (uint64_t)"next_data_archive_entry", "Could not read next data_archive entry: %s", *((const char **)v21 + 4));
    release_error(v21);
    return 0;
  }
  v14 = v13;
  type = data_archive_entry_get_type(v13);
  v16 = *(NSObject **)(a1 + 24);
  if (v16 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
  {
    v17 = data_archive_entry_path((uint64_t)v14);
    if (type > 4)
      v18 = "?";
    else
      v18 = off_24BF06CC0[type];
    *(_DWORD *)buf = 136315394;
    v23 = v17;
    v24 = 2080;
    v25 = v18;
    _os_log_impl(&dword_206367000, v16, OS_LOG_TYPE_DEFAULT, "%s [%s]", buf, 0x16u);
  }
  if (type == 1)
  {
    *a2 = 1;
    data_archive_entry_free(v14);
    return 0;
  }
  if (type == 4)
  {
    data_archive_entry_free(v14);
    return next_data_archive_entry(a1, a2, a3);
  }
  else
  {
    v19 = BOMCopierSourceEntryNewFromDataArchive(*(_QWORD *)(a1 + 280), v14, v12, a3);
    data_archive_entry_free(v14);
  }
  return v19;
}

uint64_t synthesize_filesystem_stuff()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  copyfile_flags_t v8;
  const char *ActualPath;
  int v10;
  int *v11;
  int v12;
  int *v13;
  uint64_t v14;
  unsigned int *v15;
  const char *Path;
  NSObject *v17;
  NSObject *v19;
  const char *v20;
  int v21;
  int v22;
  int *v23;
  int v24;
  int *v25;
  unsigned int *v26;
  unsigned int *v27;
  const char *v28;
  NSObject *v29;
  uint64_t v30;
  char *v31;
  char __str[16];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _BYTE v46[31];
  _OWORD v47[64];
  uint8_t v48[4];
  const char *v49;
  char __s[1024];
  _BYTE buf[1024];
  stat v52;
  uint64_t v53;

  v0 = MEMORY[0x24BDAC7A8]();
  v3 = v2;
  v4 = v1;
  v5 = v0;
  v53 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(v0 + 67) || BOMCopierSourceEntryGetType(v1) == 13)
    goto LABEL_28;
  v6 = *(NSObject **)(v5 + 24);
  if (v6 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_206367000, v6, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble entry", buf, 2u);
  }
  v7 = *(_BYTE *)(v5 + 68) || *(_BYTE *)(v5 + 69) ? 4980740 : 4980736;
  v8 = v7 | *(unsigned __int8 *)(v5 + 70);
  ActualPath = (const char *)BOMCopierSourceEntryGetActualPath(v4);
  if ((copyfile(ActualPath, 0, 0, v8 | 0x10000) & v8) == 0)
    goto LABEL_28;
  memcpy(buf, "/tmp/.BC.T_XXXXXX", sizeof(buf));
  if (!mktemp(buf))
  {
    v12 = *__error();
    v13 = __error();
    strerror(*v13);
    BOMCopierErrorCapture(v3, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3789, (uint64_t)"synthesize_apple_double", "Could not mktemp %s: %s");
    goto LABEL_14;
  }
  if (!copyfile(ActualPath, buf, 0, v8))
  {
    v14 = BOMCopierSourceEntryNewFromPath(buf, 0, v3);
    if (!v14)
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3808, (uint64_t)"synthesize_apple_double", "Could not create BOMCopierSourceEntry from %s", buf);
      unlink(buf);
      goto LABEL_14;
    }
    v15 = (unsigned int *)v14;
    Path = (const char *)BOMCopierSourceEntryGetPath(v4);
    bzero(__s, 0x400uLL);
    bzero(v47, 0x400uLL);
    dirname_r(Path, __s);
    basename_r(Path, (char *)v47);
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s/%s%s", __s, "._", (const char *)v47);
    if (BOMCopierSourceEntrySetPath(v15, __str))
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3828, (uint64_t)"synthesize_apple_double", "Could not create set path entry for %s");
LABEL_24:
      BOMCopierSourceEntryFree(v15);
      goto LABEL_14;
    }
    if (BOMCopierSourceEntrySetOption((uint64_t)v15, CFSTR("DeleteOnFree"), (const void *)*MEMORY[0x24BDBD270]))
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3836, (uint64_t)"synthesize_apple_double", "Could not set kBOMCopierSourceEntryDeleteOnFree option", v30);
      goto LABEL_24;
    }
    if (push_preempt_stack(v5, (uint64_t)v15, v3))
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3844, (uint64_t)"synthesize_apple_double", "Could not push synthetic AppleDouble entry", v30);
      goto LABEL_24;
    }
    v17 = *(NSObject **)(v5 + 24);
    if (v17 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
    {
      v52.st_dev = 136315138;
      *(_QWORD *)&v52.st_mode = ActualPath;
      _os_log_impl(&dword_206367000, v17, OS_LOG_TYPE_DEFAULT, "Synthesized AppleDouble from %s", (uint8_t *)&v52, 0xCu);
    }
LABEL_28:
    if (!*(_BYTE *)(v5 + 66) || BOMCopierSourceEntryGetType(v4) == 13)
      return 0;
    v19 = *(NSObject **)(v5 + 24);
    if (v19 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_206367000, v19, OS_LOG_TYPE_DEFAULT, "Synthesizing resource fork entry", buf, 2u);
    }
    v20 = (const char *)BOMCopierSourceEntryGetActualPath(v4);
    v31 = 0;
    if (asprintf(&v31, "%s%s", v20, "/..namedfork/rsrc") < 0)
    {
      v24 = *__error();
      v25 = __error();
      strerror(*v25);
      BOMCopierErrorCapture(v3, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3653, (uint64_t)"synthesize_resource_fork", "Could not asprintf resource path for %s: %s");
      goto LABEL_39;
    }
    memset(&v52, 0, sizeof(v52));
    v21 = lstat(v31, &v52);
    free(v31);
    if (v21)
    {
      if (*__error() != 2)
      {
        v22 = *__error();
        v23 = __error();
        strerror(*v23);
        BOMCopierErrorCapture(v3, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3666, (uint64_t)"synthesize_resource_fork", "Could not lstat resource path for %s: %s");
        goto LABEL_39;
      }
    }
    else if (v52.st_size)
    {
      v26 = BOMCopierSourceEntryNewFromResourceFork(v20, v3);
      if (v26)
      {
        v27 = v26;
        v28 = (const char *)BOMCopierSourceEntryGetPath(v4);
        bzero(buf, 0x400uLL);
        memset(v47, 0, 255);
        dirname_r(v28, buf);
        basename_r(v28, (char *)v47);
        v45 = 0u;
        memset(v46, 0, sizeof(v46));
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v40 = 0u;
        v38 = 0u;
        v39 = 0u;
        v36 = 0u;
        v37 = 0u;
        v34 = 0u;
        v35 = 0u;
        *(_OWORD *)__str = 0u;
        v33 = 0u;
        snprintf(__str, 0xFFuLL, "%s%s", (const char *)v47, "/..namedfork/rsrc");
        bzero(__s, 0x400uLL);
        snprintf(__s, 0x400uLL, "%s/%s", buf, __str);
        if (BOMCopierSourceEntrySetPath(v27, __s))
        {
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3709, (uint64_t)"synthesize_resource_fork", "Could not create set path entry for %s");
        }
        else if (BOMCopierSourceEntrySetParent((uint64_t)v27, buf))
        {
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3717, (uint64_t)"synthesize_resource_fork", "Could not create set entry parent for %s");
        }
        else if (BOMCopierSourceEntrySetName((uint64_t)v27, __str))
        {
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3725, (uint64_t)"synthesize_resource_fork", "Could not create set entry name for %s");
        }
        else
        {
          if (!push_preempt_stack(v5, (uint64_t)v27, v3))
          {
            v29 = *(NSObject **)(v5 + 24);
            if (v29)
            {
              if (os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v48 = 136315138;
                v49 = v20;
                _os_log_impl(&dword_206367000, v29, OS_LOG_TYPE_DEFAULT, "Synthesized resource fork from %s", v48, 0xCu);
              }
            }
            return 0;
          }
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3733, (uint64_t)"synthesize_resource_fork", "Could not push synthetic resource fork entry");
        }
        BOMCopierSourceEntryFree(v27);
      }
      else
      {
        *(stat *)buf = v52;
        BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3688, (uint64_t)"synthesize_resource_fork", "Could not create BOMCopierSourceEntry from %s");
      }
LABEL_39:
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3627, (uint64_t)"synthesize_filesystem_stuff", "Could not discover resource fork");
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  v10 = *__error();
  v11 = __error();
  strerror(*v11);
  BOMCopierErrorCapture(v3, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3796, (uint64_t)"synthesize_apple_double", "Could not copyfile %s to %s: %s", ActualPath);
LABEL_14:
  BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3605, (uint64_t)"synthesize_filesystem_stuff", "Could not synthesize the AppleDouble file");
  return 0xFFFFFFFFLL;
}

uint64_t adjust_filesystem_entry_path(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  const char *v6;
  const char *v7;
  int v8;
  uint64_t v9;
  int v10;
  int *v11;
  char *v12;
  char *__s;

  v6 = "";
  if (!*(_BYTE *)(a1 + 93))
    v6 = ".";
  v7 = (const char *)(*(_QWORD *)(a2 + 48)
                    + *(_QWORD *)(a1 + 144)
                    - *(_QWORD *)(a1 + 136)
                    + *(unsigned __int8 *)(a1 + 93));
  __s = 0;
  v8 = asprintf(&__s, "%s%s", v6, v7);
  if (!__s || v8 < 0)
  {
    v10 = *__error();
    v11 = __error();
    v12 = strerror(*v11);
    BOMCopierErrorCapture(a4, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3558, (uint64_t)"adjust_filesystem_entry_path", "Could not asprintf the entry_path: %s", v12);
    return 1;
  }
  else if (BOMCopierSourceEntrySetPath(a3, __s))
  {
    v9 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3571, (uint64_t)"adjust_filesystem_entry_path", "Could not set the entry path");
    free(__s);
  }
  else
  {
    free(__s);
    return 0;
  }
  return v9;
}

uint64_t push_preempt_stack(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  char *v5;

  v5 = *(char **)(a1 + 312);
  if (v5 || (v5 = (char *)BOMStackNew(), (*(_QWORD *)(a1 + 312) = v5) != 0))
  {
    BOMStackPush(v5, a2);
    return 0;
  }
  else
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4589, (uint64_t)"push_preempt_stack", "Could not create empty preempt stack");
    return 0xFFFFFFFFLL;
  }
}

char *is_apple_double(_QWORD *a1)
{
  int Type;
  char *result;

  Type = BOMCopierSourceEntryGetType((uint64_t)a1);
  if (Type != 15 && Type != 8)
    return 0;
  result = BOMCopierSourceEntryGetName(a1);
  if (result)
    return (char *)(strncmp(result, "._", 2uLL) == 0);
  return result;
}

uint64_t consume_source_entry(unsigned int *a1, _QWORD *a2)
{
  uint64_t v4;

  v4 = BOMCopierSourceEntrySkip((uint64_t)a1, 0, 0, a2);
  if ((_DWORD)v4)
    BOMCopierErrorCapture(a2, v4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3864, (uint64_t)"consume_source_entry", "Could not skip source entry");
  else
    BOMCopierSourceEntryFree(a1);
  return v4;
}

uint64_t push_replay_stack(_QWORD *a1, uint64_t a2, int a3, _QWORD *a4)
{
  char *v7;
  uint64_t v8;

  switch(a3)
  {
    case 3:
      v7 = (char *)a1[42];
      if (!v7)
      {
        v7 = (char *)BOMStackNew();
        a1[42] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4646, (uint64_t)"push_replay_stack", "Could not create empty replay directory stack");
          return 0xFFFFFFFFLL;
        }
      }
      break;
    case 2:
      v7 = (char *)a1[41];
      if (!v7)
      {
        v7 = (char *)BOMStackNew();
        a1[41] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4631, (uint64_t)"push_replay_stack", "Could not create empty replay AppleDouble stack");
          return 0xFFFFFFFFLL;
        }
      }
      break;
    case 1:
      v7 = (char *)a1[40];
      if (!v7)
      {
        v7 = (char *)BOMStackNew();
        a1[40] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4616, (uint64_t)"push_replay_stack", "Could not create empty replay symlink stack");
          return 0xFFFFFFFFLL;
        }
      }
      break;
    default:
      v8 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4656, (uint64_t)"push_replay_stack", "Unknown replay type: %u", a3);
      return v8;
  }
  BOMStackPush(v7, a2);
  return 0;
}

uint64_t synthesize_replay_apple_double(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int *v6;
  unsigned int *v7;
  const char *v8;
  char *v9;
  char *v10;
  const char *v11;
  size_t v12;
  int *v13;
  char *Path;
  NSObject *v15;
  uint64_t result;
  uint8_t buf[4];
  char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v6 = BOMCopierSourceEntryNew(17, a3);
  if (v6)
  {
    v7 = v6;
    v8 = BOMCopierSourceEntryGetName(a2) + 2;
    v9 = strdup(v8);
    if (v9)
    {
      v10 = v9;
      v11 = *(const char **)(a1 + 80);
      if (v11)
      {
        v12 = strlen(v11);
        v10[strlen(v10) - v12] = 0;
      }
      if (BOMCopierSourceEntrySetAppleDoubleTarget((uint64_t)v7, v10))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4039, (uint64_t)"synthesize_replay_apple_double", "Could not create set AppleDouble target for replay AppleDouble file");
        free(v10);
      }
      else
      {
        Path = (char *)BOMCopierSourceEntryGetPath((uint64_t)a2);
        v15 = *(NSObject **)(a1 + 24);
        if (v15)
        {
          if (os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315394;
            v18 = Path;
            v19 = 2080;
            v20 = v10;
            _os_log_impl(&dword_206367000, v15, OS_LOG_TYPE_DEFAULT, "Synthesizing replay AppleDouble from %s to %s", buf, 0x16u);
          }
        }
        free(v10);
        if (BOMCopierSourceEntrySetPath(v7, Path))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4054, (uint64_t)"synthesize_replay_apple_double", "Could not set entry path for replay AppleDouble file");
        }
        else if (copy_entry_metadata((uint64_t)a2, (uint64_t)v7, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4062, (uint64_t)"synthesize_replay_apple_double", "Could not copy metadata from the source entry to its replay apple double");
        }
        else
        {
          result = push_replay_stack((_QWORD *)a1, (uint64_t)v7, 2, a3);
          if (!(_DWORD)result)
            return result;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4070, (uint64_t)"synthesize_replay_apple_double", "Could not push the synthetic replay AppleDouble");
        }
      }
    }
    else
    {
      v13 = __error();
      strerror(*v13);
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4022, (uint64_t)"synthesize_replay_apple_double", "Could not duplicate %s: %s");
    }
    BOMCopierSourceEntryFree(v7);
  }
  else
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4006, (uint64_t)"synthesize_replay_apple_double", "Could not create BOMCopierSourceEntry for replay AppleDouble file");
  }
  return 0xFFFFFFFFLL;
}

uint64_t __add_sequester_entry_block_invoke(uint64_t a1, const char *a2, int a3)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char **v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  size_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v23;
  int *v24;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_QWORD *)(v5 + 24))
  {
    v18 = strlen(a2);
    v19 = *(_QWORD *)(a1 + 48);
    if (*(_BYTE *)(v19 + 93))
      v20 = "__MACOSX";
    else
      v20 = ".";
    if (!strncmp(a2, v20, v18))
    {
      v21 = *(_QWORD *)(v19 + 344);
      if (v21)
      {
        result = 0;
        *(_QWORD *)(v5 + 24) = v21;
        return result;
      }
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = path_tree_node_create(a2, *(_QWORD **)(a1 + 56));
      v23 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v23)
      {
        result = 0;
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 344) = v23;
        return result;
      }
      BOMCopierErrorCapture(*(_QWORD **)(a1 + 56), 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4751, (uint64_t)"add_sequester_entry_block_invoke", "Could not create root path tree node");
    }
    else
    {
      BOMCopierErrorCapture(*(_QWORD **)(a1 + 56), 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4741, (uint64_t)"add_sequester_entry_block_invoke", "I was expecting %s not %s");
    }
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(*(_QWORD *)(v7 + 8) + 24);
  if (*(_DWORD *)(v8 + 8))
  {
    v9 = 0;
    do
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      if (*(_QWORD *)(v10 + 24))
        break;
      v11 = *(const char ***)(*(_QWORD *)(v8 + 16) + 8 * v9);
      if (!strncmp(a2, *v11, 0xFFuLL))
      {
        *(_QWORD *)(v10 + 24) = v11;
        v7 = *(_QWORD *)(a1 + 32);
      }
      ++v9;
      v8 = *(_QWORD *)(*(_QWORD *)(v7 + 8) + 24);
    }
    while (v9 < *(unsigned int *)(v8 + 8));
  }
  v12 = *(_QWORD *)(a1 + 40);
  v13 = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 24);
  if (v13)
    goto LABEL_27;
  v14 = *(_QWORD **)(a1 + 56);
  if (a2)
  {
    v15 = path_tree_node_create(a2, *(_QWORD **)(a1 + 56));
    if (!v15)
    {
      BOMCopierErrorCapture(v14, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5055, (uint64_t)"path_tree_node_add_child", "Could not create child node for %s\n", a2);
      goto LABEL_26;
    }
    v16 = *(unsigned int *)(v8 + 8);
    v17 = malloc_type_realloc(*(void **)(v8 + 16), 8 * (v16 + 1), 0x240466AuLL);
    if (v17)
    {
      v17[v16] = v15;
      *(_DWORD *)(v8 + 8) = v16 + 1;
      *(_QWORD *)(v8 + 16) = v17;
      goto LABEL_26;
    }
    v24 = __error();
    BOMCopierErrorCapture(v14, *v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5067, (uint64_t)"path_tree_node_add_child", "Could not reallocate new children list\n");
    path_tree_node_release((uint64_t)v15);
  }
  else
  {
    BOMCopierErrorCapture(*(_QWORD **)(a1 + 56), 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5047, (uint64_t)"path_tree_node_add_child", "child_name is NULL");
  }
  v15 = 0;
LABEL_26:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v15;
  v12 = *(_QWORD *)(a1 + 40);
  v13 = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 24);
  if (!v13)
  {
    BOMCopierErrorCapture(*(_QWORD **)(a1 + 56), 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4786, (uint64_t)"add_sequester_entry_block_invoke", "Could not add child %s to %s");
    return 0xFFFFFFFFLL;
  }
LABEL_27:
  if (a3)
  {
    *(_QWORD *)(v13 + 24) = *(_QWORD *)(a1 + 64);
    v12 = *(_QWORD *)(a1 + 40);
  }
  result = 0;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 24);
  return result;
}

_QWORD *path_tree_node_create(const char *a1, _QWORD *a2)
{
  _QWORD *v4;
  char *v5;
  int v6;
  int *v7;
  char *v8;
  int *v9;

  if (!a1)
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4985, (uint64_t)"path_tree_node_create", "name is NULL");
    return 0;
  }
  v4 = malloc_type_calloc(1uLL, 0x20uLL, 0x10B0040ECAA58F3uLL);
  if (!v4)
  {
    v9 = __error();
    BOMCopierErrorCapture(a2, *v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4992, (uint64_t)"path_tree_node_create", "Could not allocate node");
    return v4;
  }
  v5 = strdup(a1);
  *v4 = v5;
  if (!v5)
  {
    v6 = *__error();
    v7 = __error();
    v8 = strerror(*v7);
    BOMCopierErrorCapture(a2, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4999, (uint64_t)"path_tree_node_create", "Could not strdup %s: %s", a1, v8);
    free(v4);
    return 0;
  }
  return v4;
}

uint64_t copy_entry_metadata(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  __int16 Mode;
  int UserID;
  int GroupID;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  BOMCopierSourceEntryGetPath(a1);
  BOMCopierSourceEntryGetPath(a2);
  Mode = BOMCopierSourceEntryGetMode(a1);
  if (BOMCopierSourceEntrySetMode(a2, Mode))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4504, (uint64_t)"copy_entry_metadata", "Could not set mode for entry %s");
  }
  else
  {
    UserID = BOMCopierSourceEntryGetUserID(a1);
    if (BOMCopierSourceEntrySetUserID(a2, UserID))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4513, (uint64_t)"copy_entry_metadata", "Could not set uid for entry %s");
    }
    else
    {
      GroupID = BOMCopierSourceEntryGetGroupID(a1);
      if (BOMCopierSourceEntrySetGroupID(a2, GroupID))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4522, (uint64_t)"copy_entry_metadata", "Could not set gid for entry %s");
      }
      else
      {
        v12 = 0uLL;
        if (BOMCopierSourceEntryGetAccessTime(a1, &v12))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4531, (uint64_t)"copy_entry_metadata", "Could not get access time for entry %s");
        }
        else if (BOMCopierSourceEntrySetAccessTime(a2, v12, *((uint64_t *)&v12 + 1)))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4538, (uint64_t)"copy_entry_metadata", "Could not set access time for entry %s");
        }
        else
        {
          v11 = 0uLL;
          if (BOMCopierSourceEntryGetModificationTime(a1, &v11))
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4547, (uint64_t)"copy_entry_metadata", "Could not get modification time for entry %s");
          }
          else if (BOMCopierSourceEntrySetModificationTime(a2, v11, *((uint64_t *)&v11 + 1)))
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4554, (uint64_t)"copy_entry_metadata", "Could not set modification time for entry %s");
          }
          else
          {
            v10 = 0uLL;
            if (BOMCopierSourceEntryGetStatusTime(a1, &v10))
            {
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4563, (uint64_t)"copy_entry_metadata", "Could not get status time for entry %s");
            }
            else
            {
              result = BOMCopierSourceEntrySetStatusTime(a2, v10, *((uint64_t *)&v10 + 1));
              if (!(_DWORD)result)
                return result;
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4570, (uint64_t)"copy_entry_metadata", "Could not set status time for entry %s");
            }
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t path_tree_node_push(uint64_t a1, const char *a2, char *a3, _QWORD *a4)
{
  uint64_t v8;
  unsigned int *v9;
  int *v11;
  unsigned int *v12;
  char *__s;

  __s = 0;
  if (a2)
    asprintf(&__s, "%s/%s");
  else
    asprintf(&__s, "%s");
  if (__s)
  {
    if (*(_DWORD *)(a1 + 8))
    {
      v8 = 0;
      while (!path_tree_node_push(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v8), __s, a3, a4))
      {
        if (++v8 >= (unint64_t)*(unsigned int *)(a1 + 8))
          goto LABEL_9;
      }
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5114, (uint64_t)"path_tree_node_push", "Could not push child %s of %s onto the stack\n");
      goto LABEL_21;
    }
LABEL_9:
    v9 = *(unsigned int **)(a1 + 24);
    if (v9)
    {
LABEL_10:
      BOMStackPush(a3, (uint64_t)v9);
      free(__s);
      return 0;
    }
    v12 = BOMCopierSourceEntryNew(6, a4);
    if (v12)
    {
      v9 = v12;
      if (BOMCopierSourceEntrySetPath(v12, __s))
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5135, (uint64_t)"path_tree_node_push", "Could not path for source entry of %s\n");
      }
      else
      {
        if (!BOMCopierSourceEntrySetMode((uint64_t)v9, 16893))
          goto LABEL_10;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5144, (uint64_t)"path_tree_node_push", "Could not mode for source entry of %s\n");
      }
      BOMCopierSourceEntryFree(v9);
    }
    else
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5127, (uint64_t)"path_tree_node_push", "Could not create source entry for %s\n");
    }
LABEL_21:
    free(__s);
    return 0xFFFFFFFFLL;
  }
  v11 = __error();
  BOMCopierErrorCapture(a4, *v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5104, (uint64_t)"path_tree_node_push", "Could not create node path for %s and %s\n", a2, *(const char **)a1);
  return 0xFFFFFFFFLL;
}

char *BOMNewPathKey(unsigned int a1, char *__s, _QWORD *a3)
{
  char *v3;
  size_t v7;
  char *v8;
  FILE *v9;
  int *v10;
  char *v11;

  v3 = 0;
  if (__s && a3)
  {
    v7 = strlen(__s);
    v8 = (char *)BOM_malloc(v7 + 5);
    v3 = v8;
    if (v8)
    {
      *a3 = v7 + 5;
      *(_DWORD *)v8 = bswap32(a1);
      strlcpy(v8 + 4, __s, v7 + 1);
    }
    else
    {
      v9 = (FILE *)*MEMORY[0x24BDAC8D8];
      v10 = __error();
      v11 = strerror(*v10);
      fprintf(v9, "malloc: %s\n", v11);
    }
  }
  return v3;
}

_DWORD *BOMNewPathValue(unsigned int a1, unsigned int a2, _QWORD *a3)
{
  _DWORD *result;
  FILE *v7;
  int *v8;
  char *v9;

  if (!a3)
    return 0;
  result = BOM_malloc(8uLL);
  if (result)
  {
    *a3 = 8;
    *result = bswap32(a1);
    result[1] = bswap32(a2);
  }
  else
  {
    v7 = (FILE *)*MEMORY[0x24BDAC8D8];
    v8 = __error();
    v9 = strerror(*v8);
    fprintf(v7, "malloc: %s\n", v9);
    return 0;
  }
  return result;
}

unsigned int *BOMPathIDFromPathKey(unsigned int *result)
{
  if (result)
    return (unsigned int *)bswap32(*result);
  return result;
}

uint64_t BOMShortNameFromPathKey(uint64_t a1)
{
  return a1 + 4;
}

uint64_t BOMBlockIDFromPathValue(uint64_t result)
{
  if (result)
    return bswap32(*(_DWORD *)(result + 4));
  return result;
}

char *BOMCopierDestinationNew(char *__s, const __CFDictionary *a2, _QWORD *a3)
{
  char *v6;
  void *v7;
  CFTypeID TypeID;
  const void *Value;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  CFTypeID v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  const void *v19;
  CFTypeID v20;
  const void *v21;
  const void *v22;
  int v23;
  int *v24;
  int v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  CFTypeID v28;
  __CFWriteStream *v29;
  __CFWriteStream *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const __CFNumber *v41;
  const __CFNumber *v42;
  const __CFNumber *v43;
  const __CFNumber *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const __CFString *v51;
  const __CFString *v52;
  CFIndex v53;
  char *v54;
  const __CFString *v55;
  const __CFString *v56;
  CFIndex v57;
  regex_t *v58;
  int v59;
  int *v60;
  char *v61;
  char *v62;
  int v63;
  const __CFString *v64;
  const __CFString *v65;
  CFIndex v66;
  char *v67;
  const void *v68;
  const void *v69;
  int v70;
  const __CFNumber *v71;
  const __CFNumber *v72;
  const __CFNumber *v73;
  const __CFNumber *v74;
  const void *v75;
  const void *v76;
  int v77;
  const void *v78;
  const void *v79;
  const void *v80;
  const void *v81;
  const void *v82;
  const void *v83;
  const __CFNumber *v84;
  const __CFNumber *v85;
  const void *v86;
  const void *v87;
  const __CFNumber *v88;
  const __CFNumber *v89;
  const void *v90;
  const void *v91;
  const void *v92;
  const void *v93;
  const void *v94;
  const void *v95;
  const void *v96;
  const void *v97;
  const void *v98;
  const void *v99;
  const void *v100;
  const void *v101;
  const void *v102;
  const void *v103;
  int v104;
  int v105;
  CFTypeID v106;
  const __CFData *v107;
  const __CFData *v108;
  size_t Length;
  size_t v110;
  void *v111;
  void *v112;
  const UInt8 *BytePtr;
  int v114;
  int v115;
  int *v116;
  AAByteStream_impl *v117;
  uint64_t v118;
  int v119;
  int v120;
  AAByteStream_impl *v121;
  int v122;
  int *v123;
  int v124;
  int *v125;
  int v126;
  int v127;
  int v128;
  int v129;
  AAByteStream_impl *v130;
  AAArchiveStream v131;
  int *v132;
  char *v133;
  int volume_state;
  int v135;
  int *v136;
  int v137;
  int v138;
  int v139;
  int *v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int *v151;
  int v152;
  int v153;
  int v154;
  char *v155;
  char *v156;
  int *v157;
  int v158;
  int v159;
  int v160;
  int *v161;
  int *v163;
  int v164;
  int v165;
  int v166;
  int v167;
  uint64_t v168;
  char *buffer;
  __int16 v170;
  char v171;
  stat v172;
  char v173[1024];
  stat valuePtr[7];
  uint64_t v175;

  v175 = *MEMORY[0x24BDAC8D0];
  if (!((unint64_t)__s | (unint64_t)a2))
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 621, (uint64_t)"BOMCopierDestinationNew", "path and options are NULL");
    return 0;
  }
  if (__s && strlen(__s) >= 0x400)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 630, (uint64_t)"BOMCopierDestinationNew", "maximum path length exceeded: %ld");
    return 0;
  }
  v6 = (char *)malloc_type_calloc(1uLL, 0x170uLL, 0x10B004067826777uLL);
  if (!v6)
  {
    v24 = __error();
    BOMCopierErrorCapture(a3, *v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 644, (uint64_t)"BOMCopierDestinationNew", "Could not allocate empty BOMCopierDestination");
    return v6;
  }
  *((_DWORD *)v6 + 2) = geteuid();
  *(_QWORD *)(v6 + 124) = 0x10000;
  *((_DWORD *)v6 + 36) = -1;
  *((_DWORD *)v6 + 29) = 0;
  v6[297] = 1;
  *((_DWORD *)v6 + 82) = -1;
  v7 = BOMHardLinkTableNew();
  *((_QWORD *)v6 + 9) = v7;
  if (!v7)
  {
    v25 = *__error();
    BOMCopierErrorCapture(a3, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 662, (uint64_t)"BOMCopierDestinationNew", "Could not create BOMHardLinkTable");
    goto LABEL_319;
  }
  *((_DWORD *)v6 + 4) = -1;
  if (!geteuid())
    v6[302] = 1;
  if (a2)
  {
    TypeID = CFBooleanGetTypeID();
    Value = CFDictionaryGetValue(a2, CFSTR("useFilesystemCache"));
    if (Value)
    {
      v10 = Value;
      if (TypeID != CFGetTypeID(Value))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2767, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionUseFilesystemCacheKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      if (CFEqual(v10, (CFTypeRef)*MEMORY[0x24BDBD268]) == 1)
        v6[40] = 1;
    }
    v11 = CFDictionaryGetValue(a2, CFSTR("applySourcePermissions"));
    if (v11)
    {
      v12 = v11;
      if (TypeID != CFGetTypeID(v11))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2782, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionApplySourcePermissionsKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      v6[43] = CFEqual(v12, (CFTypeRef)*MEMORY[0x24BDBD270]) != 0;
    }
    v13 = CFDictionaryGetValue(a2, CFSTR("createArchive"));
    if (v13)
    {
      if (TypeID != CFGetTypeID(v13))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2794, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCreateArchiveKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 11) = 1;
    }
    v14 = CFNumberGetTypeID();
    v15 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("libarchiveFormat"));
    if (v15)
    {
      v16 = v15;
      if (v14 != CFGetTypeID(v15))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2808, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionLibarchiveFormatKey must be a CFNumberRef");
        goto LABEL_319;
      }
      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v16, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2816, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 31) = valuePtr[0].st_dev;
    }
    v17 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("libarchiveFilter"));
    if (v17)
    {
      v18 = v17;
      if (v14 != CFGetTypeID(v17))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2828, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionLibarchiveFilterKey must be a CFNumberRef");
        goto LABEL_319;
      }
      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v18, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2836, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 32) = valuePtr[0].st_dev;
    }
    v19 = CFDictionaryGetValue(a2, CFSTR("createAppleArchive"));
    if (v19)
    {
      if (TypeID != CFGetTypeID(v19))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2848, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCreateAppleArchiveKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 11) = 2;
    }
    v20 = CFStringGetTypeID();
    v21 = CFDictionaryGetValue(a2, CFSTR("compressAppleArchive"));
    if (!v21)
      goto LABEL_59;
    v22 = v21;
    if (v20 == CFGetTypeID(v21))
    {
      if (CFEqual(v22, CFSTR("none")) == 1)
      {
        v23 = 0;
      }
      else if (CFEqual(v22, CFSTR("lz4")) == 1)
      {
        v23 = 256;
      }
      else if (CFEqual(v22, CFSTR("zlib")) == 1)
      {
        v23 = 1285;
      }
      else if (CFEqual(v22, CFSTR("lzma")) == 1)
      {
        v23 = 774;
      }
      else if (CFEqual(v22, CFSTR("lzfse")) == 1)
      {
        v23 = 2049;
      }
      else
      {
        if (CFEqual(v22, CFSTR("lzbitmap")) != 1)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2896, (uint64_t)"parse_copier_destination_options", "Unsupported AppleArchive compression algorithm");
          goto LABEL_319;
        }
        v23 = 1794;
      }
      *((_DWORD *)v6 + 41) = v23;
LABEL_59:
      v26 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("outputFD"));
      if (v26)
      {
        v27 = v26;
        if (v14 != CFGetTypeID(v26))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2906, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionOutputFileDescriptorKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v27, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2914, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 12) = valuePtr[0].st_dev;
      }
      v28 = CFWriteStreamGetTypeID();
      v29 = (__CFWriteStream *)CFDictionaryGetValue(a2, CFSTR("outputStream"));
      if (v29)
      {
        v30 = v29;
        if (v28 != CFGetTypeID(v29))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2928, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionOutputCFWriteStreamKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        if (CFWriteStreamGetStatus(v30) != kCFStreamStatusOpen)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2935, (uint64_t)"parse_copier_destination_options", "CFWriteStream is not open");
          goto LABEL_319;
        }
        *((_QWORD *)v6 + 7) = v30;
      }
      v31 = CFDictionaryGetValue(a2, CFSTR("output2Nowhere"));
      if (v31)
      {
        v32 = v31;
        if (TypeID != CFGetTypeID(v31))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2947, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionOutputToNowhereKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        if (CFEqual(v32, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
          *((_DWORD *)v6 + 11) = 3;
      }
      if (CFDictionaryContainsKey(a2, CFSTR("archs")) == 1)
      {
        memset(valuePtr, 0, 48);
        if (BOMCopierPrepareMatchContext(a2, (uint64_t)valuePtr, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2964, (uint64_t)"parse_copier_destination_options", "Could not prepare binary matching context");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 48) = valuePtr[0].st_dev;
        *((_QWORD *)v6 + 25) = valuePtr[0].st_ino;
      }
      v33 = CFDictionaryGetValue(a2, CFSTR("enableAtomicCopies"));
      if (v33)
      {
        v34 = v33;
        if (TypeID != CFGetTypeID(v33))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2977, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionPerformAtomicCopies must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[297] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v34) != 0;
      }
      v35 = CFDictionaryGetValue(a2, CFSTR("useDefaultDirectoryPermissions"));
      if (v35)
      {
        v36 = v35;
        if (TypeID != CFGetTypeID(v35))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2989, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionUseDefaultDirectoryPermissions must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[296] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v36) != 0;
      }
      v37 = CFDictionaryGetValue(a2, CFSTR("useAppleFSCompression"));
      if (v37)
      {
        v38 = v37;
        if (TypeID != CFGetTypeID(v37))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3001, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionUseAppleFSCompression must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[112] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v38) != 0;
      }
      v39 = CFDictionaryGetValue(a2, CFSTR("preserveAppleFSCompression"));
      if (v39)
      {
        v40 = v39;
        if (TypeID != CFGetTypeID(v39))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3013, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionPreserveAppleFSCompression must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[113] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v40) != 0;
      }
      v41 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("AppleFSCompressionType"));
      if (v41)
      {
        v42 = v41;
        if (v14 != CFGetTypeID(v41))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3026, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionAppleFSCompressionType must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v42, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3034, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 29) = valuePtr[0].st_dev;
      }
      v43 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("AppleFSCompressionFlags"));
      if (v43)
      {
        v44 = v43;
        if (v14 != CFGetTypeID(v43))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3046, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionAppleFSCompressionFlags must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v44, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3054, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 30) = valuePtr[0].st_dev;
      }
      v45 = CFDictionaryGetValue(a2, CFSTR("enforceDestinationEncapsulation"));
      if (v45)
      {
        v46 = v45;
        if (TypeID != CFGetTypeID(v45))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3066, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionEnforceDestinationEncapsulationKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[298] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v46) != 0;
      }
      v47 = CFDictionaryGetValue(a2, CFSTR("enforceDestinationLocation"));
      if (v47)
      {
        v48 = v47;
        if (TypeID != CFGetTypeID(v47))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3078, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionEnforceDestinationLocationKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[299] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v48) != 0;
      }
      v49 = CFDictionaryGetValue(a2, CFSTR("keepBinaries"));
      if (v49)
      {
        v50 = v49;
        if (TypeID != CFGetTypeID(v49))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3090, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeepBinariesKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[307] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v50) != 0;
      }
      v51 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("keptFileList"));
      if (v51)
      {
        v52 = v51;
        if (v20 != CFGetTypeID(v51))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3102, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeptFileListKey must be a CFStringRef");
          goto LABEL_319;
        }
        v53 = CFStringGetLength(v52) + 1;
        v54 = (char *)malloc_type_calloc(1uLL, v53, 0x3C5E005DuLL);
        *((_QWORD *)v6 + 40) = v54;
        if (!v54)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3112, (uint64_t)"parse_copier_destination_options", "Could not allocate %ld bytes for path");
          goto LABEL_319;
        }
        if (!CFStringGetCString(v52, v54, v53, 0x8000100u))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3119, (uint64_t)"parse_copier_destination_options", "Could not convert enumeration_bom_path string to C string");
          goto LABEL_319;
        }
      }
      v55 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("keepFilePattern"));
      if (v55)
      {
        v56 = v55;
        if (v20 != CFGetTypeID(v55))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3129, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeepFilePatternKey must be a CFStringRef");
          goto LABEL_319;
        }
        v57 = CFStringGetLength(v56) + 1;
        buffer = (char *)malloc_type_calloc(1uLL, v57, 0xE8E4CC65uLL);
        if (!buffer)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3139, (uint64_t)"parse_copier_destination_options", "Could not allocate %ld bytes for pattern");
          goto LABEL_319;
        }
        if (CFStringGetCString(v56, buffer, v57, 0x8000100u))
        {
          v58 = (regex_t *)malloc_type_malloc(0x20uLL, 0x10700404B019E81uLL);
          *((_QWORD *)v6 + 42) = v58;
          if (v58)
          {
            if (regcomp(v58, buffer, 5))
            {
              v59 = *__error();
              v60 = __error();
              v61 = strerror(*v60);
              BOMCopierErrorCapture(a3, v59, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3162, (uint64_t)"parse_copier_destination_options", "Could not compile regular expression from %s: %s", buffer, v61);
              v62 = buffer;
LABEL_140:
              free(v62);
              goto LABEL_319;
            }
            free(buffer);
            goto LABEL_142;
          }
          v63 = *__error();
          BOMCopierErrorCapture(a3, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3154, (uint64_t)"parse_copier_destination_options", "Could not allocate regular expression");
        }
        else
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3146, (uint64_t)"parse_copier_destination_options", "Could not convert enumeration_bom_path string to C string");
        }
        v62 = buffer;
        goto LABEL_140;
      }
LABEL_142:
      v64 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("keptFileDirectory"));
      if (v64)
      {
        v65 = v64;
        if (v20 != CFGetTypeID(v64))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3175, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeptFileDirectoryKey must be a CFStringRef");
          goto LABEL_319;
        }
        v66 = CFStringGetLength(v65) + 1;
        v67 = (char *)malloc_type_calloc(1uLL, v66, 0xB5EA7FB2uLL);
        *((_QWORD *)v6 + 43) = v67;
        if (!v67)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3185, (uint64_t)"parse_copier_destination_options", "Could not allocate %ld bytes for kept file directory");
          goto LABEL_319;
        }
        if (!CFStringGetCString(v65, v67, v66, 0x8000100u))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3192, (uint64_t)"parse_copier_destination_options", "Could not convert kept_file_directory string to C string");
          goto LABEL_319;
        }
      }
      v68 = CFDictionaryGetValue(a2, CFSTR("balanceKeptFiles"));
      if (v68)
      {
        v69 = v68;
        if (TypeID != CFGetTypeID(v68))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3202, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationBalanceKeptFilesKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v70 = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v69);
        v6[352] = v70 != 0;
        if (v70)
          *((_DWORD *)v6 + 89) = 100;
      }
      v71 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("keptFileBalanceLimit"));
      if (v71)
      {
        v72 = v71;
        if (v14 != CFGetTypeID(v71))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3219, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeptFileBalanceLimitKey must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v72, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3227, (uint64_t)"parse_copier_destination_options", "Could not convert the kept file balance limit to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        if (valuePtr[0].st_dev <= 0)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3233, (uint64_t)"parse_copier_destination_options", "%d is out of range for kept file balance limit");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 89) = valuePtr[0].st_dev;
      }
      v73 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("zlibCompressionLevel"));
      if (v73)
      {
        v74 = v73;
        if (v14 != CFGetTypeID(v73))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3246, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionZlibCompressionLevel must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v74, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3254, (uint64_t)"parse_copier_destination_options", "Could not convert the zlib compression level to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        if ((valuePtr[0].st_dev - 10) <= 0xFFFFFFF4)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3260, (uint64_t)"parse_copier_destination_options", "%d is out of range for Zlib compression");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 36) = valuePtr[0].st_dev;
      }
      v75 = CFDictionaryGetValue(a2, CFSTR("symlinkTreatment"));
      if (v75)
      {
        v76 = v75;
        if (CFGetTypeID(v75) != v20)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3276, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSymlinkTreatmentKey is not a CFStringRef");
          goto LABEL_319;
        }
        if (CFEqual(v76, CFSTR("unlink")))
        {
          v77 = 1;
        }
        else if (CFEqual(v76, CFSTR("follow")))
        {
          v77 = 2;
        }
        else
        {
          if (!CFEqual(v76, CFSTR("error")))
          {
            BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3291, (uint64_t)"parse_copier_destination_options", "Unknown value for kBOMCopierOptionSymlinkTreatmentKey");
            goto LABEL_319;
          }
          v77 = 0;
        }
        *((_DWORD *)v6 + 70) = v77;
      }
      v78 = CFDictionaryGetValue(a2, CFSTR("persistRestrictedFlags"));
      if (v78)
      {
        v79 = v78;
        if (TypeID != CFGetTypeID(v78))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3301, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationPersistRestrictedFlags must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[303] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v79) != 0;
      }
      v80 = CFDictionaryGetValue(a2, CFSTR("preserveRestrictedFlags"));
      if (v80)
      {
        v81 = v80;
        if (TypeID != CFGetTypeID(v80))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3313, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationPreserveRestrictedFlags must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[302] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v81) != 0;
      }
      v82 = CFDictionaryGetValue(a2, CFSTR("persistRootless"));
      if (v82)
      {
        v83 = v82;
        if (TypeID != CFGetTypeID(v82))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3325, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionPersistRootlessExtendedAttribute must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[301] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v83) != 0;
      }
      v84 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("initialInode"));
      if (v84)
      {
        v85 = v84;
        if (v14 != CFGetTypeID(v84))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3337, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionInitialInodeKey must be a CFNumberRef");
          goto LABEL_319;
        }
        *(_QWORD *)&valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v85, kCFNumberLongLongType, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3345, (uint64_t)"parse_copier_destination_options", "Could not convert kBOMCopierDestinationOptionInitialInodeKey to kCFNumberLongLongType");
          goto LABEL_319;
        }
        *((_QWORD *)v6 + 8) = *(_QWORD *)&valuePtr[0].st_dev;
      }
      v86 = CFDictionaryGetValue(a2, CFSTR("skipTerminator"));
      if (v86)
      {
        v87 = v86;
        if (TypeID != CFGetTypeID(v86))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3357, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSkipCPIOTerminatorKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[148] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v87) != 0;
      }
      v88 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("segmentFileSize"));
      if (v88)
      {
        v89 = v88;
        if (v14 != CFGetTypeID(v88))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3369, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSegmentFileSizeKey must be a CFNumberRef");
          goto LABEL_319;
        }
        *(_QWORD *)&valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v89, kCFNumberLongLongType, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3377, (uint64_t)"parse_copier_destination_options", "Could not convert kBOMCopierDestinationOptionSegmentFileSizeKey to kCFNumberLongLongType");
          goto LABEL_319;
        }
        *((_QWORD *)v6 + 19) = *(_QWORD *)&valuePtr[0].st_dev;
      }
      v90 = CFDictionaryGetValue(a2, CFSTR("appleDoubleMergeACLs"));
      if (v90)
      {
        v91 = v90;
        if (TypeID != CFGetTypeID(v90))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3389, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionAppleDoubleMergeACLsKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[160] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v91) != 0;
      }
      v92 = CFDictionaryGetValue(a2, CFSTR("cloneFiles"));
      if (v92)
      {
        v93 = v92;
        if (TypeID != CFGetTypeID(v92))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3401, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCloneFilesKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[304] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v93) != 0;
      }
      v94 = CFDictionaryGetValue(a2, CFSTR("removeSetuidPermissions"));
      if (v94)
      {
        v95 = v94;
        if (TypeID != CFGetTypeID(v94))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3413, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[305] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v95) != 0;
      }
      v96 = CFDictionaryGetValue(a2, CFSTR("removeExecutablePermissions"));
      if (v96)
      {
        v97 = v96;
        if (TypeID != CFGetTypeID(v96))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3425, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionRemoveExecutablePermissionsKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[306] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v97) != 0;
      }
      v98 = CFDictionaryGetValue(a2, CFSTR("setStaticContent"));
      if (v98)
      {
        v99 = v98;
        if (TypeID != CFGetTypeID(v98))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3437, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSetStaticContentKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[41] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v99) != 0;
      }
      v100 = CFDictionaryGetValue(a2, CFSTR("setSingleWriter"));
      if (v100)
      {
        v101 = v100;
        if (TypeID != CFGetTypeID(v100))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3449, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSetSingleWriterKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[42] = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v101) != 0;
      }
      v102 = CFDictionaryGetValue(a2, CFSTR("setDataProtectionClass"));
      if (v102)
      {
        v103 = v102;
        if (v20 != CFGetTypeID(v102))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3461, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSetDataProtectionClassKey must be a CFStringRef");
          goto LABEL_319;
        }
        v104 = CFEqual(v103, CFSTR("A"));
        v105 = 1;
        if (v104 != 1)
        {
          if (CFEqual(v103, CFSTR("B")) == 1)
          {
            v105 = 2;
          }
          else if (CFEqual(v103, CFSTR("C")) == 1)
          {
            v105 = 3;
          }
          else
          {
            if (CFEqual(v103, CFSTR("D")) != 1)
            {
              BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3479, (uint64_t)"parse_copier_destination_options", "Unsupported data protection class");
              goto LABEL_319;
            }
            v105 = 4;
          }
        }
        *((_DWORD *)v6 + 4) = v105;
        v6[12] = 1;
      }
      v106 = CFDataGetTypeID();
      v107 = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("applyProvenance"));
      if (v107)
      {
        v108 = v107;
        if (v106 != CFGetTypeID(v107))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3493, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionApplyProvenanceKey must be a CFDataRef");
          goto LABEL_319;
        }
        Length = CFDataGetLength(v108);
        if (!Length)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3501, (uint64_t)"parse_copier_destination_options", "kBOMCopierOptionApplyProvenanceKey has an invalid size");
          goto LABEL_319;
        }
        v110 = Length;
        v111 = malloc_type_malloc(Length, 0xA5D9A754uLL);
        if (!v111)
        {
          v167 = *__error();
          BOMCopierErrorCapture(a3, v167, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3508, (uint64_t)"parse_copier_destination_options", "Could not allocate provenance data buffer");
          goto LABEL_319;
        }
        v112 = v111;
        BytePtr = CFDataGetBytePtr(v108);
        memcpy(v112, BytePtr, v110);
        *((_QWORD *)v6 + 3) = v112;
        *((_QWORD *)v6 + 4) = v110;
      }
      goto LABEL_249;
    }
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2862, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCompressAppleArchiveKey must be a CFStringRef");
LABEL_319:
    BOMCopierDestinationFree((unsigned int *)v6);
    return 0;
  }
LABEL_249:
  switch(*((_DWORD *)v6 + 11))
  {
    case 0:
      memset(&v172, 0, sizeof(v172));
      v114 = stat(__s, &v172);
      if (v114)
      {
        v115 = v114;
        if (*__error() != 2)
        {
          v124 = *__error();
          v125 = __error();
          strerror(*v125);
          BOMCopierErrorCapture(a3, v124, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 711, (uint64_t)"BOMCopierDestinationNew", "Could not stat %s: %s");
          goto LABEL_319;
        }
        v6[284] = 0;
        if (dirname_r(__s, (char *)valuePtr) != (char *)valuePtr)
        {
          v116 = __error();
          strerror(*v116);
          BOMCopierErrorCapture(a3, v115, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 767, (uint64_t)"BOMCopierDestinationNew", "Could not dirname %s: %s");
          goto LABEL_319;
        }
        if (basename_r(__s, v173) != v173)
        {
          v132 = __error();
          strerror(*v132);
          BOMCopierErrorCapture(a3, v115, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 777, (uint64_t)"BOMCopierDestinationNew", "Could not basename %s: %s");
          goto LABEL_319;
        }
        if (make_path(0, (char *)valuePtr, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 785, (uint64_t)"BOMCopierDestinationNew", "Could not make the parent_path %s");
          goto LABEL_319;
        }
        v155 = realpath_DARWIN_EXTSN((const char *)valuePtr, 0);
        if (!v155)
        {
          v161 = __error();
          strerror(*v161);
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 793, (uint64_t)"BOMCopierDestinationNew", "Could not realpath %s: %s");
          goto LABEL_319;
        }
        v156 = v155;
        v171 = 0;
        v170 = 0;
        if (get_volume_state(v155, (BOOL *)&v170, a3))
        {
          v157 = __error();
          strerror(*v157);
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 814, (uint64_t)"BOMCopierDestinationNew", "Could not get volume state for %s: %s");
          goto LABEL_319;
        }
        if (v6[12])
          v6[12] = v170;
        v6[20] = HIBYTE(v170);
        v6[300] = v171;
        asprintf((char **)v6 + 36, "%s/%s", v156, v173);
        free(v156);
        if (!*((_QWORD *)v6 + 36))
        {
          v163 = __error();
          strerror(*v163);
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 839, (uint64_t)"BOMCopierDestinationNew", "Could not construct resolve path from %s and %s: %s", v156);
          goto LABEL_319;
        }
      }
      else
      {
        v6[285] = (v172.st_mode & 0xF000) == 0x4000;
        if (v6[299])
        {
          memset(valuePtr, 0, 144);
          if (lstat(__s, valuePtr))
          {
            v122 = *__error();
            v123 = __error();
            strerror(*v123);
            BOMCopierErrorCapture(a3, v122, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 733, (uint64_t)"BOMCopierDestinationNew", "Could not stat %s: %s");
            goto LABEL_319;
          }
          if ((valuePtr[0].st_mode & 0xF000) == 0xA000 && valuePtr[0].st_dev != v172.st_dev)
          {
            v150 = *__error();
            v151 = __error();
            strerror(*v151);
            BOMCopierErrorCapture(a3, v150, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 742, (uint64_t)"BOMCopierDestinationNew", "%s exists on a different device from its target");
            goto LABEL_319;
          }
        }
        v6[284] = 1;
        v133 = realpath_DARWIN_EXTSN(__s, 0);
        if (!v133)
        {
          v140 = __error();
          strerror(*v140);
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 849, (uint64_t)"BOMCopierDestinationNew", "Could not realpath %s: %s");
          goto LABEL_319;
        }
        *((_QWORD *)v6 + 36) = v133;
        BYTE2(valuePtr[0].st_dev) = 0;
        LOWORD(valuePtr[0].st_dev) = 0;
        volume_state = get_volume_state(v133, (BOOL *)valuePtr, a3);
        if (volume_state)
        {
          v135 = volume_state;
          v136 = __error();
          strerror(*v136);
          BOMCopierErrorCapture(a3, v135, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 872, (uint64_t)"BOMCopierDestinationNew", "Could not get volume state for %s: %s");
          goto LABEL_319;
        }
        if (v6[12])
          v6[12] = valuePtr[0].st_dev;
        v6[20] = BYTE1(valuePtr[0].st_dev);
        v6[300] = BYTE2(valuePtr[0].st_dev);
      }
      break;
    case 1:
      v118 = archive_write_new();
      *((_QWORD *)v6 + 17) = v118;
      if (!v118)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 902, (uint64_t)"BOMCopierDestinationNew", "Could not create archive");
        goto LABEL_319;
      }
      v119 = archive_write_set_format();
      if (v119)
      {
        v120 = archive_errno();
        strerror(v120);
        BOMCopierErrorCapture(a3, v119, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 910, (uint64_t)"BOMCopierDestinationNew", "Could not set archive format: %s");
        goto LABEL_319;
      }
      v126 = archive_write_add_filter();
      if (v126)
      {
        v127 = v126;
        v128 = archive_errno();
        strerror(v128);
        BOMCopierErrorCapture(a3, v127, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 918, (uint64_t)"BOMCopierDestinationNew", "Could not set archive filter: %s");
        goto LABEL_319;
      }
      if (*((_DWORD *)v6 + 32) == 1 && *((_DWORD *)v6 + 36) != -1)
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%d", *((_DWORD *)v6 + 36));
        v137 = archive_write_set_filter_option();
        if (v137)
        {
          v138 = v137;
          v139 = archive_errno();
          strerror(v139);
          BOMCopierErrorCapture(a3, v138, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 937, (uint64_t)"BOMCopierDestinationNew", "Could not set zlib compression level %s: %s");
          goto LABEL_319;
        }
      }
      if (*((_DWORD *)v6 + 31) == 327680 && *((_DWORD *)v6 + 36) != -1)
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%d", *((_DWORD *)v6 + 36));
        v141 = archive_write_set_format_option();
        if (v141)
        {
          v142 = v141;
          v143 = archive_errno();
          strerror(v143);
          BOMCopierErrorCapture(a3, v142, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 954, (uint64_t)"BOMCopierDestinationNew", "Could not set PKZip compression level %s: %s (%d)", valuePtr);
          goto LABEL_319;
        }
      }
      if (*((_QWORD *)v6 + 8))
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%lld", *((_QWORD *)v6 + 8));
        v144 = archive_write_set_format_option();
        if (v144)
        {
          v145 = v144;
          v146 = archive_errno();
          strerror(v146);
          BOMCopierErrorCapture(a3, v145, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 971, (uint64_t)"BOMCopierDestinationNew", "Could not set cpio starting inode %s: %s");
          goto LABEL_319;
        }
      }
      if (v6[148])
      {
        v147 = archive_write_set_format_option();
        if (v147)
        {
          v148 = v147;
          v149 = archive_errno();
          strerror(v149);
          BOMCopierErrorCapture(a3, v148, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 984, (uint64_t)"BOMCopierDestinationNew", "Could not enable cpio skip trailer %s");
          goto LABEL_319;
        }
      }
      if (__s)
      {
        v152 = archive_write_open_filename();
        if (v152)
        {
          v153 = v152;
          v154 = archive_errno();
          strerror(v154);
          BOMCopierErrorCapture(a3, v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 999, (uint64_t)"BOMCopierDestinationNew", "Could not archive_write_open_filename %s: %s\n");
          goto LABEL_319;
        }
      }
      else if (*((_QWORD *)v6 + 7))
      {
        v158 = archive_write_open2();
        if (v158)
        {
          v159 = v158;
          v160 = archive_errno();
          strerror(v160);
          BOMCopierErrorCapture(a3, v159, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1028, (uint64_t)"BOMCopierDestinationNew", "Could not archive_write_open2 %s: %s\n");
          goto LABEL_319;
        }
      }
      else
      {
        if (*((_DWORD *)v6 + 12) == -1)
        {
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1036, (uint64_t)"BOMCopierDestinationNew", "No output file descriptor\n", v168);
          goto LABEL_319;
        }
        v164 = archive_write_open_fd();
        if (v164)
        {
          v165 = v164;
          v166 = archive_errno();
          strerror(v166);
          BOMCopierErrorCapture(a3, v165, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1044, (uint64_t)"BOMCopierDestinationNew", "Could not archive_write_open_fd %s: %s\n");
          goto LABEL_319;
        }
      }
      break;
    case 2:
      if (__s)
      {
        v117 = AAFileStreamOpenWithPath(__s, 1537, 0x1A4u);
        *((_QWORD *)v6 + 21) = v117;
        if (!v117)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1063, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive byte stream at %s\n");
          goto LABEL_319;
        }
      }
      else if (*((_QWORD *)v6 + 7))
      {
        v121 = AACustomByteStreamOpen();
        *((_QWORD *)v6 + 21) = v121;
        if (!v121)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1079, (uint64_t)"BOMCopierDestinationNew", "Could not create custom AppleArchive byte stream at %s\n");
          goto LABEL_319;
        }
        AACustomByteStreamSetData(v121, v6);
        AACustomByteStreamSetCloseProc(*((AAByteStream *)v6 + 21), (AAByteStreamCloseProc)apple_archive_close_callback_0);
        AACustomByteStreamSetWriteProc(*((AAByteStream *)v6 + 21), (AAByteStreamWriteProc)apple_archive_write_callback);
        v117 = (AAByteStream_impl *)*((_QWORD *)v6 + 21);
      }
      else
      {
        v129 = *((_DWORD *)v6 + 12);
        if (v129 == -1)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1091, (uint64_t)"BOMCopierDestinationNew", "No output file descriptor\n");
          goto LABEL_319;
        }
        v117 = AAFileStreamOpenWithFD(v129, 0);
        *((_QWORD *)v6 + 21) = v117;
        if (!v117)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1099, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive byte stream from file descriptor\n");
          goto LABEL_319;
        }
      }
      v130 = AACompressionOutputStreamOpen(v117, *((_DWORD *)v6 + 41), 0x100000uLL, 0, 0);
      *((_QWORD *)v6 + 22) = v130;
      if (!v130)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1118, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive compression stream\n");
        goto LABEL_319;
      }
      v131 = AAEncodeArchiveOutputStreamOpen(v130, 0, 0, 0, 0);
      *((_QWORD *)v6 + 23) = v131;
      if (!v131)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1132, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive encoder\n");
        goto LABEL_319;
      }
      break;
    case 3:
      if (__s)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1143, (uint64_t)"BOMCopierDestinationNew", "I expect path to be NULL for nowhere destinations");
        goto LABEL_319;
      }
      break;
    default:
      return v6;
  }
  return v6;
}

void BOMCopierDestinationFree(unsigned int *a1)
{
  void *v2;
  void *v3;
  void *v4;
  int v5;
  void *v6;
  void *v7;
  void *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  AAArchiveStream_impl *v13;
  char *v14;
  FILE *v15;
  const char *v16;
  AAByteStream_impl *v17;
  char *v18;
  AAByteStream_impl *v19;
  char *v20;
  FILE *v21;
  FILE *v22;
  int v23;
  int v24;
  _QWORD *v25;
  const void **v26;
  char *v27;

  if (!a1)
  {
    fwrite("copier_destination is NULL", 0x1AuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return;
  }
  v2 = (void *)*((_QWORD *)a1 + 3);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)a1 + 45);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)a1 + 43);
  if (v4)
    free(v4);
  if (*((_QWORD *)a1 + 42))
  {
    MEMORY[0x20BCF4398]();
    free(*((void **)a1 + 42));
  }
  v5 = a1[82];
  if (v5 != -1)
    close(v5);
  v6 = (void *)*((_QWORD *)a1 + 40);
  if (v6)
    free(v6);
  v7 = (void *)*((_QWORD *)a1 + 36);
  if (v7)
    free(v7);
  v8 = (void *)*((_QWORD *)a1 + 25);
  if (v8)
  {
    v9 = a1[48];
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = 16;
      do
      {
        v12 = *(void **)(*((_QWORD *)a1 + 25) + v11);
        if (v12)
        {
          free(v12);
          v9 = a1[48];
        }
        ++v10;
        v11 += 32;
      }
      while (v10 < v9);
      v8 = (void *)*((_QWORD *)a1 + 25);
    }
    free(v8);
  }
  v13 = (AAArchiveStream_impl *)*((_QWORD *)a1 + 23);
  if (v13)
  {
    v14 = (char *)AAArchiveStreamClose(v13);
    if ((_DWORD)v14)
    {
      v15 = (FILE *)*MEMORY[0x24BDAC8D8];
      v27 = v14;
      v16 = "Could not close AppleArchive encoder: %d\n";
LABEL_34:
      v21 = v15;
LABEL_35:
      fprintf(v21, v16, v27);
      return;
    }
  }
  v17 = (AAByteStream_impl *)*((_QWORD *)a1 + 22);
  if (v17)
  {
    v18 = (char *)AAByteStreamClose(v17);
    if ((_DWORD)v18)
    {
      v15 = (FILE *)*MEMORY[0x24BDAC8D8];
      v27 = v18;
      v16 = "Could not close AppleArchive compression stream: %d\n";
      goto LABEL_34;
    }
  }
  v19 = (AAByteStream_impl *)*((_QWORD *)a1 + 21);
  if (v19)
  {
    v20 = (char *)AAByteStreamClose(v19);
    if ((_DWORD)v20)
    {
      v15 = (FILE *)*MEMORY[0x24BDAC8D8];
      v27 = v20;
      v16 = "Could not close AppleArchive byte stream: %d\n";
      goto LABEL_34;
    }
  }
  if (*((_QWORD *)a1 + 17))
  {
    if (archive_write_close())
    {
      v22 = (FILE *)*MEMORY[0x24BDAC8D8];
      v23 = archive_errno();
      v27 = strerror(v23);
      v16 = "Could not close archive %s\n";
LABEL_41:
      v21 = v22;
      goto LABEL_35;
    }
    if (archive_write_free())
    {
      v22 = (FILE *)*MEMORY[0x24BDAC8D8];
      v24 = archive_errno();
      v27 = strerror(v24);
      v16 = "Could not free archive: %s\n";
      goto LABEL_41;
    }
  }
  v25 = (_QWORD *)*((_QWORD *)a1 + 13);
  if (v25)
  {
    BOMCopierDataAnalyzerFree(v25);
    *((_QWORD *)a1 + 13) = 0;
  }
  v26 = (const void **)*((_QWORD *)a1 + 9);
  if (v26)
    BOMHardLinkTableFree(v26);
  free(a1);
}

uint64_t make_path(NSObject *a1, char *__s1, _QWORD *a3)
{
  char *v6;
  char *v7;
  int v8;
  _BOOL8 v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;
  int *v14;
  int v15;
  int *v16;
  char *v17;
  int v19;
  int *v20;
  uint8_t buf[4];
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v6 = strdup(__s1);
  if (!v6)
  {
    v15 = *__error();
    v16 = __error();
    v17 = strerror(*v16);
    BOMCopierErrorCapture(a3, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3538, (uint64_t)"make_path", "Could not duplicate %s: %s", __s1, v17);
    return 1;
  }
  v7 = v6;
  v8 = *v6;
  v9 = v8 == 47;
  if (v8 == 47)
    ++v6;
  v10 = strchr(v6, 47);
  if (!v10)
  {
LABEL_13:
    if (mkdir(v7, 0x1EDu))
    {
      if (*__error() != 17)
      {
        v13 = *__error();
        v14 = __error();
        strerror(*v14);
        BOMCopierErrorCapture(a3, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3599, (uint64_t)"make_path", "Could not mkdir %s: %s");
        goto LABEL_22;
      }
    }
    else if (a1)
    {
      if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v22 = v7;
        _os_log_impl(&dword_206367000, a1, OS_LOG_TYPE_DEFAULT, "Created directory %s", buf, 0xCu);
      }
    }
    free(v7);
    return 0;
  }
  v11 = v10;
  v12 = &v7[v9 + 1];
  while (1)
  {
    *v11 = 0;
    if (!mkdir(v7, 0x1EDu))
    {
      if (a1 && os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v22 = v7;
        _os_log_impl(&dword_206367000, a1, OS_LOG_TYPE_DEFAULT, "Created directory %s", buf, 0xCu);
      }
      goto LABEL_8;
    }
    if (*__error() != 17)
      break;
LABEL_8:
    *v11 = 47;
    v11 = strchr(v12++, 47);
    if (!v11)
      goto LABEL_13;
  }
  v19 = *__error();
  v20 = __error();
  strerror(*v20);
  BOMCopierErrorCapture(a3, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3562, (uint64_t)"make_path", "Could not mkdir %s: %s");
LABEL_22:
  free(v7);
  return 1;
}

uint64_t get_volume_state(const char *a1, BOOL *a2, _QWORD *a3)
{
  int v6;
  int *v7;
  uint64_t result;
  char f_flags;
  int v10;
  int *v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  int v15;
  statfs v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  memset(&v16, 0, 512);
  if (!statfs(a1, &v16))
  {
    f_flags = v16.f_flags;
    *a2 = (v16.f_flags & 0x80) != 0;
    a2[1] = (f_flags & 8) == 0;
    v14 = xmmword_2063CFCC0;
    v15 = 0;
    v12 = xmmword_2063CFCD4;
    v13 = 0;
    if (getattrlist(a1, &v12, &v14, 0x14uLL, 0))
    {
      if (*__error() != 22)
      {
        v10 = *__error();
        v11 = __error();
        strerror(*v11);
        BOMCopierErrorCapture(a3, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8657, (uint64_t)"get_volume_state", "Could not getattrlist %s: %s\n");
        return 1;
      }
      if (*(_DWORD *)v16.f_fstypename == 7562856)
        a2[2] = 1;
      if (*(_DWORD *)v16.f_fstypename ^ 0x73667061 | v16.f_fstypename[4])
        return 0;
    }
    else if ((BYTE6(v14) & 1) == 0)
    {
      return 0;
    }
    result = 0;
    a2[2] = 1;
    return result;
  }
  v6 = *__error();
  v7 = __error();
  strerror(*v7);
  BOMCopierErrorCapture(a3, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8628, (uint64_t)"get_volume_state", "Could not statfs %s: %s");
  return 1;
}

uint64_t libarchive_open_callback_0()
{
  return 0;
}

CFIndex libarchive_write_callback(int a1, uint64_t a2, UInt8 *buffer, CFIndex bufferLength)
{
  if (a2)
    return CFWriteStreamWrite(*(CFWriteStreamRef *)(a2 + 56), buffer, bufferLength);
  else
    return -1;
}

uint64_t libarchive_close_callback_0()
{
  return 0;
}

uint64_t libarchive_free_callback()
{
  return 0;
}

uint64_t apple_archive_close_callback_0()
{
  return 0;
}

CFIndex apple_archive_write_callback(uint64_t a1, const UInt8 *a2, CFIndex a3)
{
  if (a1)
    return CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 56), a2, a3);
  else
    return -1;
}

_QWORD *BOMCopierDestinationSetLog(_QWORD *result, uint64_t a2)
{
  if (result)
  {
    if (a2)
      *result = a2;
  }
  return result;
}

uint64_t BOMCopierDestinationSetAllowBom(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  if (a1)
  {
    v3 = 0;
    *(_QWORD *)(a1 + 80) = a2;
  }
  else
  {
    v3 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1304, (uint64_t)"BOMCopierDestinationSetAllowBom", "copier_destination is NULL");
  }
  return v3;
}

uint64_t BOMCopierDestinationSetDenyBom(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  if (a1)
  {
    v3 = 0;
    *(_QWORD *)(a1 + 88) = a2;
  }
  else
  {
    v3 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1326, (uint64_t)"BOMCopierDestinationSetDenyBom", "copier_destination is NULL");
  }
  return v3;
}

uint64_t BOMCopierDestinationSetChecksumBom(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *v5;
  uint64_t v6;

  if (a1)
  {
    *(_QWORD *)(a1 + 96) = a2;
    if (!a2)
      return 0;
    if (*(_QWORD *)(a1 + 104))
      return 0;
    v5 = BOMCopierDataAnalyzerNew(2, a3);
    *(_QWORD *)(a1 + 104) = v5;
    if (v5)
    {
      return 0;
    }
    else
    {
      v6 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1365, (uint64_t)"BOMCopierDestinationSetChecksumBom", "Could not create BOMCopierDataAnalyzer");
    }
  }
  else
  {
    v6 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1348, (uint64_t)"BOMCopierDestinationSetChecksumBom", "copier_destination is NULL");
  }
  return v6;
}

uint64_t BOMCopierDestinationSetRedirectCallback(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;

  if (a1)
  {
    v4 = 0;
    *(_QWORD *)(a1 + 208) = a2;
    *(_QWORD *)(a1 + 216) = a3;
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1387, (uint64_t)"BOMCopierDestinationSetRedirectCallback", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationSetConflictResolver(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;

  if (a1)
  {
    v4 = 0;
    *(_QWORD *)(a1 + 224) = a2;
    *(_QWORD *)(a1 + 232) = a3;
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1410, (uint64_t)"BOMCopierDestinationSetConflictResolver", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationSetFinalizationCallback(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;

  if (a1)
  {
    v4 = 0;
    *(_QWORD *)(a1 + 264) = a2;
    *(_QWORD *)(a1 + 272) = a3;
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1433, (uint64_t)"BOMCopierDestinationSetFinalizationCallback", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationGetCopyOperation(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 240);
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1453, (uint64_t)"BOMCopierDestinationGetCopyOperation", "copier_destination is NULL");
  return 2;
}

uint64_t BOMCopierDestinationGetCopyResult(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 244);
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1470, (uint64_t)"BOMCopierDestinationGetCopyResult", "copier_destination is NULL");
  return 1;
}

uint64_t BOMCopierDestinationSetDataWrittenCallback(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;

  if (a1)
  {
    v4 = 0;
    *(_QWORD *)(a1 + 248) = a2;
    *(_QWORD *)(a1 + 256) = a3;
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1490, (uint64_t)"BOMCopierDestinationSetDataWrittenCallback", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationCreateEntry(uint64_t a1, uint64_t a2, char a3, _QWORD *a4)
{
  _BOOL4 v8;
  uint64_t Path;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  int *v14;
  int v16;
  int entry_apple_archive;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1513, (uint64_t)"BOMCopierDestinationCreateEntry", "copier_destination is NULL");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1519, (uint64_t)"BOMCopierDestinationCreateEntry", "source_entry is NULL");
    return 0;
  }
  if (*(_QWORD *)(a1 + 80) && !BOMCopierSourceEntryIsRoot(a2))
  {
    Path = BOMCopierSourceEntryGetPath(a2);
    v8 = !BOMBomFSObjectExistsAtPath(*(_QWORD *)(a1 + 80), Path);
  }
  else
  {
    v8 = 0;
  }
  if (*(_QWORD *)(a1 + 88))
  {
    if (!BOMCopierSourceEntryIsRoot(a2))
    {
      v10 = BOMCopierSourceEntryGetPath(a2);
      if (BOMBomFSObjectExistsAtPath(*(_QWORD *)(a1 + 88), v10))
        v8 = 1;
    }
  }
  v11 = malloc_type_calloc(1uLL, 0x178uLL, 0x10300404E91E69FuLL);
  if (!v11)
  {
    v13 = *__error();
    v14 = __error();
    strerror(*v14);
    BOMCopierErrorCapture(a4, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1584, (uint64_t)"BOMCopierDestinationCreateEntry", "Could not allocate empty destination entry: %s");
    return 0;
  }
  v12 = (uint64_t)v11;
  v11[8] = -1;
  *(_DWORD *)v11 = *(_DWORD *)(a1 + 44);
  v11[1] = a2;
  if (!v8)
  {
    BOMCopierDataAnalyzerReset(*(uint64_t **)(a1 + 104));
    *(_QWORD *)(v12 + 24) = *(_QWORD *)(a1 + 104);
    *(_DWORD *)(v12 + 32) = 1;
    if (BOMCopierSourceEntryGetType(a2) == 8)
    {
      *(_QWORD *)(v12 + 56) = BOMCopierSourceEntryGetSize(a2);
      if (BOMCopierSourceEntryGetBinaryType(a2))
      {
        v19 = 0u;
        v20 = 0u;
        v18 = 0u;
        LODWORD(v18) = *(_DWORD *)(a1 + 192);
        *((_QWORD *)&v18 + 1) = *(_QWORD *)(a1 + 200);
        if (BOMCopierMatchBinary(a2, (unsigned int *)&v18, a4))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3647, (uint64_t)"match_binary", "Could not match the binary");
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1639, (uint64_t)"BOMCopierDestinationCreateEntry", "Could not match the source binary");
LABEL_33:
          BOMCopierDestinationEntryFree((_QWORD *)v12);
          return 0;
        }
        *(_OWORD *)(v12 + 32) = v19;
        *(_DWORD *)(v12 + 48) = v20;
        *(_QWORD *)(v12 + 56) = *((_QWORD *)&v20 + 1);
      }
    }
    if (*(_DWORD *)(v12 + 32) == 2)
      return v12;
    v16 = *(_DWORD *)(a1 + 44);
    if (v16 == 2)
    {
      entry_apple_archive = create_entry_apple_archive(a1, a2, v12, a4);
    }
    else if (v16 == 1)
    {
      entry_apple_archive = create_entry_libarchive(a1, a2, (_QWORD *)v12, a4);
    }
    else
    {
      if (v16)
        return v12;
      entry_apple_archive = create_entry_filesystem(a1, a2, v12, a3, a4);
    }
    if (!entry_apple_archive)
      return v12;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1679, (uint64_t)"BOMCopierDestinationCreateEntry", "Could not create the entry");
    goto LABEL_33;
  }
  *((_BYTE *)v11 + 16) = 1;
  return v12;
}

void BOMCopierDestinationEntryFree(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  FILE *v5;
  int *v6;
  char *v7;
  int v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  if (a1)
  {
    v2 = (void *)a1[45];
    if (v2)
      free(v2);
    v3 = (void *)a1[43];
    if (v3)
      free(v3);
    if (a1[10])
      archive_entry_free();
    v4 = (void *)a1[40];
    if (v4)
      free(v4);
    if (a1[20])
    {
      if (ParallelCompressionAFSCStreamClose())
      {
        v5 = (FILE *)*MEMORY[0x24BDAC8D8];
        v6 = __error();
        v7 = strerror(*v6);
        fprintf(v5, "Could not close compressor stream: %s", v7);
      }
      a1[20] = 0;
    }
    v8 = *((_DWORD *)a1 + 17);
    if (v8 != *((_DWORD *)a1 + 16))
    {
      close(v8);
      v8 = *((_DWORD *)a1 + 16);
    }
    if (v8 != -1)
      close(v8);
    v9 = (void *)a1[18];
    if (v9)
      free(v9);
    v10 = (void *)a1[17];
    if (v10)
      free(v10);
    v11 = (void *)a1[16];
    if (v11)
      free(v11);
    v12 = (void *)a1[15];
    if (v12)
      free(v12);
    v13 = (void *)a1[5];
    if (v13)
      free(v13);
    free(a1);
  }
}

uint64_t create_entry_filesystem(uint64_t a1, uint64_t a2, uint64_t a3, char a4, _QWORD *a5)
{
  unsigned int Type;
  const char *Path;
  NSObject *v12;
  size_t v13;
  unint64_t v14;
  int v15;
  char *v16;
  int v17;
  int *v18;
  void (*v19)(uint64_t, _BYTE *, _QWORD);
  char *v20;
  const char **v21;
  char *v22;
  NSObject *v23;
  const char *v24;
  char *v25;
  int v26;
  const char *v27;
  int *v28;
  char *v29;
  int v30;
  uint64_t v31;
  int *v32;
  int v33;
  int *v34;
  int v35;
  int *v36;
  char *v37;
  NSObject *v38;
  char v39;
  char v40;
  unsigned int v41;
  os_log_t v42;
  int v43;
  NSObject *v44;
  const char *v45;
  NSObject *v46;
  uint64_t v47;
  const char *v48;
  __int16 v49;
  int v50;
  char *v51;
  char *v52;
  void *v53;
  void *v54;
  char *v55;
  NSObject *v56;
  const char *v57;
  uint64_t (*v58)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD *);
  int v59;
  int v60;
  int *v61;
  int v62;
  uint64_t v63;
  int *v64;
  uint64_t v65;
  unsigned int v67;
  BOOL IsSegmentedFile;
  BOOL v69;
  ssize_t v70;
  size_t v71;
  void *v72;
  void *v73;
  ssize_t v74;
  int v75;
  int *v76;
  int v77;
  int *v78;
  int v79;
  int *v80;
  int v81;
  int *v82;
  NSObject *v83;
  const char *v84;
  int *v85;
  int v86;
  int *v87;
  size_t v88;
  char *v89;
  char *v90;
  int v91;
  __int16 Mode;
  mode_t v93;
  int v94;
  int *v95;
  int v96;
  int *v97;
  int v98;
  int *v99;
  int v100;
  int *v101;
  int v102;
  int *v103;
  int v104;
  int *v105;
  char *v106;
  int v107;
  int *v108;
  int Device;
  uint64_t Inode;
  const char *SymlinkTarget;
  int v112;
  int *v113;
  int v114;
  NSObject *v115;
  const char *v116;
  int *v117;
  char *v118;
  os_log_t v119;
  uint64_t v120;
  const char *v121;
  NSObject *v122;
  uint32_t v123;
  int v124;
  int *v125;
  int v126;
  const char *v127;
  int *v128;
  NSObject *v129;
  const char *v130;
  int v131;
  int *v132;
  int v133;
  int v134;
  NSObject *v135;
  uint64_t v136;
  const char *v137;
  int v138;
  int v139;
  int *v140;
  NSObject *v141;
  uint64_t v142;
  int v143;
  int v144;
  int v145;
  int *v146;
  int v147;
  int *v148;
  int v149;
  int *v150;
  int v151;
  NSObject *v152;
  int v153;
  int *v154;
  int v155;
  int *v156;
  NSObject *v157;
  const char *v158;
  const char *v159;
  int v160;
  const char *v161;
  BOOL v162;
  uint64_t v163;
  os_log_t v164;
  uint64_t v165;
  int v166;
  int *v167;
  int v168;
  int *v169;
  int v170;
  int *v171;
  uint64_t v172;
  uint64_t v173;
  const char *v174;
  _QWORD *v175;
  uint64_t Size;
  _BYTE v177[12];
  __int16 v178;
  _BYTE *v179;
  _BYTE buf[12];
  __int16 v181;
  const char *v182;
  __int16 v183;
  const char *v184;
  uint64_t v185;

  v185 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 240) = 0;
  Type = BOMCopierSourceEntryGetType(a2);
  Path = (const char *)BOMCopierSourceEntryGetPath(a2);
  v12 = *(NSObject **)a1;
  if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = string_for_entry_type(Type);
    v181 = 2080;
    v182 = Path;
    _os_log_impl(&dword_206367000, v12, OS_LOG_TYPE_DEFAULT, "entry_path: [%s] %s", buf, 0x16u);
  }
  v13 = strlen(Path);
  if (!v13)
  {
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7821, (uint64_t)"construct_filesystem_destination", "The entry path is empty");
LABEL_87:
    v65 = 1;
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3690, (uint64_t)"create_entry_filesystem", "Could not construct filesystem destinations");
    return v65;
  }
  v14 = v13;
  if (!strncmp(Path, ".", v13))
  {
    ++Path;
  }
  else if (v14 >= 3)
  {
    v15 = *(unsigned __int8 *)Path;
    if (v15 != 46)
      goto LABEL_12;
    Path += 2 * (Path[1] == 47);
  }
  v15 = *(unsigned __int8 *)Path;
LABEL_12:
  if (BOMCopierSourceEntryIsRoot(a2))
  {
    if (Type == 6 || !*(_BYTE *)(a1 + 284) || !*(_BYTE *)(a1 + 285))
    {
LABEL_16:
      v16 = strdup(*(const char **)(a1 + 288));
      *(_QWORD *)(a3 + 120) = v16;
      if (!v16)
      {
        v17 = *__error();
        v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture(a5, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7938, (uint64_t)"construct_filesystem_destination", "Could not construct destination path from %s: %s");
        goto LABEL_87;
      }
      goto LABEL_21;
    }
  }
  else if (!v15)
  {
    goto LABEL_16;
  }
  if (asprintf((char **)(a3 + 120), "%s/%s", *(const char **)(a1 + 288), Path) < 0 || !*(_QWORD *)(a3 + 120))
  {
    v30 = *__error();
    v31 = *(_QWORD *)(a1 + 288);
    v32 = __error();
    strerror(*v32);
    BOMCopierErrorCapture(a5, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7946, (uint64_t)"construct_filesystem_destination", "Could not construct destination path from %s and %s: %s", v31);
    goto LABEL_87;
  }
LABEL_21:
  v19 = *(void (**)(uint64_t, _BYTE *, _QWORD))(a1 + 208);
  if (v19)
  {
    *(_QWORD *)buf = 0;
    v19(a1, buf, *(_QWORD *)(a1 + 216));
    if (*(_QWORD *)buf)
    {
      free(*(void **)(a3 + 120));
      *(_QWORD *)(a3 + 120) = *(_QWORD *)buf;
    }
    *(_QWORD *)(a1 + 208) = 0;
    *(_QWORD *)(a1 + 216) = 0;
  }
  v20 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x1055A69BuLL);
  *(_QWORD *)(a3 + 128) = v20;
  if (!v20)
  {
    v33 = *__error();
    v34 = __error();
    strerror(*v34);
    BOMCopierErrorCapture(a5, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7974, (uint64_t)"construct_filesystem_destination", "Could not allocate destination name: %s");
    goto LABEL_87;
  }
  v21 = (const char **)(a3 + 120);
  basename_r(*(const char **)(a3 + 120), v20);
  v22 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0xE058D778uLL);
  *(_QWORD *)(a3 + 136) = v22;
  if (!v22)
  {
    v35 = *__error();
    v36 = __error();
    strerror(*v36);
    BOMCopierErrorCapture(a5, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7984, (uint64_t)"construct_filesystem_destination", "Could not allocate destination parent: %s");
    goto LABEL_87;
  }
  dirname_r(*v21, v22);
  v23 = *(NSObject **)a1;
  if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    v24 = *v21;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v24;
    _os_log_impl(&dword_206367000, v23, OS_LOG_TYPE_DEFAULT, "destination_path: %s", buf, 0xCu);
  }
  if (*(_BYTE *)(a1 + 297) && (Type - 7 < 4 || Type == 5) && !BOMCopierSourceEntryIsSegmentedFile(a2))
  {
    *(_QWORD *)buf = 0;
    if (asprintf((char **)buf, "%s/%s", *(const char **)(a3 + 136), ".BCD.T_XXXXXX") < 0 || !*(_QWORD *)buf)
    {
      v62 = *__error();
      v63 = *(_QWORD *)(a3 + 136);
      v64 = __error();
      strerror(*v64);
      BOMCopierErrorCapture(a5, v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8029, (uint64_t)"construct_filesystem_destination", "Could not construct atomic template path from %s and %s: %s", v63);
      goto LABEL_87;
    }
    v25 = mktemp(*(char **)buf);
    if (v25 != *(char **)buf)
    {
      v26 = *__error();
      v27 = *(const char **)buf;
      v28 = __error();
      v29 = strerror(*v28);
      BOMCopierErrorCapture(a5, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8039, (uint64_t)"construct_filesystem_destination", "Could not mktemp %s and %s: %s", v27, v29, v174);
      free(*(void **)buf);
      goto LABEL_87;
    }
    v37 = v25;
    *(_QWORD *)(a3 + 144) = v25;
    *(_BYTE *)(a3 + 152) = 1;
  }
  else
  {
    v37 = strdup(*(const char **)(a3 + 120));
    *(_QWORD *)(a3 + 144) = v37;
    if (!v37)
    {
      v60 = *__error();
      v61 = __error();
      strerror(*v61);
      BOMCopierErrorCapture(a5, v60, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8063, (uint64_t)"construct_filesystem_destination", "Could not duplicate %s: %s");
      goto LABEL_87;
    }
  }
  v38 = *(NSObject **)a1;
  if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v37;
    _os_log_impl(&dword_206367000, v38, OS_LOG_TYPE_DEFAULT, "destination_staging_path: %s", buf, 0xCu);
  }
  v39 = 0;
  while (1)
  {
    v40 = v39;
    *(_BYTE *)(a3 + 153) = 1;
    if (lstat(*(const char **)(a3 + 120), (stat *)(a3 + 168)))
    {
      if (*__error() != 2)
      {
        v79 = *__error();
        v80 = __error();
        strerror(*v80);
        BOMCopierErrorCapture(a5, v79, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8096, (uint64_t)"resolve_filesystem_conflict", "Could not lstat %s: %s");
        goto LABEL_119;
      }
      *(_BYTE *)(a3 + 153) = 0;
      goto LABEL_95;
    }
    v41 = BOMCopierSourceEntryGetType(a2);
    v42 = *(os_log_t *)a1;
    v43 = *(_WORD *)(a3 + 172) & 0xF000;
    switch(v41)
    {
      case 0u:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8352, (uint64_t)"check_filesystem_conflict", "The source entry is unknown");
        goto LABEL_118;
      case 1u:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8358, (uint64_t)"check_filesystem_conflict", "The source entry is a circular directory");
        goto LABEL_118;
      case 2u:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8364, (uint64_t)"check_filesystem_conflict", "The source entry is an unreadable directory");
LABEL_118:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8121, (uint64_t)"resolve_filesystem_conflict", "Could not check for a destination conflict for %s");
        goto LABEL_119;
      case 3u:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_95;
      case 6u:
        if (v43 == 0x4000)
          goto LABEL_95;
        if (!v42 || !os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          goto LABEL_57;
        *(_WORD *)buf = 0;
        v44 = v42;
        v45 = "Filesystem Conflict: The source entry is a Directory but the destination entry is not.";
        break;
      default:
        if (v43 != 0x4000)
          goto LABEL_95;
        if (!v42 || !os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          goto LABEL_57;
        *(_WORD *)buf = 0;
        v44 = v42;
        v45 = "Filesystem Conflict: The source entry is not a Directory but the destination entry is.";
        break;
    }
    _os_log_impl(&dword_206367000, v44, OS_LOG_TYPE_DEFAULT, v45, buf, 2u);
LABEL_57:
    v46 = *(NSObject **)a1;
    if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      v47 = *(_QWORD *)(a3 + 120);
      v48 = *(const char **)(a3 + 144);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v47;
      v181 = 2080;
      v182 = v48;
      _os_log_impl(&dword_206367000, v46, OS_LOG_TYPE_DEFAULT, "%s conflicts with %s", buf, 0x16u);
    }
    if (v41 == 6)
    {
      v49 = *(_WORD *)(a3 + 172);
      if ((v49 & 0xF000) == 0xA000)
        break;
    }
    v58 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD *))(a1 + 224);
    if (!v58)
    {
      string_for_mode(*(_WORD *)(a3 + 172));
      string_for_entry_type(v41);
      BOMCopierErrorCapture(a5, 21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8321, (uint64_t)"resolve_filesystem_conflict", "%s: conflict replacing %s with %s", *(_QWORD *)(a3 + 120));
      goto LABEL_119;
    }
LABEL_80:
    *(_DWORD *)(a1 + 240) = 0;
    v59 = v58(a1, a2, a3, *(_QWORD *)(a1 + 232), a5);
    if (v59 != 3)
    {
      if (v59 == 2)
      {
        *(_DWORD *)(a1 + 240) = 2;
        return 1;
      }
      if (v59 == 1)
      {
        *(_QWORD *)(a1 + 240) = 0x100000001;
        return 1;
      }
LABEL_95:
      if (*(_DWORD *)(a1 + 240))
        return 1;
      v67 = BOMCopierSourceEntryGetType(a2);
      IsSegmentedFile = BOMCopierSourceEntryIsSegmentedFile(a2);
      v69 = IsSegmentedFile;
      if (*(_BYTE *)(a1 + 297))
      {
LABEL_97:
        if (*(_BYTE *)(a3 + 153))
        {
          if (v67 == 8)
            goto LABEL_99;
          goto LABEL_132;
        }
LABEL_110:
        if (make_path(*(NSObject **)a1, *(char **)(a3 + 136), a5))
        {
          v77 = *__error();
          v78 = __error();
          strerror(*v78);
          BOMCopierErrorCapture(a5, v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3787, (uint64_t)"create_entry_filesystem", "Could not make_path %s: %s");
          return 1;
        }
        goto LABEL_132;
      }
      if (!*(_BYTE *)(a3 + 153))
        goto LABEL_110;
      if (v67 <= 0xA)
      {
        if (((1 << v67) & 0x6B0) != 0)
        {
          if (unlink(*v21))
          {
            v75 = *__error();
            v76 = __error();
            strerror(*v76);
            BOMCopierErrorCapture(a5, v75, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3746, (uint64_t)"create_entry_filesystem", "Could not unlink %s: %s");
            return 1;
          }
          v83 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v84 = *v21;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v84;
            _os_log_impl(&dword_206367000, v83, OS_LOG_TYPE_DEFAULT, "Unlinked %s", buf, 0xCu);
          }
          goto LABEL_97;
        }
        if (v67 == 8)
        {
          if (!IsSegmentedFile)
          {
            if (unlink(*v21))
            {
              v86 = *__error();
              v87 = __error();
              strerror(*v87);
              BOMCopierErrorCapture(a5, v86, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3764, (uint64_t)"create_entry_filesystem", "Could not unlink %s: %s");
              return 1;
            }
            goto LABEL_97;
          }
LABEL_99:
          if (*(_BYTE *)(a1 + 301))
          {
            v70 = getxattr(*v21, "com.apple.rootless", 0, 0, 0, 1);
            if (v70 == -1)
            {
              if (*__error() != 93)
              {
                v85 = __error();
                strerror(*v85);
                v65 = 1;
                BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3804, (uint64_t)"create_entry_filesystem", "Could not get size for rootless attribute %s: %s");
                return v65;
              }
            }
            else
            {
              v71 = v70;
              if (v70 >= 1)
              {
                v72 = malloc_type_malloc(v70, 0x4350292CuLL);
                if (!v72)
                {
                  v114 = *__error();
                  BOMCopierErrorCapture(a5, v114, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3814, (uint64_t)"create_entry_filesystem", "Could not allocate attribute buffer: %s");
                  return 1;
                }
                v73 = v72;
                v74 = getxattr(*v21, "com.apple.rootless", v72, v71, 0, 1);
                if (v74 == -1)
                {
                  v116 = *v21;
                  v117 = __error();
                  v118 = strerror(*v117);
                  v65 = 1;
                  BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3821, (uint64_t)"create_entry_filesystem", "Could not get rootless attribute for xattr %s: %s", v116, v118);
                  free(v73);
                  return v65;
                }
                *(_QWORD *)(a3 + 312) = v74;
                *(_QWORD *)(a3 + 320) = v73;
              }
            }
          }
        }
      }
LABEL_132:
      if (*(_BYTE *)(a1 + 298))
      {
        v88 = strlen(*(const char **)(a1 + 288));
        v89 = realpath_DARWIN_EXTSN(*(const char **)(a3 + 136), 0);
        if (!v89)
        {
          v96 = *__error();
          v97 = __error();
          strerror(*v97);
          BOMCopierErrorCapture(a5, v96, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3848, (uint64_t)"create_entry_filesystem", "Could not realpath parent %s: %s");
          return 1;
        }
        v90 = v89;
        v91 = strncmp(*(const char **)(a1 + 288), v89, v88);
        free(v90);
        if (v91)
        {
          v65 = 1;
          BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3858, (uint64_t)"create_entry_filesystem", "%s resolves outside of %s");
          return v65;
        }
      }
      v65 = 0;
      switch(v67)
      {
        case 6u:
          if (*(_BYTE *)(a3 + 153))
            return 0;
          Mode = BOMCopierSourceEntryGetMode(a2);
          v93 = *(_BYTE *)(a1 + 296) ? 493 : Mode;
          if (!mkdir(*v21, v93))
            return 0;
          v94 = *__error();
          v95 = __error();
          strerror(*v95);
          BOMCopierErrorCapture(a5, v94, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3882, (uint64_t)"create_entry_filesystem", "Could not create directory at %s: %s");
          return 1;
        case 8u:
          if (BOMCopierSourceEntryGetHardlinkCount(a2) < 2)
            goto LABEL_176;
          Device = BOMCopierSourceEntryGetDevice(a2);
          Inode = BOMCopierSourceEntryGetInode(a2);
          v175 = 0;
          Size = BOMCopierSourceEntryGetSize(a2);
          if (BOMHardLinkTableGetPathAndData(*(CFDictionaryRef **)(a1 + 72), Device, Inode, buf, &v175))
          {
            BOMHardLinkTableSetPathAndData(*(CFDictionaryRef **)(a1 + 72), Device, Inode, (char *)*v21, &Size, 8uLL);
          }
          else if (*v175 == Size)
          {
            if (*(_BYTE *)(a3 + 153) && unlink(*v21))
            {
              v124 = *__error();
              v125 = __error();
              strerror(*v125);
              BOMCopierErrorCapture(a5, v124, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3956, (uint64_t)"create_entry_filesystem", "Could not unlink %s: %s");
              return 1;
            }
            if (link(buf, *v21))
            {
              if (*__error() != 18)
              {
                v126 = *__error();
                v127 = *v21;
                v128 = __error();
                strerror(*v128);
                BOMCopierErrorCapture(a5, v126, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3968, (uint64_t)"create_entry_filesystem", "Could not create hardlink %s to %s: %s", v127);
                return 1;
              }
            }
            else
            {
              *(_DWORD *)(a1 + 244) = 2;
              *(_BYTE *)(a3 + 154) = 1;
              *(_BYTE *)(a3 + 152) = 0;
              v129 = *(NSObject **)a1;
              if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                v130 = *v21;
                *(_DWORD *)v177 = 136315394;
                *(_QWORD *)&v177[4] = v130;
                v178 = 2080;
                v179 = buf;
                _os_log_impl(&dword_206367000, v129, OS_LOG_TYPE_DEFAULT, "Hardlinked %s to %s", v177, 0x16u);
              }
            }
          }
LABEL_176:
          if (!*(_BYTE *)(a1 + 304))
            goto LABEL_181;
          buf[0] = 0;
          if (BOMCopierSourceEntryClone(a2, *(char **)(a3 + 144), buf, a5))
          {
            v131 = *__error();
            v132 = __error();
            strerror(*v132);
            BOMCopierErrorCapture(a5, v131, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4003, (uint64_t)"create_entry_filesystem", "Could not clone source entry to %s: %s");
            return 1;
          }
          if (buf[0])
            *(_BYTE *)(a3 + 154) = 1;
LABEL_181:
          if (*(_BYTE *)(a3 + 154))
            return 0;
          if (v69)
          {
            v133 = open(*(const char **)(a3 + 144), 1, 420);
            if (v133 == -1)
            {
              v139 = *__error();
              v140 = __error();
              strerror(*v140);
              BOMCopierErrorCapture(a5, v139, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4087, (uint64_t)"create_entry_filesystem", "Could not open regular file at %s: %s");
              return 1;
            }
            v134 = v133;
            if (lseek(v133, 0, 2) == -1)
            {
              v153 = *__error();
              v154 = __error();
              strerror(*v154);
              BOMCopierErrorCapture(a5, v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4096, (uint64_t)"create_entry_filesystem", "Could not seek to the end of %s: %s");
              return 1;
            }
            v135 = *(NSObject **)a1;
            if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              v136 = *(_QWORD *)(a3 + 144);
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v136;
              _os_log_impl(&dword_206367000, v135, OS_LOG_TYPE_DEFAULT, "Opened segmented file at %s", buf, 0xCu);
            }
            goto LABEL_198;
          }
          v137 = *(const char **)(a3 + 144);
          if (*(_BYTE *)(a1 + 12))
            v138 = open_dprotected_np(v137, 1537, *(_DWORD *)(a1 + 16), 0, 420);
          else
            v138 = open(v137, 513, 420);
          v134 = v138;
          if (v138 == -1)
          {
            v149 = *__error();
            v150 = __error();
            strerror(*v150);
            BOMCopierErrorCapture(a5, v149, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4042, (uint64_t)"create_entry_filesystem", "Could not create regular file at %s: %s");
            return 1;
          }
          v141 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v142 = *(_QWORD *)(a3 + 144);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v142;
            _os_log_impl(&dword_206367000, v141, OS_LOG_TYPE_DEFAULT, "Created file at %s", buf, 0xCu);
          }
          if ((a4 & 2) == 0)
          {
LABEL_198:
            v143 = v134;
            goto LABEL_199;
          }
          *(_QWORD *)v177 = 0;
          asprintf((char **)v177, "%s%s", *(const char **)(a3 + 144), "/..namedfork/rsrc");
          if (!*(_QWORD *)v177)
          {
            v166 = *__error();
            v167 = __error();
            strerror(*v167);
            BOMCopierErrorCapture(a5, v166, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4060, (uint64_t)"create_entry_filesystem", "Could not create rsrc path for %s: %s");
            return 1;
          }
          v151 = open(*(const char **)v177, 513, 420);
          if (v151 == -1)
          {
            v168 = *__error();
            v169 = __error();
            strerror(*v169);
            BOMCopierErrorCapture(a5, v168, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4067, (uint64_t)"create_entry_filesystem", "Could not create resource fork at %s: %s");
            return 1;
          }
          v143 = v151;
          v152 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = *(_QWORD *)v177;
            _os_log_impl(&dword_206367000, v152, OS_LOG_TYPE_DEFAULT, "Open resource fork at %s", buf, 0xCu);
          }
          free(*(void **)v177);
LABEL_199:
          v144 = *(unsigned __int8 *)(a1 + 41);
          if (*(_BYTE *)(a1 + 41) && fcntl(v134, 68, 1))
          {
            v145 = *__error();
            v146 = __error();
            strerror(*v146);
            BOMCopierErrorCapture(a5, v145, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4116, (uint64_t)"create_entry_filesystem", "Could not set F_SETSTATICCONTENT for %s: %s");
            return 1;
          }
          if (*(_BYTE *)(a1 + 42))
          {
            if (fcntl(v134, 76, 1))
            {
              v147 = *__error();
              v148 = __error();
              strerror(*v148);
              BOMCopierErrorCapture(a5, v147, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4128, (uint64_t)"create_entry_filesystem", "Could not set F_SINGLE_WRITER for %s: %s");
              return 1;
            }
            if (*(_BYTE *)(a1 + 40))
            {
LABEL_217:
              if (fcntl(v134, 48, 1))
              {
                v155 = *__error();
                v156 = __error();
                strerror(*v156);
                BOMCopierErrorCapture(a5, v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4140, (uint64_t)"create_entry_filesystem", "Could not F_NOCACHE %s: %s\n");
                return 1;
              }
            }
          }
          else
          {
            if (*(_BYTE *)(a1 + 40))
              goto LABEL_217;
            if (!v144)
            {
LABEL_230:
              *(_DWORD *)(a3 + 64) = v134;
              *(_DWORD *)(a3 + 68) = v143;
              if (BOMCopierSourceEntryGetSize(a2) <= 0x4000)
                return 0;
              v65 = 0;
              v162 = (a4 & 1) == 0 && *(_BYTE *)(a1 + 112) == 0;
              if (v162 || !*(_BYTE *)(a1 + 300))
                return v65;
              v163 = ParallelCompressionAFSCStreamOpen();
              if (v163)
              {
                *(_QWORD *)(a3 + 160) = v163;
                v164 = *(os_log_t *)a1;
                if (!*(_QWORD *)a1)
                  return 0;
                v65 = 0;
                if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
                {
                  v165 = *(_QWORD *)(a3 + 144);
                  *(_DWORD *)buf = 136315138;
                  *(_QWORD *)&buf[4] = v165;
                  v121 = "Enabled filesystem compression for %s";
                  v122 = v164;
                  v123 = 12;
                  goto LABEL_165;
                }
                return v65;
              }
              v170 = *__error();
              v171 = __error();
              strerror(*v171);
              BOMCopierErrorCapture(a5, v170, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4193, (uint64_t)"create_entry_filesystem", "Could not create ParallelCompression AFSC stream for %s: %s");
              return 1;
            }
          }
          v157 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v158 = "F_SETSTATICCONTENT ";
            if (!*(_BYTE *)(a1 + 41))
              v158 = "";
            if (*(_BYTE *)(a1 + 42))
              v159 = "F_SINGLE_WRITER ";
            else
              v159 = "";
            v160 = *(unsigned __int8 *)(a1 + 40);
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v158;
            v181 = 2080;
            v182 = v159;
            if (v160)
              v161 = "F_NOCACHE ";
            else
              v161 = "";
            v183 = 2080;
            v184 = v161;
            _os_log_impl(&dword_206367000, v157, OS_LOG_TYPE_DEFAULT, "Set %s%s%s", buf, 0x20u);
          }
          goto LABEL_230;
        case 9u:
          SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget(a2);
          if (symlink(SymlinkTarget, *(const char **)(a3 + 144)))
          {
            v112 = *__error();
            v113 = __error();
            strerror(*v113);
            BOMCopierErrorCapture(a5, v112, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4211, (uint64_t)"create_entry_filesystem", "Could not create symlink at %s: %s");
            return 1;
          }
          v119 = *(os_log_t *)a1;
          if (!*(_QWORD *)a1)
            return 0;
          v65 = 0;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v120 = *(_QWORD *)(a3 + 144);
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v120;
            v181 = 2080;
            v182 = SymlinkTarget;
            v121 = "Created symlink %s -> %s";
            v122 = v119;
            v123 = 22;
LABEL_165:
            _os_log_impl(&dword_206367000, v122, OS_LOG_TYPE_DEFAULT, v121, buf, v123);
            return 0;
          }
          return v65;
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
          return v65;
        default:
          BOMCopierSourceEntryTypeString(v67);
          BOMCopierErrorCapture(a5, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4259, (uint64_t)"create_entry_filesystem", "Unsupported BOMCopierSourceEntryType: %s");
          return 1;
      }
    }
LABEL_81:
    v39 = 1;
    if ((v40 & 1) != 0)
      goto LABEL_95;
  }
  v50 = *(_DWORD *)(a1 + 280);
  if (!v50)
  {
    v58 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD *))(a1 + 224);
    if (!v58)
    {
      string_for_mode(v49);
      BOMCopierErrorCapture(a5, 20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8188, (uint64_t)"resolve_filesystem_conflict", "%s: conflict replacing %s with %s", *v21);
      goto LABEL_119;
    }
    goto LABEL_80;
  }
  if (v50 != 2)
  {
    if (v50 == 1)
    {
      if (unlink(*v21))
      {
        v81 = *__error();
        v82 = __error();
        strerror(*v82);
        BOMCopierErrorCapture(a5, v81, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8198, (uint64_t)"resolve_filesystem_conflict", "Could not unlink %s: %s");
        goto LABEL_119;
      }
      *(_BYTE *)(a3 + 153) = 0;
      v115 = *(NSObject **)a1;
      if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_206367000, v115, OS_LOG_TYPE_DEFAULT, "Conflicting symlink unlinked", buf, 2u);
      }
    }
    goto LABEL_95;
  }
  if (stat(*v21, (stat *)(a3 + 168)))
  {
    v98 = *__error();
    v99 = __error();
    strerror(*v99);
    BOMCopierErrorCapture(a5, v98, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8212, (uint64_t)"resolve_filesystem_conflict", "Could not stat %s: %s");
    goto LABEL_119;
  }
  if ((*(_WORD *)(a3 + 172) & 0xF000) != 0x4000)
  {
    BOMCopierErrorCapture(a5, 20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8218, (uint64_t)"resolve_filesystem_conflict", "%s: Not a directory");
    goto LABEL_119;
  }
  if (!basename_r(*v21, buf))
  {
    v100 = *__error();
    v101 = __error();
    strerror(*v101);
    BOMCopierErrorCapture(a5, v100, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8230, (uint64_t)"resolve_filesystem_conflict", "Could not basename %s: %s");
    goto LABEL_119;
  }
  v51 = realpath_DARWIN_EXTSN(*v21, 0);
  if (!v51)
  {
    v102 = *__error();
    v103 = __error();
    strerror(*v103);
    BOMCopierErrorCapture(a5, v102, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8237, (uint64_t)"resolve_filesystem_conflict", "Could not resolve %s: %s");
    goto LABEL_119;
  }
  v52 = v51;
  free((void *)*v21);
  *v21 = 0;
  asprintf((char **)(a3 + 120), "%s/%s", v52, buf);
  if (!*v21)
  {
    v104 = *__error();
    v105 = __error();
    v106 = strerror(*v105);
    BOMCopierErrorCapture(a5, v104, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8247, (uint64_t)"resolve_filesystem_conflict", "Could not reconstruct destination path: %s", v106);
    free(v52);
    goto LABEL_119;
  }
  v53 = *(void **)(a3 + 136);
  if (v53)
    free(v53);
  *(_QWORD *)(a3 + 136) = v52;
  v54 = *(void **)(a3 + 144);
  if (v54)
    free(v54);
  v55 = strdup(*(const char **)(a3 + 120));
  *(_QWORD *)(a3 + 144) = v55;
  if (v55)
  {
    v56 = *(NSObject **)a1;
    if (*(_QWORD *)a1)
    {
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
        || (*(_WORD *)v177 = 0,
            _os_log_impl(&dword_206367000, v56, OS_LOG_TYPE_DEFAULT, "Conflicting symlink followed", v177, 2u),
            (v56 = *(NSObject **)a1) != 0))
      {
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          v57 = *v21;
          *(_DWORD *)v177 = 136315138;
          *(_QWORD *)&v177[4] = v57;
          _os_log_impl(&dword_206367000, v56, OS_LOG_TYPE_DEFAULT, "destination_path: %s", v177, 0xCu);
        }
      }
    }
    goto LABEL_81;
  }
  v107 = *__error();
  v108 = __error();
  strerror(*v108);
  BOMCopierErrorCapture(a5, v107, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8267, (uint64_t)"resolve_filesystem_conflict", "Could not duplicate %s: %s");
LABEL_119:
  v65 = 1;
  BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3705, (uint64_t)"create_entry_filesystem", "Could not resolve filesystem conflict", v172, v173);
  return v65;
}

uint64_t create_entry_libarchive(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  const char *Path;
  char *v11;
  int Device;
  uint64_t Inode;
  unsigned int HardlinkCount;
  const UInt8 *v15;
  uint64_t v16;
  int *v17;
  CFDictionaryRef *v18;
  uint64_t v19;
  int Type;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  UInt8 bytes[8];

  v8 = archive_entry_new();
  if (v8)
  {
    v9 = v8;
    Path = (const char *)BOMCopierSourceEntryGetPath(a2);
    archive_entry_set_pathname();
    v11 = strdup(Path);
    a3[15] = v11;
    if (!v11)
    {
      v17 = __error();
      strerror(*v17);
      v16 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4293, (uint64_t)"create_entry_libarchive", "Could not duplicate entry path %s: %s");
      return v16;
    }
    Device = BOMCopierSourceEntryGetDevice(a2);
    Inode = BOMCopierSourceEntryGetInode(a2);
    HardlinkCount = BOMCopierSourceEntryGetHardlinkCount(a2);
    Type = BOMCopierSourceEntryGetType(a2);
    if (Type == 8 && HardlinkCount >= 2)
    {
      v15 = BOMHardLinkTableGet(*(CFDictionaryRef **)(a1 + 72), Device, Inode);
      if (v15)
      {
        *(_QWORD *)bytes = *(_QWORD *)v15;
      }
      else
      {
        v18 = *(CFDictionaryRef **)(a1 + 72);
        *(_QWORD *)bytes = *(_QWORD *)(a1 + 64);
        BOMHardLinkTableSet(v18, Device, Inode, bytes, 8);
        ++*(_QWORD *)(a1 + 64);
      }
    }
    else
    {
      *(_QWORD *)bytes = *(_QWORD *)(a1 + 64);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)bytes + 1;
    }
    BOMCopierSourceEntryGetMode(a2);
    BOMCopierSourceEntryGetUserID(a2);
    BOMCopierSourceEntryGetGroupID(a2);
    v24 = 0uLL;
    if (BOMCopierSourceEntryGetAccessTime(a2, &v24))
    {
      v16 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4362, (uint64_t)"create_entry_libarchive", "Could not get source entry access time");
    }
    else
    {
      v23 = 0uLL;
      if (BOMCopierSourceEntryGetModificationTime(a2, &v23))
      {
        v16 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4372, (uint64_t)"create_entry_libarchive", "Could not get source entry modification time");
      }
      else
      {
        v22 = 0uLL;
        if (BOMCopierSourceEntryGetStatusTime(a2, &v22))
        {
          v16 = 1;
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4382, (uint64_t)"create_entry_libarchive", "Could not get source entry status time");
        }
        else
        {
          archive_entry_set_dev();
          archive_entry_set_nlink();
          archive_entry_set_ino64();
          archive_entry_set_perm();
          archive_entry_set_mode();
          archive_entry_set_uid();
          archive_entry_set_gid();
          archive_entry_set_size();
          archive_entry_set_atime();
          archive_entry_set_mtime();
          archive_entry_set_ctime();
          switch(Type)
          {
            case 4:
            case 6:
            case 10:
              archive_entry_set_filetype();
              break;
            case 8:
              archive_entry_set_filetype();
              a3[9] = *(_QWORD *)(a1 + 136);
              v19 = *(_QWORD *)(a1 + 152);
              if (v19 >= 1 && a3[7] >> 33)
              {
                a3[11] = v19;
                a3[12] = v19;
                archive_entry_set_size();
              }
              break;
            case 9:
              BOMCopierSourceEntryGetSymlinkTarget(a2);
              archive_entry_set_filetype();
              archive_entry_set_symlink();
              break;
            case 13:
            case 17:
            case 18:
            case 19:
              break;
            default:
              v16 = 1;
              BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4473, (uint64_t)"create_entry_libarchive", "Unknown source entry type: %d");
              goto LABEL_27;
          }
          if (!archive_write_header())
          {
            v16 = 0;
            a3[10] = v9;
            return v16;
          }
          archive_error_string();
          v16 = 1;
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4483, (uint64_t)"create_entry_libarchive", "Could not write archive entry: %s (%d)");
        }
      }
    }
LABEL_27:
    archive_entry_free();
  }
  else
  {
    v16 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4283, (uint64_t)"create_entry_libarchive", "Could not create empty archive entry");
  }
  return v16;
}

uint64_t create_entry_apple_archive(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  AAHeader v8;
  AAHeader_impl *v9;
  int Type;
  uint64_t v11;
  uint64_t v12;
  AAFieldKey v13;
  int v14;
  const char *Path;
  size_t v16;
  AAFieldKey v17;
  int v18;
  char *v20;
  const char *SymlinkTarget;
  const char *v22;
  size_t v23;
  AAFieldKey v24;
  int v25;
  int *v26;
  int Device;
  AAFieldKey v28;
  unsigned int UserID;
  AAFieldKey v30;
  int v31;
  unsigned int GroupID;
  AAFieldKey v33;
  int v34;
  __int16 Mode;
  AAFieldKey v36;
  int v37;
  unsigned int v38;
  AAFieldKey v39;
  int v40;
  int ModificationTime;
  AAFieldKey v42;
  int v43;
  uint64_t Inode;
  AAFieldKey v45;
  unsigned int HardlinkCount;
  AAFieldKey v47;
  int64_t v48;
  AAFieldKey v49;
  int v50;
  AAFieldKey v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  timespec value;

  v8 = AAHeaderCreate();
  if (!v8)
  {
    v12 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4511, (uint64_t)"create_entry_apple_archive", "Could not create AppleArchive header");
    return v12;
  }
  v9 = v8;
  Type = BOMCopierSourceEntryGetType(a2);
  if ((Type - 4) > 7)
    v11 = 63;
  else
    v11 = qword_2063CFCF0[Type - 4];
  v13.ikey = 5265748;
  v14 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v13, v11);
  if (v14)
  {
    BOMCopierErrorCapture(a4, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4553, (uint64_t)"populate_aa_header", "Could not set AppleArchive type");
LABEL_11:
    v12 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4518, (uint64_t)"create_entry_apple_archive", "Could not populate AppleArchive header");
    AAHeaderDestroy(v9);
    return v12;
  }
  Path = (const char *)BOMCopierSourceEntryGetPath(a2);
  v16 = strlen(Path);
  v17.ikey = 5521744;
  v18 = AAHeaderSetFieldString(v9, 0xFFFFFFFF, v17, Path, v16);
  if (v18)
  {
    BOMCopierErrorCapture(a4, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4561, (uint64_t)"populate_aa_header", "Could not set AppleArchive path");
    goto LABEL_11;
  }
  v20 = strdup(Path);
  *(_QWORD *)(a3 + 120) = v20;
  if (!v20)
  {
    v26 = __error();
    strerror(*v26);
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4568, (uint64_t)"populate_aa_header", "Could not duplicate entry path %s: %s");
    goto LABEL_11;
  }
  if (Type == 9)
  {
    SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget(a2);
    if (!SymlinkTarget)
    {
      BOMCopierErrorCapture(a4, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4577, (uint64_t)"populate_aa_header", "Could not set AppleArchive size");
      goto LABEL_11;
    }
    v22 = SymlinkTarget;
    v23 = strlen(SymlinkTarget);
    v24.ikey = 4935244;
    v25 = AAHeaderSetFieldString(v9, 0xFFFFFFFF, v24, v22, v23);
    if (v25)
    {
      BOMCopierErrorCapture(a4, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4587, (uint64_t)"populate_aa_header", "Could not set AppleArchive symlink path");
      goto LABEL_11;
    }
  }
  else if ((Type & 0xFFFFFFFD) == 5)
  {
    Device = BOMCopierSourceEntryGetDevice(a2);
    v28.ikey = 5653828;
    AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v28, Device);
  }
  UserID = BOMCopierSourceEntryGetUserID(a2);
  v30.ikey = 4475221;
  v31 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v30, UserID);
  if (v31)
  {
    BOMCopierErrorCapture(a4, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4608, (uint64_t)"populate_aa_header", "Could not set AppleArchive uid");
    goto LABEL_11;
  }
  GroupID = BOMCopierSourceEntryGetGroupID(a2);
  v33.ikey = 4475207;
  v34 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v33, GroupID);
  if (v34)
  {
    BOMCopierErrorCapture(a4, v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4616, (uint64_t)"populate_aa_header", "Could not set AppleArchive gid");
    goto LABEL_11;
  }
  Mode = BOMCopierSourceEntryGetMode(a2);
  v36.ikey = 4476749;
  v37 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v36, Mode & 0xFFF);
  if (v37)
  {
    BOMCopierErrorCapture(a4, v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4624, (uint64_t)"populate_aa_header", "Could not set AppleArchive mode");
    goto LABEL_11;
  }
  v38 = BOMCopierSourceEntryGetMode(a2);
  v39.ikey = 4672582;
  v40 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v39, v38);
  if (v40)
  {
    BOMCopierErrorCapture(a4, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4632, (uint64_t)"populate_aa_header", "Could not set AppleArchive mode");
    goto LABEL_11;
  }
  value.tv_sec = 0;
  value.tv_nsec = 0;
  ModificationTime = BOMCopierSourceEntryGetModificationTime(a2, &value);
  if (ModificationTime)
  {
    BOMCopierErrorCapture(a4, ModificationTime, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4640, (uint64_t)"populate_aa_header", "Could not retrieve modification time");
    goto LABEL_11;
  }
  v42.ikey = 5067853;
  v43 = AAHeaderSetFieldTimespec(v9, 0xFFFFFFFF, v42, &value);
  if (v43)
  {
    BOMCopierErrorCapture(a4, v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4647, (uint64_t)"populate_aa_header", "Could not set AppleArchive modification time");
    goto LABEL_11;
  }
  Inode = BOMCopierSourceEntryGetInode(a2);
  v45.ikey = 5197385;
  AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v45, Inode);
  HardlinkCount = BOMCopierSourceEntryGetHardlinkCount(a2);
  v47.ikey = 4934734;
  AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v47, HardlinkCount);
  if (Type == 8)
  {
    v48 = *(_QWORD *)(a3 + 56);
    v49.ikey = 5917011;
    v50 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v49, v48);
    if (v50)
    {
      BOMCopierErrorCapture(a4, v50, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4689, (uint64_t)"populate_aa_header", "Could not set AppleArchive size");
      goto LABEL_11;
    }
    if (v48 >= 1)
    {
      v51.ikey = 5521732;
      v52 = AAHeaderSetFieldBlob(v9, 0xFFFFFFFF, v51, v48);
      if (v52)
      {
        BOMCopierErrorCapture(a4, v52, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4698, (uint64_t)"populate_aa_header", "Could not append AA_FIELD_DAT to AppleArchive header: %d");
        goto LABEL_11;
      }
    }
  }
  v55 = 0;
  if (BOMCopierSourceEntryGetACL(a2, &v55, a4))
  {
    v53 = populate_aa_header_acl(a2, a3, v9, a4);
    if (v53)
    {
      BOMCopierErrorCapture(a4, v53, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4711, (uint64_t)"populate_aa_header", "Could not encode ACL");
      goto LABEL_11;
    }
  }
  if (BOMCopierSourceEntryGetExtendedAttributeCount(a2, a4))
  {
    v54 = populate_aa_header_xattr(a2, a3, v9, a4);
    if (v54)
    {
      BOMCopierErrorCapture(a4, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4722, (uint64_t)"populate_aa_header", "Could not encode extended attributes");
      goto LABEL_11;
    }
  }
  v12 = AAArchiveStreamWriteHeader(*(AAArchiveStream *)(a1 + 184), v9);
  AAHeaderDestroy(v9);
  if ((_DWORD)v12)
  {
    v12 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4529, (uint64_t)"create_entry_apple_archive", "Could not write AppleArchive header");
  }
  else
  {
    *(_DWORD *)(a3 + 328) = 5521732;
    *(_QWORD *)(a3 + 336) = *(_QWORD *)(a1 + 184);
  }
  return v12;
}

uint64_t BOMCopierDestinationFinalizeEntry(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  void (*v6)(_QWORD *, uint64_t, _QWORD *, uint64_t, uint64_t);
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  int Type;
  int v18;
  int v19;
  char *Path;
  uint64_t FSObjectAtPath;
  uint64_t v23;
  int v24;
  int v25;

  if (!a1)
  {
    v11 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1786, (uint64_t)"BOMCopierDestinationFinalizeEntry", "copier_destination is NULL");
    return v11;
  }
  if (!a2)
  {
    v11 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1792, (uint64_t)"BOMCopierDestinationFinalizeEntry", "destination_entry is NULL");
    return v11;
  }
  v5 = (uint64_t)a1;
  if (!*((_BYTE *)a2 + 16))
  {
    v13 = a1[12];
    v14 = a2[3];
    Type = BOMCopierSourceEntryGetType(a2[1]);
    if (Type == 8 && v14 != 0 && v13 != 0)
    {
      if (BOMCopierDataAnalyzerFinalize((uint64_t *)a2[3], a3))
      {
        v11 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1842, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not finalize data analyzer");
        return v11;
      }
      v25 = 0;
      if (BOMCopierDataAnalyzerGetDigest(a2[3], 2, (uint64_t)&v25, a3))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1851, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not retrieve CRC32 from data analyzer");
        return 1;
      }
      BOMCopierDataAnalyzerReset((uint64_t *)a2[3]);
      Path = (char *)BOMCopierSourceEntryGetPath(a2[1]);
      FSObjectAtPath = BOMBomGetFSObjectAtPath(*(_QWORD *)(v5 + 96), Path);
      if (!FSObjectAtPath)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1866, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not lookup %s in checksum bom");
        return 1;
      }
      v23 = FSObjectAtPath;
      v24 = BOMFSObjectChecksum(FSObjectAtPath);
      BOMFSObjectFree(v23);
      if (v24 != v25)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1876, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Checksum mismatch for %s: %d vs %d", Path);
        return 1;
      }
    }
    if (*((_DWORD *)a2 + 8) != 2)
    {
      v18 = *(_DWORD *)(v5 + 44);
      if (v18 == 2)
      {
        if (finalize_entry_apple_archive((uint64_t)a2, a3))
        {
          v11 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1908, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not finalize AppleArchive entry");
          return v11;
        }
      }
      else if (!v18)
      {
        finalize_entry_filesystem(v5, (uint64_t)a2, a3);
        if (v19)
        {
          v11 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1898, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not finalize filesystem entry");
          return v11;
        }
      }
    }
    if (Type == 17)
      goto LABEL_7;
    v6 = *(void (**)(_QWORD *, uint64_t, _QWORD *, uint64_t, uint64_t))(v5 + 264);
    if (!v6)
      goto LABEL_7;
    v10 = *(unsigned int *)(v5 + 244);
    v7 = a2[1];
    v8 = *(_QWORD *)(v5 + 272);
    a1 = (_QWORD *)v5;
    v9 = a2;
    goto LABEL_6;
  }
  v6 = (void (*)(_QWORD *, uint64_t, _QWORD *, uint64_t, uint64_t))a1[33];
  if (v6)
  {
    v7 = a2[1];
    v8 = a1[34];
    v9 = a2;
    v10 = 1;
LABEL_6:
    v6(a1, v7, v9, v10, v8);
  }
LABEL_7:
  BOMCopierDestinationEntryFree(a2);
  return 0;
}

void finalize_entry_filesystem(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  unsigned int Type;
  int v8;
  int v9;
  int *v10;
  const char *AppleDoubleTarget;
  int v12;
  int *v13;
  int v14;
  uint64_t SymlinkTarget;
  const char *v16;
  int v17;
  int *v18;
  int v19;
  __int16 v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  gid_t v31;
  int v32;
  uint64_t v33;
  int *v34;
  copyfile_flags_t v35;
  NSObject *v36;
  uint64_t v37;
  int v38;
  int *v39;
  int v40;
  uint64_t v41;
  int *v42;
  int ExtendedAttributeCount;
  int v44;
  unsigned int i;
  const char *ExtendedAttributeName;
  const char *v47;
  size_t ExtendedAttributeSize;
  size_t v49;
  void *v50;
  void *v51;
  NSObject *v52;
  __darwin_ino64_t v53;
  size_t v54;
  unsigned int v55;
  void *v56;
  int v57;
  int *v58;
  char *v59;
  NSObject *v60;
  uint64_t v61;
  const char *ACL;
  acl_t v63;
  _acl *v64;
  const char *v65;
  int v66;
  int v67;
  int v68;
  int *v69;
  int v70;
  int *v71;
  int v72;
  int *v73;
  void *v74;
  unsigned int v75;
  int v76;
  int v77;
  ssize_t v78;
  int v79;
  int *v80;
  NSObject *v81;
  uint64_t v82;
  int v83;
  int *v84;
  int *v85;
  acl_t file;
  _acl *v87;
  _acl *v88;
  _acl *v89;
  int v90;
  int v91;
  int *v92;
  NSObject *v93;
  uint64_t v94;
  const void *v95;
  int v96;
  int *v97;
  unsigned int Flags;
  unsigned int v100;
  int v101;
  int *v102;
  uid_t v103;
  unsigned int v104;
  __uint32_t v105;
  NSObject *v106;
  uint64_t v107;
  int v108;
  int v109;
  uint64_t UserID;
  gid_t GroupID;
  int Mode;
  _BOOL4 v114;
  unsigned __int16 v115;
  unsigned __int16 v116;
  NSObject *v117;
  uint64_t v118;
  const char *v119;
  const char *v120;
  const char *v121;
  int v122;
  uint64_t v123;
  int *v124;
  int v125;
  uint64_t v126;
  int *v127;
  NSObject *v128;
  uint64_t v129;
  int v130;
  int *v131;
  int v132;
  int *v133;
  int v134;
  int *v135;
  int v136;
  const char *v137;
  off_t st_size;
  int *v139;
  char *v140;
  int v141;
  uint64_t v142;
  uint64_t st_flags;
  int *v144;
  int v145;
  int *v146;
  int v147;
  int v148;
  int *v149;
  int v150;
  int *v151;
  int v152;
  int v153;
  uint64_t v154;
  int *v155;
  int v156;
  uint64_t v157;
  int *v158;
  int v159;
  uint64_t v160;
  int *v161;
  int v162;
  uint64_t v163;
  int *v164;
  int v165;
  uint64_t v166;
  int *v167;
  int v168;
  uint64_t v169;
  int *v170;
  NSObject *v172;
  uint64_t v173;
  unsigned int v174;
  char *to;
  _BYTE buf[24];
  char *v177;
  char __bp[32];
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  _BYTE v191[31];
  stat v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  _BYTE v198[31];
  uint64_t v199;

  v199 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a2 + 154))
  {
    apply_retention_policy(a1, a2, a3);
    return;
  }
  v6 = *(_QWORD *)(a2 + 8);
  Type = BOMCopierSourceEntryGetType(v6);
  switch(Type)
  {
    case 8u:
      v8 = *(_DWORD *)(a2 + 64);
      if (v8 == -1)
        goto LABEL_51;
      if (!*(_QWORD *)(a2 + 160))
        goto LABEL_48;
      if (!ParallelCompressionAFSCStreamClose())
      {
        *(_QWORD *)(a2 + 160) = 0;
        v8 = *(_DWORD *)(a2 + 64);
LABEL_48:
        if (*(_DWORD *)(a2 + 68) != v8)
        {
          close(*(_DWORD *)(a2 + 68));
          v8 = *(_DWORD *)(a2 + 64);
        }
        *(_DWORD *)(a2 + 68) = -1;
        close(v8);
        *(_DWORD *)(a2 + 64) = -1;
        goto LABEL_51;
      }
      v9 = *__error();
      v10 = __error();
      strerror(*v10);
      BOMCopierErrorCapture(a3, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5163, (uint64_t)"finalize_entry_filesystem", "Could not close AFSC stream for %s: %s");
      return;
    case 0x10u:
      memset(&v192, 0, sizeof(v192));
      if (lstat(*(const char **)(a2 + 120), &v192))
      {
        v14 = *__error();
        BOMCopierErrorCapture(a3, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5191, (uint64_t)"finalize_entry_filesystem", "Missing symlink target for %s");
        return;
      }
      if ((v192.st_mode & 0xF000) != 0x8000)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5197, (uint64_t)"finalize_entry_filesystem", "%s is not a regular file");
        return;
      }
      if (v192.st_size >= 1025)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5203, (uint64_t)"finalize_entry_filesystem", "%s is too large (%luu) to hold a symlink target");
        return;
      }
      v74 = malloc_type_calloc(1uLL, v192.st_size + 1, 0xE4FAC41FuLL);
      if (!v74)
      {
        v130 = *__error();
        v131 = __error();
        strerror(*v131);
        BOMCopierErrorCapture(a3, v130, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5212, (uint64_t)"finalize_entry_filesystem", "Could not allocate target buffer %lu: %s");
        return;
      }
      v56 = v74;
      v75 = Type;
      v76 = open(*(const char **)(a2 + 120), 0);
      if (v76 == -1)
      {
        v134 = *__error();
        v135 = __error();
        strerror(*v135);
        BOMCopierErrorCapture(a3, v134, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5219, (uint64_t)"finalize_entry_filesystem", "Could not open %s: %s");
        goto LABEL_68;
      }
      v77 = v76;
      v78 = read(v76, v56, v192.st_size);
      if (v78 != v192.st_size)
      {
        v136 = *__error();
        v137 = *(const char **)(a2 + 120);
        st_size = v192.st_size;
        v139 = __error();
        v140 = strerror(*v139);
        BOMCopierErrorCapture(a3, v136, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5227, (uint64_t)"finalize_entry_filesystem", "Could not read %s %lu: %s", v137, st_size, v140);
        close(v77);
        goto LABEL_68;
      }
      close(v77);
      if (unlink(*(const char **)(a2 + 120)))
      {
        v79 = *__error();
        v80 = __error();
        strerror(*v80);
        BOMCopierErrorCapture(a3, v79, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5238, (uint64_t)"finalize_entry_filesystem", "Could not unlink %s: %s");
        goto LABEL_68;
      }
      if (symlink((const char *)v56, *(const char **)(a2 + 120)))
      {
        v153 = *__error();
        v154 = *(_QWORD *)(a2 + 120);
        v155 = __error();
        strerror(*v155);
        BOMCopierErrorCapture(a3, v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5246, (uint64_t)"finalize_entry_filesystem", "Could not symlink %s to %s: %s", v154);
        goto LABEL_68;
      }
      v172 = *(NSObject **)a1;
      if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        v173 = *(_QWORD *)(a2 + 120);
        *(_DWORD *)__bp = 136315394;
        *(_QWORD *)&__bp[4] = v173;
        *(_WORD *)&__bp[12] = 2080;
        *(_QWORD *)&__bp[14] = v56;
        _os_log_impl(&dword_206367000, v172, OS_LOG_TYPE_DEFAULT, "Transmogrified symlink: %s to %s", (uint8_t *)__bp, 0x16u);
      }
      free(v56);
      Type = v75;
      goto LABEL_51;
    case 0x11u:
      AppleDoubleTarget = (const char *)BOMCopierSourceEntryGetAppleDoubleTarget(v6);
      to = 0;
      asprintf(&to, "%s/%s", *(const char **)(a2 + 136), AppleDoubleTarget);
      if (!to)
      {
        v26 = *__error();
        v27 = *(_QWORD *)(a2 + 136);
        v28 = __error();
        strerror(*v28);
        BOMCopierErrorCapture(a3, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5297, (uint64_t)"finalize_entry_filesystem", "Could not construct target path for %s and %s: %s", v27);
        return;
      }
      memset(&v192, 0, sizeof(v192));
      if (lstat(to, &v192))
      {
        v12 = *__error();
        v13 = __error();
        strerror(*v13);
        BOMCopierErrorCapture(a3, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5305, (uint64_t)"finalize_entry_filesystem", "Could not lstat %s: %s");
        return;
      }
      if (*(_BYTE *)(a1 + 160))
        v35 = 9175045;
      else
        v35 = 9175044;
      if (copyfile(*(const char **)(a2 + 120), to, 0, v35) < 0)
      {
        if (*__error() != 45)
        {
          v125 = *__error();
          v126 = *(_QWORD *)(a2 + 120);
          v127 = __error();
          strerror(*v127);
          BOMCopierErrorCapture(a3, v125, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5386, (uint64_t)"finalize_entry_filesystem", "Could not merge %s to %s: %s", v126);
          goto LABEL_179;
        }
        free(to);
        v81 = *(NSObject **)a1;
        if (v81 && os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          v82 = *(_QWORD *)(a2 + 120);
          *(_DWORD *)__bp = 136315138;
          *(_QWORD *)&__bp[4] = v82;
          _os_log_impl(&dword_206367000, v81, OS_LOG_TYPE_DEFAULT, "AppleDouble merge not supported on this filesystem. Unlinking %s", (uint8_t *)__bp, 0xCu);
        }
        if (unlink(*(const char **)(a2 + 120)))
        {
          v83 = *__error();
          v84 = __error();
          strerror(*v84);
          BOMCopierErrorCapture(a3, v83, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5379, (uint64_t)"finalize_entry_filesystem", "Could not unlink %s: %s");
        }
      }
      else
      {
        v36 = *(NSObject **)a1;
        if (v36 && os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          v37 = *(_QWORD *)(a2 + 120);
          *(_DWORD *)__bp = 136315394;
          *(_QWORD *)&__bp[4] = v37;
          *(_WORD *)&__bp[12] = 2080;
          *(_QWORD *)&__bp[14] = to;
          _os_log_impl(&dword_206367000, v36, OS_LOG_TYPE_DEFAULT, "Merged AppleDouble %s to %s", (uint8_t *)__bp, 0x16u);
        }
        if (unlink(*(const char **)(a2 + 120)))
        {
          v38 = *__error();
          v39 = __error();
          strerror(*v39);
          BOMCopierErrorCapture(a3, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5397, (uint64_t)"finalize_entry_filesystem", "Could not unlink %s: %s");
LABEL_179:
          v59 = to;
          goto LABEL_180;
        }
        file = acl_get_file(to, ACL_TYPE_EXTENDED);
        if (file)
        {
          v87 = file;
          v88 = acl_init(0);
          if (!v88)
          {
            v145 = *__error();
            v146 = __error();
            strerror(*v146);
            BOMCopierErrorCapture(a3, v145, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5426, (uint64_t)"finalize_entry_filesystem", "Could not create empty ACL for %s: %s");
            goto LABEL_179;
          }
          v89 = v88;
          v90 = acl_set_file(to, ACL_TYPE_EXTENDED, v88);
          free(v89);
          if (v90)
          {
            v91 = *__error();
            v92 = __error();
            strerror(*v92);
            BOMCopierErrorCapture(a3, v91, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5437, (uint64_t)"finalize_entry_filesystem", "Could not remove saved ACL from %s: %s");
            goto LABEL_179;
          }
          v147 = acl_set_file(to, ACL_TYPE_EXTENDED, v87);
          acl_free(v87);
          if (v147)
          {
            v148 = *__error();
            v149 = __error();
            strerror(*v149);
            BOMCopierErrorCapture(a3, v148, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5477, (uint64_t)"finalize_entry_filesystem", "Could not re-apply saved ACL to %s: %s");
            goto LABEL_179;
          }
        }
        *(_QWORD *)&buf[16] = 0;
        *(_OWORD *)buf = xmmword_2063CFCA8;
        *(timespec *)__bp = v192.st_mtimespec;
        *(timespec *)&__bp[16] = v192.st_atimespec;
        if (setattrlist(to, buf, __bp, 0x20uLL, 1u) && *__error() != 13)
        {
          v150 = *__error();
          v151 = __error();
          strerror(*v151);
          BOMCopierErrorCapture(a3, v150, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5513, (uint64_t)"finalize_entry_filesystem", "Could not setattrlist timestamps for %s: %s");
        }
        else
        {
          free(to);
        }
      }
      return;
    case 0x12u:
      SymlinkTarget = BOMCopierSourceEntryGetSymlinkTarget(*(_QWORD *)(a2 + 8));
      if (!SymlinkTarget)
      {
        v29 = *__error();
        BOMCopierErrorCapture(a3, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5265, (uint64_t)"finalize_entry_filesystem", "Missing symlink target for %s");
        return;
      }
      v16 = (const char *)SymlinkTarget;
      if (unlink(*(const char **)(a2 + 120)))
      {
        v17 = *__error();
        v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture(a3, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5272, (uint64_t)"finalize_entry_filesystem", "Could not unlink placeholder at %s: %s");
        return;
      }
      if (symlink(v16, *(const char **)(a2 + 120)))
      {
        v40 = *__error();
        v41 = *(_QWORD *)(a2 + 120);
        v42 = __error();
        strerror(*v42);
        BOMCopierErrorCapture(a3, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5279, (uint64_t)"finalize_entry_filesystem", "Could not symlink %s to %s: %s", v41);
        return;
      }
LABEL_51:
      v174 = Type;
      ExtendedAttributeCount = BOMCopierSourceEntryGetExtendedAttributeCount(v6, a3);
      if (!ExtendedAttributeCount)
        goto LABEL_65;
      v44 = ExtendedAttributeCount;
      for (i = 0; i != v44; ++i)
      {
        ExtendedAttributeName = (const char *)BOMCopierSourceEntryGetExtendedAttributeName(v6, i, a3);
        if (!ExtendedAttributeName)
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5653, (uint64_t)"finalize_entry_filesystem", "Could not get xattr name for index %d");
          return;
        }
        v47 = ExtendedAttributeName;
        if (strcmp(ExtendedAttributeName, "com.apple.ResourceFork") || !*(_BYTE *)(a2 + 155))
        {
          ExtendedAttributeSize = BOMCopierSourceEntryGetExtendedAttributeSize(v6, i, a3);
          if (!ExtendedAttributeSize)
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5680, (uint64_t)"finalize_entry_filesystem", "Could not get xattr size for index %d: %s");
            return;
          }
          v49 = ExtendedAttributeSize;
          v50 = malloc_type_malloc(ExtendedAttributeSize, 0x10E06445uLL);
          if (!v50)
          {
            v69 = __error();
            strerror(*v69);
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5687, (uint64_t)"finalize_entry_filesystem", "Could not allocate buffer for value: %s\n");
            return;
          }
          v51 = v50;
          if (BOMCopierSourceEntryCopyExtendedAttribute(v6, i, v50, v49, 0, a3) != v49)
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5694, (uint64_t)"finalize_entry_filesystem", "Could not copy attribute value for index %d: %s\n");
            return;
          }
          if (setxattr(*(const char **)(a2 + 144), v47, v51, v49, 0, 1))
          {
            v70 = *__error();
            v71 = __error();
            strerror(*v71);
            BOMCopierErrorCapture(a3, v70, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5701, (uint64_t)"finalize_entry_filesystem", "Could not set xattr %s on %s: %s", v47);
            return;
          }
          v52 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v53 = *(_QWORD *)(a2 + 120);
            v192.st_dev = 136315394;
            *(_QWORD *)&v192.st_mode = v47;
            WORD2(v192.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v192.st_ino + 6) = v53;
            _os_log_impl(&dword_206367000, v52, OS_LOG_TYPE_DEFAULT, "Applied xattr %s to %s", (uint8_t *)&v192, 0x16u);
          }
          free(v51);
        }
      }
LABEL_65:
      v54 = *(_QWORD *)(a2 + 312);
      v55 = v174;
      if (!v54)
        goto LABEL_73;
      v56 = *(void **)(a2 + 320);
      if (!setxattr(*(const char **)(a2 + 144), "com.apple.rootless", v56, v54, 0, 1))
      {
        v60 = *(NSObject **)a1;
        if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
        {
          v61 = *(_QWORD *)(a2 + 120);
          v192.st_dev = 136315138;
          *(_QWORD *)&v192.st_mode = v61;
          _os_log_impl(&dword_206367000, v60, OS_LOG_TYPE_DEFAULT, "Applied xattr com.apple.rootless to %s", (uint8_t *)&v192, 0xCu);
        }
LABEL_73:
        to = 0;
        ACL = (const char *)BOMCopierSourceEntryGetACL(v6, &to, a3);
        if (ACL && to)
        {
          v63 = acl_from_text(ACL);
          if (!v63)
          {
            v72 = *__error();
            v73 = __error();
            strerror(*v73);
            BOMCopierErrorCapture(a3, v72, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5754, (uint64_t)"finalize_entry_filesystem", "Could not create ACL from text [%s]: %s");
            return;
          }
          v64 = v63;
          v65 = *(const char **)(a2 + 144);
          if (v174 == 9)
          {
            v66 = open(v65, 0x200000);
            if (v66 == -1)
            {
              v132 = *__error();
              v133 = __error();
              strerror(*v133);
              BOMCopierErrorCapture(a3, v132, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5767, (uint64_t)"finalize_entry_filesystem", "Unable to open the symlink %s: %s\n");
              return;
            }
            v67 = v66;
            v68 = acl_set_fd_np(v66, v64, ACL_TYPE_EXTENDED);
            close(v67);
            v55 = v174;
          }
          else
          {
            v68 = acl_set_file(v65, ACL_TYPE_EXTENDED, v64);
          }
          acl_free(v64);
          if (v68)
          {
            v85 = __error();
            strerror(*v85);
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5782, (uint64_t)"finalize_entry_filesystem", "Could not set ACL on %s: %s");
            return;
          }
          v93 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v94 = *(_QWORD *)(a2 + 144);
            v192.st_dev = 136315138;
            *(_QWORD *)&v192.st_mode = v94;
            _os_log_impl(&dword_206367000, v93, OS_LOG_TYPE_DEFAULT, "Applied ACL to %s", (uint8_t *)&v192, 0xCu);
          }
        }
        if (v55 == 8)
        {
          v95 = *(const void **)(a1 + 24);
          if (v95)
          {
            if (setxattr(*(const char **)(a2 + 144), "com.apple.provenance", v95, *(_QWORD *)(a1 + 32), 0, 1))
            {
              v96 = *__error();
              v97 = __error();
              strerror(*v97);
              BOMCopierErrorCapture(a3, v96, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5807, (uint64_t)"finalize_entry_filesystem", "Could not set provenance xattr %s: %s");
              return;
            }
            v128 = *(NSObject **)a1;
            if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              v129 = *(_QWORD *)(a2 + 120);
              v192.st_dev = 136315138;
              *(_QWORD *)&v192.st_mode = v129;
              _os_log_impl(&dword_206367000, v128, OS_LOG_TYPE_DEFAULT, "Applied xattr com.apple.provenance to %s", (uint8_t *)&v192, 0xCu);
            }
          }
        }
        else if (v55 != 6)
        {
          goto LABEL_141;
        }
        Flags = BOMCopierSourceEntryGetFlags(v6);
        if ((Flags & 0x80000) != 0 && *(_BYTE *)(a1 + 302) == 0)
          v100 = Flags & 0xFFF7FFFF;
        else
          v100 = Flags;
        if (*(_BYTE *)(a2 + 153) && *(_BYTE *)(a1 + 303))
          v100 |= *(_DWORD *)(a2 + 284) & 0x80000;
        memset(&v192, 0, sizeof(v192));
        if (lstat(*(const char **)(a2 + 144), &v192))
        {
          v101 = *__error();
          v102 = __error();
          strerror(*v102);
          BOMCopierErrorCapture(a3, v101, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5862, (uint64_t)"finalize_entry_filesystem", "Could not lstat %s: %s\n");
          return;
        }
        if (BOMCopierSourceEntryIsCompressed(v6) && !*(_BYTE *)(a1 + 113))
          v100 &= ~0x20u;
        if (*(_BYTE *)(a1 + 112) && (v192.st_flags & 0x40000020) == 0x20)
          v100 |= 0x20u;
        v103 = geteuid();
        v104 = v100 & 0xC000FFFF;
        if (!v103)
          v104 = v100;
        if ((~v104 & 0x40000020) != 0)
          v105 = v104;
        else
          v105 = v104 & 0xBFFFFFDF;
        if (v105)
        {
          if (change_flags(*(const char **)(a2 + 144), v192.st_flags, v105) && *__error() != 45)
          {
            v141 = *__error();
            v142 = *(_QWORD *)(a2 + 144);
            st_flags = v192.st_flags;
            v144 = __error();
            strerror(*v144);
            BOMCopierErrorCapture(a3, v141, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5925, (uint64_t)"finalize_entry_filesystem", "Could not change file flags on %s from %u to %u: %s. Calling error handler", v142, st_flags);
            return;
          }
          v106 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v107 = *(_QWORD *)(a2 + 120);
            *(_DWORD *)__bp = 136315650;
            *(_QWORD *)&__bp[4] = v107;
            *(_WORD *)&__bp[12] = 1024;
            *(_DWORD *)&__bp[14] = v192.st_flags;
            *(_WORD *)&__bp[18] = 1024;
            *(_DWORD *)&__bp[20] = v105;
            _os_log_impl(&dword_206367000, v106, OS_LOG_TYPE_DEFAULT, "Changed file flags on %s from %u to %u", (uint8_t *)__bp, 0x18u);
          }
        }
LABEL_141:
        apply_retention_policy(a1, a2, a3);
        if (v108)
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5943, (uint64_t)"finalize_entry_filesystem", "Could not apply retention policy");
          return;
        }
        v109 = *(_DWORD *)(a1 + 8);
        UserID = BOMCopierSourceEntryGetUserID(v6);
        GroupID = BOMCopierSourceEntryGetGroupID(v6);
        Mode = BOMCopierSourceEntryGetMode(v6);
        if (*(_DWORD *)(a1 + 8) || *(_BYTE *)(a1 + 305))
        {
          v114 = v174 == 8 && *(_BYTE *)(a1 + 306) != 0;
        }
        else
        {
          if (*(_BYTE *)(a1 + 20))
            v152 = BOMCopierSourceEntryGetHonorsSetuid(v6) ^ 1;
          else
            v152 = 0;
          v114 = v174 == 8 && *(_BYTE *)(a1 + 306) != 0;
          if ((v152 & 1) == 0 && !v114)
          {
LABEL_160:
            v119 = "symlink";
            v120 = "post-order directory";
            switch(v174)
            {
              case 6u:
                v120 = "directory";
                goto LABEL_192;
              case 8u:
              case 0xFu:
                if (v174 == 15)
                  v121 = "extra regular file";
                else
                  v121 = "regular file";
                if (v109 || !chown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  if (!chmod(*(const char **)(a2 + 120), Mode))
                    goto LABEL_203;
                  v197 = 0u;
                  memset(v198, 0, sizeof(v198));
                  v195 = 0u;
                  v196 = 0u;
                  v193 = 0u;
                  v194 = 0u;
                  memset(&v192, 0, sizeof(v192));
                  strmode((unsigned __int16)Mode, (char *)&v192);
                  v122 = *__error();
                  v123 = *(_QWORD *)(a2 + 120);
                  v124 = __error();
                  strerror(*v124);
                  BOMCopierErrorCapture(a3, v122, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6131, (uint64_t)"finalize_entry_filesystem", "Could not chmod %s %s to %s: %s", v121, v123);
                }
                else
                {
                  v168 = *__error();
                  v169 = *(_QWORD *)(a2 + 120);
                  v170 = __error();
                  strerror(*v170);
                  BOMCopierErrorCapture(a3, v168, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6119, (uint64_t)"finalize_entry_filesystem", "Could not chown %s to %d:%d: %s", v169, UserID);
                }
                return;
              case 9u:
              case 0x10u:
                goto LABEL_200;
              case 0xDu:
                goto LABEL_192;
              case 0xEu:
                v120 = "extra directory";
LABEL_192:
                if (!v109 && chown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  v159 = *__error();
                  v160 = *(_QWORD *)(a2 + 120);
                  v161 = __error();
                  strerror(*v161);
                  BOMCopierErrorCapture(a3, v159, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6067, (uint64_t)"finalize_entry_filesystem", "Could not chown %s to %d:%d: %s", v160, UserID);
                  return;
                }
                if ((!*(_BYTE *)(a2 + 153) || *(_BYTE *)(a1 + 43)) && chmod(*(const char **)(a2 + 120), Mode))
                {
                  v197 = 0u;
                  memset(v198, 0, sizeof(v198));
                  v195 = 0u;
                  v196 = 0u;
                  v193 = 0u;
                  v194 = 0u;
                  memset(&v192, 0, sizeof(v192));
                  strmode((unsigned __int16)Mode, (char *)&v192);
                  v156 = *__error();
                  v157 = *(_QWORD *)(a2 + 120);
                  v158 = __error();
                  strerror(*v158);
                  BOMCopierErrorCapture(a3, v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6097, (uint64_t)"finalize_entry_filesystem", "Could not chmod %s %s to %s: %s", v120, v157);
                  return;
                }
                goto LABEL_203;
              case 0x12u:
                v119 = "replay symlink";
LABEL_200:
                if (v109 || !lchown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  if (lchmod(*(const char **)(a2 + 120), Mode))
                  {
                    v197 = 0u;
                    memset(v198, 0, sizeof(v198));
                    v195 = 0u;
                    v196 = 0u;
                    v193 = 0u;
                    v194 = 0u;
                    memset(&v192, 0, sizeof(v192));
                    strmode((unsigned __int16)Mode, (char *)&v192);
                    v162 = *__error();
                    v163 = *(_QWORD *)(a2 + 120);
                    v164 = __error();
                    strerror(*v164);
                    BOMCopierErrorCapture(a3, v162, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6168, (uint64_t)"finalize_entry_filesystem", "Could not lchmod %s %s to %s: %s", v119, v163);
                  }
                  else
                  {
LABEL_203:
                    if (set_timestamps(v6, a2, *(NSObject **)a1, a3))
                      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6191, (uint64_t)"finalize_entry_filesystem", "Could not set timestamps on destination entry");
                  }
                }
                else
                {
                  v165 = *__error();
                  v166 = *(_QWORD *)(a2 + 120);
                  v167 = __error();
                  strerror(*v167);
                  BOMCopierErrorCapture(a3, v165, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6156, (uint64_t)"finalize_entry_filesystem", "Could not lchown %s to %d:%d: %s", v166, UserID);
                }
                break;
              default:
                BOMCopierSourceEntryTypeString(v174);
                BOMCopierErrorCapture(a3, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6175, (uint64_t)"finalize_entry_filesystem", "Unsupported BOMCopierSourceEntryType: %s");
                return;
            }
            return;
          }
          v115 = Mode;
          if (!v152)
          {
LABEL_152:
            if (v114)
              v116 = v115 & 0xFFB6;
            else
              v116 = v115;
            if (Mode != v116)
            {
              v197 = 0u;
              memset(v198, 0, sizeof(v198));
              v195 = 0u;
              v196 = 0u;
              v193 = 0u;
              v194 = 0u;
              memset(&v192, 0, sizeof(v192));
              strmode(Mode, (char *)&v192);
              v190 = 0u;
              memset(v191, 0, sizeof(v191));
              v188 = 0u;
              v189 = 0u;
              v186 = 0u;
              v187 = 0u;
              v184 = 0u;
              v185 = 0u;
              v183 = 0u;
              v181 = 0u;
              v182 = 0u;
              v179 = 0u;
              v180 = 0u;
              memset(__bp, 0, sizeof(__bp));
              strmode(v116, __bp);
              v117 = *(NSObject **)a1;
              if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                v118 = *(_QWORD *)(a2 + 120);
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = v118;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = &v192;
                *(_WORD *)&buf[22] = 2080;
                v177 = __bp;
                _os_log_impl(&dword_206367000, v117, OS_LOG_TYPE_DEFAULT, "Filtering the mode for %s from %s to %s", buf, 0x20u);
              }
              LOWORD(Mode) = v116;
            }
            goto LABEL_160;
          }
        }
        v115 = Mode & 0xF1FF;
        goto LABEL_152;
      }
      v57 = *__error();
      v58 = __error();
      strerror(*v58);
      BOMCopierErrorCapture(a3, v57, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5723, (uint64_t)"finalize_entry_filesystem", "Could not set rootless xattr %s: %s");
LABEL_68:
      v59 = (char *)v56;
LABEL_180:
      free(v59);
      return;
    case 0x13u:
      if (*(_DWORD *)(a1 + 8)
        || (v30 = BOMCopierSourceEntryGetUserID(v6),
            v31 = BOMCopierSourceEntryGetGroupID(v6),
            !chown(*(const char **)(a2 + 120), v30, v31)))
      {
        v19 = BOMCopierSourceEntryGetMode(v6);
        if ((*(_DWORD *)(a1 + 8)
           || *(_BYTE *)(a1 + 305)
           || *(_BYTE *)(a1 + 20) && (BOMCopierSourceEntryGetHonorsSetuid(v6) & 1) == 0)
          && (v19 & 0xE00) != 0)
        {
          v20 = v19 & 0xF1FF;
          v197 = 0u;
          memset(v198, 0, sizeof(v198));
          v195 = 0u;
          v196 = 0u;
          v193 = 0u;
          v194 = 0u;
          memset(&v192, 0, sizeof(v192));
          strmode(v19, (char *)&v192);
          v190 = 0u;
          memset(v191, 0, sizeof(v191));
          v188 = 0u;
          v189 = 0u;
          v186 = 0u;
          v187 = 0u;
          v184 = 0u;
          v185 = 0u;
          v183 = 0u;
          v181 = 0u;
          v182 = 0u;
          v179 = 0u;
          v180 = 0u;
          memset(__bp, 0, sizeof(__bp));
          strmode(v19 & 0xF1FF, __bp);
          v21 = *(NSObject **)a1;
          if (*(_QWORD *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            v22 = *(_QWORD *)(a2 + 120);
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v22;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = &v192;
            *(_WORD *)&buf[22] = 2080;
            v177 = __bp;
            _os_log_impl(&dword_206367000, v21, OS_LOG_TYPE_DEFAULT, "Filtering the mode for %s from %s to %s", buf, 0x20u);
          }
          LOWORD(v19) = v20;
        }
        if (chmod(*(const char **)(a2 + 120), v19))
        {
          v197 = 0u;
          memset(v198, 0, sizeof(v198));
          v195 = 0u;
          v196 = 0u;
          v193 = 0u;
          v194 = 0u;
          memset(&v192, 0, sizeof(v192));
          strmode((unsigned __int16)v19, (char *)&v192);
          v23 = *__error();
          v24 = *(_QWORD *)(a2 + 120);
          v25 = __error();
          strerror(*v25);
          BOMCopierErrorCapture(a3, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5612, (uint64_t)"finalize_entry_filesystem", "Could not chmod relay directory %s to %s: %s", v24);
        }
        else if (set_timestamps(v6, a2, *(NSObject **)a1, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5627, (uint64_t)"finalize_entry_filesystem", "Could not set timestamps on destination entry");
        }
      }
      else
      {
        v32 = *__error();
        v33 = *(_QWORD *)(a2 + 120);
        v34 = __error();
        strerror(*v34);
        BOMCopierErrorCapture(a3, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5545, (uint64_t)"finalize_entry_filesystem", "Could not chown %s to %d:%d: %s", v33, v30);
      }
      return;
    default:
      goto LABEL_51;
  }
}

uint64_t finalize_entry_apple_archive(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  int v7;
  int v8;

  v4 = *(char **)(a1 + 344);
  if (v4
    && (*(_DWORD *)(a1 + 328) = 4997953,
        BOMCopierDestinationEntryWrite(a1, v4, *(_QWORD *)(a1 + 352), a2) != *(_QWORD *)(a1 + 352)))
  {
    v7 = *__error();
    BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6220, (uint64_t)"finalize_entry_apple_archive", "Could not write encoded AppleArchive ACL buffer to the destination");
  }
  else
  {
    v5 = *(char **)(a1 + 360);
    if (!v5)
      return 0;
    *(_DWORD *)(a1 + 328) = 5521752;
    if (BOMCopierDestinationEntryWrite(a1, v5, *(_QWORD *)(a1 + 368), a2) == *(_QWORD *)(a1 + 368))
      return 0;
    v8 = *__error();
    BOMCopierErrorCapture(a2, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6240, (uint64_t)"finalize_entry_apple_archive", "Could not write encoded AppleArchive XAT buffer to the destination");
  }
  return 1;
}

uint64_t BOMCopierDestinationEntryGetMatchType(uint64_t a1, _QWORD *a2)
{
  if (a1)
    return *(unsigned int *)(a1 + 32);
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1943, (uint64_t)"BOMCopierDestinationEntryGetMatchType", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationEntryGetMatchRecordCount(uint64_t a1, _QWORD *a2)
{
  if (a1)
    return *(unsigned int *)(a1 + 36);
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1961, (uint64_t)"BOMCopierDestinationEntryGetMatchRecordCount", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationEntryGetMatchRecord(uint64_t a1, unsigned int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 36) <= a2)
    {
      BOMCopierErrorCapture(a4, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1987, (uint64_t)"BOMCopierDestinationEntryGetMatchRecord", "index %d is out of range", a2);
      return 22;
    }
    else if (a3)
    {
      v4 = 0;
      v5 = *(_QWORD *)(a1 + 40) + 40 * a2;
      v6 = *(_OWORD *)v5;
      v7 = *(_OWORD *)(v5 + 16);
      *(_QWORD *)(a3 + 32) = *(_QWORD *)(v5 + 32);
      *(_OWORD *)a3 = v6;
      *(_OWORD *)(a3 + 16) = v7;
    }
    else
    {
      v4 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1993, (uint64_t)"BOMCopierDestinationEntryGetMatchRecord", "match_record is NULL");
    }
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1981, (uint64_t)"BOMCopierDestinationEntryGetMatchRecord", "destination_entry is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationEntryWriteFatHeader(uint64_t a1, size_t *a2, _QWORD *a3)
{
  int BinaryType;
  uint64_t v7;
  int v9;
  unsigned int v10;
  size_t v11;
  char *v12;
  char *v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  _OWORD *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  int v21;
  uint64_t v22;
  int v23;
  int *v24;
  char *v25;
  _OWORD v26[2];
  int8x8_t v27;

  if (a1)
  {
    if (a2)
    {
      BinaryType = BOMCopierSourceEntryGetBinaryType(*(_QWORD *)(a1 + 8));
      if ((BinaryType - 5) > 0xFFFFFFFD)
      {
        v9 = BinaryType;
        v10 = 20;
        if (BinaryType == 4)
          v10 = 32;
        v11 = v10 * (unint64_t)*(unsigned int *)(a1 + 48) + 8;
        v12 = (char *)malloc_type_malloc(v11, 0x4AB16E04uLL);
        if (v12)
        {
          v13 = v12;
          if (v9 == 4)
            v14 = -889275713;
          else
            v14 = -889275714;
          v27 = (int8x8_t)__PAIR64__(*(_DWORD *)(a1 + 48), v14);
          BOMSwapFatHeader(&v27, 2);
          *(int8x8_t *)v13 = v27;
          if (*(_DWORD *)(a1 + 36))
          {
            v15 = 0;
            v16 = 0;
            v17 = v13 + 8;
            do
            {
              v18 = *(_QWORD *)(a1 + 40);
              if (*(_BYTE *)(v18 + v15))
              {
                v19 = v18 + v15;
                if (v9 == 4)
                {
                  memset(v26, 0, sizeof(v26));
                  *(_QWORD *)&v26[0] = *(_QWORD *)(v19 + 4);
                  *(_OWORD *)((char *)v26 + 8) = *(_OWORD *)(v19 + 16);
                  DWORD2(v26[1]) = *(_QWORD *)(v19 + 32);
                  BOMSwapFatArch64((uint64_t)v26, 1u, 2);
                  v20 = v26[1];
                  *v17 = v26[0];
                  v17[1] = v20;
                  v17 += 2;
                }
                else
                {
                  memset(v26, 0, 20);
                  *(_QWORD *)&v26[0] = *(_QWORD *)(v19 + 4);
                  *((int32x2_t *)&v26[0] + 1) = vmovn_s64(*(int64x2_t *)(v19 + 16));
                  LODWORD(v26[1]) = *(_QWORD *)(v19 + 32);
                  BOMSwapFatArch((uint64_t)v26, 1u, 2);
                  v21 = v26[1];
                  *v17 = v26[0];
                  *((_DWORD *)v17 + 4) = v21;
                  v17 = (_OWORD *)((char *)v17 + 20);
                }
              }
              ++v16;
              v15 += 40;
            }
            while (v16 < *(unsigned int *)(a1 + 36));
          }
          v22 = BOMCopierDestinationEntryWrite(a1, v13, v11, a3);
          free(v13);
          if (v22 == v11)
          {
            v7 = 0;
            *a2 = v11;
          }
          else
          {
            v7 = 1;
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2132, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "Could not write the fat header to the destination entry");
          }
        }
        else
        {
          v23 = *__error();
          v24 = __error();
          v25 = strerror(*v24);
          BOMCopierErrorCapture(a3, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2059, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "Could not allocate %ld bytes: %s", v11, v25);
          return 1;
        }
      }
      else
      {
        v7 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2027, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "source entry is not a fat file");
      }
    }
    else
    {
      v7 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2020, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "fat_header_size is NULL");
    }
  }
  else
  {
    v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2014, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "destination_entry is NULL");
  }
  return v7;
}

uint64_t BOMCopierDestinationEntryWrite(uint64_t a1, char *__buf, size_t nbyte, _QWORD *a4)
{
  uint64_t v8;
  char *v9;
  size_t v10;
  ssize_t v11;
  BOOL v12;
  AAFieldKey v13;
  uint64_t *v14;
  int *v15;

  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2159, (uint64_t)"BOMCopierDestinationEntryWrite", "destination_entry is NULL");
    return -1;
  }
  if (!__buf)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2165, (uint64_t)"BOMCopierDestinationEntryWrite", "buffer is NULL");
    return -1;
  }
  if (!nbyte)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2171, (uint64_t)"BOMCopierDestinationEntryWrite", "num_bytes is 0");
    return -1;
  }
  switch(*(_DWORD *)a1)
  {
    case 0:
      v8 = 0;
      v9 = __buf;
      break;
    case 1:
      if (*(_QWORD *)(a1 + 72))
      {
        v8 = write_data_libarchive((_QWORD *)a1, (uint64_t)__buf, nbyte, a4);
        goto LABEL_27;
      }
      v8 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2192, (uint64_t)"BOMCopierDestinationEntryWrite", "destination_entry->archive is NULL");
      return v8;
    case 2:
      v13 = *(AAFieldKey *)(a1 + 328);
      if (!AAArchiveStreamWriteBlob(*(AAArchiveStream *)(a1 + 336), v13, __buf, nbyte))
        goto LABEL_26;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6929, (uint64_t)"write_data_apple_archive", "Could not write to AppleArchive: %u");
      return -1;
    case 3:
LABEL_26:
      *(_QWORD *)(a1 + 112) += nbyte;
      v8 = nbyte;
LABEL_27:
      v14 = *(uint64_t **)(a1 + 24);
      if (!v14 || v8 < 1 || !BOMCopierDataAnalyzerUpdate(v14, __buf, v8, a4))
        return v8;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2221, (uint64_t)"BOMCopierDestinationEntryWrite", "Could not update data analyzer");
      return -1;
    default:
      return 0;
  }
  while (1)
  {
    v10 = nbyte - v8 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : nbyte - v8;
    if (*(_QWORD *)(a1 + 160))
      break;
    v11 = write(*(_DWORD *)(a1 + 68), v9, v10);
    if (v11 == -1)
    {
      v15 = __error();
      strerror(*v15);
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6747, (uint64_t)"write_data_filesystem", "Could not write %ld bytes: %s\n");
      return -1;
    }
LABEL_13:
    v9 += v11;
    v8 += v11;
    if (v11)
      v12 = v8 == nbyte;
    else
      v12 = 1;
    if (v12)
    {
      *(_QWORD *)(a1 + 112) += v8;
      goto LABEL_27;
    }
  }
  v11 = ParallelCompressionAFSCStreamWrite();
  if (v11 != -1)
    goto LABEL_13;
  v8 = -1;
  BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6739, (uint64_t)"write_data_filesystem", "Could not AFSC compress %ld bytes: %ld\n");
  return v8;
}

uint64_t write_data_libarchive(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  const char *v23;

  v8 = 0;
  while (1)
  {
    if ((unint64_t)(a3 - v8) >= 0x7FFFFFFF)
      v9 = 0x7FFFFFFFLL;
    else
      v9 = a3 - v8;
    if ((uint64_t)a1[11] >= 1)
    {
      v11 = a1[12];
      v10 = a1[13];
      v12 = v10 + v9;
      v13 = v11 - v10;
      if (v12 > v11)
        v9 = v13;
    }
    v14 = archive_write_data();
    if (!v14)
    {
LABEL_18:
      a1[14] += v8;
      return v8;
    }
    v15 = v14;
    if (v14 == -1)
    {
      v21 = (const char *)archive_error_string();
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6842, (uint64_t)"write_data_libarchive", "Could not archive file data (%ld bytes): %s\n", v9, v21);
      return -1;
    }
    v8 += v14;
    v16 = a1[11];
    if (v16 >= 1)
    {
      v17 = a1[12];
      v18 = a1[13] + v14;
      a1[13] = v18;
      if (v17 == v18)
      {
        v19 = a1[7];
        v20 = v19 - a1[14] - v8 >= v16 ? v16 : v19 - a1[14] - v8;
        a1[12] = v20;
        a1[13] = 0;
        if (v20 >= 1)
        {
          archive_entry_set_size();
          if (archive_write_header())
            break;
        }
      }
    }
    a2 += v15;
    if (v8 == a3)
      goto LABEL_18;
  }
  v23 = (const char *)archive_error_string();
  v8 = 1;
  BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6902, (uint64_t)"write_data_libarchive", "Could not write next segment archive entry: %s\n", v23);
  return v8;
}

uint64_t BOMCopierDestinationEntrySeek(int *a1, void *data, unint64_t a3, off_t len, _QWORD *a5)
{
  int v10;
  int v11;
  int v12;
  int *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  AAFieldKey v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;

  if (!a1)
  {
    v15 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2243, (uint64_t)"BOMCopierDestinationEntrySeek", "destination_entry is NULL");
    return v15;
  }
  v10 = *a1;
  if (*a1 != 2)
  {
    if (v10 != 1)
    {
      if (!v10 && lseek(a1[17], len, 1) == -1)
      {
        v11 = *__error();
        v12 = a1[17];
        v13 = __error();
        v14 = strerror(*v13);
        BOMCopierErrorCapture(a5, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6949, (uint64_t)"seek_filesystem", "Could not lseek in the destination %d:%lu: %s", v12, len, v14);
        return 1;
      }
      goto LABEL_26;
    }
    if (!data)
    {
      v15 = 22;
      BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2268, (uint64_t)"BOMCopierDestinationEntrySeek", "seek_buffer is NULL");
      return v15;
    }
    if (!a3)
    {
      v15 = 22;
      BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2274, (uint64_t)"BOMCopierDestinationEntrySeek", "seek_buffer is NULL");
      return v15;
    }
    if (!*((_QWORD *)a1 + 9))
    {
      v15 = 22;
      BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2280, (uint64_t)"BOMCopierDestinationEntrySeek", "destination_entry->archive is NULL");
      return v15;
    }
    if (len)
    {
      v19 = 0;
      while (1)
      {
        v20 = len - v19 >= a3 ? a3 : len - v19;
        if (write_data_libarchive(a1, (uint64_t)data, v20, a5) != v20)
          break;
        v19 += v20;
        if (v19 == len)
          goto LABEL_26;
      }
      v15 = 1;
      BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6978, (uint64_t)"seek_libarchive", "Could not write zeroes to the archive for seeking");
      return v15;
    }
LABEL_26:
    v21 = (uint64_t *)*((_QWORD *)a1 + 3);
    if (!v21 || !BOMCopierDataAnalyzerUpdate(v21, data, len, a5))
      return 0;
    v15 = 1;
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2307, (uint64_t)"BOMCopierDestinationEntrySeek", "Could not update data analyzer");
    return v15;
  }
  if (!len)
    goto LABEL_26;
  v16 = 0;
  while (1)
  {
    v17 = len - v16 >= a3 ? a3 : len - v16;
    v18.ikey = 5521732;
    if (AAArchiveStreamWriteBlob(*((AAArchiveStream *)a1 + 42), v18, data, v17))
      break;
    v16 += v17;
    if (v16 == len)
      goto LABEL_26;
  }
  v15 = 1;
  BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7010, (uint64_t)"seek_apple_archive", "Could not write zeroes to AppleArchive: %u");
  return v15;
}

uint64_t BOMCopierDestinationEntryGetType(uint64_t a1, _QWORD *a2)
{
  if (a1)
    return BOMCopierSourceEntryModeToType(*(unsigned __int16 *)(a1 + 172));
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2326, (uint64_t)"BOMCopierDestinationEntryGetType", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationEntryGetPath(uint64_t a1, _QWORD *a2)
{
  if (a1)
    return *(_QWORD *)(a1 + 120);
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2344, (uint64_t)"BOMCopierDestinationEntryGetPath", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationEntryGetTotalWritten(uint64_t a1, _QWORD *a2)
{
  if (a1)
    return *(_QWORD *)(a1 + 112);
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2362, (uint64_t)"BOMCopierDestinationEntryGetTotalWritten", "destination_entry is NULL");
  return 0;
}

BOOL BOMCopierDestinationEntrySkipped(uint64_t a1, _QWORD *a2)
{
  if (a1)
    return *(_BYTE *)(a1 + 16) != 0;
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2380, (uint64_t)"BOMCopierDestinationEntrySkipped", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationSetInit(_QWORD *a1, size_t a2, size_t a3, uint64_t a4, _QWORD *a5)
{
  _QWORD *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  int v15;
  int *v16;
  int v17;
  int *v18;
  int v19;
  int *v20;

  if (!a1)
  {
    v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2401, (uint64_t)"BOMCopierDestinationSetInit", "destination_set is NULL");
    return v13;
  }
  if (!a2)
  {
    v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2407, (uint64_t)"BOMCopierDestinationSetInit", "io_buffer_size is 0");
    return v13;
  }
  if (!a3)
  {
    v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2413, (uint64_t)"BOMCopierDestinationSetInit", "zero_buffer_size is 0");
    return v13;
  }
  if (!a4)
  {
    v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2419, (uint64_t)"BOMCopierDestinationSetInit", "copier_destination is NULL");
    return v13;
  }
  bzero(a1, 0x430uLL);
  *(_DWORD *)a1 = 1;
  v10 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  a1[1] = v10;
  if (!v10)
  {
    v15 = *__error();
    v16 = __error();
    strerror(*v16);
    BOMCopierErrorCapture(a5, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2435, (uint64_t)"BOMCopierDestinationSetInit", "Could not allocate destination list: %s");
    return 1;
  }
  *v10 = a4;
  v11 = malloc_type_valloc(a2, 0x4AB463F2uLL);
  a1[2] = v11;
  if (!v11)
  {
    v17 = *__error();
    v18 = __error();
    strerror(*v18);
    BOMCopierErrorCapture(a5, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2448, (uint64_t)"BOMCopierDestinationSetInit", "Could not allocate I/O buffer: %s");
    return 1;
  }
  a1[3] = a2;
  v12 = malloc_type_valloc(a3, 0x59638F12uLL);
  a1[4] = v12;
  if (!v12)
  {
    v19 = *__error();
    v20 = __error();
    strerror(*v20);
    BOMCopierErrorCapture(a5, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2457, (uint64_t)"BOMCopierDestinationSetInit", "Could not allocate zero buffer: %s");
    return 1;
  }
  bzero(v12, a3);
  v13 = 0;
  a1[5] = a3;
  return v13;
}

void BOMCopierDestinationSetRelease(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  if (a1)
  {
    v2 = (void *)a1[4];
    if (v2)
      free(v2);
    v3 = (void *)a1[2];
    if (v3)
      free(v3);
    v4 = (void *)a1[1];
    if (v4)
      free(v4);
    bzero(a1, 0x430uLL);
  }
  else
  {
    BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2478, (uint64_t)"BOMCopierDestinationSetRelease", "destination_set is NULL");
  }
}

uint64_t BOMCopierCopySourceEntryToDestinationSet(uint64_t a1, unsigned int *a2, _QWORD *a3)
{
  size_t v6;
  unsigned int *v7;
  unsigned int *v8;
  char *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  _BOOL4 IsCompressed;
  _BYTE *v14;
  int v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  char v21;
  uint64_t Entry;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v27;
  int *v28;
  char *v29;
  int v30;
  int *v31;
  char *v32;
  NSObject *v33;
  uint64_t Size;
  _BOOL4 v35;
  unsigned int *v36;
  uint64_t v37;
  uint64_t v38;
  int ExtendedAttributeCount;
  int v40;
  unsigned int v41;
  char v42;
  const char *ExtendedAttributeName;
  const char *v44;
  const char *v45;
  _QWORD *v46;
  int v47;
  int *v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  _BOOL4 IsStreamed;
  _BOOL4 v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  size_t v65;
  size_t v66;
  size_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  NSObject *v71;
  uint64_t v72;
  uint64_t v73;
  void (*v74)(uint64_t, uint64_t, uint64_t, _QWORD);
  char v75;
  NSObject *v76;
  const char *v77;
  NSObject *v78;
  uint32_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  int ArchCount;
  unsigned int v87;
  uint64_t v88;
  __int128 v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t j;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  size_t v100;
  char *v101;
  unsigned int *v102;
  size_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  void (*v110)(uint64_t, uint64_t, uint64_t, _QWORD, __n128);
  const char *ActualPath;
  unsigned int *v112;
  uint64_t v113;
  uint64_t v114;
  NSObject *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  unsigned int v121;
  uint64_t v122;
  unsigned int *v123;
  uint64_t v124;
  uint64_t v125;
  unsigned int *v126;
  _QWORD *v127;
  __int128 v128;
  __int128 v129;
  uint8_t buf[32];
  uint64_t v131;
  uint64_t v132;

  v132 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2512, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "source_entry is NULL");
    return v25;
  }
  if (!a2)
  {
    v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2518, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "destination_set is NULL");
    return v25;
  }
  if (!*((_QWORD *)a2 + 4))
  {
    v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2524, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "zero_buffer is NULL");
    return v25;
  }
  if (!*((_QWORD *)a2 + 5))
  {
    v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2530, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "zero_buffer_size is 0");
    return v25;
  }
  v6 = *a2;
  v7 = (unsigned int *)malloc_type_calloc(1uLL, 0x48uLL, 0x1030040A1FD43D8uLL);
  if (!v7)
  {
    v27 = *__error();
    v28 = __error();
    v29 = strerror(*v28);
    BOMCopierErrorCapture(a3, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2559, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "Could not allocate copy state: %s", v29);
    return 1;
  }
  v8 = v7;
  *v7 = *a2;
  *((_QWORD *)v7 + 1) = *((_QWORD *)a2 + 2);
  *((_OWORD *)v7 + 1) = *(_OWORD *)(a2 + 6);
  *((_QWORD *)v7 + 4) = *((_QWORD *)a2 + 5);
  *((_QWORD *)v7 + 5) = ***((_QWORD ***)a2 + 1);
  *((_QWORD *)v7 + 6) = a2 + 12;
  v9 = (char *)malloc_type_calloc(v6, 0x20uLL, 0x92671938uLL);
  if (!v9)
  {
    v30 = *__error();
    v31 = __error();
    v32 = strerror(*v31);
    BOMCopierErrorCapture(a3, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2577, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "Could not allocate copy target list: %s", v32);
    release_copy_state(v8);
    return 1;
  }
  v126 = v8;
  if ((_DWORD)v6)
  {
    v10 = 0;
    v11 = (uint64_t *)*((_QWORD *)a2 + 1);
    do
    {
      v12 = *v11++;
      *(_QWORD *)&v9[v10] = v12;
      v10 += 32;
    }
    while (32 * v6 != v10);
    *((_QWORD *)v8 + 7) = v9;
    v127 = v8 + 14;
    IsCompressed = BOMCopierSourceEntryIsCompressed(a1);
    *((_BYTE *)v8 + 64) = 0;
    v14 = v8 + 16;
    if (IsCompressed)
    {
      v15 = 0;
      v16 = *((_QWORD *)a2 + 1);
      v17 = v6;
      do
      {
        if (*(_BYTE *)(*(_QWORD *)v16 + 113))
          v15 += *(unsigned __int8 *)(*(_QWORD *)v16 + 300);
        v16 += 8;
        --v17;
      }
      while (v17);
      if (v15 && v15 == (_DWORD)v6)
        *v14 = 1;
    }
    v18 = 0;
    for (i = 0; i != v6; ++i)
    {
      v20 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * i);
      if (IsCompressed && *(_BYTE *)(v20 + 113))
      {
        if (*v14)
          v21 = 2;
        else
          v21 = 1;
      }
      else
      {
        v21 = 0;
      }
      if ((*(_DWORD *)(v20 + 44) - 1) > 1
        || !BOMCopierSourceEntryIsRoot(a1) && BOMCopierSourceEntryGetType(a1) != 13)
      {
        Entry = BOMCopierDestinationCreateEntry(v20, a1, v21, a3);
        if (!Entry)
        {
          v25 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2715, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "Could not create destination entry");
          v46 = v126;
          goto LABEL_208;
        }
        v23 = *(_DWORD *)(Entry + 32);
        v24 = *v127 + v18;
        *(_QWORD *)v24 = v20;
        *(_QWORD *)(v24 + 8) = Entry;
        *(_DWORD *)(v24 + 16) = v23;
        if ((v23 - 3) <= 1)
          *v14 = 0;
      }
      v18 += 32;
    }
    v8 = v126;
  }
  else
  {
    *((_QWORD *)v8 + 7) = v9;
    v127 = v8 + 14;
    BOMCopierSourceEntryIsCompressed(a1);
    *((_BYTE *)v8 + 64) = 0;
    v14 = v8 + 16;
  }
  v33 = *((_QWORD *)v8 + 5);
  if (BOMCopierSourceEntryGetType(a1) != 8)
  {
LABEL_81:
    v54 = BOMCopierSourceEntrySkip(a1, *((void **)v8 + 1), *((_QWORD *)v8 + 2), a3);
    if ((_DWORD)v54)
    {
      v25 = v54;
      BOMCopierErrorCapture(a3, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7333, (uint64_t)"copy_entry_to_destinations", "Could not skip remaning source entry data\n", v116);
      goto LABEL_207;
    }
    v55 = *v8;
    if (!(_DWORD)v55)
    {
LABEL_89:
      v25 = 0;
      goto LABEL_207;
    }
    v56 = 0;
    v57 = 0;
    v58 = *v127;
    while (1)
    {
      v59 = *(_QWORD *)(v58 + v56 + 8);
      if (v59)
      {
        v60 = *(_QWORD **)(v58 + v56);
        snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v59 + 120));
        v61 = BOMCopierDestinationFinalizeEntry(v60, (_QWORD *)v59, a3);
        if ((_DWORD)v61)
        {
          v25 = v61;
          BOMCopierErrorCapture(a3, v61, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7353, (uint64_t)"copy_entry_to_destinations", "Could not finalize destination entry\n", v117);
          goto LABEL_207;
        }
        v58 = *((_QWORD *)v8 + 7);
        *(_QWORD *)(v58 + v56 + 8) = 0;
        v55 = *v8;
      }
      ++v57;
      v56 += 32;
      if (v57 >= v55)
        goto LABEL_89;
    }
  }
  Size = BOMCopierSourceEntryGetSize(a1);
  v35 = BOMCopierSourceEntryIsCompressed(a1);
  v36 = 0;
  v37 = Size;
  if (Size < 1)
    goto LABEL_63;
  v38 = a1;
  if (v35)
  {
    if (*v14)
    {
      ExtendedAttributeCount = BOMCopierSourceEntryGetExtendedAttributeCount(a1, a3);
      if (ExtendedAttributeCount)
      {
        v40 = ExtendedAttributeCount;
        v41 = 0;
        v42 = 0;
        do
        {
          ExtendedAttributeName = (const char *)BOMCopierSourceEntryGetExtendedAttributeName(a1, v41, a3);
          if (!ExtendedAttributeName)
          {
            v25 = 1;
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7183, (uint64_t)"copy_entry_to_destinations", "Could not retrieve extended attribute name for index %u", v41);
            v8 = v126;
            goto LABEL_207;
          }
          v44 = ExtendedAttributeName;
          if (!strcmp(ExtendedAttributeName, "com.apple.ResourceFork"))
          {
            ActualPath = (const char *)BOMCopierSourceEntryGetActualPath(a1);
            v8 = v126;
            if (!ActualPath)
            {
              v25 = 1;
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7205, (uint64_t)"copy_entry_to_destinations", "Could not retrieve actual path for source entry");
              goto LABEL_207;
            }
            v112 = BOMCopierSourceEntryNewFromResourceFork(ActualPath, a3);
            if (!v112)
            {
              v25 = 1;
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7212, (uint64_t)"copy_entry_to_destinations", "Could not create resource fork entry for %s");
              goto LABEL_207;
            }
            v36 = v112;
            v113 = *v126;
            v37 = 1;
            if ((_DWORD)v113)
            {
              v114 = *v127 + 8;
              do
              {
                if (*(_QWORD *)v114)
                  *(_BYTE *)(*(_QWORD *)v114 + 155) = 1;
                v114 += 32;
                --v113;
              }
              while (v113);
            }
            v38 = (uint64_t)v112;
            goto LABEL_64;
          }
          v42 |= strcmp(v44, "com.apple.decmpfs") == 0;
          ++v41;
        }
        while (v40 != v41);
        BOMCopierSourceEntrySetSize(a1, 0);
        v8 = v126;
        if ((v42 & 1) == 0)
          goto LABEL_58;
        if (v33 && os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v45 = "Skipping copying com.apple.decmpfs until finalization";
          goto LABEL_61;
        }
      }
      else
      {
        BOMCopierSourceEntrySetSize(a1, 0);
LABEL_58:
        if (v33 && os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v45 = "Source entry claims to be compressed but there is no com.apple.decmpfs extended attribute. Assuming zero-length file.";
LABEL_61:
          _os_log_impl(&dword_206367000, v33, OS_LOG_TYPE_DEFAULT, v45, buf, 2u);
        }
      }
      v36 = 0;
      v37 = 0;
    }
    else
    {
      v36 = 0;
      v37 = 1;
    }
LABEL_63:
    v38 = a1;
  }
LABEL_64:
  v122 = v37;
  v123 = v36;
  v124 = Size;
  v125 = v38;
  if (!BOMCopierSourceEntryGetBinaryType(v38) || !*v8)
    goto LABEL_71;
  v47 = 0;
  v48 = (int *)(*v127 + 16);
  v49 = *v8;
  do
  {
    v50 = *v48;
    v48 += 8;
    if (v50 == 1)
      ++v47;
    --v49;
  }
  while (v49);
  if (v47 == *v8)
  {
LABEL_71:
    v51 = BOMCopierSourceEntryGetSize(v38);
    IsStreamed = BOMCopierSourceEntryIsStreamed(v38);
    if (v51)
      v53 = 0;
    else
      v53 = IsStreamed;
    if (!v51 && !IsStreamed)
      goto LABEL_76;
    v62 = 0;
    v120 = v51;
    while (1)
    {
      v63 = v51 - v62;
      while (1)
      {
        v64 = v63 >= *((_QWORD *)v8 + 2) ? *((_QWORD *)v8 + 2) : v63;
        v65 = v53 ? *((_QWORD *)v8 + 2) : v64;
        v66 = BOMCopierSourceEntryRead(v38, *((char **)v8 + 1), v65, a3);
        v67 = v66;
        if (v53)
          break;
        if ((v66 & 0x8000000000000000) != 0)
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7468, (uint64_t)"copy_file_entry_to_destinations", "Could not read %lu bytes from source");
LABEL_124:
          v25 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7291, (uint64_t)"copy_entry_to_destinations", "Could not copy file entry to destination entry list", v118);
          goto LABEL_207;
        }
        if (v66)
          goto LABEL_104;
      }
      if ((v66 & 0x8000000000000000) != 0)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7457, (uint64_t)"copy_file_entry_to_destinations", "Could not read %lu bytes from non-deterministic source");
        goto LABEL_124;
      }
      if (!v66)
        break;
LABEL_104:
      if (*v8)
      {
        v68 = 0;
        v69 = 0;
        do
        {
          v70 = *(_QWORD *)(*v127 + v68 + 8);
          if (v70)
          {
            snprintf(*((char **)v126 + 6), 0x400uLL, "%s", *(const char **)(v70 + 120));
            if (!*(_BYTE *)(v70 + 16) && !*(_BYTE *)(v70 + 154))
            {
              v71 = *((_QWORD *)v126 + 5);
              if (v71 && os_log_type_enabled(*((os_log_t *)v126 + 5), OS_LOG_TYPE_DEFAULT))
              {
                v72 = *(_QWORD *)(v70 + 120);
                *(_DWORD *)buf = 134218242;
                *(_QWORD *)&buf[4] = v67;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v72;
                _os_log_impl(&dword_206367000, v71, OS_LOG_TYPE_DEFAULT, "Copying %lu bytes to %s", buf, 0x16u);
              }
              if (BOMCopierDestinationEntryWrite(v70, *((char **)v126 + 1), v67, a3) != v67)
              {
                BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7498, (uint64_t)"copy_file_entry_to_destinations", "Could not write %ld bytes to destination", v67);
                v8 = v126;
                goto LABEL_124;
              }
              v73 = *(_QWORD *)(*v127 + v68);
              v74 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v73 + 248);
              if (v74)
                v74(v73, v125, v70, *(_QWORD *)(v73 + 256));
            }
          }
          ++v69;
          v8 = v126;
          v68 += 32;
        }
        while (v69 < *v126);
      }
      v62 += v67;
      v51 = v120;
      v75 = v62 != v120 || v53;
      v38 = v125;
      if ((v75 & 1) == 0)
      {
        v76 = *((_QWORD *)v8 + 5);
        if (v76 && os_log_type_enabled(*((os_log_t *)v8 + 5), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v120;
          v77 = "Read %llu total bytes from the source.";
          v78 = v76;
          v79 = 12;
          goto LABEL_200;
        }
        goto LABEL_76;
      }
    }
    v115 = *((_QWORD *)v8 + 5);
    if (v115 && os_log_type_enabled(*((os_log_t *)v8 + 5), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v77 = "Read 0 bytes from non-deterministic source.";
      v78 = v115;
      v79 = 2;
LABEL_200:
      _os_log_impl(&dword_206367000, v78, OS_LOG_TYPE_DEFAULT, v77, buf, v79);
    }
LABEL_76:
    if (v123)
      BOMCopierSourceEntryFree(v123);
    if (v124 >= 1 && !v122)
      BOMCopierSourceEntrySetSize(a1, v124);
    goto LABEL_81;
  }
  v80 = 0;
  v81 = 0;
  do
  {
    v82 = *v127 + v80;
    v83 = *(_QWORD *)(v82 + 8);
    if (v83)
    {
      v84 = *(_DWORD *)(v82 + 16);
      snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v83 + 120));
      if (v84 == 4 || v84 == 1 && BOMCopierSourceEntryGetBinaryType(v125) - 3 <= 1)
      {
        *(_QWORD *)buf = 0;
        if (!*(_BYTE *)(v83 + 16) && !*(_BYTE *)(v83 + 154))
        {
          if (BOMCopierDestinationEntryWriteFatHeader(v83, (size_t *)buf, a3))
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7579, (uint64_t)"copy_binary_entry_to_destinations", "Could not write fat header\n", v116);
            goto LABEL_206;
          }
          *(_QWORD *)(*v127 + v80 + 24) += *(_QWORD *)buf;
        }
      }
    }
    ++v81;
    v80 += 32;
  }
  while (v81 < *v8);
  v85 = v125;
  ArchCount = BOMCopierSourceEntryGetArchCount(v125);
  if (!ArchCount)
    goto LABEL_76;
  v87 = 0;
  v88 = 0;
  v89 = 0uLL;
  v119 = ArchCount;
  while (1)
  {
    v128 = v89;
    v129 = v89;
    if (BOMCopierSourceEntryGetArchRecord(v85, v87, &v128, a3))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7607, (uint64_t)"copy_binary_entry_to_destinations", "Could not get arch record at index %d\n");
      goto LABEL_206;
    }
    v121 = v87;
    v90 = *((_QWORD *)&v128 + 1) - v88;
    if (*((_QWORD *)&v128 + 1) != v88)
    {
      v88 = *((_QWORD *)&v128 + 1);
      if (BOMCopierSourceEntrySeek(v85, v90, *((void **)v8 + 1), *((_QWORD *)v8 + 2), a3))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7623, (uint64_t)"copy_binary_entry_to_destinations", "Could not seek to beginning of matching slice\n");
        goto LABEL_206;
      }
    }
    v91 = v88;
    v92 = *v8;
    v89 = 0uLL;
    if ((_DWORD)v92)
    {
      v93 = 0;
      for (j = 0; j < v92; ++j)
      {
        v95 = *(_QWORD *)(*v127 + v93 + 8);
        if (v95)
        {
          snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v95 + 120));
          v89 = 0uLL;
          v131 = 0;
          memset(buf, 0, sizeof(buf));
          if (!*(_BYTE *)(v95 + 16))
          {
            if (BOMCopierDestinationEntryGetMatchRecord(v95, v87, (uint64_t)buf, a3))
            {
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7658, (uint64_t)"copy_binary_entry_to_destinations", "Could not get match record at index %d\n");
              goto LABEL_206;
            }
            v89 = 0uLL;
            if (buf[0])
            {
              if (*(_QWORD *)&buf[16] == -1)
              {
                BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7672, (uint64_t)"copy_binary_entry_to_destinations", "dude offset is wack", v116);
                goto LABEL_206;
              }
              v96 = *(_QWORD *)(*v127 + v93 + 24);
              v97 = *(_QWORD *)&buf[16] - v96;
              if (*(_QWORD *)&buf[16] != v96)
              {
                if (BOMCopierDestinationEntrySeek((int *)v95, *((void **)v8 + 3), *((_QWORD *)v8 + 4), *(_QWORD *)&buf[16] - v96, a3))
                {
                  BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7684, (uint64_t)"copy_binary_entry_to_destinations", "Could not seek %ld bytes to beginning of new slice");
                  goto LABEL_206;
                }
                *(_QWORD *)(*v127 + v93 + 24) += v97;
                v89 = 0uLL;
              }
            }
          }
          v92 = *v8;
        }
        v93 += 32;
      }
    }
    v98 = v129;
    if ((_QWORD)v129)
      break;
    v85 = v125;
    v88 = v91;
LABEL_176:
    if (++v87 == v119)
      goto LABEL_76;
  }
  v99 = 0;
  v85 = v125;
  v88 = v91;
  while (1)
  {
    v100 = v98 - v99;
    v101 = (char *)*((_QWORD *)v8 + 1);
    v102 = v8;
    if (v100 >= *((_QWORD *)v8 + 2))
      v103 = *((_QWORD *)v8 + 2);
    else
      v103 = v100;
    if (BOMCopierSourceEntryRead(v85, v101, v103, a3) != v103)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7710, (uint64_t)"copy_binary_entry_to_destinations", "Could not read %ld bytes from source", v103);
      v8 = v102;
      goto LABEL_206;
    }
    v104 = *v102;
    v87 = v121;
    v89 = 0uLL;
    if ((_DWORD)v104)
      break;
LABEL_173:
    v88 += v103;
    v99 += v103;
    v98 = v129;
    v85 = v125;
    v8 = v126;
    if (v99 == (_QWORD)v129)
      goto LABEL_176;
  }
  v105 = 0;
  v106 = 0;
  while (1)
  {
    v107 = *(_QWORD *)(*v127 + v105 + 8);
    if (v107)
      break;
LABEL_164:
    ++v106;
    v105 += 32;
    if (v106 >= v104)
      goto LABEL_173;
  }
  snprintf(*((char **)v126 + 6), 0x400uLL, "%s", *(const char **)(v107 + 120));
  v89 = 0uLL;
  v131 = 0;
  memset(buf, 0, sizeof(buf));
  if (*(_BYTE *)(v107 + 16))
    goto LABEL_163;
  if (BOMCopierDestinationEntryGetMatchRecord(v107, v121, (uint64_t)buf, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7740, (uint64_t)"copy_binary_entry_to_destinations", "Could not get match record at index %d\n");
    goto LABEL_189;
  }
  v89 = 0uLL;
  if (!buf[0] || *(_BYTE *)(v107 + 16) || *(_BYTE *)(v107 + 154))
  {
LABEL_163:
    v104 = *v126;
    goto LABEL_164;
  }
  if (BOMCopierDestinationEntryWrite(v107, *((char **)v126 + 1), v103, a3) == v103)
  {
    v108 = (_QWORD *)(*v127 + v105);
    v108[3] += v103;
    v109 = *v108;
    v110 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, __n128))(*v108 + 248);
    v89 = 0uLL;
    if (v110)
    {
      v110(v109, v125, v107, *(_QWORD *)(v109 + 256), (__n128)0);
      v89 = 0uLL;
    }
    goto LABEL_163;
  }
  BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7754, (uint64_t)"copy_binary_entry_to_destinations", "Could not write %ld bytes to destination: %s\n");
LABEL_189:
  v8 = v126;
LABEL_206:
  v25 = 1;
  BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7299, (uint64_t)"copy_entry_to_destinations", "Could not copy file entry to destination entry list");
LABEL_207:
  v46 = v8;
LABEL_208:
  release_copy_state(v46);
  return v25;
}

void release_copy_state(_QWORD *a1)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = (char *)a1[7];
  if (v2)
  {
    v3 = *(unsigned int *)a1;
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 8;
      do
      {
        if (*(_QWORD *)&v2[v5])
        {
          BOMCopierDestinationEntryFree(*(_QWORD **)&v2[v5]);
          v2 = (char *)a1[7];
          *(_QWORD *)&v2[v5] = 0;
          v3 = *(unsigned int *)a1;
        }
        ++v4;
        v5 += 32;
      }
      while (v4 < v3);
    }
    free(v2);
  }
  a1[8] = 0;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  free(a1);
}

const char *string_for_entry_type(unsigned int a1)
{
  if (a1 > 0x13)
    return "?";
  else
    return off_24BF06CE8[a1];
}

const char *string_for_mode(__int16 a1)
{
  unsigned int v1;

  v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6)
    return "?";
  else
    return off_24BF06D88[v1 >> 12];
}

uint64_t populate_aa_header_acl(uint64_t a1, uint64_t a2, AAHeader_impl *a3, _QWORD *a4)
{
  pid_t v8;
  int v9;
  const char *ACL;
  _acl *v11;
  _acl *v12;
  int v13;
  char *v14;
  int *v15;
  char *v16;
  int *v17;
  char *v18;
  uint64_t v19;
  int *v20;
  int v21;
  int *v22;
  char *v23;
  char *v24;
  AAEntryACLBlob_impl *v26;
  size_t EncodedSize;
  const uint8_t *EncodedData;
  char *v29;
  char *v30;
  AAFieldKey v31;
  int v32;
  int v33;
  int *v34;
  char *v35;
  uint64_t v36;
  char *path_p;

  path_p = 0;
  v8 = getpid();
  asprintf(&path_p, "/tmp/.BCDE.%u.T_XXXXXX", v8);
  if (path_p)
  {
    v9 = mkstemp(path_p);
    if (v9 == -1)
    {
      v20 = __error();
      strerror(*v20);
      v19 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4871, (uint64_t)"populate_aa_header_acl", "Could not mkstemp %s: %s\n");
    }
    else
    {
      close(v9);
      v36 = 0;
      ACL = (const char *)BOMCopierSourceEntryGetACL(a1, &v36, a4);
      if (ACL)
      {
        v11 = acl_from_text(ACL);
        if (!v11)
        {
          v21 = *__error();
          v22 = __error();
          v23 = strerror(*v22);
          BOMCopierErrorCapture(a4, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4890, (uint64_t)"populate_aa_header_acl", "Could not convert ACL text: %s", v23);
          goto LABEL_12;
        }
        v12 = v11;
        if (acl_set_file(path_p, ACL_TYPE_EXTENDED, v11))
        {
          v13 = *__error();
          v14 = path_p;
          v15 = __error();
          v16 = strerror(*v15);
          BOMCopierErrorCapture(a4, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4898, (uint64_t)"populate_aa_header_acl", "Could not set ACL on %s: %s", v14, v16);
          acl_free(v12);
LABEL_12:
          v24 = path_p;
          goto LABEL_13;
        }
        acl_free(v12);
        v26 = AAEntryACLBlobCreateWithPath(path_p, "", 0);
        if (v26)
        {
          free(path_p);
          EncodedSize = AAEntryACLBlobGetEncodedSize(v26);
          EncodedData = AAEntryACLBlobGetEncodedData(v26);
          v29 = (char *)malloc_type_malloc(EncodedSize, 0xC1FC8717uLL);
          if (!v29)
          {
            v33 = *__error();
            v34 = __error();
            v35 = strerror(*v34);
            BOMCopierErrorCapture(a4, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4926, (uint64_t)"populate_aa_header_acl", "Could not allocate encoded buffer: %s", v35);
            AAEntryACLBlobDestroy(v26);
            return 1;
          }
          v30 = v29;
          memcpy(v29, EncodedData, EncodedSize);
          AAEntryACLBlobDestroy(v26);
          v31.ikey = 4997953;
          v32 = AAHeaderSetFieldBlob(a3, 0xFFFFFFFF, v31, EncodedSize);
          if (!v32)
          {
            v19 = 0;
            *(_QWORD *)(a2 + 344) = v30;
            *(_QWORD *)(a2 + 352) = EncodedSize;
            return v19;
          }
          BOMCopierErrorCapture(a4, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4942, (uint64_t)"populate_aa_header_acl", "Could not append AA_FIELD_ACL to AppleArchive header: %d", v32);
          v24 = v30;
LABEL_13:
          free(v24);
          return 1;
        }
        v19 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4909, (uint64_t)"populate_aa_header_acl", "Could create AppleArchive ACL blob from %s: %s");
      }
      else
      {
        v19 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4882, (uint64_t)"populate_aa_header_acl", "Could not get ACL from source entry");
      }
    }
    free(path_p);
  }
  else
  {
    v17 = __error();
    v18 = strerror(*v17);
    v19 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4864, (uint64_t)"populate_aa_header_acl", "Could not create ACL file path: %s\n", v18);
  }
  return v19;
}

uint64_t populate_aa_header_xattr(uint64_t a1, uint64_t a2, AAHeader_impl *a3, _QWORD *a4)
{
  AAEntryXATBlob v8;
  AAEntryXATBlob_impl *v9;
  int ExtendedAttributeCount;
  int v11;
  unsigned int v12;
  void *v13;
  size_t v14;
  uint64_t ExtendedAttributeName;
  const char *v16;
  size_t ExtendedAttributeSize;
  size_t v18;
  int appended;
  size_t EncodedSize;
  const uint8_t *EncodedData;
  void *v22;
  void *v23;
  AAFieldKey v24;
  int v25;
  uint64_t v26;
  int v27;
  int *v28;
  int v29;
  int *v30;
  uint64_t v32;

  v8 = AAEntryXATBlobCreate();
  if (!v8)
  {
    v26 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4750, (uint64_t)"populate_aa_header_xattr", "Could not create AppleArchive XAT blob");
    return v26;
  }
  v9 = v8;
  ExtendedAttributeCount = BOMCopierSourceEntryGetExtendedAttributeCount(a1, a4);
  if (ExtendedAttributeCount)
  {
    v11 = ExtendedAttributeCount;
    v32 = a2;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    do
    {
      ExtendedAttributeName = BOMCopierSourceEntryGetExtendedAttributeName(a1, v12, a4);
      if (!ExtendedAttributeName)
      {
        v26 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4764, (uint64_t)"populate_aa_header_xattr", "Could not get name for xattr %u");
        return v26;
      }
      v16 = (const char *)ExtendedAttributeName;
      ExtendedAttributeSize = BOMCopierSourceEntryGetExtendedAttributeSize(a1, v12, a4);
      if (!ExtendedAttributeSize)
      {
        v26 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4771, (uint64_t)"populate_aa_header_xattr", "Could not get size for xattr %u");
        return v26;
      }
      v18 = ExtendedAttributeSize;
      if (v14 < ExtendedAttributeSize)
      {
        v13 = malloc_type_realloc(v13, ExtendedAttributeSize, 0xADE94BC4uLL);
        v14 = v18;
        if (!v13)
        {
          v29 = *__error();
          v30 = __error();
          strerror(*v30);
          BOMCopierErrorCapture(a4, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4781, (uint64_t)"populate_aa_header_xattr", "Could not allocate buffer %u: %s");
          return 1;
        }
      }
      if (BOMCopierSourceEntryCopyExtendedAttribute(a1, v12, v13, v18, 0, a4) != v18)
      {
        v26 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4789, (uint64_t)"populate_aa_header_xattr", "Could not copy xattr %u");
        return v26;
      }
      appended = AAEntryXATBlobAppendEntry(v9, v16, (const uint8_t *)v13, v18);
      if (appended)
      {
        BOMCopierErrorCapture(a4, appended, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4796, (uint64_t)"populate_aa_header_xattr", "Could not append %u entry to AppleArchive XAT blob: %d");
        return 1;
      }
      ++v12;
    }
    while (v11 != v12);
    a2 = v32;
    if (v13)
      free(v13);
  }
  EncodedSize = AAEntryXATBlobGetEncodedSize(v9);
  EncodedData = AAEntryXATBlobGetEncodedData(v9);
  v22 = malloc_type_malloc(EncodedSize, 0x8C0427uLL);
  if (!v22)
  {
    v27 = *__error();
    v28 = __error();
    strerror(*v28);
    BOMCopierErrorCapture(a4, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4816, (uint64_t)"populate_aa_header_xattr", "Could not allocate encoded buffer: %s");
    return 1;
  }
  v23 = v22;
  memcpy(v22, EncodedData, EncodedSize);
  AAEntryXATBlobDestroy(v9);
  v24.ikey = 5521752;
  v25 = AAHeaderSetFieldBlob(a3, 0xFFFFFFFF, v24, EncodedSize);
  if (v25)
  {
    BOMCopierErrorCapture(a4, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4831, (uint64_t)"populate_aa_header_xattr", "Could not append AA_FIELD_XAT to AppleArchive header: %d", v25);
    free(v23);
    return 1;
  }
  v26 = 0;
  *(_QWORD *)(a2 + 360) = v23;
  *(_QWORD *)(a2 + 368) = EncodedSize;
  return v26;
}

void apply_retention_policy(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  std::error_code *v7;
  int BinaryType;
  _BOOL4 v9;
  const char *Path;
  int v11;
  char *v12;
  int *v13;
  int v14;
  int *v15;
  std::error_code *v16;
  std::__fs::filesystem::path *v17;
  const std::__fs::filesystem::path *v18;
  NSObject *v19;
  int v20;
  int v21;
  int *v22;
  void *v23;
  unint64_t v24;
  int *v25;
  int v26;
  int *v27;
  const char *v28;
  int v29;
  int v30;
  size_t v31;
  const std::__fs::filesystem::path *v32;
  const std::__fs::filesystem::path *v33;
  NSObject *v34;
  int v35;
  int v36;
  int *v37;
  int v38;
  int *v39;
  int v40;
  int *v41;
  int v42;
  int *v43;
  int v44;
  int *v45;
  std::__fs::filesystem::path *__to;
  uint8_t buf[16];
  unsigned __int8 v48[21];
  uuid_t out;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a2 + 8);
  if (BOMCopierSourceEntryGetType(v6) == 8)
  {
    if (*(_BYTE *)(a1 + 307))
    {
      BinaryType = BOMCopierSourceEntryGetBinaryType(v6);
      v9 = BinaryType != 0;
      if (!*(_QWORD *)(a1 + 336))
      {
        if (!BinaryType)
          goto LABEL_40;
LABEL_11:
        __to = 0;
        v12 = *(char **)(a1 + 344);
        if (v12)
        {
          if (make_path(*(NSObject **)a1, v12, a3))
          {
            v13 = __error();
            strerror(*v13);
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6456, (uint64_t)"apply_retention_policy", "Could not make the kept file directory %s: %s");
            return;
          }
          if (*(_BYTE *)(a1 + 352))
          {
            if (!*(_QWORD *)(a1 + 360))
            {
              v23 = malloc_type_calloc(1uLL, 0x400uLL, 0x6A9B944BuLL);
              *(_QWORD *)(a1 + 360) = v23;
              if (!v23)
              {
                v40 = *__error();
                v41 = __error();
                strerror(*v41);
                BOMCopierErrorCapture(a3, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6475, (uint64_t)"apply_retention_policy", "Could not allocate kept file subdirectory path: %s");
                return;
              }
            }
            v24 = *(_QWORD *)(a1 + 312);
            if (!v24 || !(v24 % *(unsigned int *)(a1 + 356)))
            {
              memset(out, 0, sizeof(out));
              uuid_generate_random(out);
              *(_OWORD *)buf = 0u;
              memset(v48, 0, sizeof(v48));
              uuid_unparse(out, (char *)buf);
              snprintf(*(char **)(a1 + 360), 0x400uLL, "%s/%c%c/%c%c/%c%c/%s", *(const char **)(a1 + 344), (char)buf[0], (char)buf[1], (char)buf[2], (char)buf[3], (char)buf[4], (char)buf[5], (const char *)buf);
              if (make_path(*(NSObject **)a1, *(char **)(a1 + 360), a3))
              {
                v25 = __error();
                strerror(*v25);
                BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6502, (uint64_t)"apply_retention_policy", "Could not make the kept file subdirectory %s: %s");
                return;
              }
            }
            asprintf((char **)&__to, "%s/%lu");
          }
          else
          {
            getpid();
            asprintf((char **)&__to, "%s/%s.dittoKeptBinary.%d.%lu");
          }
        }
        else
        {
          getpid();
          asprintf((char **)&__to, "%s.dittoKeptBinary.%d.%lu");
        }
        v17 = __to;
        if (!__to)
        {
          v26 = *__error();
          v27 = __error();
          strerror(*v27);
          BOMCopierErrorCapture(a3, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6522, (uint64_t)"apply_retention_policy", "Could not asprintf kept path: %s\n");
          return;
        }
        ++*(_QWORD *)(a1 + 312);
        v18 = *(const std::__fs::filesystem::path **)(a2 + 120);
        v19 = *(NSObject **)a1;
        if (*(_QWORD *)a1)
        {
          if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
            || (*(_DWORD *)buf = 136315138,
                *(_QWORD *)&buf[4] = v18,
                _os_log_impl(&dword_206367000, v19, OS_LOG_TYPE_DEFAULT, "kept old: %s", buf, 0xCu),
                (v19 = *(NSObject **)a1) != 0))
          {
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v17;
              _os_log_impl(&dword_206367000, v19, OS_LOG_TYPE_DEFAULT, "kept new: %s", buf, 0xCu);
            }
          }
        }
        rename(v18, v17, v16);
        if (v20)
        {
          v21 = *__error();
          v22 = __error();
          strerror(*v22);
          BOMCopierErrorCapture(a3, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6537, (uint64_t)"apply_retention_policy", "Could not rename kept %s to %s: %s", v18);
LABEL_24:
          free(__to);
          return;
        }
        v28 = *(const char **)(a1 + 320);
        if (v28)
        {
          v29 = *(_DWORD *)(a1 + 328);
          if (v29 == -1)
          {
            v30 = open(v28, 1545, 420);
            if (v30 == -1)
            {
              v44 = *__error();
              v45 = __error();
              strerror(*v45);
              BOMCopierErrorCapture(a3, v44, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6560, (uint64_t)"apply_retention_policy", "Could not open %s: %s");
              goto LABEL_24;
            }
            v29 = v30;
            *(_DWORD *)(a1 + 328) = v30;
          }
          v31 = strlen((const char *)__to);
          if (write(v29, __to, v31) != v31)
          {
            v38 = *__error();
            v39 = __error();
            strerror(*v39);
            BOMCopierErrorCapture(a3, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6576, (uint64_t)"apply_retention_policy", "Could not write to %s: %s");
            goto LABEL_24;
          }
          if (write(v29, "\n", 1uLL) != 1)
          {
            v42 = *__error();
            v43 = __error();
            strerror(*v43);
            BOMCopierErrorCapture(a3, v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6585, (uint64_t)"apply_retention_policy", "Could not write to %s: %s");
            goto LABEL_24;
          }
        }
        free(__to);
        goto LABEL_40;
      }
    }
    else
    {
      if (!*(_QWORD *)(a1 + 336))
        goto LABEL_40;
      v9 = 0;
    }
    Path = (const char *)BOMCopierSourceEntryGetPath(v6);
    v11 = regexec(*(const regex_t **)(a1 + 336), Path, 0, 0, 0);
    if (v11)
    {
      if (v11 != 1)
      {
        v14 = *__error();
        v15 = __error();
        strerror(*v15);
        BOMCopierErrorCapture(a3, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6426, (uint64_t)"apply_retention_policy", "Could not regexec %s: %s\n");
        return;
      }
      if (!v9)
        goto LABEL_40;
    }
    goto LABEL_11;
  }
LABEL_40:
  if (*(_BYTE *)(a2 + 152))
  {
    v32 = *(const std::__fs::filesystem::path **)(a2 + 144);
    v33 = *(const std::__fs::filesystem::path **)(a2 + 120);
    v34 = *(NSObject **)a1;
    if (*(_QWORD *)a1)
    {
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
        || (*(_DWORD *)buf = 136315138,
            *(_QWORD *)&buf[4] = v32,
            _os_log_impl(&dword_206367000, v34, OS_LOG_TYPE_DEFAULT, "rename old: %s", buf, 0xCu),
            (v34 = *(NSObject **)a1) != 0))
      {
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v33;
          _os_log_impl(&dword_206367000, v34, OS_LOG_TYPE_DEFAULT, "rename new: %s", buf, 0xCu);
        }
      }
    }
    rename(v32, v33, v7);
    if (v35)
    {
      v36 = *__error();
      v37 = __error();
      strerror(*v37);
      BOMCopierErrorCapture(a3, v36, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6606, (uint64_t)"apply_retention_policy", "Could not rename staged %s to %s: %s", v32);
    }
  }
}

uint64_t set_timestamps(uint64_t a1, uint64_t a2, NSObject *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const char *v13;
  int *v14;
  char *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v23 = 0uLL;
  if (BOMCopierSourceEntryGetModificationTime(a1, &v23))
  {
    v8 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6637, (uint64_t)"set_timestamps", "Could not retrieve the entry modification time");
  }
  else
  {
    v22 = 0uLL;
    if (BOMCopierSourceEntryGetAccessTime(a1, &v22))
    {
      v8 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6646, (uint64_t)"set_timestamps", "Could not retrieve the entry access time");
    }
    else
    {
      v21 = 0;
      v20 = xmmword_2063CFCA8;
      v11 = *((_QWORD *)&v23 + 1);
      v10 = v23;
      v17 = v23;
      if (v22 != 0)
      {
        v11 = *((_QWORD *)&v22 + 1);
        v10 = v22;
      }
      v18 = v10;
      v19 = v11;
      if (!setattrlist(*(const char **)(a2 + 120), &v20, &v17, 0x20uLL, 1u))
      {
        if (a3)
        {
          v8 = 0;
          if (!os_log_type_enabled(a3, OS_LOG_TYPE_DEFAULT))
            return v8;
          v16 = *(_QWORD *)(a2 + 120);
          *(_DWORD *)buf = 134219010;
          v25 = v17;
          v26 = 2048;
          v27 = *((_QWORD *)&v17 + 1);
          v28 = 2048;
          v29 = v18;
          v30 = 2048;
          v31 = v19;
          v32 = 2080;
          v33 = v16;
          _os_log_impl(&dword_206367000, a3, OS_LOG_TYPE_DEFAULT, "Set mtime [%ld.%ld] and atime [%ld.%ld] on %s", buf, 0x34u);
        }
        return 0;
      }
      v12 = *__error();
      v13 = *(const char **)(a2 + 120);
      v14 = __error();
      v15 = strerror(*v14);
      BOMCopierErrorCapture(a4, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6676, (uint64_t)"set_timestamps", "Could not setattrlist timestamps for %s: %s", v13, v15);
      return 1;
    }
  }
  return v8;
}

uint64_t change_flags(const char *a1, int a2, __uint32_t a3)
{
  uint64_t result;
  _DWORD v6[3];

  v6[0] = a2;
  v6[1] = a3;
  v6[2] = -1;
  result = fsctl(a1, 0xC00C4114uLL, v6, 0);
  if ((_DWORD)result)
  {
    if (*__error() == 25 || *__error() == 45)
    {
      result = chflags(a1, a3);
      if ((_DWORD)result)
        return *__error() != 45;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

_QWORD *data_read_stream_new(uint64_t a1, uint64_t a2)
{
  _QWORD *result;

  if (a2)
    return 0;
  result = platform_calloc(a1, 1uLL, 0x68uLL);
  if (result)
  {
    *(_DWORD *)result = 1919246692;
    result[1] = a1;
    *((_DWORD *)result + 25) = 1684104557;
  }
  return result;
}

void data_read_stream_free(void *__b)
{
  bz_stream *v2;
  z_stream *v3;
  void *v4;
  void *v5;
  uint64_t v6;

  if (__b && *(_DWORD *)__b == 1919246692 && *((_DWORD *)__b + 25) == 1684104557)
  {
    v2 = (bz_stream *)*((_QWORD *)__b + 11);
    if (v2)
    {
      BZ2_bzDecompressEnd(v2);
      platform_free(*((_QWORD *)__b + 1), *((void **)__b + 11));
    }
    v3 = (z_stream *)*((_QWORD *)__b + 10);
    if (v3)
    {
      inflateEnd(v3);
      platform_free(*((_QWORD *)__b + 1), *((void **)__b + 10));
    }
    v4 = (void *)*((_QWORD *)__b + 8);
    if (v4)
      platform_free(*((_QWORD *)__b + 1), v4);
    v5 = (void *)*((_QWORD *)__b + 4);
    if (v5)
      platform_free(*((_QWORD *)__b + 1), v5);
    v6 = *((_QWORD *)__b + 1);
    platform_memset(v6, __b, 0, 0x68uLL);
    platform_free(v6, __b);
  }
}

uint64_t data_read_stream_set_source(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v4;
  int v5;
  void *v6;
  size_t v7;
  unsigned __int8 *v8;
  int v9;
  FILE *v10;
  int *v11;
  FILE *v12;
  int *v13;
  int v14;
  int v16;
  int v17;
  void *v19;
  int v20;
  z_stream *v21;
  FILE *v22;
  const char *v23;
  FILE *v24;
  int *v25;
  FILE *v26;
  bz_stream *v27;
  int *v28;
  int *v29;
  char *v30;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != 1919246692)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (a2 && *(_DWORD *)(a1 + 100) == 1684104557)
  {
    *(_QWORD *)(a1 + 16) = a2;
    v4 = getpagesize();
    if (v4 <= 0xE)
      v5 = 14;
    else
      v5 = v4;
    *(_QWORD *)(a1 + 24) = v5;
    v6 = platform_valloc(*(_QWORD *)(a1 + 8), v5);
    *(_QWORD *)(a1 + 32) = v6;
    if (v6)
    {
      v7 = resilient_source_read(*(_QWORD *)(a1 + 16), v6, 0xEuLL);
      if (v7 != -1)
      {
        *(_QWORD *)(a1 + 40) = v7;
        if ((uint64_t)v7 < 1)
          goto LABEL_42;
        v8 = *(unsigned __int8 **)(a1 + 32);
        if (v7 < 0xA)
        {
          if (v7 < 7)
            goto LABEL_42;
          v9 = *v8;
LABEL_36:
          if (v9 == 24 && v8[1] == 77 && v8[2] == 34 && v8[3] == 4)
          {
            v14 = 3;
            goto LABEL_41;
          }
LABEL_42:
          if (*(_DWORD *)(a1 + 72))
          {
            *(_QWORD *)(a1 + 56) = 0x20000;
            v19 = platform_valloc(*(_QWORD *)(a1 + 8), 0x20000uLL);
            *(_QWORD *)(a1 + 64) = v19;
            if (!v19)
            {
              v24 = (FILE *)*MEMORY[0x24BDAC8D8];
              v25 = __error();
              v30 = strerror(*v25);
              v23 = "Could not allocate read buffer: %s\n";
              goto LABEL_51;
            }
            v20 = *(_DWORD *)(a1 + 72);
            if (v20 == 2)
            {
              v27 = (bz_stream *)platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x50uLL);
              *(_QWORD *)(a1 + 88) = v27;
              if (v27)
              {
                result = BZ2_bzDecompressInit(v27, 0, 0);
                if (!(_DWORD)result)
                  return result;
                v22 = (FILE *)*MEMORY[0x24BDAC8D8];
                v30 = (char *)result;
                v23 = "Could not BZ2_bzDecompressInit: %d\n";
                goto LABEL_55;
              }
              v24 = (FILE *)*MEMORY[0x24BDAC8D8];
              v29 = __error();
              v30 = strerror(*v29);
              v23 = "Could not allocate bzip2 stream: %s\n";
LABEL_51:
              v26 = v24;
LABEL_56:
              fprintf(v26, v23, v30);
              fwrite("Could not initialize decompression\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
              return 0xFFFFFFFFLL;
            }
            if (v20 == 1)
            {
              v21 = (z_stream *)platform_calloc(*(_QWORD *)(a1 + 8), 1uLL, 0x70uLL);
              *(_QWORD *)(a1 + 80) = v21;
              if (v21)
              {
                result = inflateInit2_(v21, 31, "1.2.12", 112);
                if (!(_DWORD)result)
                  return result;
                v22 = (FILE *)*MEMORY[0x24BDAC8D8];
                v30 = (char *)result;
                v23 = "Could not inflateInit2: %d\n";
LABEL_55:
                v26 = v22;
                goto LABEL_56;
              }
              v24 = (FILE *)*MEMORY[0x24BDAC8D8];
              v28 = __error();
              v30 = strerror(*v28);
              v23 = "Could not allocate zlib stream: %s\n";
              goto LABEL_51;
            }
          }
          return 0;
        }
        v9 = *v8;
        if (v9 == 31 && v8[1] == 139 && v8[2] == 8)
        {
          v14 = 1;
        }
        else
        {
          if (v7 < 0xE || v9 != 66)
            goto LABEL_36;
          if (v8[1] != 90 || v8[2] != 104 || v8[3] - 49 > 8)
            goto LABEL_42;
          if (*((_DWORD *)v8 + 1) != 643383601 || *((_WORD *)v8 + 4) != 22867)
          {
            v16 = *((_DWORD *)v8 + 1);
            v17 = *((unsigned __int16 *)v8 + 4);
            if (v16 != 944075287 || v17 != 36944)
              goto LABEL_42;
          }
          v14 = 2;
        }
LABEL_41:
        *(_DWORD *)(a1 + 72) = v14;
        goto LABEL_42;
      }
      v12 = (FILE *)*MEMORY[0x24BDAC8D8];
      v13 = __error();
      strerror(*v13);
      fprintf(v12, "Could not read minimal data for auto-detection: %s\n");
    }
    else
    {
      v10 = (FILE *)*MEMORY[0x24BDAC8D8];
      v11 = __error();
      strerror(*v11);
      fprintf(v10, "Could not allocate discovery buffer: %s\n");
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

size_t resilient_source_read(uint64_t a1, void *a2, size_t a3)
{
  size_t v6;

  do
    v6 = data_source_read(a1, a2, a3);
  while (v6 == -1 && *__error() == 35);
  return v6;
}

uint64_t data_stream_read(uint64_t a1, char *__dst, size_t a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  z_stream *v9;
  int v10;
  uint64_t v11;
  bz_stream *v12;
  int v13;
  uint64_t v14;

  if (!a1 || *(_DWORD *)a1 != 1919246692)
    return -1;
  result = -1;
  if (__dst && *(_DWORD *)(a1 + 100) == 1684104557)
  {
    if (a3)
    {
      if (*(_DWORD *)(a1 + 72))
      {
        while (1)
        {
          result = read_from_source((uint64_t *)a1, *(char **)(a1 + 64), *(_QWORD *)(a1 + 56), a3);
          if (result == -1)
            break;
          v7 = result;
          v8 = *(_DWORD *)(a1 + 72);
          if (v8 == 2)
          {
            v12 = *(bz_stream **)(a1 + 88);
            v12->next_in = *(char **)(a1 + 64);
            v12->avail_in = v7;
            v12->next_out = __dst;
            v12->avail_out = a3;
            v13 = BZ2_bzDecompress(v12);
            if (v13)
            {
              if (v13 != 4)
              {
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not BZ2_bzDecompress: %d\n");
                return -1;
              }
              *(_BYTE *)(a1 + 96) = 1;
            }
            v11 = *(_QWORD *)(a1 + 88);
          }
          else
          {
            if (v8 != 1)
              return -1;
            v9 = *(z_stream **)(a1 + 80);
            v9->next_in = *(Bytef **)(a1 + 64);
            v9->avail_in = v7;
            v9->next_out = (Bytef *)__dst;
            v9->avail_out = a3;
            v10 = inflate(v9, 0);
            if (v10)
            {
              if (v10 != 1)
              {
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not inflate: %d\n");
                return -1;
              }
              *(_BYTE *)(a1 + 96) = 1;
            }
            v11 = *(_QWORD *)(a1 + 80);
          }
          v14 = *(unsigned int *)(v11 + 32);
          result = a3 - v14;
          if (v7 >= 1 && a3 == v14)
          {
            result = 0;
            if (!*(_BYTE *)(a1 + 96))
              continue;
          }
          return result;
        }
      }
      else
      {
        return read_from_source((uint64_t *)a1, __dst, a3, a3);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

size_t read_from_source(uint64_t *a1, char *__dst, size_t a3, size_t a4)
{
  char *v4;
  size_t v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  size_t v13;
  FILE *v14;
  int *v15;
  char *v16;

  v4 = __dst;
  if (a4 >= a3)
    v6 = a3;
  else
    v6 = a4;
  v8 = a1[5];
  v7 = a1[6];
  v9 = v8 > v7;
  v10 = v8 - v7;
  if (v9)
  {
    if (v6 >= v10)
      v11 = v10;
    else
      v11 = v6;
    memcpy(__dst, (const void *)(a1[4] + v7), v11);
    a1[6] += v11;
    v4 += v11;
    v6 -= v11;
    if (v6)
      goto LABEL_12;
  }
  else
  {
    v11 = 0;
    if (v6)
    {
LABEL_12:
      v12 = 0;
      do
      {
        v13 = resilient_source_read(a1[2], v4, v6 - v12);
        if (v13 == -1)
        {
          if (*__error() != 35)
          {
            v14 = (FILE *)*MEMORY[0x24BDAC8D8];
            v15 = __error();
            v16 = strerror(*v15);
            fprintf(v14, "Could not read %ld bytes from source: %s\n", v6 - v12, v16);
            return -1;
          }
        }
        else
        {
          if (!v13)
            return v11;
          v4 += v13;
          v12 += v13;
          v11 += v13;
        }
      }
      while (v12 != v6);
    }
  }
  return v11;
}

uint64_t BOMBomHLIndexNew(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  CFMutableDictionaryRef Mutable;

  v2 = BOM_malloczero(0x20uLL);
  v3 = (uint64_t)v2;
  if (v2)
  {
    *v2 = a1;
    v4 = BOMTreeNewWithName(a1, "HLIndex");
    *(_QWORD *)(v3 + 8) = v4;
    if (!v4
      || (Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], 0),
          (*(_QWORD *)(v3 + 16) = Mutable) == 0))
    {
      BOMBomHLIndexFree(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t BOMBomHLIndexFree(uint64_t a1)
{
  const __CFDictionary *v2;
  uint64_t v3;
  size_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  if (*(_BYTE *)(a1 + 24) && BOMBomHLIndexCommit(a1))
    return 1;
  v2 = *(const __CFDictionary **)(a1 + 16);
  if (v2)
  {
    LODWORD(v3) = CFDictionaryGetCount(v2);
    v4 = 8 * v3;
    v5 = (const void **)BOM_malloc(v4);
    if (v5)
    {
      v6 = v5;
      v7 = (const void **)BOM_malloc(v4);
      if (v7)
      {
        v8 = (uint64_t *)v7;
        CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v6, v7);
        v3 = v3;
        if ((_DWORD)v3)
        {
          v9 = v8;
          do
          {
            v10 = *v9++;
            BOMTreeFree(v10);
            --v3;
          }
          while (v3);
        }
        free(v6);
        free(v8);
        CFRelease(*(CFTypeRef *)(a1 + 16));
        goto LABEL_10;
      }
    }
    return 1;
  }
LABEL_10:
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
    BOMTreeFree(v11);
  free((void *)a1);
  return 0;
}

uint64_t BOMBomHLIndexOpen(uint64_t a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  CFMutableDictionaryRef Mutable;

  v4 = BOM_malloczero(0x20uLL);
  v5 = (uint64_t)v4;
  if (v4)
  {
    *v4 = a1;
    v6 = BOMTreeOpenWithName(a1, "HLIndex", a2);
    *(_QWORD *)(v5 + 8) = v6;
    if (!v6
      || a2
      && (Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], 0),
          (*(_QWORD *)(v5 + 16) = Mutable) == 0))
    {
      BOMBomHLIndexFree(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t BOMBomHLIndexCommit(uint64_t a1)
{
  const __CFDictionary *v2;
  unsigned int Count;
  size_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  const void **v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t result;

  if (!*(_BYTE *)(a1 + 24))
    return 0;
  v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2)
    goto LABEL_10;
  Count = CFDictionaryGetCount(v2);
  v4 = 8 * Count;
  v5 = (const void **)BOM_malloc(v4);
  if (v5)
  {
    v6 = v5;
    v7 = (const void **)BOM_malloc(v4);
    if (v7)
    {
      v8 = v7;
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v6, v7);
      v9 = Count;
      if (Count)
      {
        v10 = 0;
        v11 = 8 * v9;
        while (!BOMTreeCommit((uint64_t)v8[v10 / 8]))
        {
          v10 += 8;
          if (v11 == v10)
            goto LABEL_9;
        }
        free(v6);
        free(v8);
        return 1;
      }
LABEL_9:
      free(v6);
      free(v8);
LABEL_10:
      result = BOMTreeCommit(*(_QWORD *)(a1 + 8));
      if (!(_DWORD)result)
      {
        *(_BYTE *)(a1 + 24) = 0;
        return result;
      }
    }
  }
  return 1;
}

uint64_t BOMBomHLIndexCount(uint64_t a1, unsigned int a2)
{
  const void *TreeFor;
  uint64_t v3;
  char v5;

  v5 = 0;
  if (!a1)
    return 0;
  if (a2)
  {
    TreeFor = _hl_findTreeFor(a1, a2, &v5);
    if (TreeFor)
      goto LABEL_4;
    return 0;
  }
  TreeFor = *(const void **)(a1 + 8);
  if (!TreeFor)
    return 0;
LABEL_4:
  v3 = BOMTreeCount((uint64_t)TreeFor);
  if (v5)
    BOMTreeFree((uint64_t)TreeFor);
  return v3;
}

const void *_hl_findTreeFor(uint64_t a1, unsigned int a2, char *a3)
{
  unsigned int v4;
  int IsOpenForWriting;
  CFNumberRef v7;
  CFNumberRef v8;
  const void *Value;
  uint64_t v10;
  _QWORD *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  CFNumberRef v17;
  CFNumberRef v18;
  char v19;
  unsigned int v21;
  unsigned int valuePtr;

  v4 = a2;
  valuePtr = a2;
  IsOpenForWriting = BOMStorageIsOpenForWriting(*(_QWORD *)a1);
  if (*(_QWORD *)(a1 + 16))
  {
    v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
    if (!v7)
      return 0;
    v8 = v7;
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v7);
    CFRelease(v8);
    if (Value)
      return Value;
    v4 = valuePtr;
  }
  valuePtr = bswap32(v4);
  v10 = *(_QWORD *)a1;
  v11 = *(_QWORD **)(a1 + 8);
  v12 = (unsigned int *)BOMTreeGetValue((uint64_t)v11, &valuePtr, 4uLL);
  if (v12)
  {
    v13 = *v12;
    v14 = bswap32(*v12);
    v21 = v14;
    if (!v13)
      return 0;
    Value = (const void *)BOMTreeOpen(v10, v14, IsOpenForWriting);
    if (!Value)
    {
LABEL_18:
      if (a3)
      {
        v19 = 1;
        goto LABEL_20;
      }
      return Value;
    }
  }
  else
  {
    if (!IsOpenForWriting)
      return 0;
    v15 = BOMStorageNewBlock(v10);
    if (!v15)
      return 0;
    v16 = v15;
    Value = BOMTreeNewWithOptions(v10, v15, 0, 0x40u, 0);
    if (!Value)
      goto LABEL_18;
    v21 = bswap32(v16);
    BOMTreeSetValue(v11, &valuePtr, 4uLL, (uint64_t)&v21, 4);
  }
  if (!*(_QWORD *)(a1 + 16))
    goto LABEL_18;
  valuePtr = bswap32(valuePtr);
  v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
  if (!v17)
    return 0;
  v18 = v17;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v17, Value);
  CFRelease(v18);
  if (a3)
  {
    v19 = 0;
LABEL_20:
    *a3 = v19;
  }
  return Value;
}

uint64_t BOMBomHLIndexBlock(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  char *v4;
  char *i;
  unsigned int *v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v2 = a2;
  if (BOMTreeCount(*(_QWORD *)(a1 + 8)) <= a2)
    return 0;
  v4 = (char *)BOMTreeIteratorNew(*(_QWORD *)(a1 + 8), 0, 0, 0);
  if (!v4)
    return 0;
  for (i = v4; v2; --v2)
    BOMTreeIteratorNext((uint64_t)i);
  v6 = (unsigned int *)BOMTreeIteratorKey((uint64_t)i);
  if (v6)
    v7 = bswap32(*v6);
  else
    v7 = 0;
  BOMTreeIteratorFree(i);
  return v7;
}

uint64_t BOMBomHLIndexGet(uint64_t a1, unsigned int a2, unsigned int a3, void *a4, size_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  const void *TreeFor;
  char *v11;
  char *i;
  const void *v13;
  char v15;

  v5 = 0;
  v15 = 0;
  v6 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a5)
      {
        TreeFor = _hl_findTreeFor(a1, a2, &v15);
        v5 = (uint64_t)TreeFor;
        if (TreeFor)
        {
          if (BOMTreeCount((uint64_t)TreeFor) > a3)
          {
            v11 = (char *)BOMTreeIteratorNew(v5, 0, 0, 0);
            if (v11)
            {
              for (i = v11; a3; --a3)
                BOMTreeIteratorNext((uint64_t)i);
              *a5 = BOMTreeIteratorKeySize((uint64_t)i);
              v13 = (const void *)BOMTreeIteratorKey((uint64_t)i);
              memmove(a4, v13, *a5);
              BOMTreeIteratorFree(i);
              v6 = 0;
            }
          }
        }
      }
    }
  }
  if (v15)
    BOMTreeFree(v5);
  return v6;
}

uint64_t BOMBomHLIndexSet(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *TreeFor;
  uint64_t v10;
  char v12;

  v4 = 0;
  v12 = 0;
  v5 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        TreeFor = _hl_findTreeFor(a1, a2, &v12);
        v4 = (uint64_t)TreeFor;
        if (TreeFor)
        {
          v10 = BOMTreeSetValue(TreeFor, a3, a4, 0, 0);
          *(_BYTE *)(a1 + 24) = 1;
          v5 = v10;
        }
      }
    }
  }
  if (v12)
    BOMTreeFree(v4);
  return v5;
}

uint64_t BOMBomHLIndexRemove(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  uint64_t v4;
  const void *TreeFor;
  uint64_t v9;
  CFNumberRef v10;
  CFNumberRef v11;
  __CFDictionary *v12;
  char v14;
  unsigned int valuePtr;

  valuePtr = a2;
  v14 = 0;
  v4 = 1;
  if (!a1 || !a2)
    return v4;
  TreeFor = _hl_findTreeFor(a1, a2, &v14);
  v9 = (uint64_t)TreeFor;
  if (TreeFor)
  {
    if (a3)
    {
      v4 = BOMTreeRemoveValue((uint64_t)TreeFor, a3, a4);
    }
    else
    {
      v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
      if (!v10)
        goto LABEL_11;
      v11 = v10;
      v12 = *(__CFDictionary **)(a1 + 16);
      if (v12)
        CFDictionaryRemoveValue(v12, v11);
      CFRelease(v11);
      BOMTreeRemoveAndFree(v9);
      v4 = 0;
    }
    *(_BYTE *)(a1 + 24) = 1;
  }
LABEL_11:
  if (v14)
    BOMTreeFree(v9);
  return v4;
}

uint64_t _BOMBomHLIndexPrintDiagnostics(uint64_t result)
{
  uint64_t v1;
  FILE **v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v1 = *(_QWORD *)(result + 8);
    v2 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Tree: %s\n", "HLIndex");
    result = (uint64_t)BOMTreeIteratorNew(v1, 0, 0, 0);
    if (result)
    {
      v3 = result;
      v4 = 0;
      if (BOMTreeIteratorIsAtEnd(result))
      {
LABEL_4:
        fprintf(*v2, "   # records: %d\n", v4);
        fprintf(*v2, "   # pages  : %d (%d)\n", 0, 0);
        fprintf(*v2, "     leaf   : %d (%d)\n", 0, 0);
        fprintf(*v2, "     branch : %d (%d)\n", 0, 0);
        fprintf(*v2, "   key size : %zd\n", 0);
        return fprintf(*v2, "   data size: %zd\n", 0);
      }
      else
      {
        while (1)
        {
          result = BOMTreeIteratorValue(v3);
          if (!result)
            break;
          if (!*(_DWORD *)result)
            break;
          v5 = bswap32(*(_DWORD *)result);
          v6 = BOMTreeStorage(v1);
          result = BOMTreeOpen(v6, v5, 0);
          if (!result)
            break;
          v7 = result;
          v4 += BOMTreeCount(result);
          BOMTreeFree(v7);
          BOMTreeIteratorNext(v3);
          if (BOMTreeIteratorIsAtEnd(v3))
            goto LABEL_4;
        }
      }
    }
  }
  return result;
}

uint64_t _BOMBomPrint(uint64_t a1)
{
  unsigned int *RootFSObject;
  char *v3;
  _DWORD *v4;
  _DWORD *v5;
  FILE **v6;
  const char *v7;
  int v8;
  int v9;

  if (!a1)
    return 1;
  RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a1);
  v3 = BOMBomEnumeratorNew(a1, RootFSObject);
  BOMFSObjectFree((uint64_t)RootFSObject);
  if (!v3)
    return 1;
  v4 = BOMBomEnumeratorNext((uint64_t)v3);
  if (v4)
  {
    v5 = v4;
    v6 = (FILE **)MEMORY[0x24BDAC8D8];
    do
    {
      v7 = (const char *)BOMFSObjectPathName((uint64_t)v5);
      v8 = BOMFSObjectPathID((uint64_t)v5);
      v9 = BOMFSObjectParentPathID((uint64_t)v5);
      fprintf(*v6, "%d\t%d\t%s\n", v9, v8, v7);
      BOMFSObjectFree((uint64_t)v5);
      v5 = BOMBomEnumeratorNext((uint64_t)v3);
    }
    while (v5);
  }
  BOMBomEnumeratorFree(v3);
  return 0;
}

uint64_t _BOMBomPathTreePrint(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  char *v3;
  char *v4;
  char *v5;
  FILE **v6;
  unsigned int *v7;
  unsigned int *v8;
  FILE *v9;
  unsigned int v10;
  const char *v11;
  unsigned int v12;
  int v13;
  size_t v15;

  if (!a1)
    return 1;
  v1 = BOMBomPathsTree(a1);
  if (!v1)
    return 1;
  v2 = v1;
  v15 = 0;
  v3 = BOMNewPathKey(0, "", &v15);
  if (!v3)
    return 1;
  v4 = v3;
  v5 = (char *)BOMTreeIteratorNew(v2, v3, v15, 0);
  free(v4);
  if (!v5)
    return 1;
  if (!BOMTreeIteratorIsAtEnd((uint64_t)v5))
  {
    v6 = (FILE **)MEMORY[0x24BDAC8D8];
    do
    {
      v7 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v5);
      v8 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v5);
      v9 = *v6;
      v10 = BOMPathIDFromPathKey(v7);
      v11 = (const char *)BOMShortNameFromPathKey((uint64_t)v7);
      v12 = BOMPathIDFromPathKey(v8);
      v13 = BOMBlockIDFromPathValue((uint64_t)v8);
      fprintf(v9, "%d\t%s -> %d\t%d\n", v10, v11, v12, v13);
      BOMTreeIteratorNext((uint64_t)v5);
    }
    while (!BOMTreeIteratorIsAtEnd((uint64_t)v5));
  }
  BOMTreeIteratorFree(v5);
  return 0;
}

uint64_t _BOMCFArrayPrint(const __CFArray *a1)
{
  CFTypeID TypeID;
  int Count;
  CFIndex v4;
  uint64_t v5;
  FILE **v6;
  FILE *v7;
  const char *ValueAtIndex;
  uint64_t v9;

  if (!a1)
    return 1;
  TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      v4 = 0;
      v5 = Count;
      v6 = (FILE **)MEMORY[0x24BDAC8D8];
      do
      {
        v7 = *v6;
        ValueAtIndex = (const char *)CFArrayGetValueAtIndex(a1, v4);
        fprintf(v7, "%d\t%s\n", v4++, ValueAtIndex);
      }
      while (v5 != v4);
    }
    return 0;
  }
  else
  {
    v9 = 1;
    fwrite("[not an array]\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v9;
}

uint64_t BOMCopierNew()
{
  return BOMCopierNewWithSys(0);
}

uint64_t BOMCopierNewWithSys(void *a1)
{
  void *v2;
  uint64_t v3;
  void *v5;
  void *v6;
  void **v7;

  v2 = BOM_malloczero(0x3308uLL);
  v3 = (uint64_t)v2;
  if (v2)
  {
    *((_DWORD *)v2 + 4) = 0x20000;
    if (vm_allocate(*MEMORY[0x24BDAEC58], (vm_address_t *)v2 + 1, 0x20000uLL, 1))
    {
      BOMCopierFree(v3);
      return 0;
    }
    else
    {
      *(_QWORD *)(v3 + 24) = 4096;
      v5 = malloc_type_calloc(1uLL, 0x1000uLL, 0x18A1ECF8uLL);
      *(_QWORD *)(v3 + 32) = v5;
      if (v5)
      {
        *(_DWORD *)(v3 + 10568) = getpid();
        *(_BYTE *)(v3 + 2304) = 0;
        *(_BYTE *)(v3 + 6400) = 0;
        *(_DWORD *)(v3 + 12792) = -1;
        v6 = BOMHardLinkTableNew();
        *(_QWORD *)v3 = v6;
        if (v6)
        {
          v7 = BOMStackNew();
          *(_QWORD *)(v3 + 40) = v7;
          if (v7)
          {
            if (!a1)
              a1 = BomSys_default();
            *(_QWORD *)(v3 + 12832) = a1;
          }
        }
      }
    }
  }
  return v3;
}

void BOMCopierFree(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void **v5;

  if (a1)
  {
    _resetCopier(a1);
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      MEMORY[0x20BCF4590](*MEMORY[0x24BDAEC58], v2, *(int *)(a1 + 16));
      *(_QWORD *)(a1 + 8) = 0;
    }
    v3 = *(void **)(a1 + 32);
    if (v3)
    {
      free(v3);
      *(_QWORD *)(a1 + 32) = 0;
    }
    if (*(_QWORD *)a1)
    {
      BOMHardLinkTableFree(*(const void ***)a1);
      *(_QWORD *)a1 = 0;
    }
    v4 = *(_QWORD *)(a1 + 40);
    if (v4)
    {
      while (!BOMStackIsEmpty(v4))
      {
        v5 = (void **)BOMStackPop(*(uint64_t **)(a1 + 40));
        free(*v5);
        free(v5[1]);
        free(v5[2]);
        free(v5);
        v4 = *(_QWORD *)(a1 + 40);
      }
      BOMStackFree(*(void ***)(a1 + 40));
    }
    free((void *)a1);
  }
}

void _resetCopier(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  uint64_t *v16;
  _QWORD *v17;
  void *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  const void *v27;
  unsigned int *v28;
  const void *v29;
  void *v30;
  const void *v31;

  if (a1)
  {
    v3 = (_QWORD *)(a1 + 216);
    v2 = *(void **)(a1 + 216);
    if (v2)
    {
      free(v2);
      *v3 = 0;
      v3[1] = 0;
    }
    v4 = *(void **)(a1 + 12928);
    if (v4)
    {
      free(v4);
      *(_QWORD *)(a1 + 12928) = 0;
    }
    v5 = *(void **)(a1 + 12920);
    if (v5)
    {
      free(v5);
      *(_QWORD *)(a1 + 12920) = 0;
    }
    v6 = *(void **)(a1 + 12936);
    if (v6)
    {
      free(v6);
      *(_QWORD *)(a1 + 12936) = 0;
    }
    v7 = *(void **)(a1 + 10584);
    if (v7)
    {
      free(v7);
      *(_QWORD *)(a1 + 10584) = 0;
    }
    v8 = *(void **)(a1 + 12912);
    if (v8)
    {
      free(v8);
      *(_QWORD *)(a1 + 12912) = 0;
    }
    v9 = *(void **)(a1 + 12904);
    if (v9)
    {
      free(v9);
      *(_QWORD *)(a1 + 12904) = 0;
    }
    v10 = *(void **)(a1 + 12896);
    if (v10)
    {
      free(v10);
      *(_QWORD *)(a1 + 12896) = 0;
    }
    v11 = *(_QWORD *)(a1 + 152);
    if (v11)
    {
      BOMBomFree(v11);
      *(_QWORD *)(a1 + 152) = 0;
    }
    v12 = *(_QWORD *)(a1 + 160);
    if (v12)
    {
      BOMBomFree(v12);
      *(_QWORD *)(a1 + 160) = 0;
    }
    v14 = (_QWORD *)(a1 + 176);
    v13 = *(_QWORD *)(a1 + 176);
    if (v13)
    {
      BOMFileClose(v13);
      *v14 = 0;
    }
    v15 = *(void **)(a1 + 184);
    if (v15)
    {
      BOMPatternFree(v15);
      *(_QWORD *)(a1 + 184) = 0;
    }
    v16 = *(uint64_t **)(a1 + 12736);
    if (v16)
    {
      BOMCPIOFree(v16);
      *(_QWORD *)(a1 + 12736) = 0;
    }
    v17 = *(_QWORD **)(a1 + 12760);
    if (v17)
    {
      BOMPKZipFree(v17);
      *(_QWORD *)(a1 + 12760) = 0;
    }
    if (*(_QWORD *)(a1 + 12840))
      BOMCopierSandbox_unbox(a1);
    v18 = *(void **)(a1 + 136);
    if (v18)
    {
      v19 = *(unsigned int *)(a1 + 144);
      if ((_DWORD)v19)
      {
        v20 = 0;
        v21 = 16;
        do
        {
          v22 = *(void **)(*(_QWORD *)(a1 + 136) + v21);
          if (v22)
          {
            free(v22);
            v19 = *(unsigned int *)(a1 + 144);
          }
          ++v20;
          v21 += 32;
        }
        while (v20 < v19);
        v18 = *(void **)(a1 + 136);
      }
      free(v18);
      *(_QWORD *)(a1 + 136) = 0;
    }
    v23 = *(_QWORD *)(a1 + 152);
    if (v23)
    {
      BOMBomFree(v23);
      *(_QWORD *)(a1 + 152) = 0;
    }
    v24 = *(_QWORD *)(a1 + 160);
    if (v24)
    {
      BOMBomFree(v24);
      *(_QWORD *)(a1 + 160) = 0;
    }
    v25 = *(void **)(a1 + 184);
    if (v25)
    {
      BOMPatternFree(v25);
      *(_QWORD *)(a1 + 184) = 0;
    }
    v26 = *(void **)(a1 + 12800);
    if (v26)
    {
      free(v26);
      *(_QWORD *)(a1 + 12800) = 0;
    }
    *(_DWORD *)(a1 + 10564) = 0;
    v27 = *(const void **)(a1 + 12856);
    if (v27)
    {
      CFRelease(v27);
      *(_QWORD *)(a1 + 12856) = 0;
    }
    bzero((void *)(a1 + 248), 0x400uLL);
    bzero((void *)(a1 + 1272), 0x400uLL);
    *(_QWORD *)(a1 + 2296) = 0;
    bzero((void *)(a1 + 2304), 0x400uLL);
    bzero((void *)(a1 + 3328), 0x400uLL);
    bzero((void *)(a1 + 4352), 0x400uLL);
    bzero((void *)(a1 + 5376), 0x400uLL);
    bzero((void *)(a1 + 6400), 0x400uLL);
    bzero((void *)(a1 + 7424), 0x400uLL);
    bzero((void *)(a1 + 8448), 0x400uLL);
    *(_DWORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 168) = 0;
    *(_WORD *)(a1 + 172) = 0;
    *(_QWORD *)(a1 + 12712) = 0x300000000;
    *(_BYTE *)(a1 + 12720) = 0;
    *(_WORD *)(a1 + 12768) = 256;
    *v14 = 0;
    *(_QWORD *)(a1 + 184) = 0;
    *(_WORD *)(a1 + 192) = 1;
    *(_DWORD *)(a1 + 232) = 0;
    *(_WORD *)(a1 + 12813) = 257;
    *(_WORD *)(a1 + 12744) = 0;
    *(_BYTE *)(a1 + 12746) = 0;
    *(_DWORD *)(a1 + 12816) = 2;
    *(_WORD *)(a1 + 12822) = 0;
    *(_BYTE *)(a1 + 12824) = 0;
    *(_QWORD *)(a1 + 12960) = 0;
    *(_QWORD *)(a1 + 12976) = 0;
    *(_QWORD *)(a1 + 12984) = -1;
    *(_DWORD *)(a1 + 212) = -1;
    v28 = *(unsigned int **)(a1 + 13032);
    if (v28)
    {
      BOMCopierDestinationFree(v28);
      *(_QWORD *)(a1 + 13032) = 0;
    }
    v29 = *(const void **)(a1 + 13008);
    if (v29)
    {
      CFRelease(v29);
      *(_QWORD *)(a1 + 13008) = 0;
    }
    v30 = *(void **)(a1 + 13016);
    if (v30)
    {
      BOMCopierSourceFree(v30);
      *(_QWORD *)(a1 + 13016) = 0;
      v31 = *(const void **)(a1 + 13008);
      if (v31)
      {
        CFRelease(v31);
        *(_QWORD *)(a1 + 13008) = 0;
      }
    }
  }
}

uint64_t BOMCopierCopy(uint64_t a1, char *a2, char *a3)
{
  return BOMCopierCopyWithOptions(a1, a2, a3, 0);
}

uint64_t BOMCopierCopyWithOptions(uint64_t a1, char *a2, char *a3, const void *a4)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFTypeID v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFTypeID TypeID;
  const void *Value;
  const void *v25;
  CFTypeID v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  char *v36;
  int v37;
  _QWORD *v38;
  uint64_t v39;
  int *v40;
  void (*v41)(uint64_t, const char *, uint64_t);
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  int *v45;
  const void *v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  _BYTE v57[1024];
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    _resetCopier(a1);
    *__error() = 0;
    v8 = getenv("DITTO2");
    if (v8)
    {
      if (strcmp(v8, "1"))
      {
        if (!a4)
          goto LABEL_15;
        goto LABEL_5;
      }
    }
    else
    {
      if (!a4)
        goto LABEL_15;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(a4))
        goto LABEL_18;
      Value = CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("DITTO2"));
      if (!Value
        || (v25 = Value, v26 = CFBooleanGetTypeID(), v26 != CFGetTypeID(v25))
        || !CFEqual(v25, (CFTypeRef)*MEMORY[0x24BDBD270]))
      {
LABEL_5:
        v14 = CFDictionaryGetTypeID();
        if (v14 == CFGetTypeID(a4))
        {
          if (_parseCopierOptions(a1, (const __CFDictionary *)a4))
          {
            BOMCopierNotifyFatalError(a1, "Could not parse the options dictionary", v21, v9, v10, v11, v12, v13, v56);
LABEL_17:
            _resetCopier(a1);
            return 1;
          }
LABEL_15:
          if (_verifyCopierOptions(a1, (uint64_t)a2, (uint64_t)a3, v9, v10, v11, v12, v13)
            || _prepareCopierState(a1))
          {
            goto LABEL_17;
          }
          v34 = *(_DWORD *)(a1 + 12712);
          if (v34)
          {
            v35 = *(_DWORD *)(a1 + 12964);
            *(_DWORD *)(a1 + 12992) = v35;
            if (!*(_BYTE *)(a1 + 12813))
            {
              v35 |= 0x10u;
              *(_DWORD *)(a1 + 12992) = v35;
            }
            if (v34 == 1)
            {
              v36 = getenv("BOM_ASYNC");
              if (!v36 || strcmp("0", v36))
              {
                v35 |= 0x20u;
                *(_DWORD *)(a1 + 12992) = v35;
              }
            }
            if (a2)
            {
              v37 = strcmp("-", a2);
              v38 = (_QWORD *)(a1 + 12976);
              if (v37)
              {
                if (!BOMFileOpenWithSys(v38, (uint64_t)a2, 0, 0, v35, *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))goto LABEL_49;
                goto LABEL_41;
              }
              if (BOMFileOpenSTDIN(v38, v35))
              {
LABEL_41:
                v45 = __error();
                v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
                if (!v41)
                  goto LABEL_17;
                v42 = *v45;
                v43 = a1;
                v44 = a2;
                goto LABEL_43;
              }
            }
            else
            {
              v39 = *(unsigned int *)(a1 + 12984);
              if ((_DWORD)v39 == -1)
              {
                v46 = *(const void **)(a1 + 12944);
                if (v46 && BOMFileNewFromCFReadStream((_QWORD *)(a1 + 12976), v46, v35))
                {
                  v47 = __error();
                  v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
                  if (!v41)
                    goto LABEL_17;
                  v42 = *v47;
                  v44 = "CFReadStream";
                  v43 = a1;
                  goto LABEL_43;
                }
              }
              else if (BOMFileNewFromFDWithSys((_QWORD *)(a1 + 12976), v39, v35, "rb", *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
              {
                v40 = __error();
                v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
                if (!v41)
                  goto LABEL_17;
                v42 = *v40;
                v43 = a1;
                v44 = 0;
LABEL_43:
                v41(v43, v44, v42);
                goto LABEL_17;
              }
            }
          }
          else
          {
            if (!a2)
            {
              BOMCopierNotifyFatalError(a1, "If the source is a filesystem, the fromObj argument cannot be nil", v28, v29, v30, v31, v32, v33, v56);
              _resetCopier(a1);
              goto LABEL_17;
            }
            if (*(_BYTE *)(a1 + 12968))
            {
              v28 = *(_QWORD *)(a1 + 152);
              if (v28)
                BOMCopierSandbox_boxup(a1, a2, v28);
            }
          }
LABEL_49:
          if (*(_DWORD *)(a1 + 12712)
            || (_BYTE *)(*(uint64_t (**)(_QWORD, char *, _BYTE *))(*(_QWORD *)(a1 + 12832) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v57) == v57)
          {
            if (!_prepareCopierDestination(a1, a3, v28, v29, v30, v31, v32, v33))
            {
              v22 = 1;
              switch(*(_DWORD *)(a1 + 12712))
              {
                case 0:
                  v55 = _BOMCopierCopyFromFilesystem(a1, a2, a3);
                  goto LABEL_57;
                case 1:
                  v55 = _BOMCopierCopyFromCPIO(a1, *(_QWORD *)(a1 + 12976), a3, v50, v51, v52, v53, v54);
                  goto LABEL_57;
                case 2:
                  v55 = _BOMCopierCopyFromPKZip(a1, *(_QWORD *)(a1 + 12976), a3, v50, v51, v52, v53, v54);
LABEL_57:
                  v22 = v55;
                  if (!(_DWORD)v55)
                    goto LABEL_58;
                  goto LABEL_59;
                case 3:
                  goto LABEL_59;
                default:
LABEL_58:
                  v22 = _finalizeCopierDestination(a1, v48, v49, v50, v51, v52, v53, v54);
LABEL_59:
                  _resetCopier(a1);
                  break;
              }
              return v22;
            }
          }
          else
          {
            BOMCopierNotifyFatalError(a1, "Cannot get the real path for source '%s'", v28, v29, v30, v31, v32, v33, (char)a2);
          }
          goto LABEL_17;
        }
LABEL_18:
        BOMCopierNotifyFatalError(a1, "The options dictionary is not a CFDictionary", v15, v16, v17, v18, v19, v20, v56);
        return 1;
      }
    }
    return BOMCopierCopyWithOptions2(a1, a2, a3, a4);
  }
  v22 = 1;
  fwrite("Invalid BOMCopier\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return v22;
}

void BOMCopierNotifyFatalError(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  FILE *v10;
  int *v11;
  FILE *v12;
  int *v13;
  char *v14;

  if (a1 && *(_QWORD *)(a1 + 56))
  {
    v14 = 0;
    if (vasprintf(&v14, a2, &a9) == -1)
    {
      v10 = (FILE *)*MEMORY[0x24BDAC8D8];
      v11 = __error();
      strerror(*v11);
      fprintf(v10, "Could not create fatal message: %s\n");
    }
    else if (v14)
    {
      (*(void (**)(uint64_t))(a1 + 56))(a1);
      free(v14);
    }
    else
    {
      v12 = (FILE *)*MEMORY[0x24BDAC8D8];
      v13 = __error();
      strerror(*v13);
      fprintf(v12, "Could not allocate fatal message: %s\n");
    }
  }
}

uint64_t _parseCopierOptions(uint64_t a1, const __CFDictionary *a2)
{
  CFTypeID TypeID;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeID v9;
  const void *Value;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *UTF8String;
  const __CFBoolean *v21;
  const __CFBoolean *v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFBoolean *v26;
  const __CFBoolean *v27;
  const __CFBoolean *v28;
  const __CFBoolean *v29;
  const __CFBoolean *v30;
  const __CFBoolean *v31;
  const void *v32;
  const void *v33;
  const __CFBoolean *v34;
  const __CFBoolean *v35;
  const __CFBoolean *v36;
  const __CFBoolean *v37;
  const __CFBoolean *v38;
  const __CFBoolean *v39;
  const __CFBoolean *v40;
  const __CFBoolean *v41;
  const __CFBoolean *v42;
  const __CFBoolean *v43;
  const __CFBoolean *v44;
  const __CFBoolean *v45;
  const __CFBoolean *v46;
  const __CFBoolean *v47;
  const __CFString *v48;
  const __CFString *v49;
  const __CFString *v50;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFBoolean *v57;
  const __CFBoolean *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  char v64;
  int v65;
  const char *v66;
  const __CFBoolean *v67;
  const __CFBoolean *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  const void *v75;
  const void *v76;
  const __CFNumber *v77;
  const __CFNumber *v78;
  const __CFBoolean *v79;
  const __CFBoolean *v80;
  unsigned __int8 v81;
  const __CFBoolean *v82;
  const __CFBoolean *v83;
  const __CFBoolean *v84;
  const __CFBoolean *v85;
  const __CFNumber *v86;
  const __CFNumber *v87;
  const __CFBoolean *v88;
  const __CFBoolean *v89;
  const __CFBoolean *v90;
  const __CFBoolean *v91;
  unsigned __int8 v92;
  const __CFDictionary *v93;
  const __CFDictionary *v94;
  const __CFBoolean *v95;
  const __CFBoolean *v96;
  const __CFDictionary *v97;
  const __CFDictionary *v98;
  const __CFBoolean *v99;
  const __CFBoolean *v100;
  const void *v101;
  const void *v102;
  const void *v103;
  const void *v104;
  const void *v105;
  const void *v106;
  CFTypeID v107;
  const void *v108;
  const void *v109;
  CFTypeID v110;
  const void *v111;
  const void *v112;
  int v113;
  const __CFBoolean *v114;
  const __CFBoolean *v115;
  const __CFBoolean *v116;
  const __CFBoolean *v117;
  const __CFString *v118;
  const __CFString *v119;
  const __CFString *v120;
  const __CFBoolean *v121;
  const __CFBoolean *v122;
  const __CFBoolean *v123;
  const __CFBoolean *v124;
  const __CFBoolean *v125;
  const __CFBoolean *v126;
  const __CFBoolean *v127;
  const __CFBoolean *v128;
  const __CFBoolean *v129;
  const __CFBoolean *v130;
  const __CFBoolean *v131;
  const __CFBoolean *v132;
  const __CFBoolean *v133;
  const __CFBoolean *v134;
  const __CFBoolean *v135;
  const __CFBoolean *v136;
  const void *v137;
  const void *v138;
  int v139;
  int v140;
  uint64_t result;
  const __CFData *v142;
  size_t Length;
  size_t v144;
  void *v145;
  void *v146;
  const UInt8 *BytePtr;
  char v148;
  CFTypeRef cf1;

  TypeID = CFArrayGetTypeID();
  v5 = CFDictionaryGetTypeID();
  v6 = CFStringGetTypeID();
  v7 = CFBooleanGetTypeID();
  v8 = CFNumberGetTypeID();
  v9 = CFDataGetTypeID();
  Value = CFDictionaryGetValue(a2, CFSTR("archs"));
  *(_QWORD *)(a1 + 12880) = Value;
  if (Value && CFGetTypeID(Value) != TypeID)
  {
    v66 = "kBOMCopierOptionArchitectureArrayKey is not a CFArrayRef";
    goto LABEL_269;
  }
  v17 = CFDictionaryGetValue(a2, CFSTR("fallbackForSubtype"));
  *(_QWORD *)(a1 + 12888) = v17;
  if (v17 && CFGetTypeID(v17) != v5)
  {
    v66 = "kBOMCopierOptionArchitectureFallbackKey is not a CFDictionaryRef";
    goto LABEL_269;
  }
  v18 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("indexbom"));
  if (v18)
  {
    v19 = v18;
    if (CFGetTypeID(v18) != v6)
    {
      v66 = "kBOMCopierOptionIndexBomKey is not a CFStringRef";
      goto LABEL_269;
    }
    UTF8String = BOMCFStringGetUTF8String(v19);
    *(_QWORD *)(a1 + 12896) = UTF8String;
    if (!UTF8String)
    {
      v66 = "Cannot convert indexbom from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  v21 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("verifyFileDataPerIndexBom"));
  if (v21)
  {
    v22 = v21;
    if (CFGetTypeID(v21) != v7)
    {
      v66 = "kBOMCopierOptionVerifyFileDataPerIndexBomKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 197) = BOMCFGetBoolValue(v22);
  }
  v23 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("skipbom"));
  if (v23)
  {
    v24 = v23;
    if (CFGetTypeID(v23) != v6)
    {
      v66 = "kBOMCopierOptionSkipBomKey is not a CFStringRef";
      goto LABEL_269;
    }
    v25 = BOMCFStringGetUTF8String(v24);
    *(_QWORD *)(a1 + 12904) = v25;
    if (!v25)
    {
      v66 = "Cannot convert skipbom from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  v26 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("sourceIsAppSandboxed"));
  if (v26)
  {
    v27 = v26;
    if (CFGetTypeID(v26) != v7)
    {
      v66 = "kBOMCopierOptionSourceIsAppSandboxed is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12968) = BOMCFGetBoolValue(v27);
  }
  v28 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("useHFSPlusCompression"));
  if (v28)
  {
    v29 = v28;
    if (CFGetTypeID(v28) != v7)
    {
      v66 = "kBOMCopierOptionUseHFSPlusCompressionKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12848) = BOMCFGetBoolValue(v29);
  }
  v30 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("preserveHFSPlusCompression"));
  if (v30)
  {
    v31 = v30;
    if (CFGetTypeID(v30) != v7)
    {
      v66 = "kBOMCopierOptionPreserveHFSPlusCompressionKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 195) = BOMCFGetBoolValue(v31);
  }
  v32 = CFDictionaryGetValue(a2, CFSTR("hfsPlusCompressionOptions"));
  if (v32)
  {
    v33 = v32;
    if (CFGetTypeID(v32) != v5)
    {
      v66 = "kBOMCopierOptionHFSPlusCompressionOptionsDictionaryKey is not a CFDictionaryRef";
      goto LABEL_269;
    }
    *(_QWORD *)(a1 + 12856) = v33;
    CFRetain(v33);
  }
  v34 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("copyResources"));
  if (v34)
  {
    v35 = v34;
    if (CFGetTypeID(v34) != v7)
    {
      v66 = "kBOMCopierOptionCopyResourcesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 169) = BOMCFGetBoolValue(v35);
  }
  v36 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("copyExtendedAttributes"));
  if (v36)
  {
    v37 = v36;
    if (CFGetTypeID(v36) != v7)
    {
      v66 = "kBOMCopierOptionCopyExtendedAttributesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 170) = BOMCFGetBoolValue(v37);
  }
  v38 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("copyACLs"));
  if (v38)
  {
    v39 = v38;
    if (CFGetTypeID(v38) != v7)
    {
      v66 = "kBOMCopierOptionCopyACLsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 171) = BOMCFGetBoolValue(v39);
  }
  v40 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("applySourcePermissions"));
  if (v40)
  {
    v41 = v40;
    if (CFGetTypeID(v40) != v7)
    {
      v66 = "kBOMCopierOptionApplySourcePermissionsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12822) = BOMCFGetBoolValue(v41);
  }
  v42 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("nonatomicCopy"));
  if (v42)
  {
    v43 = v42;
    if (CFGetTypeID(v42) != v7)
    {
      v66 = "kBOMCopierOptionNonAtomicCopyKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12823) = BOMCFGetBoolValue(v43);
  }
  v44 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("segmentLargeFiles"));
  if (v44)
  {
    v45 = v44;
    if (CFGetTypeID(v44) != v7)
    {
      v66 = "kBOMCopierOptionSegmentLargeFilesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12824) = BOMCFGetBoolValue(v45);
  }
  v46 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("keepBinaries"));
  if (v46)
  {
    v47 = v46;
    if (CFGetTypeID(v46) != v7)
    {
      v66 = "kBOMCopierOptionKeepBinariesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 173) = BOMCFGetBoolValue(v47);
  }
  v48 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("keepBinariesList"));
  if (v48)
  {
    v49 = v48;
    if (CFGetTypeID(v48) != v6)
    {
      v66 = "kBOMCopierOptionKeepBinariesListKey is not a CFStringRef";
      goto LABEL_269;
    }
    v50 = BOMCFStringGetUTF8String(v49);
    *(_QWORD *)(a1 + 12920) = v50;
    if (!v50)
    {
      v66 = "Cannot convert kBOMCopierOptionKeepBinariesListKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  v51 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("keepBinariesPattern"));
  if (v51)
  {
    v52 = v51;
    if (CFGetTypeID(v51) != v6)
    {
      v66 = "kBOMCopierOptionKeepBinariesPatternKey is not a CFStringRef";
      goto LABEL_269;
    }
    v53 = BOMCFStringGetUTF8String(v52);
    *(_QWORD *)(a1 + 12928) = v53;
    if (!v53)
    {
      v66 = "Cannot convert kBOMCopierOptionKeepBinariesPatternKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  v54 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("keepBinariesDir"));
  if (v54)
  {
    v55 = v54;
    if (CFGetTypeID(v54) != v6)
    {
      v66 = "kBOMCopierOptionKeepBinariesDirKey is not a CFStringRef";
      goto LABEL_269;
    }
    v56 = BOMCFStringGetUTF8String(v55);
    *(_QWORD *)(a1 + 12936) = v56;
    if (!v56)
    {
      v66 = "Cannot convert kBOMCopierOptionKeepBinariesDirKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  v57 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("crossDevices"));
  if (v57)
  {
    v58 = v57;
    if (CFGetTypeID(v57) != v7)
    {
      v66 = "kBOMCopierOptionCrossDevicesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 192) = BOMCFGetBoolValue(v58);
  }
  v59 = CFDictionaryGetValue(a2, CFSTR("createCPIO"));
  if (v59)
  {
    v60 = v59;
    if (CFGetTypeID(v59) != v7)
    {
      v66 = "kBOMCopierOptionCreateCPIOKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v60, (CFTypeRef)*MEMORY[0x24BDBD270]))
      *(_DWORD *)(a1 + 12716) = 4;
  }
  v61 = CFDictionaryGetValue(a2, CFSTR("extractCPIO"));
  if (v61)
  {
    v62 = v61;
    if (CFGetTypeID(v61) != v7)
    {
      v66 = "kBOMCopierOptionExtractCPIOKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v62, (CFTypeRef)*MEMORY[0x24BDBD270]))
      *(_DWORD *)(a1 + 12712) = 1;
  }
  v63 = CFDictionaryGetValue(a2, CFSTR("compressCPIO"));
  if (v63 || (v63 = CFDictionaryGetValue(a2, CFSTR("compress"))) != 0)
  {
    cf1 = v63;
    if (CFGetTypeID(v63) == v6)
    {
      if (!CFEqual(cf1, CFSTR("auto")))
      {
        if (CFEqual(cf1, CFSTR("none")))
        {
          v64 = 0;
          v65 = 0;
LABEL_103:
          *(_BYTE *)(a1 + 12720) = v64;
          *(_DWORD *)(a1 + 12964) = v65;
          goto LABEL_104;
        }
        if (CFEqual(cf1, CFSTR("gzip")))
        {
          v64 = 1;
          v65 = 1;
          goto LABEL_103;
        }
        if (!CFEqual(cf1, CFSTR("bzip2")))
        {
          v66 = "Unknown compression type";
          goto LABEL_269;
        }
        v65 = 2;
LABEL_102:
        v64 = 1;
        goto LABEL_103;
      }
    }
    else if (!CFEqual(cf1, (CFTypeRef)*MEMORY[0x24BDBD270]))
    {
      goto LABEL_104;
    }
    v65 = 8;
    goto LABEL_102;
  }
LABEL_104:
  v67 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("applyIndexBomOwnership"));
  if (v67)
  {
    v68 = v67;
    if (CFGetTypeID(v67) != v7)
    {
      v66 = "kBOMCopierOptionApplyIndexBomOwnershipKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12746) = BOMCFGetBoolValue(v68);
  }
  v69 = CFDictionaryGetValue(a2, CFSTR("createPKZip"));
  if (v69)
  {
    v70 = v69;
    if (CFGetTypeID(v69) != v7)
    {
      v66 = "kBOMCopierOptionCreatePKZipKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v70, (CFTypeRef)*MEMORY[0x24BDBD270]))
      *(_DWORD *)(a1 + 12716) = 5;
  }
  v71 = CFDictionaryGetValue(a2, CFSTR("extractPKZip"));
  if (v71)
  {
    v72 = v71;
    if (CFGetTypeID(v71) != v7)
    {
      v66 = "kBOMCopierOptionExtractPKZipKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v72, (CFTypeRef)*MEMORY[0x24BDBD270]))
    {
      *(_DWORD *)(a1 + 12712) = 2;
      *(_BYTE *)(a1 + 12768) = *(_BYTE *)(a1 + 169);
    }
  }
  v73 = CFDictionaryGetValue(a2, CFSTR("extractAppleArchive"));
  if (v73)
  {
    v74 = v73;
    if (CFGetTypeID(v73) != v7)
    {
      v66 = "kBOMCopierOptionExtractAppleArchiveKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v74, (CFTypeRef)*MEMORY[0x24BDBD270]))
      *(_DWORD *)(a1 + 12712) = 3;
  }
  v75 = CFDictionaryGetValue(a2, CFSTR("createAppleArchive"));
  if (v75)
  {
    v76 = v75;
    if (CFGetTypeID(v75) != v7)
    {
      v66 = "kBOMCopierOptionCreateAppleArchiveKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v76, (CFTypeRef)*MEMORY[0x24BDBD270]))
      *(_DWORD *)(a1 + 12716) = 6;
  }
  v77 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("zlibCompressionLevel"));
  if (v77)
  {
    v78 = v77;
    if (CFGetTypeID(v77) != v8)
    {
      v66 = "kBOMCopierOptionZlibCompressionLevel is not a CFNumberRef";
      goto LABEL_269;
    }
    CFNumberGetValue(v78, kCFNumberSInt32Type, (void *)(a1 + 12792));
  }
  v79 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("sequesterResources"));
  if (v79)
  {
    v80 = v79;
    if (CFGetTypeID(v79) != v7)
    {
      v66 = "kBOMCopierOptionSequesterResourcesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    v81 = BOMCFGetBoolValue(v80);
    *(_BYTE *)(a1 + 12768) = v81;
    *(_BYTE *)(a1 + 169) = v81;
  }
  v82 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("skipCPIOTerminator"));
  if (v82)
  {
    v83 = v82;
    if (CFGetTypeID(v82) != v7)
    {
      v66 = "kBOMCopierOptionSkipCPIOTerminatorKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12744) = BOMCFGetBoolValue(v83);
  }
  v84 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("skipCPIORoot"));
  if (v84)
  {
    v85 = v84;
    if (CFGetTypeID(v84) != v7)
    {
      v66 = "kBOMCopierOptionSkipCPIORootKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12745) = BOMCFGetBoolValue(v85);
  }
  v86 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("initialCPIOInode"));
  if (v86)
  {
    v87 = v86;
    if (CFGetTypeID(v86) != v8)
    {
      v66 = "kBOMCopierOptionInitialCPIOInodeRootKey is not a CFNumberRef";
      goto LABEL_269;
    }
    CFNumberGetValue(v87, kCFNumberSInt32Type, (void *)(a1 + 12960));
  }
  v88 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("keepParent"));
  if (v88)
  {
    v89 = v88;
    if (CFGetTypeID(v88) != v7)
    {
      v66 = "kBOMCopierOptionKeepParentKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 193) = BOMCFGetBoolValue(v89);
  }
  v90 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("useFilesystemCache"));
  if (v90)
  {
    v91 = v90;
    if (CFGetTypeID(v90) != v7)
      goto LABEL_186;
    v92 = BOMCFGetBoolValue(v91);
    *(_BYTE *)(a1 + 12813) = v92;
    *(_BYTE *)(a1 + 12814) = v92;
  }
  v93 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("sourceOptions"));
  if (v93)
  {
    v94 = v93;
    if (CFGetTypeID(v93) != v5)
    {
      v66 = "kBOMCopierOptionSourceOptionsDictionaryKey is not a CFDictionaryRef";
      goto LABEL_269;
    }
    v95 = (const __CFBoolean *)CFDictionaryGetValue(v94, CFSTR("useFilesystemCache"));
    if (v95)
    {
      v96 = v95;
      if (CFGetTypeID(v95) != v7)
        goto LABEL_186;
      *(_BYTE *)(a1 + 12813) = BOMCFGetBoolValue(v96);
    }
  }
  v97 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("destinationOptions"));
  if (!v97)
    goto LABEL_154;
  v98 = v97;
  if (CFGetTypeID(v97) != v5)
  {
    v66 = "kBOMCopierOptionDestinationOptionsDictionaryKey is not a CFDictionaryRef";
    goto LABEL_269;
  }
  v99 = (const __CFBoolean *)CFDictionaryGetValue(v98, CFSTR("useFilesystemCache"));
  if (!v99)
    goto LABEL_154;
  v100 = v99;
  if (CFGetTypeID(v99) != v7)
  {
LABEL_186:
    v66 = "kBOMCopierOptionUseFilesystemCacheKey is not a CFBooleanRef";
    goto LABEL_269;
  }
  *(_BYTE *)(a1 + 12814) = BOMCFGetBoolValue(v100);
LABEL_154:
  v101 = CFDictionaryGetValue(a2, CFSTR("inputFD"));
  if (v101)
  {
    v102 = v101;
    if (CFGetTypeID(v101) != v8)
    {
      v66 = "kBOMCopierOptionInputFileDescriptorKey is not a CFNumberRef";
      goto LABEL_269;
    }
    *(_DWORD *)(a1 + 12984) = BOMCFGetIntValue(v102);
  }
  v103 = CFDictionaryGetValue(a2, CFSTR("outputFD"));
  if (v103)
  {
    v104 = v103;
    if (CFGetTypeID(v103) != v8)
    {
      v66 = "kBOMCopierOptionOutputFileDescriptorKey is not a CFNumberRef";
      goto LABEL_269;
    }
    *(_DWORD *)(a1 + 12988) = BOMCFGetIntValue(v104);
  }
  v105 = CFDictionaryGetValue(a2, CFSTR("inputStream"));
  if (v105)
  {
    v106 = v105;
    v107 = CFGetTypeID(v105);
    if (v107 != CFReadStreamGetTypeID())
    {
      v66 = "kBOMCopierOptionInputCFReadStreamKey is not a CFReadStreamRef";
      goto LABEL_269;
    }
    *(_QWORD *)(a1 + 12944) = v106;
  }
  v108 = CFDictionaryGetValue(a2, CFSTR("outputStream"));
  if (v108)
  {
    v109 = v108;
    v110 = CFGetTypeID(v108);
    if (v110 != CFWriteStreamGetTypeID())
    {
      v66 = "kBOMCopierOptionOutputCFWriteStreamKey is not a CFWriteStreamRef";
      goto LABEL_269;
    }
    *(_QWORD *)(a1 + 12952) = v109;
  }
  v111 = CFDictionaryGetValue(a2, CFSTR("symlinkTreatment"));
  if (v111)
  {
    v112 = v111;
    if (CFGetTypeID(v111) != v6)
    {
      v66 = "kBOMCopierOptionSymlinkTreatmentKey is not a CFStringRef";
      goto LABEL_269;
    }
    if (CFEqual(v112, CFSTR("unlink")))
    {
      v113 = 0;
    }
    else if (CFEqual(v112, CFSTR("follow")))
    {
      v113 = 1;
    }
    else
    {
      if (!CFEqual(v112, CFSTR("error")))
      {
        v66 = "Unknown value for kBOMCopierOptionSymlinkTreatmentKey";
        goto LABEL_269;
      }
      v113 = 2;
    }
    *(_DWORD *)(a1 + 12816) = v113;
  }
  v114 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("enforceDestinationEncapsulation"));
  if (v114)
  {
    v115 = v114;
    if (CFGetTypeID(v114) != v7)
    {
      v66 = "kBOMCopierOptionEnforceDestinationEncapsulationKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12820) = BOMCFGetBoolValue(v115);
  }
  v116 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("enforceDestinationLocation"));
  if (v116)
  {
    v117 = v116;
    if (CFGetTypeID(v116) != v7)
    {
      v66 = "kBOMCopierOptionEnforceDestinationLocationKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12821) = BOMCFGetBoolValue(v117);
  }
  v118 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("zipFileEncryptionKey"));
  if (v118)
  {
    v119 = v118;
    if (CFGetTypeID(v118) != v6)
    {
      v66 = "kBOMCopierOptionEncryptionKey is not a CFStringRef";
      goto LABEL_269;
    }
    v120 = BOMCFStringGetUTF8String(v119);
    *(_QWORD *)(a1 + 12800) = v120;
    if (!v120)
    {
      v66 = "Cannot convert kBOMCopierOptionEncryptionKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  v121 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("persistRestrictedFlags"));
  if (v121)
  {
    v122 = v121;
    if (CFGetTypeID(v121) != v7)
    {
      v66 = "kBOMCopierOptionPersistRestrictedFlagsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12872) = BOMCFGetBoolValue(v122);
  }
  v123 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("preserveRestrictedFlags"));
  if (v123)
  {
    v124 = v123;
    if (CFGetTypeID(v123) != v7)
    {
      v66 = "kBOMCopierOptionPreserveRestrictedFlagsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12873) = BOMCFGetBoolValue(v124);
  }
  v125 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("persistRootlessEAs"));
  if (v125)
  {
    v126 = v125;
    if (CFGetTypeID(v125) != v7)
    {
      v66 = "kBOMCopierOptionPersistRootlessExtendedAttributesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(_BYTE *)(a1 + 12874) = BOMCFGetBoolValue(v126);
  }
  if (getenv("PRESERVECOMPRESSION"))
    *(_BYTE *)(a1 + 195) = 1;
  if (CFDictionaryContainsKey(a2, CFSTR("output2Nowhere")) == 1)
  {
    v66 = "The legacy engine does not support the nowhere destination";
  }
  else
  {
    v127 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("cloneFiles"));
    if (v127)
    {
      v128 = v127;
      if (CFGetTypeID(v127) != v7)
      {
        v66 = "kBOMCopierOptionCloneFilesKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(_BYTE *)(a1 + 204) = BOMCFGetBoolValue(v128);
    }
    v129 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("removeSetuidPermissions"));
    if (v129)
    {
      v130 = v129;
      if (CFGetTypeID(v129) != v7)
      {
        v66 = "kBOMCopierOptionRemoveSetuidPermissionsKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(_BYTE *)(a1 + 205) = BOMCFGetBoolValue(v130);
    }
    v131 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("removeExecutablePermissions"));
    if (v131)
    {
      v132 = v131;
      if (CFGetTypeID(v131) != v7)
      {
        v66 = "kBOMCopierOptionRemoveExecutablePermissionsKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(_BYTE *)(a1 + 206) = BOMCFGetBoolValue(v132);
    }
    v133 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("setStaticContent"));
    if (v133)
    {
      v134 = v133;
      if (CFGetTypeID(v133) != v7)
      {
        v66 = "kBOMCopierOptionSetStaticContentKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(_BYTE *)(a1 + 207) = BOMCFGetBoolValue(v134);
    }
    v135 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("setSingleWriter"));
    if (v135)
    {
      v136 = v135;
      if (CFGetTypeID(v135) != v7)
      {
        v66 = "kBOMCopierOptionSetSingleWriterKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(_BYTE *)(a1 + 208) = BOMCFGetBoolValue(v136);
    }
    v137 = CFDictionaryGetValue(a2, CFSTR("setDataProtectionClass"));
    if (v137)
    {
      v138 = v137;
      if (CFGetTypeID(v137) != v6)
      {
        v66 = "kBOMCopierOptionSetDataProtectionClassKey must be a CFStringRef";
        goto LABEL_269;
      }
      v139 = CFEqual(v138, CFSTR("A"));
      v140 = 1;
      if (v139 != 1)
      {
        if (CFEqual(v138, CFSTR("B")) == 1)
        {
          v140 = 2;
        }
        else if (CFEqual(v138, CFSTR("C")) == 1)
        {
          v140 = 3;
        }
        else
        {
          if (CFEqual(v138, CFSTR("D")) != 1)
          {
            v66 = "Unsupported data protection class";
            goto LABEL_269;
          }
          v140 = 4;
        }
      }
      *(_DWORD *)(a1 + 212) = v140;
      *(_BYTE *)(a1 + 211) = 1;
    }
    result = (uint64_t)CFDictionaryGetValue(a2, CFSTR("applyProvenance"));
    if (!result)
      return result;
    v142 = (const __CFData *)result;
    if (CFGetTypeID((CFTypeRef)result) == v9)
    {
      Length = CFDataGetLength(v142);
      if (Length)
      {
        v144 = Length;
        v145 = malloc_type_malloc(Length, 0xC3F1F04EuLL);
        if (v145)
        {
          v146 = v145;
          BytePtr = CFDataGetBytePtr(v142);
          memcpy(v146, BytePtr, v144);
          result = 0;
          *(_QWORD *)(a1 + 216) = v146;
          *(_QWORD *)(a1 + 224) = v144;
          return result;
        }
        v66 = "Could not allocate provenance data buffer";
      }
      else
      {
        v66 = "kBOMCopierOptionApplyProvenanceKey has an invalid size";
      }
    }
    else
    {
      v66 = "kBOMCopierOptionApplyProvenanceKey must be a CFDataRef";
    }
  }
LABEL_269:
  BOMCopierNotifyFatalError(a1, v66, v11, v12, v13, v14, v15, v16, v148);
  return 1;
}

uint64_t _verifyCopierOptions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  const char *v11;
  int v12;
  int v14;
  __CFReadStream *v15;
  int i;
  CFStreamStatus Status;
  __CFWriteStream *v18;
  int j;
  CFStreamStatus v20;
  char v21;
  timespec __rqtp;

  if (*(_BYTE *)(a1 + 12720) && *(_DWORD *)(a1 + 12712) != 1 && *(_DWORD *)(a1 + 12716) != 4)
  {
    v11 = "Compression is only used for CPIO archives";
    goto LABEL_23;
  }
  if (*(_BYTE *)(a1 + 12744) && *(_DWORD *)(a1 + 12716) != 4)
  {
    v11 = "SkipTerminator is only used for CPIO archives";
    goto LABEL_23;
  }
  if (*(_BYTE *)(a1 + 12745) && *(_DWORD *)(a1 + 12716) != 4)
  {
    v11 = "SkipRoot is only used for CPIO archives";
    goto LABEL_23;
  }
  v10 = *(_DWORD *)(a1 + 12712);
  if (v10 == 2 && *(_DWORD *)(a1 + 12716) != 3)
  {
    v11 = "PKZip archives can only be extracted to filesystem destinations";
    goto LABEL_23;
  }
  if (*(_BYTE *)(a1 + 12768) && v10 != 2 && *(_DWORD *)(a1 + 12716) != 5)
  {
    v11 = "sequesterResources is only for PKZip archives";
LABEL_23:
    BOMCopierNotifyFatalError(a1, v11, a3, a4, a5, a6, a7, a8, v21);
    return 1;
  }
  if ((*(_DWORD *)(a1 + 12792) - 10) <= 0xFFFFFFF4)
  {
    BOMCopierNotifyFatalError(a1, "%d is out of range for Zlib compression", a3, a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 12792));
    return 1;
  }
  if (v10 == 3 || (v12 = *(_DWORD *)(a1 + 12716), v12 == 6))
  {
    v11 = "The legacy engine does not support AppleArchive";
    goto LABEL_23;
  }
  if (v12 == 3 && *(_BYTE *)(a1 + 193))
  {
    v11 = "keepParent is only for archives";
    goto LABEL_23;
  }
  v14 = *(_DWORD *)(a1 + 12984);
  if (a2 && v14 != -1)
  {
    v11 = "Cannot specify a fromObj with kBOMCopierOptionInputFileDescriptorKey";
    goto LABEL_23;
  }
  if (a3 && *(_DWORD *)(a1 + 12988) != -1)
  {
    v11 = "Cannot specify a toObj with kBOMCopierOptionOutputFileDescriptorKey";
    goto LABEL_23;
  }
  v15 = *(__CFReadStream **)(a1 + 12944);
  if (v15)
  {
    if (!a2 && v14 == -1)
    {
      for (i = 30; ; --i)
      {
        Status = CFReadStreamGetStatus(v15);
        if (Status != kCFStreamStatusOpening)
          break;
        if (!i)
        {
          v11 = "Timed out waiting for the read stream to open";
          goto LABEL_23;
        }
        __rqtp = (timespec)xmmword_2063CFD90;
        nanosleep(&__rqtp, 0);
        v15 = *(__CFReadStream **)(a1 + 12944);
      }
      if (Status == kCFStreamStatusOpen)
        goto LABEL_43;
      BOMCopierNotifyFatalError(a1, "CFReadStream is not open: %u", a3, a4, a5, a6, a7, a8, Status);
      return 1;
    }
    v11 = "Cannot specify fromObj or kBOMCopierOptionInputFileDescriptorKey with kBOMCopierOptionInputCFReadStreamKey";
    goto LABEL_23;
  }
LABEL_43:
  v18 = *(__CFWriteStream **)(a1 + 12952);
  if (v18)
  {
    if (!a3 && *(_DWORD *)(a1 + 12988) == -1)
    {
      for (j = 30; ; --j)
      {
        v20 = CFWriteStreamGetStatus(v18);
        if (v20 != kCFStreamStatusOpening)
          break;
        if (!j)
        {
          v11 = "Timed out waiting for the write stream to open";
          goto LABEL_23;
        }
        __rqtp = (timespec)xmmword_2063CFD90;
        nanosleep(&__rqtp, 0);
        v18 = *(__CFWriteStream **)(a1 + 12952);
      }
      if (v20 == kCFStreamStatusOpen)
        goto LABEL_54;
      BOMCopierNotifyFatalError(a1, "CFWriteStream is not open: %u", a3, a4, a5, a6, a7, a8, v20);
      return 1;
    }
    v11 = "Cannot specify toObj or kBOMCopierOptionOutputFileDescriptorKey with kBOMCopierOptionOutputCFWriteStreamKey";
    goto LABEL_23;
  }
LABEL_54:
  if (*(_BYTE *)(a1 + 204) == 1)
  {
    if (*(_DWORD *)(a1 + 12712))
    {
      v11 = "kBOMCopierOptionCloneFiles requires the source to be a filesystem";
      goto LABEL_23;
    }
    if (*(_DWORD *)(a1 + 12716) != 3)
    {
      v11 = "kBOMCopierOptionCloneFiles requires the destination to be a filesystem";
      goto LABEL_23;
    }
  }
  if (*(_BYTE *)(a1 + 207) == 1 && *(_DWORD *)(a1 + 12716) != 3)
  {
    v11 = "setStaticContent is only for filesystem destinations";
    goto LABEL_23;
  }
  if (*(_BYTE *)(a1 + 208) == 1 && *(_DWORD *)(a1 + 12716) != 3)
  {
    v11 = "setSingleWriter is only for filesystem destinations";
    goto LABEL_23;
  }
  if (*(_QWORD *)(a1 + 216))
  {
    if (!*(_DWORD *)(a1 + 12712))
    {
      v11 = "applyProvenance is only for extracting from archives";
      goto LABEL_23;
    }
    if (*(_DWORD *)(a1 + 12716) != 3)
    {
      v11 = "applyProvenance is only applicable when extracting from archives";
      goto LABEL_23;
    }
  }
  return 0;
}

uint64_t _prepareCopierState(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFArray *v10;
  char *v11;
  const char *v12;
  uint64_t *v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  regex_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uid_t v53;
  char v54;
  uint64_t v55;
  void *v56;

  v2 = *(char **)(a1 + 12896);
  if (v2)
  {
    v3 = BOMBomOpenWithSys(v2, 0, *(void **)(a1 + 12832));
    *(_QWORD *)(a1 + 152) = v3;
    if (!v3)
    {
      v33 = *(_QWORD *)(a1 + 12896);
LABEL_27:
      v54 = v33;
      v12 = "Cannot open BOM at '%s'";
      goto LABEL_28;
    }
  }
  v56 = 0;
  v10 = *(const __CFArray **)(a1 + 12880);
  if (v10)
  {
    v11 = _parse_arch_list(a1, v10, *(const __CFDictionary **)(a1 + 12888), (_DWORD *)(a1 + 144), &v56);
    *(_QWORD *)(a1 + 136) = v11;
    if (!v11)
    {
      v12 = "Could not parse the Mach-O architectures to copy";
LABEL_28:
      BOMCopierNotifyFatalError(a1, v12, v4, v5, v6, v7, v8, v9, v54);
      return 1;
    }
  }
  else if (!*(_QWORD *)(a1 + 136))
  {
    goto LABEL_10;
  }
  v13 = *(uint64_t **)(a1 + 152);
  if (v13)
  {
    v14 = BOMBomNewFromBomWithOptions(0, v13, 1, (const char **)v56, 0);
    if (!v14)
    {
      BOMCopierNotifyFatalError(a1, "Cannot thin the index bom", v15, v16, v17, v18, v19, v20, v54);
      if (v56)
      {
        v34 = *(void **)v56;
        if (*(_QWORD *)v56)
        {
          v35 = 8;
          do
          {
            free(v34);
            v34 = *(void **)((char *)v56 + v35);
            v35 += 8;
          }
          while (v34);
        }
      }
      return 1;
    }
    v21 = v14;
    BOMBomFree(*(_QWORD *)(a1 + 152));
    *(_QWORD *)(a1 + 152) = v21;
  }
LABEL_10:
  v22 = v56;
  if (v56)
  {
    v23 = *(void **)v56;
    if (*(_QWORD *)v56)
    {
      v24 = 0;
      do
      {
        free(v23);
        *(_QWORD *)((char *)v56 + v24) = 0;
        v22 = v56;
        v23 = *(void **)((char *)v56 + v24 + 8);
        v24 += 8;
      }
      while (v23);
    }
    free(v22);
  }
  v25 = *(char **)(a1 + 12904);
  if (v25)
  {
    v26 = BOMBomOpenWithSys(v25, 0, *(void **)(a1 + 12832));
    *(_QWORD *)(a1 + 160) = v26;
    if (!v26)
    {
      v33 = *(_QWORD *)(a1 + 12904);
      goto LABEL_27;
    }
  }
  if (*(_QWORD *)(a1 + 12920))
  {
    if (_mkdirs_parent(a1))
    {
      BOMCopierNotifyFatalError(a1, "Cannot create parent directory for %s", v27, v28, v29, v30, v31, v32, *(_QWORD *)(a1 + 12920));
      return 1;
    }
    v55 = 0;
    if (BOMFileOpenWithSys(&v55, *(_QWORD *)(a1 + 12920), 1545, 420, 0, *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
    {
      v37 = *(_QWORD *)(a1 + 12920);
      v38 = __error();
      strerror(*v38);
      BOMCopierNotifyFatalError(a1, "Cannot open file %s for writing: %s", v39, v40, v41, v42, v43, v44, v37);
      return 1;
    }
    *(_QWORD *)(a1 + 176) = v55;
  }
  v45 = *(const char **)(a1 + 12928);
  if (v45)
  {
    v46 = BOMPatternCompileString(v45);
    *(_QWORD *)(a1 + 184) = v46;
    if (!v46)
    {
      BOMCopierNotifyFatalError(a1, "Cannot compile \"%s\" as a regular expression pattern", v47, v48, v49, v50, v51, v52, *(_QWORD *)(a1 + 12928));
      return 1;
    }
  }
  v53 = geteuid();
  *(_DWORD *)(a1 + 10496) = v53;
  if (v53 && _initGroupList(a1))
    return 1;
  if (*(_BYTE *)(a1 + 195) && (*(_DWORD *)(a1 + 12716) != 3 || !*(_BYTE *)(a1 + 170) && !*(_BYTE *)(a1 + 169)))
    *(_BYTE *)(a1 + 195) = 0;
  while (!BOMStackIsEmpty(*(_QWORD *)(a1 + 40)))
    BOMStackPop(*(uint64_t **)(a1 + 40));
  return 0;
}

uint64_t _prepareCopierDestination(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char *v20;
  uint64_t v21;
  int *v22;
  void (*v23)(uint64_t, const char *, uint64_t);
  uint64_t v24;
  const char *v25;
  int *v26;
  uint64_t v27;
  int *v28;
  const void *v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t v45;

  v10 = *(_DWORD *)(a1 + 12716);
  if (v10 != 3)
  {
    v45 = 0;
    v19 = *(_DWORD *)(a1 + 12964);
    *(_DWORD *)(a1 + 12992) = v19;
    if (!*(_BYTE *)(a1 + 12814))
    {
      v19 |= 0x10u;
      *(_DWORD *)(a1 + 12992) = v19;
    }
    if (v10 == 4)
    {
      v20 = getenv("BOM_ASYNC");
      if (v20)
      {
        if (strcmp("0", v20))
        {
          v19 |= 0x20u;
          *(_DWORD *)(a1 + 12992) = v19;
        }
      }
    }
    if (__s1)
    {
      if (!strcmp(__s1, "-"))
      {
        if (BOMFileOpenSTDOUT(&v45, v19))
        {
          v26 = __error();
          v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
          if (!v23)
            return 1;
          v24 = *v26;
          v27 = a1;
          v25 = 0;
LABEL_34:
          v23(v27, v25, v24);
          return 1;
        }
      }
      else
      {
        if (_mkdirs_parent(a1))
        {
          LOBYTE(v44) = (_BYTE)__s1;
LABEL_16:
          BOMCopierNotifyFatalError(a1, "Cannot create parent directory for %s", v13, v14, v15, v16, v17, v18, v44);
          return 1;
        }
        if (BOMFileOpenWithSys(&v45, (uint64_t)__s1, 1537, 420, *(_DWORD *)(a1 + 12992), *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
        {
          v28 = __error();
          v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
          if (!v23)
            return 1;
          v24 = *v28;
          v27 = a1;
          v25 = __s1;
          goto LABEL_34;
        }
      }
LABEL_37:
      if (*(_DWORD *)(a1 + 12716) == 4)
      {
        if (!BOMCPIONew((uint64_t **)(a1 + 12736), v45, 1, *(_DWORD *)(a1 + 12960)))
          return 0;
        BOMFileClose(v45);
        BOMCopierNotifyFatalError(a1, "Cannot create CPIO file at %s", v31, v32, v33, v34, v35, v36, v45);
      }
      else
      {
        if (!BOMPKZipNew((_QWORD *)(a1 + 12760), v45, 1))
          return 0;
        BOMFileClose(v45);
        BOMCopierNotifyFatalError(a1, "Cannot create PKZip file at %s", v37, v38, v39, v40, v41, v42, v45);
      }
      return 1;
    }
    v21 = *(unsigned int *)(a1 + 12988);
    if ((_DWORD)v21 == -1)
    {
      v29 = *(const void **)(a1 + 12952);
      if (!v29 || !BOMFileNewFromCFWriteStream(&v45, v29, v19))
        goto LABEL_37;
      v30 = __error();
      v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v23)
        return 1;
      v24 = *v30;
      v25 = "wstream";
    }
    else
    {
      if (!BOMFileNewFromFDWithSys(&v45, v21, v19, "wb", *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))goto LABEL_37;
      v22 = __error();
      v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v23)
        return 1;
      v24 = *v22;
      v25 = "fdesc";
    }
    v27 = a1;
    goto LABEL_34;
  }
  if (__s1)
  {
    v11 = *(_QWORD *)(a1 + 12936);
    if (v11)
    {
      result = _mkdirs(a1, v11);
      if (!(_DWORD)result)
        return result;
      v44 = *(_QWORD *)(a1 + 12936);
      goto LABEL_16;
    }
    return 0;
  }
  BOMCopierNotifyFatalError(a1, "If the destination is a filesystem, the toObj argument cannot be nil", a3, a4, a5, a6, a7, a8, v43);
  _resetCopier(a1);
  return 1;
}

uint64_t _BOMCopierCopyFromFilesystem(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  const char *v14;
  int *v15;
  void (*v16)(uint64_t, char *, uint64_t);
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int *v20;
  uint64_t result;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  int v30;
  int v31;
  _BOOL4 v32;
  char *v33;
  char *v34;
  size_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  size_t v43;
  int v44;
  int v45;
  uint64_t v46;
  size_t v47;
  size_t v48;
  _BYTE *v49;
  uint64_t v50;
  uint64_t v51;
  _BYTE *v52;
  int v53;
  int v54;
  int *v55;
  void (*v56)(uint64_t, uint64_t, _QWORD);
  int *v57;
  int *v58;
  int *v59;
  char v60;
  char v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  _QWORD v73[4];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  statfs v81;
  char __s[1024];
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v63 = 0uLL;
  v62 = 0uLL;
  v61 = 0;
  if (!a2 || !*a2 || *(_DWORD *)(a1 + 12716) == 3 && (!a3 || !*a3))
    return 1;
  *(_BYTE *)(a1 + 168) = 0;
  *(_BYTE *)(a1 + 11616) = 0;
  *(_BYTE *)(a1 + 12641) = 0;
  v6 = *(_QWORD *)(a1 + 152);
  if (v6)
  {
    v13 = BOMBomPathIDForKey(v6, 0, ".");
    if (!v13)
    {
      v14 = "Can't find . in bom file";
LABEL_12:
      BOMCopierNotifyFatalError(a1, v14, v7, v8, v9, v10, v11, v12, v60);
      return 1;
    }
  }
  else
  {
    v13 = 0;
  }
  if (strlen(a2) >= 0x3FF)
  {
    v60 = (char)a2;
    v14 = "source path ('%s') too long [%lu >= %lu]!";
    goto LABEL_12;
  }
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  v74 = 0u;
  v64 = 0u;
  v65 = 0u;
  v66 = 0u;
  v67 = 0u;
  v68 = 0u;
  v69 = 0u;
  v70 = 0u;
  v71 = 0u;
  v72 = 0u;
  memset(v73, 0, sizeof(v73));
  __strlcpy_chk();
  if ((*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), __s, a1 + 248) != a1 + 248)goto LABEL_14;
  if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248, v73))
  {
LABEL_18:
    v20 = __error();
    v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
    if (!v16)
      return 1;
    v17 = *v20;
    v19 = a1;
    v18 = (char *)(a1 + 248);
LABEL_20:
    v16(v19, v18, v17);
    return 1;
  }
  v22 = WORD2(v73[0]) & 0xF000;
  v64 = 0u;
  v65 = 0u;
  v66 = 0u;
  v67 = 0u;
  v68 = 0u;
  v69 = 0u;
  v70 = 0u;
  v71 = 0u;
  v72 = 0u;
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (strlen(a3) >= 0x3FF)
    {
      BOMCopierNotifyFatalError(a1, "destination path ('%s') too long [%lu >= %lu]!", v23, v24, v25, v26, v27, v28, (char)a3);
      return 1;
    }
    __strlcpy_chk();
    v31 = (*(uint64_t (**)(_QWORD, char *, __int128 *))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), __s, &v64);
    v30 = *__error();
    if (v31 && v30 != 2 && v30 != 63)
      goto LABEL_14;
    if (v31)
      v32 = v22 == 0x4000;
    else
      v32 = (WORD2(v64) & 0xF000) == 0x4000;
    if (!v31 && v22 != 0x4000 && v32)
    {
      strrchr((char *)(a1 + 248), 47);
      __strlcat_chk();
      __strlcat_chk();
      v31 = (*(uint64_t (**)(_QWORD, char *, __int128 *))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), __s, &v64);
      if (v31)
        v32 = v22 == 0x4000;
      else
        v32 = (WORD2(v64) & 0xF000) == 0x4000;
    }
    if (v22 == 0x4000 && !v31 && !v32)
    {
      BOMCopierNotifyFatalError(a1, "Can't copy directory %s into a file %s.", v37, v38, v39, v40, v41, v42, a1 - 8);
      return 1;
    }
    if (!v31 && v73[1] == *((_QWORD *)&v64 + 1) && LODWORD(v73[0]) == (_DWORD)v64)
    {
      BOMCopierNotifyFatalError(a1, "%s and %s are identical (not copied).", v37, v38, v39, v40, v41, v42, a1 - 8);
      return 1;
    }
    __strlcpy_chk();
  }
  else
  {
    v29 = "<unknown>";
    if (a3)
      v29 = a3;
    snprintf((char *)(a1 + 3328), 0x400uLL, "%s:", v29);
    v30 = 0;
    v31 = -1;
    v32 = 1;
  }
  if (v22 == 0x4000)
  {
    *(_BYTE *)(a1 + 2304) = 0;
    *(_BYTE *)(a1 + 6400) = 0;
  }
  else
  {
    _extractFileAndPath((char *)(a1 + 248), (char *)(a1 + 2304));
    if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD *))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248, v73))
    {
      goto LABEL_18;
    }
    if (v32)
    {
      __strlcpy_chk();
    }
    else
    {
      _extractFileAndPath((char *)(a1 + 3328), (char *)(a1 + 6400));
      v31 = (*(uint64_t (**)(_QWORD, uint64_t, __int128 *))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328, &v64);
      v30 = *__error();
    }
  }
  if (!*(_BYTE *)(a1 + 193))
  {
    v43 = strlen((const char *)(a1 + 248));
    if (v43 != 1 || strcmp("/", (const char *)(a1 + 248)))
    {
      __strlcat_chk();
      v36 = v43 + 1;
      goto LABEL_66;
    }
    __strlcat_chk();
LABEL_65:
    v36 = 1;
    goto LABEL_66;
  }
  __strlcpy_chk();
  v33 = strrchr(__s, 47);
  if (!v33)
    goto LABEL_67;
  v34 = v33;
  if (v33 == __s)
  {
    __strlcpy_chk();
    goto LABEL_65;
  }
  *v33 = 0;
  v35 = strlen(__s);
  snprintf((char *)(a1 + 248), 0x400uLL, "%s/./%s", __s, v34 + 1);
  v36 = v35 + 1;
LABEL_66:
  *(_QWORD *)(a1 + 2296) = a1 + v36 + 248;
LABEL_67:
  *(_DWORD *)(a1 + 232) = v73[0];
  memset(&v81, 0, 512);
  if (statfs((const char *)(a1 + 248), &v81))
    goto LABEL_18;
  *(_BYTE *)(a1 + 210) = (v81.f_flags & 8) == 0;
  v44 = *(_DWORD *)(a1 + 12716);
  switch(v44)
  {
    case 5:
      if (!BOMPKZipWriteLocalHeader(*(_QWORD *)(a1 + 12760), ".", (uint64_t)v73, 0, 0)
        && (v22 != 0x4000
         || !*(_BYTE *)(a1 + 193)
         || !BOMPKZipWriteLocalHeader(*(_QWORD *)(a1 + 12760), *(char **)(a1 + 2296), (uint64_t)v73, 0, 0)))
      {
LABEL_84:
        v45 = 0;
        v46 = 0;
        goto LABEL_86;
      }
LABEL_112:
      v58 = __error();
      v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
      if (!v16)
        return 1;
      v17 = *v58;
      v18 = (char *)(a1 + 3328);
LABEL_16:
      v19 = a1;
      goto LABEL_20;
    case 4:
      if (*(_BYTE *)(a1 + 12745))
        goto LABEL_84;
      if (*(_BYTE *)(a1 + 12746))
        _applyIndexBomOwnershipForTargetArchive(a1, ".", (uint64_t)v73);
      if (!BOMCPIOWriteDirectory(*(_QWORD *)(a1 + 12736), ".", (uint64_t)v73)
        && (v22 != 0x4000
         || !*(_BYTE *)(a1 + 193)
         || !BOMCPIOWriteDirectory(*(_QWORD *)(a1 + 12736), *(char **)(a1 + 2296), (uint64_t)v73)))
      {
        goto LABEL_84;
      }
      goto LABEL_112;
    case 3:
      *(_DWORD *)(a1 + 236) = v64;
      *(_QWORD *)(a1 + 240) = *((_QWORD *)&v64 + 1);
      __strlcpy_chk();
      if (v31)
      {
        *__error() = v30;
        if (*__error() != 2 && *__error() != 63)
          goto LABEL_14;
        v45 = 0;
      }
      else
      {
        if ((WORD2(v64) & 0xF000) != 0x4000)
        {
          v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
          if (!v16)
            return 1;
          v18 = __s;
          v19 = a1;
          v17 = 20;
          goto LABEL_20;
        }
        v45 = 1;
        if (!*(_BYTE *)(a1 + 12822))
        {
          v46 = 0;
          goto LABEL_105;
        }
      }
      if (_makeDestDir(a1, __s, 1, (uint64_t)v73, &v61))
        goto LABEL_14;
      v46 = WORD2(v73[0]);
      if ((*(unsigned int (**)(_QWORD, char *, __int128 *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), __s, &v64))
      {
        goto LABEL_14;
      }
      v62 = v75;
      v63 = v74;
LABEL_105:
      if ((*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), __s, a1 + 3328) == a1 + 3328)
      {
        _initializeAFSCData(a1);
        if (statfs((const char *)(a1 + 3328), &v81))
        {
          v57 = __error();
          v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
          if (!v16)
            return 1;
          v17 = *v57;
          v19 = a1;
          v18 = (char *)(a1 + 3328);
          goto LABEL_20;
        }
        *(_BYTE *)(a1 + 209) = (v81.f_flags & 8) == 0;
        if (*(_BYTE *)(a1 + 211) == 1)
          *(_BYTE *)(a1 + 211) = volume_has_data_protection((const char *)(a1 + 3328));
        goto LABEL_86;
      }
LABEL_14:
      v15 = __error();
      v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
      if (!v16)
        return 1;
      v17 = *v15;
      v18 = __s;
      goto LABEL_16;
  }
  v46 = 0;
  v45 = 1;
LABEL_86:
  v47 = strlen((const char *)(a1 + 248));
  v48 = strlen((const char *)(a1 + 3328));
  v49 = (_BYTE *)(a1 + 3328 + v48);
  v50 = 1024 - v47;
  v51 = 1024 - v48;
  v52 = (_BYTE *)(a1 + 248 + v47);
  if (v22 == 0x4000)
    result = _copyFromDirToDir(a1, v73, v52, v50, v49, v51, v13);
  else
    result = _copyFromFileToDir(a1, (uint64_t)v73, v52, v50, v49, v51, v13, v45);
  if (!(_DWORD)result)
  {
    if (v45 || *(_DWORD *)(a1 + 12716) != 3)
      return 0;
    if (!*(_BYTE *)(a1 + 170) && !*(_BYTE *)(a1 + 169)
      || (v53 = _copyExtendedAttributes(a1, a1 + 248, (uint64_t)v73, 0, 0), result = 0, !v53))
    {
      if (!*(_BYTE *)(a1 + 171) || (v54 = _copyACLs(a1, (char *)(a1 + 248), 0, 0, 0), result = 0, !v54))
      {
        if (v61
          && (*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 200))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328, v46))
        {
LABEL_99:
          v55 = __error();
          v56 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 64);
          if (v56)
            v56(a1, a1 + 3328, *v55);
          return 0;
        }
        result = set_timestamps_0((const char *)(a1 + 3328), &v63, &v62);
        if ((_DWORD)result)
        {
          if (*__error() == 13 || *__error() == 1)
          {
            v59 = __error();
            result = 0;
            *v59 = 0;
            return result;
          }
          goto LABEL_99;
        }
      }
    }
  }
  return result;
}

uint64_t _BOMCopierCopyFromCPIO(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v10;
  int v12;
  size_t v13;
  _BYTE *v14;
  int *v15;
  void (*v16)(uint64_t, const char *, uint64_t);
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  int *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _OWORD v32[9];
  uint64_t *v33;

  v33 = 0;
  v10 = (_BYTE *)(a1 + 12721);
  v31 = 0u;
  memset(v32, 0, sizeof(v32));
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (!a3)
    {
      BOMCopierNotifyFatalError(a1, "dstPath is NULL", 0, a4, a5, a6, a7, a8, v23);
      goto LABEL_17;
    }
    if (*(_BYTE *)(a1 + 12821) && _enforceDestinationLocation(a1, a3))
    {
      BOMFileClose(a2);
LABEL_17:
      v20 = 1;
      goto LABEL_18;
    }
    if (v10[99])
    {
      if (_resolveDestinationPath(a1, a3, (char *)(a1 + 3328)))
        goto LABEL_17;
    }
    else
    {
      __strlcpy_chk();
    }
    if ((*(unsigned int (**)(_QWORD, uint64_t, __int128 *))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328, &v23))
    {
      if (*__error() != 2 && *__error() != 63
        || _mkdirs(a1, a1 + 3328)
        || (*(unsigned int (**)(_QWORD, uint64_t, __int128 *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328, &v23))
      {
        v22 = __error();
        v16 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
        if (!v16)
          goto LABEL_17;
        v17 = *v22;
        v19 = a1;
        v18 = a3;
        goto LABEL_10;
      }
      v12 = 0;
    }
    else
    {
      v12 = 1;
    }
    _initializeAFSCData(a1);
  }
  else
  {
    __strlcpy_chk();
    v12 = 0;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
  }
  v13 = strlen((const char *)(a1 + 3328));
  v14 = (_BYTE *)(a1 + 3328 + (int)v13);
  *v14 = 47;
  if (BOMCPIONew(&v33, a2, 1, 0))
  {
    BOMFileClose(a2);
    v15 = __error();
    v16 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v16)
      goto LABEL_17;
    v17 = *v15;
    v18 = "";
    v19 = a1;
LABEL_10:
    v16(v19, v18, v17);
    goto LABEL_17;
  }
  *(_BYTE *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 2296) = a1 + 248;
  *(_QWORD *)(a1 + 12728) = v33;
  *v10 = 1;
  v20 = _copyFromCPIO(a1, (uint64_t)v32, (uint64_t)&v23, v14 + 1, ((uint64_t)(0x40000000000 - (v13 << 32)) >> 32) - 1, v12);
  if (!(_DWORD)v20)
    v20 = _restoreSymlinks(a1, 0);
LABEL_18:
  if (v10[102])
    _restoreSymlinks(a1, 1);
  if (v33)
    BOMCPIOFree(v33);
  return v20;
}

uint64_t _BOMCopierCopyFromPKZip(uint64_t a1, uint64_t a2, char *__s, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v19;
  void (*v20)(uint64_t, const char *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  int v24;
  _BYTE *v25;
  char *v26;
  int *v27;
  void *v28;
  int v29;
  char *v30;
  void *v31;
  int NumLocalHeaders;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  const char *v40;
  const char *v41;
  int v42;
  const char *v43;
  __int16 v44;
  __int16 v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  const char *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int *v68;
  void (*v69)(uint64_t, uint64_t, _QWORD);
  int *v70;
  int v71;
  const char *v72;
  int *v73;
  int *v74;
  void (*v75)(uint64_t, char *, uint64_t);
  uint64_t v76;
  char *v77;
  uint64_t v78;
  int *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int *v86;
  int v87;
  int v88;
  unsigned __int8 *v89;
  int v90;
  uint64_t v91;
  int *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char v99;
  _OWORD v100[6];
  __int128 v101;
  __int128 v102;
  __int128 v103;
  _OWORD v104[9];
  int *v105;
  _OWORD v106[9];
  _OWORD v107[9];
  uint64_t v108;
  void *v109;
  char v110[1024];
  uint64_t v111;

  v111 = *MEMORY[0x24BDAC8D0];
  v109 = 0;
  v108 = 0;
  memset(v107, 0, sizeof(v107));
  memset(v106, 0, sizeof(v106));
  if (*(_DWORD *)(a1 + 12716) != 3)
  {
    v17 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "dstPath is NULL", 0, a4, a5, a6, a7, a8, v99);
    goto LABEL_7;
  }
  if (strlen(__s) >= 0x3FF)
  {
    BOMCopierNotifyFatalError(a1, "Filename('%s') too long [%lu >= %lu]!", v11, v12, v13, v14, v15, v16, (char)__s);
LABEL_7:
    v17 = 1;
    goto LABEL_8;
  }
  if (*(_BYTE *)(a1 + 12821) && _enforceDestinationLocation(a1, __s))
  {
    BOMFileClose(a2);
    goto LABEL_7;
  }
  if (*(_BYTE *)(a1 + 12820))
  {
    if (_resolveDestinationPath(a1, __s, (char *)(a1 + 3328)))
      goto LABEL_7;
  }
  else
  {
    __strlcpy_chk();
  }
  if ((*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328, v106)&& (*__error() != 2 && *__error() != 63 || _mkdirs(a1, a1 + 3328)))
  {
    v19 = __error();
    v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v20)
      goto LABEL_7;
    v21 = *v19;
    v22 = a1;
    v23 = __s;
LABEL_28:
    v20(v22, v23, v21);
    goto LABEL_7;
  }
  _initializeAFSCData(a1);
  v24 = strlen((const char *)(a1 + 3328));
  v25 = (_BYTE *)(a1 + 3328 + v24);
  *v25 = 47;
  v26 = v25 + 1;
  if (BOMPKZipNew(&v109, a2, 1))
  {
    BOMFileClose(a2);
    v27 = __error();
    v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v20)
      goto LABEL_7;
    v21 = *v27;
    v23 = "Could not create a BOMPKZip object";
    goto LABEL_27;
  }
  *(_BYTE *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 2296) = a1 + 248;
  v28 = v109;
  *(_QWORD *)(a1 + 12752) = v109;
  *(_BYTE *)(a1 + 12721) = 1;
  if (*(_DWORD *)(a1 + 12716) == 3 && *(_BYTE *)(a1 + 12768))
  {
    v29 = strlen((const char *)(a1 + 3328));
    *(_DWORD *)(a1 + 12780) = v29 + 8;
    v30 = (char *)BOM_malloc((v29 + 9));
    *(_QWORD *)(a1 + 12784) = v30;
    if (!v30)
    {
      v73 = __error();
      v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v20)
        goto LABEL_7;
      v21 = *v73;
      v23 = "";
LABEL_27:
      v22 = a1;
      goto LABEL_28;
    }
    snprintf(v30, (*(_DWORD *)(a1 + 12780) + 1), "%s%s", (const char *)(a1 + 3328), "__MACOSX");
    v28 = v109;
  }
  BOMPKZipLoadCentralDirectory((uint64_t)v28);
  v17 = _copyFromPKZip(a1, (uint64_t)v107, (uint64_t)v106, v26, 1024 - v24 - 1);
  v31 = *(void **)(a1 + 12784);
  if (v31)
  {
    free(v31);
    *(_QWORD *)(a1 + 12784) = 0;
    *(_DWORD *)(a1 + 12780) = 0;
  }
  if (!(_DWORD)v17)
  {
    NumLocalHeaders = BOMPKZipGetNumLocalHeaders(*(_QWORD *)(a1 + 12752));
    if (NumLocalHeaders)
    {
      v39 = NumLocalHeaders;
      v40 = (const char *)(a1 + 249);
      v41 = (const char *)(a1 + 250);
      do
      {
        if (*(_DWORD *)(a1 + 12772) != 2)
        {
          v72 = "Not a central directory signature";
          goto LABEL_109;
        }
        if (BOMPKZipReadCentralHeader(*(int ***)(a1 + 12752), (char *)(a1 + 248), (uint64_t)v107, &v108))
        {
          v72 = "Couldn't read pkzip central header";
          goto LABEL_109;
        }
        v42 = *(char *)(a1 + 248);
        if (v42 == 46)
        {
          if (*v40 == 47)
            v43 = v41;
          else
            v43 = (const char *)(a1 + 248);
        }
        else
        {
          v43 = (const char *)(a1 + 248);
          if (v42 == 47)
            v43 = v40;
        }
        snprintf((char *)(a1 + 7424), 0x400uLL, "%s/%s", __s, v43);
        v44 = WORD2(v107[0]);
        if ((WORD2(v107[0]) & 0x1FF) == 0)
        {
          if ((WORD2(v107[0]) & 0xF000) == 0x4000)
          {
            v45 = 493;
          }
          else
          {
            if ((WORD2(v107[0]) & 0xF000) != 0x8000)
              goto LABEL_52;
            v45 = 420;
          }
          v44 = WORD2(v107[0]) | v45;
          WORD2(v107[0]) |= v45;
        }
LABEL_52:
        v46 = v44 & 0xF000;
        if (v46 != 0x4000)
        {
          if (v46 == 40960)
          {
            v105 = 0;
            v103 = 0u;
            memset(v104, 0, sizeof(v104));
            v101 = 0u;
            v102 = 0u;
            memset(v100, 0, sizeof(v100));
            if ((*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, v100))
            {
              v79 = __error();
              strerror(*v79);
              BOMCopierNotifyFatalError(a1, "Could not lstat %s: %s", v80, v81, v82, v83, v84, v85, a1);
              goto LABEL_110;
            }
            if ((uint64_t)v101 >= 1024)
            {
              BOMCopierNotifyFatalError(a1, "%s is too large: %ld", v47, v48, v49, v50, v51, v52, a1);
              goto LABEL_110;
            }
            if (BOMFileOpenWithSys(&v105, a1 + 7424, 0, 0, 16, *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
            {
              BOMCopierNotifyFatalError(a1, "Could not open symlink %s", v53, v54, v55, v56, v57, v58, a1);
              goto LABEL_110;
            }
            v59 = v41;
            v60 = BOMFileRead(v105, (char *)(a1 + 3328), v101);
            if (v60 != (_QWORD)v101)
            {
              BOMCopierNotifyFatalError(a1, "Could not read %s", v61, v62, v63, v64, v65, v66, a1);
              goto LABEL_110;
            }
            *(_BYTE *)(a1 + v60 + 3328) = 0;
            BOMFileClose((uint64_t)v105);
            _parentPath((char *)(a1 + 7424), v110, 0x400uLL);
            v67 = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 184))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v110, 2);
            if (v67)
            {
              if ((*(unsigned int (**)(_QWORD, char *, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v110, v104))
              {
                goto LABEL_110;
              }
              if ((*(unsigned int (**)(_QWORD, char *, _QWORD))(*(_QWORD *)(a1 + 12832) + 200))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v110, WORD2(v104[0]) | 0x1C0u))
              {
LABEL_89:
                v74 = __error();
                v75 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
                if (!v75)
                  goto LABEL_110;
                v76 = *v74;
                v77 = v110;
                v78 = a1;
LABEL_97:
                v75(v78, v77, v76);
                goto LABEL_110;
              }
            }
            if ((*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424))
            {
              v68 = __error();
              v69 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 64);
              if (v69)
                v69(a1, a1 + 7424, *v68);
            }
            if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 248))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328, a1 + 7424) == -1)
            {
              v86 = __error();
              v75 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
              if (!v75)
                goto LABEL_110;
              v76 = *v86;
              v78 = a1;
              v77 = (char *)(a1 + 7424);
              goto LABEL_97;
            }
            if (v67
              && (*(unsigned int (**)(_QWORD, char *, _QWORD))(*(_QWORD *)(a1 + 12832) + 200))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v110, WORD2(v104[0]) & 0xFFF))
            {
              goto LABEL_89;
            }
            v41 = v59;
            v40 = (const char *)(a1 + 249);
            goto LABEL_73;
          }
          if (v46 != 0x8000)
            goto LABEL_73;
        }
        if (_chPerms(a1, (char *)(a1 + 7424), (uint64_t)v107, 0, 0) == -1)
        {
          if (*__error() != 2 && *__error() != 63)
          {
            v92 = __error();
            strerror(*v92);
            BOMCopierNotifyFatalError(a1, "Could not chmod %s: %s", v93, v94, v95, v96, v97, v98, a1);
            goto LABEL_110;
          }
          *__error() = 0;
        }
LABEL_73:
        if (BOMPKZipReadNextSignature(*(_QWORD *)(a1 + 12752), (int *)(a1 + 12772)))
          goto LABEL_88;
        --v39;
      }
      while (v39);
    }
    v70 = (int *)(a1 + 12772);
    v71 = *(_DWORD *)(a1 + 12772);
    if (v71 == 3)
    {
      if (BOMPKZipSkipDigitalSignature(*(int ***)(a1 + 12752)))
      {
        v72 = "Could not skip the digital signature.";
LABEL_109:
        BOMCopierNotifyFatalError(a1, v72, v33, v34, v35, v36, v37, v38, v99);
        goto LABEL_110;
      }
      if (BOMPKZipReadNextSignature(*(_QWORD *)(a1 + 12752), (int *)(a1 + 12772)))
      {
LABEL_88:
        v72 = "Could not read next signature";
        goto LABEL_109;
      }
      v71 = *v70;
    }
    if (v71 == 4)
    {
      if (BOMPKZipSkipZIP64CentralDirectoryRecord(*(int ***)(a1 + 12752)))
      {
        v72 = "Could not skip the ZIP64 central dir record.";
        goto LABEL_109;
      }
      if (BOMPKZipReadNextSignature(*(_QWORD *)(a1 + 12752), (int *)(a1 + 12772)))
        goto LABEL_88;
      v71 = *v70;
    }
    if (v71 == 5)
    {
      if (BOMPKZipSkipZIP64CentralDirectoryLocation(*(int ***)(a1 + 12752)))
      {
        v72 = "Could not skip the ZIP64 central dir locator.";
        goto LABEL_109;
      }
      if (BOMPKZipReadNextSignature(*(_QWORD *)(a1 + 12752), (int *)(a1 + 12772)))
      {
        v72 = "Couldn't read next signature";
        goto LABEL_109;
      }
      v71 = *v70;
    }
    if (v71 != 6)
    {
      v72 = "I'm expecting the end of central directory record.";
      goto LABEL_109;
    }
    if (BOMPKZipSkipEndOfCentralDirectoryRecord(*(int ***)(a1 + 12752)))
    {
      v72 = "Could not skip the end of the central directory record.";
      goto LABEL_109;
    }
    if (*(_BYTE *)(a1 + 12768))
    {
      v87 = BOMPKZipQuarantinePathCount((uint64_t)v109);
      if (v87 - 1 >= 0)
      {
        v88 = v87;
        v89 = (unsigned __int8 *)(a1 + 7424);
        while (!BOMPKZipCopyQuarantinePath((uint64_t)v109, --v88, (void *)(a1 + 7424)))
        {
          v90 = *v89;
          if (v90 == 46 && *(_BYTE *)(a1 + 7425) == 47)
            v91 = 2;
          else
            v91 = v90 == 47;
          snprintf((char *)(a1 + 3328), 0x400uLL, "%s/%s", __s, (const char *)&v89[v91]);
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 232))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328);
          v17 = 0;
          if (v88 <= 0)
            goto LABEL_8;
        }
        v72 = "Could not copy quarantined directory path.";
        goto LABEL_109;
      }
    }
LABEL_110:
    v17 = 0;
  }
LABEL_8:
  if (v109)
    BOMPKZipFree(v109);
  return v17;
}

uint64_t _finalizeCopierDestination(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int NumLocalHeaders;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;

  switch(*(_DWORD *)(a1 + 12716))
  {
    case 3:
      v9 = *(const void **)(a1 + 12856);
      if (v9)
      {
        CFRelease(v9);
        *(_QWORD *)(a1 + 12856) = 0;
      }
      if (!*(_QWORD *)(a1 + 12864))
        goto LABEL_8;
      v10 = FinishStreamCompressorQueue();
      if (v10)
      {
        BOMCopierNotifyFatalError(a1, "Could not finish the HFS FinishStreamCompressorQueue error (%d)", v11, v12, v13, v14, v15, v16, v10);
        goto LABEL_14;
      }
      v17 = 0;
      *(_QWORD *)(a1 + 12864) = 0;
      break;
    case 4:
      if (*(_BYTE *)(a1 + 12744))
        goto LABEL_8;
      v17 = BOMCPIOWriteTerminator(*(uint64_t **)(a1 + 12736));
      if ((_DWORD)v17)
        BOMCopierNotifyFatalError(a1, "Cannot write the terminator for the CPIO archive", v26, v27, v28, v29, v30, v31, v33);
      break;
    case 5:
      v17 = BOMPKZipWriteCentralDirectory(*(_QWORD *)(a1 + 12760));
      if ((_DWORD)v17)
      {
        NumLocalHeaders = BOMPKZipGetNumLocalHeaders(*(_QWORD *)(a1 + 12760));
        v25 = "Could not write the central directory for";
        if (!NumLocalHeaders)
          v25 = "No files for";
        BOMCopierNotifyFatalError(a1, "%s PKZip archive", v19, v20, v21, v22, v23, v24, (char)v25);
      }
      break;
    case 6:
      BOMCopierNotifyFatalError(a1, "The legacy engine does not support AppleArchive", a3, a4, a5, a6, a7, a8, v33);
LABEL_14:
      v17 = 1;
      break;
    default:
LABEL_8:
      v17 = 0;
      break;
  }
  return v17;
}

uint64_t BOMCopierRedirectPath(uint64_t a1, int a2, char *__s)
{
  size_t v5;
  uint64_t v6;

  if (!__s)
    return 1;
  v5 = strlen(__s);
  v6 = 1;
  if (v5 <= 0x3FF)
  {
    memmove((void *)(a1 + 10592), __s, v5 + 1);
    *(_BYTE *)(a1 + 11616) = 1;
    return 0;
  }
  return v6;
}

uint64_t BOMCopierRedirectSourcePath(uint64_t a1, int a2, char *__s)
{
  size_t v5;
  uint64_t v6;

  if (!__s)
    return 1;
  v5 = strlen(__s);
  v6 = 1;
  if (v5 <= 0x3FF)
  {
    memmove((void *)(a1 + 11617), __s, v5 + 1);
    *(_BYTE *)(a1 + 12641) = 1;
    return 0;
  }
  return v6;
}

uint64_t BOMCopierCancelCopy(uint64_t result)
{
  if (result)
    *(_BYTE *)(result + 168) = 1;
  return result;
}

uint64_t BOMCopierCountFilesInArchive(uint64_t a1, char *__s, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t Code;
  const __CFDictionary *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFDictionary *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  int Type;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t Size;
  const char *SymlinkTarget;
  uint64_t Path;
  __int16 Mode;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char v72;
  _QWORD *v73;
  void *v74;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x24BDAC8D0];
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "BOMCopierCountFilesInArchive: missing path", (uint64_t)a3, a4, a5, a6, a7, a8, v72);
    return 22;
  }
  v12 = strlen(__s);
  if (v12 >= 0x400)
  {
    BOMCopierNotifyFatalError(a1, "BOMCopierCountFilesInArchive: maximum path length exceeded: %ld", v13, v14, v15, v16, v17, v18, v12);
    return 22;
  }
  values = (void *)*MEMORY[0x24BDBD270];
  keys[0] = CFSTR("extractLibarchive");
  v20 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (const void **)keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v20)
  {
    BOMCopierNotifyFatalError(a1, "Could not create empty BOMCopierSource options", v21, v22, v23, v24, v25, v26, v72);
    _resetCopier(a1);
    return 1;
  }
  v27 = v20;
  v74 = 0;
  v28 = BOMCopierSourceNew(__s, v20, 0, &v74);
  if (!v28)
  {
    Code = BOMCopierErrorGetCode((uint64_t)v74);
    BOMCopierErrorGetMessage((uint64_t)v74);
    BOMCopierNotifyFatalError(a1, "Could not create BOMCopierSource from %s: %s", v59, v60, v61, v62, v63, v64, (char)__s);
    CFRelease(v27);
    BOMCopierErrorFree(v74);
    return Code;
  }
  v29 = (void *)v28;
  v73 = (_QWORD *)a4;
  CFRelease(v27);
  v36 = BOMCopierSourceNext((uint64_t)v29, &v74, v30, v31, v32, v33, v34, v35);
  if (v36)
  {
    v37 = v36;
    v38 = 0;
    v39 = 0;
    while (1)
    {
      Type = BOMCopierSourceEntryGetType((uint64_t)v37);
      if (Type == 9)
      {
        SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget((uint64_t)v37);
        if (!SymlinkTarget)
          goto LABEL_16;
        Size = strlen(SymlinkTarget);
      }
      else
      {
        if (!Type)
        {
          BOMCopierNotifyFatalError(a1, "Unknown BOMCopierSourceEntry", v41, v42, v43, v44, v45, v46, v72);
          BOMCopierSourceEntryFree((unsigned int *)v37);
          BOMCopierSourceFree(v29);
          return 1;
        }
        Size = BOMCopierSourceEntryGetSize((uint64_t)v37);
      }
      v39 += Size;
LABEL_16:
      if (a1 && *(_QWORD *)(a1 + 88))
      {
        Path = BOMCopierSourceEntryGetPath((uint64_t)v37);
        Mode = BOMCopierSourceEntryGetMode((uint64_t)v37);
        v51 = BOMCopierSourceEntryGetSize((uint64_t)v37);
        v52 = BOMFSObjectTypeForMode(Mode);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(a1, Path, v52, v51);
      }
      BOMCopierSourceEntryFree((unsigned int *)v37);
      v37 = BOMCopierSourceNext((uint64_t)v29, &v74, v53, v54, v55, v56, v57, v58);
      ++v38;
      if (!v37)
        goto LABEL_24;
    }
  }
  v39 = 0;
  v38 = 0;
LABEL_24:
  BOMCopierSourceFree(v29);
  if (v74)
  {
    BOMCopierErrorGetMessage((uint64_t)v74);
    BOMCopierNotifyFatalError(a1, "Could not enumerate %s: %s", v65, v66, v67, v68, v69, v70, (char)__s);
    BOMCopierErrorFree(v74);
    return 1;
  }
  if (a3)
    *a3 = v38;
  Code = 0;
  if (v73)
    *v73 = v39;
  return Code;
}

uint64_t BOMCopierCountFilesInDirectory(uint64_t a1, char *__s, const __CFDictionary *a3, _QWORD *a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __CFDictionary *Mutable;
  __CFDictionary *v28;
  const void **v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __darwin_time_t v38;
  int v39;
  uint64_t *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __darwin_time_t tv_sec;
  __darwin_time_t v57;
  __darwin_suseconds_t tv_usec;
  __darwin_time_t v59;
  int v60;
  uint64_t matched;
  uint64_t Size;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const char *Message;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  timeval v87;
  void *v88;
  __int128 v89;
  void *v90[2];
  __int128 v91;

  if (!a1)
    return 1;
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "missing path parameter", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v86);
    return 1;
  }
  v13 = strlen(__s);
  if (v13 >= 0x400)
  {
    BOMCopierNotifyFatalError(a1, "maximum path length exceeded: %ld", v14, v15, v16, v17, v18, v19, v13);
    return 1;
  }
  if (a3)
  {
    if (_parseCopierOptions(a1, a3))
    {
      v26 = "Could not parse the options dictionary";
LABEL_49:
      BOMCopierNotifyFatalError(a1, v26, v20, v21, v22, v23, v24, v25, v86);
      goto LABEL_50;
    }
    if (_verifyCopierOptions(a1, 0, 0, v21, v22, v23, v24, v25))
    {
      v26 = "Could not verify the copier options";
      goto LABEL_49;
    }
    if (_prepareCopierState(a1))
    {
LABEL_50:
      _resetCopier(a1);
      return 1;
    }
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    v26 = "Could not create empty BOMCopierSource options";
    goto LABEL_49;
  }
  v28 = Mutable;
  v29 = (const void **)MEMORY[0x24BDBD270];
  if (*(_BYTE *)(a1 + 169) == 1)
    CFDictionarySetValue(Mutable, CFSTR("synthesizeResourceForks"), (const void *)*MEMORY[0x24BDBD270]);
  if (*(_BYTE *)(a1 + 192) == 1)
    CFDictionarySetValue(v28, CFSTR("crossDevices"), *v29);
  *(_OWORD *)v90 = 0u;
  v91 = 0u;
  v89 = 0u;
  v88 = 0;
  if (*(_QWORD *)(a1 + 136)
    && (CFDictionarySetValue(v28, CFSTR("discoverBinaries"), *v29),
        BOMCopierPrepareMatchContext(a3, (uint64_t)&v89, &v88))
    || (v30 = BOMCopierSourceNew(__s, v28, 0, &v88)) == 0)
  {
    BOMCopierErrorGetMessage((uint64_t)v88);
    BOMCopierNotifyFatalError(a1, "Could not create BOMCopierSource from %s: %s", v63, v64, v65, v66, v67, v68, (char)__s);
    CFRelease(v28);
    BOMCopierErrorFree(v88);
    return 1;
  }
  v31 = (void *)v30;
  CFRelease(v28);
  if (*(_QWORD *)(a1 + 120))
  {
    *(_QWORD *)(a1 + 12680) = 1;
    *(_DWORD *)(a1 + 12688) = 0;
    v87.tv_sec = 0;
    *(_QWORD *)&v87.tv_usec = 0;
    gettimeofday(&v87, 0);
    v38 = *(_QWORD *)(a1 + 12680) + v87.tv_sec;
    *(_QWORD *)(a1 + 12696) = v38;
    v39 = *(_DWORD *)(a1 + 12688) + v87.tv_usec;
    *(_DWORD *)(a1 + 12704) = v39;
    if (v39 > 999999)
    {
      *(_QWORD *)(a1 + 12696) = v38 + 1;
      *(_DWORD *)(a1 + 12704) = v39 - 1000000;
    }
  }
  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  v40 = BOMCopierSourceNext((uint64_t)v31, 0, v32, v33, v34, v35, v36, v37);
  if (v40)
  {
    v41 = v40;
    v42 = 0;
    v43 = 0;
    while (1)
    {
      switch(BOMCopierSourceEntryGetType((uint64_t)v41))
      {
        case 0u:
          BOMCopierNotifyFatalError(a1, "Unknown BOMCopierSourceEntry", v44, v45, v46, v47, v48, v49, v86);
          BOMCopierSourceEntryFree((unsigned int *)v41);
          BOMCopierSourceFree(v31);
          return 1;
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 9u:
        case 0xBu:
          ++v43;
          goto LABEL_31;
        case 8u:
          if (BOMCopierSourceEntryGetBinaryType((uint64_t)v41))
          {
            matched = BOMCopierMatchBinary((uint64_t)v41, (unsigned int *)&v89, &v88);
            if ((_DWORD)matched)
            {
              v69 = matched;
              Message = (const char *)BOMCopierErrorGetMessage((uint64_t)v88);
              BOMCopierNotifyFatalError(a1, Message, v80, v81, v82, v83, v84, v85, v86);
              BOMCopierErrorFree(v88);
              BOMCopierSourceEntryFree((unsigned int *)v41);
              BOMCopierSourceFree(v31);
              return v69;
            }
            Size = *((_QWORD *)&v91 + 1);
            if (v90[1])
              free(v90[1]);
          }
          else
          {
            Size = BOMCopierSourceEntryGetSize((uint64_t)v41);
          }
          v42 += Size;
          v43 += !BOMCopierSourceEntryIsResourceFork(v41);
LABEL_31:
          BOMCopierSourceEntryFree((unsigned int *)v41);
          if (!*(_QWORD *)(a1 + 120))
            goto LABEL_39;
          v87.tv_sec = 0;
          *(_QWORD *)&v87.tv_usec = 0;
          gettimeofday(&v87, 0);
          tv_sec = v87.tv_sec;
          v57 = *(_QWORD *)(a1 + 12696);
          if (v87.tv_sec == v57)
          {
            tv_usec = v87.tv_usec;
            if (v87.tv_usec >= *(_DWORD *)(a1 + 12704))
              goto LABEL_37;
          }
          else if (v87.tv_sec >= v57)
          {
            tv_usec = v87.tv_usec;
LABEL_37:
            (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 120))(a1, v43, v42);
            v59 = *(_QWORD *)(a1 + 12680) + tv_sec;
            *(_QWORD *)(a1 + 12696) = v59;
            v60 = *(_DWORD *)(a1 + 12688) + tv_usec;
            *(_DWORD *)(a1 + 12704) = v60;
            if (v60 > 999999)
            {
              *(_QWORD *)(a1 + 12696) = v59 + 1;
              *(_DWORD *)(a1 + 12704) = v60 - 1000000;
            }
          }
LABEL_39:
          v41 = BOMCopierSourceNext((uint64_t)v31, 0, v50, v51, v52, v53, v54, v55);
          if (!v41)
            goto LABEL_54;
          break;
        default:
          goto LABEL_31;
      }
    }
  }
  v43 = 0;
  v42 = 0;
LABEL_54:
  BOMCopierSourceFree(v31);
  v71 = BOMCopierReleaseMatchContext((unsigned int *)&v89, &v88);
  if ((_DWORD)v71)
  {
    v69 = v71;
    v72 = (const char *)BOMCopierErrorGetMessage((uint64_t)v88);
    BOMCopierNotifyFatalError(a1, v72, v73, v74, v75, v76, v77, v78, v86);
    BOMCopierErrorFree(v88);
  }
  else
  {
    if (a4)
      *a4 = v43;
    v69 = 0;
    if (a5)
      *a5 = v42;
  }
  return v69;
}

uint64_t BOMCopierSetUserData(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 48) = a2;
  return result;
}

uint64_t BOMCopierUserData(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

uint64_t BOMCopierSetFatalErrorHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 56) = a2;
  return result;
}

uint64_t BOMCopierSetFatalFileErrorHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t BOMCopierSetFileErrorHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 72) = a2;
  return result;
}

uint64_t BOMCopierSetFileConflictErrorHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 80) = a2;
  return result;
}

uint64_t BOMCopierSetCopyFileStartedHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 88) = a2;
  return result;
}

uint64_t BOMCopierSetCopyFileFinishedHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 96) = a2;
  return result;
}

uint64_t BOMCopierSetCopyFileUpdateHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 104) = a2;
  return result;
}

uint64_t BOMCopierSetCountFilesUpdateHandler(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 120) = a2;
  return result;
}

uint64_t BOMCopierSetPKZipPasswordRequester(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 128) = a2;
  return result;
}

uint64_t BOMCopierGetArchiveFileDescriptor(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t File;
  uint64_t v4;

  if (a1)
  {
    v1 = *(_DWORD *)(a1 + 12712);
    if (v1 == 2)
    {
      v4 = *(_QWORD *)(a1 + 12752);
      if (v4)
      {
        File = BOMPKZipGetFile(v4);
        return BOMFileGetFileDescriptor(File);
      }
    }
    else if (v1 == 1)
    {
      v2 = *(_QWORD *)(a1 + 12728);
      if (v2)
      {
        File = BOMCPIOGetFile(v2);
        return BOMFileGetFileDescriptor(File);
      }
    }
  }
  return 0xFFFFFFFFLL;
}

size_t _extractFileAndPath(char *a1, char *a2)
{
  char *v4;
  size_t result;
  __int16 v6;

  v4 = strrchr(a1, 47);
  if (v4)
  {
    *v4 = 0;
    result = strlcpy(a2, v4 + 1, 0x400uLL);
    if (*a1)
      return result;
    v6 = 47;
  }
  else
  {
    result = strlcpy(a2, a1, 0x400uLL);
    v6 = 46;
  }
  *(_WORD *)a1 = v6;
  return result;
}

uint64_t _initializeAFSCData(uint64_t a1)
{
  uint64_t result;

  result = __strlcpy_chk();
  if (!*(_BYTE *)(a1 + 195))
    goto LABEL_7;
  if (*(_DWORD *)(a1 + 12712) || (result = VolumeSupportsCompression(), (result & 1) == 0))
  {
    *(_BYTE *)(a1 + 195) = 0;
    goto LABEL_7;
  }
  if (!*(_BYTE *)(a1 + 195))
  {
LABEL_7:
    if (!*(_BYTE *)(a1 + 12848))
      return result;
  }
  if (*(_DWORD *)(a1 + 12716) == 3 && (result = VolumeSupportsCompression(), (_DWORD)result))
  {
    if (*(_BYTE *)(a1 + 12848))
    {
      if (!*(_QWORD *)(a1 + 12864))
      {
        result = CreateStreamCompressorQueueWithOptions();
        *(_QWORD *)(a1 + 12864) = result;
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 195) = 0;
    *(_BYTE *)(a1 + 12848) = 0;
  }
  return result;
}

void _applyIndexBomOwnershipForTargetArchive(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t FSObjectAtPath;
  uint64_t v6;

  v3 = *(_QWORD *)(a1 + 152);
  if (v3)
  {
    FSObjectAtPath = BOMBomGetFSObjectAtPath(v3, a2);
    if (FSObjectAtPath)
    {
      v6 = FSObjectAtPath;
      *(_DWORD *)(a3 + 16) = BOMFSObjectUserID(FSObjectAtPath);
      *(_DWORD *)(a3 + 20) = BOMFSObjectGroupID(v6);
      BOMFSObjectFree(v6);
    }
  }
}

uint64_t _copyFromDirToDir(uint64_t a1, _DWORD *a2, _BYTE *a3, uint64_t a4, _BYTE *a5, uint64_t a6, unsigned int a7)
{
  char *v13;
  char *v14;
  int *v15;
  void (*v16)(uint64_t, uint64_t, _QWORD);
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  size_t v21;
  int v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL4 v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int *v31;
  unint64_t v32;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void **v42;
  unint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  char **v53;
  void **v54;
  uint64_t i;
  void **v56;
  void **v57;
  char v59;
  char *__source;
  _BOOL4 v61;
  uint64_t v62;
  _BYTE *v63;
  _BYTE *v64;
  unint64_t v65;
  size_t __size;
  unsigned int v67;
  unsigned int v68;
  void **v69;
  _OWORD v70[9];
  _OWORD v71[9];
  uint64_t v72;
  unsigned int v73;
  unsigned __int8 v74;
  statfs v75;
  _OWORD v76[66];
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  v74 = 0;
  v72 = 0;
  memset(v76, 0, 512);
  memset(v71, 0, sizeof(v71));
  memset(&v70[2], 0, 112);
  *a3 = 47;
  *a5 = 47;
  a3[1] = 0;
  v13 = a3 + 1;
  memset(v70, 0, 32);
  a5[1] = 0;
  v14 = a5 + 1;
  if (*(_BYTE *)(a1 + 192) == 1)
  {
    if (*(_DWORD *)(a1 + 232) == *a2)
      goto LABEL_11;
    memset(&v75, 0, 512);
    if (!statfs((const char *)(a1 + 248), &v75))
    {
      *(_BYTE *)(a1 + 210) = (v75.f_flags & 8) == 0;
      goto LABEL_11;
    }
    v15 = __error();
    v16 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 64);
    if (v16)
      v16(a1, a1 + 248, *v15);
    return 0;
  }
  if (!*(_BYTE *)(a1 + 192) && *(_DWORD *)(a1 + 232) != *a2)
    return 0;
LABEL_11:
  v18 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 272))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248);
  if (!v18)
  {
    *a5 = 0;
    *a3 = 0;
    __error();
    return _checkCopyFileError(a1);
  }
  v19 = v18;
  v68 = a7;
  v63 = a5;
  v64 = a3;
  v20 = a6 - 1;
  v21 = a4 - 1;
  v73 = 0;
  __size = a6 - 1;
  if (a6 - 1 >= (unint64_t)(a4 - 1))
    v20 = a4 - 1;
  v65 = v20;
  v22 = (*(uint64_t (**)(_QWORD, uint64_t, _OWORD *, uint64_t *))(*(_QWORD *)(a1 + 12832) + 296))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v18, v76, &v72);
  v23 = 0;
  v17 = 0;
  v24 = v22 == 0;
  v69 = 0;
  if (v22 || (v25 = v72) == 0)
  {
LABEL_80:
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 280))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v19);
    if (v24)
    {
      if (!(_DWORD)v17)
      {
        if (v69 && v23)
        {
          v54 = v69;
          for (i = v23; i; --i)
          {
            v73 = 0;
            if (*v54)
            {
              if (*(_BYTE *)(a1 + 168))
                goto LABEL_94;
              if ((unint64_t)v54[1] + 1 > v65
                || (strlcpy(v14, (const char *)*v54, __size),
                    strncpy(v13, (const char *)*v54, v21),
                    (*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248, v71)))
              {
                __error();
                if (_checkCopyFileError(a1))
                  goto LABEL_94;
              }
              else if (_checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v71, (uint64_t)v70, &v74, &v73) != 1&& _copyFile(a1, (uint64_t)v71, (uint64_t)v70, v74, *(_DWORD **)(a1 + 136), &v73, 0) == 2)
              {
LABEL_94:
                v19 = 0;
                goto LABEL_95;
              }
            }
            v54 += 2;
          }
        }
        v19 = 0;
        v17 = 0;
        *v63 = 0;
        *v64 = 0;
LABEL_101:
        v56 = v69;
        if (v69)
          goto LABEL_102;
        goto LABEL_106;
      }
    }
    else
    {
      v17 = _checkCopyFileError(a1);
    }
    v19 = 0;
    goto LABEL_101;
  }
  v23 = 0;
  v69 = 0;
  v17 = 0;
  v67 = 0;
  v62 = 0;
  while (1)
  {
    v73 = 0;
    if (_ignore_readdir_entry(v25))
      goto LABEL_43;
    if (*(_BYTE *)(a1 + 168))
      goto LABEL_99;
    if (strlcpy(v13, (const char *)(v72 + 21), v21) >= v21)
      goto LABEL_40;
    v26 = *(_QWORD *)(a1 + 152);
    if (v26)
    {
      v67 = BOMBomPathIDForKey(v26, v68, (char *)(v72 + 21));
      if (!v67)
      {
        v67 = 0;
        goto LABEL_43;
      }
    }
    v27 = *(_QWORD *)(a1 + 160);
    if (v27)
      v28 = BOMBomFSObjectExistsAtPath(v27, *(_QWORD *)(a1 + 2296));
    else
      v28 = 0;
    if ((*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248, v71))
    {
      __error();
      v29 = a1;
      goto LABEL_41;
    }
    if (*(_BYTE *)(a1 + 12746) && *(_DWORD *)(a1 + 12716) == 4)
      _applyIndexBomOwnershipForTargetArchive(a1, *(char **)(a1 + 2296), (uint64_t)v71);
    if (*(unsigned __int16 *)(v72 + 18) > 0xF9u)
    {
      v61 = v28;
      v75.f_bfree = 0;
      *(_OWORD *)&v75.f_bsize = xmmword_2063CFD74;
      v31 = (unsigned int *)BOM_malloczero(0x30CuLL);
      if ((*(unsigned int (**)(_QWORD, uint64_t, statfs *, unsigned int *, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 120))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248, &v75, v31, 780, 1))
      {
        free(v31);
        __error();
        v17 = _checkCopyFileError(a1);
        if (v17 > 1)
          goto LABEL_99;
        goto LABEL_43;
      }
      v32 = v31[2];
      if (v65 < v32)
      {
        free(v31);
LABEL_40:
        v29 = a1;
LABEL_41:
        if (_checkCopyFileError(v29))
          goto LABEL_99;
        v17 = 0;
        goto LABEL_43;
      }
      __source = (char *)v31 + (int)v31[1] + 4;
      strlcpy(v14, __source, __size);
      strlcpy(v13, __source, v21);
      free(v31);
      v30 = v32 - 1;
      v28 = v61;
    }
    else
    {
      if (strlcpy(v14, (const char *)(v72 + 21), __size) >= __size)
      {
        v29 = a1;
        goto LABEL_41;
      }
      v30 = *(unsigned __int16 *)(v72 + 18);
    }
    v34 = _checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v71, (uint64_t)v70, &v74, &v73);
    if (v73 != 1)
      break;
    if ((_DWORD)v34 == 1)
    {
      v17 = v34;
    }
    else if ((_DWORD)v34)
    {
LABEL_99:
      v17 = 2;
      goto LABEL_101;
    }
LABEL_43:
    v24 = (*(unsigned int (**)(_QWORD, uint64_t, _OWORD *, uint64_t *))(*(_QWORD *)(a1 + 12832) + 296))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v19, v76, &v72) == 0;
    v25 = v72;
    if (!v24 || v72 == 0)
      goto LABEL_80;
  }
  v35 = WORD2(v71[0]) & 0xF000;
  if (v28)
  {
    if (v35 != 0x4000)
      goto LABEL_43;
    goto LABEL_66;
  }
  if (v35 != 0x8000)
  {
LABEL_66:
    HIDWORD(v43) = v35;
    LODWORD(v43) = v35 - 0x2000;
    switch((v43 >> 13))
    {
      case 0u:
      case 2u:
        v44 = _copyDevice(a1, (uint64_t)v71);
        break;
      case 1u:
        v44 = _copyDir(a1, (uint64_t)v71, (uint64_t)v70, v30, v74, (uint64_t)v13, v21, v14, __size, v67, v28);
        break;
      case 3u:
        v44 = _copyFile(a1, (uint64_t)v71, (uint64_t)v70, v74, *(_DWORD **)(a1 + 136), &v73, 0);
        break;
      case 4u:
        v44 = _copyLink(a1, (uint64_t)v71, (uint64_t)v70, v74);
        break;
      default:
        goto LABEL_43;
    }
    if ((_DWORD)v44 == 1)
    {
      v17 = 1;
    }
    else if ((_DWORD)v44 == 2)
    {
      v17 = v44;
      goto LABEL_101;
    }
    goto LABEL_43;
  }
  if (*(_DWORD *)(a1 + 12716) != 3)
  {
    v35 = 0x8000;
    goto LABEL_66;
  }
  if (!BOMAppleDoubleIsADFile((const char *)(a1 + 248)))
  {
    v35 = WORD2(v71[0]) & 0xF000;
    goto LABEL_66;
  }
  if (v62)
  {
    if (v62 == v23)
    {
      v62 = 2 * v23;
      v42 = (void **)BOM_realloc(v69, 32 * v23);
    }
    else
    {
      v42 = v69;
    }
  }
  else
  {
    v42 = (void **)BOM_malloc(0x40uLL);
    v62 = 4;
  }
  v69 = v42;
  if (!v42)
  {
    BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double files.", v36, v37, v38, v39, v40, v41, v59);
    v17 = 2;
    goto LABEL_107;
  }
  v45 = (char *)BOM_malloc(v30 + 1);
  if (v45)
  {
    v52 = v45;
    strlcpy(v45, v13, v30 + 1);
    v53 = (char **)&v69[2 * v23];
    *v53 = v52;
    v53[1] = (char *)v30;
    ++v23;
    goto LABEL_43;
  }
  BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double filename.", v46, v47, v48, v49, v50, v51, v59);
LABEL_95:
  v17 = 2;
  v56 = v69;
LABEL_102:
  if (v23)
  {
    v57 = v56;
    do
    {
      free(*v57);
      *v57 = 0;
      v57 += 2;
      --v23;
    }
    while (v23);
  }
  free(v56);
LABEL_106:
  if (v19)
LABEL_107:
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 280))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v19);
  return v17;
}

uint64_t _copyFromFileToDir(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4, _BYTE *a5, uint64_t a6, unsigned int a7, int a8)
{
  char *v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  size_t v20;
  const char *v21;
  unint64_t v22;
  _OWORD v23[9];
  _OWORD v24[9];
  unsigned int v25;
  unsigned __int8 v26[9];

  v26[0] = 0;
  *a3 = 47;
  v25 = 0;
  *a5 = 47;
  v15 = a5 + 1;
  v16 = (_BYTE *)(a1 + 2304);
  if (strlcpy(a3 + 1, (const char *)(a1 + 2304), a4 - 1) >= a4 - 1)
    return 1;
  v17 = *(_QWORD *)(a1 + 152);
  if (v17)
  {
    if (!BOMBomPathIDForKey(v17, a7, (char *)(a1 + 2304)))
      return 1;
  }
  v18 = *(_QWORD *)(a1 + 160);
  if (v18)
  {
    if (BOMBomFSObjectExistsAtPath(v18, *(_QWORD *)(a1 + 2296)))
      return 1;
  }
  memset(v24, 0, sizeof(v24));
  memset(v23, 0, sizeof(v23));
  if ((*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248, v24))
  {
LABEL_7:
    __error();
    return _checkCopyFileError(a1);
  }
  v20 = a6 - 1;
  if (*(_BYTE *)(a1 + 12746) && *(_DWORD *)(a1 + 12716) == 4)
    _applyIndexBomOwnershipForTargetArchive(a1, *(char **)(a1 + 2296), (uint64_t)v24);
  v21 = (const char *)(*(_BYTE *)(a1 + 6400) ? a1 + 6400 : a1 + 2304);
  if (strlcpy(v15, v21, v20) >= v20)
    return 1;
  if (a8)
  {
    result = _checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v24, (uint64_t)v23, v26, &v25);
    if (v25 == 1)
      return result;
  }
  else
  {
    v26[0] = 0;
    result = 1;
  }
  HIDWORD(v22) = WORD2(v24[0]) & 0xF000;
  LODWORD(v22) = HIDWORD(v22) - 0x2000;
  switch((v22 >> 13))
  {
    case 0u:
    case 2u:
      result = _copyDevice(a1, (uint64_t)v24);
      break;
    case 3u:
      result = _copyFile(a1, (uint64_t)v24, (uint64_t)v23, v26[0], *(_DWORD **)(a1 + 136), &v25, 0);
      break;
    case 4u:
      result = _copyLink(a1, (uint64_t)v24, (uint64_t)v23, v26[0]);
      break;
    default:
      break;
  }
  if (!(_DWORD)result)
  {
    *a5 = 0;
    *a3 = 0;
    *v16 = 0;
    if (!a8)
    {
      if (*(_DWORD *)(a1 + 12716) == 3)
      {
        result = set_timestamps_0((const char *)(a1 + 3328), (__int128 *)(a2 + 32), (_OWORD *)(a2 + 48));
        if ((_DWORD)result)
          goto LABEL_7;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _copyExtendedAttributes(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5)
{
  int v10;
  char *v11;
  const char *v12;
  uint64_t v14;
  size_t v15;
  size_t v16;
  uint64_t v17;
  char *v19;
  char *v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;

  v10 = *(_DWORD *)(a1 + 12716);
  if (v10 != 3)
  {
    v11 = (char *)(a1 + 7424);
    if (*(_BYTE *)(a1 + 11616))
      v12 = (const char *)(a1 + 10592);
    else
      v12 = *(const char **)(a1 + 2296);
    strncpy(v11, v12, 0x400uLL);
  }
  if (a5)
  {
    if (v10 == 3 && *a5 == 2)
      return 0;
  }
  if ((*(_DWORD *)(a3 + 116) & 0x40000020) == 0x20 && *(_BYTE *)(a1 + 195))
  {
    if (*(_BYTE *)(a1 + 196))
      v14 = 1;
    else
      v14 = 33;
  }
  else
  {
    v14 = 1;
  }
  v15 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 144))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, 0, 0, v14);
  if (v15 == -1)
    goto LABEL_48;
  v16 = v15;
  if (!v15)
  {
    if (a5)
    {
      v17 = 0;
      *a5 = 1;
      return v17;
    }
    return 0;
  }
  v19 = (char *)BOM_malloc(v15);
  if (!v19
    || (v20 = v19,
        v21 = (*(uint64_t (**)(_QWORD, uint64_t, char *, size_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 144))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v19, v16, v14), v21 == -1))
  {
LABEL_48:
    __error();
    return _checkCopyFileError(a1);
  }
  if (v21 < 1)
  {
    v22 = 0;
LABEL_50:
    v17 = 0;
    if (a5)
    {
      *a5 = 0;
      if (!v22)
        goto LABEL_56;
    }
    else
    {
LABEL_54:
      if (!v22)
        goto LABEL_56;
    }
LABEL_55:
    free(v22);
    goto LABEL_56;
  }
  v22 = 0;
  v23 = &v20[v21];
  v24 = 3328;
  if (a4)
    v24 = 7424;
  v34 = v20;
  v35 = a1 + v24;
  v25 = v20;
  v33 = &v20[v21];
  while (1)
  {
    if (!strcmp(v25, "com.apple.FinderInfo") || !strcmp(v25, "com.apple.ResourceFork"))
    {
      if (!*(_BYTE *)(a1 + 169))
        goto LABEL_46;
    }
    else if (!*(_BYTE *)(a1 + 170))
    {
      goto LABEL_46;
    }
    v26 = (*(uint64_t (**)(_QWORD, uint64_t, const char *, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 128))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v25, 0, 0, 0, v14);
    if (v26 == -1)
      break;
    v27 = v26;
    if (!v22)
    {
      v22 = BOM_malloc(0x800000uLL);
      if (!v22)
      {
        __error();
        v17 = _checkCopyFileError(a1);
        goto LABEL_56;
      }
    }
    if (v27)
    {
      v28 = 0;
      v29 = 0;
      while (1)
      {
        v30 = (unint64_t)(v27 - v29) >= 0x800000 ? 0x800000 : v27 - v29;
        v31 = (*(uint64_t (**)(_QWORD, uint64_t, const char *, void *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 128))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v25, v22, v30, v28, v14);
        if (v31 == -1)
          break;
        v32 = v31;
        if ((*(unsigned int (**)(_QWORD, uint64_t, const char *, void *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 136))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v35, v25, v22, v31, v28, 1) == -1)break;
        v29 += v32;
        v28 = (v28 + v32);
        if (v29 == v27)
        {
          v23 = v33;
          v20 = v34;
          goto LABEL_46;
        }
      }
      __error();
      v17 = _checkCopyFileError(a1);
      v20 = v34;
      goto LABEL_54;
    }
LABEL_46:
    v25 += strlen(v25) + 1;
    if (v25 >= v23)
      goto LABEL_50;
  }
  __error();
  v17 = _checkCopyFileError(a1);
  if (v22)
    goto LABEL_55;
LABEL_56:
  free(v20);
  return v17;
}

uint64_t _copyACLs(uint64_t a1, char *path_p, int a3, int a4, _DWORD *a5)
{
  acl_t link_np;
  _acl *v10;
  _acl *v11;
  uint64_t v12;
  acl_t file;
  _acl *v14;
  int v15;
  const char *v16;
  int v17;
  acl_flagset_t flagset_d;
  acl_t acl_p;
  acl_entry_t v21;
  acl_entry_t entry_p;

  v21 = 0;
  entry_p = 0;
  acl_p = 0;
  if (*(_DWORD *)(a1 + 12716) != 3)
    return 0;
  flagset_d = 0;
  if (a4)
  {
    link_np = acl_get_link_np(path_p, ACL_TYPE_EXTENDED);
    if (link_np)
    {
      v10 = link_np;
      v11 = acl_get_link_np((const char *)(a1 + 3328), ACL_TYPE_EXTENDED);
      goto LABEL_8;
    }
LABEL_26:
    if (*__error() == 2)
    {
      v12 = 0;
      if (a5)
        *a5 = 0;
    }
    else
    {
      __error();
      v12 = _checkCopyFileError(a1);
    }
    goto LABEL_36;
  }
  file = acl_get_file(path_p, ACL_TYPE_EXTENDED);
  if (!file)
    goto LABEL_26;
  v10 = file;
  v11 = acl_get_file((const char *)(a1 + 3328), ACL_TYPE_EXTENDED);
LABEL_8:
  acl_p = v11;
  if (!v11)
  {
    if (*__error() != 2 && *__error() != 63)
      goto LABEL_34;
    acl_p = acl_init(4);
  }
  v14 = v10;
  v15 = 0;
  while (!acl_get_entry(v14, v15, &entry_p))
  {
    acl_get_flagset_np(entry_p, &flagset_d);
    if (!acl_get_flag_np(flagset_d, ACL_ENTRY_INHERITED)
      && (acl_create_entry(&acl_p, &v21) == -1 || acl_copy_entry(v21, entry_p) == -1))
    {
      goto LABEL_34;
    }
    if (entry_p)
      v15 = -1;
    else
      v15 = 0;
    v14 = v10;
  }
  if (a3)
    v16 = (const char *)(a1 + 7424);
  else
    v16 = (const char *)(a1 + 3328);
  if (a4)
    v17 = acl_set_link_np(v16, ACL_TYPE_EXTENDED, acl_p);
  else
    v17 = acl_set_file(v16, ACL_TYPE_EXTENDED, acl_p);
  if (v17 != -1)
  {
    v12 = 0;
    if (a5)
      *a5 = 0;
    goto LABEL_35;
  }
LABEL_34:
  __error();
  v12 = _checkCopyFileError(a1);
LABEL_35:
  acl_free(v10);
LABEL_36:
  if (acl_p)
    acl_free(acl_p);
  return v12;
}

uint64_t _checkForDestinationConflict(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, _BYTE *a5, _DWORD *a6)
{
  char *v12;
  size_t v13;
  uint64_t v14;
  char v16;
  __int16 v17;
  int v18;
  int v19;
  int v20;

  *a5 = 0;
  *a6 = 0;
  if (*(_BYTE *)(a1 + 12820))
  {
    v12 = dirname_r(a2, (char *)(a1 + 9472));
    if (!v12
      || !(*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v12, a1 + 8448)&& *__error() != 2)
    {
      goto LABEL_31;
    }
    v13 = strlen((const char *)(a1 + 4352));
    if (strncmp((const char *)(a1 + 4352), (const char *)(a1 + 8448), v13))
    {
      *a6 = 1;
      v14 = a1;
      return _checkCopyFileError(v14);
    }
  }
  if ((*(unsigned int (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, a4))
  {
LABEL_8:
    if (*__error() == 2 || *__error() == 63)
      goto LABEL_10;
    goto LABEL_31;
  }
  v16 = 1;
  while (1)
  {
    v17 = *(_WORD *)(a4 + 4);
    v18 = v17 & 0xF000;
    if ((*(_WORD *)(a3 + 4) & 0xF000) != 0x4000)
    {
      if (v18 != 0x4000)
        goto LABEL_35;
LABEL_21:
      if ((v16 & 1) == 0
        || (BOMFSObjectTypeForMode(v17),
            BOMFSObjectTypeForMode(*(_WORD *)(a3 + 4)),
            _checkCopyFileConflictError(a1) != 3))
      {
        *a6 = 1;
        goto LABEL_32;
      }
      goto LABEL_23;
    }
    if (v18 == 0x4000)
      goto LABEL_35;
    if (v18 != 40960)
      goto LABEL_21;
    v19 = *(_DWORD *)(a1 + 12816);
    if (v19 != 2)
      break;
    if ((v16 & 1) == 0)
      goto LABEL_36;
    BOMFSObjectTypeForMode(v17);
    BOMFSObjectTypeForMode(*(_WORD *)(a3 + 4));
    if (_checkCopyFileConflictError(a1) != 3)
      goto LABEL_36;
LABEL_23:
    v20 = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, a4);
    v16 = 0;
    if (v20)
      goto LABEL_8;
  }
  if (v19 == 1)
  {
    if ((*(unsigned int (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, a4))
    {
      goto LABEL_31;
    }
    if ((*(_WORD *)(a4 + 4) & 0xF000) == 0x4000)
    {
LABEL_35:
      *a5 = 1;
      return 0;
    }
LABEL_36:
    *a6 = 1;
    v14 = a1;
    return _checkCopyFileError(v14);
  }
  if (v19)
    return 0;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328))
  {
LABEL_31:
    *a6 = 1;
    __error();
LABEL_32:
    v14 = a1;
    return _checkCopyFileError(v14);
  }
LABEL_10:
  *a5 = 0;
  return 0;
}

uint64_t _copyFile(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 a4, _DWORD *a5, unsigned int *a6, int a7)
{
  _BYTE *v11;
  int v12;
  int v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t File;
  uint64_t v28;
  int v29;
  _BOOL4 v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  unsigned int v37;
  int *v38;
  int v39;
  unsigned int v40;
  BOOL v41;
  const void *v42;
  unsigned int *v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t FSObjectAtPath;
  uint64_t v54;
  int v55;
  void (*v56)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD);
  unsigned int v58;
  char *v59;
  _BOOL4 v60;
  unsigned int v61;
  uint64_t v62;
  _OWORD v65[7];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;
  char v71;
  unsigned int v72;
  char v73[9];

  v73[0] = a4;
  v72 = 0;
  v71 = 0;
  v70 = 0;
  v11 = (_BYTE *)(a1 + 11616);
  v69 = 0uLL;
  v68 = 0uLL;
  if (*(_DWORD *)(a1 + 12712))
  {
LABEL_2:
    v12 = 0;
    v13 = 0;
    v14 = (int *)(a2 + 116);
    v60 = (*(_DWORD *)(a2 + 116) & 0x40000020) == 32;
    v15 = *(_QWORD *)(a2 + 96);
    goto LABEL_3;
  }
  if (BOMAppleDoubleIsADFile((const char *)(a1 + 248)))
  {
    if (*(_BYTE *)(a1 + 169))
      goto LABEL_21;
    goto LABEL_2;
  }
  v14 = (int *)(a2 + 116);
  v29 = *(_DWORD *)(a2 + 116) & 0x40000020;
  v30 = v29 == 32;
  if (v29 == 32)
  {
    if (*(_BYTE *)(a1 + 195))
      v32 = 33;
    else
      v32 = 1;
  }
  else
  {
    v32 = 1;
  }
  v33 = *(_QWORD *)(a2 + 96);
  v34 = (*(uint64_t (**)(_QWORD, uint64_t, const char *, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 12832)
                                                                                                  + 128))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 248, "com.apple.ResourceFork", 0, 0, 0, v32);
  v60 = v30;
  if (v34 == -1)
  {
    if (*__error() != 2 && *__error() != 93 && *__error() != 45)
    {
      v38 = __error();
      v34 = 0;
      v13 = *v38;
      goto LABEL_45;
    }
    v34 = 0;
  }
  v13 = 0;
LABEL_45:
  v15 = v34 + v33;
  v12 = 1;
LABEL_3:
  if (*(_DWORD *)(a1 + 12712))
    v16 = a1 + 248;
  else
    v16 = *(_QWORD *)(a1 + 2296);
  v17 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  *v11 = 0;
  v11[1025] = 0;
  v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88);
  v62 = v16;
  v61 = v17;
  if (v18)
  {
    v19 = v16;
    v20 = v15;
    v21 = v18(a1, v19, v17, v15);
  }
  else
  {
    v20 = v15;
    v21 = 0;
  }
  if (*(_BYTE *)(a1 + 168))
    v22 = 2;
  else
    v22 = v21;
  if ((_DWORD)v22 == 1)
  {
LABEL_21:
    *a6 = 1;
    v25 = *(_DWORD *)(a1 + 12712);
    if (v25 == 2)
    {
      File = BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
      v28 = File;
      if (v11[1153] && BOMFileSetCompression(File, 1, 1, *(_DWORD *)(a1 + 12792)))
      {
        __error();
        _checkCopyFileError(a1);
        v22 = 2;
        goto LABEL_144;
      }
      if (*(_DWORD *)(a1 + 12776))
        BOMFileSetPartialRead(v28, 1);
      v26 = _skipPKZipFile();
    }
    else
    {
      if (v25 != 1)
        goto LABEL_143;
      v26 = _skipCPIOFile(a1);
    }
    v22 = 2 * (v26 != 0);
    goto LABEL_144;
  }
  if ((_DWORD)v22 != 2)
  {
    if (v13)
    {
      v23 = a1;
LABEL_19:
      v24 = _checkCopyFileError(v23);
LABEL_20:
      v22 = v24;
      goto LABEL_144;
    }
    if (*v11)
    {
      LODWORD(v65[0]) = 0;
      v31 = (char *)(a1 + 10592);
      v24 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, v73, v65);
      if (LODWORD(v65[0]) == 1)
        goto LABEL_20;
    }
    else
    {
      v31 = (char *)(a1 + 3328);
    }
    v59 = v31;
    if (v11[1025] && !*(_DWORD *)(a1 + 12712))
    {
      v35 = (char *)(a1 + 11617);
      if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 11617, a2) == -1)
      {
LABEL_90:
        __error();
        v23 = a1;
        goto LABEL_19;
      }
      if ((*(_WORD *)(a2 + 4) & 0xF000) != 0x8000)
      {
        v23 = a1;
        goto LABEL_19;
      }
    }
    else
    {
      v35 = (char *)(a1 + 248);
    }
    if (*(_DWORD *)(a1 + 12716) == 3)
      v58 = *v14;
    else
      v58 = 0;
    *(_BYTE *)(a1 + 196) = 1;
    v36 = _copyDataFork(a1, v35, a2, a3, v73[0], a5, a6, a7);
    if ((_DWORD)v36)
    {
      v22 = v36;
      if (*(_DWORD *)(a1 + 12716) != 3)
        goto LABEL_144;
LABEL_55:
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424);
      goto LABEL_144;
    }
    if (*a6)
    {
      v72 = *a6;
    }
    else
    {
      if (*(_DWORD *)(a1 + 12716) == 3)
      {
        if (v11[1232] || (v37 = *(unsigned __int8 *)(a1 + 195), *(_BYTE *)(a1 + 195)))
        {
          v70 = AFSCLockFilePath();
          if (!v70)
          {
LABEL_94:
            __error();
            (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424);
LABEL_95:
            v23 = a1;
            goto LABEL_19;
          }
          v37 = *a6;
        }
      }
      else
      {
        v37 = 0;
      }
      v72 = v37;
      if (v37)
        v39 = 0;
      else
        v39 = v12;
      if (v39 == 1)
      {
        if (*(_DWORD *)(a1 + 12716) == 3)
        {
          if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169))
            v40 = _copyExtendedAttributes(a1, (uint64_t)v35, a2, 1, &v72);
          else
            v40 = 0;
          if (v40)
            v41 = 1;
          else
            v41 = *(_BYTE *)(a1 + 172) == 0;
          if (v41)
            v22 = v40;
          else
            v22 = 0;
          if (*(_BYTE *)(a1 + 171) && !(_DWORD)v22)
            v22 = _copyACLs(a1, v35, 1, 0, &v72);
          if ((_DWORD)v22)
            goto LABEL_55;
        }
        else
        {
          v22 = _copyAppleDoubleToArchive(a1, (uint64_t)v35, a2, &v72);
          if ((_DWORD)v22)
            goto LABEL_144;
        }
      }
    }
    v42 = *(const void **)(a1 + 216);
    if (v42 && setxattr((const char *)(a1 + 7424), "com.apple.provenance", v42, *(_QWORD *)(a1 + 224), 0, 1))
      goto LABEL_90;
    v43 = a6;
    v44 = v20;
    v45 = v62;
    if (!*a6 && *(_DWORD *)(a1 + 12716) == 3)
    {
      if (_chPerms(a1, (char *)(a1 + 7424), a2, &v71, 1))
        goto LABEL_94;
      v46 = *(_OWORD *)(a2 + 32);
      v68 = *(_OWORD *)(a2 + 48);
      v69 = v46;
      if (set_timestamps_0((const char *)(a1 + 7424), &v69, &v68))
      {
        if (*__error() != 13 && *__error() != 1)
          goto LABEL_94;
        *__error() = 0;
      }
      if (*(_DWORD *)(a1 + 12712)
        && *(_DWORD *)(a1 + 12716) == 3
        && *(_BYTE *)(a1 + 169)
        && BOMAppleDoubleIsADFile(v59))
      {
        __strlcpy_chk();
        __strlcat_chk();
        if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 264))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, a1 + 8448))
        {
          goto LABEL_94;
        }
        v43 = a6;
        v45 = v62;
        if (v62 == a1 + 248)
          __strlcat_chk();
      }
      else if (!v11[1207]
             && (a7 & 1) == 0
             && (*(unsigned int (**)(_QWORD, uint64_t, char *))(*(_QWORD *)(a1 + 12832) + 264))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, v59))
      {
        goto LABEL_94;
      }
      if (v58)
      {
        if (*(_DWORD *)(a1 + 10496))
          v47 = v58 & 0xC000FFFF;
        else
          v47 = v58;
        if (v60 && (!*(_BYTE *)(a1 + 195) || *(_BYTE *)(a1 + 196)))
          v47 = v47 & 0xFFFFFFDF;
        if ((_DWORD)v47)
        {
          v48 = v45;
          v49 = v44;
          v50 = *v14;
          v66 = 0u;
          v67 = 0u;
          memset(v65, 0, sizeof(v65));
          if (!(*(unsigned int (**)(_QWORD, char *, _OWORD *))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v59, v65))
          {
            v50 = DWORD1(v66);
            if ((DWORD1(v66) & 0x40000020) == 0x20)
              v51 = v47 | 0x20;
            else
              v51 = v47;
            if (v11[1232])
              v52 = v51;
            else
              v52 = v47;
            if ((~v52 & 0x40000020) != 0)
              v47 = v52;
            else
              v47 = v52 & 0xBFFFFFDF;
          }
          if (change_flags_0(a1, v59, v50, v47) || set_timestamps_0(v59, &v69, &v68))
          {
            __error();
            goto LABEL_95;
          }
          v44 = v49;
          v45 = v48;
        }
      }
      if (*(_BYTE *)(a1 + 197))
      {
        FSObjectAtPath = BOMBomGetFSObjectAtPath(*(_QWORD *)(a1 + 152), *(char **)(a1 + 2296));
        v54 = v44;
        v55 = BOMFSObjectChecksum(FSObjectAtPath);
        BOMFSObjectFree(FSObjectAtPath);
        v41 = v55 == *(_DWORD *)(a1 + 200);
        v44 = v54;
        if (!v41)
        {
          if (*(_QWORD *)(a1 + 56))
            goto LABEL_95;
        }
      }
    }
    if (*(_DWORD *)(a1 + 12712) == 2 && *(_DWORD *)(a1 + 12776))
      v44 = *(_QWORD *)(a2 + 96);
    v56 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD))(a1 + 96);
    if (v56)
      v56(a1, v45, v61, v44, *v43);
LABEL_143:
    v22 = 0;
  }
LABEL_144:
  _unlockAFSCFileLock(&v70);
  return v22;
}

uint64_t _copyDir(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, char *a8, size_t a9, unsigned int a10, unsigned __int8 a11)
{
  int v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t, uint64_t, uint64_t, _QWORD);
  int v21;
  int v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  void *v27;
  int v28;
  int v29;
  const char *v30;
  int v32;
  _BOOL4 v33;
  char *v34;
  int v35;
  int v36;
  __int128 v37;
  char *v38;
  int v39;
  uint64_t File;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int *v46;
  uint64_t v47;
  void (*v48)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v49;
  int v50;
  unsigned int v51;
  int v52;
  char *path_p;
  unsigned int v54;
  char *v55;
  size_t v56;
  uint64_t v57;
  unint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  __int128 v64;
  __int128 v65;
  unsigned __int8 v66;
  _BYTE v67[9];

  v16 = a11;
  v67[0] = a5;
  v66 = 0;
  v65 = 0uLL;
  v64 = 0uLL;
  if (!*(_DWORD *)(a1 + 12712)
    && *(_DWORD *)a2 == *(_DWORD *)(a1 + 236)
    && *(_QWORD *)(a2 + 8) == *(_QWORD *)(a1 + 240))
  {
    return 0;
  }
  v17 = (_BYTE *)(a1 + 11616);
  v18 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  v19 = *(_QWORD *)(a1 + 2296);
  *v17 = 0;
  *(_BYTE *)(a1 + 12641) = 0;
  v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 88);
  v21 = v20 ? v20(a1, v19, v18, 0) : 0;
  v22 = *(_BYTE *)(a1 + 168) ? 2 : v21;
  if (v22 == 1)
    return 0;
  if (v22 != 2)
  {
    v57 = a7;
    if (*v17)
    {
      LODWORD(v63) = 0;
      v24 = (char *)(a1 + 10592);
      v23 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, v67, &v63);
      if ((_DWORD)v63 == 1)
        return v23;
    }
    else
    {
      v23 = 0;
      v24 = (char *)(a1 + 3328);
    }
    v54 = v18;
    if (*(_BYTE *)(a1 + 12641) && !*(_DWORD *)(a1 + 12712))
    {
      v26 = (char *)(a1 + 11617);
      if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 11617, a2) == -1)
      {
        __error();
        return _checkCopyFileError(a1);
      }
      if ((*(_WORD *)(a2 + 4) & 0xF000) != 0x4000)
        return _checkCopyFileError(a1);
      v56 = a9;
      v25 = v24;
    }
    else
    {
      v56 = a9;
      v25 = v24;
      v26 = (char *)(a1 + 248);
    }
    if (*(_DWORD *)(a1 + 12712) || *(_DWORD *)(a1 + 12716) != 3 || (*(_BYTE *)(a2 + 118) & 1) == 0)
    {
LABEL_25:
      v55 = a8;
      v28 = *(_DWORD *)(a1 + 12716);
      path_p = v26;
      if (v28 == 3)
      {
        if (v67[0])
        {
          v29 = v16;
          if (v16 || !*(_BYTE *)(a1 + 12822))
            goto LABEL_45;
        }
        else
        {
          v29 = v16;
          if (v16)
            goto LABEL_45;
        }
        if (!_makeDestDir(a1, v25, 1, a2, &v66))
        {
LABEL_45:
          v32 = v66;
          v33 = v66 != 0;
          if (v66)
          {
            v51 = *(unsigned __int16 *)(a2 + 4);
            v34 = strdup(v25);
          }
          else
          {
            v51 = 0;
            v34 = v25;
          }
          v52 = v67[0];
          v35 = v67[0] | v29;
          if (v35)
          {
            v36 = v33;
          }
          else
          {
            v37 = *(_OWORD *)(a2 + 48);
            v65 = *(_OWORD *)(a2 + 32);
            v64 = v37;
            if (!v32)
            {
              v38 = strdup(v34);
              v36 = 1;
LABEL_53:
              v39 = *(_DWORD *)(a1 + 12712);
              if (v39 != 2)
                goto LABEL_78;
              if (*(_DWORD *)(a1 + 12776))
              {
                if (*(_BYTE *)(a1 + 12769))
                {
                  File = BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
                  BOMFileSetPartialRead(File, 1);
                  v41 = BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
                  if (BOMFileSetCompression(v41, 1, 1, *(_DWORD *)(a1 + 12792)))
                    goto LABEL_94;
                  v50 = v36;
                  v42 = (int *)BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
                  while (BOMFileRead(v42, _copyDir_waste, 0x40uLL) != -1
                       && !BOMFileEndOfCompressionStream((_BOOL8)v42))
                    ;
                  v43 = BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
                  if (BOMFileSetCompression(v43, 0, 1, *(_DWORD *)(a1 + 12792)))
                  {
                    __error();
                    v23 = _checkCopyFileError(a1);
                    if ((v50 & 1) == 0)
                      return v23;
LABEL_99:
                    free(v38);
                    return v23;
                  }
                  v45 = BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
                  BOMFileSetPartialRead(v45, 0);
                  v36 = v50;
                }
                v62 = 0;
                v46 = (int *)BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
                if (BOMFileRead(v46, (char *)&v62, 4uLL) == 4 && v62 == 134695760)
                {
                  v61 = 0;
                  v63 = 0;
                  v60 = 0;
                  if (!BOMPKZipReadDataDescriptor(*(int ***)(a1 + 12752), *(unsigned __int8 *)(a1 + 12812), &v61, &v63, &v60))
                  {
                    v39 = *(_DWORD *)(a1 + 12712);
LABEL_78:
                    switch(v39)
                    {
                      case 0:
                        v47 = _copyFromDirToDir(a1, a2, a6 + a4, v57 - a4, &v55[a4], v56 - a4, a10);
                        goto LABEL_82;
                      case 1:
                        v47 = _copyFromCPIO(a1, a2, a3, v55, v56, v52);
                        goto LABEL_82;
                      case 2:
                        goto LABEL_80;
                      case 3:
                        v23 = 2;
                        if ((v36 & 1) != 0)
                          goto LABEL_99;
                        break;
                      default:
                        goto LABEL_83;
                    }
                    return v23;
                  }
                }
                goto LABEL_94;
              }
LABEL_80:
              v47 = _copyFromPKZip(a1, a2, a3, v55, v56);
LABEL_82:
              v23 = v47;
LABEL_83:
              if ((_DWORD)v23)
              {
LABEL_84:
                if (!v36)
                  return v23;
                goto LABEL_99;
              }
              if (!v35 && !*(_DWORD *)(a1 + 12712))
              {
                if (*(_DWORD *)(a1 + 12716) == 3)
                {
                  if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169))
                  {
                    v23 = _copyExtendedAttributes(a1, (uint64_t)path_p, a2, 0, 0);
                    if ((_DWORD)v23)
                      goto LABEL_84;
                  }
                  if (!*(_BYTE *)(a1 + 171))
                    goto LABEL_88;
                  v49 = _copyACLs(a1, path_p, 0, 0, 0);
                }
                else
                {
                  v49 = _copyAppleDoubleToArchive(a1, (uint64_t)path_p, a2, 0);
                }
                v23 = v49;
                if ((_DWORD)v49)
                  goto LABEL_84;
              }
LABEL_88:
              if (v66)
              {
                if ((*(unsigned int (**)(_QWORD, char *, _QWORD))(*(_QWORD *)(a1 + 12832) + 200))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v38, v51) == -1)goto LABEL_94;
                v52 = v67[0];
              }
              if (*(_DWORD *)(a1 + 12716) == 3 && !(v52 | v29) && set_timestamps_0(v38, &v65, &v64))
              {
LABEL_94:
                __error();
                v23 = _checkCopyFileError(a1);
                if ((v36 & 1) == 0)
                  return v23;
                goto LABEL_99;
              }
              if (!*(_DWORD *)(a1 + 12712))
              {
                v48 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 96);
                if (v48)
                {
                  v48(a1, *(_QWORD *)(a1 + 2296), v54, 0, 0);
                  v23 = 0;
                  if ((v36 & 1) == 0)
                    return v23;
                  goto LABEL_99;
                }
              }
              v23 = 0;
              goto LABEL_84;
            }
            v36 = 1;
          }
          v38 = v34;
          goto LABEL_53;
        }
      }
      else
      {
        v29 = v16;
        v30 = v25;
        if (!*v17)
          v30 = *(const char **)(a1 + 2296);
        strncpy((char *)(a1 + 7424), v30, 0x400uLL);
        if (v16)
          goto LABEL_45;
        if (v28 == 4)
        {
          if (!BOMCPIOWriteDirectory(*(_QWORD *)(a1 + 12736), (char *)(a1 + 7424), a2))
            goto LABEL_45;
        }
        else if (!BOMPKZipWriteLocalHeader(*(_QWORD *)(a1 + 12760), (char *)(a1 + 7424), a2, 0, 0))
        {
          goto LABEL_45;
        }
      }
LABEL_44:
      __error();
      return _checkCopyFileError(a1);
    }
    v27 = BOM_malloc(0x400uLL);
    v63 = 0;
    if (BOMHardLinkTableGetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a2, *(_QWORD *)(a2 + 8), (char *)v27, &v63))
    {
      BOMHardLinkTableSetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a2, *(_QWORD *)(a2 + 8), v25, (const void *)(a2 + 96), 8uLL);
      free(v27);
      goto LABEL_25;
    }
    if (v67[0]
      && (*(unsigned int (**)(_QWORD, char *))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v25))
    {
      free(v27);
      goto LABEL_44;
    }
    v44 = (*(uint64_t (**)(_QWORD, void *, char *))(*(_QWORD *)(a1 + 12832) + 240))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v27, v25);
    free(v27);
    if (v44)
    {
      v16 = a11;
      if (*__error() != 18)
        goto LABEL_44;
      goto LABEL_25;
    }
    return 0;
  }
  return 2;
}

uint64_t _copyLink(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  _BYTE *v7;
  uint64_t v8;
  const char *v9;
  uint64_t (*v10)(uint64_t, const char *, uint64_t, _QWORD);
  unsigned int v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  int *v19;
  int v20;
  char v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  const char *v29;
  int v30;
  uint64_t File;
  const char *v32;
  void (*v33)(uint64_t, const char *, uint64_t, _QWORD, _QWORD);
  uint64_t v34;
  void **v35;
  void **v36;
  size_t v37;
  size_t v38;
  void *v39;
  size_t __n;
  int v41;
  char v42;
  char v43;

  v7 = (_BYTE *)(a1 + 11616);
  v43 = a4;
  v42 = 0;
  v8 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  if (*(_DWORD *)(a1 + 12712))
    v9 = (const char *)(a1 + 248);
  else
    v9 = *(const char **)(a1 + 2296);
  *v7 = 0;
  v7[1025] = 0;
  v10 = *(uint64_t (**)(uint64_t, const char *, uint64_t, _QWORD))(a1 + 88);
  if (v10)
    v11 = v10(a1, v9, v8, 0);
  else
    v11 = 0;
  if (*(_BYTE *)(a1 + 168))
    v12 = 2;
  else
    v12 = v11;
  if ((_DWORD)v12 == 1)
  {
    v12 = 0;
LABEL_16:
    if (*(_DWORD *)(a1 + 12712) == 1)
    {
      if (_skipCPIOFile(a1))
        return 2;
      else
        return v12;
    }
    return v12;
  }
  if ((_DWORD)v12 == 2)
    return v12;
  if (*v7)
  {
    v41 = 0;
    v13 = (char *)(a1 + 10592);
    v14 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, &v43, &v41);
    if (v41 == 1)
    {
LABEL_14:
      v12 = v14;
      goto LABEL_16;
    }
  }
  else
  {
    v13 = (char *)(a1 + 3328);
  }
  if (!v7[1025] || *(_DWORD *)(a1 + 12712))
  {
    v16 = (char *)(a1 + 248);
LABEL_25:
    v12 = 2;
    switch(*(_DWORD *)(a1 + 12712))
    {
      case 0:
        v17 = (*(uint64_t (**)(_QWORD, char *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 12832) + 256))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v16, *(_QWORD *)(a1 + 8), *(int *)(a1 + 16));
        if (v17 == -1)
          goto LABEL_64;
        goto LABEL_39;
      case 1:
        v17 = *(_QWORD *)(a2 + 96);
        if (v17 >= 1025)
        {
          v14 = _checkCopyFileError(a1);
          goto LABEL_14;
        }
        v18 = BOMCPIORead(*(int ***)(a1 + 12728), *(char **)(a1 + 8), *(_QWORD *)(a2 + 96));
LABEL_38:
        if (v18 != v17)
          goto LABEL_64;
LABEL_39:
        *(_BYTE *)(*(_QWORD *)(a1 + 8) + v17) = 0;
        v20 = *(_DWORD *)(a1 + 12716);
        if (v20 == 5)
        {
          v28 = crc32(0, 0, 0);
          if (*v7)
            v29 = v13;
          else
            v29 = v9;
          strncpy((char *)(a1 + 7424), v29, 0x400uLL);
          v30 = crc32(v28, *(const Bytef **)(a1 + 8), v17);
          if (!BOMPKZipWriteLocalHeader(*(_QWORD *)(a1 + 12760), (char *)(a1 + 7424), a2, v30, v17))
          {
            File = BOMPKZipGetFile(*(_QWORD *)(a1 + 12760));
            if (BOMFileWrite(File, *(UInt8 **)(a1 + 8), v17) == v17)
              goto LABEL_69;
          }
        }
        else if (v20 == 4)
        {
          if (*v7)
            v32 = v13;
          else
            v32 = v9;
          strncpy((char *)(a1 + 7424), v32, 0x400uLL);
          if (!BOMCPIOWriteSymlink(*(_QWORD *)(a1 + 12736), (char *)(a1 + 7424), a2, *(char **)(a1 + 8)))
            goto LABEL_69;
        }
        else
        {
          v21 = 0;
          if (v20 != 3)
            goto LABEL_70;
          if (*(_BYTE *)(a1 + 173) && v43 && (*(_WORD *)(a3 + 4) & 0xF000) == 0xA000)
          {
            v22 = (*(uint64_t (**)(_QWORD, char *, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 256))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v13, a1 + 8448, 1024);
            if (v22 == -1)
              goto LABEL_64;
            *(_BYTE *)(a1 + v22 + 8448) = 0;
            if (v17 == v22 && !strcmp(*(const char **)(a1 + 8), (const char *)(a1 + 8448)))
              goto LABEL_69;
          }
          _parentPath(v13, (char *)(a1 + 7424), 0x400uLL);
          __strlcat_chk();
          if ((*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 336))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424)&& !(*(unsigned int (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 248))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), *(_QWORD *)(a1 + 8), a1 + 7424))
          {
            if (*(_DWORD *)(a1 + 12712) == 1)
            {
              v23 = _chPerms(a1, (char *)(a1 + 7424), a2, &v42, 1);
              v24 = *(_QWORD *)(a1 + 12832);
              v25 = *(unsigned int (**)(uint64_t, uint64_t))(v24 + 224);
              v26 = *(_QWORD *)(v24 + 8);
              if (v23)
              {
                v25(v26, a1 + 7424);
                __error();
                v27 = a1;
                return _checkCopyFileError(v27);
              }
              if (!v25(v26, (uint64_t)v13) || *__error() == 2 || *__error() == 63)
              {
                v35 = (void **)BOM_malloc(0x18uLL);
                if (!v35)
                  goto LABEL_93;
                v36 = v35;
                __n = strlen(v13) + 1;
                v37 = strlen((const char *)(a1 + 7424)) + 1;
                v38 = strlen(v9) + 1;
                *v36 = BOM_malloc(__n);
                v36[1] = BOM_malloc(v37);
                v39 = BOM_malloc(v38);
                v36[2] = v39;
                if (!*v36 || !v36[1] || !v39)
                {
LABEL_93:
                  v27 = a1;
                  return _checkCopyFileError(v27);
                }
                memcpy(*v36, v13, __n);
                memcpy(v36[1], (const void *)(a1 + 7424), v37);
                memcpy(v36[2], v9, v38);
                BOMStackPush(*(char **)(a1 + 40), (uint64_t)v36);
                v21 = 1;
LABEL_70:
                if (*(_DWORD *)(a1 + 12712))
                  goto LABEL_71;
                if (*(_DWORD *)(a1 + 12716) == 3)
                {
                  if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169))
                  {
                    v12 = _copyExtendedAttributes(a1, (uint64_t)v16, a2, 0, 0);
                    if ((_DWORD)v12)
                      goto LABEL_16;
                  }
                  if (!*(_BYTE *)(a1 + 171))
                  {
LABEL_71:
                    if ((v21 & 1) == 0)
                    {
                      v33 = *(void (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD))(a1 + 96);
                      if (v33)
                        v33(a1, v9, v8, 0, 0);
                    }
                    return 0;
                  }
                  v34 = _copyACLs(a1, v16, 0, 1, 0);
                }
                else
                {
                  v34 = _copyAppleDoubleToArchive(a1, (uint64_t)v16, a2, 0);
                }
                v12 = v34;
                if ((_DWORD)v34)
                  goto LABEL_16;
                goto LABEL_71;
              }
LABEL_68:
              __error();
              v27 = a1;
              return _checkCopyFileError(v27);
            }
            if ((*(unsigned int (**)(_QWORD, uint64_t, char *))(*(_QWORD *)(a1 + 12832) + 264))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, v13))
            {
              goto LABEL_64;
            }
            if (_chPerms(a1, v13, a2, &v42, 1))
            {
              (*(void (**)(_QWORD, char *))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v13);
              goto LABEL_68;
            }
LABEL_69:
            v21 = 0;
            goto LABEL_70;
          }
        }
        break;
      case 2:
        v17 = *(_QWORD *)(a2 + 96);
        if (v17 >= 1025)
          return _checkCopyFileError(a1);
        v19 = (int *)BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
        v18 = BOMFileRead(v19, *(char **)(a1 + 8), v17);
        goto LABEL_38;
      case 3:
        return v12;
      default:
        v17 = 0;
        goto LABEL_39;
    }
    goto LABEL_64;
  }
  v16 = (char *)(a1 + 11617);
  if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 11617, a2) != -1)
  {
    if ((*(_WORD *)(a2 + 4) & 0xF000) != 0xA000)
      return _checkCopyFileError(a1);
    goto LABEL_25;
  }
LABEL_64:
  __error();
  return _checkCopyFileError(a1);
}

uint64_t _copyDevice(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t, _QWORD);
  int v8;
  int v9;
  uint64_t result;
  char *v11;
  int v12;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);
  int v15;
  char v16;
  _OWORD v17[9];

  v4 = (_BYTE *)(a1 + 11616);
  v5 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  if (*(_DWORD *)(a1 + 12712))
    v6 = a1 + 248;
  else
    v6 = *(_QWORD *)(a1 + 2296);
  *v4 = 0;
  v4[1025] = 0;
  v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 88);
  if (v7)
    v8 = v7(a1, v6, v5, 0);
  else
    v8 = 0;
  if (*(_BYTE *)(a1 + 168))
    v9 = 2;
  else
    v9 = v8;
  if (v9 == 1)
    return 0;
  if (v9 == 2)
    return 2;
  memset(v17, 0, sizeof(v17));
  if (!*v4)
  {
    v11 = (char *)(a1 + 3328);
    goto LABEL_17;
  }
  v15 = 0;
  v11 = (char *)(a1 + 10592);
  result = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, (uint64_t)v17, &v16, &v15);
  if (v15 != 1)
  {
LABEL_17:
    if (v4[1025] && !*(_DWORD *)(a1 + 12712))
    {
      if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 11617, a2) == -1)goto LABEL_30;
      if ((*(_WORD *)(a2 + 4) & 0xB000 | 0x4000) != 0x6000)
      {
        v13 = a1;
        return _checkCopyFileError(v13);
      }
    }
    v12 = *(_DWORD *)(a1 + 12716);
    if (v12 != 4)
    {
      if (v12 == 3)
      {
        _parentPath(v11, (char *)(a1 + 7424), 0x400uLL);
        __strlcat_chk();
        if (!(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 336))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424)|| (*(unsigned int (**)(_QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 12832) + 176))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, *(unsigned __int16 *)(a2 + 4), *(unsigned int *)(a2 + 24))|| (*(unsigned int (**)(_QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 12832) + 192))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, *(unsigned int *)(a2 + 16), *(unsigned int *)(a2 + 20))|| set_timestamps_0((const char *)(a1 + 7424), (__int128 *)(a2 + 32), (_OWORD *)(a2 + 48))|| (*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 12832) + 264))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, a1 + 3328))
        {
          goto LABEL_30;
        }
      }
      goto LABEL_31;
    }
    __strlcpy_chk();
    if (!BOMCPIOWriteDevice(*(_QWORD *)(a1 + 12736), (char *)(a1 + 7424), a2))
    {
LABEL_31:
      v14 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 96);
      if (v14)
        v14(a1, v6, v5, 0, 0);
      return 0;
    }
LABEL_30:
    __error();
    v13 = a1;
    return _checkCopyFileError(v13);
  }
  return result;
}

_QWORD *_unlockAFSCFileLock(_QWORD *result)
{
  if (result)
  {
    result = (_QWORD *)*result;
    if (result)
    {
      result = (_QWORD *)AFSCUnlockFile();
      if ((_DWORD)result)
        return (_QWORD *)fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not unlock AFSC file: %d\n", (_DWORD)result);
    }
  }
  return result;
}

uint64_t _skipCPIOFile(uint64_t a1)
{
  int *v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (BOMCPIOSeek() != -1)
    return 0;
  v3 = __error();
  v4 = strerror(*v3);
  BOMCopierNotifyFatalError(a1, "cpio seek error: %s", v5, v6, v7, v8, v9, v10, v4);
  return 2;
}

uint64_t _skipPKZipFile()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t File;
  int *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  int *v15;
  int *v16;
  uint64_t result;
  int *v18;
  const char *v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int NumLocalHeaders;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int *v35;
  char v36;
  char v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  int v41;
  char v42[131072];
  uint64_t v43;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = v0;
  v43 = *MEMORY[0x24BDAC8D0];
  v4 = (_BYTE *)(v0 + 12769);
  File = BOMPKZipGetFile(*(_QWORD *)(v0 + 12752));
  v6 = (int *)File;
  if (!*(_DWORD *)(v3 + 12776))
    goto LABEL_22;
  BOMFileSetPartialRead(File, 1);
  if (*v4 && BOMFileSetCompression((uint64_t)v6, 1, 1, *(_DWORD *)(v3 + 12792)))
  {
    v7 = __error();
    v36 = strerror(*v7);
    v14 = "pkzip set compression (1,1) error: %s";
LABEL_11:
    BOMCopierNotifyFatalError(v3, v14, v8, v9, v10, v11, v12, v13, v36);
    return 2;
  }
  while (!BOMFileEndOfCompressionStream((_BOOL8)v6))
  {
    if ((BOMFileRead(v6, v42, 0x20000uLL) & 0x8000000000000000) != 0)
    {
      v16 = __error();
      v36 = strerror(*v16);
      v14 = "pkzip read seek error: %s";
      goto LABEL_11;
    }
  }
  if (*v4 && BOMFileSetCompression((uint64_t)v6, 0, 1, *(_DWORD *)(v3 + 12792)))
  {
    v15 = __error();
    v36 = strerror(*v15);
    v14 = "pkzip set compression (0,1) error: %s";
    goto LABEL_11;
  }
  BOMFileSetPartialRead((uint64_t)v6, 0);
  v41 = 0;
  if (BOMFileRead(v6, (char *)&v41, 4uLL) != 4)
  {
    v19 = "pkzip read span error: %s";
LABEL_20:
    v20 = __error();
    v37 = strerror(*v20);
    BOMCopierNotifyFatalError(v3, v19, v21, v22, v23, v24, v25, v26, v37);
    return 2;
  }
  if (v41 != 134695760)
  {
    v19 = "pkzip spanning doesn't match: %s";
    goto LABEL_20;
  }
  v40 = 0;
  v38 = 0;
  v39 = 0;
  if (BOMPKZipReadDataDescriptor(*(int ***)(v3 + 12752), v4[43], &v40, &v39, &v38))
  {
    v18 = __error();
    v36 = strerror(*v18);
    v14 = "Could not read pkzip data descriptor: %s";
    goto LABEL_11;
  }
  *(_QWORD *)(v2 + 96) = v38;
  v27 = BOMPKZipGetFile(*(_QWORD *)(v3 + 12752));
  BOMFileSetPartialRead(v27, 1);
LABEL_22:
  if (*v4)
  {
    v28 = BOMPKZipGetFile(*(_QWORD *)(v3 + 12752));
    if (BOMFileSetCompression(v28, 0, 1, *(_DWORD *)(v3 + 12792)))
      return 2;
  }
  if (*(_DWORD *)(v3 + 12776))
    return 0;
  v29 = *(_QWORD *)(v3 + 12752);
  NumLocalHeaders = BOMPKZipGetNumLocalHeaders(v29);
  result = BOMPKZipGetFileCompressedSize(v29, NumLocalHeaders - 1);
  if ((_DWORD)result)
  {
    v31 = result;
    while (1)
    {
      v32 = v31 >= 0x20000 ? 0x20000 : v31;
      v33 = BOMFileRead(v6, v42, v32);
      if ((v33 & 0x8000000000000000) != 0)
        break;
      v34 = v33;
      result = 0;
      v31 -= v34;
      if (!v31)
        return result;
    }
    v35 = __error();
    v36 = strerror(*v35);
    v14 = "pkzip seek error: %s";
    goto LABEL_11;
  }
  return result;
}

uint64_t _copyDataFork(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, int a5, _DWORD *a6, _DWORD *a7, int a8)
{
  _DWORD *v9;
  int v13;
  _BOOL4 v14;
  const char *v15;
  char *v16;
  const char *v17;
  const char *v18;
  char *v20;
  char *v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int64_t v45;
  uint64_t v46;
  _DWORD *v47;
  uint64_t v48;
  unint64_t v49;
  int *File;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int *v57;
  uint64_t i;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t (*v67)(uint64_t, uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  int v76;
  unsigned int *v77;
  unsigned int v78;
  size_t v79;
  unsigned int *v80;
  unsigned int *v81;
  unsigned int *v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  int8x8_t v87;
  int v88;
  uint64_t (*v89)(uint64_t, uint64_t, uint64_t);
  uint64_t v90;
  int v91;
  unsigned int FileUncompressedSize;
  int *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  _DWORD *v101;
  uint64_t v102;
  int v103;
  int v104;
  int *v105;
  uint64_t v106;
  int NumLocalHeaders;
  int FileCompressedSize;
  int v109;
  uint64_t v110;
  char v111;
  BOOL v112;
  char v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  int v119;
  int FileDescriptor;
  int v121;
  uint64_t v122;
  unsigned int *v123;
  void *v124;
  unsigned int *v125;
  int v126;
  _QWORD *v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _QWORD *v133;
  unsigned int *v134;
  unsigned int *v135;
  uint64_t v136;
  unsigned int *v137;
  uint64_t v138;
  uint64_t v139;
  unsigned int v140;
  uint64_t v141;
  _QWORD *v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  int64_t v146;
  BOOL v147;
  int64_t v148;
  _QWORD *v149;
  uint64_t v150;
  _QWORD *v151;
  _QWORD *v152;
  unsigned int v153;
  uint64_t v154;
  unsigned int *v155;
  uint64_t *v156;
  _QWORD *v157;
  uint64_t v158;
  int64_t v159;
  uint64_t v160;
  uint64_t v161;
  regex_t *v162;
  uint64_t v163;
  int *v164;
  void (*v165)(uint64_t, uint64_t, uint64_t);
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  int v172;
  int *v173;
  uint64_t v174;
  size_t v175;
  int *v176;
  char v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  void *v184;
  char *v185;
  char *v186;
  uint64_t v187;
  int *v188;
  void (*v189)(uint64_t, uint64_t, _QWORD);
  int *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  char v197;
  uint64_t v198;
  int v200;
  uint64_t v202;
  unsigned int *v203;
  int v204;
  uint64_t v205;
  void *__src;
  unsigned int *v207;
  int v208;
  int v209;
  uint64_t v210;
  _DWORD *v211;
  const char *v212;
  uint64_t v213;
  _BYTE *v215;
  int v216;
  int v217;
  _QWORD *v218;
  void *v219;
  uint64_t v220;
  void *v221;
  uint64_t v222;
  uint64_t v223;
  int *v224;
  stat v225;
  uint64_t v226;

  v9 = a6;
  v226 = *MEMORY[0x24BDAC8D0];
  v223 = 0;
  v224 = 0;
  v221 = 0;
  v222 = 0;
  v219 = 0;
  v220 = 0;
  v209 = *(_DWORD *)(a1 + 12716);
  v13 = *(unsigned __int8 *)(a1 + 197);
  if (a6)
    v14 = 1;
  else
    v14 = *(_BYTE *)(a1 + 173) != 0;
  if (v209 == 5)
    HIDWORD(v220) = crc32(0, 0, 0);
  v215 = (_BYTE *)(a1 + 11616);
  if (*(_DWORD *)(a1 + 12712))
    v15 = (const char *)(a1 + 248);
  else
    v15 = *(const char **)(a1 + 2296);
  v212 = v15;
  v213 = a3;
  v208 = v13;
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (*(_BYTE *)(a1 + 12823) || (a8 & 1) != 0)
    {
      if (*v215)
        v18 = (const char *)(a1 + 10592);
      else
        v18 = (const char *)(a1 + 3328);
      strncpy((char *)(a1 + 7424), v18, 0x400uLL);
    }
    else
    {
      if (*v215)
        v16 = (char *)(a1 + 10592);
      else
        v16 = (char *)(a1 + 3328);
      _parentPath(v16, (char *)(a1 + 7424), 0x400uLL);
      __strlcat_chk();
      if (!(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 336))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424))
      {
        __error();
        return _checkCopyFileError(a1);
      }
      if (*(_DWORD *)(a1 + 12716) != 3)
        goto LABEL_35;
    }
    if (*(unsigned __int16 *)(a3 + 6) >= 2u)
    {
      v218 = 0;
      if (BOMHardLinkTableGetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a3, *(_QWORD *)(a3 + 8), (char *)&v225, &v218))
      {
        BOMHardLinkTableSetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a3, *(_QWORD *)(a3 + 8), (char *)(a1 + 3328), (const void *)(a3 + 96), 8uLL);
        goto LABEL_35;
      }
      if (*v218 == *(_QWORD *)(a3 + 96))
      {
        if (!a5
          || !(*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 3328))
        {
          if (!(*(unsigned int (**)(_QWORD, stat *, uint64_t))(*(_QWORD *)(a1 + 12832) + 240))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), &v225, a1 + 3328))
          {
            v43 = 0;
            *a7 = 2;
            goto LABEL_126;
          }
          if (*__error() == 18)
            goto LABEL_35;
        }
        __error();
        v43 = _checkCopyFileError(a1);
LABEL_126:
        LOBYTE(a2) = 0;
        v44 = 0;
        v202 = 0;
        v203 = 0;
        v45 = 0;
        v46 = 0;
        v204 = 0;
        v205 = 0;
        __src = 0;
        v207 = 0;
        v200 = 0;
        goto LABEL_157;
      }
    }
  }
  else
  {
    if (*v215)
      v17 = (const char *)(a1 + 10592);
    else
      v17 = v15;
    strncpy((char *)(a1 + 7424), v17, 0x400uLL);
  }
LABEL_35:
  if (*(_BYTE *)(a1 + 204) == 1)
  {
    v20 = strdup((const char *)(a1 + 3328));
    if (!v20)
    {
      v29 = __error();
      strerror(*v29);
      BOMCopierNotifyFatalError(a1, "Could not duplicate %s: %s", v30, v31, v32, v33, v34, v35, a1);
      goto LABEL_43;
    }
    v21 = v20;
    if (!dirname_r((const char *)(a1 + 3328), v20))
    {
      v36 = __error();
      strerror(*v36);
      BOMCopierNotifyFatalError(a1, "Could not dirname %s: %s", v37, v38, v39, v40, v41, v42, a1);
      goto LABEL_42;
    }
    memset(&v225, 0, sizeof(v225));
    if (stat(v21, &v225))
    {
      v22 = __error();
      strerror(*v22);
      BOMCopierNotifyFatalError(a1, "Could not stat %s: %s", v23, v24, v25, v26, v27, v28, (char)v21);
LABEL_42:
      free(v21);
      goto LABEL_43;
    }
    free(v21);
    if (*(_DWORD *)a3 == v225.st_dev)
    {
      if (!copyfile(a2, (const char *)(a1 + 3328), 0, 0x200000Fu))
      {
        LOBYTE(a2) = 0;
        v44 = 0;
        v202 = 0;
        v203 = 0;
        v45 = 0;
        v46 = 0;
        v204 = 0;
        v205 = 0;
        __src = 0;
        v207 = 0;
        v200 = 0;
        v43 = 0;
        *a7 = 2;
        goto LABEL_157;
      }
      if (*__error() != 45)
      {
        v93 = __error();
        strerror(*v93);
        BOMCopierNotifyFatalError(a1, "Could not clone %s to %s: %s", v94, v95, v96, v97, v98, v99, (char)a2);
LABEL_43:
        __error();
        v43 = _checkCopyFileError(a1);
LABEL_44:
        LOBYTE(a2) = 0;
        v44 = 0;
        v202 = 0;
        v203 = 0;
        v45 = 0;
        v46 = 0;
        v204 = 0;
        v205 = 0;
        __src = 0;
        v207 = 0;
        v200 = 0;
        goto LABEL_168;
      }
    }
  }
  v198 = (uint64_t)a2;
  LOBYTE(a2) = 0;
  v44 = 0;
  v202 = 0;
  v203 = 0;
  v45 = 0;
  v46 = 0;
  v205 = 0;
  __src = 0;
  v207 = 0;
  v200 = 0;
  v204 = 0;
  v43 = 0;
  switch(*(_DWORD *)(a1 + 12712))
  {
    case 0:
      if (BOMFileOpenWithSys(&v224, v198, 0, 0, 16 * (*(_BYTE *)(a1 + 12813) == 0), *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))goto LABEL_43;
      v43 = 0;
      goto LABEL_53;
    case 1:
      v43 = 0;
      v224 = (int *)BOMCPIOGetFile(*(_QWORD *)(a1 + 12728));
      goto LABEL_53;
    case 2:
      File = (int *)BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
      v224 = File;
      if (*(_BYTE *)(a1 + 12796))
      {
        if (*(_QWORD *)(a1 + 12800))
        {
          v211 = v9;
          v43 = 0;
        }
        else
        {
          v89 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 128);
          if (!v89)
          {
            BOMCopierNotifyFatalError(a1, "No password was provided and the client did not provide a callback for retrieving the PKZip encryption key", v51, v52, v53, v54, v55, v56, v197);
            v43 = 2;
            goto LABEL_44;
          }
          v43 = v89(a1, a1 + 248, a1 + 12800);
          if ((_DWORD)v43 == 2)
            goto LABEL_44;
          v211 = v9;
          File = v224;
        }
        if (BOMFileRead(File, (char *)&v225, 0xCuLL) != 12)
          goto LABEL_43;
        while (1)
        {
          v57 = (int *)BOMFileSetKeys((uint64_t)v224, *(_BYTE **)(a1 + 12800));
          for (i = 0; i != 12; ++i)
          {
            v59 = *((unsigned __int8 *)&v225.st_dev + i);
            v60 = decrypt_byte((uint64_t)v57) ^ v59;
            update_keys(v57, v60);
          }
          if (*(unsigned __int8 *)(a1 + 12811) == (_DWORD)v60)
            break;
          free(*(void **)(a1 + 12800));
          *(_QWORD *)(a1 + 12800) = 0;
          v67 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 128);
          if (!v67)
          {
            BOMCopierNotifyFatalError(a1, "The password appears to be invalid and the client did not provide a callback for retrieving a new PKZip encryption key", v61, v62, v63, v64, v65, v66, v197);
LABEL_124:
            BOMCopierNotifyFatalError(a1, "The password provided for the encrypted PKZip archive appears to be invalid", v68, v69, v70, v71, v72, v73, v197);
            v43 = 2;
            a3 = v213;
            goto LABEL_44;
          }
          v43 = v67(a1, a1 + 248, a1 + 12800);
          if ((_DWORD)v43 == 2)
            goto LABEL_124;
        }
        v105 = v224;
        v106 = *(_QWORD *)(a1 + 12752);
        NumLocalHeaders = BOMPKZipGetNumLocalHeaders(v106);
        FileCompressedSize = BOMPKZipGetFileCompressedSize(v106, NumLocalHeaders - 1);
        BOMFileSetEncryptedRemainder((uint64_t)v105, FileCompressedSize - 12);
        a3 = v213;
        v9 = v211;
      }
      else
      {
        v43 = 0;
      }
      if (*(_BYTE *)(a1 + 12769))
      {
        if (BOMFileSetCompression((uint64_t)v224, 1, 1, *(_DWORD *)(a1 + 12792)))
          goto LABEL_43;
        *(_QWORD *)(a3 + 96) = -1;
      }
      if (*(_DWORD *)(a1 + 12776))
      {
        BOMFileSetPartialRead((uint64_t)v224, 1);
        if (!*(_BYTE *)(a1 + 12769))
        {
          v90 = *(_QWORD *)(a1 + 12752);
          v91 = BOMPKZipGetNumLocalHeaders(v90);
          FileUncompressedSize = BOMPKZipGetFileUncompressedSize(v90, v91 - 1);
          *(_QWORD *)(a3 + 96) = FileUncompressedSize;
          if (!FileUncompressedSize)
          {
            BOMFileSetDataDescriptor((uint64_t)v224, 1);
            *(_QWORD *)(a3 + 96) = -1;
          }
        }
      }
LABEL_53:
      v44 = *(_QWORD *)(a3 + 96);
      if (!v14)
      {
        v200 = 0;
        v203 = 0;
        v45 = 0;
        HIDWORD(v222) = 0;
LABEL_61:
        if ((unint64_t)v44 >> 33 && *(_BYTE *)(a1 + 12824))
        {
          v202 = 0;
          v204 = 0;
          v205 = 0;
          __src = 0;
          v207 = 0;
          LODWORD(a2) = 1;
          v46 = 0x40000000;
        }
        else
        {
          LODWORD(a2) = 0;
          v202 = 0;
          v204 = 0;
          v205 = 0;
          __src = 0;
          v207 = 0;
          v46 = v44;
        }
        goto LABEL_128;
      }
      v47 = v9;
      v48 = *(int *)(a1 + 16);
      v210 = *(_QWORD *)(a3 + 96);
      if (v44 == -1)
      {
        v74 = 0;
        v45 = 0;
        do
        {
          v75 = BOMFileRead(v224, (char *)(*(_QWORD *)(a1 + 8) + v74), v48 - v74);
          if ((v75 & 0x8000000000000000) != 0)
          {
            __error();
            v43 = _checkCopyFileError(a1);
            LOBYTE(a2) = 0;
            v202 = 0;
            v203 = 0;
            v46 = 0;
            v204 = 0;
            v205 = 0;
            __src = 0;
            v207 = 0;
            v200 = 0;
            v44 = -1;
            goto LABEL_168;
          }
          v74 += v75;
          v45 += v75;
        }
        while (v74 < v48 && !BOMFileEndOfCompressionStream((_BOOL8)v224));
      }
      else
      {
        if (v44 >= v48)
          v49 = *(int *)(a1 + 16);
        else
          v49 = *(_QWORD *)(a3 + 96);
        v45 = BOMFileRead(v224, *(char **)(a1 + 8), v49);
        if (v45 < 0)
        {
          __error();
          v43 = _checkCopyFileError(a1);
          LOBYTE(a2) = 0;
          v202 = 0;
          v203 = 0;
          v45 = 0;
          v46 = 0;
          v204 = 0;
          v205 = 0;
          __src = 0;
          v207 = 0;
          v200 = 0;
          LOBYTE(v14) = 1;
          goto LABEL_259;
        }
      }
      v76 = BOMArchFlagForHeader(*(int **)(a1 + 8), v45);
      if (v76 == 1)
      {
        v85 = *(_QWORD *)(a1 + 8);
        v86 = (char *)BOM_malloc(0x1CuLL);
        if (!v86)
        {
          LOBYTE(a2) = 0;
          v202 = 0;
          v203 = 0;
          v46 = 0;
          v204 = 0;
          v205 = 0;
          __src = 0;
          v207 = 0;
          v200 = 0;
          goto LABEL_259;
        }
        *(_QWORD *)v86 = 0x1CAFEBABELL;
        v84 = (uint64_t)(v86 + 8);
        v87 = 0;
        v88 = *(_DWORD *)v85;
        if (*(int *)v85 > -17958195)
        {
          if (v88 == -17958193 || v88 == -17958194)
            v87 = *(int8x8_t *)(v85 + 4);
        }
        else if (v88 == -822415874 || v88 == -805638658)
        {
          v87 = vrev32_s8(*(int8x8_t *)(v85 + 4));
        }
        *((int8x8_t *)v86 + 1) = v87;
        v78 = 1;
        v200 = 1;
        *((_DWORD *)v86 + 4) = 0;
        v203 = (unsigned int *)v86;
        *(_QWORD *)(v86 + 20) = v210;
        v44 = v210;
      }
      else
      {
        if (v76 == 2)
        {
          v77 = *(unsigned int **)(a1 + 8);
          v78 = bswap32(v77[1]);
          v79 = (int)(20 * v78 + 8);
          v80 = (unsigned int *)BOM_malloc(v79);
          if (!v80)
          {
            LOBYTE(a2) = 0;
            v202 = 0;
            v203 = 0;
            v46 = 0;
            v204 = 0;
            v205 = 0;
            __src = 0;
            v207 = 0;
            v200 = 0;
            goto LABEL_258;
          }
          v81 = v80;
          v82 = v77;
          v83 = (char *)(v80 + 2);
          memmove(v80, v82, v79);
          v203 = v81;
          _fat_header_big_to_host(v81, v79);
          v84 = (uint64_t)v83;
          v200 = 1;
        }
        else
        {
          v78 = 0;
          v84 = 0;
          v203 = 0;
          v200 = 0;
        }
        v44 = v210;
      }
      if (_determine_thin_type_and_archs(v84, v78, v47, &v221, &v222, (_DWORD *)&v222 + 1, 0))
      {
        LOBYTE(a2) = 0;
        v202 = 0;
        v46 = 0;
        v204 = 0;
        v205 = 0;
        __src = 0;
        v207 = 0;
        v43 = 0;
        *a7 = 1;
        a3 = v213;
        goto LABEL_157;
      }
      a3 = v213;
      if (!HIDWORD(v222))
        goto LABEL_61;
      v100 = 20 * v222 + 8;
      v101 = BOM_malloc(v100);
      v204 = v100;
      if (v101)
      {
        v102 = (uint64_t)(v101 + 2);
        *v101 = -889275714;
        v103 = v222;
        __src = v101;
        v101[1] = v222;
        _sortFatArchsByOffset(v221, v103);
        if (HIDWORD(v222) == 1)
          v104 = 0;
        else
          v104 = v100;
        _createNewFatArchArray((uint64_t *)v221, v222, v102, v104);
        LODWORD(a2) = 0;
        v202 = 0;
        v207 = 0;
        v205 = v102;
        v46 = (*(_DWORD *)(v102 + 20 * (int)v222 - 8) + *(_DWORD *)(v102 + 20 * (int)v222 - 12));
        goto LABEL_128;
      }
      LOBYTE(a2) = 0;
      v202 = 0;
      v46 = 0;
      v205 = 0;
      __src = 0;
      v207 = 0;
      while (1)
      {
LABEL_168:
        if (v223 && *(_DWORD *)(a1 + 12716) == 3)
        {
          if (BOMFileClose(v223) && !(_DWORD)v43)
          {
            __error();
            v43 = _checkCopyFileError(a1);
          }
          v223 = 0;
        }
        if ((_DWORD)v43 != 0 || (a2 & 1) == 0 || v44 <= v45)
          break;
        v43 = 0;
        if (v14)
          LOBYTE(v14) = 0;
        if (v46 >= v44 - v45)
          v46 = v44 - v45;
        LODWORD(a2) = 1;
        a8 = 1;
LABEL_128:
        v109 = *(_DWORD *)(a1 + 12716);
        if (v109 != 3)
        {
          if (v46 == -1)
            v114 = 0;
          else
            v114 = v46;
          *(_QWORD *)(a3 + 96) = v114;
          v115 = (char *)(a1 + 7424);
          if (v109 == 4)
          {
            if (BOMCPIOWriteHeader(*(_QWORD *)(a1 + 12736), v115, a3))
              goto LABEL_167;
            v223 = BOMCPIOGetFile(*(_QWORD *)(a1 + 12736));
          }
          else
          {
            if (BOMPKZipWriteLocalHeader(*(_QWORD *)(a1 + 12760), v115, a3, 0, 0))
              goto LABEL_167;
            v122 = BOMPKZipGetFile(*(_QWORD *)(a1 + 12760));
            v223 = v122;
            if (v46 >= 1)
            {
              if (BOMFileSetCompression(v122, 1, 0, *(_DWORD *)(a1 + 12792)))
                goto LABEL_167;
              v202 = BOMFileOffset(v223);
            }
          }
          goto LABEL_203;
        }
        v110 = v44;
        v111 = 16 * (*(_BYTE *)(a1 + 12814) == 0);
        if (a5)
          v112 = *(_BYTE *)(a1 + 12823) == 0;
        else
          v112 = 1;
        if (v112)
          v113 = 1;
        else
          v113 = a8;
        if ((v113 & 1) != 0
          || !(*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424))
        {
          if (a8)
            v116 = 521;
          else
            v116 = 2561;
          if (BOMFileOpenWithSys(&v223, a1 + 7424, v116, 384, v111, *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
          {
            if (*__error() != 2
              || !*(_DWORD *)(a1 + 12712)
              || _mkdirs_parent(a1)
              || (!a8 ? (v117 = 1537) : (v117 = 521),
                  BOMFileOpenWithSys(&v223, a1 + 7424, v117, 384, v111, *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832))))
            {
              __error();
              v43 = _checkCopyFileError(a1);
              a3 = v213;
              goto LABEL_156;
            }
          }
          if (*(_BYTE *)(a1 + 207) == 1 || *(_BYTE *)(a1 + 208) == 1 || *(_BYTE *)(a1 + 211) == 1)
          {
            FileDescriptor = BOMFileGetFileDescriptor(v223);
            a3 = v213;
            if (FileDescriptor != -1)
            {
              v121 = FileDescriptor;
              v44 = v110;
              if (*(_BYTE *)(a1 + 211) == 1 && fcntl(FileDescriptor, 64, *(unsigned int *)(a1 + 212))
                || *(_BYTE *)(a1 + 207) == 1 && fcntl(v121, 68, 1)
                || *(_BYTE *)(a1 + 208) == 1 && fcntl(v121, 76, 1))
              {
                __error();
                v43 = _checkCopyFileError(a1);
                goto LABEL_157;
              }
              goto LABEL_203;
            }
          }
          else
          {
            a3 = v213;
          }
          v44 = v110;
LABEL_203:
          if (HIDWORD(v222))
          {
            v127 = BOM_calloc(168 * (int)v222 + 168, 1uLL);
            if (v127)
            {
              v128 = (uint64_t)v127;
              v129 = 0;
              v130 = v44;
              v131 = 0;
              *v127 = a1;
              v132 = v223;
              v127[1] = v224;
              v127[2] = v132;
              v127[3] = v212;
              v127[4] = v130;
              v210 = v130;
              v127[5] = v46;
              v133 = v127 + 7;
              if (HIDWORD(v222) != 2)
                goto LABEL_208;
              v131 = v204;
              v134 = (unsigned int *)BOM_malloc(v204);
              if (v134)
              {
                v135 = v134;
                memmove(v134, __src, v204);
                _fat_header_host_to_big(v135, v204);
                v129 = 1;
                *(_DWORD *)(v128 + 56) = 1;
                *(_QWORD *)(v128 + 64) = v204;
                *(_DWORD *)(v128 + 72) = 1;
                *(_QWORD *)(v128 + 80) = 0;
                *(_QWORD *)(v128 + 88) = v135;
                v207 = v135;
                *(_QWORD *)(v128 + 96) = 0;
                *(_QWORD *)(v128 + 104) = 0;
                a3 = v213;
LABEL_208:
                if ((int)v222 >= 1)
                {
                  v136 = 0;
                  v137 = (unsigned int *)(v205 + 8);
                  while (1)
                  {
                    v138 = *((_QWORD *)v221 + v136);
                    v140 = *v137;
                    v137 += 5;
                    v139 = v140;
                    v141 = v140 - v131;
                    if (v140 <= v131)
                    {
                      v139 = v131;
                    }
                    else
                    {
                      v142 = &v133[7 * v129];
                      *(_DWORD *)v142 = 0;
                      v142[1] = v141;
                      *((_DWORD *)v142 + 4) = 1;
                      v142[3] = 0;
                      v142[4] = 0;
                      v142[5] = v131;
                      v142[6] = 0;
                      ++v129;
                    }
                    v143 = *(unsigned int *)(v138 + 8);
                    v144 = *(unsigned int *)(v138 + 12);
                    v145 = v45 - v143;
                    if (v45 <= v143)
                      break;
                    v146 = (v144 + v143);
                    v147 = v146 <= v45;
                    v148 = v146 - v45;
                    if (v147)
                    {
                      v151 = &v133[7 * v129];
                      *(_DWORD *)v151 = 1;
                      v151[1] = v144;
                      *((_DWORD *)v151 + 4) = 1;
                      v151[3] = 0;
                      v151[4] = *(_QWORD *)(a1 + 8) + v143;
                      goto LABEL_218;
                    }
                    v149 = &v133[7 * v129];
                    *(_DWORD *)v149 = 1;
                    v149[1] = v145;
                    *((_DWORD *)v149 + 4) = 1;
                    v149[3] = 0;
                    v149[4] = *(_QWORD *)(a1 + 8) + v143;
                    v149[5] = v139;
                    v149[6] = 0;
                    v150 = v145 + v139;
                    ++v129;
                    *((_DWORD *)v149 + 14) = 2;
                    v149[8] = v148;
                    *((_DWORD *)v149 + 18) = 1;
                    v149[10] = v45;
                    v149[11] = 0;
                    v149[12] = v150;
                    v149[13] = 0;
                    v131 = v148 + v150;
LABEL_219:
                    ++v129;
                    if (++v136 >= (int)v222)
                      goto LABEL_220;
                  }
                  v151 = &v133[7 * v129];
                  *(_DWORD *)v151 = 2;
                  v151[1] = v144;
                  *((_DWORD *)v151 + 4) = 1;
                  v151[3] = v143;
                  v151[4] = 0;
LABEL_218:
                  v151[5] = v139;
                  v151[6] = 0;
                  v131 = v139 + v144;
                  goto LABEL_219;
                }
LABEL_220:
                v152 = &v133[7 * v129];
                *(_DWORD *)v152 = 4;
                v152[1] = 0;
                *((_DWORD *)v152 + 4) = 1;
                v153 = v129 + 1;
                v44 = v210;
                v152[3] = v210;
                v152[4] = 0;
                v152[5] = 0;
                v152[6] = 0;
                goto LABEL_221;
              }
              v207 = 0;
LABEL_258:
              a3 = v213;
LABEL_259:
              v44 = v210;
            }
          }
          else
          {
            v157 = BOM_calloc(0xA8uLL, 1uLL);
            if (v157)
            {
              v128 = (uint64_t)v157;
              *v157 = a1;
              v158 = v223;
              v157[1] = v224;
              v157[2] = v158;
              v157[3] = v212;
              v157[4] = v44;
              v157[5] = v46;
              if (v14)
              {
                v153 = 1;
                *((_DWORD *)v157 + 14) = 1;
                v157[8] = v45;
                *((_DWORD *)v157 + 18) = 1;
                v157[10] = 0;
                v157[11] = *(_QWORD *)(a1 + 8);
                v157[12] = 0;
                v157[13] = 0;
                v159 = v45;
                if ((_DWORD)a2)
                {
                  *((_DWORD *)v157 + 28) = 2;
                  v157[15] = v46 - v45;
                  *((_DWORD *)v157 + 32) = 1;
                  v157[17] = v45;
                  v157[18] = 0;
                  v157[19] = v45;
                  v157[20] = 0;
                  v45 = v46;
                  v153 = 2;
                  goto LABEL_221;
                }
              }
              else
              {
                v159 = 0;
                v153 = 0;
                if ((a2 & 1) != 0)
                {
                  *((_DWORD *)v157 + 14) = 2;
                  v157[8] = v46;
                  v153 = 1;
                  *((_DWORD *)v157 + 18) = 1;
                  v157[10] = v45;
                  v157[11] = 0;
                  v157[12] = v45;
                  v157[13] = 0;
                  v45 += v46;
                  goto LABEL_221;
                }
              }
              if (v46 == -1 || v46 > v45)
              {
                v160 = (uint64_t)&v157[7 * v153 + 7];
                *(_DWORD *)v160 = 3;
                *(_QWORD *)(v160 + 8) = 0;
                *(_DWORD *)(v160 + 16) = 1;
                *(_QWORD *)(v160 + 24) = v45;
                *(_QWORD *)(v160 + 32) = 0;
                *(_QWORD *)(v160 + 40) = v159;
                *(_QWORD *)(v160 + 48) = 0;
                ++v153;
              }
LABEL_221:
              *(_DWORD *)(v128 + 48) = v153;
              v154 = v44;
              _normalizeBomCopySpecification(v128, 0x1000u, *(_DWORD *)(a1 + 16), (size_t *)&v219);
              if ((*(_DWORD *)(a3 + 116) & 0x40000020) == 0x20
                && *(_BYTE *)(a1 + 195)
                && *((_QWORD *)v219 + 4) == *((_QWORD *)v219 + 5))
              {
                *(_BYTE *)(a1 + 196) = 0;
                if (!v208)
                  goto LABEL_234;
              }
              else
              {
                BOMFileSetAFSCCompression(v223);
                if (v209 == 5)
                  v155 = (unsigned int *)&v220 + 1;
                else
                  v155 = 0;
                if (v208)
                  v156 = &v220;
                else
                  v156 = 0;
                v43 = _executeBomCopySpecification((int *)v219, 0x1000u, *(_DWORD *)(a1 + 16), v155, (uint64_t)v156, v45);
                if (!v208)
                  goto LABEL_234;
              }
              *(_DWORD *)(a1 + 200) = v220;
LABEL_234:
              free((void *)v128);
              free(v219);
              v219 = 0;
              if ((_DWORD)v43)
                goto LABEL_235;
              if (a5
                && *(_BYTE *)(a1 + 173)
                && *(_DWORD *)(a1 + 12716) == 3
                && !*a7
                && (v200 || (v162 = *(regex_t **)(a1 + 184)) != 0
                         && BOMPatternMatch(v162, *(const char **)(a1 + 2296))))
              {
                if (!*(_QWORD *)(a1 + 12936))
                {
                  ++*(_QWORD *)(a1 + 10576);
                  snprintf((char *)(a1 + 8448), 0x400uLL, "%s.dittoKeptBinary.%d.%lu");
                  goto LABEL_286;
                }
                v161 = *(_QWORD *)(a1 + 10576);
                if (__ROR8__(0x8F5C28F5C28F5C29 * v161, 1) <= 0x51EB851EB851EB8uLL)
                {
                  v184 = *(void **)(a1 + 10584);
                  if (v184)
                    free(v184);
                  *(_QWORD *)&v225.st_dev = 0;
                  v225.st_ino = 0;
                  uuid_generate_random((unsigned __int8 *)&v225);
                  v185 = (char *)malloc_type_malloc(0x25uLL, 0x12A6DCF8uLL);
                  uuid_unparse((const unsigned __int8 *)&v225, v185);
                  v186 = (char *)malloc_type_malloc(0x400uLL, 0x66ADC323uLL);
                  *(_QWORD *)(a1 + 10584) = v186;
                  snprintf(v186, 0x400uLL, "%s/%.2s/%.2s/%.2s/%s", *(const char **)(a1 + 12936), v185, v185 + 2, v185 + 4, v185);
                  free(v185);
                  if (!_mkdirs(a1, *(_QWORD *)(a1 + 10584)))
                  {
                    v161 = *(_QWORD *)(a1 + 10576);
                    goto LABEL_273;
                  }
                  v187 = *(_QWORD *)(a1 + 10584);
                  v188 = __error();
                  v189 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 64);
                  if (v189)
                    v189(a1, v187, *v188);
LABEL_302:
                  v43 = 0;
                }
                else
                {
LABEL_273:
                  *(_QWORD *)(a1 + 10576) = v161 + 1;
                  snprintf((char *)(a1 + 8448), 0x400uLL, "%s/%lu");
LABEL_286:
                  v169 = *(_QWORD *)(a1 + 12832);
                  v170 = *(_QWORD *)(v169 + 8);
                  v171 = a1 + 3328;
                  if ((*(_WORD *)(a4 + 4) & 0xF000) == 0x8000)
                    v172 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v169 + 240))(v170, v171, a1 + 8448);
                  else
                    v172 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v169 + 264))(v170, v171, a1 + 8448);
                  if (v172)
                  {
                    v173 = __error();
                    v165 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
                    v43 = 2;
                    if (v165)
                    {
                      v166 = *v173;
                      v168 = a1;
                      v167 = a1 + 8448;
LABEL_292:
                      v165(v168, v167, v166);
                    }
                  }
                  else
                  {
                    v174 = *(_QWORD *)(a1 + 176);
                    if (!v174)
                      goto LABEL_244;
                    v175 = strlen((const char *)(a1 + 8448));
                    if (BOMFileWrite(v174, (UInt8 *)(a1 + 8448), v175) == v175)
                    {
                      a3 = v213;
                      if (BOMFileWrite(*(_QWORD *)(a1 + 176), (UInt8 *)"\n", 1) == 1)
                        goto LABEL_244;
                      v176 = __error();
                      v177 = strerror(*v176);
                      BOMCopierNotifyFatalError(a1, "can't write to keepBinariesList: %s", v178, v179, v180, v181, v182, v183, v177);
                      v43 = 2;
                    }
                    else
                    {
                      v190 = __error();
                      strerror(*v190);
                      BOMCopierNotifyFatalError(a1, "can't write %s to keepBinariesList: %s", v191, v192, v193, v194, v195, v196, a1);
                      v43 = 2;
                      a3 = v213;
                    }
LABEL_235:
                    v44 = v154;
                  }
                }
              }
              else
              {
LABEL_244:
                v44 = v154;
                if (*(_DWORD *)(a1 + 12712) != 2)
                  goto LABEL_278;
                if (*(_BYTE *)(a1 + 12769)
                  && BOMFileSetCompression((uint64_t)v224, 0, 1, *(_DWORD *)(a1 + 12792)))
                {
LABEL_167:
                  __error();
                  v43 = _checkCopyFileError(a1);
                }
                else
                {
                  BOMFileClearEncrypted((uint64_t)v224);
                  if (*(_DWORD *)(a1 + 12776))
                  {
                    BOMFileSetPartialRead((uint64_t)v224, 0);
                    BOMFileSetDataDescriptor((uint64_t)v224, 0);
                    v217 = 0;
                    if (BOMFileRead(v224, (char *)&v217, 4uLL) != 4)
                      goto LABEL_167;
                    if (v217 != 134695760)
                      goto LABEL_167;
                    v216 = 0;
                    *(_QWORD *)&v225.st_dev = 0;
                    v218 = 0;
                    if (BOMPKZipReadDataDescriptor(*(int ***)(a1 + 12752), *(unsigned __int8 *)(a1 + 12812), &v216, (unint64_t *)&v225, (unint64_t *)&v218))goto LABEL_167;
                    *(_QWORD *)(a3 + 96) = v218;
                  }
LABEL_278:
                  if (*(_DWORD *)(a1 + 12716) != 5 || !*(_QWORD *)(a3 + 96))
                    goto LABEL_302;
                  if (BOMFileSetCompression(v223, 0, 0, *(_DWORD *)(a1 + 12792)))
                    goto LABEL_167;
                  v163 = BOMFileOffset(v223) - v202;
                  v225.st_dev = 134695760;
                  v202 = v163;
                  if (BOMFileWrite(v223, (UInt8 *)&v225, 4) != 4)
                    goto LABEL_167;
                  v43 = 0;
                  if (BOMPKZipWriteDataDescriptor(*(_QWORD *)(a1 + 12760), HIDWORD(v220), v163, *(_DWORD *)(a3 + 96)))
                  {
                    v164 = __error();
                    v165 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
                    v43 = 2;
                    if (v165)
                    {
                      v166 = *v164;
                      v167 = a1 + 8448;
                      v168 = a1;
                      goto LABEL_292;
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          __error();
          v43 = _checkCopyFileError(a1);
LABEL_156:
          v44 = v110;
LABEL_157:
          v118 = *(_DWORD *)(a1 + 12712);
          switch(v118)
          {
            case 3:
              v43 = 2;
              break;
            case 2:
              *(_QWORD *)(a3 + 96) = 0;
              v119 = _skipPKZipFile();
              goto LABEL_163;
            case 1:
              *(_QWORD *)(a3 + 96) -= v45;
              v119 = _skipCPIOFile(a1);
LABEL_163:
              if (v119)
                v43 = 2;
              else
                v43 = v43;
              break;
          }
        }
      }
      BOMFileSetDataDescriptor((uint64_t)v224, 0);
      if (v224)
      {
        v123 = v203;
        v124 = __src;
        v125 = v207;
        if (!*(_DWORD *)(a1 + 12712))
        {
          v126 = BOMFileClose((uint64_t)v224);
          if (!(_DWORD)v43 && v126)
          {
            __error();
            v43 = _checkCopyFileError(a1);
          }
          v224 = 0;
        }
      }
      else
      {
        v123 = v203;
        v124 = __src;
        v125 = v207;
      }
      if (v123)
        free(v123);
      if (v221)
        free(v221);
      if (v124)
        free(v124);
      if (v125)
        free(v125);
      return v43;
    case 3:
      goto LABEL_168;
    default:
      v43 = 0;
      goto LABEL_53;
  }
}

uint64_t _copyAppleDoubleToArchive(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  int v13;
  uint64_t v14;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  uint64_t File;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t, unint64_t);
  int v26;
  int *v27;
  void (*v28)(uint64_t, uint64_t, _QWORD);
  int v29;
  int *v30;
  _OWORD v31[6];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  char v35[1024];
  UInt8 __str[1024];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 12716) == 3)
    goto LABEL_18;
  v8 = a1 + 11616;
  v9 = *(_QWORD *)(a1 + 2296);
  v10 = a1 + 7424;
  v11 = *(_BYTE *)(a1 + 11616) ? (const char *)(a1 + 10592) : *(const char **)(a1 + 2296);
  v12 = strncpy((char *)(a1 + 7424), v11, 0x400uLL);
  BOMAppleDoublePathToADPath(v12, (char *)(a1 + 5376));
  if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169))
    v13 = 4980740;
  else
    v13 = 4980736;
  v14 = v13 | (*(_BYTE *)(a1 + 171) != 0);
  if (((*(unsigned int (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 12832) + 344))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, 0, 0, v14 | 0x10000) & v14) == 0)goto LABEL_18;
  if (!issetugid())
    getenv("TMPDIR");
  if ((unint64_t)__strlcpy_chk() >= 0x400 || (unint64_t)__strlcat_chk() >= 0x400)
    return _checkCopyFileError(a1);
  if (!(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 336))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v10))
  {
LABEL_22:
    __error();
    return _checkCopyFileError(a1);
  }
  if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 344))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v10, 0, v14))
  {
    if (*__error() == 1 && *(_QWORD *)(a1 + 12840))
    {
LABEL_18:
      v16 = 0;
      if (a4)
        *a4 = 1;
      return v16;
    }
    goto LABEL_22;
  }
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  memset(v31, 0, sizeof(v31));
  if (!(*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v10, v31))
  {
    v17 = v32;
    v18 = *(_BYTE *)(v8 + 1197) == 0;
    v30 = 0;
    if (!BOMFileOpenWithSys(&v30, v10, 0, 0, 16 * v18, *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 12832))|| *__error() == 2)
    {
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v10);
      *(_QWORD *)(a3 + 96) = v17;
      *(_WORD *)(a3 + 4) = *(_WORD *)(a3 + 4) & 0x1B6 | 0x8000;
      v19 = *(_DWORD *)(a1 + 12716);
      if (v19 == 5)
      {
        if (*(_BYTE *)(v8 + 1152))
        {
          snprintf((char *)__str, 0x400uLL, "./%s/%s", "__MACOSX", (const char *)(a1 + 5378));
          _parentPath((char *)__str, v35, 0x400uLL);
          if (_insertQuarantinePath(*(_QWORD *)(a1 + 12760), v35, 1))
            goto LABEL_62;
          __strlcpy_chk();
        }
        if (BOMPKZipWriteLocalHeader(*(_QWORD *)(a1 + 12760), (char *)(a1 + 5376), a3, 0, 0))
          goto LABEL_62;
        File = BOMPKZipGetFile(*(_QWORD *)(a1 + 12760));
        if (BOMFileSetCompression(File, 1, 0, *(_DWORD *)(a1 + 12792)))
          goto LABEL_62;
        v29 = BOMFileOffset(File);
        if (v17)
        {
LABEL_37:
          v22 = 0;
          v23 = 0;
          while (!*(_BYTE *)(a1 + 168))
          {
            if (v17 - v22 >= 0x20000)
              v24 = 0x20000;
            else
              v24 = v17 - v22;
            if (BOMFileRead(v30, *(char **)(a1 + 8), v24) != v24 || BOMFileWrite(File, *(UInt8 **)(a1 + 8), v24) != v24)
              goto LABEL_62;
            v22 += v24;
            if (a4)
            {
              v25 = *(void (**)(uint64_t, uint64_t, unint64_t))(a1 + 104);
              if (v25)
                v25(a1, v9, *(_QWORD *)(a3 + 96) + v22);
            }
            if (*(_DWORD *)(a1 + 12716) == 5)
              v23 = crc32(v23, *(const Bytef **)(a1 + 8), v24);
            if (v22 >= v17)
              goto LABEL_56;
          }
          BOMFileClose((uint64_t)v30);
          return 2;
        }
      }
      else
      {
        if (v19 != 4)
        {
          BOMFileClose((uint64_t)v30);
          v20 = a1;
          return _checkCopyFileError(v20);
        }
        if (BOMCPIOWriteHeader(*(_QWORD *)(a1 + 12736), (char *)(a1 + 5376), a3))
          goto LABEL_62;
        File = BOMCPIOGetFile(*(_QWORD *)(a1 + 12736));
        v29 = 0;
        if (v17)
          goto LABEL_37;
      }
      v23 = 0;
LABEL_56:
      if (*(_DWORD *)(a1 + 12716) != 5)
        goto LABEL_64;
      if (!BOMFileSetCompression(File, 0, 0, *(_DWORD *)(a1 + 12792)))
      {
        v26 = BOMFileOffset(File);
        *(_DWORD *)__str = 134695760;
        if (BOMFileWrite(File, __str, 4) == 4)
        {
          if (BOMPKZipWriteDataDescriptor(*(_QWORD *)(a1 + 12760), v23, v26 - v29, *(_DWORD *)(a3 + 96)))
          {
            BOMFileClose((uint64_t)v30);
            v27 = __error();
            v28 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 64);
            if (v28)
              v28(a1, a1 + 8448, *v27);
            return 2;
          }
LABEL_64:
          BOMFileClose((uint64_t)v30);
          v16 = 0;
          if (a4)
            *a4 = 0;
          return v16;
        }
      }
LABEL_62:
      BOMFileClose((uint64_t)v30);
      __error();
      v20 = a1;
      return _checkCopyFileError(v20);
    }
  }
  __error();
  v16 = _checkCopyFileError(a1);
  (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v10);
  return v16;
}

uint64_t change_flags_0(uint64_t a1, char *a2, int a3, uint64_t a4)
{
  uint64_t result;
  BOOL v8;
  _DWORD v9[2];
  int v10;

  v9[0] = a3;
  v9[1] = a4;
  v10 = -1;
  if (fsctl(a2, 0xC00C4114uLL, v9, 0))
  {
    if (*__error() != 25 && *__error() != 45)
      return 1;
    result = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 208))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, a4);
    if (!(_DWORD)result)
      return result;
    v8 = *__error() == 45;
  }
  else
  {
    v8 = v9[0] == v10;
  }
  return !v8;
}

void *_parentPath(char *a1, char *a2, size_t a3)
{
  char *v6;
  int64_t v7;
  void *result;

  v6 = strrchr(a1, 47);
  if (!v6)
    return (void *)strlcpy(a2, ".", a3);
  v7 = v6 - a1;
  result = memcpy(a2, a1, v6 - a1);
  a2[v7] = 0;
  return result;
}

uint64_t _insertQuarantinePath(uint64_t a1, char *a2, uint64_t a3)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  char v16;
  char v17[1025];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v7 = 0u;
  if (BOMPKZipLookupQuarantinePath(a1, a2, &v16))
    return 0xFFFFFFFFLL;
  if (v16)
    return 0;
  _parentPath(a2, v17, 0x401uLL);
  if (*(unsigned __int16 *)v17 != 46 && _insertQuarantinePath(a1, v17, a3))
    return 0xFFFFFFFFLL;
  if ((_DWORD)a3)
  {
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    v7 = 0u;
    WORD2(v7) = 16893;
    LODWORD(v8) = geteuid();
    DWORD1(v8) = getegid();
    *(_QWORD *)&v9 = time(0);
    *(_QWORD *)&v10 = time(0);
    *(_QWORD *)&v11 = time(0);
    *(_QWORD *)&v13 = 748;
    if (BOMPKZipWriteLocalHeader(a1, a2, (uint64_t)&v7, 0, 0))
      return 0xFFFFFFFFLL;
  }
  if (BOMPKZipStoreQuarantinePath(a1, a2))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t _copyFromCPIO(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5, int a6)
{
  _BYTE *v9;
  unsigned int v10;
  char *v11;
  const char *v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  size_t v17;
  char *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  int *v27;
  void (*v28)(uint64_t, char *, _QWORD);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t FSObjectAtPath;
  uint64_t v40;
  _BOOL4 v41;
  __int16 v42;
  unint64_t v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  char *v48;
  const char *v49;
  char *v50;
  char *v51;
  char **v52;
  char *v53;
  void (*v54)(uint64_t, const char *, uint64_t, _QWORD, _QWORD);
  void (*v55)(uint64_t, const char *, uint64_t);
  uint64_t v56;
  char *v57;
  char **v58;
  uint64_t v59;
  char *v60;
  char *v61;
  uint64_t v62;
  char *v63;
  int *v64;
  void (*v65)(uint64_t, char *, _QWORD);
  const char *v66;
  int *v67;
  void **v68;
  char v70;
  size_t v71;
  uint64_t v72;
  uint64_t v73;
  char *__source;
  char *__sourcea;
  char *v77;
  size_t v78;
  char *__s1;
  const char *v82;
  int v83;
  __int16 v84;
  unsigned int v85;

  v84 = 0;
  v9 = (_BYTE *)(a1 + 248);
  v10 = strlen((const char *)(a1 + 248));
  v11 = (char *)BOM_malloc(v10 + 2);
  if (!v11)
    return 2;
  v12 = v11;
  memmove(v11, v9, v10);
  if (v10)
  {
    v13 = v10 + 1;
    v12[v10] = 47;
    v12[v10 + 1] = 0;
  }
  else
  {
    v13 = 0;
  }
  v82 = v12;
  v72 = 0;
  v73 = 0;
  v15 = 0;
  v16 = 0;
  __s1 = (char *)(a1 + 7424);
  __source = 0;
  v77 = (char *)(a1 + 3328);
  v17 = v13;
  v78 = v13;
  while (1)
  {
    v85 = 0;
    v18 = (char *)v82;
    if (*(_BYTE *)(a1 + 12721) == 1)
    {
      *__error() = 0;
      __strlcpy_chk();
      v19 = BOMCPIOReadHeader(*(_QWORD *)(a1 + 12728), v9, a2);
      if (v19)
        break;
    }
    v26 = v9;
    if (*v9 == 46)
    {
      if (*(_BYTE *)(a1 + 249) == 47)
        v26 = (const char *)(a1 + 249);
      else
        v26 = v9;
    }
    if (strlcpy(a4, v26, a5) >= a5)
    {
      v55 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (v55)
        v55(a1, v26, 63);
      goto LABEL_110;
    }
    if ((!a6 || *(_BYTE *)(a1 + 12822)) && *v26 == 46 && (!v26[1] || v26[1] == 47 && !v26[2]))
    {
      if (_chPerms(a1, v77, a2, &v84, 1))
      {
        v27 = __error();
        v28 = *(void (**)(uint64_t, char *, _QWORD))(a1 + 64);
        if (v28)
          v28(a1, v77, *v27);
      }
      LOWORD(v73) = *(_WORD *)(a2 + 4);
    }
    if (strncmp(v9, v82, v17))
    {
      *(_BYTE *)(a1 + 12721) = 0;
      v82[(v17 - 1)] = 0;
      v54 = *(void (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD))(a1 + 96);
      v53 = __source;
      if (v54)
        goto LABEL_84;
      goto LABEL_85;
    }
    v35 = 1;
    *(_BYTE *)(a1 + 12721) = 1;
    if (*(_BYTE *)(a1 + 169) && *(_DWORD *)(a1 + 12716) == 3 && (*(_WORD *)(a2 + 4) & 0xF000) == 0x8000)
      v35 = BOMAppleDoubleIsADFile(v9) == 0;
    if (!*(_BYTE *)(a1 + 12824) || (*(_WORD *)(a2 + 4) & 0xF000) != 0x8000)
      goto LABEL_37;
    if (!v16 && *(_QWORD *)(a2 + 96) == 0x40000000)
    {
      v36 = 0;
      v16 = 1;
      goto LABEL_38;
    }
    if ((v16 == 2 || v16 == 1) && !strcmp(__s1, v9))
    {
      v16 = 2;
      v36 = 1;
    }
    else
    {
LABEL_37:
      v36 = 0;
      v16 = 0;
    }
LABEL_38:
    if (*(_DWORD *)(a1 + 12716) == 3
      && (v37 = _checkForDestinationConflict(a1, v77, a2, a3, (_BYTE *)&v84 + 1, &v85), v85 == 1))
    {
      v45 = v37;
      if (v37 > 1 || _skipCPIOFile(a1))
        goto LABEL_110;
      v46 = HIDWORD(v73);
      if (v45 == 1)
        v46 = 1;
      HIDWORD(v73) = v46;
      v17 = v78;
    }
    else
    {
      v38 = *(_QWORD *)(a1 + 152);
      if (v38)
      {
        FSObjectAtPath = BOMBomGetFSObjectAtPath(v38, v9);
        if (!FSObjectAtPath)
          goto LABEL_46;
        BOMFSObjectFree(FSObjectAtPath);
      }
      v40 = *(_QWORD *)(a1 + 160);
      if (v40)
      {
        v41 = BOMBomFSObjectExistsAtPath(v40, *(_QWORD *)(a1 + 2296));
        v42 = *(_WORD *)(a2 + 4);
        if (!v41 || (v42 & 0xF000) == 0x4000)
          goto LABEL_50;
LABEL_46:
        if (_skipCPIOFile(a1))
          goto LABEL_110;
        v85 = 1;
        v17 = v78;
      }
      else
      {
        v42 = *(_WORD *)(a2 + 4);
LABEL_50:
        HIDWORD(v43) = v42 & 0xF000;
        LODWORD(v43) = HIDWORD(v43) - 0x2000;
        switch((v43 >> 13))
        {
          case 0u:
          case 2u:
            v44 = _copyDevice(a1, a2);
            goto LABEL_60;
          case 1u:
            v70 = a5;
            v44 = _copyDir(a1, a2, a3, 0, HIBYTE(v84), 0, 0, a4);
            goto LABEL_60;
          case 3u:
            v44 = _copyFile(a1, a2, a3, HIBYTE(v84), *(_DWORD **)(a1 + 136), &v85, v36);
            goto LABEL_60;
          case 4u:
            v44 = _copyLink(a1, a2, a3, SHIBYTE(v84));
LABEL_60:
            if (v44 == 1)
            {
              HIDWORD(v73) = 1;
            }
            else if (v44 == 2)
            {
              goto LABEL_110;
            }
LABEL_64:
            v17 = v78;
            if (v35 || (v85 & 0xFFFFFFFD) != 0)
              continue;
            v47 = v72;
            if (!v72)
            {
              v48 = (char *)BOM_malloc(0x40uLL);
              v47 = 4;
              goto LABEL_70;
            }
            if (v72 == v15)
            {
              v48 = (char *)BOM_realloc(__source, 32 * v72);
              v47 = 2 * v72;
LABEL_70:
              v18 = (char *)v82;
              goto LABEL_72;
            }
            v18 = (char *)v82;
            v48 = __source;
LABEL_72:
            if (!v48)
            {
              BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double files.", v29, v30, v31, v32, v33, v34, v70);
              goto LABEL_106;
            }
            v72 = v47;
            v49 = (const char *)(a1 + 3328);
            if (*(_BYTE *)(a1 + 11616))
              v49 = (const char *)(a1 + 10592);
            __sourcea = (char *)v49;
            v50 = v48;
            v71 = strlen(v49);
            v51 = (char *)malloc_type_malloc(v71 + 1, 0x37DCBF42uLL);
            v17 = v78;
            strlcpy(v51, __sourcea, v71 + 1);
            __source = v50;
            v52 = (char **)&v50[16 * v15];
            *v52 = v51;
            v52[1] = (char *)v71;
            ++v15;
            break;
          default:
            goto LABEL_64;
        }
      }
    }
  }
  if (v19 == 3)
  {
    v66 = "bad file format";
LABEL_109:
    BOMCopierNotifyFatalError(a1, "cpio read error: %s", v20, v21, v22, v23, v24, v25, (char)v66);
LABEL_110:
    if (__source)
    {
      if (v15)
      {
        v68 = (void **)__source;
        do
        {
          free(*v68);
          *v68 = 0;
          v68 += 2;
          --v15;
        }
        while (v15);
      }
      free(__source);
    }
    v14 = 2;
    v18 = (char *)v82;
    goto LABEL_116;
  }
  if (v19 != 4)
  {
    v67 = __error();
    LOBYTE(v66) = strerror(*v67);
    goto LABEL_109;
  }
  v53 = __source;
  if (v17 >= 2)
  {
    v82[(v17 - 1)] = 0;
    v54 = *(void (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD))(a1 + 96);
    if (v54)
LABEL_84:
      v54(a1, v82, 2, 0, 0);
  }
LABEL_85:
  if (v53)
  {
    v83 = 0;
    if (v15)
    {
      v56 = 0;
      v57 = v53 + 16;
      do
      {
        v58 = (char **)&v53[16 * v56];
        if (*v58)
        {
          __strlcpy_chk();
          __strlcat_chk();
          BOMAppleDoubleADPathToPath(*v58, __s1);
          HIDWORD(v73) = _mergeAppleDouble(a1, &v83);
          if (!v83)
            (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 1272);
          v59 = v56 + 1;
          if (v56 + 1 < v15)
          {
            v60 = &__source[16 * v56 + 8];
            v61 = &v57[16 * v56];
            v62 = v56 + 1;
            do
            {
              v63 = *(char **)v61;
              if (*(_QWORD *)v61 && *(_QWORD *)v60 == *((_QWORD *)v61 + 1) && !strcmp(*v58, *(const char **)v61))
              {
                free(v63);
                *(_QWORD *)v61 = 0;
                *((_QWORD *)v61 + 1) = 0;
              }
              ++v62;
              v61 += 16;
            }
            while (v15 != v62);
          }
          free(*v58);
          *v58 = 0;
          v58[1] = 0;
          v53 = __source;
        }
        else
        {
          v59 = v56 + 1;
        }
        v56 = v59;
      }
      while (v59 != v15);
    }
    free(v53);
    v18 = (char *)v82;
  }
  *a4 = 0;
  if ((_BYTE)v84)
  {
    if ((*(unsigned int (**)(_QWORD, char *, _QWORD))(*(_QWORD *)(a1 + 12832) + 200))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v77, (unsigned __int16)v73))
    {
      v64 = __error();
      v65 = *(void (**)(uint64_t, char *, _QWORD))(a1 + 64);
      if (v65)
        v65(a1, v77, *v64);
    }
  }
LABEL_106:
  v14 = HIDWORD(v73);
LABEL_116:
  free(v18);
  return v14;
}

uint64_t _copyFromPKZip(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5)
{
  _BYTE *v10;
  unsigned int v11;
  char *v12;
  char *v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  _BYTE *v25;
  unint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  int *File;
  uint64_t v49;
  char *v50;
  char *v51;
  char **v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t FSObjectAtPath;
  uint64_t v57;
  _BOOL4 v58;
  __int16 v59;
  int v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  const char *v69;
  void (*v70)(uint64_t, const char *, uint64_t);
  void (*v71)(uint64_t, char *, uint64_t, _QWORD, _QWORD);
  void (*v72)(uint64_t, char *, uint64_t, _QWORD, _QWORD);
  char *v73;
  uint64_t v74;
  void *v75;
  char *v76;
  unsigned int v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  char *v83;
  char v84;
  size_t v85;
  unsigned int v86;
  uint64_t v87;
  char *v88;
  _BYTE *v89;
  char *__s;
  uint64_t v91;
  size_t __n;
  char *v93;
  char *__dst;
  int *v95;
  int v96;
  unsigned __int8 v97;
  int v98;
  int64_t v99;
  unsigned int v100[3];

  v99 = 0;
  v98 = 0;
  v97 = 0;
  v10 = (_BYTE *)(a1 + 248);
  v11 = strlen((const char *)(a1 + 248));
  v12 = (char *)BOM_malloc(v11 + 2);
  if (!v12)
    return 2;
  v13 = v12;
  v14 = v11;
  memmove(v12, v10, v11);
  if (v11)
  {
    ++v11;
    v13[v14] = 47;
    v13[v11] = 0;
  }
  v15 = (_DWORD *)(a1 + 12772);
  if (BOMPKZipReadNextSignature(*(_QWORD *)(a1 + 12752), (int *)(a1 + 12772)))
  {
    v22 = "Couldn't read PKZip signature";
LABEL_6:
    BOMCopierNotifyFatalError(a1, v22, v16, v17, v18, v19, v20, v21, v84);
    v23 = 2;
    goto LABEL_7;
  }
  v25 = (_BYTE *)(a1 + 12721);
  if (*v15 == 2)
  {
    v23 = 0;
    *v25 = 0;
    goto LABEL_7;
  }
  if (*v15 != 1)
  {
    v22 = "Incorrect pkzip signature";
    goto LABEL_6;
  }
  v91 = a3;
  v93 = 0;
  __dst = a4;
  v87 = 0;
  v26 = 0;
  v27 = v11;
  v23 = 0;
  v95 = (int *)(a1 + 12776);
  v86 = v27;
  __n = v27;
  v88 = (char *)(a1 + 7424);
  v89 = (_BYTE *)(a1 + 249);
  __s = (char *)(a1 + 3328);
  while (1)
  {
    v100[0] = 0;
    if (!*v25)
      goto LABEL_19;
    if (BOMPKZipReadLocalHeader(*(_QWORD *)(a1 + 12752), v10, a2, (unint64_t *)&v99, &v98, (_BYTE *)(a1 + 12796), v95, (unsigned int *)(a1 + 12808), (_BYTE *)(a1 + 12812)))
    {
      v69 = "Couldn't read pkzip local header";
      goto LABEL_113;
    }
    v34 = v98;
    if (v98)
    {
      if (v98 == 8)
      {
        v34 = 1;
        goto LABEL_18;
      }
      v69 = "Unknown compression type";
LABEL_113:
      BOMCopierNotifyFatalError(a1, v69, v28, v29, v30, v31, v32, v33, v84);
      goto LABEL_114;
    }
LABEL_18:
    v25[48] = v34;
    if (!*v95 && !*(_QWORD *)(a2 + 96))
    {
      v44 = v99;
      if (v99 >= 1)
      {
        v45 = 0;
        while (1)
        {
          v46 = v44 - v45;
          v47 = v46 >= 1024 ? 1024 : v46;
          File = (int *)BOMPKZipGetFile(*(_QWORD *)(a1 + 12752));
          if (BOMFileRead(File, _copyFromPKZip_junk, v47) != v47)
            break;
          v45 += v47;
          v44 = v99;
          if (v45 == v99)
          {
            v99 = 0;
            v25 = (_BYTE *)(a1 + 12721);
            *(_BYTE *)(a1 + 12769) = 0;
            goto LABEL_19;
          }
        }
        v69 = "Couldn't extract junk data";
        goto LABEL_113;
      }
    }
LABEL_19:
    v35 = v10;
    if (*v10 == 46)
    {
      if (*v89 == 47)
        v35 = (const char *)(a1 + 249);
      else
        v35 = v10;
    }
    if (strlcpy(__dst, v35, a5) >= a5)
    {
      v70 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (v70)
        v70(a1, v35, 63);
LABEL_114:
      v23 = 2;
LABEL_115:
      if (!v93)
        goto LABEL_7;
      if (v26)
      {
        v83 = v93;
        do
        {
          free(*(void **)v83);
          *(_QWORD *)v83 = 0;
          *((_QWORD *)v83 + 1) = 0;
          v83 += 16;
          --v26;
        }
        while (v26);
      }
      v73 = v93;
LABEL_120:
      free(v73);
      goto LABEL_7;
    }
    if (strncmp(v10, v13, __n))
      break;
    *v25 = 1;
    if ((*(_WORD *)(a2 + 4) & 0xF000) == 0x8000 && BOMAppleDoubleIsADFile(v10) && *(_BYTE *)(a1 + 169))
    {
      if (*(_DWORD *)(a1 + 12716) != 3)
        goto LABEL_59;
      if (v25[47])
      {
        v42 = *v10;
        if (v42 == 46 && *v89 == 47)
          v43 = 2;
        else
          v43 = v42 == 47;
        if (!strncmp("__MACOSX", &v10[v43], 8uLL))
        {
          _parentPath(v10, v88, 0x400uLL);
          if (_insertQuarantinePath(*(_QWORD *)(a1 + 12752), v88, 0))
          {
            __error();
            _checkCopyFileError(a1);
            goto LABEL_114;
          }
        }
      }
      v49 = v87;
      if (v87)
      {
        if (v87 == v26)
        {
          v50 = (char *)BOM_realloc(v93, 32 * v87);
          v49 = 2 * v87;
        }
        else
        {
          v50 = v93;
        }
      }
      else
      {
        v50 = (char *)BOM_malloc(0x40uLL);
        v49 = 4;
      }
      if (!v50)
      {
        BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double files.", v36, v37, v38, v39, v40, v41, v84);
        goto LABEL_7;
      }
      v87 = v49;
      v93 = v50;
      v85 = strlen(__s);
      v51 = (char *)malloc_type_malloc(v85 + 1, 0x90DF671CuLL);
      strlcpy(v51, __s, v85 + 1);
      v52 = (char **)&v93[16 * v26];
      *v52 = v51;
      v25 = (_BYTE *)(a1 + 12721);
      v52[1] = (char *)v85;
      ++v26;
    }
    if (*(_DWORD *)(a1 + 12716) == 3)
    {
      v53 = _checkForDestinationConflict(a1, __s, a2, v91, &v97, v100);
      if (v100[0] == 1)
      {
        v54 = v53;
        if (v53 > 1 || _skipPKZipFile())
          goto LABEL_114;
        if (v54 == 1)
          v23 = 1;
        else
          v23 = v23;
        goto LABEL_78;
      }
    }
LABEL_59:
    v55 = *(_QWORD *)(a1 + 152);
    if (v55)
    {
      FSObjectAtPath = BOMBomGetFSObjectAtPath(v55, v10);
      if (!FSObjectAtPath)
        goto LABEL_65;
      BOMFSObjectFree(FSObjectAtPath);
    }
    v57 = *(_QWORD *)(a1 + 160);
    if (v57)
    {
      v58 = BOMBomFSObjectExistsAtPath(v57, *(_QWORD *)(a1 + 2296));
      v59 = *(_WORD *)(a2 + 4);
      if (v58 && (v59 & 0xF000) != 0x4000)
      {
LABEL_65:
        if (_skipPKZipFile())
          goto LABEL_114;
        goto LABEL_78;
      }
    }
    else
    {
      v59 = *(_WORD *)(a2 + 4);
    }
    HIDWORD(v61) = v59 & 0xF000;
    LODWORD(v61) = HIDWORD(v61) - 0x2000;
    v60 = v61 >> 13;
    if (v60 == 1)
    {
      v84 = a5;
      v62 = _copyDir(a1, a2, v91, 0, v97, 0, 0, __dst);
    }
    else
    {
      if (v60 != 3)
        goto LABEL_76;
      v62 = _copyFile(a1, a2, v91, v97, *(_DWORD **)(a1 + 136), v100, 0);
    }
    if ((_DWORD)v62 == 1)
    {
      v23 = 1;
    }
    else if ((_DWORD)v62 == 2)
    {
      v23 = v62;
      goto LABEL_115;
    }
LABEL_76:
    if (*v25 && BOMPKZipReadNextSignature(*(_QWORD *)(a1 + 12752), (int *)(a1 + 12772)))
    {
      BOMCopierNotifyFatalError(a1, "Couldn't read pkzip signature.", v63, v64, v65, v66, v67, v68, v84);
      goto LABEL_115;
    }
LABEL_78:
    if (*v15 != 1)
      goto LABEL_87;
  }
  *v25 = 0;
  v13[v86 - 1] = 0;
  v71 = *(void (**)(uint64_t, char *, uint64_t, _QWORD, _QWORD))(a1 + 96);
  if (v71)
    v71(a1, v13, 2, 0, 0);
LABEL_87:
  *__dst = 0;
  *v25 = 0;
  if (v86 >= 2)
  {
    v13[v86 - 1] = 0;
    v72 = *(void (**)(uint64_t, char *, uint64_t, _QWORD, _QWORD))(a1 + 96);
    if (v72)
      v72(a1, v13, 2, 0, 0);
  }
  v73 = v93;
  if (v93)
  {
    if (v26)
    {
      v74 = 0;
      v75 = (void *)(a1 + 8448);
      do
      {
        v76 = &v73[16 * v74];
        if (*(_QWORD *)v76)
        {
          __strlcpy_chk();
          __strlcat_chk();
          BOMAppleDoubleADPathToPath(*(char **)v76, v75);
          if (*(_BYTE *)(a1 + 12768)
            && (v77 = *(_DWORD *)(a1 + 12780), !strncmp(*(const char **)(a1 + 12784), (const char *)v75, v77)))
          {
            __strlcpy_chk();
            strlcpy(&v88[v77 - 8], (const char *)v75 + v77 + 1, 1024 - (v77 - 8));
          }
          else
          {
            __strlcpy_chk();
          }
          v96 = 0;
          v23 = _mergeAppleDouble(a1, &v96);
          if (!v96)
            (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 12832) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 1272);
          v78 = v74 + 1;
          if (v74 + 1 < v26)
          {
            v79 = &v93[16 * v74 + 8];
            v80 = v26 - 1 - v74;
            v81 = (uint64_t)&v93[16 * v74 + 16];
            do
            {
              v82 = *(char **)v81;
              if (*(_QWORD *)v81
                && *(_QWORD *)v79 == *(_QWORD *)(v81 + 8)
                && !strcmp(*(const char **)v76, *(const char **)v81))
              {
                free(v82);
                *(_QWORD *)v81 = 0;
                *(_QWORD *)(v81 + 8) = 0;
              }
              v81 += 16;
              --v80;
            }
            while (v80);
          }
          free(*(void **)v76);
          *(_QWORD *)v76 = 0;
          *((_QWORD *)v76 + 1) = 0;
          v74 = v78;
          v73 = v93;
          v75 = (void *)(a1 + 8448);
        }
        else
        {
          ++v74;
        }
      }
      while (v74 != v26);
    }
    goto LABEL_120;
  }
LABEL_7:
  free(v13);
  return v23;
}

uint64_t _mergeAppleDouble(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v6;
  acl_t file;
  _acl *v8;
  _acl *v9;
  _acl *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;

  if (*(_BYTE *)(a1 + 169) || *(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 171))
  {
    v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    memset(v17, 0, sizeof(v17));
    if ((*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 1272, v17))
    {
      __error();
      return _checkCopyFileError(a1);
    }
    if ((*(unsigned int (**)(_QWORD, uint64_t, _OWORD *))(*(_QWORD *)(a1 + 12832) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a1 + 7424, v17))
    {
      *__error() = 0;
      v4 = 0;
      if (a2)
        *a2 = 0;
      return v4;
    }
    v15 = v19;
    v16 = v18;
    v14 = 0;
    if (!*(_BYTE *)(a1 + 12848) && !*(_BYTE *)(a1 + 195) || (v14 = AFSCLockFilePath()) != 0)
    {
      if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169))
        v6 = 9175044;
      else
        v6 = 9175040;
      if (copyfile((const char *)(a1 + 1272), (const char *)(a1 + 7424), 0, v6 | (*(_BYTE *)(a1 + 171) != 0)) < 0)
      {
        if (*__error() == 45)
          *a2 = 0;
        goto LABEL_26;
      }
      file = acl_get_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED);
      if (file)
      {
        v8 = file;
        v9 = acl_init(0);
        if (!v9
          || (v10 = v9, v11 = acl_set_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED, v9), free(v10), v11)
          || (v12 = acl_set_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED, v8), acl_free(v8), v12))
        {
LABEL_26:
          __error();
          v13 = a1;
LABEL_32:
          v4 = _checkCopyFileError(v13);
LABEL_33:
          _unlockAFSCFileLock(&v14);
          return v4;
        }
      }
      if (!set_timestamps_0((const char *)(a1 + 7424), &v16, &v15) || *__error() == 13)
      {
        v4 = 0;
        if (a2)
          *a2 = 0;
        goto LABEL_33;
      }
    }
    __error();
    v13 = a1;
    goto LABEL_32;
  }
  v4 = 0;
  if (a2)
    *a2 = 1;
  return v4;
}

uint64_t _enforceDestinationLocation(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  void (*v11)(uint64_t, char *, _QWORD);
  stat v13;
  stat v14;

  memset(&v14, 0, sizeof(v14));
  if (lstat(a2, &v14))
  {
    if (*__error() == 2)
      return 0;
    goto LABEL_6;
  }
  if ((v14.st_mode & 0xF000) == 0xA000)
  {
    memset(&v13, 0, sizeof(v13));
    if (stat(a2, &v13))
    {
LABEL_6:
      v10 = __error();
      v11 = *(void (**)(uint64_t, char *, _QWORD))(a1 + 64);
      if (v11)
        v11(a1, a2, *v10);
      return 0xFFFFFFFFLL;
    }
    if (v14.st_dev != v13.st_dev)
    {
      BOMCopierNotifyFatalError(a1, "%s exists on a different device from its target", v4, v5, v6, v7, v8, v9, (char)a2);
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t _resolveDestinationPath(uint64_t a1, char *a2, char *a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  int64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v38;
  int *v39;
  size_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int *v47;
  void (*v48)(uint64_t, char *, _QWORD);
  char v49;

  bzero(a3, 0x400uLL);
  if (*a2 != 47 && !getcwd(a3, 0x400uLL))
  {
    v39 = __error();
    v49 = strerror(*v39);
    v38 = "Could not get current working directory: %s\n";
    goto LABEL_18;
  }
  v6 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x100004077774924uLL);
  if (!v6)
  {
    v38 = "Could not allocate unresolved prefix\n";
LABEL_18:
    BOMCopierNotifyFatalError(a1, v38, v7, v8, v9, v10, v11, v12, v49);
    return 0xFFFFFFFFLL;
  }
  v13 = v6;
  v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x100004077774924uLL);
  if (v14)
  {
    v21 = v14;
    while (1)
    {
      v22 = strchr(a2, 47);
      v29 = v22;
      if (v22)
      {
        v30 = v22 - a2;
        if ((unint64_t)(v22 - a2) >= 0x400)
        {
          BOMCopierNotifyFatalError(a1, "Unresolved path component too large: %ld\n", v23, v24, v25, v26, v27, v28, (_BYTE)v22 - (_BYTE)a2);
          goto LABEL_28;
        }
        strncpy(v13, a2, 0x400uLL);
        v13[v30] = 0;
        if (snprintf(v21, 0x400uLL, "%s/%s", a3, v13) >= 0x400)
          goto LABEL_27;
        a2 = v29 + 1;
      }
      else
      {
        if (snprintf(v21, 0x400uLL, "%s/%s", a3, a2) >= 0x400)
        {
LABEL_27:
          BOMCopierNotifyFatalError(a1, "Could not construct path to resolve: %s %s %ld\n", v31, v32, v33, v34, v35, v36, (char)a3);
          goto LABEL_28;
        }
        a2 = 0;
      }
      if (!(*(uint64_t (**)(_QWORD, char *, char *))(*(_QWORD *)(a1 + 12832) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v21, a3))break;
      if (!v29)
        goto LABEL_14;
    }
    if (*__error() == 2)
    {
      if (!a2)
      {
LABEL_14:
        free(v21);
        free(v13);
        return 0;
      }
      v40 = strlen(a3);
      if (v40 + strlen(a2) + 2 <= 0x3FF)
      {
        *(_WORD *)&a3[strlen(a3)] = 47;
        strncat(a3, a2, 0x400uLL);
        goto LABEL_14;
      }
      BOMCopierNotifyFatalError(a1, "Concatenated path too large: %s %s %ld\n", v41, v42, v43, v44, v45, v46, (char)a3);
    }
    else
    {
      v47 = __error();
      v48 = *(void (**)(uint64_t, char *, _QWORD))(a1 + 64);
      if (v48)
        v48(a1, v21, *v47);
    }
LABEL_28:
    free(v21);
  }
  else
  {
    BOMCopierNotifyFatalError(a1, "Could not allocate path to resolve\n", v15, v16, v17, v18, v19, v20, v49);
  }
  free(v13);
  return 0xFFFFFFFFLL;
}

uint64_t _restoreSymlinks(uint64_t a1, int a2)
{
  uint64_t v4;
  void **v5;
  void *v6;
  int *v7;
  void (*v8)(uint64_t, void *, _QWORD);
  void (*v9)(uint64_t, void *, uint64_t, _QWORD, _QWORD);

  v4 = 0;
  while (!BOMStackIsEmpty(*(_QWORD *)(a1 + 40)))
  {
    v5 = (void **)BOMStackPop(*(uint64_t **)(a1 + 40));
    if ((*(unsigned int (**)(_QWORD, void *, void *))(*(_QWORD *)(a1 + 12832) + 264))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v5[1], *v5))
    {
      v6 = *v5;
      v7 = __error();
      v8 = *(void (**)(uint64_t, void *, _QWORD))(a1 + 64);
      if (v8)
        v8(a1, v6, *v7);
      if (!a2)
      {
        free(*v5);
        free(v5[1]);
        free(v5[2]);
        free(v5);
        return 1;
      }
      v4 = 1;
    }
    else
    {
      v9 = *(void (**)(uint64_t, void *, uint64_t, _QWORD, _QWORD))(a1 + 96);
      if (v9)
        v9(a1, v5[2], 3, 0, 0);
    }
    free(*v5);
    free(v5[1]);
    free(v5[2]);
    free(v5);
  }
  return v4;
}

uint64_t BOMCopierPrepareMatchContext(const __CFDictionary *a1, uint64_t a2, _QWORD *a3)
{
  CFTypeID TypeID;
  CFTypeID v7;
  const __CFArray *Value;
  const __CFArray *v9;
  CFTypeID v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  int64_t Count;
  void *v14;
  void *v15;
  CFIndex v16;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  char **v19;
  char **v20;
  char **v21;
  int v22;
  int v23;
  _BOOL4 v26;
  BOOL v27;
  CFIndex v28;
  _QWORD *v29;
  _DWORD *v30;
  const __CFArray *v31;
  const __CFArray *v32;
  int64_t v33;
  int64_t v34;
  _DWORD *v35;
  CFIndex v36;
  _DWORD *v37;
  const __CFString *v38;
  const __CFString *v39;
  uint64_t v40;
  void *v42;
  void *v43;
  CFTypeID v44;
  const __CFDictionary *theDict;
  CFTypeID v46;
  char __s2[255];
  char buffer[255];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v40 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 42, (uint64_t)"BOMCopierPrepareMatchContext", "match_context is NULL");
    return v40;
  }
  TypeID = CFArrayGetTypeID();
  if (!a1)
    goto LABEL_46;
  v7 = TypeID;
  Value = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("archs"));
  v9 = Value;
  if (Value && CFGetTypeID(Value) != v7)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 61, (uint64_t)"BOMCopierPrepareMatchContext", "kBOMCopierOptionArchitectureArrayKey is not a CFArrayRef");
    return 1;
  }
  v10 = CFDictionaryGetTypeID();
  v11 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("fallbackForSubtype"));
  v12 = v11;
  if (v11 && CFGetTypeID(v11) != v10)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 75, (uint64_t)"BOMCopierPrepareMatchContext", "kBOMCopierOptionArchitectureFallbackKey is not a CFDictionaryRef");
    return 1;
  }
  if (!v9)
  {
LABEL_46:
    LODWORD(Count) = 0;
    v15 = 0;
LABEL_47:
    v40 = 0;
    *(_DWORD *)a2 = Count;
    *(_QWORD *)(a2 + 8) = v15;
    return v40;
  }
  Count = CFArrayGetCount(v9);
  v14 = malloc_type_calloc(Count, 0x20uLL, 0x101004001FB615FuLL);
  if (!v14)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 92, (uint64_t)"BOMCopierPrepareMatchContext", "Could not allocate bom_cpu_type_list");
    return 1;
  }
  v15 = v14;
  v44 = v7;
  v46 = CFStringGetTypeID();
  if (Count < 1)
    goto LABEL_47;
  v16 = 0;
  theDict = v12;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, v16);
    if (!ValueAtIndex)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 105, (uint64_t)"BOMCopierPrepareMatchContext", "Could not retrieve item %d from architecture list");
LABEL_63:
      v42 = v15;
      goto LABEL_64;
    }
    v18 = ValueAtIndex;
    if (v46 != CFGetTypeID(ValueAtIndex))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 112, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from architecture list is not a CFString");
      goto LABEL_63;
    }
    if (!CFStringGetCString(v18, buffer, 255, 0x8000100u))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 120, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from architecture list could not converted to a UTF8 string");
      goto LABEL_63;
    }
    v19 = BOMGetArchInfoFromName(buffer);
    if (!v19)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 128, (uint64_t)"BOMCopierPrepareMatchContext", "Could not resolve architecture info for %s");
      goto LABEL_63;
    }
    v20 = v19;
    v21 = BOMGetArchInfoFromCpuType(*((_DWORD *)v19 + 2), -1);
    if (!v21)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 136, (uint64_t)"BOMCopierPrepareMatchContext", "Could not resolve family architecture info for %s");
      goto LABEL_63;
    }
    v22 = *((_DWORD *)v20 + 3);
    v23 = *((_DWORD *)v21 + 2);
    v26 = v22 == 3 && v23 == 16777223 || v22 != *((_DWORD *)v21 + 3);
    if (v22)
      v27 = 0;
    else
      v27 = v23 == 16777228;
    if (v27)
      v26 = 1;
    if (!v26)
      v22 = -1;
    v28 = (CFIndex)v15 + 32 * v16;
    *(_DWORD *)v28 = v23;
    *(_BYTE *)(v28 + 4) = !v26;
    *(_DWORD *)(v28 + 8) = v22;
    *(_QWORD *)(v28 + 16) = 0;
    v29 = (_QWORD *)(v28 + 16);
    *(_DWORD *)(v28 + 24) = 0;
    v30 = (_DWORD *)(v28 + 24);
    if (!theDict)
      goto LABEL_43;
    v31 = (const __CFArray *)CFDictionaryGetValue(theDict, v18);
    if (!v31)
      goto LABEL_43;
    v32 = v31;
    if (v44 != CFGetTypeID(v31))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 172, (uint64_t)"BOMCopierPrepareMatchContext", "Corresponding fallback entry for item %d from architecture list is not a CFArray");
      goto LABEL_63;
    }
    v43 = v15;
    v33 = CFArrayGetCount(v32);
    if (v33 >= 1)
      break;
LABEL_42:
    v15 = v43;
LABEL_43:
    if (++v16 == Count)
      goto LABEL_47;
  }
  v34 = v33;
  v35 = malloc_type_calloc(v33, 4uLL, 0x100004052888210uLL);
  v36 = 0;
  *v29 = v35;
  v37 = v35;
  *v30 = v34;
  while (1)
  {
    v38 = (const __CFString *)CFArrayGetValueAtIndex(v32, v36);
    if (!v38)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 193, (uint64_t)"BOMCopierPrepareMatchContext", "Could not retrieve item %d from fallback list");
      goto LABEL_56;
    }
    v39 = v38;
    if (v46 != CFGetTypeID(v38))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 201, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from fallback list is not a CFString");
      goto LABEL_56;
    }
    if (!CFStringGetCString(v39, __s2, 255, 0x8000100u))
      break;
    v37[v36++] = *((_DWORD *)BOMGetArchInfoFromName(__s2) + 3);
    if (v34 == v36)
      goto LABEL_42;
  }
  BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 210, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from fallback list could not converted to a UTF8 string");
LABEL_56:
  free(v37);
  v42 = v43;
LABEL_64:
  free(v42);
  return 1;
}

uint64_t BOMCopierReleaseMatchContext(unsigned int *a1, _QWORD *a2)
{
  uint64_t v3;
  void **v4;
  void **v5;
  uint64_t v6;

  if (a1)
  {
    v3 = *a1;
    v4 = (void **)*((_QWORD *)a1 + 1);
    if ((_DWORD)v3)
    {
      v5 = v4 + 2;
      do
      {
        if (*v5)
          free(*v5);
        v5 += 4;
        --v3;
      }
      while (v3);
    }
    else if (!v4)
    {
LABEL_11:
      v6 = 0;
      *a1 = 0;
      *((_QWORD *)a1 + 1) = 0;
      return v6;
    }
    free(v4);
    goto LABEL_11;
  }
  v6 = 22;
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 250, (uint64_t)"BOMCopierReleaseMatchContext", "match_context is NULL");
  return v6;
}

uint64_t BOMCopierMatchBinary(uint64_t a1, unsigned int *a2, _QWORD *a3)
{
  unint64_t v6;
  uint64_t v7;
  unsigned int ArchCount;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  BOOL v14;
  BOOL v15;
  BOOL *v16;
  int v17;
  int v18;
  unint64_t v19;
  _DWORD *v20;
  unint64_t v22;
  int *v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  int *v33;
  char *v34;
  unint64_t *v35;
  uint64_t v36;
  int *v37;
  int BinaryType;
  unsigned int v39;
  _DWORD *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  int v45;
  uint64_t Size;
  unsigned int v47;
  char *v48;
  _OWORD v49[2];

  if (a1)
  {
    if (a2)
    {
      v6 = *a2;
      v7 = *((_QWORD *)a2 + 1);
      a2[4] = 2;
      *((_QWORD *)a2 + 5) = 0;
      *(_QWORD *)(a2 + 7) = 0;
      *(_QWORD *)(a2 + 5) = 0;
      ArchCount = BOMCopierSourceEntryGetArchCount(a1);
      v9 = ArchCount;
      v48 = (char *)malloc_type_calloc(ArchCount, 0x28uLL, 0x1000040DFF313CCuLL);
      if (!v48)
      {
        v32 = *__error();
        v33 = __error();
        v34 = strerror(*v33);
        BOMCopierErrorCapture(a3, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 323, (uint64_t)"BOMCopierMatchBinary", "Could not allocate empty match record list: %s", v34);
        return 1;
      }
      Size = BOMCopierSourceEntryGetSize(a1);
      v10 = *a2;
      if (*a2)
        v11 = 0;
      else
        v11 = ArchCount;
      if (v10)
        v12 = 2;
      else
        v12 = 1;
      v45 = v12;
      v47 = ArchCount;
      if (ArchCount)
      {
        v13 = 0;
        v14 = v10 == 0;
        if ((_DWORD)v6)
          v15 = v10 == 0;
        else
          v15 = 1;
        while (1)
        {
          memset(v49, 0, sizeof(v49));
          if (BOMCopierSourceEntryGetArchRecord(a1, v13, v49, a3))
            break;
          v16 = (BOOL *)&v48[40 * v13];
          *v16 = v14;
          v17 = v49[0];
          *((_DWORD *)v16 + 1) = v49[0];
          v18 = DWORD1(v49[0]);
          *((_DWORD *)v16 + 2) = DWORD1(v49[0]);
          *((_OWORD *)v16 + 1) = *(_OWORD *)((char *)v49 + 8);
          *((_QWORD *)v16 + 4) = *((_QWORD *)&v49[1] + 1);
          if (!v15)
          {
            v19 = 0;
            v20 = (_DWORD *)(v7 + 8);
            do
            {
              if (v17 == *(v20 - 2) && (*((_BYTE *)v20 - 4) || ((*v20 ^ v18) & 0xFFFFFF) == 0))
              {
                *v16 = 1;
                ++v11;
                goto LABEL_37;
              }
              v20 += 8;
              ++v19;
            }
            while (v19 < v6);
            if (!v15)
            {
              v22 = 0;
              do
              {
                v23 = (int *)(v7 + 32 * v22);
                if (*((_BYTE *)v23 + 4) || (v25 = v23[6], !(_DWORD)v25))
                {
                  v24 = 0;
                }
                else
                {
                  v26 = 0;
                  v24 = 0;
                  v27 = *v23;
                  v28 = 4 * v25;
                  do
                  {
                    if (v17 == v27 && v18 == *(_DWORD *)(*(_QWORD *)(v7 + 32 * v22 + 16) + v26))
                    {
                      v24 = 1;
                      *v16 = 1;
                      ++v11;
                    }
                    v26 += 4;
                  }
                  while (v28 != v26);
                }
                if ((v24 & 1) != 0)
                  break;
                ++v22;
              }
              while (v22 < v6);
            }
          }
LABEL_37:
          if (++v13 == v9)
            goto LABEL_38;
        }
        v37 = __error();
        BOMCopierErrorCapture(a3, *v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 347, (uint64_t)"BOMCopierMatchBinary", "Could not get arch record for index %d", MEMORY[0x24BDAE888]);
        free(v48);
        return 1;
      }
LABEL_38:
      if (v11 == v47)
      {
        v29 = 1;
        v30 = Size;
      }
      else if (v11)
      {
        if (v11 == 1)
        {
          v30 = Size;
          if (!v47)
          {
            v29 = 3;
LABEL_67:
            v31 = 0;
            a2[4] = v29;
            a2[5] = v47;
            *((_QWORD *)a2 + 3) = v48;
            a2[8] = v11;
            *((_QWORD *)a2 + 5) = v30;
            return v31;
          }
          v35 = (unint64_t *)(v48 + 24);
          v36 = v9;
          do
          {
            if (*((_BYTE *)v35 - 24))
            {
              *(v35 - 1) = 0;
              v30 = *v35;
            }
            v35 += 5;
            --v36;
          }
          while (v36);
          v29 = 3;
        }
        else
        {
          v30 = Size;
          v29 = v45;
          if (v11 < v47)
          {
            BinaryType = BOMCopierSourceEntryGetBinaryType(a1);
            v39 = 20;
            if (BinaryType == 4)
              v39 = 32;
            v30 = v39 * (unint64_t)v11 + 8;
            v40 = v48 + 32;
            v41 = v9;
            do
            {
              if (*((_BYTE *)v40 - 32))
              {
                v42 = (v30 + (1 << *v40) - 1) & -(uint64_t)(1 << *v40);
                *((_QWORD *)v40 - 2) = v42;
                v30 = v42 + *((_QWORD *)v40 - 1);
              }
              v40 += 10;
              --v41;
            }
            while (v41);
            v29 = 4;
          }
        }
      }
      else
      {
        v30 = 0;
        v29 = 2;
      }
      if (v47)
      {
        v43 = v48 + 16;
        do
        {
          if (!*((_BYTE *)v43 - 16))
            *v43 = -1;
          v43 += 5;
          --v9;
        }
        while (v9);
      }
      goto LABEL_67;
    }
    v31 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 294, (uint64_t)"BOMCopierMatchBinary", "match_context is NULL");
  }
  else
  {
    v31 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 288, (uint64_t)"BOMCopierMatchBinary", "source_entry is NULL");
  }
  return v31;
}

uint64_t BOMFSOArchInfoInitialize()
{
  uint64_t v0;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  const char *v19;
  char **v20;
  const char *v21;
  uint64_t v22;
  int v23;
  char *v24;
  int *v25;
  uint64_t v26;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  char __str[1028];
  _BYTE v34[4096];
  uint64_t v35;

  v0 = MEMORY[0x24BDAC7A8]();
  v35 = *MEMORY[0x24BDAC8D0];
  if (*(uint64_t *)(v1 + 96) >= 4096)
    v2 = 4096;
  else
    v2 = *(_QWORD *)(v1 + 96);
  if (*(_DWORD *)v0 != 1)
    return 0;
  v3 = v0;
  v4 = *(_BYTE **)(v0 + 24);
  if (v4)
  {
    v2 = *(unsigned int *)(v0 + 32);
    goto LABEL_7;
  }
  v26 = *(unsigned int *)(v0 + 16);
  if ((_DWORD)v26 != -1)
  {
    if (*(_QWORD *)(v0 + 144))
    {
      snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v0 + 144), *(const char **)(v0 + 72));
      v26 = *(unsigned int *)(v3 + 16);
    }
    if ((*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v3 + 160) + 64))(*(_QWORD *)(*(_QWORD *)(v3 + 160) + 8), v26, 0, 0) < 0)return 0;
    v4 = v34;
    if ((*(uint64_t (**)(_QWORD, _QWORD, _BYTE *, unint64_t))(*(_QWORD *)(v3 + 160) + 48))(*(_QWORD *)(*(_QWORD *)(v3 + 160) + 8), *(unsigned int *)(v3 + 16), v34, v2) == v2)
    {
LABEL_7:
      if (v2 < 8)
        return 0;
      v5 = *(unsigned int *)(v3 + 16);
      if (BOMArchFlagForHeader((int *)v4, v2) == 2)
      {
        v6 = bswap32(*((_DWORD *)v4 + 1));
        v7 = 20 * v6 + 8;
        if (v7 <= (uint64_t)v2
          || (_DWORD)v5 != -1
          && (*(uint64_t (**)(_QWORD, uint64_t, _BYTE *))(*(_QWORD *)(v3 + 160) + 48))(*(_QWORD *)(*(_QWORD *)(v3 + 160) + 8), v5, &v4[v2]) == v7 - v2)
        {
          *(_WORD *)(v3 + 40) |= 2 << B_ARCHOFFT;
          *(_DWORD *)(v3 + 104) = v6;
          *(_QWORD *)(v3 + 112) = BOM_malloc(24 * v6);
          if (v6 >= 1)
          {
            v32 = v5;
            v8 = 0;
            v9 = (unsigned int *)(v4 + 20);
            v10 = 24 * v6;
            while (1)
            {
              v11 = *(v9 - 3);
              if (*(_DWORD *)v4 == -889275714)
              {
                v12 = *(_QWORD *)(v3 + 112) + v8;
                *(_DWORD *)v12 = v11;
                v13 = *(v9 - 2);
                *(_DWORD *)(v12 + 4) = v13;
                v14 = *v9;
                *(_QWORD *)(v12 + 8) = v14;
                v15 = *(v9 - 1);
              }
              else
              {
                v16 = *(_QWORD *)(v3 + 112) + v8;
                *(_DWORD *)v16 = bswap32(v11);
                v13 = *(v9 - 2);
                *(_DWORD *)(v16 + 4) = bswap32(v13);
                v14 = bswap32(*v9);
                *(_QWORD *)(v16 + 8) = v14;
                v15 = bswap32(*(v9 - 1));
              }
              if ((*(_WORD *)(v3 + 40) & (unsigned __int16)B_CKSUMS) == 0)
                goto LABEL_28;
              v17 = v15;
              v18 = v14 + v15;
              if (v18 > *(_QWORD *)(v3 + 64))
              {
                v19 = *(const char **)(v3 + 72);
                v20 = BOMGetArchInfoFromCpuType(v11, v13);
                if (v20)
                {
                  v21 = *v20;
                }
                else
                {
                  v31 = v11;
                  v21 = _cpuNameForType_generic;
                  snprintf(_cpuNameForType_generic, 0x50uLL, "<cputype %d, subtype %d>", v31, v13);
                }
                v24 = BOMExceptionHandlerMessage("file %s is corrupt: slice for %s extends beyond length of file. (%lu > %lld)\n", v19, v21, v18, *(_QWORD *)(v3 + 64));
                v25 = __error();
                _BOMExceptionHandlerCall((uint64_t)v24, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOArchInfo.c", 470, *v25);
                goto LABEL_28;
              }
              *(_DWORD *)__str = 0;
              v22 = *(_QWORD *)(v3 + 24);
              if (v22)
              {
                if (BOMCRC32ForBuffer(v22 + v17, __str, v14))
                  goto LABEL_23;
              }
              else
              {
                if ((*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v3 + 160) + 64))(*(_QWORD *)(*(_QWORD *)(v3 + 160) + 8), v32) == -1)
                {
                  v23 = 0;
                  goto LABEL_25;
                }
                if (BOMCRC32ForFileDesc(v32, __str, v14))
LABEL_23:
                  *(_DWORD *)__str = 0;
              }
              v23 = *(_DWORD *)__str;
LABEL_25:
              *(_DWORD *)(*(_QWORD *)(v3 + 112) + v8 + 16) = v23;
LABEL_28:
              v8 += 24;
              v9 += 5;
              if (v10 == v8)
                return 1;
            }
          }
          return 1;
        }
      }
      if (v2 < 0x1C)
        return 0;
      v28 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 != -17958194)
      {
        if (v28 == -822415874)
        {
LABEL_44:
          v29 = bswap32(*((_DWORD *)v4 + 1));
          v30 = bswap32(*((_DWORD *)v4 + 2));
LABEL_50:
          _handleMachO_common(v3, v29, v30);
          return 1;
        }
        if (v2 < 0x20)
          return 0;
        if (v28 != -17958193)
        {
          if (v28 != -805638658)
            return 0;
          goto LABEL_44;
        }
      }
      v29 = *((_DWORD *)v4 + 1);
      v30 = *((_DWORD *)v4 + 2);
      goto LABEL_50;
    }
  }
  return 1;
}

void BOMFSOArchInfoRelease(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 112);
  if (v2)
    free(v2);
  *(_QWORD *)(a1 + 112) = 0;
}

uint64_t BOMFSOArchInfoCopy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 *v9;
  __int128 v10;

  result = 1;
  if (a1 && a2)
  {
    *(_DWORD *)(a2 + 104) = *(_DWORD *)(a1 + 104);
    v5 = BOM_malloc(24 * *(int *)(a1 + 104));
    *(_QWORD *)(a2 + 112) = v5;
    if (v5)
    {
      if (*(_DWORD *)(a2 + 104))
      {
        v6 = 0;
        v7 = 0;
        do
        {
          v8 = *(_QWORD *)(a2 + 112) + v6;
          v9 = (__int128 *)(*(_QWORD *)(a1 + 112) + v6);
          v10 = *v9;
          *(_QWORD *)(v8 + 16) = *((_QWORD *)v9 + 2);
          *(_OWORD *)v8 = v10;
          ++v7;
          v6 += 24;
        }
        while (v7 < *(unsigned int *)(a2 + 104));
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMFSOArchInfoContainsArchitecture(uint64_t a1, int a2)
{
  uint64_t v2;
  int *v3;
  int v4;

  if (((unsigned __int16)B_ARCH & *(_WORD *)(a1 + 40)) == 0)
    return 0;
  if (!((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT))
    return 0;
  v2 = *(unsigned int *)(a1 + 104);
  if (!(_DWORD)v2)
    return 0;
  v3 = *(int **)(a1 + 112);
  while (1)
  {
    v4 = *v3;
    v3 += 6;
    if (v4 == a2)
      break;
    if (!--v2)
      return 0;
  }
  return 1;
}

uint64_t BOMFSOArchInfoArchCount(_DWORD *a1)
{
  if (*a1 == 1)
    return a1[26];
  else
    return 0;
}

uint64_t BOMFSOArchInfoGetArch(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2)
    return 0;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 112) + 24 * a2);
}

uint64_t BOMFSOArchInfoGetArchSubtype(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2)
    return 0;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 112) + 24 * a2 + 4);
}

uint64_t BOMFSOArchInfoGetArchSize(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2)
    return 0;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 112) + 24 * a2 + 8);
}

uint64_t BOMFSOArchInfoThinKeepingArchs(uint64_t a1, int *a2, unsigned int a3)
{
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int v14;
  char *v15;
  __int128 v16;
  uint64_t result;
  void *v18;

  if (((unsigned __int16)B_ARCH & *(_WORD *)(a1 + 40)) == 0)
    return 1;
  if ((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT != 2)
    return 0;
  v6 = (char *)BOM_malloc(24 * *(int *)(a1 + 104));
  if (!v6)
    return 1;
  v7 = v6;
  v8 = *(unsigned int *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = 0;
    do
    {
      if (a3)
      {
        v11 = *(_QWORD *)(a1 + 112) + 24 * v9;
        v12 = a3;
        v13 = a2;
        while (1)
        {
          v14 = *v13++;
          if (*(_DWORD *)v11 == v14)
            break;
          if (!--v12)
            goto LABEL_12;
        }
        v15 = &v6[24 * v10];
        v16 = *(_OWORD *)v11;
        *((_QWORD *)v15 + 2) = *(_QWORD *)(v11 + 16);
        *(_OWORD *)v15 = v16;
        ++v10;
        v8 = *(unsigned int *)(a1 + 104);
      }
LABEL_12:
      ++v9;
    }
    while (v9 < v8);
  }
  else
  {
    v10 = 0;
  }
  v18 = *(void **)(a1 + 112);
  if (v18)
    free(v18);
  result = 0;
  *(_DWORD *)(a1 + 104) = v10;
  *(_DWORD *)(a1 + 108) = 0;
  *(_QWORD *)(a1 + 112) = v7;
  if (v10 == 1)
  {
    result = 0;
    *(_QWORD *)(a1 + 64) = *((_QWORD *)v7 + 1);
    *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 4);
  }
  return result;
}

uint64_t BOMFSOArchInfoThinKeepingArchsAndSubArchs(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  char *v14;
  __int128 v15;
  uint64_t result;
  void *v17;

  if (((unsigned __int16)B_ARCH & *(_WORD *)(a1 + 40)) == 0)
    return 1;
  if ((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT != 2)
    return 0;
  v6 = (char *)BOM_malloc(24 * *(int *)(a1 + 104));
  if (!v6)
    return 1;
  v7 = v6;
  v8 = *(unsigned int *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = 0;
    do
    {
      if (a3)
      {
        v11 = *(_QWORD *)(a1 + 112) + 24 * v9;
        v12 = a3;
        v13 = (_DWORD *)(a2 + 8);
        while (*(_DWORD *)v11 != *(v13 - 2) || !*((_BYTE *)v13 - 4) && ((*v13 ^ *(_DWORD *)(v11 + 4)) & 0xFFFFFF) != 0)
        {
          v13 += 8;
          if (!--v12)
            goto LABEL_14;
        }
        v14 = &v6[24 * v10];
        v15 = *(_OWORD *)v11;
        *((_QWORD *)v14 + 2) = *(_QWORD *)(v11 + 16);
        *(_OWORD *)v14 = v15;
        ++v10;
        v8 = *(unsigned int *)(a1 + 104);
      }
LABEL_14:
      ++v9;
    }
    while (v9 < v8);
  }
  else
  {
    v10 = 0;
  }
  v17 = *(void **)(a1 + 112);
  if (v17)
    free(v17);
  result = 0;
  *(_DWORD *)(a1 + 104) = v10;
  *(_DWORD *)(a1 + 108) = 0;
  *(_QWORD *)(a1 + 112) = v7;
  if (v10 == 1)
  {
    result = 0;
    *(_QWORD *)(a1 + 64) = *((_QWORD *)v7 + 1);
    *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 4);
  }
  return result;
}

void BOMFSOArchInfoSet(uint64_t a1, unsigned int a2, uint64_t a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int16 v11;

  if (a1)
  {
    v6 = *(void **)(a1 + 112);
    if (v6)
    {
      free(v6);
      *(_DWORD *)(a1 + 104) = 0;
      *(_QWORD *)(a1 + 112) = 0;
      *(_WORD *)(a1 + 40) &= ~B_ARCH;
    }
    if (a2)
    {
      *(_DWORD *)(a1 + 104) = a2;
      v7 = BOM_malloc(24 * (int)a2);
      v8 = 0;
      *(_QWORD *)(a1 + 112) = v7;
      do
      {
        v9 = *(_QWORD *)(a1 + 112) + v8;
        v10 = *(_OWORD *)(a3 + v8);
        *(_QWORD *)(v9 + 16) = *(_QWORD *)(a3 + v8 + 16);
        *(_OWORD *)v9 = v10;
        v8 += 24;
      }
      while (24 * a2 != v8);
      if (a2 == 1)
        v11 = 1;
      else
        v11 = 2;
      *(_WORD *)(a1 + 40) |= B_ARCH | (unsigned __int16)(v11 << B_ARCHOFFT);
    }
  }
}

uint64_t _handleMachO_common(uint64_t a1, int a2, int a3)
{
  _QWORD *v6;
  uint64_t result;

  *(_WORD *)(a1 + 40) |= 1 << B_ARCHOFFT;
  *(_DWORD *)(a1 + 104) = 1;
  v6 = BOM_malloc(0x18uLL);
  *(_QWORD *)(a1 + 112) = v6;
  v6[1] = *(_QWORD *)(a1 + 64);
  *(_DWORD *)v6 = a2;
  *((_DWORD *)v6 + 1) = a3;
  result = BOMFSObjectChecksum(a1);
  *(_DWORD *)(*(_QWORD *)(a1 + 112) + 16) = result;
  return result;
}

uint64_t BOMFSObjectArchiveLength(uint64_t a1)
{
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    return -1;
  v2 = *(_WORD *)(a1 + 40);
  if (((unsigned __int16)B_STAT & v2) != 0)
  {
    v3 = BOMFSOTypeInfoArchiveLength(a1);
    if (v3 < 0)
      return -1;
    v4 = v3 + 30;
    v2 = *(_WORD *)(a1 + 40);
  }
  else
  {
    v4 = 4;
  }
  if (((unsigned __int16)B_ARCH & v2) == 0)
    goto LABEL_9;
  v5 = BOMFSOArchInfoArchiveLength(a1);
  if (v5 < 0)
    return -1;
  v4 += v5;
  v2 = *(_WORD *)(a1 + 40);
LABEL_9:
  if (((unsigned __int16)B_OPAQUEDATA & v2) != 0)
    v4 += *(_QWORD *)(a1 + 128) + 4;
  return v4;
}

uint64_t BOMFSObjectArchive(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned __int16 v5;

  result = 1;
  if (a1 && a2)
  {
    BOMStreamWriteUInt8(a1, *(_BYTE *)a2);
    BOMStreamWriteUInt8(a1, 1);
    BOMStreamWriteUInt16(a1, *(_WORD *)(a2 + 40));
    v5 = *(_WORD *)(a2 + 40);
    if (((unsigned __int16)B_STAT & v5) != 0)
    {
      BOMStreamWriteUInt16(a1, *(_WORD *)(a2 + 42));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 44));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 48));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 56));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 64));
      BOMFSOTypeInfoArchive(a1, a2);
      v5 = *(_WORD *)(a2 + 40);
    }
    if (((unsigned __int16)B_ARCH & v5) != 0)
    {
      BOMFSOArchInfoArchive(a1, a2);
      v5 = *(_WORD *)(a2 + 40);
    }
    if (((unsigned __int16)B_OPAQUEDATA & v5) != 0)
    {
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 128));
      BOMStreamWriteBuffer(a1, *(const void **)(a2 + 120), *(_QWORD *)(a2 + 128));
    }
    return 0;
  }
  return result;
}

_DWORD *BOMFSObjectUnarchive(uint64_t a1)
{
  int UInt8;
  int v3;
  void *Sys;
  _DWORD *v5;
  unsigned __int16 UInt16;
  unsigned int UInt32;
  void *v8;

  if (!a1)
    return 0;
  UInt8 = BOMStreamReadUInt8(a1);
  v3 = BOMStreamReadUInt8(a1);
  if ((UInt8 - 6) <= 0xFFFFFFFA)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "filesystem object has an invalid type: 0x%X\nCannot dearchive.\n");
    return 0;
  }
  if (v3 != 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "filesystem object has an invalid version: 0x%X\nCannot dearchive.\n");
    return 0;
  }
  Sys = (void *)BOMStreamGetSys(a1);
  v5 = BOMFSObjectNewWithSys(UInt8, Sys);
  if (v5)
  {
    UInt16 = BOMStreamReadUInt16(a1);
    *((_WORD *)v5 + 20) = UInt16;
    if (((unsigned __int16)B_STAT & UInt16) != 0)
    {
      *((_WORD *)v5 + 21) = BOMStreamReadUInt16(a1);
      v5[11] = BOMStreamReadUInt32(a1);
      v5[12] = BOMStreamReadUInt32(a1);
      *((_QWORD *)v5 + 7) = BOMStreamReadUInt32(a1);
      *((_QWORD *)v5 + 8) = BOMStreamReadUInt32(a1);
      UInt16 = *((_WORD *)v5 + 20);
      if (((unsigned __int16)B_STAT & UInt16) != 0)
      {
        if (BOMFSOTypeInfoUnarchive(a1, (uint64_t)v5))
          goto LABEL_19;
        UInt16 = *((_WORD *)v5 + 20);
      }
    }
    if (((unsigned __int16)B_ARCH & UInt16) != 0)
    {
      if (BOMFSOArchInfoUnarchive(a1, (uint64_t)v5))
        goto LABEL_19;
      UInt16 = *((_WORD *)v5 + 20);
    }
    if (((unsigned __int16)B_OPAQUEDATA & UInt16) != 0)
    {
      UInt32 = BOMStreamReadUInt32(a1);
      *((_QWORD *)v5 + 16) = UInt32;
      v8 = BOM_malloc(UInt32);
      *((_QWORD *)v5 + 15) = v8;
      if (v8)
      {
        BOMStreamReadBuffer(a1, v8, *((_QWORD *)v5 + 16));
        return v5;
      }
LABEL_19:
      BOMFSObjectFree((uint64_t)v5);
      return 0;
    }
  }
  return v5;
}

uint64_t BOMFSObjectTypeForMode(__int16 a1)
{
  unsigned int v1;

  v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 14 > 2)
    return 0;
  else
    return dword_2063CFDF8[v1 >> 12];
}

char *BOMNameForFSObjectType(int a1)
{
  int v1;

  if ((a1 - 6) >= 0xFFFFFFFB)
    v1 = a1;
  else
    v1 = 0;
  return &gTypeStrings[10 * v1];
}

_QWORD *BOMFSObjectNew(int a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = BOM_malloczero(0xA8uLL);
  v3 = v2;
  if (v2)
  {
    *(_DWORD *)v2 = a1;
    v2[20] = BomSys_default();
  }
  return v3;
}

_DWORD *BOMFSObjectNewWithSys(int a1, void *a2)
{
  _DWORD *v4;
  _DWORD *v5;

  v4 = BOM_malloczero(0xA8uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = a1;
    if (!a2)
      a2 = BomSys_default();
    *((_QWORD *)v5 + 20) = a2;
  }
  return v5;
}

_DWORD *BOMFSObjectNewFromPath(char *a1, __int16 a2)
{
  return BOMFSObjectNewFromPathWithSys(a1, a2, 0);
}

_DWORD *BOMFSObjectNewFromPathWithSys(char *a1, __int16 a2, unsigned int (**a3)(_QWORD, char *, __int128 *))
{
  unsigned int (**v3)(_QWORD, char *, __int128 *);
  _DWORD *v6;
  int v8;
  size_t v9;
  void *v10;
  char *v11;
  const char *v12;
  size_t v13;
  void *v14;
  int v15;
  unsigned int v16;
  unsigned int (*v17)(_QWORD, char *, __int128 *);
  int v18;
  void *v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;

  v3 = a3;
  if (!a3)
    v3 = (unsigned int (**)(_QWORD, char *, __int128 *))BomSys_default();
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v30 = 0u;
  if (v3[12](v3[1], a1, &v30))
    return 0;
  v8 = BOMFSObjectTypeForMode(SWORD2(v30));
  if (v8 == 5)
    return 0;
  if (!v8)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "file '%s' is an unknown file type\n", a1);
    return 0;
  }
  v6 = BOMFSObjectNewWithSys(v8, v3);
  if (!v6)
    return v6;
  v9 = strlen(a1) + 1;
  v10 = BOM_malloc(v9);
  *((_QWORD *)v6 + 9) = v10;
  if (!v10)
  {
LABEL_24:
    v20 = (void *)*((_QWORD *)v6 + 10);
    if (v20)
      free(v20);
    free(v6);
    return 0;
  }
  memmove(v10, a1, v9);
  v11 = strrchr(a1, 47);
  v12 = a1;
  if (v11)
  {
    if (v11[1])
      v12 = v11 + 1;
    else
      v12 = v11;
  }
  v13 = strlen(v12) + 1;
  v14 = BOM_malloc(v13);
  *((_QWORD *)v6 + 10) = v14;
  if (!v14)
  {
    v19 = (void *)*((_QWORD *)v6 + 9);
    if (v19)
      free(v19);
    goto LABEL_24;
  }
  memmove(v14, v12, v13);
  *((_WORD *)v6 + 20) = a2;
  v15 = a2 & 1;
  if ((a2 & 1) != 0)
  {
    *((_WORD *)v6 + 21) = WORD2(v30);
    *(_QWORD *)(v6 + 11) = v31;
    *((_QWORD *)v6 + 7) = v33;
    *((_QWORD *)v6 + 8) = v36;
  }
  if ((a2 & 0xFFF) != 0 && *v6 == 1)
  {
    v16 = v3[23](v3[1], a1, (__int128 *)4);
    v17 = v3[1];
    if (v16 == -1)
    {
      v3[25](v17, a1, (__int128 *)(WORD2(v30) & 0xFFF | 0x124u));
      v18 = ((uint64_t (*)(unsigned int (*)(_QWORD, char *, __int128 *), char *, _QWORD, _QWORD))v3[2])(v3[1], a1, 0, 0);
      v3[25](v3[1], a1, (__int128 *)(WORD2(v30) & 0xFFF));
    }
    else
    {
      v18 = ((uint64_t (*)(unsigned int (*)(_QWORD, char *, __int128 *), char *, _QWORD, _QWORD))v3[2])(v17, a1, 0, 0);
    }
    if (v18 == -1)
    {
      BOMFSObjectFree((uint64_t)v6);
      return 0;
    }
    v6[4] = v18;
    *((_QWORD *)v6 + 3) = 0;
    *((_QWORD *)v6 + 4) = 0;
    a2 = *((_WORD *)v6 + 20);
    v15 = a2 & 1;
  }
  if (v15)
  {
    v27 = v36;
    v28 = v37;
    v29 = v38;
    v23 = v32;
    v24 = v33;
    v25 = v34;
    v26 = v35;
    v21 = v30;
    v22 = v31;
    BOMFSOTypeInfoInitialize((uint64_t)v6, (uint64_t)&v21);
    a2 = *((_WORD *)v6 + 20);
  }
  if ((a2 & 4) != 0)
  {
    v27 = v36;
    v28 = v37;
    v29 = v38;
    v23 = v32;
    v24 = v33;
    v25 = v34;
    v26 = v35;
    v21 = v30;
    v22 = v31;
    BOMFSOArchInfoInitialize();
  }
  if (*v6 == 1 && (v6[10] & 0xFFF) != 0)
  {
    ((void (*)(unsigned int (*)(_QWORD, char *, __int128 *), _QWORD))v3[4])(v3[1], v6[4]);
    *((_QWORD *)v6 + 3) = 0;
    *((_QWORD *)v6 + 4) = 0;
  }
  return v6;
}

void BOMFSObjectFree(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  if (a1)
  {
    v2 = *(void **)(a1 + 72);
    if (v2)
      free(v2);
    v3 = *(void **)(a1 + 80);
    if (v3)
      free(v3);
    BOMFSOTypeInfoRelease(a1);
    BOMFSOArchInfoRelease(a1);
    v4 = *(void **)(a1 + 120);
    if (v4)
      free(v4);
    v5 = *(void **)(a1 + 144);
    if (v5)
    {
      if (*(_BYTE *)(a1 + 152))
        free(v5);
    }
    free((void *)a1);
  }
}

uint64_t BOMFSObjectENewFromPath(char *a1, __int128 *a2, int a3, __int16 a4)
{
  return BOMFSObjectENewFromPathWithSys(a1, a2, a3, a4, 0);
}

uint64_t BOMFSObjectENewFromPathWithSys(char *a1, __int128 *a2, int a3, __int16 a4, void *a5)
{
  int v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  size_t v14;
  void *v15;
  char *v16;
  const char *v17;
  size_t v18;
  void *v19;
  int v20;
  int v22;
  uint64_t v23;
  int v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;

  v10 = BOMFSObjectTypeForMode(*((_WORD *)a2 + 2));
  if (!v10)
    return 0;
  v11 = v10;
  if (!a5)
    a5 = BomSys_default();
  v12 = BOMFSObjectNewWithSys(v11, a5);
  v13 = (uint64_t)v12;
  if (v12)
  {
    v12[4] = -1;
    v14 = strlen(a1) + 1;
    v15 = BOM_malloc(v14);
    *(_QWORD *)(v13 + 72) = v15;
    if (!v15)
      goto LABEL_18;
    memmove(v15, a1, v14);
    v16 = strrchr(a1, 47);
    v17 = a1;
    if (v16)
    {
      if (v16[1])
        v17 = v16 + 1;
      else
        v17 = v16;
    }
    v18 = strlen(v17) + 1;
    v19 = BOM_malloc(v18);
    *(_QWORD *)(v13 + 80) = v19;
    if (v19)
    {
      memmove(v19, v17, v18);
      *(_WORD *)(v13 + 40) = a4;
      v20 = a4 & 1;
      if ((a4 & 1) != 0)
      {
        *(_WORD *)(v13 + 42) = *((_WORD *)a2 + 2);
        *(_QWORD *)(v13 + 44) = *((_QWORD *)a2 + 2);
        *(_QWORD *)(v13 + 56) = *((_QWORD *)a2 + 6);
        *(_QWORD *)(v13 + 64) = *((_QWORD *)a2 + 12);
      }
      if ((a4 & 0xFFF) == 0 || *(_DWORD *)v13 != 1)
        goto LABEL_29;
      if (a3 != -1)
      {
        *(_DWORD *)(v13 + 16) = a3;
LABEL_28:
        *(_QWORD *)(v13 + 24) = 0;
        *(_QWORD *)(v13 + 32) = 0;
LABEL_29:
        if (v20)
        {
          v25 = a2[7];
          v39 = a2[6];
          v40 = v25;
          v41 = a2[8];
          v26 = a2[3];
          v35 = a2[2];
          v36 = v26;
          v27 = a2[5];
          v37 = a2[4];
          v38 = v27;
          v28 = a2[1];
          v33 = *a2;
          v34 = v28;
          BOMFSOTypeInfoInitialize(v13, (uint64_t)&v33);
          a4 = *(_WORD *)(v13 + 40);
        }
        if ((a4 & 4) != 0)
        {
          v29 = a2[7];
          v39 = a2[6];
          v40 = v29;
          v41 = a2[8];
          v30 = a2[3];
          v35 = a2[2];
          v36 = v30;
          v31 = a2[5];
          v37 = a2[4];
          v38 = v31;
          v32 = a2[1];
          v33 = *a2;
          v34 = v32;
          BOMFSOArchInfoInitialize();
        }
        if (*(_DWORD *)v13 == 1 && (*(_WORD *)(v13 + 40) & 0xFFF) != 0)
        {
          *(_QWORD *)(v13 + 24) = 0;
          *(_QWORD *)(v13 + 32) = 0;
          if (a3 == -1)
          {
            (*((void (**)(_QWORD, _QWORD))a5 + 4))(*((_QWORD *)a5 + 1), *(unsigned int *)(v13 + 16));
            *(_DWORD *)(v13 + 16) = -1;
          }
        }
        return v13;
      }
      v22 = (*((uint64_t (**)(_QWORD, char *, uint64_t))a5 + 23))(*((_QWORD *)a5 + 1), a1, 4);
      v23 = *((_QWORD *)a5 + 1);
      if (v22 == -1)
      {
        (*((void (**)(uint64_t, char *, _QWORD))a5 + 25))(v23, a1, *((_WORD *)a2 + 2) & 0xFFF | 0x124u);
        *(_DWORD *)(v13 + 16) = (*((uint64_t (**)(_QWORD, char *, _QWORD, _QWORD))a5 + 2))(*((_QWORD *)a5 + 1), a1, 0, 0);
        (*((void (**)(_QWORD, char *, _QWORD))a5 + 25))(*((_QWORD *)a5 + 1), a1, *((_WORD *)a2 + 2) & 0xFFF);
        v24 = *(_DWORD *)(v13 + 16);
      }
      else
      {
        v24 = (*((uint64_t (**)(uint64_t, char *, _QWORD, _QWORD))a5 + 2))(v23, a1, 0, 0);
        *(_DWORD *)(v13 + 16) = v24;
      }
      if (v24 != -1)
      {
        a4 = *(_WORD *)(v13 + 40);
        v20 = a4 & 1;
        goto LABEL_28;
      }
    }
    else
    {
LABEL_18:
      if (a3 == -1 && *(_DWORD *)(v13 + 16) != -1)
        (*((void (**)(_QWORD))a5 + 4))(*((_QWORD *)a5 + 1));
    }
    BOMFSObjectFree(v13);
    return 0;
  }
  return v13;
}

_QWORD *BOMFSObjectCopy(uint64_t a1)
{
  _DWORD *v2;
  _QWORD *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  const char *v12;
  size_t v13;
  char *v14;
  const char *v15;
  size_t v16;
  char *v17;
  void *v18;
  const char *v19;
  size_t v20;
  char *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  v2 = BOMFSObjectNewWithSys(*(_DWORD *)a1, *(void **)(a1 + 160));
  v3 = v2;
  if (!v2)
    return v3;
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)a1;
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v2 + 2) = v4;
  *(_OWORD *)v2 = v5;
  v6 = *(_OWORD *)(a1 + 48);
  v7 = *(_OWORD *)(a1 + 64);
  v8 = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v2 + 6) = v8;
  *((_OWORD *)v2 + 3) = v6;
  *((_OWORD *)v2 + 4) = v7;
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *(_OWORD *)(a1 + 128);
  v11 = *(_OWORD *)(a1 + 144);
  *((_QWORD *)v2 + 20) = *(_QWORD *)(a1 + 160);
  *((_OWORD *)v2 + 8) = v10;
  *((_OWORD *)v2 + 9) = v11;
  *((_OWORD *)v2 + 7) = v9;
  v2[4] = 0;
  *((_QWORD *)v2 + 3) = 0;
  *((_QWORD *)v2 + 4) = 0;
  v12 = *(const char **)(a1 + 72);
  if (v12)
  {
    v13 = strlen(v12) + 1;
    v14 = (char *)BOM_malloc(v13);
    v3[9] = v14;
    if (!v14)
      goto LABEL_16;
    strlcpy(v14, *(const char **)(a1 + 72), v13);
  }
  v15 = *(const char **)(a1 + 80);
  if (v15)
  {
    v16 = strlen(v15) + 1;
    v17 = (char *)BOM_malloc(v16);
    v3[10] = v17;
    if (!v17)
      goto LABEL_16;
    strlcpy(v17, *(const char **)(a1 + 80), v16);
  }
  if (BOMFSOArchInfoCopy(a1, (uint64_t)v3) || BOMFSOTypeInfoCopy(a1, (uint64_t)v3))
    return 0;
  if (*(_QWORD *)(a1 + 120))
  {
    v18 = BOM_malloc(*(_QWORD *)(a1 + 128));
    v3[15] = v18;
    if (v18)
    {
      memmove(v18, *(const void **)(a1 + 120), *(_QWORD *)(a1 + 128));
      goto LABEL_13;
    }
LABEL_16:
    v22 = (void *)v3[9];
    if (v22)
      free(v22);
    v23 = (void *)v3[10];
    if (v23)
      free(v23);
    v24 = (void *)v3[15];
    if (v24)
      free(v24);
    v25 = (void *)v3[18];
    if (v25)
      free(v25);
    free(v3);
    return 0;
  }
LABEL_13:
  v19 = *(const char **)(a1 + 144);
  if (v19)
  {
    v20 = strlen(v19) + 1;
    v21 = (char *)BOM_malloc(v20);
    v3[18] = v21;
    if (v21)
    {
      strlcpy(v21, *(const char **)(a1 + 144), v20);
      *(_BYTE *)(a1 + 152) = 1;
      return v3;
    }
    goto LABEL_16;
  }
  return v3;
}

_DWORD *BOMFSObjectNewFromPathDeferred(uint64_t a1, char *a2, __int16 a3, const char *a4, int a5)
{
  return BOMFSObjectNewFromPathDeferredWithSys(a1, a2, a3, a4, a5, 0);
}

_DWORD *BOMFSObjectNewFromPathDeferredWithSys(uint64_t a1, char *a2, __int16 a3, const char *a4, int a5, void *a6)
{
  int v12;
  _DWORD *v13;
  size_t v14;
  void *v15;
  char *v16;
  const char *v17;
  size_t v18;
  void *v19;
  size_t v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;

  v12 = BOMFSObjectTypeForMode(*(_WORD *)(a1 + 4));
  v13 = BOMFSObjectNewWithSys(v12, a6);
  if (v13)
  {
    v14 = strlen(a2) + 1;
    v15 = BOM_malloc(v14);
    *((_QWORD *)v13 + 9) = v15;
    if (v15)
    {
      memmove(v15, a2, v14);
      v16 = strrchr(a2, 47);
      v17 = a2;
      if (v16)
      {
        if (v16[1])
          v17 = v16 + 1;
        else
          v17 = v16;
      }
      v18 = strlen(v17) + 1;
      v19 = BOM_malloc(v18);
      *((_QWORD *)v13 + 10) = v19;
      if (v19)
      {
        memmove(v19, v17, v18);
        *((_WORD *)v13 + 20) = a3;
        if (a5)
        {
          v20 = strlen(a4) + 1;
          v21 = BOM_malloc(v20);
          *((_QWORD *)v13 + 18) = v21;
          memmove(v21, a4, v20);
          *((_BYTE *)v13 + 152) = 1;
          if ((a3 & 1) == 0)
          {
LABEL_10:
            *((_WORD *)v13 + 68) = 0;
            return v13;
          }
        }
        else
        {
          *((_QWORD *)v13 + 18) = a4;
          if ((a3 & 1) == 0)
            goto LABEL_10;
        }
        *((_WORD *)v13 + 21) = *(_WORD *)(a1 + 4);
        *(_QWORD *)(v13 + 11) = *(_QWORD *)(a1 + 16);
        v24 = *(_QWORD *)(a1 + 96);
        *((_QWORD *)v13 + 7) = *(_QWORD *)(a1 + 48);
        *((_QWORD *)v13 + 8) = v24;
        BOMFSOTypeInfoInitializeDeferred((uint64_t)v13, a1, (uint64_t)a2, 1u);
        *((_WORD *)v13 + 68) = 1;
        return v13;
      }
      v22 = (void *)*((_QWORD *)v13 + 9);
      if (v22)
        free(v22);
    }
    v23 = (void *)*((_QWORD *)v13 + 10);
    if (v23)
      free(v23);
    free(v13);
    return 0;
  }
  return v13;
}

_DWORD *BOMFSObjectNewFromPathString(const __CFString *a1, __int16 a2)
{
  return BOMFSObjectNewFromPathStringWithSys(a1, a2, 0);
}

_DWORD *BOMFSObjectNewFromPathStringWithSys(const __CFString *a1, __int16 a2, unsigned int (**a3)(_QWORD, char *, __int128 *))
{
  char *CStringPtr;
  char *v7;
  int CString;
  _DWORD *v9;
  int v10;

  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    v7 = 0;
LABEL_5:
    v9 = BOMFSObjectNewFromPathWithSys(CStringPtr, a2, a3);
    goto LABEL_6;
  }
  v7 = (char *)BOM_malloc(0x2800uLL);
  CString = CFStringGetCString(a1, v7, 10240, 0x8000100u);
  v9 = 0;
  if (v7)
  {
    v10 = CString;
    CStringPtr = v7;
    if (v10)
      goto LABEL_5;
  }
LABEL_6:
  if (v7)
    free(v7);
  return v9;
}

uint64_t BOMFSObjectType(unsigned int *a1)
{
  return *a1;
}

uint64_t BOMFSObjectPathName(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 72);
  return result;
}

uint64_t BOMFSObjectShortName(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 80);
  return result;
}

CFStringRef BOMFSObjectPathNameString(CFStringRef result)
{
  if (result)
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], (const char *)result[2].info, 0x8000100u);
  return result;
}

CFStringRef BOMFSObjectShortNameString(CFStringRef result)
{
  if (result)
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], result[2].data, 0x8000100u);
  return result;
}

uint64_t BOMFSObjectMode(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0)
        _loadStatInfo(result);
    }
    return *(unsigned __int16 *)(v1 + 42);
  }
  return result;
}

uint64_t _loadStatInfo(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  char __str[1025];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if ((*(_WORD *)(a1 + 136) & 1) != 0)
    return 0;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  v4 = 0u;
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(a1 + 144), *(const char **)(a1 + 72));
  if ((*(unsigned int (**)(_QWORD, char *, __int128 *))(*(_QWORD *)(a1 + 160) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8), __str, &v4))
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "stat error for '%s'\n", __str);
    return 1;
  }
  else
  {
    *(_WORD *)(a1 + 42) = WORD2(v4);
    *(_QWORD *)(a1 + 44) = v5;
    v3 = v10;
    *(_QWORD *)(a1 + 56) = v7;
    *(_QWORD *)(a1 + 64) = v3;
    BOMFSOTypeInfoInitializeDeferred(a1, (uint64_t)&v4, (uint64_t)__str, 1u);
    result = 0;
    *(_WORD *)(a1 + 136) |= 1u;
  }
  return result;
}

uint64_t BOMFSObjectUserID(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0)
        _loadStatInfo(result);
    }
    return *(unsigned int *)(v1 + 44);
  }
  return result;
}

uint64_t BOMFSObjectGroupID(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0)
        _loadStatInfo(result);
    }
    return *(unsigned int *)(v1 + 48);
  }
  return result;
}

uint64_t BOMFSObjectModTime(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0)
        _loadStatInfo(result);
    }
    return *(_QWORD *)(v1 + 56);
  }
  return result;
}

uint64_t BOMFSObjectSize(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0)
        _loadStatInfo(result);
    }
    return *(_QWORD *)(v1 + 64);
  }
  return result;
}

uint64_t BOMFSObjectPathID(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 4);
  return result;
}

uint64_t BOMFSObjectSetPathID(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 4) = a2;
  return result;
}

uint64_t BOMFSObjectParentPathID(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 8);
  return result;
}

uint64_t BOMFSObjectSetParentPathID(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 8) = a2;
  return result;
}

void BOMFSObjectSetPathName(uint64_t a1, char *__s, int a3)
{
  void *v6;
  size_t v7;
  void *v8;

  if (a1)
  {
    v6 = *(void **)(a1 + 72);
    if (v6)
      free(v6);
    if (__s && a3)
    {
      v7 = strlen(__s) + 1;
      v8 = BOM_malloc(v7);
      *(_QWORD *)(a1 + 72) = v8;
      memmove(v8, __s, v7);
    }
    else
    {
      *(_QWORD *)(a1 + 72) = __s;
    }
  }
}

void BOMFSObjectSetShortName(uint64_t a1, char *__s, int a3)
{
  void *v6;
  size_t v7;
  void *v8;

  if (a1)
  {
    v6 = *(void **)(a1 + 80);
    if (v6)
      free(v6);
    if (__s && a3)
    {
      v7 = strlen(__s) + 1;
      v8 = BOM_malloc(v7);
      *(_QWORD *)(a1 + 80) = v8;
      memmove(v8, __s, v7);
    }
    else
    {
      *(_QWORD *)(a1 + 80) = __s;
    }
  }
}

uint64_t BOMFSObjectSetFlags(uint64_t result, __int16 a2)
{
  if (result)
    *(_WORD *)(result + 40) = a2;
  return result;
}

uint64_t BOMFSObjectSetMode(uint64_t result, __int16 a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_WORD *)(result + 42) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetUserID(uint64_t result, int a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_DWORD *)(result + 44) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetGroupID(uint64_t result, int a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_DWORD *)(result + 48) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetModTime(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_QWORD *)(result + 56) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetSize(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_QWORD *)(result + 64) = a2;
  }
  return result;
}

uint64_t BOMFSObjectVisitOrder(uint64_t a1)
{
  return *(unsigned int *)(a1 + 156);
}

uint64_t BOMFSObjectOpaqueData(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 120);
  return result;
}

uint64_t BOMFSObjectOpaqueDataSize(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 128);
  return result;
}

uint64_t BOMFSObjectSetOpaqueData(uint64_t a1, const void *a2, size_t a3, int a4)
{
  void *v8;
  _QWORD *v9;
  __int16 v10;
  void *v11;
  uint64_t result;

  if (!a1)
    return 1;
  v9 = (_QWORD *)(a1 + 120);
  v8 = *(void **)(a1 + 120);
  if (v8)
    free(v8);
  v10 = *(_WORD *)(a1 + 40);
  if (a2 && a3)
  {
    *(_WORD *)(a1 + 40) = v10 | 0x10;
    *(_QWORD *)(a1 + 128) = a3;
    if (a4)
    {
      v11 = BOM_malloc(a3);
      *v9 = v11;
      if (v11)
      {
        memmove(v11, a2, a3);
        return 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      result = 0;
      *v9 = a2;
    }
  }
  else
  {
    result = 0;
    *(_WORD *)(a1 + 40) = v10 & 0xFFEF;
    *v9 = 0;
    v9[1] = 0;
  }
  return result;
}

uint64_t BOMFSObjectBlockID(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 12);
  return result;
}

uint64_t BOMFSObjectSetBlockID(uint64_t result, int a2)
{
  if (result)
  {
    if (a2)
      *(_DWORD *)(result + 12) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetVisitOrder(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 156) = a2;
  return result;
}

uint64_t BOMFSObjectChecksum(uint64_t result)
{
  _DWORD *v1;

  if (result)
  {
    v1 = (_DWORD *)result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 2) == 0)
        _loadCksumInfo(result);
    }
    return BOMFSOTypeInfoChecksum(v1);
  }
  return result;
}

uint64_t _loadCksumInfo(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char __str[1025];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if ((*(_WORD *)(result + 136) & 2) != 0)
    return result;
  v1 = result;
  result = _loadStatInfo(result);
  if ((_DWORD)result)
    return result;
  if (*(_DWORD *)v1 != 1 || (*(_WORD *)(v1 + 40) & 2) == 0)
    goto LABEL_10;
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v1 + 144), *(const char **)(v1 + 72));
  v2 = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(v1 + 160) + 184))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), __str, 4);
  v3 = *(_QWORD *)(v1 + 160);
  v4 = *(_QWORD *)(v3 + 8);
  if (v2 == -1)
  {
    (*(void (**)(uint64_t, char *, _QWORD))(v3 + 200))(v4, __str, *(_WORD *)(v1 + 42) & 0xFFF | 0x124u);
    v5 = (*(uint64_t (**)(_QWORD, char *, _QWORD, _QWORD))(*(_QWORD *)(v1 + 160) + 16))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), __str, 0, 0);
    result = (*(uint64_t (**)(_QWORD, char *, _QWORD))(*(_QWORD *)(v1 + 160) + 200))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), __str, *(_WORD *)(v1 + 42) & 0xFFF);
  }
  else
  {
    result = (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD))(v3 + 16))(v4, __str, 0, 0);
    v5 = result;
  }
  if (v5 != -1)
  {
    *(_DWORD *)(v1 + 16) = v5;
    *(_QWORD *)(v1 + 24) = 0;
    *(_QWORD *)(v1 + 32) = 0;
LABEL_10:
    result = BOMFSOTypeInfoInitializeDeferred(v1, 0, (uint64_t)__str, 2u);
    *(_WORD *)(v1 + 136) |= 2u;
    if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 2) != 0)
    {
      result = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v1 + 160) + 32))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), *(unsigned int *)(v1 + 16));
      *(_DWORD *)(v1 + 16) = 0;
      *(_QWORD *)(v1 + 24) = 0;
      *(_QWORD *)(v1 + 32) = 0;
    }
  }
  return result;
}

uint64_t BOMFSObjectSymlinkTarget(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0)
        _loadStatInfo(result);
    }
    return BOMFSOTypeInfoSymlinkTarget(v1);
  }
  return result;
}

CFStringRef BOMFSObjectSymlinkTargetString(CFStringRef result)
{
  uint64_t v1;

  if (result)
  {
    v1 = (uint64_t)result;
    if (result[4].data)
    {
      if ((result[4].info & 1) == 0)
        _loadStatInfo((uint64_t)result);
    }
    return BOMFSOTypeInfoSymlinkTargetString(v1);
  }
  return result;
}

_DWORD *BOMFSObjectSetSymlinkTarget(_DWORD *result, char *__s, int a3)
{
  if (result)
  {
    *((_WORD *)result + 20) |= 1u;
    return BOMFSOTypeInfoSetSymlinkTarget(result, __s, a3);
  }
  return result;
}

uint64_t BOMFSObjectDeviceID(uint64_t a1)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)(a1 + 144))
  {
    if ((*(_WORD *)(a1 + 136) & 1) == 0)
      _loadStatInfo(a1);
  }
  return BOMFSOTypeInfoDeviceID((_DWORD *)a1);
}

_DWORD *BOMFSObjectSetChecksum(_DWORD *result, int a2)
{
  if (result)
    return BOMFSOTypeInfoSetChecksum(result, a2);
  return result;
}

_DWORD *BOMFSObjectSetDeviceID(_DWORD *result, int a2)
{
  if (result)
  {
    *((_WORD *)result + 20) |= 1u;
    return BOMFSOTypeInfoSetDeviceID(result, a2);
  }
  return result;
}

const char *BOMFSObjectSummary(const char *result, int a2, int a3, int a4)
{
  uint64_t v7;

  if (result)
  {
    v7 = (uint64_t)result;
    if (*((_QWORD *)result + 18))
    {
      _loadCksumInfo((uint64_t)result);
      _loadArchInfo(v7);
    }
    return BOMFSOTypeInfoSummary(v7, a2, a3, a4);
  }
  return result;
}

uint64_t _loadArchInfo(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char __str[1025];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if ((*(_WORD *)(result + 136) & 4) != 0)
    return result;
  v1 = result;
  result = _loadStatInfo(result);
  if ((_DWORD)result)
    return result;
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v1 + 144), *(const char **)(v1 + 72));
  if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 4) != 0)
  {
    v2 = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(v1 + 160) + 184))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), __str, 4);
    v3 = *(_QWORD *)(v1 + 160);
    v4 = *(_QWORD *)(v3 + 8);
    if (v2 == -1)
    {
      (*(void (**)(uint64_t, char *, _QWORD))(v3 + 200))(v4, __str, *(_WORD *)(v1 + 42) & 0xFFF | 0x124u);
      v5 = (*(uint64_t (**)(_QWORD, char *, _QWORD, _QWORD))(*(_QWORD *)(v1 + 160) + 16))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), __str, 0, 0);
      result = (*(uint64_t (**)(_QWORD, char *, _QWORD))(*(_QWORD *)(v1 + 160) + 200))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), __str, *(_WORD *)(v1 + 42) & 0xFFF);
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD))(v3 + 16))(v4, __str, 0, 0);
      v5 = result;
    }
    if (v5 == -1)
      return result;
    *(_DWORD *)(v1 + 16) = v5;
    *(_QWORD *)(v1 + 24) = 0;
    *(_QWORD *)(v1 + 32) = 0;
  }
  result = BOMFSOArchInfoInitialize();
  if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 4) != 0)
  {
    result = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v1 + 160) + 32))(*(_QWORD *)(*(_QWORD *)(v1 + 160) + 8), *(unsigned int *)(v1 + 16));
    *(_DWORD *)(v1 + 16) = 0;
    *(_QWORD *)(v1 + 24) = 0;
    *(_QWORD *)(v1 + 32) = 0;
  }
  *(_WORD *)(v1 + 136) |= 4u;
  return result;
}

uint64_t BOMFSObjectSummaryWithFormat(uint64_t a1, char *a2, int a3)
{
  if (!a1 || !a2)
    return 0;
  if (*(_QWORD *)(a1 + 144))
  {
    _loadCksumInfo(a1);
    _loadArchInfo(a1);
  }
  return BOMFSOTypeInfoSummaryWithFormat(a1, a2, a3);
}

const char *BOMFSObjectParseSummary(const char *result)
{
  const char *v1;
  void *v2;

  if (result)
  {
    v1 = result;
    v2 = BomSys_default();
    return (const char *)BOMFSOTypeInfoParseSummaryWithSys(v1, v2);
  }
  return result;
}

const char *BOMFSObjectParseSummaryWithSys(const char *result, void *a2)
{
  const char *v2;

  if (result)
  {
    v2 = result;
    if (!a2)
      a2 = BomSys_default();
    return (const char *)BOMFSOTypeInfoParseSummaryWithSys(v2, a2);
  }
  return result;
}

uint64_t BOMFSObjectIsBinaryObject(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 144) && (*(_WORD *)(result + 136) & 4) == 0)
      _loadArchInfo(result);
    if (*(_DWORD *)v1 == 1)
    {
      v2 = *(unsigned __int16 *)(v1 + 40);
      if (v2 > 0xFFF)
        return (v2 >> 2) & 1;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BOMFSObjectContainsArchitecture(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 144) && (*(_WORD *)(a1 + 136) & 4) == 0)
    _loadArchInfo(a1);
  return BOMFSOArchInfoContainsArchitecture(a1, a2);
}

uint64_t BOMFSObjectArchCount(uint64_t result)
{
  _DWORD *v1;

  if (result)
  {
    v1 = (_DWORD *)result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0)
        _loadArchInfo(result);
    }
    return BOMFSOArchInfoArchCount(v1);
  }
  return result;
}

uint64_t BOMFSObjectGetArch(uint64_t result, unsigned int a2)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0)
        _loadArchInfo(result);
    }
    return BOMFSOArchInfoGetArch(v3, a2);
  }
  return result;
}

uint64_t BOMFSObjectGetArchSubtype(uint64_t result, unsigned int a2)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0)
        _loadArchInfo(result);
    }
    return BOMFSOArchInfoGetArchSubtype(v3, a2);
  }
  return result;
}

uint64_t BOMFSObjectGetArchSize(uint64_t result, unsigned int a2)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    if (*(_QWORD *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0)
        _loadArchInfo(result);
    }
    return BOMFSOArchInfoGetArchSize(v3, a2);
  }
  return result;
}

uint64_t BOMFSObjectThinKeepingArchs(uint64_t a1, int *a2, unsigned int a3)
{
  uint64_t result;

  result = 1;
  if (a1 && a2)
  {
    if (a3)
    {
      if (*(_QWORD *)(a1 + 144))
      {
        if ((*(_WORD *)(a1 + 136) & 4) == 0)
          _loadArchInfo(a1);
      }
      return BOMFSOArchInfoThinKeepingArchs(a1, a2, a3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BOMFSObjectThinKeepingArchsAndSubArchs(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = 1;
  if (a1 && a2)
  {
    if (a3)
    {
      if (*(_QWORD *)(a1 + 144))
      {
        if ((*(_WORD *)(a1 + 136) & 4) == 0)
          _loadArchInfo(a1);
      }
      return BOMFSOArchInfoThinKeepingArchsAndSubArchs(a1, a2, a3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void BOMFSObjectSetArchInfo(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a1)
    BOMFSOArchInfoSet(a1, a2, a3);
}

unsigned __int8 *BOMFSObjectTypeFromRawData(unsigned __int8 *result)
{
  if (result)
    return (unsigned __int8 *)*result;
  return result;
}

void capture_error(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _DWORD *v14;
  _DWORD *v15;
  char *v16;
  FILE *v17;
  int *v18;
  char *v19;
  FILE *v20;
  int *v21;
  char *v22;
  char *v23;
  char *v24;

  v23 = 0;
  if (a1 && !*a1)
  {
    v24 = 0;
    v14 = malloc_type_calloc(1uLL, 0x30uLL, 0x105004057D267B0uLL);
    if (v14)
    {
      v15 = v14;
      v24 = &a9;
      if (vasprintf(&v23, a5, &a9) < 0)
      {
        v20 = (FILE *)*MEMORY[0x24BDAC8D8];
        v21 = __error();
        v22 = strerror(*v21);
        fprintf(v20, "Could not create error message: %s\n", v22);
      }
      else
      {
        v16 = v23;
        if (v23)
        {
          *(_QWORD *)v15 = a2;
          v15[2] = a3;
          *((_QWORD *)v15 + 2) = "Aug  3 2024";
          *((_QWORD *)v15 + 3) = a4;
          *((_QWORD *)v15 + 4) = v16;
          v15[10] = *__error();
          *a1 = v15;
          return;
        }
        fwrite("Error message is NULL\n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      }
      free(v15);
    }
    else
    {
      v17 = (FILE *)*MEMORY[0x24BDAC8D8];
      v18 = __error();
      v19 = strerror(*v18);
      fprintf(v17, "Could not allocate error state: %s\n", v19);
    }
  }
}

void release_error(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    v2 = (void *)a1[4];
    if (v2)
      free(v2);
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }
}

char *BOMCopierSourceEntryTypeString(unsigned int a1)
{
  if (a1 > 0x13)
    return 0;
  else
    return off_24BF06E18[a1];
}

_DWORD *BOMCopierSourceEntryNew(int a1, _QWORD *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  int v6;
  __darwin_time_t tv_sec;
  uint64_t v8;
  int v9;
  int *v10;
  char *v11;
  timeval v13;

  v4 = malloc_type_calloc(1uLL, 0x150uLL, 0x1030040944BAE5BuLL);
  v5 = v4;
  if (v4)
  {
    v4[1] = a1;
    if (once != -1)
      dispatch_once(&once, &__block_literal_global);
    v6 = global_groupID;
    v5[21] = global_userID;
    v5[22] = v6;
    *((_WORD *)v5 + 46) = -32348;
    v13.tv_sec = 0;
    *(_QWORD *)&v13.tv_usec = 0;
    gettimeofday(&v13, 0);
    tv_sec = v13.tv_sec;
    v8 = 1000 * v13.tv_usec;
    *((_QWORD *)v5 + 13) = v13.tv_sec;
    *((_QWORD *)v5 + 14) = v8;
    *((_QWORD *)v5 + 15) = tv_sec;
    *((_QWORD *)v5 + 16) = v8;
    *((_QWORD *)v5 + 17) = tv_sec;
    *((_QWORD *)v5 + 18) = v8;
    v5[81] = -1;
  }
  else
  {
    v9 = *__error();
    v10 = __error();
    v11 = strerror(*v10);
    BOMCopierErrorCapture(a2, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 514, (uint64_t)"BOMCopierSourceEntryNew", "Could not allocate %ld bytes for BOMCopierSourceEntry: %s", 336, v11);
  }
  return v5;
}

uint64_t BOMCopierSourceEntryNewFromPath(char *a1, char a2, _QWORD *a3)
{
  int v6;
  int *v7;
  uint64_t v8;
  int v10;
  _DWORD *v11;
  char *v12;
  const char *v13;
  char *v14;
  ssize_t v15;
  char *v16;
  int v17;
  int *v18;
  int v19;
  int *v20;
  timespec st_mtimespec;
  int v22;
  int *v23;
  stat v24;
  char __s1[1024];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 557, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Invalid path");
    return 0;
  }
  memset(&v24, 0, sizeof(v24));
  if (lstat(a1, &v24))
  {
    v6 = *__error();
    v7 = __error();
    strerror(*v7);
    BOMCopierErrorCapture(a3, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 572, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not stat %s: %s");
    return 0;
  }
  v10 = mode_to_source_entry_type(v24.st_mode);
  v11 = BOMCopierSourceEntryNew(v10, a3);
  v8 = (uint64_t)v11;
  if (!v11)
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 581, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not create BOMCopierSourceEntry for type %d", v10);
    return v8;
  }
  *v11 = 1;
  v12 = resolve_path(a1, v10 == 9, a3);
  *(_QWORD *)(v8 + 16) = v12;
  if (!v12)
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 593, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not resolve %s");
    goto LABEL_29;
  }
  v13 = v12;
  v14 = strdup(a1);
  *(_QWORD *)(v8 + 24) = v14;
  if (!v14)
  {
    v19 = *__error();
    v20 = __error();
    strerror(*v20);
    BOMCopierErrorCapture(a3, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 602, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not duplicate path %s: %s");
    goto LABEL_29;
  }
  if (v10 == 9)
  {
    bzero(__s1, 0x400uLL);
    v15 = readlink(v13, __s1, 0x400uLL);
    if (v15 == -1)
    {
      if (*__error() != 13)
      {
        v22 = *__error();
        v23 = __error();
        strerror(*v23);
        BOMCopierErrorCapture(a3, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 620, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not readlink %s: %s\n");
        goto LABEL_29;
      }
    }
    else if (v15 >= 1)
    {
      __s1[v15] = 0;
      v16 = strdup(__s1);
      *(_QWORD *)(v8 + 48) = v16;
      if (!v16)
      {
        v17 = *__error();
        v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture(a3, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 633, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not duplicate %s: %s\n");
LABEL_29:
        BOMCopierSourceEntryFree((unsigned int *)v8);
        return 0;
      }
    }
  }
  *(_QWORD *)(v8 + 84) = *(_QWORD *)&v24.st_uid;
  st_mtimespec = v24.st_mtimespec;
  *(timespec *)(v8 + 104) = v24.st_atimespec;
  *(_DWORD *)(v8 + 64) = v24.st_dev;
  *(_QWORD *)(v8 + 72) = v24.st_ino;
  *(_WORD *)(v8 + 80) = v24.st_nlink;
  *(_WORD *)(v8 + 92) = v24.st_mode;
  *(_QWORD *)(v8 + 96) = v24.st_size;
  *(timespec *)(v8 + 120) = st_mtimespec;
  *(timespec *)(v8 + 136) = v24.st_ctimespec;
  *(_DWORD *)(v8 + 152) = v24.st_flags;
  if ((a2 & 2) != 0 && v10 == 8 && parse_regular_file(v8, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 672, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not parse the regular file");
    goto LABEL_29;
  }
  if (capture_extended_attributes(v8, a2, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 686, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not capture extended attributes");
    goto LABEL_29;
  }
  if ((a2 & 0x20) != 0 && capture_acl(v8, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 700, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not capture access control list");
    goto LABEL_29;
  }
  return v8;
}

uint64_t mode_to_source_entry_type(__int16 a1)
{
  unsigned int v1;

  v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6)
    return 0;
  else
    return dword_2063CFE50[v1 >> 12];
}

char *resolve_path(char *a1, char a2, _QWORD *a3)
{
  int v5;
  int *v6;
  char *result;
  int v8;
  int *v9;
  char *v10;
  char *v11;
  int v12;
  int *v13;
  char *v14;
  int v15;
  int *v16;
  int v17;
  int v18;
  int *v19;
  char *v20;
  char v21[255];
  char v22[1024];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if ((a2 & 1) == 0)
  {
    result = realpath_DARWIN_EXTSN(a1, 0);
    if (result)
      return result;
    v8 = *__error();
    v9 = __error();
    strerror(*v9);
    BOMCopierErrorCapture(a3, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5332, (uint64_t)"resolve_path", "Could not realpath %s: %s\n");
    return 0;
  }
  if (dirname_r(a1, v22) != v22)
  {
    v5 = *__error();
    v6 = __error();
    strerror(*v6);
    BOMCopierErrorCapture(a3, v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5346, (uint64_t)"resolve_path", "Could not dirname %s: %s\n");
    return 0;
  }
  v10 = realpath_DARWIN_EXTSN(v22, 0);
  if (!v10)
  {
    v15 = *__error();
    __error();
    v16 = __error();
    strerror(*v16);
    BOMCopierErrorCapture(a3, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5353, (uint64_t)"resolve_path", "Could not realpath %s %d: %s\n", v22);
    return 0;
  }
  v11 = v10;
  if (basename_r(a1, v21) != v21)
  {
    v12 = *__error();
    v13 = __error();
    v14 = strerror(*v13);
    BOMCopierErrorCapture(a3, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5360, (uint64_t)"resolve_path", "Could not basename %s: %s\n", a1, v14);
    free(v11);
    return 0;
  }
  v20 = 0;
  v17 = asprintf(&v20, "%s/%s", v11, v21);
  free(v11);
  if (v17 < 0 || (result = v20) == 0)
  {
    v18 = *__error();
    v19 = __error();
    strerror(*v19);
    BOMCopierErrorCapture(a3, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5373, (uint64_t)"resolve_path", "Could not construct resolved path from %s + %s: %s\n", v22);
    return 0;
  }
  return result;
}

uint64_t BOMCopierSourceEntryFree(unsigned int *a1)
{
  int v2;
  unsigned int v3;
  FILE *v4;
  int *v5;
  uint64_t v6;
  FILE *v7;
  int *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  unint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  if (!a1)
  {
    BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1739, (uint64_t)"BOMCopierSourceEntryFree", "Invalid source_entry");
    return 1;
  }
  v2 = a1[81];
  if (v2 != -1)
    close(v2);
  if (*((_BYTE *)a1 + 320))
  {
    if (!*((_QWORD *)a1 + 2))
    {
      v6 = 1;
      fwrite("Could not get actual path", 0x19uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      return v6;
    }
    v3 = a1[1];
    if (v3 - 8 >= 3)
    {
      if (v3 == 6 && rmdir(*((const char **)a1 + 2)))
      {
        v7 = (FILE *)*MEMORY[0x24BDAC8D8];
        v8 = __error();
        strerror(*v8);
        fprintf(v7, "Could not rmdir %s: %s");
        return 1;
      }
    }
    else if (unlink(*((const char **)a1 + 2)))
    {
      v4 = (FILE *)*MEMORY[0x24BDAC8D8];
      v5 = __error();
      strerror(*v5);
      fprintf(v4, "Could not unlink %s: %s");
      return 1;
    }
  }
  v9 = (void *)*((_QWORD *)a1 + 5);
  if (v9)
    free(v9);
  v10 = (void *)*((_QWORD *)a1 + 4);
  if (v10)
    free(v10);
  v11 = (void *)*((_QWORD *)a1 + 3);
  if (v11)
    free(v11);
  v12 = (void *)*((_QWORD *)a1 + 2);
  if (v12)
    free(v12);
  v13 = (void *)*((_QWORD *)a1 + 6);
  if (v13)
    free(v13);
  v14 = (void *)*((_QWORD *)a1 + 7);
  if (v14)
    free(v14);
  v15 = (void *)*((_QWORD *)a1 + 25);
  if (v15)
    free(v15);
  v16 = (void *)*((_QWORD *)a1 + 21);
  if (v16)
    free(v16);
  v17 = (void *)*((_QWORD *)a1 + 30);
  if (v17)
    free(v17);
  if (a1[52])
  {
    v18 = 0;
    v19 = 0;
    do
    {
      free(*(void **)(*((_QWORD *)a1 + 27) + v18));
      v20 = *(void **)(*((_QWORD *)a1 + 27) + v18 + 16);
      if (v20)
        free(v20);
      ++v19;
      v18 += 24;
    }
    while (v19 < a1[52]);
  }
  v21 = (void *)*((_QWORD *)a1 + 27);
  if (v21)
    free(v21);
  v22 = (void *)*((_QWORD *)a1 + 28);
  if (v22)
    free(v22);
  v23 = (void *)*((_QWORD *)a1 + 39);
  if (v23)
    free(v23);
  *((_OWORD *)a1 + 19) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_OWORD *)a1 + 17) = 0u;
  *((_OWORD *)a1 + 18) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_OWORD *)a1 + 16) = 0u;
  *((_OWORD *)a1 + 13) = 0u;
  *((_OWORD *)a1 + 14) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  free(a1);
  return 0;
}

uint64_t parse_regular_file(uint64_t a1, _QWORD *a2)
{
  int v4;
  size_t v5;
  unint64_t Size;
  char *v7;
  char *v8;
  size_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  char *v14;
  int v15;
  int v16;
  int v17;
  int v19;
  int v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  int v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v30;
  int v31;
  int *v32;
  char *v33;
  _DWORD *v34;
  _QWORD *v35;
  int v37;
  __int128 v38;
  uint64_t v39;
  int v40;
  int v41;
  int *v42;
  char *v43;
  int8x16_t v44;
  int v45;
  int v46;
  size_t count;
  int8x16_t v48[2];

  if (a1)
  {
    if (*(_BYTE *)(a1 + 156))
    {
      v4 = 1;
      v5 = 4096;
      goto LABEL_10;
    }
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  Size = BOMCopierSourceEntryGetSize(a1);
  if (Size >= 0x1000)
    v5 = 4096;
  else
    v5 = Size;
  if (!Size)
    return 0;
  v4 = 0;
LABEL_10:
  v7 = (char *)malloc_type_malloc(0x1000uLL, 0x1FAA4AF7uLL);
  if (!v7)
  {
    v12 = *__error();
    v13 = __error();
    v14 = strerror(*v13);
    BOMCopierErrorCapture(a2, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4004, (uint64_t)"parse_regular_file", "Could not allocate %lld bytes for parse buffer: %s", 4096, v14);
    return 1;
  }
  v8 = v7;
  v9 = BOMCopierSourceEntryRead(a1, v7, v5, a2);
  v10 = v9;
  if (v4)
  {
    if (!v9)
    {
      free(v8);
      return 0;
    }
    if (v9 == -1)
    {
      BOMCopierSourceEntryGetPath(a1);
      v11 = 1;
      BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4019, (uint64_t)"parse_regular_file", "Could not read %lu bytes from %s");
LABEL_24:
      free(v8);
      return v11;
    }
  }
  else if (v9 != v5)
  {
    BOMCopierSourceEntryGetPath(a1);
    v11 = 1;
    BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4035, (uint64_t)"parse_regular_file", "Could not read %lu bytes from %s");
    goto LABEL_24;
  }
  *(_QWORD *)(a1 + 160) = 4096;
  *(_QWORD *)(a1 + 168) = v8;
  *(_QWORD *)(a1 + 176) = v9;
  if (v9 < 0x1C)
    return 0;
  v11 = 0;
  v15 = *(_DWORD *)v8;
  if (*(int *)v8 <= -822415875)
  {
    v16 = 3;
    if (v15 > -889275715)
    {
      if (v15 != -889275714)
      {
        v17 = -889275713;
        goto LABEL_33;
      }
    }
    else if (v15 != -1095041334)
    {
      v17 = -1078264118;
LABEL_33:
      if (v15 != v17)
        return v11;
      v16 = 4;
    }
    v21 = *(_QWORD *)v8;
    count = *(_QWORD *)v8;
    if ((v15 & 0xFEFFFFFF) == 0xBEBAFECA)
    {
      v22 = BOMHostByteOrder();
      BOMSwapFatHeader((int8x8_t *)&count, v22);
      LODWORD(v23) = HIDWORD(count);
    }
    else
    {
      v23 = HIDWORD(v21);
    }
    v27 = v23;
    v28 = malloc_type_calloc(v23, 0x20uLL, 0x1000040E0EAB150uLL);
    if (!v28)
    {
      v31 = *__error();
      v32 = __error();
      v33 = strerror(*v32);
      BOMCopierErrorCapture(a2, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4235, (uint64_t)"parse_regular_file", "Could not allocate BOMCopierArchRecord: %s", v33);
      v11 = 1;
      goto LABEL_24;
    }
    v25 = v28;
    if (v15 == -1078264118 || v15 == -889275713)
      v30 = 32;
    else
      v30 = 20;
    if (v10 < v30 * (unint64_t)(v23 + 1) + 8)
    {
      v11 = 0;
      v8 = (char *)v28;
      goto LABEL_24;
    }
    v46 = v16;
    if ((_DWORD)v23)
    {
      v34 = v8 + 8;
      v35 = v28;
      do
      {
        if (v15 == -889275714 || v15 == -1095041334)
        {
          memset(v48, 0, 20);
          __memcpy_chk();
          if (v15 == -1095041334)
          {
            v37 = BOMHostByteOrder();
            BOMSwapFatArch((uint64_t)v48, 1u, v37);
          }
          *v35 = v48[0].i64[0];
          *(_QWORD *)&v38 = v48[0].u32[2];
          *((_QWORD *)&v38 + 1) = v48[0].u32[3];
          *(_OWORD *)(v35 + 1) = v38;
          v39 = v48[1].u32[0];
        }
        else
        {
          memset(v48, 0, sizeof(v48));
          __memcpy_chk();
          if (v15 == -1078264118)
          {
            v40 = BOMHostByteOrder();
            BOMSwapFatArch64((uint64_t)v48, 1u, v40);
          }
          *v35 = v48[0].i64[0];
          *(int8x16_t *)(v35 + 1) = *(int8x16_t *)((char *)v48 + 8);
          v39 = v48[1].u32[2];
        }
        v35[3] = v39;
        v34 = (_DWORD *)((char *)v34 + v30);
        v35 += 4;
        --v27;
      }
      while (v27);
    }
    v19 = v46;
LABEL_77:
    v11 = 0;
    *(_DWORD *)(a1 + 192) = v19;
    *(_DWORD *)(a1 + 196) = v23;
    *(_QWORD *)(a1 + 200) = v25;
    return v11;
  }
  v19 = 1;
  if (v15 > -17958195)
  {
    if (v15 != -17958194)
    {
      v20 = -17958193;
LABEL_39:
      if (v15 != v20)
        return v11;
      if (v9 >= 0x20)
      {
        v19 = 2;
        goto LABEL_42;
      }
      return 0;
    }
  }
  else if (v15 != -822415874)
  {
    v20 = -805638658;
    goto LABEL_39;
  }
LABEL_42:
  v24 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
  if (v24)
  {
    v25 = v24;
    if (v15 == -17958194 || v15 == -822415874)
    {
      v48[0] = *(int8x16_t *)v8;
      *(int8x16_t *)((char *)v48 + 12) = *(int8x16_t *)(v8 + 12);
      if (v15 == -822415874)
      {
        v26 = BOMHostByteOrder();
        BOMSwapMachHeader((uint64_t)v48, v26);
      }
    }
    else
    {
      v44 = *((int8x16_t *)v8 + 1);
      v48[0] = *(int8x16_t *)v8;
      v48[1] = v44;
      if (v15 == -805638658)
      {
        v45 = BOMHostByteOrder();
        BOMSwapMachHeader64(v48, v45);
      }
    }
    *v25 = *(uint64_t *)((char *)v48[0].i64 + 4);
    v25[1] = 0;
    v25[2] = *(_QWORD *)(a1 + 96);
    v25[3] = 0;
    LODWORD(v23) = 1;
    goto LABEL_77;
  }
  v41 = *__error();
  v42 = __error();
  v43 = strerror(*v42);
  BOMCopierErrorCapture(a2, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4149, (uint64_t)"parse_regular_file", "Could not allocate BOMCopierArchRecord: %s", v43);
  free(v8);
  return 1;
}

ssize_t capture_extended_attributes(uint64_t a1, char a2, _QWORD *a3)
{
  const char *v6;
  ssize_t result;
  int v8;
  size_t v9;
  int v10;
  int *v11;
  char *v12;
  char *v13;
  size_t v14;
  unint64_t v15;
  const char *v16;
  _QWORD *v17;
  _QWORD *v18;
  unsigned int v19;
  const char *v20;
  unsigned int v21;
  _BOOL4 v22;
  char v23;
  char *v24;
  uint64_t v25;
  size_t v26;
  ssize_t v27;
  int v28;
  int *v29;
  int v30;
  int v31;
  int *v32;
  char *v33;
  int v34;
  int *v35;
  int v36;
  int *v37;
  _QWORD *v38;
  char *v39;

  if ((a2 & 0x1C) == 0)
    return 0;
  if (a1)
  {
    v6 = *(const char **)(a1 + 16);
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    v6 = 0;
  }
  if ((a2 & 0x10) != 0)
    v8 = 33;
  else
    v8 = 1;
  result = listxattr(v6, 0, 0, v8);
  if (result)
  {
    v9 = result;
    if (result == -1)
    {
      if (*__error() == 1 || *__error() == 45 || *__error() == 13)
        return 0;
      v10 = *__error();
      v11 = __error();
      strerror(*v11);
      BOMCopierErrorCapture(a3, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4409, (uint64_t)"capture_extended_attributes", "Could not listxattr %s: %s");
      return 1;
    }
    v12 = (char *)malloc_type_malloc(result, 0xD6988167uLL);
    if (v12)
    {
      v13 = v12;
      if (listxattr(v6, v12, v9, v8) == v9)
      {
        LODWORD(v14) = 0;
        v15 = (unint64_t)&v13[v9];
        v16 = v13;
        do
        {
          v14 = (v14 + 1);
          v16 += strlen(v16) + 1;
        }
        while ((unint64_t)v16 < v15);
        v17 = malloc_type_calloc(v14, 0x18uLL, 0x10100406AB5462FuLL);
        if (v17)
        {
          v18 = v17;
          v19 = 0;
          v20 = v13;
          v21 = 0;
          v38 = a3;
          v39 = (char *)v20;
          while (1)
          {
            if ((a2 & 4) != 0)
            {
              if ((a2 & 8) != 0)
                goto LABEL_30;
              if (string_compare(v20, "com.apple.FinderInfo"))
              {
                v22 = string_compare(v20, "com.apple.ResourceFork") != 0;
                if ((a2 & 0x10) == 0)
                  goto LABEL_38;
                goto LABEL_31;
              }
            }
            else if ((a2 & 8) != 0)
            {
              if (string_compare(v20, "com.apple.FinderInfo"))
              {
                v22 = string_compare(v20, "com.apple.ResourceFork") == 0;
                if ((a2 & 0x10) == 0)
                  goto LABEL_38;
                goto LABEL_31;
              }
LABEL_30:
              v22 = 1;
              if ((a2 & 0x10) == 0)
                goto LABEL_38;
              goto LABEL_31;
            }
            v22 = 0;
            if ((a2 & 0x10) == 0)
            {
LABEL_38:
              if (v22)
                goto LABEL_39;
              goto LABEL_41;
            }
LABEL_31:
            if (!string_compare(v20, "com.apple.decmpfs")
              || (!string_compare(v20, "com.apple.ResourceFork") ? (v23 = 1) : (v23 = v22), (v23 & 1) != 0))
            {
LABEL_39:
              v24 = strdup(v20);
              v18[3 * v21] = v24;
              if (!v24)
              {
                v34 = *__error();
                v35 = __error();
                strerror(*v35);
                BOMCopierErrorCapture(v38, v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4549, (uint64_t)"capture_extended_attributes", "Could not duplicate %s: %s");
LABEL_57:
                free(v18);
                v33 = v39;
                goto LABEL_58;
              }
              ++v19;
              ++v21;
            }
LABEL_41:
            v20 += strlen(v20) + 1;
            if ((unint64_t)v20 >= v15)
            {
              if (v19)
              {
                v25 = 0;
                v26 = v19;
                while (1)
                {
                  v27 = getxattr(v6, (const char *)v18[v25], 0, 0, 0, v8);
                  if (v27 == -1)
                    break;
                  v18[v25 + 1] = v27;
                  v25 += 3;
                  if (3 * v19 == v25)
                    goto LABEL_54;
                }
                v36 = *__error();
                v37 = __error();
                strerror(*v37);
                BOMCopierErrorCapture(v38, v36, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4582, (uint64_t)"capture_extended_attributes", "Could not getxattr size for %s: %s");
                goto LABEL_57;
              }
              v26 = 0;
LABEL_54:
              qsort(v18, v26, 0x18uLL, (int (__cdecl *)(const void *, const void *))xattr_compare);
              *(_DWORD *)(a1 + 208) = v19;
              *(_QWORD *)(a1 + 216) = v18;
              free(v39);
              return 0;
            }
          }
        }
        v31 = *__error();
        v32 = __error();
        strerror(*v32);
        BOMCopierErrorCapture(a3, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4468, (uint64_t)"capture_extended_attributes", "Could not allocate extended attribute list: %s");
      }
      else
      {
        v30 = *__error();
        BOMCopierErrorCapture(a3, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4434, (uint64_t)"capture_extended_attributes", "%ld does not match %ld\n");
      }
      v33 = v13;
LABEL_58:
      free(v33);
    }
    else
    {
      v28 = *__error();
      v29 = __error();
      strerror(*v29);
      BOMCopierErrorCapture(a3, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4427, (uint64_t)"capture_extended_attributes", "Could not allocate %ld bytes for name buffer: %s\n");
    }
    return 1;
  }
  return result;
}

uint64_t capture_acl(uint64_t a1, _QWORD *a2)
{
  const char *v4;
  _acl *link_np;
  _acl *v6;
  char *v7;
  char *v8;
  uint64_t result;
  ssize_t v10;
  int v11;
  int *v12;
  int v13;
  int *v14;
  ssize_t len_p;

  if (a1)
  {
    v4 = *(const char **)(a1 + 16);
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    v4 = 0;
  }
  if (*(_DWORD *)(a1 + 4) == 9)
    link_np = acl_get_link_np(v4, ACL_TYPE_EXTENDED);
  else
    link_np = acl_get_file(v4, ACL_TYPE_EXTENDED);
  v6 = link_np;
  if (link_np)
  {
    len_p = 0;
    v7 = acl_to_text(link_np, &len_p);
    if (v7)
    {
      v8 = v7;
      acl_free(v6);
      result = 0;
      v10 = len_p;
      *(_QWORD *)(a1 + 224) = v8;
      *(_QWORD *)(a1 + 232) = v10;
      return result;
    }
    v11 = *__error();
    v12 = __error();
    strerror(*v12);
    BOMCopierErrorCapture(a2, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4682, (uint64_t)"capture_acl", "Could not convert ACL to text for %s: %s");
  }
  else
  {
    if (*__error() == 2)
      return 0;
    v13 = *__error();
    v14 = __error();
    strerror(*v14);
    BOMCopierErrorCapture(a2, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4666, (uint64_t)"capture_acl", "Could not retrieve ACL for %s: %s");
  }
  return 1;
}

_DWORD *BOMCopierSourceEntryNewFromResourceFork(const char *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  int v6;
  int *v7;
  int v8;
  int *v9;
  _DWORD *v10;
  int v12;
  int *v13;
  char *v14;
  _DWORD *v15;
  _QWORD *v16;
  int v17;
  int *v18;
  int v19;
  int *v20;
  char *v21;
  int v22;
  int *v23;
  int v24;
  int *v25;
  timespec st_mtimespec;
  int v27;
  int *v28;
  stat v29;
  char *v30;
  char v31[255];
  char __s1[1024];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v4 = realpath_DARWIN_EXTSN(a1, 0);
    if (v4)
    {
      v5 = v4;
      v30 = 0;
      if (asprintf(&v30, "%s%s", v4, "/..namedfork/rsrc") < 0)
      {
        v12 = *__error();
        v13 = __error();
        v14 = strerror(*v13);
        BOMCopierErrorCapture(a2, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 753, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not constructed resolved rsrc path: %s", v14);
        free(v5);
      }
      else
      {
        free(v5);
        memset(&v29, 0, sizeof(v29));
        if (lstat(v30, &v29))
        {
          v6 = *__error();
          v7 = __error();
          strerror(*v7);
          BOMCopierErrorCapture(a2, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 764, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not stat %s: %s");
        }
        else
        {
          v15 = BOMCopierSourceEntryNew(8, a2);
          v10 = v15;
          if (!v15)
          {
            BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 771, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not create BOMCopierSourceEntry for regular file");
            return v10;
          }
          *v15 = 2;
          *((_QWORD *)v15 + 2) = v30;
          v16 = v15 + 6;
          if (asprintf((char **)v15 + 3, "%s%s", a1, "/..namedfork/rsrc") == -1 || !*v16)
          {
            v19 = *__error();
            v20 = __error();
            strerror(*v20);
            BOMCopierErrorCapture(a2, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 785, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not constructed entry rsrc path: %s");
          }
          else if (__s1 == dirname_r(a1, __s1))
          {
            v21 = strdup(__s1);
            *((_QWORD *)v10 + 4) = v21;
            if (v21)
            {
              if (v31 == basename_r(a1, v31))
              {
                if (asprintf((char **)v10 + 5, "%s%s", v31, "/..namedfork/rsrc") != -1 && *((_QWORD *)v10 + 5))
                {
                  *(_QWORD *)(v10 + 21) = *(_QWORD *)&v29.st_uid;
                  st_mtimespec = v29.st_mtimespec;
                  *(timespec *)(v10 + 26) = v29.st_atimespec;
                  v10[16] = v29.st_dev;
                  *((_QWORD *)v10 + 9) = v29.st_ino;
                  *((_WORD *)v10 + 40) = v29.st_nlink;
                  *((_WORD *)v10 + 46) = v29.st_mode;
                  *((_QWORD *)v10 + 12) = v29.st_size;
                  *(timespec *)(v10 + 30) = st_mtimespec;
                  *(timespec *)(v10 + 34) = v29.st_ctimespec;
                  v10[38] = v29.st_flags;
                  return v10;
                }
                v27 = *__error();
                v28 = __error();
                strerror(*v28);
                BOMCopierErrorCapture(a2, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 813, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not constructed entry rsrc name: %s");
              }
              else
              {
                v22 = *__error();
                v23 = __error();
                strerror(*v23);
                BOMCopierErrorCapture(a2, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 806, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not basename_r %s: %s");
              }
            }
            else
            {
              v24 = *__error();
              v25 = __error();
              strerror(*v25);
              BOMCopierErrorCapture(a2, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 799, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not duplicate %s: %s");
            }
          }
          else
          {
            v17 = *__error();
            v18 = __error();
            strerror(*v18);
            BOMCopierErrorCapture(a2, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 792, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not dirname_r %s: %s");
          }
        }
      }
    }
    else
    {
      v8 = *__error();
      __error();
      v9 = __error();
      strerror(*v9);
      BOMCopierErrorCapture(a2, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 745, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not realpath %s %d: %s\n", a1);
    }
  }
  else
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 732, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Invalid path");
  }
  return 0;
}

uint64_t BOMCopierSourceEntryNewFromFTSENT(uint64_t a1, char a2, _QWORD *a3)
{
  int v6;
  _DWORD *v7;
  uint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  ssize_t v11;
  _BYTE *v12;
  uint64_t v13;
  int v14;
  int *v15;
  int v16;
  int *v17;
  char v19[1024];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 850, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Invalid filesystem_entry");
    return 0;
  }
  v6 = 6;
  switch(*(_WORD *)(a1 + 88))
  {
    case 1:
      break;
    case 2:
      v6 = 1;
      break;
    case 3:
      v6 = mode_to_source_entry_type(*(_WORD *)(*(_QWORD *)(a1 + 96) + 4));
      break;
    case 4:
      v6 = 2;
      break;
    case 5:
      v6 = 3;
      break;
    case 6:
      v6 = 13;
      break;
    case 8:
      v6 = 8;
      break;
    case 0xC:
      v6 = 9;
      break;
    case 0xE:
      v6 = 11;
      break;
    default:
      v6 = 0;
      break;
  }
  v7 = BOMCopierSourceEntryNew(v6, a3);
  v8 = (uint64_t)v7;
  if (v7)
  {
    *v7 = 3;
    v9 = copy_string(*(const void **)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
    *(_QWORD *)(v8 + 16) = v9;
    if (!v9)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 877, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not duplicate %s");
      goto LABEL_36;
    }
    v10 = copy_string(*(const void **)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
    *(_QWORD *)(v8 + 24) = v10;
    if (!v10)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 886, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not duplicate %s");
      goto LABEL_36;
    }
    if (v6 == 9)
    {
      bzero(v19, 0x400uLL);
      v11 = readlink(*(const char **)(a1 + 40), v19, 0x400uLL);
      if (v11 == -1)
      {
        v14 = *__error();
        v15 = __error();
        strerror(*v15);
        BOMCopierErrorCapture(a3, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 899, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not readlink %s: %s\n");
        goto LABEL_36;
      }
      v19[v11] = 0;
      v12 = copy_string(v19, v11);
      *(_QWORD *)(v8 + 48) = v12;
      if (!v12)
      {
        v17 = __error();
        strerror(*v17);
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 909, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not duplicate %s: %s\n");
        goto LABEL_36;
      }
    }
    v13 = *(_QWORD *)(a1 + 96);
    *(_DWORD *)(v8 + 64) = *(_DWORD *)v13;
    *(_QWORD *)(v8 + 72) = *(_QWORD *)(v13 + 8);
    *(_WORD *)(v8 + 80) = *(_WORD *)(v13 + 6);
    *(_WORD *)(v8 + 92) = *(_WORD *)(v13 + 4);
    *(_QWORD *)(v8 + 84) = *(_QWORD *)(v13 + 16);
    *(_QWORD *)(v8 + 96) = *(_QWORD *)(v13 + 96);
    *(_OWORD *)(v8 + 104) = *(_OWORD *)(v13 + 32);
    *(_OWORD *)(v8 + 120) = *(_OWORD *)(v13 + 48);
    *(_OWORD *)(v8 + 136) = *(_OWORD *)(v13 + 64);
    *(_DWORD *)(v8 + 152) = *(_DWORD *)(v13 + 116);
    if ((a2 & 1) != 0 && v6 == 8)
      *(_BYTE *)(v8 + 321) = 1;
    if ((a2 & 2) != 0 && v6 == 8 && parse_regular_file(v8, a3))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 961, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not parse the regular file");
LABEL_36:
      BOMCopierSourceEntryFree((unsigned int *)v8);
      return 0;
    }
    if (capture_extended_attributes(v8, a2, a3))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 975, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not capture extended attributes");
      goto LABEL_36;
    }
    if ((a2 & 0x20) != 0)
    {
      v16 = capture_acl(v8, a3);
      if (v16)
      {
        BOMCopierErrorCapture(a3, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 989, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not capture access control list");
        goto LABEL_36;
      }
    }
  }
  else
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 865, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not create BOMCopierSourceEntry from %d", v6);
  }
  return v8;
}

_BYTE *copy_string(const void *a1, size_t a2)
{
  size_t v4;
  _BYTE *v5;
  _BYTE *v6;
  FILE *v7;
  int *v8;
  char *v9;

  v4 = a2 + 1;
  v5 = malloc_type_malloc(a2 + 1, 0xF6B84704uLL);
  v6 = v5;
  if (v5)
  {
    memcpy(v5, a1, a2);
    v6[a2] = 0;
  }
  else
  {
    v7 = (FILE *)*MEMORY[0x24BDAC8D8];
    v8 = __error();
    v9 = strerror(*v8);
    fprintf(v7, "Could not allocate copy buffer of %ld bytes: %s\n", v4, v9);
  }
  return v6;
}

uint64_t BOMCopierSourceEntryNewFromFSObject(const char *a1, uint64_t a2, __int16 a3, _QWORD *a4)
{
  __int16 v8;
  uint64_t v9;
  const char *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  _DWORD *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  int *v19;
  int *v21;
  int v22;
  int v23;
  int *v24;
  char *v25;
  ssize_t v26;
  char *v27;
  timespec st_mtimespec;
  int v29;
  int *v30;
  int Code;
  int v32;
  int *v33;
  int v34;
  int *v35;
  char *v36;
  char *v37;
  const char *v38;
  char *v39;
  uint64_t v40;
  int v41;
  char *v42;
  int *v43;
  char *v44;
  int v45;
  int v46;
  int *v47;
  int *v48;
  int v49;
  int *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  stat v54;
  char *v55;
  char __s1[1024];
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1023, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Invalid source_path");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1029, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Invalid fso");
    return 0;
  }
  v8 = BOMFSObjectMode(a2);
  v9 = BOMFSObjectPathName(a2);
  if (!v9)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1047, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not retrieve path from fso\n");
    return 0;
  }
  v10 = (const char *)v9;
  v11 = mode_to_source_entry_type(v8);
  v12 = strcmp(v10, ".");
  if (v12)
    v13 = 0;
  else
    v13 = 6;
  if (v11)
    v14 = v11;
  else
    v14 = v13;
  v15 = BOMCopierSourceEntryNew(v14, a4);
  v16 = (uint64_t)v15;
  if (!v15)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1063, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not create BOMCopierSourceEntry from %d", v14);
    return v16;
  }
  *v15 = 4;
  v17 = strdup(v10);
  *(_QWORD *)(v16 + 24) = v17;
  if (!v17)
  {
    v21 = __error();
    strerror(*v21);
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1076, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate fso_path %s: %s\n");
    goto LABEL_23;
  }
  v55 = 0;
  if (v12)
  {
    if (asprintf(&v55, "%s/%s", a1, v10 + 2) == -1 || (v18 = v55) == 0)
    {
      v19 = __error();
      strerror(*v19);
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1097, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not construct path from %s and %s: %s\n", a1);
      goto LABEL_23;
    }
  }
  else
  {
    v18 = strdup(a1);
    v55 = v18;
    if (!v18)
    {
      v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1087, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s\n");
      goto LABEL_23;
    }
  }
  memset(&v54, 0, sizeof(v54));
  v22 = lstat(v18, &v54);
  if (v22)
  {
    if (*__error() != 13 && *__error() != 1)
    {
      v34 = *__error();
      v35 = __error();
      strerror(*v35);
      BOMCopierErrorCapture(a4, v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1121, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not lstat %s: %s\n");
      goto LABEL_23;
    }
    if ((a3 & 0x100) == 0)
    {
      v23 = *__error();
      v24 = __error();
      strerror(*v24);
      BOMCopierErrorCapture(a4, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1113, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not lstat %s: %s\n");
      goto LABEL_23;
    }
  }
  v53 = 0;
  v25 = resolve_path(v55, v14 == 9, &v53);
  *(_QWORD *)(v16 + 16) = v25;
  if (!v25)
  {
    Code = BOMCopierErrorGetCode((uint64_t)v53);
    if (Code != 13 && Code != 1)
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1147, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not resolve %s", v55);
      BOMCopierSourceEntryFree((unsigned int *)v16);
      free(v55);
      return 0;
    }
    if ((a3 & 0x100) == 0)
    {
      v32 = *__error();
      v33 = __error();
      strerror(*v33);
      BOMCopierErrorCapture(a4, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1137, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not resolve path for %s: %s\n");
      goto LABEL_23;
    }
    BOMCopierErrorFree(v53);
    goto LABEL_49;
  }
  if (v22)
  {
LABEL_49:
    v36 = v55;
    v37 = strdup(v55);
    *(_QWORD *)(v16 + 16) = v37;
    if (v37)
    {
      free(v36);
      if (v14 == 9)
      {
        v38 = (const char *)BOMFSObjectSymlinkTarget(a2);
        if (!v38)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1183, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not get symlink target from fso\n", v51, v52);
          goto LABEL_23;
        }
        v39 = strdup(v38);
        *(_QWORD *)(v16 + 48) = v39;
        if (!v39)
        {
          v48 = __error();
          strerror(*v48);
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1191, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s\n");
          goto LABEL_23;
        }
      }
      *(_WORD *)(v16 + 92) = BOMFSObjectMode(a2);
      *(_DWORD *)(v16 + 84) = BOMFSObjectUserID(a2);
      *(_DWORD *)(v16 + 88) = BOMFSObjectGroupID(a2);
      v40 = BOMFSObjectSize(a2);
      *(_QWORD *)(v16 + 104) = 0;
      *(_QWORD *)(v16 + 112) = 0;
      *(_QWORD *)(v16 + 96) = v40;
      *(_QWORD *)(v16 + 120) = BOMFSObjectModTime(a2);
      *(_QWORD *)(v16 + 128) = 0;
      *(_QWORD *)(v16 + 136) = 0;
      *(_QWORD *)(v16 + 144) = 0;
      *(_DWORD *)(v16 + 152) = 0;
      return v16;
    }
    v41 = *__error();
    v42 = v55;
    v43 = __error();
    v44 = strerror(*v43);
    BOMCopierErrorCapture(a4, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1165, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s", v42, v44);
    free(v55);
LABEL_23:
    BOMCopierSourceEntryFree((unsigned int *)v16);
    return 0;
  }
  free(v55);
  if (v14 == 9)
  {
    bzero(__s1, 0x400uLL);
    v26 = readlink(*(const char **)(v16 + 16), __s1, 0x400uLL);
    if (v26 == -1)
    {
      v46 = *__error();
      v47 = __error();
      strerror(*v47);
      BOMCopierErrorCapture(a4, v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1226, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not readlink %s: %s\n");
      goto LABEL_23;
    }
    __s1[v26] = 0;
    v27 = strdup(__s1);
    *(_QWORD *)(v16 + 48) = v27;
    if (!v27)
    {
      v49 = *__error();
      v50 = __error();
      strerror(*v50);
      BOMCopierErrorCapture(a4, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1236, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s\n");
      goto LABEL_23;
    }
  }
  *(_QWORD *)(v16 + 84) = *(_QWORD *)&v54.st_uid;
  st_mtimespec = v54.st_mtimespec;
  *(timespec *)(v16 + 104) = v54.st_atimespec;
  *(_DWORD *)(v16 + 64) = v54.st_dev;
  *(_QWORD *)(v16 + 72) = v54.st_ino;
  *(_WORD *)(v16 + 80) = v54.st_nlink;
  *(_WORD *)(v16 + 92) = v54.st_mode;
  *(_QWORD *)(v16 + 96) = v54.st_size;
  *(timespec *)(v16 + 120) = st_mtimespec;
  *(timespec *)(v16 + 136) = v54.st_ctimespec;
  *(_DWORD *)(v16 + 152) = v54.st_flags;
  if ((a3 & 0x80) != 0)
    *(_DWORD *)(v16 + 84) = BOMFSObjectUserID(a2);
  if ((a3 & 2) != 0 && v14 == 8)
  {
    v29 = parse_regular_file(v16, a4);
    if (v29)
    {
      BOMCopierErrorCapture(a4, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1280, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not parse the regular file", v51, v52);
      goto LABEL_23;
    }
  }
  v45 = capture_extended_attributes(v16, a3, a4);
  if (v45)
  {
    BOMCopierErrorCapture(a4, v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1294, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not capture extended attributes", v51, v52);
    goto LABEL_23;
  }
  if ((a3 & 0x20) != 0 && capture_acl(v16, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1308, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not capture access control list", v51, v52);
    goto LABEL_23;
  }
  return v16;
}

uint64_t BOMCopierSourceEntryNewFromLibarchive(uint64_t a1, uint64_t a2, __int16 a3, _QWORD *a4)
{
  __int16 v8;
  int v9;
  _DWORD *v10;
  uint64_t v11;
  const char *v12;
  size_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  __int16 v18;
  __int16 v19;
  int v20;
  int *v21;
  int v22;
  int *v23;
  int v24;
  int *v25;
  const char *v27;
  char *v28;
  int v29;
  int *v30;

  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1343, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Invalid archive");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1349, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Invalid archive_entry");
    return 0;
  }
  v8 = archive_entry_mode();
  v9 = mode_to_source_entry_type(v8);
  v10 = BOMCopierSourceEntryNew(v9, 0);
  v11 = (uint64_t)v10;
  if (!v10)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1364, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not create BOMCopierSourceEntry from %d", v9);
    return v11;
  }
  *v10 = 5;
  v12 = (const char *)archive_entry_pathname();
  v13 = strlen(v12) - 1;
  if (v12[v13] == 47)
  {
    v14 = strdup(v12);
    if (!v14)
    {
      v24 = *__error();
      v25 = __error();
      strerror(*v25);
      BOMCopierErrorCapture(a4, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1386, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s");
      goto LABEL_22;
    }
    v15 = v14;
    v14[v13] = 0;
    v12 = v14;
  }
  else
  {
    v15 = 0;
  }
  v16 = strdup(v12);
  *(_QWORD *)(v11 + 24) = v16;
  if (!v16)
  {
    v20 = *__error();
    v21 = __error();
    strerror(*v21);
    BOMCopierErrorCapture(a4, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1398, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s");
LABEL_22:
    BOMCopierSourceEntryFree((unsigned int *)v11);
    return 0;
  }
  v17 = strdup(v12);
  *(_QWORD *)(v11 + 16) = v17;
  if (!v17)
  {
    v22 = *__error();
    v23 = __error();
    strerror(*v23);
    BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1406, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s");
    goto LABEL_22;
  }
  if (v15)
    free(v15);
  *(_QWORD *)(v11 + 256) = a1;
  *(_QWORD *)(v11 + 264) = a2;
  *(_DWORD *)(v11 + 64) = archive_entry_dev();
  *(_QWORD *)(v11 + 72) = archive_entry_ino();
  *(_WORD *)(v11 + 80) = archive_entry_nlink();
  *(_WORD *)(v11 + 92) = archive_entry_mode();
  *(_DWORD *)(v11 + 84) = archive_entry_uid();
  *(_DWORD *)(v11 + 88) = archive_entry_gid();
  *(_QWORD *)(v11 + 96) = archive_entry_size();
  *(_QWORD *)(v11 + 104) = archive_entry_atime();
  *(_QWORD *)(v11 + 112) = archive_entry_atime_nsec();
  *(_QWORD *)(v11 + 120) = archive_entry_mtime();
  *(_QWORD *)(v11 + 128) = archive_entry_mtime_nsec();
  *(_QWORD *)(v11 + 136) = archive_entry_ctime();
  *(_QWORD *)(v11 + 144) = archive_entry_ctime_nsec();
  if ((a3 & 0x200) != 0)
  {
    v18 = *(_WORD *)(v11 + 92);
    if ((v18 & 0xF000) == 0x4000)
    {
      v19 = v18 | 0x1ED;
    }
    else if ((*(_WORD *)(v11 + 92) & 0xE00) != 0)
    {
      v19 = -32348;
    }
    else
    {
      v19 = v18 | 0x1A4;
    }
    *(_WORD *)(v11 + 92) = v19;
  }
  if (v9 != 8)
  {
    if (v9 != 9)
      return v11;
    v27 = (const char *)archive_entry_symlink();
    if (v27)
    {
      v28 = strdup(v27);
      *(_QWORD *)(v11 + 48) = v28;
      if (v28)
      {
        *(_QWORD *)(v11 + 96) = strlen(v28);
        return v11;
      }
      v29 = *__error();
      v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture(a4, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1461, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s\n");
    }
    else
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1453, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not get symlink target from Libarchive entry\n");
    }
    goto LABEL_22;
  }
  if ((a3 & 2) != 0 && parse_regular_file(v11, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1480, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not parse the regular file");
    goto LABEL_22;
  }
  return v11;
}

uint64_t BOMCopierSourceEntryNewFromDataArchive(uint64_t a1, _DWORD *a2, __int16 a3, _QWORD *a4)
{
  unsigned int type;
  __int16 v9;
  int v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  const char *v14;
  size_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  __int16 v23;
  int v24;
  int *v25;
  int v26;
  int *v27;
  int v28;
  int *v29;

  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1500, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Invalid data_archive");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1506, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Invalid data_archive_entry");
    return 0;
  }
  type = data_archive_entry_get_type(a2);
  v9 = data_archive_entry_mode((uint64_t)a2);
  v10 = mode_to_source_entry_type(v9);
  v11 = v10;
  if (type == 3)
  {
    switch(v10)
    {
      case 6:
        v11 = 14;
        break;
      case 9:
        v11 = 16;
        break;
      case 8:
        v11 = 15;
        break;
      default:
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1533, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Unexpected post order entry type: %u");
        return 0;
    }
  }
  v12 = BOMCopierSourceEntryNew(v11, a4);
  v13 = (uint64_t)v12;
  if (!v12)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1541, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not create BOMCopierSourceEntry from %d", v11);
    return v13;
  }
  *v12 = 6;
  v14 = (const char *)data_archive_entry_path((uint64_t)a2);
  v15 = strlen(v14) - 1;
  if (v14[v15] == 47)
  {
    v16 = strdup(v14);
    if (!v16)
    {
      v28 = *__error();
      v29 = __error();
      strerror(*v29);
      BOMCopierErrorCapture(a4, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1563, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not duplicate %s: %s");
      goto LABEL_41;
    }
    v17 = v16;
    v16[v15] = 0;
    v14 = v16;
  }
  else
  {
    v17 = 0;
  }
  v18 = strdup(v14);
  *(_QWORD *)(v13 + 24) = v18;
  if (!v18)
  {
    v24 = *__error();
    v25 = __error();
    strerror(*v25);
    BOMCopierErrorCapture(a4, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1575, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not duplicate %s: %s");
LABEL_41:
    BOMCopierSourceEntryFree((unsigned int *)v13);
    return 0;
  }
  v19 = strdup(v14);
  *(_QWORD *)(v13 + 16) = v19;
  if (!v19)
  {
    v26 = *__error();
    v27 = __error();
    strerror(*v27);
    BOMCopierErrorCapture(a4, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1583, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not duplicate %s: %s");
    goto LABEL_41;
  }
  if (v17)
    free(v17);
  *(_QWORD *)(v13 + 272) = a1;
  *(_QWORD *)(v13 + 280) = a2;
  *(_DWORD *)(v13 + 64) = data_archive_entry_dev(a2);
  *(_QWORD *)(v13 + 72) = data_archive_entry_inode((uint64_t)a2);
  *(_WORD *)(v13 + 80) = data_archive_entry_nlink((uint64_t)a2);
  *(_WORD *)(v13 + 92) = data_archive_entry_mode((uint64_t)a2);
  *(_DWORD *)(v13 + 84) = data_archive_entry_uid(a2);
  *(_DWORD *)(v13 + 88) = data_archive_entry_gid(a2);
  v20 = data_archive_entry_size((uint64_t)a2);
  if ((v11 - 15) >= 2)
    v21 = v20;
  else
    v21 = 0;
  *(_QWORD *)(v13 + 96) = v21;
  *(_QWORD *)(v13 + 104) = data_archive_entry_atime((uint64_t)a2);
  *(_QWORD *)(v13 + 112) = data_archive_entry_atime_nsec(a2);
  *(_QWORD *)(v13 + 120) = data_archive_entry_mtime((uint64_t)a2);
  *(_QWORD *)(v13 + 128) = data_archive_entry_atime_nsec(a2);
  *(_QWORD *)(v13 + 136) = data_archive_entry_ctime((uint64_t)a2);
  *(_QWORD *)(v13 + 144) = data_archive_entry_atime_nsec(a2);
  *(_BYTE *)(v13 + 156) = data_archive_entry_is_streamed((_BOOL8)a2);
  if ((a3 & 0x200) != 0)
  {
    v22 = *(_WORD *)(v13 + 92);
    if ((v22 & 0xF000) == 0x4000)
    {
      v23 = v22 | 0x1ED;
    }
    else if ((*(_WORD *)(v13 + 92) & 0xE00) != 0)
    {
      v23 = -32348;
    }
    else
    {
      v23 = v22 | 0x1A4;
    }
    *(_WORD *)(v13 + 92) = v23;
  }
  if ((a3 & 2) != 0 && v11 == 8 && parse_regular_file(v13, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1649, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not parse the regular file");
    goto LABEL_41;
  }
  return v13;
}

uint64_t BOMCopierSourceEntryNewFromAppleArchive(uint64_t a1, AAHeader header, unsigned __int8 a3, _QWORD *a4)
{
  AAFieldKey v9;
  uint32_t KeyIndex;
  unsigned int FieldUInt;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _DWORD *v17;
  uint32_t FieldCount;
  uint32_t v19;
  uint32_t v20;
  int FieldType;
  unsigned int v22;
  AAFieldKey FieldKey;
  AAFieldKey v24;
  int FieldBlob;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char v30;
  AAFieldKey v31;
  uint32_t v32;
  const char *v33;
  unsigned int FieldString;
  int v35;
  char *v36;
  char *v37;
  AAFieldKey v38;
  uint32_t v39;
  unsigned int v40;
  int v41;
  char *v42;
  AAFieldKey v43;
  uint32_t v44;
  unsigned int v45;
  int v46;
  AAFieldKey v47;
  uint32_t v48;
  unsigned int v49;
  int v50;
  AAFieldKey v51;
  uint32_t v52;
  unsigned int v53;
  int v54;
  AAFieldKey v55;
  uint32_t v56;
  unsigned int v57;
  int v58;
  __int16 v59;
  int v60;
  int v61;
  int *v62;
  int v63;
  int *v64;
  int v65;
  int v66;
  int *v67;
  int v68;
  int *v69;
  AAFieldKey v70;
  uint32_t v71;
  unsigned int v72;
  int v73;
  AAFieldKey v74;
  uint32_t v75;
  unsigned int v76;
  int v77;
  AAFieldKey v78;
  uint32_t v79;
  unsigned int v80;
  int v81;
  AAFieldKey v82;
  uint32_t v83;
  unsigned int v84;
  int v85;
  AAFieldKey v86;
  uint32_t v87;
  unsigned int FieldTimespec;
  int v89;
  char v90;
  uint64_t v91;
  uint64_t size;
  size_t v93;
  size_t length;
  timespec offset;
  uint64_t value[130];

  value[128] = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1669, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Invalid aa_decoder");
    return 0;
  }
  if (!header)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1675, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Invalid header");
    return 0;
  }
  value[0] = 0;
  v9.ikey = 5265748;
  KeyIndex = AAHeaderGetKeyIndex(header, v9);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, value), FieldUInt <= 1) ? (v12 = 1) : (v12 = FieldUInt),
        v12 < 1))
  {
LABEL_15:
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1686, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Unknown source entry type");
    return 0;
  }
  v13 = 0;
  v14 = 8;
  switch(LODWORD(value[0]))
  {
    case 'B':
      v14 = 7;
      goto LABEL_23;
    case 'C':
      v14 = 5;
      goto LABEL_23;
    case 'D':
      v14 = 6;
      goto LABEL_23;
    case 'E':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'M':
    case 'N':
    case 'O':
      goto LABEL_15;
    case 'F':
      goto LABEL_24;
    case 'L':
      v14 = 9;
      goto LABEL_23;
    case 'P':
      v14 = 4;
      goto LABEL_23;
    default:
      if (LODWORD(value[0]) == 83)
      {
        v14 = 10;
      }
      else
      {
        if (LODWORD(value[0]) != 87)
          goto LABEL_15;
        v14 = 11;
      }
LABEL_23:
      v13 = 1;
LABEL_24:
      v17 = BOMCopierSourceEntryNew(v14, 0);
      v15 = (uint64_t)v17;
      if (!v17)
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1693, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Could not create BOMCopierSourceEntry from %d", v14);
        return v15;
      }
      *v17 = 7;
      *((_QWORD *)v17 + 36) = a1;
      *((_QWORD *)v17 + 37) = header;
      v17[76] = 5521732;
      FieldCount = AAHeaderGetFieldCount(header);
      if (!FieldCount)
        goto LABEL_42;
      v19 = FieldCount;
      v20 = 0;
      break;
  }
  do
  {
    FieldType = AAHeaderGetFieldType(header, v20);
    v22 = FieldType;
    if (FieldType < 0)
    {
      BOMCopierErrorCapture(a4, FieldType, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5501, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get field type from AppleArchive header index %u: %d");
      goto LABEL_149;
    }
    FieldKey = AAHeaderGetFieldKey(header, v20);
    if (!FieldKey.ikey)
    {
      BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5508, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get field key from AppleArchive header index %u: %u");
      goto LABEL_149;
    }
    if (v22 >= 5)
    {
      if (v22 != 5)
      {
        BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5593, (uint64_t)"populate_source_entry_from_apple_archive", "Unknown AppleArchive field type: %u");
        goto LABEL_149;
      }
      v24 = FieldKey;
      if (FieldKey.ikey != 5521732)
      {
        value[0] = 0;
        offset.tv_sec = 0;
        FieldBlob = AAHeaderGetFieldBlob(header, v20, value, (uint64_t *)&offset);
        if (FieldBlob < 0)
        {
          BOMCopierErrorCapture(a4, FieldBlob, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5553, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive blob: %d");
          goto LABEL_149;
        }
        v26 = v13;
        v27 = *(unsigned int *)(v15 + 308);
        v28 = (char *)malloc_type_realloc(*(void **)(v15 + 312), 32 * (v27 + 1), 0xD1FD997DuLL);
        if (!v28)
        {
          v66 = *__error();
          v67 = __error();
          strerror(*v67);
          BOMCopierErrorCapture(a4, v66, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5564, (uint64_t)"populate_source_entry_from_apple_archive", "Could not allocate blob list: %s");
          goto LABEL_149;
        }
        v29 = &v28[32 * v27];
        *(AAFieldKey *)v29 = v24;
        *((_QWORD *)v29 + 2) = value[0];
        *((_QWORD *)v29 + 1) = offset.tv_sec;
        v30 = a3 >> 5;
        if (v24.ikey == 4997953 || (v30 = a3 >> 2, v24.ikey == 5521752))
          v29[24] = v30 & 1;
        *(_DWORD *)(v15 + 308) = v27 + 1;
        *(_QWORD *)(v15 + 312) = v28;
        v13 = v26;
      }
    }
    ++v20;
  }
  while (v19 != v20);
LABEL_42:
  bzero(value, 0x400uLL);
  length = 0;
  v31.ikey = 5521744;
  v32 = AAHeaderGetKeyIndex(header, v31);
  if ((v32 & 0x80000000) != 0)
  {
    v35 = 0;
LABEL_89:
    BOMCopierErrorCapture(a4, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5614, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get path from AppleArchive: %d");
    goto LABEL_149;
  }
  v33 = (const char *)value;
  FieldString = AAHeaderGetFieldString(header, v32, 0x400uLL, (char *)value, &length);
  if (FieldString <= 1)
    v35 = 1;
  else
    v35 = FieldString;
  if (v35 <= 0)
    goto LABEL_89;
  if (!length)
    v33 = ".";
  v36 = strdup(v33);
  *(_QWORD *)(v15 + 24) = v36;
  if (!v36)
  {
    v61 = *__error();
    v62 = __error();
    strerror(*v62);
    BOMCopierErrorCapture(a4, v61, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5631, (uint64_t)"populate_source_entry_from_apple_archive", "Could not duplicate %s: %s");
    goto LABEL_149;
  }
  v37 = strdup((const char *)value);
  *(_QWORD *)(v15 + 16) = v37;
  if (!v37)
  {
    v63 = *__error();
    v64 = __error();
    strerror(*v64);
    BOMCopierErrorCapture(a4, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5638, (uint64_t)"populate_source_entry_from_apple_archive", "Could not duplicate %s: %s");
    goto LABEL_149;
  }
  if (*(_DWORD *)(v15 + 4) == 9)
  {
    bzero(&offset, 0x400uLL);
    v93 = 0;
    v38.ikey = 4935244;
    v39 = AAHeaderGetKeyIndex(header, v38);
    if ((v39 & 0x80000000) != 0
      || ((v40 = AAHeaderGetFieldString(header, v39, 0x400uLL, (char *)&offset, &v93), v40 <= 1)
        ? (v41 = 1)
        : (v41 = v40),
          v41 <= 0))
    {
      v65 = *__error();
      BOMCopierErrorCapture(a4, v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5654, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get symlink target path: %d");
      goto LABEL_149;
    }
    v42 = strdup((const char *)&offset);
    *(_QWORD *)(v15 + 48) = v42;
    if (!v42)
    {
      v68 = *__error();
      v69 = __error();
      strerror(*v69);
      BOMCopierErrorCapture(a4, v68, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5661, (uint64_t)"populate_source_entry_from_apple_archive", "Could not duplicate %s: %s\n");
      goto LABEL_149;
    }
  }
  v93 = 0;
  v43.ikey = 5653828;
  v44 = AAHeaderGetKeyIndex(header, v43);
  if ((v44 & 0x80000000) == 0)
  {
    v45 = AAHeaderGetFieldUInt(header, v44, &v93);
    if (v45 <= 1)
      v46 = 1;
    else
      v46 = v45;
    if (v46 < 0)
    {
      BOMCopierErrorCapture(a4, v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5674, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive device: %d");
LABEL_149:
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1706, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Could not populate source entry from AppleArchive");
      goto LABEL_150;
    }
    if (v45 <= 1)
      *(_DWORD *)(v15 + 64) = v93;
  }
  v47.ikey = 5197385;
  v48 = AAHeaderGetKeyIndex(header, v47);
  if ((v48 & 0x80000000) != 0)
    goto LABEL_72;
  v49 = AAHeaderGetFieldUInt(header, v48, &v93);
  if (v49 <= 1)
    v50 = 1;
  else
    v50 = v49;
  if (v50 < 0)
  {
    BOMCopierErrorCapture(a4, v50, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5686, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive inode: %d");
    goto LABEL_149;
  }
  if (v49 <= 1)
    *(_QWORD *)(v15 + 72) = v93;
LABEL_72:
  v51.ikey = 4934734;
  v52 = AAHeaderGetKeyIndex(header, v51);
  if ((v52 & 0x80000000) != 0)
    goto LABEL_79;
  v53 = AAHeaderGetFieldUInt(header, v52, &v93);
  if (v53 <= 1)
    v54 = 1;
  else
    v54 = v53;
  if (v54 < 0)
  {
    BOMCopierErrorCapture(a4, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5698, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive nlink: %d");
    goto LABEL_149;
  }
  if (v53 <= 1)
    *(_WORD *)(v15 + 80) = v93;
LABEL_79:
  v55.ikey = 4476749;
  v56 = AAHeaderGetKeyIndex(header, v55);
  if ((v56 & 0x80000000) != 0)
    goto LABEL_103;
  v57 = AAHeaderGetFieldUInt(header, v56, &v93);
  if (v57 <= 1)
    v58 = 1;
  else
    v58 = v57;
  if (v58 < 0)
  {
    BOMCopierErrorCapture(a4, v58, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5710, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive mode: %d");
    goto LABEL_149;
  }
  if (v57 <= 1)
  {
    v59 = v93;
    *(_WORD *)(v15 + 92) = v93;
    v60 = *(_DWORD *)(v15 + 4) - 4;
    if (v60 >= 8 || ((0xF7u >> v60) & 1) == 0)
    {
      BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5757, (uint64_t)"populate_source_entry_from_apple_archive", "Unsupported entry type: %u");
      goto LABEL_149;
    }
    *(_WORD *)(v15 + 92) = word_2063CFE90[v60] | v59;
  }
LABEL_103:
  v70.ikey = 4475221;
  v71 = AAHeaderGetKeyIndex(header, v70);
  if ((v71 & 0x80000000) != 0)
    goto LABEL_110;
  v72 = AAHeaderGetFieldUInt(header, v71, &v93);
  if (v72 <= 1)
    v73 = 1;
  else
    v73 = v72;
  if (v73 < 0)
  {
    BOMCopierErrorCapture(a4, v73, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5766, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive uid: %d");
    goto LABEL_149;
  }
  if (v72 <= 1)
    *(_DWORD *)(v15 + 84) = v93;
LABEL_110:
  v74.ikey = 4475207;
  v75 = AAHeaderGetKeyIndex(header, v74);
  if ((v75 & 0x80000000) != 0)
    goto LABEL_117;
  v76 = AAHeaderGetFieldUInt(header, v75, &v93);
  if (v76 <= 1)
    v77 = 1;
  else
    v77 = v76;
  if (v77 < 0)
  {
    BOMCopierErrorCapture(a4, v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5778, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive gid: %d");
    goto LABEL_149;
  }
  if (v76 <= 1)
    *(_DWORD *)(v15 + 88) = v93;
LABEL_117:
  v91 = 0;
  size = 0;
  v78.ikey = 5521732;
  v79 = AAHeaderGetKeyIndex(header, v78);
  if ((v79 & 0x80000000) != 0)
    goto LABEL_124;
  v80 = AAHeaderGetFieldBlob(header, v79, &size, &v91);
  if (v80 <= 1)
    v81 = 1;
  else
    v81 = v80;
  if (v81 < 0)
  {
    BOMCopierErrorCapture(a4, v81, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5792, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive data size: %d");
    goto LABEL_149;
  }
  if (v80 <= 1)
    *(_QWORD *)(v15 + 96) = size;
LABEL_124:
  v82.ikey = 5917011;
  v83 = AAHeaderGetKeyIndex(header, v82);
  if ((v83 & 0x80000000) != 0)
    goto LABEL_131;
  v84 = AAHeaderGetFieldUInt(header, v83, &v93);
  if (v84 <= 1)
    v85 = 1;
  else
    v85 = v84;
  if (v85 < 0)
  {
    BOMCopierErrorCapture(a4, v85, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5804, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive size: %d");
    goto LABEL_149;
  }
  if (v84 <= 1)
    *(_QWORD *)(v15 + 96) = v93;
LABEL_131:
  offset.tv_sec = 0;
  offset.tv_nsec = 0;
  v86.ikey = 5067853;
  v87 = AAHeaderGetKeyIndex(header, v86);
  if ((v87 & 0x80000000) != 0)
    goto LABEL_138;
  FieldTimespec = AAHeaderGetFieldTimespec(header, v87, &offset);
  if (FieldTimespec <= 1)
    v89 = 1;
  else
    v89 = FieldTimespec;
  if (v89 < 0)
  {
    BOMCopierErrorCapture(a4, v89, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5817, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive modification timespec: %d");
    goto LABEL_149;
  }
  if (FieldTimespec <= 1)
    *(timespec *)(v15 + 120) = offset;
LABEL_138:
  *(_QWORD *)(v15 + 104) = 0;
  *(_QWORD *)(v15 + 112) = 0;
  *(_QWORD *)(v15 + 136) = 0;
  *(_QWORD *)(v15 + 144) = 0;
  if ((a3 & 2) != 0)
    v90 = v13;
  else
    v90 = 1;
  if ((v90 & 1) == 0 && parse_regular_file(v15, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1722, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Could not parse the regular file");
LABEL_150:
    BOMCopierSourceEntryFree((unsigned int *)v15);
    return 0;
  }
  return v15;
}

uint64_t BOMCopierSourceEntryGetActualPath(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 16);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetType(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 4);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetPath(uint64_t a1)
{
  uint64_t result;

  if (a1)
  {
    result = *(_QWORD *)(a1 + 24);
    if (!result)
      return *(_QWORD *)(a1 + 16);
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return 0;
  }
  return result;
}

char *BOMCopierSourceEntryGetParent(_QWORD *a1)
{
  char *v2;
  const char *v3;
  FILE *v4;
  const char *v5;
  size_t v6;

  if (!a1)
  {
    v4 = (FILE *)*MEMORY[0x24BDAC8D8];
    v5 = "Invalid source_entry";
    v6 = 20;
LABEL_10:
    fwrite(v5, v6, 1uLL, v4);
    return 0;
  }
  v2 = (char *)a1[4];
  if (v2)
    return v2;
  v3 = (const char *)a1[3];
  if (!v3)
  {
    v3 = (const char *)a1[2];
    if (!v3)
    {
      v4 = (FILE *)*MEMORY[0x24BDAC8D8];
      v5 = "Missing entry_path";
      v6 = 18;
      goto LABEL_10;
    }
  }
  if (!strcmp(v3, "."))
  {
    v2 = strdup(".");
    goto LABEL_14;
  }
  v2 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x8C400F89uLL);
  if (v2)
  {
    if (v2 != dirname_r(v3, v2))
    {
      free(v2);
      return 0;
    }
LABEL_14:
    a1[4] = v2;
  }
  return v2;
}

char *BOMCopierSourceEntryGetName(_QWORD *a1)
{
  char *v2;
  const char *v3;
  FILE *v4;
  const char *v5;
  size_t v6;

  if (!a1)
  {
    v4 = (FILE *)*MEMORY[0x24BDAC8D8];
    v5 = "Invalid source_entry";
    v6 = 20;
LABEL_10:
    fwrite(v5, v6, 1uLL, v4);
    return 0;
  }
  v2 = (char *)a1[5];
  if (v2)
    return v2;
  v3 = (const char *)a1[3];
  if (!v3)
  {
    v3 = (const char *)a1[2];
    if (!v3)
    {
      v4 = (FILE *)*MEMORY[0x24BDAC8D8];
      v5 = "Missing entry_path";
      v6 = 18;
      goto LABEL_10;
    }
  }
  if (!strcmp(v3, "."))
  {
    v2 = strdup(".");
    goto LABEL_14;
  }
  v2 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x24089911uLL);
  if (v2)
  {
    if (v2 != basename_r(v3, v2))
    {
      free(v2);
      return 0;
    }
LABEL_14:
    a1[5] = v2;
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetDevice(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 64);
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2026, (uint64_t)"BOMCopierSourceEntryGetDevice", "Invalid source_entry");
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetInode(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 72);
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2040, (uint64_t)"BOMCopierSourceEntryGetInode", "Invalid source_entry");
  return -1;
}

uint64_t BOMCopierSourceEntryGetHardlinkCount(uint64_t a1)
{
  if (a1)
    return *(unsigned __int16 *)(a1 + 80);
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2054, (uint64_t)"BOMCopierSourceEntryGetHardlinkCount", "Invalid source_entry");
  return 0xFFFFLL;
}

uint64_t BOMCopierSourceEntryGetSize(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1)
      return *(_QWORD *)(a1 + 96);
    else
      return *(_QWORD *)(a1 + 248);
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return 0;
  }
}

uint64_t BOMCopierSourceEntryGetMode(uint64_t a1)
{
  if (a1)
    return *(unsigned __int16 *)(a1 + 92);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetUserID(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 84);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetGroupID(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 88);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetFlags(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 152);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetAccessTime(uint64_t a1, _OWORD *a2)
{
  uint64_t v2;

  if (a1)
  {
    if (a2)
    {
      v2 = 0;
      *a2 = *(_OWORD *)(a1 + 104);
    }
    else
    {
      v2 = 1;
      fwrite("Invalid access_time", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetModificationTime(uint64_t a1, _OWORD *a2)
{
  uint64_t v2;

  if (a1)
  {
    if (a2)
    {
      v2 = 0;
      *a2 = *(_OWORD *)(a1 + 120);
    }
    else
    {
      v2 = 1;
      fwrite("Invalid modification_time", 0x19uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetStatusTime(uint64_t a1, _OWORD *a2)
{
  uint64_t v2;

  if (a1)
  {
    if (a2)
    {
      v2 = 0;
      *a2 = *(_OWORD *)(a1 + 136);
    }
    else
    {
      v2 = 1;
      fwrite("Invalid status_time", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetSymlinkTarget(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 48);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetAppleDoubleTarget(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 56);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

BOOL BOMCopierSourceEntryIsCompressed(_BOOL8 result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 152);
    return (v1 & 0x20) != 0 && (v1 & 0x40000000) == 0;
  }
  return result;
}

uint64_t BOMCopierSourceEntryIsRestricted(uint64_t result)
{
  if (result)
    return (*(unsigned __int8 *)(result + 154) >> 3) & 1;
  return result;
}

uint64_t BOMCopierSourceEntryGetBinaryType(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 192);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetArchCount(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 196);
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetArchRecord(uint64_t a1, unsigned int a2, _OWORD *a3, _QWORD *a4)
{
  uint64_t result;
  _OWORD *v6;
  __int128 v7;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 196) <= a2)
    {
      BOMCopierErrorCapture(a4, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2344, (uint64_t)"BOMCopierSourceEntryGetArchRecord", "index is out of range");
    }
    else
    {
      if (a3)
      {
        result = 0;
        v6 = (_OWORD *)(*(_QWORD *)(a1 + 200) + 32 * a2);
        v7 = v6[1];
        *a3 = *v6;
        a3[1] = v7;
        return result;
      }
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2350, (uint64_t)"BOMCopierSourceEntryGetArchRecord", "Invalid arch_record");
    }
  }
  else
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2338, (uint64_t)"BOMCopierSourceEntryGetArchRecord", "Invalid source_entry");
  }
  return 1;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeCount(uint64_t a1, _QWORD *a2)
{
  if (a1)
    return *(unsigned int *)(a1 + 208);
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2370, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeCount", "source_entry is NULL");
  return 0;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeName(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 208) > a2)
      return *(_QWORD *)(*(_QWORD *)(a1 + 216) + 24 * a2);
    BOMCopierErrorCapture(a3, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2395, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeName", "index is out of range");
  }
  else
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2389, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeName", "source_entry is NULL");
  }
  return 0;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeSize(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 208) > a2)
      return *(_QWORD *)(*(_QWORD *)(a1 + 216) + 24 * a2 + 8);
    BOMCopierErrorCapture(a3, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2420, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeSize", "index is out of range");
  }
  else
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2414, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeSize", "source_entry is NULL");
  }
  return 0;
}

ssize_t BOMCopierSourceEntryCopyExtendedAttribute(uint64_t a1, unsigned int a2, void *__dst, size_t __n, u_int32_t a5, _QWORD *a6)
{
  size_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  const char *v14;
  int v15;
  BOOL v16;
  int v17;

  if (!a1)
  {
    BOMCopierErrorCapture(a6, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2442, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "source_entry is NULL");
    return -1;
  }
  if (*(_DWORD *)(a1 + 208) <= a2)
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2448, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "index is out of range");
    return -1;
  }
  if (!__dst)
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2454, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "value is NULL");
    return -1;
  }
  v8 = __n;
  if (!__n)
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2460, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "size is 0");
    return -1;
  }
  v10 = *(_QWORD *)(a1 + 216);
  v11 = v10 + 24 * a2;
  if (__n + a5 > *(_QWORD *)(v11 + 8))
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2473, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "size + position are out of range");
    return -1;
  }
  v13 = *(_QWORD *)(v10 + 24 * a2 + 16);
  if (v13)
  {
    memcpy(__dst, (const void *)(v13 + a5), __n);
    return v8;
  }
  v14 = *(const char **)v11;
  v15 = string_compare(*(const char **)v11, "com.apple.decmpfs");
  if (string_compare(v14, "com.apple.ResourceFork"))
    v16 = v15 == 0;
  else
    v16 = 1;
  if (v16)
    v17 = 33;
  else
    v17 = 1;
  return getxattr(*(const char **)(a1 + 16), v14, __dst, v8, a5, v17);
}

uint64_t string_compare(const char *a1, const char *a2)
{
  size_t v4;
  size_t v5;
  size_t v6;

  v4 = strlen(a1);
  v5 = strlen(a2);
  if (v5 <= v4)
    v6 = v4;
  else
    v6 = v5;
  return strncmp(a1, a2, v6);
}

uint64_t BOMCopierSourceEntryGetACL(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v4;

  if (a1)
  {
    if (a2)
    {
      v4 = a1 + 224;
      result = *(_QWORD *)(a1 + 224);
      *a2 = *(_QWORD *)(v4 + 8);
      return result;
    }
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2516, (uint64_t)"BOMCopierSourceEntryGetACL", "acl_text_size is NULL");
  }
  else
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2510, (uint64_t)"BOMCopierSourceEntryGetACL", "source_entry is NULL");
  }
  return 0;
}

uint64_t BOMCopierSourceEntryGetQuarantine(uint64_t a1, _QWORD *a2)
{
  if (!a1)
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2536, (uint64_t)"BOMCopierSourceEntryGetQuarantine", "source_entry is NULL");
  return 0;
}

uint64_t BOMCopierSourceEntryCheckAccess(uint64_t a1, _QWORD *a2)
{
  int v3;
  int v4;
  int v5;
  uint64_t result;
  int v7;
  int *v8;

  if (!a1)
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2555, (uint64_t)"BOMCopierSourceEntryCheckAccess", "Invalid source_entry");
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)a1 - 1) > 3)
    return 0;
  v3 = *(_DWORD *)(a1 + 4);
  if (v3 == 6)
    v4 = 5;
  else
    v4 = 4;
  if (v3 == 9)
    v5 = 48;
  else
    v5 = 16;
  result = faccessat(-2, *(const char **)(a1 + 16), v4, v5);
  if ((_DWORD)result)
  {
    v7 = *__error();
    v8 = __error();
    strerror(*v8);
    BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2595, (uint64_t)"BOMCopierSourceEntryCheckAccess", "Could not faccess %s: %s");
    return 0xFFFFFFFFLL;
  }
  return result;
}

size_t BOMCopierSourceEntryRead(uint64_t a1, char *__dst, size_t a3, _QWORD *a4)
{
  char *v5;
  size_t v6;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  size_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;

  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2613, (uint64_t)"BOMCopierSourceEntryRead", "Invalid source_entry");
    return -1;
  }
  v5 = __dst;
  if (!__dst)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2619, (uint64_t)"BOMCopierSourceEntryRead", "Invalid buffer");
    return -1;
  }
  v6 = a3;
  if (!a3)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2625, (uint64_t)"BOMCopierSourceEntryRead", "Invalid num_bytes");
    return -1;
  }
  v9 = (_QWORD *)(a1 + 168);
  v8 = *(_QWORD *)(a1 + 168);
  if (!v8)
  {
    v12 = 0;
    goto LABEL_16;
  }
  v11 = *(_QWORD *)(a1 + 176);
  v10 = *(_QWORD *)(a1 + 184);
  if (v11 - v10 >= a3)
    v12 = a3;
  else
    v12 = v11 - v10;
  memcpy(__dst, (const void *)(v8 + v10), v12);
  v5 += v12;
  v6 -= v12;
  v13 = *(_QWORD *)(a1 + 176);
  v14 = *(_QWORD *)(a1 + 184) + v12;
  *(_QWORD *)(a1 + 184) = v14;
  if (v14 == v13)
  {
    *(_QWORD *)(a1 + 160) = 0;
    free(*(void **)(a1 + 168));
    *v9 = 0;
    v9[1] = 0;
    v9[2] = 0;
  }
  if (v6)
  {
LABEL_16:
    v15 = open_origin(a1, a4);
    if (v15)
    {
      BOMCopierErrorCapture(a4, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2672, (uint64_t)"BOMCopierSourceEntryRead", "Could not open the underlying origin");
    }
    else
    {
      v21 = read_from_origin(a1, v5, v6, a4, v16, v17, v18, v19);
      if (v21 != -1)
      {
        if (v21 >= 1)
          *(_QWORD *)(a1 + 328) += v21;
        v12 += v21;
        return v12;
      }
      BOMCopierErrorCapture(a4, -1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2684, (uint64_t)"BOMCopierSourceEntryRead", "Could not read from the underlying origin");
    }
    return -1;
  }
  return v12;
}

uint64_t open_origin(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  const char *v5;
  int v6;
  int v7;
  int v8;
  int *v9;
  char *v10;
  int v11;
  int *v12;

  if ((*(_DWORD *)a1 - 1) > 3 || *(_DWORD *)(a1 + 324) != -1)
    return 0;
  v5 = *(const char **)(a1 + 16);
  if (!v5)
  {
    BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4757, (uint64_t)"open_origin", "source entry has no actual path");
    return 0xFFFFFFFFLL;
  }
  v6 = open(*(const char **)(a1 + 16), 0);
  if (v6 == -1)
  {
    v11 = *__error();
    v12 = __error();
    strerror(*v12);
    BOMCopierErrorCapture(a2, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4764, (uint64_t)"open_origin", "Could not open %s: %s");
    return 0xFFFFFFFFLL;
  }
  v7 = v6;
  if (*(_BYTE *)(a1 + 321) && fcntl(v6, 48, 1))
  {
    v8 = *__error();
    v9 = __error();
    v10 = strerror(*v9);
    BOMCopierErrorCapture(a2, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4773, (uint64_t)"open_origin", "Could not F_NOCACHE %s: %s", v5, v10);
    return 1;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a1 + 324) = v7;
  }
  return result;
}

uint64_t read_from_origin(uint64_t a1, void *a2, size_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v11;
  int v12;
  int *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  BOOL v17;
  size_t v18;
  int *v20;
  AAFieldKey v21;
  int Blob;
  void *v23;

  switch(*(_DWORD *)a1)
  {
    case 0:
      v14 = *(_QWORD *)(a1 + 240);
      if (!v14)
        return 0;
      v15 = *(_QWORD *)(a1 + 248);
      v16 = *(_QWORD *)(a1 + 328);
      v17 = v15 > v16;
      v18 = v15 - v16;
      if (!v17)
        return 0;
      if (v18 >= a3)
        v11 = a3;
      else
        v11 = v18;
      memcpy(a2, (const void *)(v14 + v16), v11);
      return v11;
    case 1:
    case 2:
    case 3:
    case 4:
      v11 = read(*(_DWORD *)(a1 + 324), a2, a3);
      if (v11 != -1)
        return v11;
      v12 = *__error();
      v13 = __error();
      strerror(*v13);
      BOMCopierErrorCapture(a4, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4847, (uint64_t)"read_from_origin", "Could not read %ld bytes from file descriptor: %s");
      return -1;
    case 5:
      return archive_read_data();
    case 6:
      v23 = 0;
      v11 = data_archive_read_data(*(_QWORD *)(a1 + 272), a2, a3, &v23, a5, a6, a7, a8);
      if (v11 == -1)
      {
        v20 = __error();
        BOMCopierErrorCapture(a4, *v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4864, (uint64_t)"read_from_origin", "Could not read %ld bytes from data_archive: %s", a3, *((const char **)v23 + 4));
        release_error(v23);
      }
      return v11;
    case 7:
      v21 = *(AAFieldKey *)(a1 + 304);
      Blob = AAArchiveStreamReadBlob(*(AAArchiveStream *)(a1 + 288), v21, a2, a3);
      if (!Blob)
        return a3;
      BOMCopierErrorCapture(a4, Blob, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4876, (uint64_t)"read_from_origin", "Could not read %lu bytes from data_archive: %u");
      return -1;
    default:
      return -1;
  }
}

uint64_t BOMCopierSourceEntrySeek(uint64_t a1, unint64_t a2, void *a3, unint64_t a4, _QWORD *a5)
{
  void *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  off_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  off_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  size_t v27;
  int v28;
  int *v29;
  int v30;

  if (a1)
  {
    if ((a2 & 0x8000000000000000) == 0)
    {
      v11 = (_QWORD *)(a1 + 168);
      v10 = *(void **)(a1 + 168);
      if (v10)
      {
        v12 = *(_QWORD *)(a1 + 176);
        v13 = *(_QWORD *)(a1 + 184);
        if (v12 - v13 >= a2)
          v14 = a2;
        else
          v14 = v12 - v13;
        v15 = v14 + v13;
        *(_QWORD *)(a1 + 184) = v15;
        if (v15 == v12)
        {
          *(_QWORD *)(a1 + 160) = 0;
          free(v10);
          *v11 = 0;
          v11[1] = 0;
          v11[2] = 0;
        }
      }
      else
      {
        v14 = 0;
      }
      v17 = a2 - v14;
      if (!v17)
        return 0;
      v18 = open_origin(a1, a5);
      if ((_DWORD)v18)
      {
        v16 = v18;
        BOMCopierErrorCapture(a5, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2764, (uint64_t)"BOMCopierSourceEntrySeek", "Could not open the origin");
        return v16;
      }
      v23 = *(_QWORD *)(a1 + 328);
      v24 = v23 + v17;
      v25 = *(_DWORD *)a1;
      if ((*(_DWORD *)a1 - 1) < 4)
      {
        v23 = lseek(*(_DWORD *)(a1 + 324), v17, 1);
        if (v23 != -1)
        {
LABEL_29:
          *(_QWORD *)(a1 + 328) = v23;
          goto LABEL_39;
        }
        v28 = *__error();
        v29 = __error();
        strerror(*v29);
        BOMCopierErrorCapture(a5, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4969, (uint64_t)"seek_from_origin", "Could not lseek: %s");
      }
      else if ((v25 - 5) >= 3)
      {
        if (v25 || !*(_QWORD *)(a1 + 240))
        {
LABEL_39:
          if (v24 != v23)
          {
            v16 = 1;
            BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2776, (uint64_t)"BOMCopierSourceEntrySeek", "Could not seek forward in the origin");
            return v16;
          }
          goto LABEL_40;
        }
        if (v24 <= *(_QWORD *)(a1 + 248))
        {
LABEL_40:
          v16 = 0;
          *(_QWORD *)(a1 + 328) = v24;
          return v16;
        }
        BOMCopierErrorCapture(a5, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4938, (uint64_t)"seek_from_origin", "Cannot seek beyond the end of entry data");
      }
      else
      {
        if (*(_DWORD *)(a1 + 4) != 8)
          goto LABEL_39;
        if (a3)
        {
          if (a4)
          {
            v26 = 0;
            while (1)
            {
              v27 = v17 - v26 >= a4 ? a4 : v17 - v26;
              if (read_from_origin(a1, a3, v27, a5, v19, v20, v21, v22) != v27)
                break;
              v26 += v27;
              if (v26 == v17)
              {
                v23 = *(_QWORD *)(a1 + 328) + v17;
                goto LABEL_29;
              }
            }
            v30 = *__error();
            BOMCopierErrorCapture(a5, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5063, (uint64_t)"seek_from_origin", "Could not read %lld bytes from archive for seeking");
          }
          else
          {
            BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5041, (uint64_t)"seek_from_origin", "seek_buffer_size is 0");
          }
        }
        else
        {
          BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5035, (uint64_t)"seek_from_origin", "seek_buffer is NULL");
        }
      }
      v23 = -1;
      goto LABEL_39;
    }
    v16 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2719, (uint64_t)"BOMCopierSourceEntrySeek", "Invalid seek_amount");
  }
  else
  {
    v16 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2713, (uint64_t)"BOMCopierSourceEntrySeek", "source_entry is NULL");
  }
  return v16;
}

uint64_t BOMCopierSourceEntrySkip(uint64_t a1, void *a2, size_t a3, _QWORD *a4)
{
  size_t v7;
  void *v8;
  uint64_t v9;
  int v10;
  int v11;
  int *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  size_t v16;
  int v17;

  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2796, (uint64_t)"BOMCopierSourceEntrySkip", "Invalid source_entry");
    return 1;
  }
  if (a3)
    v7 = a3;
  else
    v7 = 0x4000000;
  v8 = a2;
  if (!a2)
  {
    v8 = malloc_type_malloc(v7, 0x37F4229AuLL);
    if (!v8)
    {
      v11 = *__error();
      v12 = __error();
      strerror(*v12);
      BOMCopierErrorCapture(a4, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2818, (uint64_t)"BOMCopierSourceEntrySkip", "Could not allocate %ld bytes for skip buffer: %s\n");
      return 1;
    }
  }
  if (*(_DWORD *)a1 != 7)
  {
    if (*(_DWORD *)a1 == 5 && skip_remaining_file_data(a1, v8, v7))
    {
      v9 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2834, (uint64_t)"BOMCopierSourceEntrySkip", "Could not skip remaining libarchive file data");
LABEL_11:
      if (v8 != a2)
        free(v8);
      return v9;
    }
    goto LABEL_29;
  }
  v10 = skip_remaining_file_data(a1, v8, v7);
  if (v10)
  {
    BOMCopierErrorCapture(a4, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2855, (uint64_t)"BOMCopierSourceEntrySkip", "Could not skip remaining AppleArchive file data");
    if (v8 != a2)
      free(v8);
    return 1;
  }
  if (*(_DWORD *)(a1 + 308))
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      v15 = *(_QWORD *)(a1 + 312) + v13;
      *(_DWORD *)(a1 + 304) = *(_DWORD *)v15;
      v16 = *(_QWORD *)(v15 + 16);
      if (BOMCopierSourceEntryRead(a1, (char *)v8, v16, a4) != v16)
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5866, (uint64_t)"parse_apple_archive_blobs", "Could not read AppleArchive blob data");
        goto LABEL_36;
      }
      if (*(_BYTE *)(*(_QWORD *)(a1 + 312) + v13 + 24))
      {
        v17 = *(_DWORD *)(a1 + 304);
        if (v17 == 4997953)
        {
          if (parse_apple_archive_acl_blob(a1, (uint8_t *)v8, v16, a4))
          {
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5881, (uint64_t)"parse_apple_archive_blobs", "Could not parse AppleArchive ACL blob: %d");
            goto LABEL_36;
          }
          v17 = *(_DWORD *)(a1 + 304);
        }
        if (v17 == 5521752 && parse_apple_archive_xat_blob(a1, (uint8_t *)v8, v16, a4))
          break;
      }
      ++v14;
      v13 += 32;
      if (v14 >= *(unsigned int *)(a1 + 308))
        goto LABEL_29;
    }
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5891, (uint64_t)"parse_apple_archive_blobs", "Could not read parse AppleArchive XAT blob: %d");
LABEL_36:
    v9 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2873, (uint64_t)"BOMCopierSourceEntrySkip", "Could not parse AppleArchive payload blobs");
    goto LABEL_11;
  }
LABEL_29:
  if (v8 != a2)
    free(v8);
  return 0;
}

uint64_t skip_remaining_file_data(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t Size;
  uint64_t v7;

  if (*(_DWORD *)(a1 + 4) != 8)
    return 0;
  Size = BOMCopierSourceEntryGetSize(a1);
  if (!Size || !BOMCopierSourceEntrySeek(a1, Size - *(_QWORD *)(a1 + 328), a2, a3, 0))
    return 0;
  v7 = 1;
  fwrite("Could not seek to the end of the source entry\n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return v7;
}

uint64_t BOMCopierSourceEntryClone(uint64_t a1, char *__s1, _BYTE *a3, _QWORD *a4)
{
  char *v8;
  char *v9;
  int *v10;
  uint64_t v11;
  int *v12;
  int *v14;
  int v15;
  const char *v16;
  int *v17;
  char *v18;
  stat v19;

  if (a1)
  {
    if (__s1)
    {
      if (a3)
      {
        *a3 = 0;
        if ((*(_DWORD *)a1 | 2) == 3)
        {
          if (*(_DWORD *)(a1 + 4) == 8)
          {
            v8 = strdup(__s1);
            if (v8)
            {
              v9 = v8;
              if (!dirname_r(__s1, v8))
              {
                v14 = __error();
                strerror(*v14);
                v11 = 1;
                BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2971, (uint64_t)"BOMCopierSourceEntryClone", "Could not dirname %s: %s");
                goto LABEL_18;
              }
              memset(&v19, 0, sizeof(v19));
              if (stat(v9, &v19))
              {
                v10 = __error();
                strerror(*v10);
                v11 = 1;
                BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2981, (uint64_t)"BOMCopierSourceEntryClone", "Could not stat %s: %s");
LABEL_18:
                free(v9);
                return v11;
              }
              free(v9);
              if (*(_DWORD *)(a1 + 64) == v19.st_dev)
              {
                if (!copyfile(*(const char **)(a1 + 16), __s1, 0, 0x200000Fu))
                {
                  v11 = 0;
                  *a3 = 1;
                  return v11;
                }
                if (*__error() != 45)
                {
                  v15 = *__error();
                  v16 = *(const char **)(a1 + 16);
                  v17 = __error();
                  v18 = strerror(*v17);
                  BOMCopierErrorCapture(a4, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2998, (uint64_t)"BOMCopierSourceEntryClone", "Could not clone %s to %s: %s", v16, __s1, v18);
                  return 1;
                }
              }
              return 0;
            }
            else
            {
              v12 = __error();
              strerror(*v12);
              v11 = 1;
              BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2964, (uint64_t)"BOMCopierSourceEntryClone", "Could not duplicate %s: %s");
            }
          }
          else
          {
            v11 = 1;
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2957, (uint64_t)"BOMCopierSourceEntryClone", "Entry is not a regular file");
          }
        }
        else
        {
          v11 = 1;
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2951, (uint64_t)"BOMCopierSourceEntryClone", "Origin %u does not support filesystem cloning");
        }
      }
      else
      {
        v11 = 22;
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2923, (uint64_t)"BOMCopierSourceEntryClone", "Invalid cloned");
      }
    }
    else
    {
      v11 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2917, (uint64_t)"BOMCopierSourceEntryClone", "Invalid path");
    }
  }
  else
  {
    v11 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2911, (uint64_t)"BOMCopierSourceEntryClone", "Invalid source_entry");
  }
  return v11;
}

uint64_t BOMCopierSourceEntrySetRoot(uint64_t a1, char a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = 0;
    *(_BYTE *)(a1 + 157) = a2;
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

BOOL BOMCopierSourceEntryIsRoot(uint64_t a1)
{
  if (a1)
    return *(_BYTE *)(a1 + 157) != 0;
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

BOOL BOMCopierSourceEntryIsResourceFork(_DWORD *a1)
{
  if (a1)
    return *a1 == 2;
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

BOOL BOMCopierSourceEntrySetPath(_QWORD *a1, char *__s)
{
  size_t v4;
  FILE *v5;
  const char *v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  void *v10;
  void *v11;
  void *v12;
  _BYTE *v13;

  if (a1)
  {
    if (!__s)
    {
      v5 = (FILE *)*MEMORY[0x24BDAC8D8];
      v6 = "Invalid entry_path";
      v7 = 1;
      v8 = 18;
      goto LABEL_7;
    }
    v4 = strlen(__s);
    if (v4 >= 0x400)
    {
      v5 = (FILE *)*MEMORY[0x24BDAC8D8];
      v6 = "entry_path is too long";
      v7 = 1;
      v8 = 22;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }
    v9 = v4;
    v10 = (void *)a1[3];
    if (v10)
    {
      free(v10);
      a1[3] = 0;
    }
    v11 = (void *)a1[4];
    if (v11)
    {
      free(v11);
      a1[4] = 0;
    }
    v12 = (void *)a1[5];
    if (v12)
    {
      free(v12);
      a1[5] = 0;
    }
    v13 = copy_string(__s, v9);
    a1[3] = v13;
    return v13 == 0;
  }
  else
  {
    v7 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v7;
}

BOOL BOMCopierSourceEntrySetParent(uint64_t a1, char *__s)
{
  size_t v4;
  FILE *v5;
  const char *v6;
  uint64_t v7;
  size_t v8;
  _BYTE *v9;

  if (a1)
  {
    if (!__s)
    {
      v5 = (FILE *)*MEMORY[0x24BDAC8D8];
      v6 = "Invalid entry_parent";
      v7 = 1;
      v8 = 20;
      goto LABEL_7;
    }
    v4 = strlen(__s);
    if (v4 >= 0x400)
    {
      v5 = (FILE *)*MEMORY[0x24BDAC8D8];
      v6 = "entry_path is too long";
      v7 = 1;
      v8 = 22;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }
    if (!*(_QWORD *)(a1 + 32))
      *(_QWORD *)(a1 + 32) = 0;
    v9 = copy_string(__s, v4);
    *(_QWORD *)(a1 + 32) = v9;
    return v9 == 0;
  }
  else
  {
    v7 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v7;
}

BOOL BOMCopierSourceEntrySetName(uint64_t a1, char *__s)
{
  size_t v4;
  FILE *v5;
  const char *v6;
  uint64_t v7;
  size_t v8;
  _BYTE *v9;

  if (a1)
  {
    if (!__s)
    {
      v5 = (FILE *)*MEMORY[0x24BDAC8D8];
      v6 = "Invalid entry_name";
      v7 = 1;
      v8 = 18;
      goto LABEL_7;
    }
    v4 = strlen(__s);
    if (v4 >= 0xFF)
    {
      v5 = (FILE *)*MEMORY[0x24BDAC8D8];
      v6 = "entry_name is too long";
      v7 = 1;
      v8 = 22;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }
    if (!*(_QWORD *)(a1 + 40))
      *(_QWORD *)(a1 + 40) = 0;
    v9 = copy_string(__s, v4);
    *(_QWORD *)(a1 + 40) = v9;
    return v9 == 0;
  }
  else
  {
    v7 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v7;
}

uint64_t BOMCopierSourceEntrySetData(uint64_t a1, const void *a2, size_t size)
{
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  FILE *v10;
  const char *v11;
  size_t v12;

  if (!a1)
  {
    v9 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return v9;
  }
  if (!a2)
  {
    v10 = (FILE *)*MEMORY[0x24BDAC8D8];
    v11 = "Invalid data";
    v9 = 1;
    v12 = 12;
LABEL_11:
    fwrite(v11, v12, 1uLL, v10);
    return v9;
  }
  if (!size)
  {
    v10 = (FILE *)*MEMORY[0x24BDAC8D8];
    v11 = "Invalid data size";
    v9 = 1;
    v12 = 17;
    goto LABEL_11;
  }
  v6 = *(void **)(a1 + 240);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(a1 + 248) = 0;
  }
  v7 = malloc_type_malloc(size, 0xF9D3B54FuLL);
  if (!v7)
    return 1;
  v8 = v7;
  memcpy(v7, a2, size);
  v9 = 0;
  *(_QWORD *)(a1 + 240) = v8;
  *(_QWORD *)(a1 + 248) = size;
  return v9;
}

uint64_t BOMCopierSourceEntrySetMode(uint64_t a1, __int16 a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = 0;
    *(_WORD *)(a1 + 92) = a2;
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = 0;
    *(_QWORD *)(a1 + 96) = a2;
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetUserID(uint64_t a1, int a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = 0;
    *(_DWORD *)(a1 + 84) = a2;
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetGroupID(uint64_t a1, int a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = 0;
    *(_DWORD *)(a1 + 88) = a2;
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetAccessTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a1)
  {
    v3 = 0;
    *(_QWORD *)(a1 + 104) = a2;
    *(_QWORD *)(a1 + 112) = a3;
  }
  else
  {
    v3 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v3;
}

uint64_t BOMCopierSourceEntrySetModificationTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a1)
  {
    v3 = 0;
    *(_QWORD *)(a1 + 120) = a2;
    *(_QWORD *)(a1 + 128) = a3;
  }
  else
  {
    v3 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v3;
}

uint64_t BOMCopierSourceEntrySetStatusTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a1)
  {
    v3 = 0;
    *(_QWORD *)(a1 + 136) = a2;
    *(_QWORD *)(a1 + 144) = a3;
  }
  else
  {
    v3 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v3;
}

BOOL BOMCopierSourceEntrySetSymlinkTarget(uint64_t a1, char *__s1)
{
  int v3;
  void *v6;
  char *v7;
  uint64_t v8;

  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (v3 == 18 || v3 == 9)
    {
      v6 = *(void **)(a1 + 48);
      if (v6)
        free(v6);
      v7 = strdup(__s1);
      *(_QWORD *)(a1 + 48) = v7;
      return v7 == 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v8 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v8;
}

BOOL BOMCopierSourceEntrySetAppleDoubleTarget(uint64_t a1, char *__s1)
{
  void *v4;
  char *v5;
  uint64_t v6;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 4) == 17)
    {
      v4 = *(void **)(a1 + 56);
      if (v4)
        free(v4);
      v5 = strdup(__s1);
      *(_QWORD *)(a1 + 56) = v5;
      return v5 == 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v6 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v6;
}

uint64_t BOMCopierSourceEntrySetQuarantine()
{
  return 0;
}

uint64_t BOMCopierSourceEntrySetSegmentedFile(uint64_t a1, char a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = 0;
    *(_BYTE *)(a1 + 158) = a2;
  }
  else
  {
    v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetHonorsSetuid(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 8) = a2;
  return 0;
}

BOOL BOMCopierSourceEntryIsSegmentedFile(uint64_t a1)
{
  if (a1)
    return *(_BYTE *)(a1 + 158) != 0;
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

BOOL BOMCopierSourceEntryIsStreamed(uint64_t a1)
{
  if (a1)
    return *(_BYTE *)(a1 + 156) != 0;
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0;
}

uint64_t BOMCopierSourceEntrySetOption(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  int v5;
  uint64_t v6;
  FILE *v7;
  const char *v8;
  size_t v9;

  if (!a1)
  {
    v6 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return v6;
  }
  if (!cf1)
  {
    v7 = (FILE *)*MEMORY[0x24BDAC8D8];
    v8 = "Invalid key";
    v6 = 1;
    v9 = 11;
LABEL_9:
    fwrite(v8, v9, 1uLL, v7);
    return v6;
  }
  if (!a3)
  {
    v7 = (FILE *)*MEMORY[0x24BDAC8D8];
    v8 = "Invalid value";
    v6 = 1;
    v9 = 13;
    goto LABEL_9;
  }
  if (CFEqual(cf1, CFSTR("DeleteOnFree")) != 1)
    return 1;
  v5 = CFEqual(a3, (CFTypeRef)*MEMORY[0x24BDBD270]);
  v6 = 0;
  *(_BYTE *)(a1 + 320) = v5 != 0;
  return v6;
}

uint64_t BOMCopierSourceEntryCompare(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8;
  FILE *v9;
  const char *v10;
  size_t v11;
  unsigned int v13;
  unsigned int v14;
  char *v15;
  char *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  char v23[255];
  char __bp[255];
  char __str[1024];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v9 = (FILE *)*MEMORY[0x24BDAC8D8];
    v10 = "Invalid source_entry";
    v11 = 20;
LABEL_9:
    fwrite(v10, v11, 1uLL, v9);
    return 0;
  }
  if (!a2)
  {
    v9 = (FILE *)*MEMORY[0x24BDAC8D8];
    v10 = "Invalid other_entry";
    v11 = 19;
    goto LABEL_9;
  }
  if (!a4)
  {
    v9 = (FILE *)*MEMORY[0x24BDAC8D8];
    v10 = "Invalid compare_handler";
    v11 = 23;
    goto LABEL_9;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, const char *))(a4 + 16))(a4, a1, a2, 0, "");
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    v8 = 1;
  }
  else
  {
    snprintf(__str, 0x400uLL, "entry_origin: %d vs %d", *(_DWORD *)a1, *(_DWORD *)a2);
    v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_origin", __str);
  }
  v13 = *(_DWORD *)(a1 + 4);
  v14 = *(_DWORD *)(a2 + 4);
  if (v13 != v14)
  {
    v15 = BOMCopierSourceEntryTypeString(v13);
    v16 = BOMCopierSourceEntryTypeString(v14);
    snprintf(__str, 0x400uLL, "entry_type: %s vs %s", v15, v16);
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_type", __str) & v8;
  }
  if ((compare_strings((int)"entry_resolved_path", *(char **)(a1 + 16), *(char **)(a2 + 16), __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_resolved_path", __str) & v8;
  if ((compare_strings((int)"entry_path", *(char **)(a1 + 24), *(char **)(a2 + 24), __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_path", __str) & v8;
  BOMCopierSourceEntryGetParent((_QWORD *)a1);
  BOMCopierSourceEntryGetParent((_QWORD *)a2);
  if ((compare_strings((int)"entry_parent", *(char **)(a1 + 32), *(char **)(a2 + 32), __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_parent", __str) & v8;
  BOMCopierSourceEntryGetName((_QWORD *)a1);
  BOMCopierSourceEntryGetName((_QWORD *)a2);
  if ((compare_strings((int)"entry_name", *(char **)(a1 + 40), *(char **)(a2 + 40), __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_name", __str) & v8;
  if ((compare_strings((int)"entry_symlink_target", *(char **)(a1 + 48), *(char **)(a2 + 48), __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_symlink_target", __str) & v8;
  v17 = *(_DWORD *)(a2 + 84);
  if (*(_DWORD *)(a1 + 84) != v17)
  {
    snprintf(__str, 0x400uLL, "entry_uid: %d vs %d", *(_DWORD *)(a1 + 84), v17);
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_uid", __str) & v8;
  }
  v18 = *(_DWORD *)(a2 + 88);
  if (*(_DWORD *)(a1 + 88) != v18)
  {
    snprintf(__str, 0x400uLL, "entry_gid: %d vs %d", *(_DWORD *)(a1 + 88), v18);
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_gid", __str) & v8;
  }
  v19 = *(unsigned __int16 *)(a1 + 92);
  if (v19 != *(unsigned __int16 *)(a2 + 92))
  {
    strmode(v19, __bp);
    strmode(*(unsigned __int16 *)(a2 + 92), v23);
    snprintf(__str, 0x400uLL, "entry_mode: %s vs %s", __bp, v23);
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_mode", __str) & v8;
  }
  v20 = *(_QWORD *)(a2 + 96);
  if (*(_QWORD *)(a1 + 96) != v20)
  {
    snprintf(__str, 0x400uLL, "entry_size: %lld vs %lld", *(_QWORD *)(a1 + 96), v20);
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_size", __str) & v8;
  }
  if ((compare_times("entry_access_time", (_QWORD *)(a1 + 104), (_QWORD *)(a2 + 104), a3, __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_access_time", __str) & v8;
  if ((compare_times("entry_modification_time", (_QWORD *)(a1 + 120), (_QWORD *)(a2 + 120), a3, __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_modification_time", __str) & v8;
  if ((compare_times("entry_status_time", (_QWORD *)(a1 + 136), (_QWORD *)(a2 + 136), a3, __str) & 1) == 0)
    v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_status_time", __str) & v8;
  if (*(unsigned __int8 *)(a1 + 157) != *(unsigned __int8 *)(a2 + 157))
  {
    if (*(_BYTE *)(a1 + 157))
      v21 = "yes";
    else
      v21 = "no";
    if (*(_BYTE *)(a2 + 157))
      v22 = "yes";
    else
      v22 = "no";
    snprintf(__str, 0x400uLL, "is_root: %s vs %s", v21, v22);
    return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "is_root", __str) & v8;
  }
  return v8;
}

uint64_t compare_strings(int a1, char *__s1, char *__s2, char *__str)
{
  uint64_t result;

  if (__s1 && !__s2 || !__s1 && __s2)
  {
    snprintf(__str, 0x400uLL, "%s is missing %s");
    return 0;
  }
  result = 1;
  if (__s1 && __s2)
  {
    if (!strcmp(__s1, __s2))
      return 1;
    snprintf(__str, 0x400uLL, "%s: %s vs %s");
    return 0;
  }
  return result;
}

uint64_t compare_times(const char *a1, _QWORD *a2, _QWORD *a3, unint64_t a4, char *__str)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (*a2 != *a3)
    snprintf(__str, 0x400uLL, "%s.tv_sec: %ld vs %ld", a1, *a2, *a3);
  v10 = a2[1];
  v11 = a3[1];
  v12 = v10 - v11;
  if (v10 == v11)
    return 1;
  if (v12 < 0)
    v12 = v11 - v10;
  if (v12 < a4)
    return 1;
  snprintf(__str, 0x400uLL, "%s.tv_nsec: %ld vs %ld (%ld margin)", a1, v10, a3[1], a4);
  return 0;
}

uint64_t BOMCopierSourceEntryGetHonorsSetuid(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8);
}

uint64_t parse_apple_archive_acl_blob(uint64_t a1, uint8_t *data, size_t data_size, _QWORD *a4)
{
  AAEntryACLBlob v6;
  AAEntryACLBlob_impl *v7;
  pid_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int *v12;
  char *v14;
  int *v15;
  char *v16;
  _acl *file;
  _acl *v18;
  char *v19;
  char *v20;
  ssize_t v21;
  int v22;
  int *v23;
  int v24;
  int *v25;
  const char *v26;
  ssize_t len_p;
  char *dir;

  v6 = AAEntryACLBlobCreateWithEncodedData(data, data_size);
  if (v6)
  {
    v7 = v6;
    dir = 0;
    v8 = getpid();
    asprintf(&dir, "/tmp/.BCSE.%u.T_XXXXXX", v8);
    if (dir)
    {
      v9 = mkstemp(dir);
      if (v9 == -1)
      {
        v14 = dir;
        v15 = __error();
        v16 = strerror(*v15);
        v26 = v14;
        v11 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5932, (uint64_t)"parse_apple_archive_acl_blob", "Could not mkstemp %s: %s\n", v26, v16);
        free(dir);
      }
      else
      {
        close(v9);
        v10 = AAEntryACLBlobApplyToPath(v7, dir, "", 0);
        if (v10)
        {
          BOMCopierErrorCapture(a4, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5942, (uint64_t)"parse_apple_archive_acl_blob", "Could not apply AppleArchive ACL blob to %s: %d\n");
        }
        else
        {
          file = acl_get_file(dir, ACL_TYPE_EXTENDED);
          if (file)
          {
            v18 = file;
            len_p = 0;
            v19 = acl_to_text(file, &len_p);
            acl_free(v18);
            if (v19)
            {
              v21 = len_p;
              v20 = dir;
              *(_QWORD *)(a1 + 224) = v19;
              *(_QWORD *)(a1 + 232) = v21;
              free(v20);
              AAEntryACLBlobClear(v7);
              AAEntryACLBlobDestroy(v7);
              return 0;
            }
            v24 = *__error();
            v25 = __error();
            strerror(*v25);
            BOMCopierErrorCapture(a4, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5962, (uint64_t)"parse_apple_archive_acl_blob", "Could not convert ACL to text for %s: %s");
          }
          else
          {
            v22 = *__error();
            v23 = __error();
            strerror(*v23);
            BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5950, (uint64_t)"parse_apple_archive_acl_blob", "Could not get ACL for %s: %s\n");
          }
        }
        free(dir);
        return 1;
      }
    }
    else
    {
      v12 = __error();
      strerror(*v12);
      v11 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5925, (uint64_t)"parse_apple_archive_acl_blob", "Could not create ACL file path: %s\n");
    }
  }
  else
  {
    v11 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5917, (uint64_t)"parse_apple_archive_acl_blob", "Could not decode AppleArchive ACL data blob");
  }
  return v11;
}

uint64_t parse_apple_archive_xat_blob(uint64_t a1, uint8_t *data, size_t data_size, _QWORD *a4)
{
  AAEntryXATBlob_impl *v6;
  AAEntryXATBlob_impl *v7;
  uint32_t EntryCount;
  uint32_t v9;
  uint32_t v10;
  size_t v11;
  char *v12;
  char *v13;
  uint8_t *v14;
  uint8_t *v15;
  int v16;
  char *v17;
  char **v18;
  uint64_t v19;
  int v20;
  int *v21;
  int v22;
  int *v23;
  char *v24;
  int v25;
  int *v26;
  size_t data_sizea;
  size_t key_length;

  v6 = AAEntryXATBlobCreateWithEncodedData(data, data_size);
  if (v6)
  {
    v7 = v6;
    EntryCount = AAEntryXATBlobGetEntryCount(v6);
    if (EntryCount)
    {
      v9 = EntryCount;
      v10 = 0;
      while (1)
      {
        data_sizea = 0;
        key_length = 0;
        if (AAEntryXATBlobGetEntry(v7, v10, 0, 0, &key_length, 0, 0, &data_sizea))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6020, (uint64_t)"parse_apple_archive_xat_blob", "Could not retrieve AppleArchive XAT entry sizes: %d");
          return 1;
        }
        v11 = key_length + 1;
        v12 = (char *)malloc_type_malloc(key_length + 1, 0x889BDEDBuLL);
        if (!v12)
        {
          v20 = *__error();
          v21 = __error();
          strerror(*v21);
          BOMCopierErrorCapture(a4, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6028, (uint64_t)"parse_apple_archive_xat_blob", "Could not allocate xattr name: %s");
          return 1;
        }
        v13 = v12;
        v14 = (uint8_t *)malloc_type_malloc(data_sizea, 0xEE5EB754uLL);
        if (!v14)
        {
          v22 = *__error();
          v23 = __error();
          v24 = strerror(*v23);
          BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6035, (uint64_t)"parse_apple_archive_xat_blob", "Could not allocate xattr value: %s", v24);
          goto LABEL_19;
        }
        v15 = v14;
        if (AAEntryXATBlobGetEntry(v7, v10, v11, v13, &key_length, data_sizea, v14, &data_sizea))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6043, (uint64_t)"parse_apple_archive_xat_blob", "Could not retrieve AppleArchive XAT entry: %d");
          goto LABEL_18;
        }
        v16 = *(_DWORD *)(a1 + 208);
        v17 = (char *)malloc_type_realloc(*(void **)(a1 + 216), 24 * (v16 + 1), 0x5B4B69D3uLL);
        if (!v17)
          break;
        v18 = (char **)&v17[24 * v16];
        *v18 = v13;
        v18[1] = (char *)data_sizea;
        v18[2] = (char *)v15;
        *(_DWORD *)(a1 + 208) = v16 + 1;
        *(_QWORD *)(a1 + 216) = v17;
        if (v9 == ++v10)
          goto LABEL_10;
      }
      v25 = *__error();
      v26 = __error();
      strerror(*v26);
      BOMCopierErrorCapture(a4, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6061, (uint64_t)"parse_apple_archive_xat_blob", "Could not allocate new_extended_attribute_list: %s");
LABEL_18:
      free(v15);
LABEL_19:
      free(v13);
      return 1;
    }
    else
    {
LABEL_10:
      AAEntryXATBlobClear(v7);
      AAEntryXATBlobDestroy(v7);
      return 0;
    }
  }
  else
  {
    v19 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5997, (uint64_t)"parse_apple_archive_xat_blob", "Could not decode AppleArchive XAT data blob");
  }
  return v19;
}

uint64_t xattr_compare(const char **a1, const char **a2)
{
  return string_compare(*a1, *a2);
}

uint64_t BOMFSOTypeInfoArchiveLength(uint64_t a1)
{
  int v1;
  uint64_t result;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(_DWORD *)a1 - 1;
  result = 1;
  switch(v1)
  {
    case 0:
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0)
        result = 5;
      else
        result = 1;
      break;
    case 1:
      return result;
    case 2:
      v4 = (unsigned __int16)(B_CKSUMS & *(_WORD *)(a1 + 40)) == 0;
      v5 = *(_QWORD *)(a1 + 64);
      if (v4)
        v6 = v5 + 1;
      else
        v6 = v5 + 5;
      result = v6 + 5;
      break;
    case 3:
      result = 5;
      break;
    default:
      result = -1;
      break;
  }
  return result;
}

uint64_t BOMFSOTypeInfoArchive(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  signed int v5;

  switch(*(_DWORD *)a2)
  {
    case 1:
      BOMStreamWriteUInt8(a1, 1);
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0)
        goto LABEL_10;
      goto LABEL_11;
    case 2:
      BOMStreamWriteUInt8(a1, 1);
      goto LABEL_11;
    case 3:
      BOMStreamWriteUInt8(a1, 1);
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0)
        BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 88));
      v5 = *(_DWORD *)(a2 + 64) + 1;
      BOMStreamWriteUInt32(a1, v5);
      BOMStreamWriteBuffer(a1, *(const void **)(a2 + 96), v5);
      goto LABEL_11;
    case 4:
      BOMStreamWriteUInt8(a1, 1);
LABEL_10:
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 88));
LABEL_11:
      result = 0;
      break;
    default:
      result = 1;
      break;
  }
  return result;
}

uint64_t BOMFSOTypeInfoUnarchive(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int UInt32;
  size_t v6;
  char *v7;
  char *v8;
  char *v9;

  v2 = 1;
  if (a1 && a2)
  {
    switch(*(_DWORD *)a2)
    {
      case 1:
        if (BOMStreamReadUInt8(a1) != 1)
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "File object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1;
        }
        if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0)
          goto LABEL_16;
        goto LABEL_24;
      case 2:
        if (BOMStreamReadUInt8(a1) == 1)
          goto LABEL_24;
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Directory object has an invalid version: 0x%X\nCannot dearchive.\n");
        return 1;
      case 3:
        if (BOMStreamReadUInt8(a1) != 1)
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Symlink object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1;
        }
        if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0)
          *(_DWORD *)(a2 + 88) = BOMStreamReadUInt32(a1);
        UInt32 = BOMStreamReadUInt32(a1);
        if (UInt32)
        {
          v6 = UInt32;
          v7 = (char *)BOM_malloc(UInt32);
          if (!v7)
            return 1;
          v8 = v7;
          BOMStreamReadBuffer(a1, v7, v6);
        }
        else
        {
          v2 = 1;
          v9 = (char *)BOM_malloc(1uLL);
          if (!v9)
            return v2;
          v8 = v9;
          *v9 = 0;
        }
        BOMFSObjectSetSymlinkTarget((_DWORD *)a2, v8, 0);
LABEL_24:
        v2 = 0;
        break;
      case 4:
        if (BOMStreamReadUInt8(a1) == 1)
        {
LABEL_16:
          v2 = 0;
          *(_DWORD *)(a2 + 88) = BOMStreamReadUInt32(a1);
        }
        else
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Device object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1;
        }
        return v2;
      default:
        return 1;
    }
  }
  return v2;
}

uint64_t BOMFSOTypeInfoInitialize(uint64_t a1, uint64_t a2)
{
  int v4;
  char *v5;
  int *v6;
  uint64_t v7;
  char *v8;
  int *v9;
  size_t v10;
  void *v11;
  char __s[1024];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v4 = BOMFSObjectType((unsigned int *)a1);
  if (v4 == 4)
  {
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 24);
  }
  else if (v4 == 3)
  {
    v7 = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 160) + 256))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8), *(_QWORD *)(a1 + 72), __s, 1024);
    if (v7 < 0 || v7 == 1024)
    {
      v8 = BOMExceptionHandlerMessage("can't access symlink for %s", *(const char **)(a1 + 72));
      v9 = __error();
      _BOMExceptionHandlerCall((uint64_t)v8, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 95, *v9);
      v7 = 0;
    }
    __s[v7] = 0;
    v10 = strlen(__s) + 1;
    v11 = BOM_malloc(v10);
    memmove(v11, __s, v10);
    BOMFSOTypeInfoSetSymlinkTarget((_DWORD *)a1, (char *)v11, 0);
  }
  else if (v4 == 1 && ((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0 && _getFileChecksum(a1))
  {
    v5 = BOMExceptionHandlerMessage("can't compute checksum for %s", *(const char **)(a1 + 72));
    v6 = __error();
    _BOMExceptionHandlerCall((uint64_t)v5, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 88, *v6);
  }
  return 0;
}

uint64_t _getFileChecksum(uint64_t a1)
{
  unint64_t v2;
  char *v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
  {
    v3 = &v5;
    return BOMCRC32ForBuffer((uint64_t)v3, (_DWORD *)(a1 + 88), v2);
  }
  v3 = *(char **)(a1 + 24);
  if (v3)
    return BOMCRC32ForBuffer((uint64_t)v3, (_DWORD *)(a1 + 88), v2);
  if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 160) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8), *(unsigned int *)(a1 + 16), 0, 0) < 0)return 0;
  else
    return BOMCRC32ForFileDesc(*(_DWORD *)(a1 + 16), (_DWORD *)(a1 + 88), v2);
}

_DWORD *BOMFSOTypeInfoSetSymlinkTarget(_DWORD *result, char *__s, int a3)
{
  _DWORD *v3;
  char *v5;
  size_t v6;
  void *v7;
  size_t v8;

  if (__s)
  {
    v3 = result;
    if (*result == 3)
    {
      v5 = __s;
      result = (_DWORD *)strlen(__s);
      v6 = (size_t)result;
      if (a3)
      {
        v7 = BOM_malloc((size_t)result + 1);
        result = memmove(v7, v5, v6);
        *((_BYTE *)v7 + v6) = 0;
        v5 = (char *)v7;
      }
      v3[22] = 0;
      *((_QWORD *)v3 + 12) = v5;
      if (((unsigned __int16)B_CKSUMS & (_WORD)v3[10]) != 0)
      {
        v8 = strlen(v5);
        result = (_DWORD *)BOMCRC32ForBuffer((uint64_t)v5, v3 + 22, v8);
      }
      *((_QWORD *)v3 + 8) = v6;
    }
  }
  return result;
}

uint64_t BOMFSOTypeInfoInitializeDeferred(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 a4)
{
  int v8;
  BOOL v9;
  char *v10;
  int *v11;
  uint64_t v12;
  char *v13;
  int *v14;
  size_t v15;
  void *v16;
  void *v17;
  _DWORD *v19;
  const char *v20;
  size_t v21;
  char __s[1024];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v8 = BOMFSObjectType((unsigned int *)a1);
  switch(v8)
  {
    case 4:
      if (((unsigned __int16)B_STAT & a4) != 0)
        *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 24);
      break;
    case 3:
      if (((unsigned __int16)B_STAT & a4) != 0)
      {
        v12 = (*(uint64_t (**)(_QWORD, uint64_t, char *, uint64_t))(*(_QWORD *)(a1 + 160) + 256))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8), a3, __s, 1024);
        if (v12 < 0 || v12 == 1024)
        {
          v13 = BOMExceptionHandlerMessage("can't access symlink for %s", *(const char **)(a1 + 72));
          v14 = __error();
          _BOMExceptionHandlerCall((uint64_t)v13, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 136, *v14);
          v12 = 0;
        }
        __s[v12] = 0;
        v15 = strlen(__s) + 1;
        v16 = BOM_malloc(v15);
        memmove(v16, __s, v15);
        v17 = *(void **)(a1 + 96);
        if (v17)
          free(v17);
        *(_QWORD *)(a1 + 96) = v16;
      }
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0 && (unsigned __int16)(B_CKSUMS & a4) != 0)
      {
        v19 = (_DWORD *)(a1 + 88);
        v20 = *(const char **)(a1 + 96);
        v21 = strlen(v20);
        BOMCRC32ForBuffer((uint64_t)v20, v19, v21);
      }
      break;
    case 1:
      v9 = ((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) == 0 || (unsigned __int16)(B_CKSUMS & a4) == 0;
      if (!v9 && _getFileChecksum(a1))
      {
        v10 = BOMExceptionHandlerMessage("can't compute checksum for %s", *(const char **)(a1 + 72));
        v11 = __error();
        _BOMExceptionHandlerCall((uint64_t)v10, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 127, *v11);
      }
      break;
  }
  return 0;
}

void BOMFSOTypeInfoRelease(uint64_t a1)
{
  void *v1;

  if (*(_DWORD *)a1 == 3)
  {
    v1 = *(void **)(a1 + 96);
    if (v1)
      free(v1);
  }
}

uint64_t BOMFSOTypeInfoCopy(uint64_t a1, uint64_t a2)
{
  size_t v4;
  char *v5;

  if (*(_DWORD *)a1 != 3)
    return 0;
  v4 = strlen(*(const char **)(a1 + 96)) + 1;
  v5 = (char *)BOM_malloc(v4);
  *(_QWORD *)(a2 + 96) = v5;
  if (v5)
  {
    strlcpy(v5, *(const char **)(a1 + 96), v4);
    return 0;
  }
  return 1;
}

uint64_t BOMFSOTypeInfoChecksum(_DWORD *a1)
{
  if ((*a1 | 2) == 3)
    return a1[22];
  else
    return 0;
}

uint64_t BOMFSOTypeInfoSymlinkTarget(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3)
    return *(_QWORD *)(a1 + 96);
  else
    return 0;
}

CFStringRef BOMFSOTypeInfoSymlinkTargetString(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3)
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], *(const char **)(a1 + 96), 0x8000100u);
  else
    return 0;
}

uint64_t BOMFSOTypeInfoDeviceID(_DWORD *a1)
{
  if (*a1 == 4)
    return a1[22];
  else
    return 0;
}

_DWORD *BOMFSOTypeInfoSetChecksum(_DWORD *result, int a2)
{
  if ((*result | 2) == 3)
    result[22] = a2;
  return result;
}

_DWORD *BOMFSOTypeInfoSetDeviceID(_DWORD *result, int a2)
{
  if (*result == 4)
    result[22] = a2;
  return result;
}

const char *BOMFSOTypeInfoSummary(uint64_t a1, int a2, int a3, int a4)
{
  char *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13[16];
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v8 = (char *)printBuffer;
  if (!printBuffer)
  {
    v8 = (char *)BOM_malloc(0x1000uLL);
    printBuffer = (uint64_t)v8;
  }
  if ((unsigned __int16)(B_INFOMASK & *(_WORD *)(a1 + 40)) == (unsigned __int16)B_PATHONLY)
  {
    snprintf(v8, 0x1000uLL, "%s\n");
  }
  else
  {
    switch(*(_DWORD *)a1)
    {
      case 1:
        *(_OWORD *)v13 = 0u;
        v14 = 0u;
        if (a4 == -1)
          goto LABEL_25;
        v10 = *(unsigned int *)(a1 + 104);
        if (!(_DWORD)v10)
          goto LABEL_13;
        v11 = *(_QWORD *)(a1 + 112) + 8;
        break;
      case 2:
        if (!a3)
          goto LABEL_23;
        snprintf(v8, 0x1000uLL, "%s\t%d/%d\n");
        return (const char *)printBuffer;
      case 3:
        v12 = *(_QWORD *)(a1 + 72);
        if (a3)
          snprintf(v8, 0x1000uLL, "%s\t%d/%d\t%lld\t%05u\t%s\n", v12);
        else
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%lld\t%05u\t%s\n", v12, *(unsigned __int16 *)(a1 + 42));
        return (const char *)printBuffer;
      case 4:
        if (a3)
LABEL_23:
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\n");
        else
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%d\n");
        return (const char *)printBuffer;
      default:
        return "";
    }
    while (*(_DWORD *)(v11 - 8) != a4)
    {
      v11 += 24;
      if (!--v10)
      {
LABEL_13:
        if (!a2)
          goto LABEL_27;
        goto LABEL_26;
      }
    }
LABEL_25:
    if (!a2)
      goto LABEL_27;
LABEL_26:
    ctime_r((const time_t *)(a1 + 56), v13);
    v8 = (char *)printBuffer;
LABEL_27:
    snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%llu\t%u%s%s%s", *(_QWORD *)(a1 + 72), *(unsigned __int16 *)(a1 + 42), *(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48));
  }
  return (const char *)printBuffer;
}

uint64_t BOMFSOTypeInfoSummaryWithFormat(uint64_t a1, char *a2, int a3)
{
  char *v6;
  int v7;
  char v8;
  int v9;
  int v10;
  size_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  const __CFString *v16;
  char *v17;
  int v18;
  const void *v19;
  const __CFString *Value;
  char *UTF8String;
  size_t v22;
  const char *v23;
  size_t v24;
  int v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  char *v30;
  const __CFString *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  size_t v36;
  uint64_t v37;
  char *v38;
  size_t v39;
  uint64_t v40;
  size_t v41;
  uint64_t v42;
  uint64_t v43;
  gid_t v44;
  group *v45;
  const char *gr_name;
  uid_t v47;
  passwd *v48;
  const char *pw_name;
  uid_t v50;
  passwd *v51;
  const char *v52;
  size_t v53;
  CFStringRef v54;
  __CFDictionary *v55;
  CFStringRef v56;
  const __CFString *v57;
  char *v58;
  gid_t v59;
  group *v60;
  char *p_str;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  char *v65;
  char v66;
  int v67;
  uint64_t v68;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unsigned int v74;
  time_t v75;
  char __str;
  _BYTE v77[7];
  char __bp[12];
  char __s[32];
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  v6 = (char *)printBuffer;
  if (!printBuffer)
  {
    v6 = (char *)BOM_malloc(0x1000uLL);
    printBuffer = (uint64_t)v6;
  }
  v75 = 0;
  v7 = BOMFSObjectType((unsigned int *)a1);
  v8 = *a2;
  if (*a2)
  {
    v9 = v7;
    v10 = 0;
    v72 = 0;
    v74 = v7 & 0xFFFFFFFD;
    v73 = v7;
    while (1)
    {
      if (v8 > 98)
      {
        switch(v8)
        {
          case 'c':
            if ((v10 & 0x1000) != 0)
              goto LABEL_129;
            v10 |= 0x1000u;
            if (v74 != 1)
              goto LABEL_71;
            if (a3 == -1)
            {
              v53 = printBuffer - (_QWORD)v6 + 4096;
            }
            else
            {
              v13 = *(unsigned int *)(a1 + 104);
              if (!(_DWORD)v13)
                goto LABEL_129;
              v14 = *(_QWORD *)(a1 + 112) + 16;
              while (*(_DWORD *)(v14 - 16) != a3)
              {
                v14 += 24;
                if (!--v13)
                  goto LABEL_129;
              }
              v53 = printBuffer - (_QWORD)v6 + 4096;
            }
            v12 = snprintf(v6, v53, "%u\t");
            goto LABEL_128;
          case 'f':
            if ((v10 & 1) != 0)
              goto LABEL_129;
            v10 |= 1u;
            v33 = printBuffer - (_QWORD)v6 + 4096;
            BOMFSObjectPathName(a1);
            goto LABEL_62;
          case 'g':
            if ((v10 & 0x10) != 0)
              goto LABEL_129;
            v10 |= 0x10u;
            v34 = printBuffer - (_QWORD)v6 + 4096;
            BOMFSObjectGroupID(a1);
            v35 = v6;
            v36 = v34;
            goto LABEL_74;
          case 'l':
            if ((v10 & 2) != 0)
              goto LABEL_129;
            v10 |= 2u;
            if (v9 != B_SymlinkType)
              goto LABEL_71;
            v33 = printBuffer - (_QWORD)v6 + 4096;
            BOMFSObjectSymlinkTarget(a1);
LABEL_62:
            v30 = v6;
            v26 = v33;
LABEL_63:
            v12 = snprintf(v30, v26, "%s\t");
            goto LABEL_128;
          case 'm':
LABEL_33:
            if ((v10 & 4) != 0)
              goto LABEL_129;
LABEL_34:
            v10 |= 4u;
            v24 = printBuffer - (_QWORD)v6 + 4096;
            BOMFSObjectMode(a1);
            v12 = snprintf(v6, v24, "%o\t");
            goto LABEL_128;
          case 's':
            if ((v10 & 0x400) != 0)
              goto LABEL_129;
            v10 |= 0x400u;
            if (BOMFSObjectType((unsigned int *)a1) == B_DirectoryType)
            {
              v12 = snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "\t", v70, v71);
              goto LABEL_128;
            }
            if (a3 == -1)
            {
              v12 = snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%llu\t");
              goto LABEL_128;
            }
            v42 = *(unsigned int *)(a1 + 104);
            if (!(_DWORD)v42)
              goto LABEL_129;
            v43 = *(_QWORD *)(a1 + 112) + 8;
            while (*(_DWORD *)(v43 - 8) != a3)
            {
              v43 += 24;
              if (!--v42)
                goto LABEL_129;
            }
            v39 = printBuffer - (_QWORD)v6 + 4096;
            v38 = v6;
            goto LABEL_70;
          case 't':
            if ((v10 & 0x100) != 0)
              goto LABEL_129;
            v10 |= 0x100u;
            if (v74 == 1)
            {
              v37 = printBuffer - (_QWORD)v6 + 4096;
              BOMFSObjectModTime(a1);
              v38 = v6;
              v39 = v37;
LABEL_70:
              v12 = snprintf(v38, v39, "%lu\t");
LABEL_128:
              v6 += v12;
            }
            else
            {
LABEL_71:
              *v6++ = 9;
            }
            goto LABEL_129;
          case 'u':
            if ((v10 & 0x40) != 0)
              goto LABEL_129;
            v10 |= 0x40u;
            v40 = printBuffer - (_QWORD)v6 + 4096;
            BOMFSObjectUserID(a1);
            v35 = v6;
            v36 = v40;
LABEL_74:
            v12 = snprintf(v35, v36, "%d\t");
            goto LABEL_128;
          default:
            goto LABEL_129;
        }
      }
      switch(v8)
      {
        case 'F':
          if ((v10 & 1) == 0)
          {
            v10 |= 1u;
            v11 = printBuffer - (_QWORD)v6 + 4096;
            BOMFSObjectPathName(a1);
            v12 = snprintf(v6, v11, "\"%s\"\t");
            goto LABEL_128;
          }
          goto LABEL_129;
        case 'G':
          if ((v10 & 0x20) == 0)
          {
            if (!BOMFSOTypeInfoSummaryWithFormat_groupNameHash)
              BOMFSOTypeInfoSummaryWithFormat_groupNameHash = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x24BDBD6B0]);
            v10 |= 0x20u;
            v19 = (const void *)(int)BOMFSObjectGroupID(a1);
            if (!CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v19))
            {
              v44 = BOMFSObjectGroupID(a1);
              v45 = getgrgid(v44);
              if (v45)
                gr_name = v45->gr_name;
              else
                gr_name = "<unknown>";
              goto LABEL_107;
            }
            Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v19);
            UTF8String = (char *)BOMCFStringGetUTF8String(Value);
            v6 += snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%s\t", UTF8String);
            free(UTF8String);
          }
          goto LABEL_129;
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
          goto LABEL_129;
        case 'L':
          if ((v10 & 2) == 0)
          {
            v10 |= 2u;
            if (v9 == B_SymlinkType)
            {
              v22 = printBuffer - (_QWORD)v6 + 4096;
              v23 = (const char *)BOMFSObjectSymlinkTarget(a1);
              v6 += snprintf(v6, v22, "\"%s\"\t", v23);
              goto LABEL_33;
            }
            *v6++ = 9;
            if ((v10 & 4) == 0)
              goto LABEL_34;
          }
          goto LABEL_129;
        case 'M':
          if ((v10 & 8) == 0)
          {
            v10 |= 8u;
            v25 = BOMFSObjectMode(a1);
            strmode(v25, __bp);
            v26 = printBuffer - (_QWORD)v6 + 4096;
            goto LABEL_49;
          }
          goto LABEL_129;
        case 'S':
          if ((v10 & 0x800) != 0)
            goto LABEL_129;
          v10 |= 0x800u;
          if (v74 != 1)
          {
            *v6 = 0;
            goto LABEL_129;
          }
          if (a3 == -1)
          {
            v29 = snprintf(&__str, 0xCuLL, "%lld");
          }
          else
          {
            v27 = *(unsigned int *)(a1 + 104);
            if (!(_DWORD)v27)
            {
LABEL_44:
              v29 = v72;
              if (!v72)
                goto LABEL_45;
              goto LABEL_112;
            }
            v28 = *(_QWORD *)(a1 + 112) + 8;
            while (*(_DWORD *)(v28 - 8) != a3)
            {
              v28 += 24;
              if (!--v27)
                goto LABEL_44;
            }
            v29 = snprintf(&__str, 0xCuLL, "%lu");
          }
          if (!v29)
          {
LABEL_45:
            v72 = 0;
            goto LABEL_129;
          }
LABEL_112:
          if (__str == 45)
          {
            --v29;
            *v6++ = __str;
            p_str = v77;
          }
          else
          {
            p_str = &__str;
          }
          v62 = (v29 - 1);
          if (v29 >= 1)
          {
            v63 = 0;
            v64 = v29 - 1;
            v65 = v6;
            while (1)
            {
              *v65++ = p_str[v63];
              if ((_DWORD)v62 != (_DWORD)v63 && (_DWORD)v62 - 3 * (v64 / 3) == (_DWORD)v63)
                break;
              if ((_DWORD)v62 == (_DWORD)v63)
              {
                v66 = 9;
                goto LABEL_122;
              }
LABEL_123:
              ++v63;
              --v64;
              v6 = v65;
              if (v62 + 1 == v63)
              {
                v72 = 0;
                v6 = v65;
                goto LABEL_129;
              }
            }
            v66 = 44;
LABEL_122:
            v65 = v6 + 2;
            v6[1] = v66;
            goto LABEL_123;
          }
          v72 = v29;
LABEL_129:
          v67 = *++a2;
          v8 = v67;
          if (!v67)
            goto LABEL_132;
          break;
        case 'T':
          if ((v10 & 0x200) == 0)
          {
            v10 |= 0x200u;
            if (v74 != 1)
              goto LABEL_71;
            v75 = BOMFSObjectModTime(a1);
            ctime_r(&v75, __s);
            __s[strlen(__s) - 1] = 0;
            v26 = printBuffer - (_QWORD)v6 + 4096;
LABEL_49:
            v30 = v6;
            goto LABEL_63;
          }
          goto LABEL_129;
        case 'U':
          if ((v10 & 0x80) == 0)
          {
            if (!BOMFSOTypeInfoSummaryWithFormat_userNameHash)
              BOMFSOTypeInfoSummaryWithFormat_userNameHash = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x24BDBD6B0]);
            v10 |= 0x80u;
            v19 = (const void *)(int)BOMFSObjectUserID(a1);
            if (!CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v19))
            {
              v47 = BOMFSObjectUserID(a1);
              v48 = getpwuid(v47);
              if (v48)
                pw_name = v48->pw_name;
              else
                pw_name = "<unknown>";
              v54 = CFStringCreateWithCString(0, pw_name, 0x8000100u);
              v6 += snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%s\t", pw_name);
              v55 = (__CFDictionary *)BOMFSOTypeInfoSummaryWithFormat_userNameHash;
              goto LABEL_108;
            }
            v31 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v19);
            v32 = (char *)BOMCFStringGetUTF8String(v31);
            v6 += snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%s\t", v32);
            free(v32);
          }
          goto LABEL_129;
        default:
          if (v8 == 47)
          {
            if ((v10 & 0x2000) == 0)
            {
              v10 |= 0x2000u;
              v41 = printBuffer - (_QWORD)v6 + 4096;
              BOMFSObjectUserID(a1);
              BOMFSObjectGroupID(a1);
              v12 = snprintf(v6, v41, "%d/%d\t");
              goto LABEL_128;
            }
          }
          else if (v8 == 63 && (v10 & 0x4000) == 0)
          {
            if (!BOMFSOTypeInfoSummaryWithFormat_userNameHash)
              BOMFSOTypeInfoSummaryWithFormat_userNameHash = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x24BDBD6B0]);
            v15 = (const void *)(int)BOMFSObjectUserID(a1);
            if (CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v15))
            {
              v16 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v15);
              v17 = (char *)BOMCFStringGetUTF8String(v16);
              v18 = snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%s/", v17);
              free(v17);
            }
            else
            {
              v50 = BOMFSObjectUserID(a1);
              v51 = getpwuid(v50);
              if (v51)
                v52 = v51->pw_name;
              else
                v52 = "<unknown>";
              v56 = CFStringCreateWithCString(0, v52, 0x8000100u);
              v18 = snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%s/", v52);
              CFDictionarySetValue((CFMutableDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v15, v56);
              CFRelease(v56);
            }
            if (!BOMFSOTypeInfoSummaryWithFormat_groupNameHash)
              BOMFSOTypeInfoSummaryWithFormat_groupNameHash = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x24BDBD6B0]);
            v10 |= 0x4000u;
            v6 += v18;
            v19 = (const void *)(int)BOMFSObjectGroupID(a1);
            if (CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v19))
            {
              v57 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v19);
              v58 = (char *)BOMCFStringGetUTF8String(v57);
              v6 += snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%s\t", v58);
              free(v58);
            }
            else
            {
              v59 = BOMFSObjectGroupID(a1);
              v60 = getgrgid(v59);
              if (v60)
                gr_name = v60->gr_name;
              else
                gr_name = "<unknown>";
LABEL_107:
              v54 = CFStringCreateWithCString(0, gr_name, 0x8000100u);
              v6 += snprintf(v6, printBuffer - (_QWORD)v6 + 4096, "%s\t", gr_name);
              v55 = (__CFDictionary *)BOMFSOTypeInfoSummaryWithFormat_groupNameHash;
LABEL_108:
              CFDictionarySetValue(v55, v19, v54);
              CFRelease(v54);
            }
            v9 = v73;
          }
          goto LABEL_129;
      }
    }
  }
LABEL_132:
  v68 = printBuffer;
  if ((unint64_t)v6 > printBuffer)
  {
    *--v6 = 0;
    v68 = printBuffer;
  }
  snprintf(v6, v68 - (_QWORD)v6 + 4096, "\n");
  return printBuffer;
}

_DWORD *BOMFSOTypeInfoParseSummaryWithSys(const char *a1, void *a2)
{
  char *v3;
  uint64_t v4;
  char *v5;
  uint64_t i;
  char *v7;
  char *v8;
  char *v9;
  __int16 v10;
  __int16 v11;
  int v12;
  _DWORD *v13;
  _DWORD *v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v19;
  char *__endptr;
  char *__stringp;
  char *__s[2];
  char *__str[2];
  char *v24[2];
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v25 = 0u;
  v26 = 0u;
  *(_OWORD *)__str = 0u;
  *(_OWORD *)v24 = 0u;
  *(_OWORD *)__s = 0u;
  v3 = strdup(a1);
  v4 = 0;
  __endptr = 0;
  __stringp = v3;
  v19 = 0;
  while (1)
  {
    v5 = strsep(&__stringp, "\t");
    __s[v4] = v5;
    if (!v5)
      break;
    if (++v4 == 10)
      goto LABEL_42;
  }
  if ((_DWORD)v4)
  {
    if ((_DWORD)v4 != 10)
    {
      for (i = 0; i != v4; ++i)
      {
        if (!*__s[i])
        {
          warnx("Empty field in summary");
          goto LABEL_45;
        }
      }
      if (v4 <= 1)
        goto LABEL_43;
      v7 = __s[0];
      v8 = strrchr(__s[0], 47);
      if (v8)
        v9 = v8 + 1;
      else
        v9 = v7;
      v10 = strtol(__s[1], &__endptr, 8);
      if (*__endptr)
      {
LABEL_17:
        v13 = 0;
      }
      else
      {
        v11 = v10;
        v12 = BOMFSObjectTypeForMode(v10);
        switch(v12)
        {
          case 1:
            if ((_DWORD)v4 != 5)
              goto LABEL_17;
            break;
          case 2:
            if ((_DWORD)v4 != 3)
              goto LABEL_17;
            break;
          case 3:
            if ((_DWORD)v4 != 6)
              goto LABEL_17;
            break;
          case 4:
            if ((_DWORD)v4 != 4)
              goto LABEL_17;
            break;
          default:
            goto LABEL_17;
        }
        if (!a2)
          a2 = BomSys_default();
        v14 = BOMFSObjectNewWithSys(v12, a2);
        v13 = v14;
        if (!v14)
        {
          warnx("Can't create FSO for %s");
LABEL_40:
          if (v3)
            goto LABEL_46;
          goto LABEL_47;
        }
        BOMFSObjectSetFlags((uint64_t)v14, B_CKSUMS | B_STAT);
        BOMFSObjectSetPathName((uint64_t)v13, v7, 1);
        BOMFSObjectSetShortName((uint64_t)v13, v9, 1);
        BOMFSObjectSetMode((uint64_t)v13, v11);
        if (sscanf(__str[0], "%d/%d", (char *)&v19 + 4, &v19) == 2)
        {
          BOMFSObjectSetUserID((uint64_t)v13, SHIDWORD(v19));
          BOMFSObjectSetGroupID((uint64_t)v13, v19);
          switch(v12)
          {
            case 1:
LABEL_30:
              v15 = strtoll(__str[1], &__endptr, 10);
              if (!*__endptr)
              {
                BOMFSObjectSetSize((uint64_t)v13, v15);
                v16 = strtoul(v24[0], &__endptr, 10);
                if (!*__endptr)
                {
                  BOMFSObjectSetChecksum(v13, v16);
                  if (v12 == 3)
                    BOMFSObjectSetSymlinkTarget(v13, v24[1], 1);
                  goto LABEL_34;
                }
              }
              break;
            case 4:
              v17 = strtoul(__str[1], &__endptr, 10);
              if (!*__endptr)
              {
                BOMFSObjectSetDeviceID(v13, v17);
                if (!v3)
                  return v13;
                goto LABEL_38;
              }
              break;
            case 3:
              goto LABEL_30;
            default:
LABEL_34:
              if (!v3)
                return v13;
LABEL_38:
              free(v3);
              return v13;
          }
        }
      }
      warnx("Improperly formatted field");
      goto LABEL_40;
    }
LABEL_42:
    warnx("Improperly formatted input, too many fields");
  }
  else
  {
LABEL_43:
    warnx("Not enough fields");
  }
LABEL_45:
  v13 = 0;
  if (v3)
LABEL_46:
    free(v3);
LABEL_47:
  if (v13)
  {
    BOMFSObjectFree((uint64_t)v13);
    return 0;
  }
  return v13;
}

uint64_t BOMFSOArchInfoArchiveLength(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*(_DWORD *)a1 != 1 || !((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT))
    return 0;
  v1 = *(int *)(a1 + 104);
  v2 = 4 * v1;
  v3 = 12 * v1;
  if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0)
    v4 = v2;
  else
    v4 = 0;
  return v3 + v4 + 5;
}

uint64_t BOMFSOArchInfoArchive(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)a2 == 1)
  {
    if ((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a2 + 40)) >> B_ARCHOFFT)
    {
      v4 = *(unsigned int *)(a2 + 104);
      BOMStreamWriteUInt8(a1, 1);
      BOMStreamWriteUInt32(a1, v4);
      if ((int)v4 >= 1)
      {
        v5 = 0;
        v6 = 24 * v4;
        do
        {
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(_QWORD *)(a2 + 112) + v5));
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(_QWORD *)(a2 + 112) + v5 + 4));
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(_QWORD *)(a2 + 112) + v5 + 8));
          if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0)
            BOMStreamWriteUInt32(a1, *(_DWORD *)(*(_QWORD *)(a2 + 112) + v5 + 16));
          v5 += 24;
        }
        while (v6 != v5);
      }
    }
  }
  return 0;
}

uint64_t BOMFSOArchInfoUnarchive(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int UInt8;
  int UInt32;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  result = 1;
  if (!a1 || !a2)
    return result;
  if (*(_DWORD *)a2 != 1 || !((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a2 + 40)) >> B_ARCHOFFT))
    return 0;
  UInt8 = BOMStreamReadUInt8(a1);
  if (UInt8 != 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Architecture info has an invalid version: 0x%X\nCannot dearchive.\n", UInt8);
    return 1;
  }
  UInt32 = BOMStreamReadUInt32(a1);
  *(_DWORD *)(a2 + 104) = UInt32;
  v7 = BOM_malloc(24 * UInt32);
  *(_QWORD *)(a2 + 112) = v7;
  if (!v7)
    return 1;
  if (UInt32 < 1)
    return 0;
  v8 = 0;
  v9 = 24 * UInt32;
  do
  {
    *(_DWORD *)(*(_QWORD *)(a2 + 112) + v8) = BOMStreamReadUInt32(a1);
    *(_DWORD *)(*(_QWORD *)(a2 + 112) + v8 + 4) = BOMStreamReadUInt32(a1);
    *(_QWORD *)(*(_QWORD *)(a2 + 112) + v8 + 8) = BOMStreamReadUInt32(a1);
    if ((*(_WORD *)(a2 + 40) & (unsigned __int16)B_CKSUMS) != 0)
      *(_DWORD *)(*(_QWORD *)(a2 + 112) + v8 + 16) = BOMStreamReadUInt32(a1);
    result = 0;
    v8 += 24;
  }
  while (v9 != v8);
  return result;
}

uint64_t BOMStorageNew(const char *a1, uint64_t a2)
{
  return BOMStorageNewWithOptionsAndSys(a1, a2, 0);
}

uint64_t BOMStorageNewWithOptionsAndSys(const char *a1, uint64_t a2, uint64_t (**a3)(_QWORD, const char *, uint64_t, uint64_t))
{
  uint64_t (**v3)(_QWORD, const char *, uint64_t, uint64_t);
  uint64_t v5;
  uint64_t v6;
  FILE *v8;
  int *v9;
  char *v10;
  _BYTE v11[1028];
  int v12;
  uint64_t (**v13)(_QWORD, const char *, uint64_t, uint64_t);
  uint64_t v14;

  v3 = a3;
  v14 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    v3 = (uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t))BomSys_default();
  v5 = v3[2](v3[1], a1, 1538, 420);
  if ((_DWORD)v5 == -1)
  {
    v8 = (FILE *)*MEMORY[0x24BDAC8D8];
    v9 = __error();
    v10 = strerror(*v9);
    fprintf(v8, "can't open %s: %s\n", a1, v10);
  }
  else
  {
    v6 = v5;
    bzero(v11, 0x460uLL);
    v12 = v6;
    v13 = v3;
    if (!_WriteRootPage((uint64_t)v11))
    {
      ((void (*)(uint64_t (*)(_QWORD, const char *, uint64_t, uint64_t), uint64_t))v3[4])(v3[1], v6);
      return BOMStorageOpenWithSys(a1, 1, v3);
    }
  }
  return 0;
}

uint64_t BOMStorageNewWithSys(const char *a1, uint64_t (**a2)(_QWORD, const char *, uint64_t, uint64_t))
{
  return BOMStorageNewWithOptionsAndSys(a1, (uint64_t)a2, a2);
}

uint64_t BOMStorageNewWithOptions(const char *a1, uint64_t a2)
{
  return BOMStorageNewWithOptionsAndSys(a1, a2, 0);
}

uint64_t _WriteRootPage(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  FILE *v6;
  int *v7;
  char *v8;

  if (a1)
    v2 = *(_QWORD *)(a1 + 1120);
  else
    v2 = 0;
  v3 = 1;
  v4 = BOMStreamWithFileAndSys(*(_DWORD *)(a1 + 1028), 0, 0x200uLL, 1, 0, (void *)v2);
  if (v4)
  {
    v5 = v4;
    BOMStreamWriteUInt32(v4, 0x424F4D53u);
    BOMStreamWriteUInt32(v5, 0x746F7265u);
    BOMStreamWriteUInt32(v5, 1u);
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1056));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1060));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1064));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1096));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1100));
    v3 = BOMStreamFree(v5);
    if ((*(unsigned int (**)(_QWORD, _QWORD))(v2 + 72))(*(_QWORD *)(v2 + 8), *(unsigned int *)(a1 + 1028)))
    {
      v6 = (FILE *)*MEMORY[0x24BDAC8D8];
      v7 = __error();
      v8 = strerror(*v7);
      fprintf(v6, "fsync: %s\n", v8);
      return 1;
    }
  }
  return v3;
}

uint64_t BOMStorageOpenWithSys(const char *a1, int a2, void *a3)
{
  void *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int UInt32;
  void *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  FILE *v18;
  int *v19;
  char *v20;
  FILE *v21;
  int *v22;
  const char *v23;
  FILE *v24;
  char *v25;
  int *v26;
  FILE *v28;
  int *v29;
  char *v30;
  unsigned int v31;
  int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  FILE *v45;
  int *v46;
  char *v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;

  v3 = a3;
  if (!a3)
    v3 = BomSys_default();
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v49 = 0u;
  v6 = (*((uint64_t (**)(_QWORD, const char *, _QWORD, uint64_t))v3 + 2))(*((_QWORD *)v3 + 1), a1, 2 * (a2 != 0), 420);
  if ((_DWORD)v6 != -1)
  {
    v7 = v6;
    if ((*((unsigned int (**)(_QWORD, uint64_t, __int128 *))v3 + 11))(*((_QWORD *)v3 + 1), v6, &v49) == -1)
    {
      v21 = (FILE *)*MEMORY[0x24BDAC8D8];
      v22 = __error();
      v47 = strerror(*v22);
      v23 = "fstat: %s\n";
LABEL_15:
      v24 = v21;
LABEL_19:
      fprintf(v24, v23, v47, v48, v49, v50, v51, v52, v53, v54);
      goto LABEL_20;
    }
    v8 = BOMStreamWithFileAndSys(v7, 0, 0x200uLL, 0, 0, v3);
    if (!v8)
    {
      v24 = (FILE *)*MEMORY[0x24BDAC8D8];
      v47 = (char *)a1;
      v23 = "can't read from %s\n";
      goto LABEL_19;
    }
    v9 = v8;
    if (BOMStreamReadUInt32(v8) == 1112493395 && BOMStreamReadUInt32(v9) == 1953460837)
    {
      UInt32 = BOMStreamReadUInt32(v9);
      if (UInt32 == 1)
      {
        v11 = BOM_malloc(0x468uLL);
        v12 = (uint64_t)v11;
        if (!v11)
        {
          v28 = (FILE *)*MEMORY[0x24BDAC8D8];
          v29 = __error();
          v30 = strerror(*v29);
          fprintf(v28, "malloc: %s\n", v30);
          BOMStreamFree(v9);
          (*((void (**)(_QWORD, uint64_t))v3 + 4))(*((_QWORD *)v3 + 1), v7);
          return v12;
        }
        bzero(v11, 0x468uLL);
        *(_QWORD *)(v12 + 1120) = v3;
        *(_DWORD *)(v12 + 1028) = v7;
        v13 = v55;
        *(_DWORD *)(v12 + 1032) = v55;
        *(_DWORD *)(v12 + 1036) = v13;
        *(_BYTE *)(v12 + 1052) = a2;
        *(_BYTE *)(v12 + 1053) = 0;
        *(_DWORD *)(v12 + 1056) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1060) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1064) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1096) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1100) = BOMStreamReadUInt32(v9);
        BOMStreamFree(v9);
        v14 = *(_DWORD *)(v12 + 1060);
        v15 = *(_DWORD *)(v12 + 1064);
        v16 = __CFADD__(v15, v14);
        v17 = v15 + v14;
        if (!v16)
        {
          v31 = *(_DWORD *)(v12 + 1032);
          if (v17 > v31)
          {
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; admin range is outside file\n");
            goto LABEL_20;
          }
          v32 = *(_DWORD *)(v12 + 1096);
          v33 = *(_DWORD *)(v12 + 1100);
          v16 = __CFADD__(v33, v32);
          v34 = v33 + v32;
          if (v16)
          {
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; overflow of toc offset+size\n");
            goto LABEL_20;
          }
          if (v34 > v31)
          {
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; toc range is outside file\n");
            goto LABEL_20;
          }
          if (a2)
          {
            if (v31 <= 0x4000)
              v35 = 0x4000;
            else
              v35 = *(_DWORD *)(v12 + 1032);
            *(_DWORD *)(v12 + 1048) = v35;
            _CreateMapAddress(v12, v35);
            v36 = *(_QWORD *)(v12 + 1040);
            if (!v36)
              goto LABEL_20;
            *(_BYTE *)(v12 + 1053) = 1;
            v37 = *(unsigned int *)(v12 + 1096);
            if ((_DWORD)v37)
            {
              v38 = BOMStreamWithFileAndSys(*(_DWORD *)(v12 + 1028), v37, *(unsigned int *)(v12 + 1100), 0, (char *)(v36 + v37), v3);
              if (!v38)
                goto LABEL_20;
              BOMStreamFree(v38);
            }
            _CreateBlockTable(v12);
            v39 = *(unsigned int *)(v12 + 1060);
            if ((_DWORD)v39)
            {
              v40 = BOMStreamWithFileAndSys(v7, v39, *(unsigned int *)(v12 + 1064), 0, 0, v3);
LABEL_45:
              v43 = v40;
              if (!v40)
              {
                v45 = (FILE *)*MEMORY[0x24BDAC8D8];
                v46 = __error();
                strerror(*v46);
                fprintf(v45, "can't read from %s: %s\n");
                goto LABEL_20;
              }
              if (_ReadBlockTable(v12, v40) || _ReadFreeList(v12, v43))
                goto LABEL_20;
              BOMStreamFree(v43);
LABEL_50:
              __strlcpy_chk();
              return v12;
            }
            goto LABEL_49;
          }
          v41 = (*((uint64_t (**)(_QWORD, _QWORD))v3 + 40))(*((_QWORD *)v3 + 1), 0);
          if (v41 != -1)
          {
            *(_DWORD *)(v12 + 1048) = *(_DWORD *)(v12 + 1032);
            *(_QWORD *)(v12 + 1040) = v41;
            *(_BYTE *)(v12 + 1053) = 1;
            _CreateBlockTable(v12);
            v42 = *(unsigned int *)(v12 + 1060);
            if ((_DWORD)v42)
            {
              v40 = (uint64_t)BOMStreamWithAddress(*(_QWORD *)(v12 + 1040) + v42, *(unsigned int *)(v12 + 1064), 0);
              goto LABEL_45;
            }
LABEL_49:
            *(_QWORD *)(v12 + 1088) = _NewFreeList();
            goto LABEL_50;
          }
          v21 = (FILE *)*MEMORY[0x24BDAC8D8];
          v44 = __error();
          v47 = strerror(*v44);
          v23 = "mmap: %s\n";
          goto LABEL_15;
        }
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; overflow of admin offset+size\n");
LABEL_20:
        (*((void (**)(_QWORD, uint64_t))v3 + 4))(*((_QWORD *)v3 + 1), v7);
        return 0;
      }
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s has an unknown version: 0x%X\n", a1, UInt32);
    }
    else
    {
      v25 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", a1);
      v26 = __error();
      _BOMExceptionHandlerCall((uint64_t)v25, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 323, *v26);
    }
    BOMStreamFree(v9);
    goto LABEL_20;
  }
  v18 = (FILE *)*MEMORY[0x24BDAC8D8];
  v19 = __error();
  v20 = strerror(*v19);
  fprintf(v18, "can't open %s: %s\n", a1, v20);
  return 0;
}

uint64_t BOMStorageNewInRAM()
{
  char *v0;
  uint64_t v1;
  unsigned int v2;

  v0 = (char *)BOM_malloczero(0x468uLL);
  v1 = (uint64_t)v0;
  if (v0)
  {
    *(_QWORD *)(v0 + 1028) = 0x200FFFFFFFFLL;
    *((_DWORD *)v0 + 259) = 512;
    *((_WORD *)v0 + 526) = 1;
    *((_QWORD *)v0 + 140) = BomSys_default();
    if (*(_DWORD *)(v1 + 1032) <= 0x4000u)
      v2 = 0x4000;
    else
      v2 = *(_DWORD *)(v1 + 1032);
    *(_DWORD *)(v1 + 1048) = v2;
    _CreateMapAddress(v1, v2);
    if (*(_QWORD *)(v1 + 1040))
    {
      *(_BYTE *)(v1 + 1053) = 1;
      _CreateBlockTable(v1);
      __strlcpy_chk();
      *(_QWORD *)(v1 + 1088) = _NewFreeList();
    }
    else
    {
      free((void *)v1);
      return 0;
    }
  }
  return v1;
}

uint64_t _CreateMapAddress(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v3 = (unint64_t)a2 % *MEMORY[0x24BDB03C8];
  if (v3)
    v4 = *MEMORY[0x24BDB03C8] - v3;
  else
    v4 = 0;
  v5 = v4 + a2;
  result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 1120)
                                                                                                 + 320))(*(_QWORD *)(*(_QWORD *)(a1 + 1120) + 8), 0, v5, 3, 4098, 0xFFFFFFFFLL, 0);
  if (result == -1)
    v7 = 0;
  else
    v7 = result;
  *(_QWORD *)(a1 + 1040) = v7;
  *(_DWORD *)(a1 + 1048) = v5;
  return result;
}

uint64_t _CreateBlockTable(uint64_t a1)
{
  unint64_t v2;
  vm_size_t v3;
  uint64_t result;

  v2 = 0x4000uLL % *MEMORY[0x24BDB03C8];
  if (v2)
    v3 = *MEMORY[0x24BDB03C8] - v2 + 0x4000;
  else
    v3 = 0x4000;
  result = vm_allocate(*MEMORY[0x24BDAEC58], (vm_address_t *)(a1 + 1072), v3, 1);
  if ((_DWORD)result)
    *(_QWORD *)(a1 + 1072) = 0;
  *(_DWORD *)(a1 + 1080) = v3;
  return result;
}

_DWORD *_NewFreeList()
{
  const __CFAllocator *v0;
  __CFDictionary *Mutable;
  char *v2;
  CFStringRef v3;
  _DWORD *v4;

  v0 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v2 = getenv("BOMFREELISTIMPLEMENTATION");
  if (v2)
  {
    v3 = CFStringCreateWithCString(v0, v2, 0x8000100u);
    CFDictionaryAddValue(Mutable, CFSTR("Implementation"), v3);
    CFRelease(v3);
  }
  v4 = _BOMFreeListAllocate(Mutable);
  CFRelease(Mutable);
  return v4;
}

uint64_t BOMStorageOpen(const char *a1, int a2)
{
  return BOMStorageOpenWithSys(a1, a2, 0);
}

uint64_t _ReadBlockTable(uint64_t a1, uint64_t a2)
{
  unsigned int UInt32;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  FILE *v12;
  int *v13;
  char *v14;

  UInt32 = BOMStreamReadUInt32(a2);
  if (!UInt32)
    return 0;
  v5 = UInt32;
  if (!(UInt32 >> 29) && *(unsigned int *)(a1 + 1064) >= 8 * (unint64_t)UInt32)
  {
    _ExpandBlockTable(a1, 12 * UInt32);
    if (!*(_QWORD *)(a1 + 1072))
    {
      v12 = (FILE *)*MEMORY[0x24BDAC8D8];
      v13 = __error();
      v14 = strerror(*v13);
      fprintf(v12, "realloc: %s\n", v14);
      return 1;
    }
    v7 = 0;
    *(_DWORD *)(a1 + 1068) = v5;
    v8 = 12 * v5;
    do
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 1072) + v7) = BOMStreamReadUInt32(a2);
      v9 = BOMStreamReadUInt32(a2);
      v10 = *(_QWORD *)(a1 + 1072) + v7;
      *(_DWORD *)(v10 + 4) = v9;
      *(_BYTE *)(v10 + 8) = (*(_DWORD *)v10 & v9) == -1;
      *(_BYTE *)(v10 + 9) = 0;
      v7 += 12;
    }
    while (v8 != v7);
    return 0;
  }
  v6 = 1;
  fwrite("bad value for block table count\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return v6;
}

uint64_t _ReadFreeList(uint64_t a1, uint64_t a2)
{
  int UInt32;
  int v5;
  size_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void (*v10)(uint64_t, void *, size_t, _BOOL8);
  _BOOL8 v11;

  UInt32 = BOMStreamReadUInt32(a2);
  *(_QWORD *)(a1 + 1088) = _NewFreeList();
  if (!UInt32)
    return 0;
  v5 = 8 * UInt32;
  v6 = 8 * UInt32;
  v7 = BOM_malloc(v5);
  if (v7)
  {
    v8 = v7;
    BOMStreamReadBuffer(a2, v7, v6);
    v9 = *(_QWORD *)(a1 + 1088);
    v10 = *(void (**)(uint64_t, void *, size_t, _BOOL8))(v9 + 16);
    v11 = BOMStreamGetByteOrder(a2) == 1;
    v10(v9, v8, v6, v11);
    free(v8);
    return 0;
  }
  return 1;
}

uint64_t BOMStorageOpenInRAM(uint64_t a1, unint64_t a2, char a3)
{
  int v4;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  int v10;
  int v11;
  BOOL v12;
  unsigned int v13;
  char *v14;
  int *v15;
  FILE *v17;
  int *v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  FILE *v26;
  int *v27;

  if (a2 <= 0x1FF)
  {
    fwrite("stream invalid; root page is outside of address range\n", 0x36uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return 0;
  }
  v4 = a2;
  v6 = BOMStreamWithAddress(a1, 0x200uLL, 0);
  if (!v6)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't read from %s\n");
    return 0;
  }
  v7 = (uint64_t)v6;
  if (BOMStreamReadUInt32((uint64_t)v6) != 1112493395
    || BOMStreamReadUInt32(v7) != 1953460837)
  {
    v14 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", "<memory>");
    v15 = __error();
    _BOMExceptionHandlerCall((uint64_t)v14, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 490, *v15);
LABEL_12:
    BOMStreamFree(v7);
    return 0;
  }
  if (BOMStreamReadUInt32(v7) != 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s has an unknown version: 0x%X\n");
    goto LABEL_12;
  }
  v8 = BOM_malloc(0x468uLL);
  if (!v8)
  {
    v17 = (FILE *)*MEMORY[0x24BDAC8D8];
    v18 = __error();
    strerror(*v18);
    fprintf(v17, "malloc: %s\n");
    goto LABEL_12;
  }
  v9 = (uint64_t)v8;
  bzero(v8, 0x468uLL);
  *(_QWORD *)(v9 + 1120) = BomSys_default();
  *(_DWORD *)(v9 + 1028) = -1;
  *(_DWORD *)(v9 + 1032) = v4;
  *(_DWORD *)(v9 + 1036) = v4;
  *(_BYTE *)(v9 + 1052) = a3;
  *(_BYTE *)(v9 + 1053) = 0;
  *(_DWORD *)(v9 + 1056) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1060) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1064) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1096) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1100) = BOMStreamReadUInt32(v7);
  BOMStreamFree(v7);
  v10 = *(_DWORD *)(v9 + 1060);
  v11 = *(_DWORD *)(v9 + 1064);
  v12 = __CFADD__(v11, v10);
  v13 = v11 + v10;
  if (v12)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; overflow of admin offset+size\n");
  }
  else
  {
    v19 = *(_DWORD *)(v9 + 1032);
    if (v13 <= v19)
    {
      v20 = *(_DWORD *)(v9 + 1096);
      v21 = *(_DWORD *)(v9 + 1100);
      v12 = __CFADD__(v21, v20);
      v22 = v21 + v20;
      if (v12)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; overflow of toc offset+size\n");
      }
      else
      {
        if (v22 <= v19)
        {
          *(_DWORD *)(v9 + 1048) = v19;
          *(_QWORD *)(v9 + 1040) = a1;
          _CreateBlockTable(v9);
          v23 = *(unsigned int *)(v9 + 1060);
          if ((_DWORD)v23)
          {
            v24 = BOMStreamWithAddress(*(_QWORD *)(v9 + 1040) + v23, *(unsigned int *)(v9 + 1064), 0);
            if (!v24)
            {
              v26 = (FILE *)*MEMORY[0x24BDAC8D8];
              v27 = __error();
              strerror(*v27);
              fprintf(v26, "can't read from %s: %s\n");
              return 0;
            }
            v25 = (uint64_t)v24;
            if (_ReadBlockTable(v9, (uint64_t)v24) || _ReadFreeList(v9, v25))
              return 0;
            BOMStreamFree(v25);
          }
          else
          {
            *(_QWORD *)(v9 + 1088) = _NewFreeList();
          }
          __strlcpy_chk();
          return v9;
        }
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; toc range is outside file\n");
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: stream invalid; admin range is outside file\n");
    }
  }
  return 0;
}

BOOL BOMStorageIsStorageFile(const char *a1)
{
  return BOMStorageIsStorageFileWithSys(a1, 0);
}

BOOL BOMStorageIsStorageFileWithSys(const char *a1, void *a2)
{
  void *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL8 v8;
  FILE *v9;
  int *v10;
  char *v11;

  v2 = a2;
  if (!a2)
    v2 = BomSys_default();
  v4 = (*((uint64_t (**)(_QWORD, const char *, _QWORD, uint64_t))v2 + 2))(*((_QWORD *)v2 + 1), a1, 0, 420);
  if ((_DWORD)v4 == -1)
  {
    v9 = (FILE *)*MEMORY[0x24BDAC8D8];
    v10 = __error();
    v11 = strerror(*v10);
    fprintf(v9, "can't open %s: %s\n", a1, v11);
    return 0;
  }
  else
  {
    v5 = v4;
    v6 = BOMStreamWithFileAndSys(v4, 0, 0x200uLL, 0, 0, v2);
    if (v6)
    {
      v7 = v6;
      v8 = BOMStreamReadUInt32(v6) == 1112493395 && BOMStreamReadUInt32(v7) == 1953460837;
      BOMStreamFree(v7);
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "can't read from %s\n", a1);
      v8 = 0;
    }
    (*((void (**)(_QWORD, uint64_t))v2 + 4))(*((_QWORD *)v2 + 1), v5);
  }
  return v8;
}

uint64_t BOMStorageFree(_DWORD *a1)
{
  uint64_t v3;
  int *v4;
  void (**v5)(_QWORD);
  int v6;
  int v7;
  int *v8;

  if (!a1)
    return 1;
  if (a1[279] && BOMStorageCommit((uint64_t)a1))
    return 1;
  v3 = *((_QWORD *)a1 + 134);
  if (v3 && MEMORY[0x20BCF4590](*MEMORY[0x24BDAEC58], v3, a1[270]))
  {
    v4 = __error();
    _BOMExceptionHandlerCall((uint64_t)"vm_deallocate failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1550, *v4);
  }
  v5 = (void (**)(_QWORD))*((_QWORD *)a1 + 136);
  if (v5)
  {
    v5[4](*((_QWORD *)a1 + 136));
    free(v5);
  }
  if (*((_QWORD *)a1 + 130))
  {
    if (*((_BYTE *)a1 + 1053))
    {
      v6 = *((unsigned __int8 *)a1 + 1052);
      v7 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)a1 + 140) + 328))(*(_QWORD *)(*((_QWORD *)a1 + 140) + 8));
      if (v6)
      {
        if (v7 == -1)
        {
          v8 = __error();
          _BOMExceptionHandlerCall((uint64_t)"munmap failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1417, *v8);
        }
      }
    }
  }
  if (a1[257] != -1)
    (*(void (**)(_QWORD))(*((_QWORD *)a1 + 140) + 32))(*(_QWORD *)(*((_QWORD *)a1 + 140) + 8));
  free(a1);
  return 0;
}

uint64_t BOMStorageCommit(uint64_t a1)
{
  _BOOL8 v2;
  uint64_t v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t, _BOOL8, size_t *);
  _BOOL8 v18;
  void *v19;
  int v20;
  size_t __len;

  if (!a1)
    return 1;
  if (!*(_DWORD *)(a1 + 1116))
    return 0;
  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    goto LABEL_8;
  }
  _FlushWriteCache(a1);
  if (_AdjustFileSize(a1, 0, 0))
    return 1;
  v4 = *(_QWORD *)(a1 + 1088);
  v5 = 8 * (*(_DWORD *)(a1 + 1068) + *(_DWORD *)(v4 + 8));
  v6 = (v5 + 24);
  if (v5 == -24)
  {
    v7 = 0;
  }
  else
  {
    v7 = (*(uint64_t (**)(uint64_t, unint64_t))(v4 + 48))(v4, v6);
    if (!v7)
      v7 = *(_DWORD *)(a1 + 1032);
  }
  v8 = *(_DWORD *)(a1 + 1060);
  v9 = *(_DWORD *)(a1 + 1064);
  *(_DWORD *)(a1 + 1060) = v7;
  *(_DWORD *)(a1 + 1064) = v6;
  if (v8 && v9)
    (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
  v10 = v7;
  v2 = 1;
  v11 = BOMStreamWithFile(*(_DWORD *)(a1 + 1028), v10, v6, 1, 0);
  if (v11)
  {
    v12 = v11;
    v13 = *(unsigned int *)(a1 + 1068);
    BOMStreamWriteUInt32(v11, *(_DWORD *)(a1 + 1068));
    if ((_DWORD)v13)
    {
      v14 = 0;
      v15 = 12 * v13;
      do
      {
        BOMStreamWriteUInt32(v12, *(_DWORD *)(*(_QWORD *)(a1 + 1072) + v14));
        BOMStreamWriteUInt32(v12, *(_DWORD *)(*(_QWORD *)(a1 + 1072) + v14 + 4));
        v14 += 12;
      }
      while (v15 != v14);
    }
    BOMStreamWriteUInt32(v12, *(_DWORD *)(*(_QWORD *)(a1 + 1088) + 8));
    __len = 0;
    v16 = *(_QWORD *)(a1 + 1088);
    v17 = *(uint64_t (**)(uint64_t, _BOOL8, size_t *))(v16 + 24);
    v18 = BOMStreamGetByteOrder(v12) == 1;
    v19 = (void *)v17(v16, v18, &__len);
    BOMStreamWriteBuffer(v12, v19, __len);
    free(v19);
    v20 = BOMStreamFree(v12);
    if (_AdjustFileSize(a1, 0, 0))
      return 1;
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    v2 = (_WriteRootPage(a1) | v20) != 0;
LABEL_8:
    *(_DWORD *)(a1 + 1116) = 0;
  }
  return v2;
}

uint64_t BOMStorageGetSys(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 1120);
  return result;
}

uint64_t BOMStorageIsOpenForWriting(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 1052);
  return result;
}

uint64_t BOMStorageNewBlock(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  if (!a1 || !*(_BYTE *)(a1 + 1052))
    return 0;
  v2 = (*(_DWORD *)(a1 + 1056) + 1);
  *(_DWORD *)(a1 + 1056) = v2;
  if (v2 >= *(_DWORD *)(a1 + 1068))
  {
    v3 = *(_DWORD *)(a1 + 1080);
    if (v3 >= 0x100000)
      v4 = v3 + 0x100000;
    else
      v4 = 2 * v3;
    _ExpandBlockTable(a1, v4);
    *(_DWORD *)(a1 + 1068) = *(_DWORD *)(a1 + 1080) / 0xCu;
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 1072) + 12 * v2 + 8) = 0;
  return v2;
}

uint64_t _ExpandBlockTable(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  vm_size_t v3;
  unint64_t v4;
  int v5;
  vm_size_t v6;
  vm_map_t *v7;
  int *v8;
  int *v9;
  int *v10;
  vm_address_t v11;
  int *v12;
  vm_address_t address;

  v2 = result;
  v3 = *(unsigned int *)(result + 1080);
  if (v3 >= a2)
  {
    if (*(_QWORD *)(result + 1072))
      return result;
    goto LABEL_14;
  }
  address = 0;
  v4 = (unint64_t)a2 % *MEMORY[0x24BDB03C8];
  if (v4)
    v5 = *MEMORY[0x24BDB03C8] - v4;
  else
    v5 = 0;
  v6 = v5 + a2;
  v7 = (vm_map_t *)MEMORY[0x24BDAEC58];
  if (vm_allocate(*MEMORY[0x24BDAEC58], &address, v6, 1))
  {
    v8 = __error();
    _BOMExceptionHandlerCall((uint64_t)"vm_allocate failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1570, *v8);
  }
  if (vm_copy(*v7, *(_QWORD *)(v2 + 1072), v3, address))
  {
    v9 = __error();
    _BOMExceptionHandlerCall((uint64_t)"vm_copy failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1572, *v9);
  }
  result = MEMORY[0x20BCF4590](*v7, *(_QWORD *)(v2 + 1072), v3);
  if ((_DWORD)result)
  {
    v10 = __error();
    result = _BOMExceptionHandlerCall((uint64_t)"vm_deallocate failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1575, *v10);
  }
  v11 = address;
  *(_QWORD *)(v2 + 1072) = address;
  *(_DWORD *)(v2 + 1080) = v6;
  if (!v11)
  {
LABEL_14:
    v12 = __error();
    return _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1591, *v12);
  }
  return result;
}

uint64_t BOMStorageNewNamedBlock(uint64_t a1, const char *a2)
{
  uint64_t v4;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  int UInt32;
  _QWORD *v16;
  uint64_t v17;
  size_t v18;
  unsigned int v19;
  unsigned int UInt8;
  char v21;
  size_t v22;
  unsigned int v23;
  unsigned int i;
  _BYTE __dst[255];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 1052))
    return 0;
  if (_tocGet(a1, a2))
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "name %s already exists!\n", a2);
    return 0;
  }
  v4 = BOMStorageNewBlock(a1);
  v6 = strlen(a2);
  if ((v6 & 0xFFFFFF00) != 0)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "name '%s' is > %d\n", a2, 255);
  }
  else
  {
    v7 = v6;
    if (*(_DWORD *)(a1 + 1096))
      v8 = *(_DWORD *)(a1 + 1100);
    else
      v8 = 4;
    v9 = v6 + v8;
    v10 = v9 + 5;
    if (v9 == -5)
    {
      v11 = 0;
    }
    else
    {
      v11 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 1088) + 48))();
      if (!v11)
        v11 = *(_DWORD *)(a1 + 1032);
    }
    _ExpandMapAddress(a1, v11 + v10);
    v12 = *(unsigned int *)(a1 + 1096);
    if ((_DWORD)v12)
    {
      v13 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v12, *(unsigned int *)(a1 + 1100), 0);
      if (!v13)
        return v4;
      v14 = (uint64_t)v13;
      UInt32 = BOMStreamReadUInt32((uint64_t)v13);
    }
    else
    {
      UInt32 = 0;
      v14 = 0;
    }
    v16 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v11, v10, 1);
    if (v16)
    {
      v17 = (uint64_t)v16;
      v18 = v7;
      BOMStreamWriteUInt32((uint64_t)v16, UInt32 + 1);
      if (v14)
      {
        v23 = v11;
        for (i = v10; UInt32; --UInt32)
        {
          v19 = BOMStreamReadUInt32(v14);
          UInt8 = BOMStreamReadUInt8(v14);
          v21 = UInt8;
          v22 = UInt8;
          BOMStreamReadBuffer(v14, __dst, UInt8);
          BOMStreamWriteUInt32(v17, v19);
          BOMStreamWriteUInt8(v17, v21);
          BOMStreamWriteBuffer(v17, __dst, v22);
        }
        BOMStreamFree(v14);
        if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100))
          (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
        v10 = i;
        v11 = v23;
        v18 = v7;
      }
      BOMStreamWriteUInt32(v17, v4);
      BOMStreamWriteUInt8(v17, v7);
      BOMStreamWriteBuffer(v17, a2, v18);
      BOMStreamFree(v17);
      *(_DWORD *)(a1 + 1096) = v11;
      *(_DWORD *)(a1 + 1100) = v10;
      _AdjustFileSize(a1, v11, v10);
      if (*(_DWORD *)(a1 + 1028) != -1)
        _AddToWriteCache(a1, v11, v10);
      *(_DWORD *)(a1 + 1116) = 1;
    }
  }
  return v4;
}

uint64_t _tocGet(uint64_t a1, const char *a2)
{
  uint64_t v2;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  int UInt32;
  int v8;
  uint64_t v9;
  unsigned int UInt8;
  char __s2[256];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0;
  v2 = *(unsigned int *)(a1 + 1096);
  if (!(_DWORD)v2)
    return 0;
  v4 = *(unsigned int *)(a1 + 1100);
  if (!(_DWORD)v4)
    return 0;
  v5 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v2, v4, 0);
  if (!v5)
    return 0;
  v6 = (uint64_t)v5;
  UInt32 = BOMStreamReadUInt32((uint64_t)v5);
  if (UInt32)
  {
    v8 = UInt32;
    while (1)
    {
      v9 = BOMStreamReadUInt32(v6);
      UInt8 = BOMStreamReadUInt8(v6);
      BOMStreamReadBuffer(v6, __s2, UInt8);
      __s2[UInt8] = 0;
      if (!strcmp(a2, __s2))
        break;
      if (!--v8)
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    v9 = 0;
  }
  BOMStreamFree(v6);
  return v9;
}

uint64_t BOMStorageSizeOfBlock(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t v4;

  result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 1056) < a2)
      return 0;
    if (*(_DWORD *)(a1 + 1068) <= a2)
      return 0;
    v4 = *(_QWORD *)(a1 + 1072);
    if (*(_BYTE *)(v4 + 12 * a2 + 8) == 1)
      return 0;
    else
      return *(unsigned int *)(v4 + 12 * a2 + 4);
  }
  return result;
}

double BOMStorageFreeBlock(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  _DWORD *v5;
  BOOL v6;
  uint64_t v7;
  double result;

  if (a1)
  {
    if (a2)
    {
      if (*(_DWORD *)(a1 + 1056) >= a2)
      {
        v3 = *(_QWORD *)(a1 + 1072);
        if (!*(_BYTE *)(v3 + 12 * a2 + 8))
        {
          v5 = (_DWORD *)(v3 + 12 * a2);
          if (*v5)
            v6 = v5[1] == 0;
          else
            v6 = 1;
          if (!v6)
          {
            (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
            v3 = *(_QWORD *)(a1 + 1072);
          }
          v7 = v3 + 12 * a2;
          result = NAN;
          *(_QWORD *)v7 = -1;
          *(_BYTE *)(v7 + 8) = 1;
        }
      }
    }
  }
  return result;
}

void BOMStorageFreeNamedBlock(uint64_t a1, const char *a2)
{
  unsigned int v4;
  int v5;
  int v6;
  unsigned int v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int UInt32;
  unsigned int v14;
  size_t UInt8;
  char __s1[256];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      v4 = _tocGet(a1, a2);
      if (v4)
      {
        BOMStorageFreeBlock(a1, v4);
        if (*(_DWORD *)(a1 + 1096))
        {
          v5 = strlen(a2);
          v6 = *(_DWORD *)(a1 + 1100);
          if (v6)
          {
            v7 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 1088) + 48))();
            if (!v7)
              v7 = *(_DWORD *)(a1 + 1032);
          }
          else
          {
            v7 = 0;
          }
          v8 = (v6 - v5 - 5);
          _ExpandMapAddress(a1, v7 + v8);
          v9 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + *(unsigned int *)(a1 + 1096), *(unsigned int *)(a1 + 1100), 0);
          if (v9)
          {
            v10 = (uint64_t)v9;
            v11 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v7, v8, 1);
            if (v11)
            {
              v12 = (uint64_t)v11;
              UInt32 = BOMStreamReadUInt32(v10);
              BOMStreamWriteUInt32(v12, UInt32 - 1);
              for (; UInt32; --UInt32)
              {
                v14 = BOMStreamReadUInt32(v10);
                UInt8 = BOMStreamReadUInt8(v10);
                BOMStreamReadBuffer(v10, __s1, UInt8);
                __s1[UInt8] = 0;
                if (strcmp(__s1, a2))
                {
                  BOMStreamWriteUInt32(v12, v14);
                  BOMStreamWriteUInt8(v12, UInt8);
                  BOMStreamWriteBuffer(v12, __s1, UInt8);
                }
              }
              BOMStreamFree(v10);
              BOMStreamFree(v12);
              if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100))
                (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
              *(_DWORD *)(a1 + 1096) = v7;
              *(_DWORD *)(a1 + 1100) = v8;
              _AdjustFileSize(a1, v7, v8);
              if (*(_DWORD *)(a1 + 1028) != -1)
                _AddToWriteCache(a1, v7, v8);
              *(_DWORD *)(a1 + 1116) = 1;
            }
          }
        }
      }
    }
  }
}

uint64_t BOMStorageCount(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 1056);
  return result;
}

uint64_t BOMStorageCopyToBlock(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  if (a1 && a2 && *(_DWORD *)(a1 + 1056) >= a2 && *(_BYTE *)(a1 + 1052))
    return BOMStorageCopyToBlockRange(a1, a2, a3, a4, 0, *(unsigned int *)(*(_QWORD *)(a1 + 1072) + 12 * a2 + 4));
  else
    return 1;
}

uint64_t BOMStorageCopyToBlockRange(uint64_t a1, unsigned int a2, const void *a3, size_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t result;
  unsigned int *v10;
  unint64_t v11;
  int v12;
  int v13;
  const char *v14;
  int v15;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  unsigned int v22;
  unsigned int *v23;
  BOOL v24;
  unsigned int v25;
  const void *v28;
  unsigned int v29;
  size_t v30;
  uint64_t v31;
  const void *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;

  result = 1;
  if (!a1 || !a2 || *(_DWORD *)(a1 + 1056) < a2 || !*(_BYTE *)(a1 + 1052))
    return result;
  v10 = (unsigned int *)(*(_QWORD *)(a1 + 1072) + 12 * a2);
  v11 = v10[1];
  v12 = a6 + a5;
  if (a6 + a5 > v11)
  {
    v13 = *__error();
    v14 = "BOMStorageCopyToBlockRange: length extends beyond block size";
    v15 = 893;
LABEL_7:
    _BOMExceptionHandlerCall((uint64_t)v14, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v15, v13);
    return 1;
  }
  v18 = *v10;
  if (v11 <= a5)
    v19 = a5;
  else
    v19 = v10[1];
  v20 = a4 - a6 + v19;
  if ((_DWORD)v11 == v20 && v18 >= *(_DWORD *)(a1 + 1036))
  {
    v22 = v18;
  }
  else
  {
    if ((_DWORD)v18)
      v21 = (_DWORD)v11 == 0;
    else
      v21 = 1;
    if (!v21)
      (*(void (**)(void))(*(_QWORD *)(a1 + 1088) + 40))();
    if (v20)
    {
      v22 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 1088) + 48))();
      if (!v22)
        v22 = *(_DWORD *)(a1 + 1032);
    }
    else
    {
      v22 = 0;
    }
    v23 = (unsigned int *)(*(_QWORD *)(a1 + 1072) + 12 * a2);
    *v23 = v22;
    v23[1] = v20;
  }
  if (v20)
    v24 = v22 == 0;
  else
    v24 = 1;
  if (v24)
    return 0;
  v36 = v22 + v20;
  _ExpandMapAddress(a1, v22 + v20);
  if (a5)
  {
    memmove((void *)(*(_QWORD *)(a1 + 1040) + v22), (const void *)(*(_QWORD *)(a1 + 1040) + v18), a5);
    v25 = a5;
  }
  else
  {
    v25 = 0;
  }
  if (v11 <= a5 || v22 < v18 || v22 >= (int)v11 + (int)v18)
  {
    if (a4)
    {
      v28 = a3;
      v29 = v25;
      memmove((void *)(*(_QWORD *)(a1 + 1040) + v22 + v25), v28, a4);
      v25 = v29 + a4;
    }
    if (v20 > v25)
    {
      memmove((void *)(*(_QWORD *)(a1 + 1040) + v22 + v25), (const void *)(*(_QWORD *)(a1 + 1040) + a5 + a6 + v18), v20 - v25);
      *(_BYTE *)(*(_QWORD *)(a1 + 1072) + 12 * a2 + 9) = 1;
      goto LABEL_51;
    }
  }
  else
  {
    v30 = (v11 - v12);
    if ((_DWORD)v30)
    {
      v31 = *(_QWORD *)(a1 + 1040);
      v32 = (const void *)(v31 + a5 + a6 + v18);
      v33 = v25;
      memmove((void *)(v31 + v22 + a5 + a4), v32, v30);
      v25 = v33;
    }
    if (a4)
    {
      v34 = v25;
      memmove((void *)(*(_QWORD *)(a1 + 1040) + v22 + v25), a3, a4);
      v25 = v34 + a4;
    }
    v25 += v30;
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 1072) + 12 * a2 + 9) = 1;
  if (v25 != v20)
  {
    v13 = *__error();
    v14 = "BOMStorageCopyToBlockRange: internal consistency error";
    v15 = 997;
    goto LABEL_7;
  }
LABEL_51:
  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    if (v36 > *(_DWORD *)(a1 + 1032))
      *(_DWORD *)(a1 + 1032) = v36;
  }
  else
  {
    _AddToWriteCache(a1, v22, v20);
  }
  v35 = _AdjustFileSize(a1, v22, v20);
  result = 1;
  if (!v35)
  {
    *(_DWORD *)(a1 + 1116) = 1;
    return 0;
  }
  return result;
}

uint64_t _ExpandMapAddress(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  vm_address_t v8;
  vm_address_t v9;
  int *v10;
  int v11;
  const char *v12;
  int v13;

  v2 = result;
  v3 = *(_DWORD *)(result + 1048);
  if (v3 >= a2)
  {
    if (!*(_QWORD *)(result + 1040))
      goto LABEL_15;
  }
  else
  {
    if (v3 >= 0x100000)
      LODWORD(v4) = v3 + 0x100000;
    else
      LODWORD(v4) = 2 * v3;
    if (v4 <= a2)
      v4 = a2;
    else
      v4 = v4;
    v5 = v4 % *MEMORY[0x24BDB03C8];
    v6 = *MEMORY[0x24BDB03C8] - v5;
    if (!v5)
      v6 = 0;
    v7 = (v6 + v4);
    v8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(result + 1120)
                                                                                               + 320))(*(_QWORD *)(*(_QWORD *)(result + 1120) + 8), 0, v7, 3, 4098, 0xFFFFFFFFLL, 0);
    if (v8 == -1)
    {
      v11 = *__error();
      v12 = "mmap failed";
      v13 = 1443;
      return _BOMExceptionHandlerCall((uint64_t)v12, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v13, v11);
    }
    v9 = v8;
    if (vm_copy(*MEMORY[0x24BDAEC58], *(_QWORD *)(v2 + 1040), *(unsigned int *)(v2 + 1048), v8))
    {
      v10 = __error();
      _BOMExceptionHandlerCall((uint64_t)"vm_copy failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1447, *v10);
    }
    result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v2 + 1120) + 328))(*(_QWORD *)(*(_QWORD *)(v2 + 1120) + 8), *(_QWORD *)(v2 + 1040), *(unsigned int *)(v2 + 1048));
    if ((_DWORD)result == -1)
    {
      v11 = *__error();
      v12 = "munmap failed";
      v13 = 1449;
      return _BOMExceptionHandlerCall((uint64_t)v12, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v13, v11);
    }
    *(_QWORD *)(v2 + 1040) = v9;
    *(_DWORD *)(v2 + 1048) = v7;
    if (!v9)
    {
LABEL_15:
      v11 = *__error();
      v12 = "Out of memory.";
      v13 = 1460;
      return _BOMExceptionHandlerCall((uint64_t)v12, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v13, v11);
    }
  }
  return result;
}

void _AddToWriteCache(uint64_t a1, unsigned int a2, int a3)
{
  _DWORD *v5;
  unsigned int v6;
  _DWORD *v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  _DWORD *v12;
  int v13;
  _DWORD *v14;
  _QWORD *v15;
  unsigned int v16;
  _DWORD *v17;
  int *v18;

  if (!a2 || !a3)
    return;
  v5 = *(_DWORD **)(a1 + 1104);
  if (v5)
  {
    v6 = v5[2];
    if (v6 <= a2)
    {
      while (1)
      {
        v7 = v5;
        v5 = *(_DWORD **)v5;
        if (!v5)
          break;
        v8 = v5[2];
        if (v8 >= a2)
        {
          v10 = v7[3];
          if (v10 + v7[2] != a2)
            goto LABEL_6;
          v7[3] = v10 + a3;
          if (a3 + a2 == v5[2])
          {
            v7[3] = v5[3] + v10 + a3;
            *(_QWORD *)v7 = *(_QWORD *)v5;
            free(v5);
            v11 = *(_DWORD *)(a1 + 1112) - 1;
            goto LABEL_23;
          }
          goto LABEL_24;
        }
      }
      v13 = v7[3];
      if (v13 + v7[2] == a2)
      {
        v7[3] = v13 + a3;
        goto LABEL_24;
      }
      v12 = _newFreeListEntry(a2, a3);
      if (v12)
      {
        *(_QWORD *)v12 = 0;
        goto LABEL_21;
      }
    }
    else
    {
      v7 = 0;
      v8 = v5[2];
LABEL_6:
      if (a3 + a2 == v8)
      {
        v9 = v5[3] + a3;
        v5[2] = a2;
        v5[3] = v9;
        goto LABEL_24;
      }
      v12 = _newFreeListEntry(a2, a3);
      if (v12)
      {
        *(_QWORD *)v12 = v5;
        if (v6 <= a2)
LABEL_21:
          *(_QWORD *)v7 = v12;
        else
          *(_QWORD *)(a1 + 1104) = v12;
        v11 = *(_DWORD *)(a1 + 1112) + 1;
        goto LABEL_23;
      }
    }
    v18 = __error();
    _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 2068, *v18);
    return;
  }
  *(_QWORD *)(a1 + 1104) = _newFreeListEntry(a2, a3);
  v11 = 1;
LABEL_23:
  *(_DWORD *)(a1 + 1112) = v11;
LABEL_24:
  if (*(_DWORD *)(a1 + 1112) < 0x10u)
  {
    v14 = *(_DWORD **)(a1 + 1104);
    if (v14)
    {
      v15 = 0;
      do
      {
        v16 = v14[3];
        if (v16 < 0xFFFF)
        {
          v17 = *(_DWORD **)v14;
          v15 = v14;
        }
        else
        {
          v17 = *(_DWORD **)v14;
          if (v15)
          {
            *v15 = v17;
            v17 = *(_DWORD **)v14;
          }
          else
          {
            *(_QWORD *)(a1 + 1104) = v17;
          }
          _WriteAddress(a1, v14[2], v16);
          free(v14);
          --*(_DWORD *)(a1 + 1112);
        }
        v14 = v17;
      }
      while (v17);
    }
  }
  else
  {
    _FlushWriteCache(a1);
  }
}

uint64_t _AdjustFileSize(uint64_t a1, int a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  FILE *v7;
  int *v8;
  char *v9;

  if (a2)
  {
    if ((a3 + a2) <= *(_DWORD *)(a1 + 1032))
    {
      return 0;
    }
    else
    {
      result = 0;
      *(_DWORD *)(a1 + 1032) = a3 + a2;
    }
  }
  else
  {
    v5 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 1120) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 1120) + 8), *(unsigned int *)(a1 + 1028), 0, 2);
    if (v5 == -1)
    {
      v7 = (FILE *)*MEMORY[0x24BDAC8D8];
      v8 = __error();
      v9 = strerror(*v8);
      fprintf(v7, "lseek: %s\n", v9);
      return 1;
    }
    else
    {
      v6 = v5;
      result = 0;
      *(_DWORD *)(a1 + 1032) = v6;
    }
  }
  return result;
}

uint64_t BOMStorageCopyFromBlock(uint64_t a1, unsigned int a2, void *a3)
{
  int v4;
  const char *v5;
  int v6;
  int *v8;

  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 1056) >= a2)
      return BOMStorageCopyFromBlockRange(a1, a2, 0, *(unsigned int *)(*(_QWORD *)(a1 + 1072) + 12 * a2 + 4), a3);
    v4 = *__error();
    v5 = "BOMStorageCopyFromBlock: bid > storage->blocks";
    v6 = 1047;
    goto LABEL_11;
  }
  if (a1)
  {
    if (!a2)
      goto LABEL_10;
  }
  else
  {
    v8 = __error();
    _BOMExceptionHandlerCall((uint64_t)"BOMStorageCopyFromBlock: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1035, *v8);
    if (!a2)
    {
LABEL_10:
      v4 = *__error();
      v5 = "BOMStorageCopyFromBlock: !bid";
      v6 = 1039;
LABEL_11:
      _BOMExceptionHandlerCall((uint64_t)v5, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v6, v4);
    }
  }
  return 1;
}

uint64_t BOMStorageCopyFromBlockRange(uint64_t a1, unsigned int a2, uint64_t a3, size_t __len, void *__dst)
{
  int v8;
  const char *v9;
  int v10;
  uint64_t v11;
  int *v12;
  int *v13;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  int v21;
  uint64_t v22;

  if (!a1 || !a2 || !__dst)
  {
    if (a1)
    {
      if (a2)
        goto LABEL_8;
    }
    else
    {
      v12 = __error();
      _BOMExceptionHandlerCall((uint64_t)"BOMStorageCopyFromBlockRange: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1066, *v12);
      if (a2)
      {
LABEL_8:
        if (!__dst)
          goto LABEL_14;
        return 1;
      }
    }
    v13 = __error();
    _BOMExceptionHandlerCall((uint64_t)"BOMStorageCopyFromBlockRange: !bid", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1070, *v13);
    if (!__dst)
    {
LABEL_14:
      v8 = *__error();
      v9 = "BOMStorageCopyFromBlockRange: !data";
      v10 = 1074;
      goto LABEL_15;
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    v8 = *__error();
    v9 = "BOMStorageCopyRangeFromBlockRange: bad block (bid > storage->blocks)";
    v10 = 1081;
LABEL_15:
    _BOMExceptionHandlerCall((uint64_t)v9, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v10, v8);
    return 1;
  }
  v11 = *(_QWORD *)(a1 + 1072);
  if (*(_BYTE *)(v11 + 12 * a2 + 8))
  {
    v8 = *__error();
    v9 = "BOMStorageCopyRangeFromBlockRange: reading from free block";
    v10 = 1087;
    goto LABEL_15;
  }
  v17 = (unsigned int *)(v11 + 12 * a2);
  v19 = *v17;
  v18 = v17[1];
  if ((v18 + v19) >> 32)
  {
    v8 = *__error();
    v9 = "BOMStorageCopyRangeFromBlockRange: 32-bit overflow with block address+size";
    v10 = 1098;
    goto LABEL_15;
  }
  if (v18 + v19 > *(unsigned int *)(a1 + 1032))
  {
    v8 = *__error();
    v9 = "BOMStorageCopyRangeFromBlockRange: block extends past end of storage";
    v10 = 1103;
    goto LABEL_15;
  }
  if (__len + a3 > v18)
  {
    v8 = *__error();
    v9 = "BOMStorageCopyRangeFromBlockRange: length extends beyond block size";
    v10 = 1110;
    goto LABEL_15;
  }
  if ((_DWORD)v18)
  {
    if (!(_DWORD)v19)
    {
      v8 = *__error();
      v9 = "BOMStorageCopyRangeFromBlockRange: bad block address";
      v10 = 1123;
      goto LABEL_15;
    }
    if (!*(_BYTE *)(v11 + 12 * a2 + 9))
    {
      if (*(_BYTE *)(a1 + 1052))
      {
        v21 = *(_DWORD *)(a1 + 1028);
        if (v21 != -1)
        {
          v22 = BOMStreamWithFile(v21, v19, v18, 0, (char *)(*(_QWORD *)(a1 + 1040) + v19));
          if (!v22)
          {
            v8 = *__error();
            v9 = "BOMStorageCopyRangeFromBlockRange: !stream";
            v10 = 1147;
            goto LABEL_15;
          }
          BOMStreamFree(v22);
          *(_BYTE *)(*(_QWORD *)(a1 + 1072) + 12 * a2 + 9) = 1;
        }
      }
    }
    memmove(__dst, (const void *)(*(_QWORD *)(a1 + 1040) + a3 + v19), __len);
  }
  return 0;
}

void _FlushWriteCache(uint64_t a1)
{
  _DWORD *i;

  for (i = *(_DWORD **)(a1 + 1104); i; i = *(_DWORD **)(a1 + 1104))
  {
    *(_QWORD *)(a1 + 1104) = *(_QWORD *)i;
    _WriteAddress(a1, i[2], i[3]);
    free(i);
  }
  *(_DWORD *)(a1 + 1112) = 0;
}

uint64_t BOMStorageCompact(uint64_t a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  void *v9;
  size_t v10;
  unsigned int v11;
  size_t v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  FILE *v16;
  int *v17;
  char *v18;
  void *v19;
  FILE *v20;
  int *v21;
  char __s[1025];
  char v24[1025];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (!a1 || !*(_BYTE *)(a1 + 1052) || *(_DWORD *)(a1 + 1028) == -1)
    return 1;
  v2 = *(_QWORD *)(a1 + 1120);
  BOMStorageCommit(a1);
  __strlcpy_chk();
  __strlcpy_chk();
  v3 = strrchr(__s, 47);
  if (v3)
    *v3 = 0;
  else
    __strlcpy_chk();
  __strlcat_chk();
  if (!(*(uint64_t (**)(_QWORD, char *))(v2 + 336))(*(_QWORD *)(v2 + 8), __s))
  {
    v13 = 1;
    fwrite("can't get temp file.\n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return v13;
  }
  v5 = BOMStorageNewWithOptionsAndSys(__s, v4, (uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t))v2);
  if (!v5)
    return 1;
  v6 = v5;
  if (*(_DWORD *)(a1 + 1056))
  {
    v7 = 1;
    while (v7 == BOMStorageNewBlock(v6))
    {
      v8 = *(_QWORD *)(a1 + 1072);
      if (*(_BYTE *)(v8 + 12 * v7 + 8))
      {
        BOMStorageFreeBlock(v6, v7);
      }
      else
      {
        v9 = BOM_malloc(*(unsigned int *)(v8 + 12 * v7 + 4));
        BOMStorageCopyFromBlock(a1, v7, v9);
        BOMStorageCopyToBlock(v6, v7, v9, *(unsigned int *)(*(_QWORD *)(a1 + 1072) + 12 * v7 + 4));
        free(v9);
      }
      if (++v7 > *(_DWORD *)(a1 + 1056))
        goto LABEL_16;
    }
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "unable to reserve block %d.\n");
    return 1;
  }
LABEL_16:
  if (*(_DWORD *)(a1 + 1096))
  {
    v10 = *(unsigned int *)(a1 + 1100);
    *(_DWORD *)(v6 + 1100) = v10;
    if ((_DWORD)v10)
    {
      v11 = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 1088) + 48))();
      v12 = v10;
      if (!v11)
      {
        v11 = *(_DWORD *)(v6 + 1032);
        v12 = v10;
      }
    }
    else
    {
      v12 = 0;
      v11 = 0;
    }
    *(_DWORD *)(v6 + 1096) = v11;
    _ExpandMapAddress(v6, v11 + v10);
    memmove((void *)(*(_QWORD *)(v6 + 1040) + *(unsigned int *)(v6 + 1096)), (const void *)(*(_QWORD *)(a1 + 1040) + *(unsigned int *)(a1 + 1096)), v12);
    _AdjustFileSize(v6, v11, v10);
    if (*(_DWORD *)(v6 + 1028) != -1)
      _AddToWriteCache(v6, v11, v10);
    *(_DWORD *)(v6 + 1116) = 1;
  }
  BOMStorageCommit(v6);
  v14 = BOM_malloc(0x468uLL);
  if (!v14)
  {
    BOMStorageFree((_DWORD *)v6);
    v20 = (FILE *)*MEMORY[0x24BDAC8D8];
    v21 = __error();
    strerror(*v21);
    fprintf(v20, "malloc: %s\n");
    return 1;
  }
  v15 = v14;
  memcpy(v14, (const void *)a1, 0x468uLL);
  BOMStorageFree(v15);
  if ((*(unsigned int (**)(_QWORD, char *, char *))(v2 + 264))(*(_QWORD *)(v2 + 8), __s, v24))
  {
    v16 = (FILE *)*MEMORY[0x24BDAC8D8];
    v17 = __error();
    v18 = strerror(*v17);
    fprintf(v16, "rename: %s\n", v18);
    BOMStorageFree((_DWORD *)v6);
    v13 = 1;
    v19 = (void *)BOMStorageOpenWithSys(v24, 1, (void *)v2);
    memcpy((void *)a1, v19, 0x468uLL);
    free(v19);
  }
  else
  {
    memcpy((void *)a1, (const void *)v6, 0x468uLL);
    free((void *)v6);
    return 0;
  }
  return v13;
}

uint64_t BOMStorageDumpFreeList(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 1088) + 64))();
}

void BOMStorageFindActualFreeSpace(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  int v8;
  _DWORD *v9;

  v9 = _newFreeListEntry(0, *(_DWORD *)(a1 + 1032));
  v2 = *(_DWORD *)(a1 + 1056);
  if (v2)
  {
    v3 = 1;
    do
    {
      v4 = *(_QWORD *)(a1 + 1072);
      v5 = v3;
      if (!*(_BYTE *)(v4 + 12 * v3 + 8))
      {
        _ClearAddress(&v9, *(_DWORD *)(v4 + 12 * v3), *(_DWORD *)(v4 + 12 * v3 + 4));
        v2 = *(_DWORD *)(a1 + 1056);
      }
      v3 = v5 + 1;
    }
    while (v5 + 1 <= v2);
  }
  _ClearAddress(&v9, *(_DWORD *)(a1 + 1060), *(_DWORD *)(a1 + 1064));
  _ClearAddress(&v9, *(_DWORD *)(a1 + 1096), *(_DWORD *)(a1 + 1100));
  v6 = v9;
  if (v9)
  {
    v7 = 0;
    v8 = 1;
    do
    {
      printf("Node %u:\n", v8);
      printf("\taddr = %u\n\tsize = %u\n", v6[2], v6[3]);
      v7 += v6[3];
      v6 = *(_DWORD **)v6;
      ++v8;
    }
    while (v6);
    if (v7)
      printf("======\nTotal free bytes: %u\n", v7);
  }
}

_DWORD *_newFreeListEntry(int a1, int a2)
{
  _DWORD *v4;
  _DWORD *v5;
  FILE *v6;
  int *v7;
  char *v8;

  v4 = BOM_malloc(0x10uLL);
  v5 = v4;
  if (v4)
  {
    *(_QWORD *)v4 = 0;
    v4[2] = a1;
    v4[3] = a2;
  }
  else
  {
    v6 = (FILE *)*MEMORY[0x24BDAC8D8];
    v7 = __error();
    v8 = strerror(*v7);
    fprintf(v6, "malloc: %s\n", v8);
  }
  return v5;
}

void _ClearAddress(_QWORD *a1, unsigned int a2, int a3)
{
  _DWORD *v3;
  _QWORD *v5;
  _DWORD *v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  _DWORD *v11;
  int *v12;

  if (a2)
  {
    if (a3)
    {
      v3 = (_DWORD *)*a1;
      if (*a1)
      {
        v5 = 0;
        while (1)
        {
          v6 = v3;
          v7 = v3[2];
          if (v7 <= a2)
          {
            v8 = v3[3];
            v9 = v8 + v7;
            if (v8 + v7 > a2)
              break;
          }
          v3 = *(_DWORD **)v6;
          v5 = v6;
          if (!*(_QWORD *)v6)
            return;
        }
        if (v7 == a2)
        {
          v10 = v8 - a3;
          if (v10)
          {
            v6[2] = a2 + a3;
            v6[3] = v10;
          }
          else
          {
            if (!v5)
              v5 = a1;
            *v5 = *(_QWORD *)v6;
            free(v6);
          }
        }
        else if (v9 == a3 + a2)
        {
          v6[3] = v8 - a3;
        }
        else
        {
          v11 = _newFreeListEntry(a3 + a2, v9 - (a3 + a2));
          if (v11)
          {
            *(_QWORD *)v11 = *(_QWORD *)v6;
            v6[3] = a2 - v6[2];
            *(_QWORD *)v6 = v11;
          }
          else
          {
            v12 = __error();
            _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1750, *v12);
          }
        }
      }
    }
  }
}

uint64_t _BOMStoragePrintDiagnostics(uint64_t result)
{
  uint64_t v1;
  FILE **v2;

  if (result)
  {
    v1 = result;
    v2 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "   # blocks : %d\n", *(_DWORD *)(result + 1056));
    fprintf(*v2, "   adm size : %d\n", *(_DWORD *)(v1 + 1064));
    fprintf(*v2, "   bt size  : %d\n", (8 * *(_DWORD *)(v1 + 1068)) | 4);
    fprintf(*v2, "   fl size  : %d\n", *(_DWORD *)(*(_QWORD *)(v1 + 1088) + 8));
    return fprintf(*v2, "   toc size : %d\n", *(_DWORD *)(v1 + 1100));
  }
  return result;
}

uint64_t BOMStorageDump(uint64_t a1, int a2)
{
  uint64_t v3;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int UInt32;
  const char *v9;
  uint64_t v10;
  FILE **v12;
  unsigned int UInt8;
  FILE *v14;
  BOOL v15;
  BOOL v16;
  BOOL v17;
  uint64_t v23;
  const char *p_dst;
  unsigned int v25;
  int v26;
  __int128 __dst;
  __int16 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  v3 = *(unsigned int *)(a1 + 1096);
  if (!(_DWORD)v3)
    return 1;
  v5 = *(unsigned int *)(a1 + 1100);
  if (!(_DWORD)v5)
    return 1;
  v6 = BOMStreamWithAddress(*(_QWORD *)(a1 + 1040) + v3, v5, 0);
  if (!v6)
    return 2;
  v7 = (uint64_t)v6;
  UInt32 = BOMStreamReadUInt32((uint64_t)v6);
  if (*(_BYTE *)(a1 + 1052))
  {
    if (*(_DWORD *)(a1 + 1116))
      v9 = "read/write [dirty]";
    else
      v9 = "read/write";
  }
  else
  {
    v9 = "readonly";
  }
  v12 = (FILE **)MEMORY[0x24BDAC8E8];
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "Storage: open %s (%u blocks)\n", v9, *(_DWORD *)(a1 + 1056));
  fprintf(*v12, "    ToC: %u entries (%u bytes)\n", UInt32, *(_DWORD *)(a1 + 1100));
  if (!UInt32)
  {
    v10 = 0;
    goto LABEL_67;
  }
  v26 = 0;
  do
  {
    BOMStreamReadUInt32(v7);
    UInt8 = BOMStreamReadUInt8(v7);
    BOMStreamReadBuffer(v7, &__dst, UInt8);
    *((_BYTE *)&__dst + UInt8) = 0;
    v14 = *v12;
    if ((a2 & 1) != 0)
      fprintf(v14, "    Bid: 0x%08x (%u) '%s' (%lu bytes)");
    else
      fprintf(v14, "    Bid: '%s' (%lu bytes)");
    if ((_QWORD)__dst == 0x6F666E496D6F42
      || ((_DWORD)__dst == 1752457552 ? (v15 = WORD2(__dst) == 115) : (v15 = 0),
          v15
       || (_QWORD)__dst == 0x7865646E494C48
       || ((_DWORD)__dst == 1684949334 ? (v16 = *(_DWORD *)((char *)&__dst + 3) == 7890276) : (v16 = 0),
           v16 || ((_DWORD)__dst == 1702521171 ? (v17 = *(_DWORD *)((char *)&__dst + 3) == 3421797) : (v17 = 0), v17))))
    {
      fwrite(" [BOM]\n", 7uLL, 1uLL, *v12);
      goto LABEL_54;
    }
    if ((_QWORD)__dst == 0x547463656A6F7250 && *((_QWORD *)&__dst + 1) == 0x656C6261546761)
    {
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x10u;
      v23 = a1;
      p_dst = "ProjectTagTable";
    }
    else if ((_QWORD)__dst == 0x546567616B636150 && *((_QWORD *)&__dst + 1) == 0x656C6261546761)
    {
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x20u;
      v23 = a1;
      p_dst = "PackageTagTable";
    }
    else
    {
      if ((_QWORD)__dst != 0x5467615468746150 || *(_QWORD *)((char *)&__dst + 5) != 0x656C6261546761)
      {
        if ((_QWORD)__dst == 0x547463656A6F7250 && *((_QWORD *)&__dst + 1) == 0x657254687461506FLL && v28 == 101)
        {
          fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
          v26 |= 0x80u;
          v23 = a1;
          p_dst = "ProjectToPathTree";
          v25 = a2 | 0x1310000;
        }
        else
        {
          if ((v26 & 0x20) == 0)
          {
            fputc(10, *v12);
            goto LABEL_54;
          }
          fwrite(" [Package]\n", 0xBuLL, 1uLL, *v12);
          p_dst = (const char *)&__dst;
          v23 = a1;
          v25 = a2 | 0x230000;
        }
        goto LABEL_60;
      }
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x40u;
      v23 = a1;
      p_dst = "PathTagTable";
    }
    v25 = a2 | 0x210000;
LABEL_60:
    BOMStorageDumpTree(v23, p_dst, v25);
LABEL_54:
    --UInt32;
  }
  while (UInt32);
  v10 = 0;
  if ((v26 & 0xF0) != 0 && (v26 & 0xF0) != 0xF0)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "WARNING: file appears to be a corrupt Metabom! (found %04x expected %04x or %04x)\n", v26 & 0xF0, 240, 0);
    v10 = 3;
  }
LABEL_67:
  BOMStreamFree(v7);
  return v10;
}

uint64_t _WriteAddress(uint64_t a1, unsigned int a2, unsigned int a3)
{
  int *v3;
  uint64_t v4;
  int *v6;

  v3 = (int *)BOMStreamWithFile(*(_DWORD *)(a1 + 1028), a2, a3, 1, (char *)(*(_QWORD *)(a1 + 1040) + a2));
  if (v3)
  {
    v4 = (uint64_t)v3;
    BOMStreamFlush(v3);
    return BOMStreamFree(v4);
  }
  else
  {
    v6 = __error();
    return _BOMExceptionHandlerCall((uint64_t)"Unable to create write stream.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 2141, *v6);
  }
}

BOOL BOMCKTreeBuildKey(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9)
{
  return _buildKey(a1, &a9) != 0;
}

uint64_t _buildKey(char *a1, char **a2)
{
  char *v2;
  unsigned int v4;
  char v5;
  char **v6;
  uint64_t v7;
  char **v9;

  *a1 = 0;
  v9 = a2 + 1;
  v2 = *a2;
  if (!*a2)
    return 0;
  v4 = 0;
  v5 = 1;
  while (1)
  {
    if ((v5 & 1) == 0)
    {
      if (v4 >= 0x3FF)
        break;
      *(_WORD *)&a1[v4++] = 47;
    }
    if (strchr(v2, 47))
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "invalid key segment: '%s'\n", v2);
      return 1;
    }
    v4 += strlen(v2);
    if (v4 >= 0x400)
      break;
    strlcat(a1, v2, 0x400uLL);
    v5 = 0;
    v6 = v9++;
    v2 = *v6;
    if (!*v6)
    {
      if (v4 < 0x3FF)
        return 0;
      break;
    }
  }
  v7 = 1;
  fwrite("key too long\n", 0xDuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return v7;
}

uint64_t BOMCKTreeCount(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9)
{
  uint64_t v10;
  size_t v11;
  size_t v12;
  char *v13;
  char *v14;
  char *v16;
  unsigned int v17;
  size_t v18;
  const char *v19;
  char *v20;
  BOOL v21;
  char **v22;
  char __s1[1024];
  char __s[1024];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v21 = 0;
  v22 = &a9;
  v10 = 0;
  if (!_buildKey(__s, &a9))
  {
    LODWORD(v11) = strlen(__s);
    v12 = (v11 + 1);
    v13 = (char *)BOMTreeIteratorNew(a1, __s, v12, &v21);
    if (v13)
    {
      v14 = v13;
      if (!v21)
      {
        if (!BOMTreeIteratorKey((uint64_t)v13) || (__strlcpy_chk(), strlen(__s1) == v11))
        {
          v10 = 0;
          goto LABEL_9;
        }
        if ((_DWORD)v11)
        {
          if ((unint64_t)__strlcat_chk() >= 0x400)
            v11 = v11;
          else
            v11 = v12;
        }
        else
        {
          v11 = 0;
        }
        v16 = strchr(&__s1[v11], 47);
        if (v16)
          v16[1] = 0;
        v17 = strlen(__s1);
        BOMTreeIteratorNext((uint64_t)v14);
        if (!BOMTreeIteratorIsAtEnd((uint64_t)v14))
        {
          v18 = v17;
          v10 = 1;
          do
          {
            v19 = (const char *)BOMTreeIteratorKey((uint64_t)v14);
            if (strncmp(__s, v19, v11))
              break;
            if (strncmp(__s1, v19, v18))
            {
              __strlcpy_chk();
              v20 = strchr(&__s1[v11], 47);
              if (v20)
                v20[1] = 0;
              v18 = strlen(__s1);
              v10 = (v10 + 1);
            }
            BOMTreeIteratorNext((uint64_t)v14);
          }
          while (!BOMTreeIteratorIsAtEnd((uint64_t)v14));
          goto LABEL_9;
        }
      }
      v10 = 1;
LABEL_9:
      BOMTreeIteratorFree(v14);
      return v10;
    }
    return 0;
  }
  return v10;
}

char *BOMCKTreeGet(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9)
{
  char *v11;
  int v12;
  size_t v13;
  char *v14;
  char *v15;
  char *v16;
  int v17;
  size_t v18;
  const char *v19;
  char *v20;
  char *v21;
  BOOL v23;
  char **v24;
  char __s[1024];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v23 = 0;
  v24 = &a9;
  v11 = 0;
  if (!_buildKey(__s, &a9))
  {
    v12 = strlen(__s);
    v13 = (v12 + 1);
    v14 = (char *)BOMTreeIteratorNew(a1, __s, v13, &v23);
    if (v14)
    {
      v15 = v14;
      if (v23)
      {
        v11 = (char *)BOMTreeIteratorValue((uint64_t)v14);
      }
      else
      {
        if (BOMTreeIteratorKey((uint64_t)v14))
        {
          __strlcpy_chk();
          if (v12)
            __strlcat_chk();
          else
            v13 = 0;
          v11 = &BOMCKTreeGet_next[v13];
          v16 = strchr(&BOMCKTreeGet_next[v13], 47);
          if (v16)
            v16[1] = 0;
          if (!a2)
          {
LABEL_21:
            v21 = strchr(&BOMCKTreeGet_next[v13], 47);
            if (v21)
              *v21 = 0;
            goto LABEL_24;
          }
          v17 = 0;
          v18 = strlen(BOMCKTreeGet_next);
          while (!BOMTreeIteratorIsAtEnd((uint64_t)v15))
          {
            v19 = (const char *)BOMTreeIteratorKey((uint64_t)v15);
            if (strncmp(__s, v19, v13))
              break;
            if (strncmp(BOMCKTreeGet_next, v19, v18))
            {
              __strlcpy_chk();
              v20 = strchr(&BOMCKTreeGet_next[v13], 47);
              if (v20)
                v20[1] = 0;
              v18 = strlen(BOMCKTreeGet_next);
              ++v17;
            }
            BOMTreeIteratorNext((uint64_t)v15);
            if (v17 == a2)
              goto LABEL_21;
          }
        }
        v11 = 0;
      }
LABEL_24:
      BOMTreeIteratorFree(v15);
      return v11;
    }
    return 0;
  }
  return v11;
}

_DWORD *platform_toolbox_new(uint64_t a1)
{
  _DWORD *result;

  if (a1)
    return 0;
  result = malloc_type_calloc(1uLL, 0xD0uLL, 0x1080040013202F3uLL);
  if (result)
  {
    *result = 1885499256;
    result[50] = 2020565616;
  }
  return result;
}

void platform_toolbox_free(void *a1)
{
  if (a1 && *(_DWORD *)a1 == 1885499256 && *((_DWORD *)a1 + 50) == 2020565616)
  {
    *((_OWORD *)a1 + 11) = 0u;
    *((_OWORD *)a1 + 12) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 10) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }
}

void *platform_malloc(uint64_t a1, size_t size)
{
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t, _QWORD, size_t);

  if (!a1)
    return malloc_type_malloc(size, 0x7F3F82F6uLL);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (!v3)
      goto LABEL_7;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      v5 = *(uint64_t (**)(uint64_t, _QWORD, size_t))(a1 + 24);
      if (v5)
        return (void *)v5(a1, *(_QWORD *)(a1 + 16), size);
      return malloc_type_malloc(size, 0x7F3F82F6uLL);
    }
    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0;
}

void platform_free(uint64_t a1, void *a2)
{
  int v3;
  int v4;
  void (*v5)(uint64_t, _QWORD, void *);

  if (!a1)
  {
LABEL_9:
    free(a2);
    return;
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (!v3)
      goto LABEL_7;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      v5 = *(void (**)(uint64_t, _QWORD, void *))(a1 + 32);
      if (v5)
      {
        v5(a1, *(_QWORD *)(a1 + 16), a2);
        return;
      }
      goto LABEL_9;
    }
    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }
}

void *platform_calloc(uint64_t a1, size_t count, size_t size)
{
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t, _QWORD, size_t, size_t);

  if (!a1)
    return malloc_type_calloc(count, size, 0x384D96BCuLL);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v4 = *(_DWORD *)(a1 + 4);
    if (!v4)
      goto LABEL_7;
    v5 = *(_DWORD *)(a1 + 8);
    if (v5)
    {
      *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
      v6 = *(uint64_t (**)(uint64_t, _QWORD, size_t, size_t))(a1 + 40);
      if (v6)
        return (void *)v6(a1, *(_QWORD *)(a1 + 16), count, size);
      return malloc_type_calloc(count, size, 0x384D96BCuLL);
    }
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0;
}

void *platform_valloc(uint64_t a1, size_t size)
{
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t, _QWORD, size_t);

  if (!a1)
    return malloc_type_valloc(size, 0x13EF63B8uLL);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (!v3)
      goto LABEL_7;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      v5 = *(uint64_t (**)(uint64_t, _QWORD, size_t))(a1 + 48);
      if (v5)
        return (void *)v5(a1, *(_QWORD *)(a1 + 16), size);
      return malloc_type_valloc(size, 0x13EF63B8uLL);
    }
    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0;
}

void *platform_realloc(uint64_t a1, void *ptr, size_t size)
{
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t, _QWORD, void *, size_t);

  if (!a1)
    return malloc_type_realloc(ptr, size, 0xF43CA519uLL);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v4 = *(_DWORD *)(a1 + 4);
    if (!v4)
      goto LABEL_7;
    v5 = *(_DWORD *)(a1 + 8);
    if (v5)
    {
      *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
      v6 = *(uint64_t (**)(uint64_t, _QWORD, void *, size_t))(a1 + 56);
      if (v6)
        return (void *)v6(a1, *(_QWORD *)(a1 + 16), ptr, size);
      return malloc_type_realloc(ptr, size, 0xF43CA519uLL);
    }
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0;
}

void *platform_memset(uint64_t a1, void *__b, uint64_t __c, size_t __len)
{
  void *v4;
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t, _QWORD, void *, uint64_t, size_t);

  v4 = __b;
  if (!a1)
  {
LABEL_10:
    memset(__b, __c, __len);
    return v4;
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v6 = *(_DWORD *)(a1 + 4);
    if (v6)
    {
      v7 = *(_DWORD *)(a1 + 8);
      if (!v7)
      {
        v4 = 0;
        *__error() = v6;
        *(_DWORD *)(a1 + 4) = 0;
        return v4;
      }
      *(_DWORD *)(a1 + 8) = v7 - 1;
    }
    v8 = *(uint64_t (**)(uint64_t, _QWORD, void *, uint64_t, size_t))(a1 + 64);
    if (v8)
      return (void *)v8(a1, *(_QWORD *)(a1 + 16), __b, __c, __len);
    goto LABEL_10;
  }
  return 0;
}

void *platform_memcpy(uint64_t a1, void *__dst, void *__src, size_t __n)
{
  void *v4;
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t, _QWORD, void *, void *, size_t);

  v4 = __dst;
  if (!a1)
  {
LABEL_10:
    memcpy(__dst, __src, __n);
    return v4;
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v6 = *(_DWORD *)(a1 + 4);
    if (v6)
    {
      v7 = *(_DWORD *)(a1 + 8);
      if (!v7)
      {
        v4 = 0;
        *__error() = v6;
        *(_DWORD *)(a1 + 4) = 0;
        return v4;
      }
      *(_DWORD *)(a1 + 8) = v7 - 1;
    }
    v8 = *(uint64_t (**)(uint64_t, _QWORD, void *, void *, size_t))(a1 + 72);
    if (v8)
      return (void *)v8(a1, *(_QWORD *)(a1 + 16), __dst, __src, __n);
    goto LABEL_10;
  }
  return 0;
}

uint64_t platform_memcmp(uint64_t a1, void *__s1, void *__s2, size_t __n)
{
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t, _QWORD, void *, void *, size_t);

  if (!a1)
    return memcmp(__s1, __s2, __n);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v5 = *(_DWORD *)(a1 + 4);
    if (!v5)
      goto LABEL_7;
    v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      v7 = *(uint64_t (**)(uint64_t, _QWORD, void *, void *, size_t))(a1 + 80);
      if (v7)
        return v7(a1, *(_QWORD *)(a1 + 16), __s1, __s2, __n);
      return memcmp(__s1, __s2, __n);
    }
    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t platform_strlen(uint64_t a1, char *__s)
{
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t, _QWORD, char *);

  if (!a1)
    return strlen(__s);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (!v3)
      goto LABEL_7;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      v5 = *(uint64_t (**)(uint64_t, _QWORD, char *))(a1 + 88);
      if (v5)
        return v5(a1, *(_QWORD *)(a1 + 16), __s);
      return strlen(__s);
    }
    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return -1;
}

uint64_t platform_strnlen(uint64_t a1, char *__s1, size_t __n)
{
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t, _QWORD, char *, size_t);

  if (!a1)
    return strnlen(__s1, __n);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v4 = *(_DWORD *)(a1 + 4);
    if (!v4)
      goto LABEL_7;
    v5 = *(_DWORD *)(a1 + 8);
    if (v5)
    {
      *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
      v6 = *(uint64_t (**)(uint64_t, _QWORD, char *, size_t))(a1 + 96);
      if (v6)
        return v6(a1, *(_QWORD *)(a1 + 16), __s1, __n);
      return strnlen(__s1, __n);
    }
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return -1;
}

uint64_t platform_strncmp(uint64_t a1, char *__s1, char *__s2, size_t __n)
{
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t, _QWORD, char *, char *, size_t);

  if (!a1)
    return strncmp(__s1, __s2, __n);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v5 = *(_DWORD *)(a1 + 4);
    if (!v5)
      goto LABEL_7;
    v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      v7 = *(uint64_t (**)(uint64_t, _QWORD, char *, char *, size_t))(a1 + 104);
      if (v7)
        return v7(a1, *(_QWORD *)(a1 + 16), __s1, __s2, __n);
      return strncmp(__s1, __s2, __n);
    }
    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0xFFFFFFFFLL;
}

char *platform_strdup(uint64_t a1, char *__s1)
{
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t, _QWORD, char *);

  if (!a1)
    return strdup(__s1);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (!v3)
      goto LABEL_7;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      v5 = *(uint64_t (**)(uint64_t, _QWORD, char *))(a1 + 120);
      if (v5)
        return (char *)v5(a1, *(_QWORD *)(a1 + 16), __s1);
      return strdup(__s1);
    }
    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0;
}

uint64_t platform_strtoq(uint64_t a1, char *__str, char **__endptr, uint64_t __base)
{
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t, _QWORD, char *, char **, uint64_t);

  if (!a1)
    return strtoq(__str, __endptr, __base);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v5 = *(_DWORD *)(a1 + 4);
    if (!v5)
      goto LABEL_7;
    v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      v7 = *(uint64_t (**)(uint64_t, _QWORD, char *, char **, uint64_t))(a1 + 136);
      if (v7)
        return v7(a1, *(_QWORD *)(a1 + 16), __str, __endptr, __base);
      return strtoq(__str, __endptr, __base);
    }
    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return -1;
}

uint64_t platform_read(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t, _QWORD, uint64_t, void *, size_t);

  if (!a1)
    return read(a2, a3, a4);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v5 = *(_DWORD *)(a1 + 4);
    if (!v5)
      goto LABEL_7;
    v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      v7 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, void *, size_t))(a1 + 168);
      if (v7)
        return v7(a1, *(_QWORD *)(a1 + 16), a2, a3, a4);
      return read(a2, a3, a4);
    }
    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return -1;
}

uint64_t platform_close(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t, _QWORD, uint64_t);

  if (!a1)
    return close(a2);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (!v3)
      goto LABEL_7;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      v5 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1 + 176);
      if (v5)
        return v5(a1, *(_QWORD *)(a1 + 16), a2);
      return close(a2);
    }
    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t platform_mktime(uint64_t a1, tm *a2)
{
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t, _QWORD, tm *);

  if (!a1)
    return mktime(a2);
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    v3 = *(_DWORD *)(a1 + 4);
    if (!v3)
      goto LABEL_7;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      v5 = *(uint64_t (**)(uint64_t, _QWORD, tm *))(a1 + 184);
      if (v5)
        return v5(a1, *(_QWORD *)(a1 + 16), a2);
      return mktime(a2);
    }
    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return -1;
}

_QWORD *BOMTreeNew(uint64_t a1, unsigned int a2)
{
  if (a1 && a2)
    return _BOMTreeNew(a1, 0, a2, 0, 0);
  else
    return 0;
}

_QWORD *_BOMTreeNew(uint64_t a1, const char *a2, unsigned int a3, int a4, char a5)
{
  _QWORD *result;
  uint64_t v11;
  int v12;
  unsigned int v13;
  _QWORD *v14;

  result = _newBOMTree(a1, a2);
  if (result)
  {
    v11 = (uint64_t)result;
    *((_DWORD *)result + 4) = a3;
    if (a4)
      v12 = a4;
    else
      v12 = 4096;
    *((_DWORD *)result + 78) = v12;
    v13 = v12 - 16;
    *((_DWORD *)result + 79) = v13 >> 3;
    *((_DWORD *)result + 80) = (v13 >> 3) + 1;
    *((_DWORD *)result + 81) = v13 >> 4;
    *((_BYTE *)result + 294) = a5;
    v14 = _NewPage((uint64_t)result, 0);
    *(_QWORD *)(v11 + 24) = v14;
    *((_WORD *)v14 + 2) |= 1u;
    *(_BYTE *)(v11 + 292) = 1;
    BOMTreeFree(v11);
    return (_QWORD *)_BOMTreeOpen(a1, a2, a3, 1);
  }
  return result;
}

_QWORD *BOMTreeNewWithName(uint64_t a1, const char *a2)
{
  unsigned int v4;

  if (a1 && a2 && (v4 = BOMStorageNewNamedBlock(a1, a2)) != 0)
    return _BOMTreeNew(a1, a2, v4, 0, 0);
  else
    return 0;
}

_QWORD *BOMTreeNewWithOptions(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, char a5)
{
  int v6;
  unsigned int v8;

  if (!a1)
    return 0;
  v6 = a4;
  v8 = a2;
  if (!a2 && !a3)
    return 0;
  if (!a4)
  {
    v6 = 4096;
    if (!a2)
      goto LABEL_9;
    return _BOMTreeNew(a1, a3, v8, v6, a5);
  }
  if (a4 < 0x30)
    return 0;
  if (a2)
    return _BOMTreeNew(a1, a3, v8, v6, a5);
LABEL_9:
  v8 = BOMStorageNewNamedBlock(a1, a3);
  if (v8)
    return _BOMTreeNew(a1, a3, v8, v6, a5);
  return 0;
}

uint64_t BOMTreeOpen(uint64_t a1, unsigned int a2, char a3)
{
  if (a1 && a2)
    return _BOMTreeOpen(a1, 0, a2, a3);
  else
    return 0;
}

uint64_t _BOMTreeOpen(uint64_t a1, const char *a2, unsigned int a3, char a4)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int UInt32;
  unsigned int v13;
  _QWORD *v14;
  char __str[256];
  uint64_t v17;

  v7 = a1;
  v17 = *MEMORY[0x24BDAC8D0];
  v8 = _newBOMTree(a1, a2);
  v9 = (uint64_t)v8;
  if (v8)
  {
    *v8 = v7;
    *((_DWORD *)v8 + 4) = a3;
    if (!a2)
    {
      snprintf(__str, 0x100uLL, "<Tree %d>", a3);
      v7 = *(_QWORD *)v9;
      a3 = *(_DWORD *)(v9 + 16);
    }
    v10 = BOMStreamWithBlockID(v7, a3, 0, 0);
    if (!v10)
      goto LABEL_13;
    v11 = v10;
    if (BOMStreamReadUInt32(v10) == 1953654117)
    {
      if (BOMStreamReadUInt32(v11) == 1)
      {
        UInt32 = BOMStreamReadUInt32(v11);
        *(_DWORD *)(v9 + 312) = BOMStreamReadUInt32(v11);
        *(_DWORD *)(v9 + 20) = BOMStreamReadUInt32(v11);
        *(_BYTE *)(v9 + 294) = BOMStreamReadUInt8(v11);
        BOMStreamFree(v11);
        v13 = *(_DWORD *)(v9 + 312) - 16;
        *(_DWORD *)(v9 + 316) = v13 >> 3;
        *(_DWORD *)(v9 + 320) = (v13 >> 3) + 1;
        *(_DWORD *)(v9 + 324) = v13 >> 4;
        v14 = _NewPage(v9, UInt32);
        *(_QWORD *)(v9 + 24) = v14;
        if (v14 && !_ReadPage(v9, (uint64_t)v14))
        {
          *(_BYTE *)(v9 + 293) = a4;
          return v9;
        }
LABEL_13:
        BOMTreeFree(v9);
        return 0;
      }
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Tree '%s' has an unknown version: 0x%X\n");
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s is not a Tree\n");
    }
    BOMStreamFree(v11);
    goto LABEL_13;
  }
  return v9;
}

uint64_t BOMTreeOpenWithName(uint64_t a1, const char *a2, char a3)
{
  unsigned int NamedBlock;

  if (a1 && a2 && (NamedBlock = BOMStorageGetNamedBlock(a1, a2)) != 0)
    return _BOMTreeOpen(a1, a2, NamedBlock, a3);
  else
    return 0;
}

uint64_t BOMTreeFree(uint64_t result)
{
  uint64_t v1;
  uint64_t i;
  _WORD *v3;
  void *v4;
  const void *v5;
  void *v6;
  void *v7;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 292) && BOMTreeCommit(result))
    {
      return 1;
    }
    else
    {
      for (i = 32; i != 288; i += 8)
      {
        v3 = *(_WORD **)(v1 + i);
        if (v3)
        {
          if ((v3[2] & 2) != 0)
            _WritePage(v1, *(_QWORD *)(v1 + i));
          _FreePage(v3);
          *(_QWORD *)(v1 + i) = 0;
        }
      }
      _FreePage(*(void **)(v1 + 24));
      *(_QWORD *)(v1 + 24) = 0;
      v4 = *(void **)(v1 + 8);
      if (v4)
      {
        free(v4);
        *(_QWORD *)(v1 + 8) = 0;
      }
      v5 = *(const void **)(v1 + 304);
      if (v5)
      {
        CFRelease(v5);
        *(_QWORD *)(v1 + 304) = 0;
      }
      v6 = *(void **)(v1 + 344);
      if (v6)
      {
        free(v6);
        *(_QWORD *)(v1 + 344) = 0;
      }
      v7 = *(void **)(v1 + 328);
      if (v7)
        free(v7);
      free((void *)v1);
      return 0;
    }
  }
  return result;
}

uint64_t BOMTreeCommit(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (!a1 || !*(_BYTE *)(a1 + 292))
    return 0;
  _SyncCache(a1);
  _WritePage(a1, *(_QWORD *)(a1 + 24));
  v2 = 1;
  v3 = BOMStreamWithBlockID(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), 0x15uLL, 1);
  if (v3)
  {
    v4 = v3;
    BOMStreamWriteUInt32(v3, 0x74726565u);
    BOMStreamWriteUInt32(v4, 1u);
    BOMStreamWriteUInt32(v4, **(_DWORD **)(a1 + 24));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a1 + 312));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a1 + 20));
    BOMStreamWriteUInt8(v4, *(_BYTE *)(a1 + 294));
    if (!BOMStreamFree(v4))
    {
      v2 = 0;
      *(_BYTE *)(a1 + 292) = 0;
    }
  }
  return v2;
}

void _FreePage(void *a1)
{
  if (a1)
  {
    *(_DWORD *)a1 = -1;
    *((_QWORD *)a1 + 1) = -1;
    free(*((void **)a1 + 3));
    *((_QWORD *)a1 + 3) = 0;
    free(*((void **)a1 + 4));
    free(a1);
  }
}

uint64_t BOMTreeRemoveAndFree(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  char *v3;
  char *i;
  const void *v5;
  size_t v6;
  const char *v7;
  void *v8;
  const void *v9;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)result;
    v3 = (char *)BOMTreeIteratorNew(result, 0, 0, 0);
    if (v3)
    {
      for (i = v3; !BOMTreeIteratorIsAtEnd((uint64_t)i); BOMTreeIteratorNext((uint64_t)i))
      {
        v5 = (const void *)BOMTreeIteratorKey((uint64_t)i);
        v6 = BOMTreeIteratorKeySize((uint64_t)i);
        BOMTreeRemoveValue(v1, v5, v6);
      }
      BOMTreeIteratorFree(i);
      BOMStorageFreeBlock(v2, **(_DWORD **)(v1 + 24));
      _FreePage(*(void **)(v1 + 24));
      *(_QWORD *)(v1 + 24) = 0;
      v7 = *(const char **)(v1 + 8);
      if (v7)
        BOMStorageFreeNamedBlock(v2, v7);
      else
        BOMStorageFreeBlock(v2, *(_DWORD *)(v1 + 16));
      v8 = *(void **)(v1 + 8);
      if (v8)
      {
        free(v8);
        *(_QWORD *)(v1 + 8) = 0;
      }
      v9 = *(const void **)(v1 + 304);
      if (v9)
        CFRelease(v9);
      free((void *)v1);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

_QWORD *BOMTreeIteratorNew(uint64_t a1, const void *a2, size_t a3, BOOL *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  const __CFArray *v10;
  CFIndex v11;
  CFIndex v12;
  CFIndex v13;
  __CFArray *Mutable;
  int *v15;
  CFRange v17;

  v8 = BOM_malloczero(0x48uLL);
  v9 = v8;
  if (v8)
  {
    *v8 = a1;
    BOMTreeIteratorSet((uint64_t)v8, a2, a3, a4);
    v10 = *(const __CFArray **)(a1 + 304);
    if (v10)
    {
      v11 = BOMCFArrayMaxRange(v10);
      v13 = v12;
      v17.location = v11;
      v17.length = v13;
      if (CFArrayContainsValue(*(CFArrayRef *)(a1 + 304), v17, v9))
      {
LABEL_8:
        v9[3] = BOM_malloc(v9[4]);
        v9[6] = BOM_malloc(v9[7]);
        return v9;
      }
      Mutable = *(__CFArray **)(a1 + 304);
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0);
      *(_QWORD *)(a1 + 304) = Mutable;
      if (!Mutable)
      {
        v15 = __error();
        _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2460, *v15);
        goto LABEL_8;
      }
    }
    CFArrayAppendValue(Mutable, v9);
    goto LABEL_8;
  }
  return v9;
}

uint64_t BOMTreeIteratorIsAtEnd(uint64_t a1)
{
  uint64_t result;
  _DWORD *v3;

  if (!a1)
    return 1;
  if (*(_BYTE *)(a1 + 67))
    return 1;
  if (!*(_BYTE *)(a1 + 65))
  {
    v3 = *(_DWORD **)(a1 + 8);
    if (v3)
    {
      if (*v3 == *(_DWORD *)(a1 + 16))
        return 0;
    }
  }
  if (_revalidateIterator(a1))
    return *(unsigned __int8 *)(a1 + 67);
  result = 1;
  *(_BYTE *)(a1 + 67) = 1;
  return result;
}

uint64_t BOMTreeIteratorKey(uint64_t result)
{
  uint64_t v1;
  _DWORD *v2;
  unint64_t v3;
  void *v4;
  unint64_t v5;
  unint64_t v6;
  size_t v7;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 67))
      return 0;
    if ((*(_BYTE *)(result + 65) || (v2 = *(_DWORD **)(result + 8)) == 0 || *v2 != *(_DWORD *)(result + 16))
      && !_revalidateIterator(result))
    {
      result = 0;
      *(_BYTE *)(v1 + 67) = 1;
      return result;
    }
    if (*(_BYTE *)(*(_QWORD *)v1 + 294))
      return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 24) + 4 * *(unsigned int *)(v1 + 20));
    if (!*(_BYTE *)(v1 + 40))
    {
      v3 = BOMStorageSizeOfBlock(**(_QWORD **)v1, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 24) + 4 * *(unsigned int *)(v1 + 20)));
      v4 = *(void **)(v1 + 24);
      v5 = *(_QWORD *)(v1 + 32);
      if (v3 > v5)
      {
        v6 = v3;
        if (v4)
        {
          free(*(void **)(v1 + 24));
          *(_QWORD *)(v1 + 24) = 0;
          v5 = *(_QWORD *)(v1 + 32);
        }
        if (v6 <= 2 * v5)
          v7 = 2 * v5;
        else
          v7 = v6;
        *(_QWORD *)(v1 + 32) = v7;
        v4 = BOM_malloc(v7);
        *(_QWORD *)(v1 + 24) = v4;
      }
      if (BOMStorageCopyFromBlock(**(_QWORD **)v1, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 24) + 4 * *(unsigned int *)(v1 + 20)), v4))return 0;
      *(_BYTE *)(v1 + 40) = 1;
    }
    return *(_QWORD *)(v1 + 24);
  }
  return result;
}

uint64_t BOMTreeIteratorKeySize(uint64_t a1)
{
  _DWORD *v3;

  if (!a1 || *(_BYTE *)(a1 + 67))
    return 0;
  if ((*(_BYTE *)(a1 + 65) || (v3 = *(_DWORD **)(a1 + 8)) == 0 || *v3 != *(_DWORD *)(a1 + 16))
    && !_revalidateIterator(a1))
  {
    *(_BYTE *)(a1 + 67) = 1;
    return 0;
  }
  if (*(_BYTE *)(*(_QWORD *)a1 + 294))
    return 0;
  return BOMStorageSizeOfBlock(**(_QWORD **)a1, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24) + 4 * *(unsigned int *)(a1 + 20)));
}

uint64_t BOMTreeRemoveValue(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v3;
  uint64_t v6;

  v3 = 1;
  if (a1 && a2)
  {
    if (a3 || *(_BYTE *)(a1 + 294))
    {
      if (*(_BYTE *)(a1 + 293))
      {
        v6 = *(_QWORD *)(a1 + 24);
        v3 = _findRemove(a1, &v6, 0, 0, 0, 0, a2, a3, 0);
        if (!(_DWORD)v3)
        {
          --*(_DWORD *)(a1 + 20);
          *(_BYTE *)(a1 + 292) = 1;
        }
      }
      else
      {
        v3 = 1;
        fwrite("tree is read-only\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      }
    }
    else
    {
      return 1;
    }
  }
  return v3;
}

uint64_t BOMTreeIteratorNext(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  _DWORD *v5;

  if (result)
  {
    v1 = result;
    if (!*(_BYTE *)(result + 67))
    {
      if (!*(_BYTE *)(result + 65) && (v5 = *(_DWORD **)(result + 8)) != 0 && *v5 == *(_DWORD *)(result + 16)
        || (result = _revalidateIterator(result), (_DWORD)result))
      {
        if (*(_BYTE *)(v1 + 66))
        {
          v2 = *(_DWORD *)(v1 + 20) + 1;
          *(_DWORD *)(v1 + 20) = v2;
          v3 = *(_QWORD *)(v1 + 8);
          if (v2 >= *(unsigned __int16 *)(v3 + 16))
          {
            *(_DWORD *)(v1 + 20) = 0;
            v4 = *(_DWORD *)(v3 + 8);
            if (!v4
              || (*(_DWORD *)(v1 + 16) = v4,
                  result = (uint64_t)_findPage(*(_QWORD *)v1, v4),
                  (*(_QWORD *)(v1 + 8) = result) == 0))
            {
              *(_BYTE *)(v1 + 67) = 1;
            }
          }
        }
        else
        {
          *(_BYTE *)(v1 + 66) = 1;
        }
        *(_BYTE *)(v1 + 40) = 0;
        *(_BYTE *)(v1 + 64) = 0;
      }
      else
      {
        *(_BYTE *)(v1 + 67) = 1;
      }
    }
  }
  return result;
}

void BOMTreeIteratorFree(char *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  const __CFArray *v5;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  CFIndex FirstIndexOfValue;
  CFRange v10;

  if (a1)
  {
    *(_WORD *)(a1 + 65) = 1;
    a1[67] = 1;
    v2 = (void *)*((_QWORD *)a1 + 3);
    if (v2)
    {
      free(v2);
      *((_QWORD *)a1 + 3) = 0;
    }
    a1[40] = 0;
    v3 = (void *)*((_QWORD *)a1 + 6);
    if (v3)
    {
      free(v3);
      *((_QWORD *)a1 + 6) = 0;
    }
    a1[64] = 0;
    *((_DWORD *)a1 + 4) = -1;
    *((_QWORD *)a1 + 1) = 0;
    v4 = *(_QWORD *)a1;
    v5 = *(const __CFArray **)(*(_QWORD *)a1 + 304);
    if (v5)
    {
      v6 = BOMCFArrayMaxRange(v5);
      v8 = v7;
      v10.location = v6;
      v10.length = v8;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v4 + 304), v10, a1);
      if (FirstIndexOfValue != -1)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v4 + 304), FirstIndexOfValue);
        if (!CFArrayGetCount(*(CFArrayRef *)(v4 + 304)))
        {
          CFRelease(*(CFTypeRef *)(v4 + 304));
          *(_QWORD *)(v4 + 304) = 0;
        }
      }
    }
    free(a1);
  }
}

uint64_t _SyncCache(uint64_t result)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    for (i = 32; i != 288; i += 8)
    {
      v3 = *(_QWORD *)(v1 + i);
      if (v3)
      {
        if ((*(_WORD *)(v3 + 4) & 2) != 0)
          result = _WritePage(v1, v3);
      }
    }
  }
  return result;
}

uint64_t _WritePage(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  result = BOMStreamWithBlockID(*(_QWORD *)a1, *(_DWORD *)a2, *(unsigned int *)(a1 + 312), 1);
  if (result)
  {
    v4 = result;
    BOMStreamWriteUInt16(result, *(_WORD *)(a2 + 4) & 1);
    BOMStreamWriteUInt16(v4, *(_WORD *)(a2 + 16));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a2 + 8));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a2 + 12));
    if (*(_WORD *)(a2 + 16))
    {
      v5 = 0;
      do
      {
        BOMStreamWriteUInt32(v4, *(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * v5));
        BOMStreamWriteUInt32(v4, *(_DWORD *)(*(_QWORD *)(a2 + 24) + 4 * v5++));
        v6 = *(unsigned __int16 *)(a2 + 16);
      }
      while (v5 < v6);
    }
    else
    {
      v6 = 0;
    }
    BOMStreamWriteUInt32(v4, *(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * v6));
    result = BOMStreamFree(v4);
    *(_WORD *)(a2 + 4) &= ~2u;
  }
  return result;
}

uint64_t BOMTreeStorage(uint64_t result)
{
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t BOMTreeSetCompareFunc(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 296) = a2;
  return result;
}

uint64_t BOMTreeCount(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 20);
  return result;
}

uint64_t BOMTreeSetValue(_QWORD *a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  void **PagesForKey;
  uint64_t *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  unsigned int IndexForKey;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  BOOL v22;

  v22 = 0;
  v5 = 1;
  if (!a1 || !a2)
    return v5;
  if (!a3 && !*((_BYTE *)a1 + 294))
    return 1;
  if (!*((_BYTE *)a1 + 293))
  {
    v5 = 1;
    fwrite("tree is read-only\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return v5;
  }
  PagesForKey = _FindPagesForKey((uint64_t)a1, a2, a3);
  if (!PagesForKey)
    return 1;
  v12 = (uint64_t *)PagesForKey;
  if (*((_BYTE *)a1 + 294))
  {
    v13 = (int)a2;
    goto LABEL_9;
  }
  v15 = BOMStackPeek(PagesForKey);
  if (!v15)
    goto LABEL_23;
  v16 = v15;
  IndexForKey = _findIndexForKey((uint64_t)a1, (uint64_t)v15, a2, a3, &v22);
  if (!v22)
  {
    v19 = BOMStorageNewBlock(*a1);
    if (!(_DWORD)v19)
      goto LABEL_23;
    v13 = v19;
    if (BOMStorageSetBlockData(*a1, v19, a2, a3))
      goto LABEL_23;
LABEL_9:
    v14 = BOMStorageNewBlock(*a1);
    if (!(_DWORD)v14)
      goto LABEL_23;
    goto LABEL_10;
  }
  v18 = v16[4];
  v13 = *(_DWORD *)(v16[3] + 4 * IndexForKey);
  v14 = *(unsigned int *)(v18 + 4 * IndexForKey);
  if (!(_DWORD)v14)
    goto LABEL_9;
LABEL_10:
  if (!BOMStorageSetBlockData(*a1, v14, a4, a5)
    && !_PageSetValue((uint64_t)a1, v12, a2, a3, v13, v14))
  {
    if (!v22)
      ++*((_DWORD *)a1 + 5);
    v5 = 0;
    *((_BYTE *)a1 + 292) = 1;
    goto LABEL_25;
  }
LABEL_23:
  v5 = 1;
LABEL_25:
  while (!BOMStackIsEmpty((uint64_t)v12))
  {
    v20 = BOMStackPop(v12);
    *((_WORD *)v20 + 2) &= ~8u;
  }
  BOMStackFree((void **)v12);
  return v5;
}

void **_FindPagesForKey(uint64_t a1, const void *a2, size_t a3)
{
  void **v6;

  v6 = BOMStackNew();
  if (!_findPagesForKey(a1, (char *)v6, a2, a3))
  {
    BOMStackFree(v6);
    return 0;
  }
  return v6;
}

uint64_t _findIndexForKey(uint64_t a1, uint64_t a2, const void *a3, size_t a4, BOOL *a5)
{
  int v9;
  int v10;
  uint64_t v11;
  void *v12;
  unint64_t v13;
  size_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t (*v17)(const void *, size_t, void *, size_t);
  int v18;
  int v19;
  BOOL v20;
  size_t v21;

  if (*(_WORD *)(a2 + 16))
  {
    v9 = 0;
    v10 = *(unsigned __int16 *)(a2 + 16) - 1;
    while (1)
    {
      v11 = v9 + ((v10 - v9) >> 1);
      v12 = (void *)*(unsigned int *)(*(_QWORD *)(a2 + 24) + 4 * v11);
      if (!(_DWORD)v12)
        break;
      if (*(_BYTE *)(a1 + 294))
        goto LABEL_13;
      v13 = BOMStorageSizeOfBlock(*(_QWORD *)a1, v12);
      v14 = v13;
      v15 = *(unsigned int *)(a1 + 352);
      v12 = *(void **)(a1 + 344);
      if (v13 > v15)
      {
        v16 = (2 * v15);
        if (v13 > v16)
          LODWORD(v16) = v13;
        *(_DWORD *)(a1 + 352) = v16;
        if (v12)
        {
          free(v12);
          *(_QWORD *)(a1 + 344) = 0;
          LODWORD(v16) = *(_DWORD *)(a1 + 352);
        }
        v12 = BOM_malloc(v16);
        *(_QWORD *)(a1 + 344) = v12;
      }
      BOMStorageCopyFromBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(a2 + 24) + 4 * v11), v12);
LABEL_14:
      v17 = *(uint64_t (**)(const void *, size_t, void *, size_t))(a1 + 296);
      if (v17)
      {
        v18 = v17(a3, a4, v12, v14);
      }
      else
      {
        if (*(_BYTE *)(a1 + 294))
        {
          if (v12 <= a3)
            v19 = 0;
          else
            v19 = -1;
          if (v12 < a3)
            v18 = 1;
          else
            v18 = v19;
          goto LABEL_23;
        }
        if (v12 == a3)
        {
          if (!a5)
            return v11;
          v18 = 0;
          v20 = 1;
          goto LABEL_25;
        }
        if (a3)
        {
          if (!v12)
          {
            v18 = 1;
            goto LABEL_23;
          }
          if (a4 >= v14)
            v21 = v14;
          else
            v21 = a4;
          v18 = memcmp(a3, v12, v21);
          if (v18)
            goto LABEL_23;
          if (v14 <= a4)
          {
            v18 = v14 < a4;
            goto LABEL_23;
          }
        }
        v18 = -1;
      }
LABEL_23:
      if (!a5)
        goto LABEL_26;
      v20 = v18 == 0;
LABEL_25:
      *a5 = v20;
LABEL_26:
      if (v10 == v9)
      {
        if (v18 <= 0)
          return v11;
        else
          return (v11 + 1);
      }
      if (v18 >= 1)
      {
        if ((_DWORD)v11 == v10)
          v9 += (v10 - v9) >> 1;
        else
          v9 = v11 + 1;
      }
      else
      {
        if ((v18 & 0x80000000) == 0)
          return v11;
        v10 = v11 - ((v10 - v9) > 1);
      }
    }
    v12 = 0;
LABEL_13:
    v14 = 0;
    goto LABEL_14;
  }
  v11 = 0;
  if (a5)
    *a5 = 0;
  return v11;
}

uint64_t _PageSetValue(uint64_t a1, uint64_t *a2, const void *a3, size_t a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t *v13;
  uint64_t v14;
  _BOOL4 v15;
  unsigned int IndexForKey;
  unsigned __int16 v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  _QWORD *v24;
  unsigned int *v25;
  int v26;
  int v27;
  int v28;
  _QWORD *Page;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int16 v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  _DWORD *v42;
  int v43;
  const char *v44;
  int v45;
  BOOL v47;

  v47 = 0;
  v6 = 1;
  if (a5)
  {
    if (a6)
    {
      v13 = BOMStackPop(a2);
      if (v13)
      {
        v14 = (uint64_t)v13;
        v15 = (*((_WORD *)v13 + 2) & 1) == 0;
        _invalidateIteratorsForPageID(a1, *(_DWORD *)v13);
        IndexForKey = _findIndexForKey(a1, v14, a3, a4, &v47);
        if (v47)
        {
          v17 = *(_WORD *)(v14 + 16);
        }
        else
        {
          v18 = *(_QWORD *)(v14 + 24);
          if (*(_DWORD *)(v18 + 4 * IndexForKey))
          {
            if (*(_BYTE *)(a1 + 295))
              *(_BYTE *)(a1 + 295) = 0;
            v19 = *(unsigned __int16 *)(v14 + 16);
            LODWORD(v20) = v19 - IndexForKey;
            if (v19 != IndexForKey)
            {
              v21 = *(_QWORD *)(v14 + 32);
              if (v20 <= 1)
                v20 = 1;
              else
                v20 = v20;
              v22 = v15 + v19;
              v23 = *(unsigned __int16 *)(v14 + 16);
              do
              {
                *(_DWORD *)(v18 + 4 * v23) = *(_DWORD *)(v18 + 4 * (v23 - 1));
                *(_DWORD *)(v21 + 4 * v22) = *(_DWORD *)(v21 + 4 * (v22 - 1));
                --v23;
                --v22;
                --v20;
              }
              while (v20);
            }
          }
          else
          {
            LOWORD(v19) = *(_WORD *)(v14 + 16);
          }
          *(_DWORD *)(v18 + 4 * IndexForKey) = a5;
          v17 = v19 + 1;
          *(_WORD *)(v14 + 16) = v19 + 1;
        }
        *(_DWORD *)(*(_QWORD *)(v14 + 32) + 4 * (IndexForKey + v15)) = a6;
        *(_WORD *)(v14 + 4) |= 2u;
        if (*(_DWORD *)(a1 + 316) >= v17)
        {
          v6 = 0;
        }
        else
        {
          v24 = _NewPage(a1, 0);
          if (v24)
          {
            v25 = (unsigned int *)v24;
            *((_WORD *)v24 + 2) = *((_WORD *)v24 + 2) & 0xFFFC | *(_WORD *)(v14 + 4) & 1 | 2;
            if ((*(_WORD *)(v14 + 4) & 1) == 0
              || (v26 = *(_DWORD *)v24,
                  v27 = *(_DWORD *)v14,
                  *((_DWORD *)v24 + 2) = *(_DWORD *)(v14 + 8),
                  *(_DWORD *)(v14 + 8) = v26,
                  *((_DWORD *)v24 + 3) = v27,
                  (v28 = *((_DWORD *)v24 + 2)) == 0))
            {
LABEL_25:
              if (*(_BYTE *)(a1 + 295))
              {
                LODWORD(v30) = *(_DWORD *)(a1 + 316) - 1;
                v31 = *(unsigned __int16 *)(v14 + 16);
              }
              else
              {
                v31 = *(unsigned __int16 *)(v14 + 16);
                LODWORD(v30) = v31 >> 1;
              }
              if ((int)v30 + 1 >= (int)v31)
              {
                v34 = *((_QWORD *)v25 + 4);
                v37 = *((_WORD *)v25 + 8);
                v30 = (int)v30;
                v38 = v31;
                v32 = *(_QWORD *)(v14 + 24);
                v33 = *(_QWORD *)(v14 + 32);
              }
              else
              {
                v32 = *(_QWORD *)(v14 + 24);
                v33 = *(_QWORD *)(v14 + 32);
                v35 = *((_QWORD *)v25 + 3);
                v34 = *((_QWORD *)v25 + 4);
                v30 = (int)v30;
                v36 = (int)v30 + 1;
                v37 = *((_WORD *)v25 + 8);
                do
                {
                  *(_DWORD *)(v35 + 4 * v37) = *(_DWORD *)(v32 + 4 * v36);
                  *(_DWORD *)(v34 + 4 * v37++) = *(_DWORD *)(v33 + 4 * v36);
                  *(_DWORD *)(v32 + 4 * v36) = 0;
                  *((_WORD *)v25 + 8) = v37;
                  *(_DWORD *)(v33 + 4 * v36++) = 0;
                  v38 = *(unsigned __int16 *)(v14 + 16);
                }
                while (v36 < v38);
                LOWORD(v31) = *(_WORD *)(v14 + 16);
              }
              *(_DWORD *)(v34 + 4 * v37) = *(_DWORD *)(v33 + 4 * v38);
              *(_DWORD *)(v33 + 4 * v38) = 0;
              *(_WORD *)(v14 + 16) = v31 - v37;
              v39 = *(unsigned int *)(v32 + 4 * v30);
              if ((*(_BYTE *)(v14 + 4) & 1) == 0)
              {
                *(_DWORD *)(v32 + 4 * v30) = 0;
                *(_WORD *)(v14 + 16) = v31 - v37 - 1;
              }
              _addPageToCache(a1, (uint64_t)v25);
              if (BOMStackIsEmpty((uint64_t)a2))
              {
                v40 = _NewPage(a1, 0);
                v6 = 1;
                if (v40)
                {
                  v41 = v40;
                  v42 = (_DWORD *)v40[4];
                  *(_DWORD *)v40[3] = v39;
                  *v42 = *(_DWORD *)v14;
                  v42[1] = *v25;
                  *((_WORD *)v40 + 8) = 1;
                  *((_WORD *)v40 + 2) |= 2u;
                  _addPageToCache(a1, v14);
                  v6 = 0;
                  *(_QWORD *)(a1 + 24) = v41;
                }
              }
              else
              {
                v6 = _PageSetValue(a1, a2, a3, a4, v39, *v25);
              }
              goto LABEL_44;
            }
            Page = _findPage(a1, v28);
            if (Page)
            {
              if (*((_DWORD *)Page + 3) == *(_DWORD *)v14)
              {
                *((_DWORD *)Page + 3) = *v25;
                *((_WORD *)Page + 2) |= 2u;
                goto LABEL_25;
              }
              v43 = *__error();
              v44 = "internal btree error";
              v6 = 1;
              v45 = 1998;
            }
            else
            {
              v43 = *__error();
              v44 = "missing tree page";
              v6 = 1;
              v45 = 1994;
            }
            _BOMExceptionHandlerCall((uint64_t)v44, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", v45, v43);
          }
          else
          {
            v6 = 1;
          }
        }
LABEL_44:
        *(_WORD *)(v14 + 4) &= ~8u;
      }
    }
  }
  return v6;
}

uint64_t BOMTreeGetValueSize(uint64_t a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t PagesForKey;
  uint64_t v10;
  unsigned int IndexForKey;
  uint64_t v12;
  BOOL v13;

  result = 1;
  if (a1 && a2 && a4 && (a3 || *(_BYTE *)(a1 + 294)))
  {
    PagesForKey = _findPagesForKey(a1, 0, a2, a3);
    if (PagesForKey && (v10 = PagesForKey, v13 = 0, IndexForKey = _findIndexForKey(a1, PagesForKey, a2, a3, &v13), v13))
    {
      v12 = BOMStorageSizeOfBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(v10 + 32) + 4 * IndexForKey));
      result = 0;
      *a4 = v12;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

unint64_t BOMTreeGetValue(uint64_t a1, const void *a2, size_t a3)
{
  unint64_t result;
  unint64_t v7;
  unsigned int IndexForKey;
  unsigned int v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  BOOL v13;

  result = 0;
  v13 = 0;
  if (a1 && a2)
  {
    if (!a3 && !*(_BYTE *)(a1 + 294))
      return 0;
    result = _findPagesForKey(a1, 0, a2, a3);
    if (!result)
      return result;
    v7 = result;
    IndexForKey = _findIndexForKey(a1, result, a2, a3, &v13);
    if (!v13)
      return 0;
    v9 = IndexForKey;
    result = BOMStorageSizeOfBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(v7 + 32) + 4 * IndexForKey));
    if (!result)
      return result;
    v10 = result;
    v11 = *(void **)(a1 + 328);
    if (v11)
    {
      if (result <= *(unsigned int *)(a1 + 336))
        goto LABEL_16;
      free(*(void **)(a1 + 328));
      *(_QWORD *)(a1 + 328) = 0;
      v12 = (2 * *(_DWORD *)(a1 + 336));
      if (v10 <= v12)
        result = v12;
      else
        result = v10;
      *(_DWORD *)(a1 + 336) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 336) = result;
      result = result;
    }
    v11 = BOM_malloc(result);
    *(_QWORD *)(a1 + 328) = v11;
LABEL_16:
    if (!BOMStorageCopyFromBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(v7 + 32) + 4 * v9), v11))
      return *(_QWORD *)(a1 + 328);
    return 0;
  }
  return result;
}

uint64_t _findRemove(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8, char *a9)
{
  uint64_t *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unsigned int IndexForKey;
  unsigned int v19;
  uint64_t v20;
  _QWORD *v21;
  __int16 v22;
  _BOOL4 v23;
  uint64_t result;
  char v25;
  _QWORD *v26;
  __int16 v27;
  char v28;
  _QWORD *v29;
  const void *v30;
  char v31;
  __int16 v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  BOOL v41;
  __int16 v42;
  unsigned int v43;
  unsigned int v44;
  _WORD *v45;
  uint64_t v46;
  uint64_t v47;
  _BOOL4 v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  _WORD *Page;
  int v53;
  unsigned int v54;
  uint64_t v55;
  _BOOL4 v56;
  _WORD *v57;
  int v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t *v62;
  char v63;
  unsigned __int16 v64;
  uint64_t v65;
  int *v66;
  uint64_t v67;
  uint64_t v68;
  size_t v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  uint64_t v76;
  char *v78;
  char v79;
  _QWORD *v80;
  BOOL v81;

  v14 = a2;
  v15 = a1;
  v16 = a9;
  v81 = 0;
  v17 = *a2;
  v80 = 0;
  v79 = 0;
  if (!a9)
    v16 = &v79;
  v78 = v16;
  IndexForKey = _findIndexForKey(a1, v17, a7, a8, &v81);
  v19 = IndexForKey;
  *(_DWORD *)(v17 + 20) = IndexForKey;
  if ((*(_BYTE *)(v17 + 4) & 1) != 0)
  {
    v23 = v81;
    result = 1;
    if (!v81)
      return result;
LABEL_42:
    if (v23)
    {
      _invalidateIteratorsForPageID(v15, *(_DWORD *)v17);
LABEL_45:
      v34 = *(unsigned __int16 *)(v17 + 16);
      v35 = *(_QWORD *)(v17 + 24);
      LODWORD(v36) = v34 - v19;
      if (v34 == v19)
      {
        v37 = 0;
        v38 = 0;
        *(_DWORD *)(v35 + 4 * (v19 - 1)) = 0;
        v39 = *(_QWORD *)(v17 + 32);
      }
      else
      {
        v37 = *(_DWORD *)(v35 + 4 * v19);
        v39 = *(_QWORD *)(v17 + 32);
        v38 = *(_DWORD *)(v39 + 4 * v19);
        if (v36 <= 1)
          v36 = 1;
        else
          v36 = v36;
        v40 = v19;
        do
        {
          *(_DWORD *)(v35 + 4 * v40) = *(_DWORD *)(v35 + 4 * (v40 + 1));
          *(_DWORD *)(v39 + 4 * v40) = *(_DWORD *)(v39 + 4 * (v40 + 1));
          ++v40;
          --v36;
        }
        while (v36);
      }
      *(_DWORD *)(v39 + 4 * v34) = 0;
      *(_WORD *)(v17 + 16) = v34 - 1;
      if ((*(_WORD *)(v17 + 4) & 1) != 0)
      {
        if (*(_BYTE *)(v15 + 294))
          v41 = 1;
        else
          v41 = v37 == 0;
        if (!v41)
          BOMStorageFreeBlock(*(_QWORD *)v15, v37);
        if (v38)
          BOMStorageFreeBlock(*(_QWORD *)v15, v38);
      }
      v42 = *(_WORD *)(v17 + 4);
      *(_WORD *)(v17 + 4) = v42 | 2;
      v43 = *(unsigned __int16 *)(v17 + 16);
      if ((v42 & 1) != 0 && a6 && v19 == v43)
      {
        *(_DWORD *)(*(_QWORD *)(a6 + 24) + 4 * *(unsigned int *)(a6 + 20)) = *(_DWORD *)(*(_QWORD *)(v17 + 24)
                                                                                         + 4 * (v19 - 1));
        *(_WORD *)(a6 + 4) |= 2u;
        v43 = *(unsigned __int16 *)(v17 + 16);
      }
      v44 = *(_DWORD *)(v15 + 324);
      if (v44 <= v43)
      {
        result = 0;
        *v78 = 0;
        return result;
      }
      if (v17 == *(_QWORD *)(v15 + 24))
      {
        if (!(*(_WORD *)(v17 + 4) & 1 | v43))
        {
          v51 = **(_DWORD **)(v17 + 32);
          if (v51)
          {
            Page = _findPage(v15, v51);
            Page[2] &= ~8u;
            _removePageFromCache(v15, Page);
            *(_QWORD *)(v15 + 24) = Page;
            BOMStorageFreeBlock(*(_QWORD *)v15, *(_DWORD *)v17);
            _FreePage((void *)v17);
          }
        }
      }
      else if (a3 | a4)
      {
        v73 = a3;
        v75 = v14;
        v45 = (_WORD *)*v14;
        if (a3)
          v46 = a3;
        else
          v46 = a4;
        v47 = a5;
        if (!a3)
          v47 = a6;
        if (a4)
          v48 = a3 != 0;
        else
          v48 = 0;
        v70 = v48;
        if (v48)
        {
          v49 = *(unsigned __int16 *)(a3 + 16);
          v50 = *(unsigned __int16 *)(a4 + 16);
          if (v49 >= v50)
          {
            if (v49 <= v50)
            {
              v53 = *(_DWORD *)(*(_QWORD *)(a6 + 32) + 4 * *(unsigned int *)(a6 + 20));
              if (*(_DWORD *)v45 == v53)
                v46 = a4;
              else
                v46 = a3;
              if (*(_DWORD *)v45 != v53)
                a6 = a5;
            }
            else
            {
              v46 = a3;
              a6 = a5;
            }
          }
          else
          {
            v46 = a4;
          }
        }
        else
        {
          a6 = v47;
        }
        v54 = *(unsigned __int16 *)(v46 + 16);
        v55 = a4;
        v41 = v46 == a4;
        v56 = v46 == a4;
        if (v41)
          v57 = v45;
        else
          v57 = (_WORD *)v46;
        if ((v45[2] & 1) != 0)
          _invalidateIteratorsForPageID(v15, *(_DWORD *)v46);
        v58 = *(_DWORD *)(a6 + 20) - (v46 != v55);
        if ((v57[2] & 1) == 0)
        {
          v59 = (unsigned __int16)v57[8];
          *(_DWORD *)(*((_QWORD *)v57 + 3) + 4 * v59) = *(_DWORD *)(*(_QWORD *)(a6 + 24) + 4 * v58);
          v57[8] = v59 + 1;
          v57[2] |= 2u;
        }
        if (v44 < v54)
        {
          _shiftKeysAndValues(v15, (uint64_t)v45, v46, v56);
          v60 = *(_DWORD *)(*((_QWORD *)v57 + 3) + 4 * (unsigned __int16)v57[8] - 4);
          v61 = *(_QWORD *)(a6 + 24);
          if (*(_DWORD *)(v61 + 4 * v58) != v60)
          {
            *(_DWORD *)(v61 + 4 * v58) = v60;
            *(_WORD *)(a6 + 4) |= 2u;
          }
          v62 = v75;
          v63 = 0;
          if ((v57[2] & 1) == 0)
          {
            v64 = v57[8] - 1;
            v57[8] = v64;
            *(_DWORD *)(*((_QWORD *)v57 + 3) + 4 * v64) = 0;
            v57[2] |= 2u;
          }
          goto LABEL_112;
        }
        v65 = v55;
        _shiftKeysAndValues(v15, v46, (uint64_t)v45, v46 != v55);
        if (v70)
        {
          v62 = v75;
          *(_DWORD *)(v73 + 8) = *(_DWORD *)v65;
          *(_DWORD *)(v65 + 12) = *(_DWORD *)v73;
          *(_WORD *)(v73 + 4) |= 2u;
        }
        else if (v73)
        {
          *(_DWORD *)(v73 + 8) = 0;
          v65 = v73;
          v62 = v75;
        }
        else
        {
          v62 = v75;
          if (!v65)
          {
LABEL_111:
            v45[2] &= ~8u;
            _removePageFromCache(v15, v45);
            BOMStorageFreeBlock(*(_QWORD *)v15, *(_DWORD *)v45);
            _FreePage(v45);
            v45 = 0;
            v63 = 1;
LABEL_112:
            result = 0;
            *v78 = v63;
            *v62 = (uint64_t)v45;
            return result;
          }
          *(_DWORD *)(v65 + 12) = 0;
        }
        *(_WORD *)(v65 + 4) |= 2u;
        goto LABEL_111;
      }
      return 0;
    }
LABEL_44:
    if (!*v78)
      return 0;
    goto LABEL_45;
  }
  v72 = a3;
  v76 = a6;
  if (IndexForKey)
  {
    v20 = v15;
    v21 = _findPage(v15, *(_DWORD *)(*(_QWORD *)(v17 + 32) + 4 * (IndexForKey - 1)));
    v22 = *((_WORD *)v21 + 2);
    if ((v22 & 8) == 0)
    {
      v68 = v17;
LABEL_12:
      v25 = 0;
      *((_WORD *)v21 + 2) = v22 | 8;
      goto LABEL_16;
    }
    v25 = 1;
    v68 = v17;
  }
  else if (a3)
  {
    v20 = v15;
    v21 = _findPage(v15, *(_DWORD *)(*(_QWORD *)(a3 + 32) + 4 * *(unsigned __int16 *)(a3 + 16)));
    v22 = *((_WORD *)v21 + 2);
    if ((v22 & 8) == 0)
    {
      v68 = a5;
      goto LABEL_12;
    }
    v25 = 1;
    v68 = a5;
  }
  else
  {
    v20 = v15;
    v68 = 0;
    v21 = 0;
    v25 = 1;
  }
LABEL_16:
  v74 = v14;
  v69 = a8;
  v71 = a4;
  if (v19 == *(unsigned __int16 *)(v17 + 16))
  {
    if (a4)
    {
      v26 = _findPage(v20, **(_DWORD **)(a4 + 32));
      v27 = *((_WORD *)v26 + 2);
      if ((v27 & 8) == 0)
      {
        v67 = v76;
LABEL_22:
        v28 = 0;
        *((_WORD *)v26 + 2) = v27 | 8;
        goto LABEL_26;
      }
      v28 = 1;
      v67 = v76;
    }
    else
    {
      v67 = 0;
      v26 = 0;
      v28 = 1;
    }
  }
  else
  {
    v26 = _findPage(v20, *(_DWORD *)(*(_QWORD *)(v17 + 32) + 4 * (v19 + 1)));
    v27 = *((_WORD *)v26 + 2);
    if ((v27 & 8) == 0)
    {
      v67 = v17;
      goto LABEL_22;
    }
    v28 = 1;
    v67 = v17;
  }
LABEL_26:
  v29 = _findPage(v20, *(_DWORD *)(*(_QWORD *)(v17 + 32) + 4 * v19));
  v80 = v29;
  if (!v29)
  {
    v66 = __error();
    _BOMFatalException((uint64_t)"BOMTree in invalid state - nextNode is NULL!\n", "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 1604, *v66);
  }
  v30 = a7;
  v31 = v25;
  v32 = *((_WORD *)v29 + 2);
  if ((v32 & 8) == 0)
    *((_WORD *)v29 + 2) = v32 | 8;
  v33 = v28;
  a3 = v72;
  if (v72)
    *(_WORD *)(v72 + 4) &= ~4u;
  a4 = v71;
  if (v71)
    *(_WORD *)(v71 + 4) &= ~4u;
  *((_WORD *)v29 + 2) &= ~4u;
  result = _findRemove(v20, &v80, v21, v26, v68, v67, v30, v69, v78);
  if ((v31 & 1) == 0)
    *((_WORD *)v21 + 2) &= ~8u;
  if ((v33 & 1) == 0)
    *((_WORD *)v26 + 2) &= ~8u;
  v15 = v20;
  if ((v32 & 8) == 0 && v80)
    *((_WORD *)v80 + 2) &= ~8u;
  v14 = v74;
  a6 = v76;
  if (!(_DWORD)result)
  {
    v23 = v81;
    if ((*(_WORD *)(v17 + 4) & 1) == 0)
      goto LABEL_44;
    goto LABEL_42;
  }
  return result;
}

uint64_t BOMTreeCopyToTree(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char *v4;
  char *i;
  const void *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = 1;
  if (a1 && a2)
  {
    if (!*(_DWORD *)(a2 + 20))
      *(_BYTE *)(a2 + 295) = 1;
    v4 = (char *)BOMTreeIteratorNew(a1, 0, 0, 0);
    if (!v4)
      goto LABEL_13;
    for (i = v4; ; BOMTreeIteratorNext((uint64_t)i))
    {
      if (BOMTreeIteratorIsAtEnd((uint64_t)i))
      {
        v3 = 0;
        goto LABEL_11;
      }
      v6 = (const void *)BOMTreeIteratorKey((uint64_t)i);
      v7 = BOMTreeIteratorKeySize((uint64_t)i);
      v8 = BOMTreeIteratorValue((uint64_t)i);
      v9 = BOMTreeIteratorValueSize((uint64_t)i);
      if (BOMTreeSetValue((_QWORD *)a2, v6, v7, v8, v9))
        break;
    }
    v3 = 1;
LABEL_11:
    BOMTreeIteratorFree(i);
  }
  if (a2)
LABEL_13:
    *(_BYTE *)(a2 + 295) = 0;
  return v3;
}

uint64_t BOMTreeIteratorValue(uint64_t result)
{
  uint64_t v1;
  _DWORD *v2;
  unint64_t v3;
  void *v4;
  unint64_t v5;
  unint64_t v6;
  size_t v7;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 67))
      return 0;
    if (!*(_BYTE *)(result + 65) && (v2 = *(_DWORD **)(result + 8)) != 0 && *v2 == *(_DWORD *)(result + 16)
      || _revalidateIterator(result))
    {
      if (!*(_BYTE *)(v1 + 64))
      {
        v3 = BOMStorageSizeOfBlock(**(_QWORD **)v1, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 32) + 4 * *(unsigned int *)(v1 + 20)));
        v4 = *(void **)(v1 + 48);
        v5 = *(_QWORD *)(v1 + 56);
        if (v3 > v5)
        {
          v6 = v3;
          if (v4)
          {
            free(*(void **)(v1 + 48));
            *(_QWORD *)(v1 + 48) = 0;
            v5 = *(_QWORD *)(v1 + 56);
          }
          if (v6 <= 2 * v5)
            v7 = 2 * v5;
          else
            v7 = v6;
          *(_QWORD *)(v1 + 56) = v7;
          v4 = BOM_malloc(v7);
          *(_QWORD *)(v1 + 48) = v4;
        }
        if (BOMStorageCopyFromBlock(**(_QWORD **)v1, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 32) + 4 * *(unsigned int *)(v1 + 20)), v4))return 0;
        *(_BYTE *)(v1 + 64) = 1;
      }
      return *(_QWORD *)(v1 + 48);
    }
    else
    {
      result = 0;
      *(_BYTE *)(v1 + 67) = 1;
    }
  }
  return result;
}

uint64_t BOMTreeIteratorValueSize(uint64_t a1)
{
  uint64_t v3;

  if (!a1 || *(_BYTE *)(a1 + 67))
    return 0;
  if (*(_BYTE *)(a1 + 65) || (v3 = *(_QWORD *)(a1 + 8)) == 0 || *(_DWORD *)v3 != *(_DWORD *)(a1 + 16))
  {
    if (!_revalidateIterator(a1))
    {
      *(_BYTE *)(a1 + 67) = 1;
      return 0;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  return BOMStorageSizeOfBlock(**(_QWORD **)a1, *(_DWORD *)(*(_QWORD *)(v3 + 32) + 4 * *(unsigned int *)(a1 + 20)));
}

uint64_t BOMTreeSetDensePacking(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 295) = a2;
  return result;
}

_DWORD *BOMTreeIteratorSet(uint64_t a1, const void *a2, size_t a3, BOOL *a4)
{
  _DWORD *result;
  uint64_t v9;
  int v10;

  *(_BYTE *)(a1 + 65) = 0;
  *(_BYTE *)(a1 + 67) = 0;
  result = (_DWORD *)_findPagesForKey(*(_QWORD *)a1, 0, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 16) = *result;
    result = (_DWORD *)_findIndexForKey(*(_QWORD *)a1, (uint64_t)result, a2, a3, a4);
    *(_DWORD *)(a1 + 20) = (_DWORD)result;
    *(_BYTE *)(a1 + 66) = 1;
    v9 = *(_QWORD *)(a1 + 8);
    if (result >= *(unsigned __int16 *)(v9 + 16))
    {
      *(_DWORD *)(a1 + 20) = 0;
      v10 = *(_DWORD *)(v9 + 8);
      if (!v10
        || (*(_DWORD *)(a1 + 16) = v10, result = _findPage(*(_QWORD *)a1, v10), (*(_QWORD *)(a1 + 8) = result) == 0))
      {
        *(_BYTE *)(a1 + 67) = 1;
      }
    }
  }
  else
  {
    *(_WORD *)(a1 + 66) = 256;
  }
  return result;
}

_QWORD *_findPage(uint64_t a1, int a2)
{
  uint64_t v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  void *v9;
  void *v10;
  int v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  int *v16;

  if (a2)
  {
    if (a1)
    {
      v4 = 0;
      while (1)
      {
        v5 = *(_QWORD **)(a1 + 32 + v4);
        if (v5)
        {
          if (*(_DWORD *)v5 == a2)
            break;
        }
        v4 += 8;
        if (v4 == 256)
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      v5 = 0;
    }
    v6 = 0;
    while (1)
    {
      if (v5)
        return v5;
      v7 = *(int *)(a1 + 288);
      v5 = *(_QWORD **)(a1 + 8 * v7 + 32);
      if (!v5)
      {
        v5 = _NewPage(a1, a2);
        if (!v5)
          return v5;
        if (_ReadPage(a1, (uint64_t)v5))
          return 0;
        v7 = *(int *)(a1 + 288);
        *(_QWORD *)(a1 + 8 * v7 + 32) = v5;
        goto LABEL_22;
      }
      v8 = *((_WORD *)v5 + 2);
      if ((v8 & 0xC) == 4)
        break;
      if ((v8 & 4) != 0)
      {
        v5 = 0;
LABEL_22:
        v11 = v6;
        goto LABEL_23;
      }
      v11 = 0;
      *((_WORD *)v5 + 2) = v8 | 4;
      LODWORD(v7) = *(_DWORD *)(a1 + 288);
      v5 = 0;
LABEL_23:
      v12 = v7 + 1;
      v13 = -v12 < 0;
      v14 = -v12 & 0x1F;
      v15 = v12 & 0x1F;
      if (!v13)
        v15 = -v14;
      *(_DWORD *)(a1 + 288) = v15;
      v6 = v11 + 1;
      if (!v5 && v11 >= 32)
      {
        v16 = __error();
        _BOMExceptionHandlerCall((uint64_t)"btree cache is deadlocked", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2144, *v16);
        return 0;
      }
    }
    if ((v8 & 2) != 0)
      _WritePage(a1, (uint64_t)v5);
    v9 = (void *)v5[3];
    v10 = (void *)v5[4];
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    v5[4] = 0;
    bzero(v9, 4 * *(unsigned int *)(a1 + 316));
    bzero(v10, 4 * *(unsigned int *)(a1 + 320));
    *(_DWORD *)v5 = a2;
    v5[1] = -1;
    v5[3] = v9;
    v5[4] = v10;
    if (_ReadPage(a1, (uint64_t)v5))
      return 0;
    v7 = *(int *)(a1 + 288);
    *(_QWORD *)(a1 + 8 * v7 + 32) = v5;
    goto LABEL_22;
  }
  return 0;
}

uint64_t _revalidateIterator(uint64_t a1)
{
  uint64_t PagesForKey;
  int IndexForKey;
  _QWORD *Page;
  int v5;
  uint64_t result;

  if (!*(_BYTE *)(a1 + 65))
  {
    Page = *(_QWORD **)(a1 + 8);
    if (Page)
    {
      v5 = *(_DWORD *)(a1 + 16);
      if (*(_DWORD *)Page == v5)
        goto LABEL_9;
    }
    else
    {
      v5 = *(_DWORD *)(a1 + 16);
    }
    Page = _findPage(*(_QWORD *)a1, v5);
    *(_QWORD *)(a1 + 8) = Page;
    if (!Page)
      goto LABEL_11;
    goto LABEL_9;
  }
  PagesForKey = _findPagesForKey(*(_QWORD *)a1, 0, *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32));
  *(_QWORD *)(a1 + 8) = PagesForKey;
  if (!PagesForKey)
    goto LABEL_11;
  IndexForKey = _findIndexForKey(*(_QWORD *)a1, PagesForKey, *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32), (BOOL *)(a1 + 66));
  Page = *(_QWORD **)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)Page;
  *(_DWORD *)(a1 + 20) = IndexForKey;
  *(_BYTE *)(a1 + 65) = 0;
LABEL_9:
  if (*(_DWORD *)(a1 + 20) < *((unsigned __int16 *)Page + 8))
    return 1;
LABEL_11:
  result = 0;
  *(_BYTE *)(a1 + 65) = 1;
  return result;
}

uint64_t BOMTreeVerifyLeaves(uint64_t result)
{
  uint64_t v1;
  char *v2;
  char *v3;
  char *v4;
  int v5;
  const char *v6;
  int v7;
  int v8;
  _DWORD *v9;
  char *v10;
  char *v11;

  if (result)
  {
    v1 = result;
    v2 = *(char **)(result + 24);
    if (!v2)
      return 0;
    _SyncCache(result);
    if ((*((_WORD *)v2 + 2) & 1) == 0)
    {
      while (1)
      {
        v3 = (char *)_NewPage(v1, **((_DWORD **)v2 + 4));
        if (!v3)
        {
          v5 = *__error();
          v6 = "verifier: can't make page";
          v7 = 2642;
          goto LABEL_24;
        }
        v4 = v3;
        if (_ReadPage(v1, (uint64_t)v3))
          break;
        if (v2 != *(char **)(v1 + 24))
          _FreePage(v2);
        v2 = v4;
        if ((*((_WORD *)v4 + 2) & 1) != 0)
          goto LABEL_11;
      }
      v5 = *__error();
      v6 = "verifier: can't read page";
      v7 = 2647;
      goto LABEL_24;
    }
    v4 = v2;
LABEL_11:
    if (*((_DWORD *)v4 + 3))
    {
      v5 = *__error();
      v6 = "verifier: first leaf has prev value";
      v7 = 2658;
LABEL_24:
      _BOMExceptionHandlerCall((uint64_t)v6, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", v7, v5);
      return 0;
    }
    v9 = v4 + 8;
    v8 = *((_DWORD *)v4 + 2);
    if (v8)
    {
      while (1)
      {
        v10 = (char *)_NewPage(v1, v8);
        if (!v10)
        {
          v5 = *__error();
          v6 = "verifier: can't make page";
          v7 = 2666;
          goto LABEL_24;
        }
        v11 = v10;
        if (_ReadPage(v1, (uint64_t)v10))
        {
          v5 = *__error();
          v6 = "verifier: can't read page";
          v7 = 2671;
          goto LABEL_24;
        }
        if (*v9 != *(_DWORD *)v11)
        {
          v5 = *__error();
          v6 = "verifier: page->next != next->bid";
          v7 = 2678;
          goto LABEL_24;
        }
        if (*((_DWORD *)v11 + 3) != *(_DWORD *)v4)
          break;
        if (v4 != *(char **)(v1 + 24))
          _FreePage(v4);
        v9 = v11 + 8;
        v8 = *((_DWORD *)v11 + 2);
        v4 = v11;
        if (!v8)
          goto LABEL_28;
      }
      v5 = *__error();
      v6 = "verifier: next->prev != page->bid";
      v7 = 2683;
      goto LABEL_24;
    }
    v11 = v4;
LABEL_28:
    if (v11 != *(char **)(v1 + 24))
      _FreePage(v11);
    return 1;
  }
  return result;
}

uint64_t _BOMTreeDiagnosticTraverse(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v10;
  unint64_t v12;
  int v13;
  _QWORD *Page;
  uint64_t v16;
  int v17;
  _QWORD *v18;
  unsigned int v19;

  if (!a1)
    return 1;
  v10 = a2;
  if (!a2)
    v10 = *(_QWORD *)(a1 + 24);
  if ((*(_WORD *)(v10 + 4) & 1) != 0)
  {
    if (a3)
      ++*a3;
    if (!*(_WORD *)(v10 + 16))
    {
      v16 = 0;
LABEL_28:
      v13 = 0;
      if (a6)
      {
        v19 = *(_DWORD *)(*(_QWORD *)(v10 + 32) + 4 * v16);
        if (v19)
        {
          v13 = 0;
          *a6 += BOMStorageSizeOfBlock(*(_QWORD *)a1, v19);
        }
      }
      return v13 != 0;
    }
    v16 = 0;
    while (!a5 || *(_BYTE *)(a1 + 294))
    {
      if (a6)
        goto LABEL_19;
LABEL_20:
      if (++v16 >= (unint64_t)*(unsigned __int16 *)(v10 + 16))
        goto LABEL_28;
    }
    *a5 += BOMStorageSizeOfBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(v10 + 24) + 4 * v16));
    if (!a6)
      goto LABEL_20;
LABEL_19:
    *a6 += BOMStorageSizeOfBlock(*(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(v10 + 32) + 4 * v16));
    goto LABEL_20;
  }
  if (a4)
    ++*a4;
  if (*(_WORD *)(v10 + 16))
  {
    v12 = 0;
    v13 = 0;
    do
    {
      Page = _findPage(a1, *(_DWORD *)(*(_QWORD *)(v10 + 32) + 4 * v12));
      v13 += _BOMTreeDiagnosticTraverse(a1, Page, a3, a4, a5, a6);
      ++v12;
    }
    while (v12 < *(unsigned __int16 *)(v10 + 16));
  }
  else
  {
    v12 = 0;
    v13 = 0;
  }
  v17 = *(_DWORD *)(*(_QWORD *)(v10 + 32) + 4 * v12);
  if (v17)
  {
    v18 = _findPage(a1, v17);
    v13 += _BOMTreeDiagnosticTraverse(a1, v18, a3, a4, a5, a6);
  }
  return v13 != 0;
}

uint64_t _BOMTreePrintDiagnostics(uint64_t result)
{
  uint64_t v1;
  int v2;
  FILE **v3;
  size_t v4;
  size_t v5;
  int v6;
  int v7;

  v7 = 0;
  v6 = 0;
  v4 = 0;
  v5 = 0;
  if (result)
  {
    v1 = result;
    result = _BOMTreeDiagnosticTraverse(result, 0, &v7, &v6, &v5, &v4);
    if (!(_DWORD)result)
    {
      v2 = v6 + v7;
      v3 = (FILE **)MEMORY[0x24BDAC8D8];
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "   # records: %d\n", *(_DWORD *)(v1 + 20));
      fprintf(*v3, "   # pages  : %d (%d)\n", v2, *(_DWORD *)(v1 + 312) * v2);
      fprintf(*v3, "     leaf   : %d (%d)\n", v7, *(_DWORD *)(v1 + 312) * v7);
      fprintf(*v3, "     branch : %d (%d)\n", v6, *(_DWORD *)(v1 + 312) * v6);
      fprintf(*v3, "   key size : %zd\n", v5);
      return fprintf(*v3, "   data size: %zd\n", v4);
    }
  }
  return result;
}

uint64_t BOMMemoryDump(unsigned __int8 *a1, uint64_t a2, const char *a3)
{
  uint64_t v3;
  FILE **v5;
  FILE *v6;
  unsigned __int8 *v8;
  unint64_t v9;
  const char *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  char v16;
  char *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  int v21;
  char v22;
  uint64_t v23;
  uint64_t v25;
  const char *v26;
  unsigned __int8 *v27;
  char v28[17];
  uint64_t v29;

  v3 = a2;
  v29 = *MEMORY[0x24BDAC8D0];
  v5 = (FILE **)MEMORY[0x24BDAC8E8];
  v6 = (FILE *)*MEMORY[0x24BDAC8E8];
  v27 = a1;
  if (!a1)
  {
    fprintf(v6, "(%lu bytes) (NULL)\n", a2);
    return 0;
  }
  fprintf(v6, "(%lu bytes)\n", a2);
  if (v3 >= 1)
  {
    v8 = v27;
    v9 = (unint64_t)&v27[v3];
    v10 = "";
    if (a3)
      v10 = a3;
    v25 = v3;
    v26 = v10;
    while (1)
    {
      v11 = v8;
      fprintf(*v5, "%s%08x:", v26, (_DWORD)v8 - (_DWORD)v27);
      v12 = 0;
      v13 = v28;
      do
      {
        fprintf(*v5, " %02x", *v8);
        v14 = *v8;
        if ((v14 & 0x80) != 0)
          v15 = __maskrune(v14, 0x40000uLL);
        else
          v15 = *(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v14 + 60) & 0x40000;
        if (v15)
          v16 = v14;
        else
          v16 = 46;
        *v13 = v16;
        v17 = v13 + 1;
        v18 = v12 + 1;
        if (v12 < 15)
        {
          v19 = &v11[v18];
          if ((unint64_t)&v11[v18] < v9)
          {
            fprintf(*v5, "%02x", *v19);
            v20 = *v19;
            if ((v20 & 0x80) != 0)
              v21 = __maskrune(v20, 0x40000uLL);
            else
              v21 = *(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v20 + 60) & 0x40000;
            if (v21)
              v22 = v20;
            else
              v22 = 46;
            v17 = v13 + 2;
            v13[1] = v22;
            v18 = v12 + 2;
          }
        }
        v8 = &v11[v18];
        if (v18 > 15)
          break;
        v13 = v17;
        v12 = v18;
      }
      while ((unint64_t)v8 < v9);
      if (v18 > 15)
        goto LABEL_29;
      v23 = 16 - v18;
      if (((16 - (_DWORD)v18) & 1) == 0)
        goto LABEL_28;
      fwrite("  ", 2uLL, 1uLL, *v5);
      if (v18 != 15)
        break;
LABEL_29:
      *v17 = 0;
      fprintf(*v5, "  %s\n", v28);
      if ((unint64_t)v8 >= v9)
        return v25;
    }
    v23 = 15 - v18;
    do
    {
LABEL_28:
      fwrite("     ", 5uLL, 1uLL, *v5);
      v23 -= 2;
    }
    while (v23);
    goto LABEL_29;
  }
  return v3;
}

uint64_t BOMStorageDumpTree(uint64_t a1, const char *a2, unsigned int a3)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  FILE **v7;
  char *v8;
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unint64_t v13;
  unint64_t v14;
  _BOOL4 v15;
  unsigned int v16;
  const char *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  const char *v22;
  int v23;
  size_t v24;
  uint64_t v26;
  int v27;
  unsigned int v28;

  v4 = a2;
  v5 = BOMTreeOpenWithName(a1, a2, 0);
  if (v5)
  {
    v6 = v5;
    v7 = (FILE **)MEMORY[0x24BDAC8E8];
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "        %s (%u entries)\n", v4, *(_DWORD *)(v5 + 20));
    v26 = v6;
    v8 = (char *)BOMTreeIteratorNew(v6, 0, 0, 0);
    if (!BOMTreeIteratorIsAtEnd((uint64_t)v8))
    {
      v9 = HIWORD(a3) & 0xF;
      v27 = v9;
      v28 = a3;
      do
      {
        fprintf(*v7, "        %s   Key ", v4);
        v10 = (unsigned __int8 *)BOMTreeIteratorKey((uint64_t)v8);
        v11 = BOMTreeIteratorKeySize((uint64_t)v8);
        switch(v9)
        {
          case 3:
            BOMPathKeyDump((uint64_t)v10, v11);
            break;
          case 2:
            BOMPathIdDump(v10, v11);
            break;
          case 1:
            BOMPathDump((char *)v10);
            break;
          default:
            BOMMemoryDump(v10, v11, "        ");
            break;
        }
        fprintf(*v7, "        %s Value ", v4);
        v12 = (unsigned __int8 *)BOMTreeIteratorValue((uint64_t)v8);
        v13 = BOMTreeIteratorValueSize((uint64_t)v8);
        v14 = v13;
        if ((a3 & 0x1000000) != 0)
        {
          if (v13 >= 4)
          {
            v17 = v4;
            v18 = a3;
            v20 = *(_DWORD *)v12;
            v12 += 4;
            v19 = v20;
            v21 = bswap32(v20);
            v22 = "ies";
            if (v20 == 0x1000000)
              v22 = "y";
            fprintf(*v7, "(%lu bytes for %d entr%s)\n", v13, v21, v22);
            v15 = v19 != 0;
            v14 -= 4;
            v16 = v18;
            v4 = v17;
            if (!v14)
              goto LABEL_32;
LABEL_20:
            if (v15)
            {
              v23 = (v16 >> 20) & 0xF;
              do
              {
                if ((v16 & 0x1000000) != 0)
                  fprintf(*v7, "  %s", "        ");
                switch(v23)
                {
                  case 3:
                    v24 = BOMPathKeyDump((uint64_t)v12, v14);
                    break;
                  case 2:
                    v24 = BOMPathIdDump(v12, v14);
                    break;
                  case 1:
                    v24 = BOMPathDump((char *)v12);
                    break;
                  default:
                    v24 = BOMMemoryDump(v12, v14, "        ");
                    break;
                }
                v12 += v24;
                v14 -= v24;
              }
              while (v14);
            }
            goto LABEL_32;
          }
          v16 = 0;
          v15 = 1;
          if (v13)
            goto LABEL_20;
        }
        else
        {
          v15 = 1;
          v16 = a3;
          if (v13)
            goto LABEL_20;
        }
LABEL_32:
        BOMTreeIteratorNext((uint64_t)v8);
        v9 = v27;
        a3 = v28;
      }
      while (!BOMTreeIteratorIsAtEnd((uint64_t)v8));
    }
    fputc(10, *v7);
    if (v8)
      BOMTreeIteratorFree(v8);
    BOMTreeFree(v26);
    return 0;
  }
  else
  {
    fputc(10, (FILE *)*MEMORY[0x24BDAC8E8]);
    return 0xFFFFFFFFLL;
  }
}

_QWORD *_newBOMTree(uint64_t a1, const char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  FILE *v6;
  int *v7;
  char *v8;

  v4 = BOM_malloczero(0x168uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = a1;
    if (a2)
      v4[1] = strdup(a2);
  }
  else
  {
    v6 = (FILE *)*MEMORY[0x24BDAC8D8];
    v7 = __error();
    v8 = strerror(*v7);
    fprintf(v6, "malloc: %s\n", v8);
  }
  return v5;
}

_QWORD *_NewPage(uint64_t a1, int a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  _QWORD *v9;

  v4 = *(_QWORD *)a1;
  v5 = BOM_malloczero(4 * (*(_DWORD *)(a1 + 316) + 1));
  if (!v5)
    return 0;
  v6 = v5;
  v7 = BOM_malloczero(4 * (*(_DWORD *)(a1 + 320) + 1));
  if (!v7)
  {
    free(v6);
    return 0;
  }
  v8 = v7;
  v9 = BOM_malloczero(0x28uLL);
  if (v9)
  {
    if (!a2)
      a2 = BOMStorageNewBlock(v4);
    v9[3] = v6;
    v9[4] = v8;
    *(_DWORD *)v9 = a2;
  }
  else
  {
    free(v6);
    free(v8);
  }
  return v9;
}

uint64_t _ReadPage(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v3 = BOMStreamWithBlockID(*(_QWORD *)a1, *(_DWORD *)a2, *(unsigned int *)(a1 + 312), 0);
  if (!v3)
    return 1;
  v4 = v3;
  *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 4) & 0xFFFE | (BOMStreamReadUInt16(v3) != 0);
  *(_WORD *)(a2 + 16) = BOMStreamReadUInt16(v4);
  *(_DWORD *)(a2 + 8) = BOMStreamReadUInt32(v4);
  *(_DWORD *)(a2 + 12) = BOMStreamReadUInt32(v4);
  if (*(_WORD *)(a2 + 16))
  {
    v5 = 0;
    do
    {
      *(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * v5) = BOMStreamReadUInt32(v4);
      *(_DWORD *)(*(_QWORD *)(a2 + 24) + 4 * v5++) = BOMStreamReadUInt32(v4);
    }
    while (v5 < *(unsigned __int16 *)(a2 + 16));
  }
  *(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * *(unsigned __int16 *)(a2 + 16)) = BOMStreamReadUInt32(v4);
  BOMStreamFree(v4);
  return 0;
}

void _invalidateIteratorsForPageID(uint64_t a1, unsigned int a2)
{
  const __CFArray *v3;
  CFIndex v5;
  CFIndex v6;
  CFIndex v7;
  CFRange v8;

  v3 = *(const __CFArray **)(a1 + 304);
  if (v3)
  {
    v5 = BOMCFArrayMaxRange(v3);
    v7 = v6;
    v8.location = v5;
    v8.length = v7;
    CFArrayApplyFunction(*(CFArrayRef *)(a1 + 304), v8, (CFArrayApplierFunction)_invalidateIterator, (void *)a2);
  }
}

void _addPageToCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  _WORD *v5;
  _WORD *v6;
  __int16 v8;
  int v9;
  BOOL v10;
  int v11;
  int v12;
  uint64_t v13;
  _WORD *v14;

  v3 = a1 + 8 * *(int *)(a1 + 288);
  v6 = *(_WORD **)(v3 + 32);
  v4 = (_QWORD *)(v3 + 32);
  v5 = v6;
  if (v6)
  {
    while (1)
    {
      v8 = v5[2];
      if ((v8 & 0xC) == 4)
        break;
      v5[2] = v8 | 4;
      v9 = *(_DWORD *)(a1 + 288) + 1;
      v10 = -v9 < 0;
      v11 = -v9 & 0x1F;
      v12 = v9 & 0x1F;
      if (!v10)
        v12 = -v11;
      *(_DWORD *)(a1 + 288) = v12;
      v13 = a1 + 8 * v12;
      v14 = *(_WORD **)(v13 + 32);
      v4 = (_QWORD *)(v13 + 32);
      v5 = v14;
      if (!v14)
        goto LABEL_10;
    }
    if ((v8 & 2) != 0)
      _WritePage(a1, (uint64_t)v5);
    _FreePage(v5);
    v4 = (_QWORD *)(a1 + 8 * *(int *)(a1 + 288) + 32);
  }
LABEL_10:
  *v4 = a2;
}

uint64_t _invalidateIterator(uint64_t result, int a2)
{
  uint64_t v2;
  size_t v3;
  void *v4;
  int *v5;
  int *v6;

  if (result)
  {
    v2 = result;
    if (*(_DWORD *)(result + 16) == a2 && !*(_BYTE *)(result + 67) && !*(_BYTE *)(result + 65))
    {
      result = *(_QWORD *)(result + 8);
      if (result && *(_DWORD *)result == a2
        || (result = (uint64_t)_findPage(*(_QWORD *)v2, a2), (*(_QWORD *)(v2 + 8) = result) != 0))
      {
        if (*(_BYTE *)(*(_QWORD *)v2 + 294))
        {
          *(_QWORD *)(v2 + 24) = *(unsigned int *)(*(_QWORD *)(result + 24) + 4 * *(unsigned int *)(v2 + 20));
          *(_QWORD *)(v2 + 32) = 0;
        }
        else
        {
          v3 = BOMStorageSizeOfBlock(**(_QWORD **)v2, *(_DWORD *)(*(_QWORD *)(result + 24) + 4 * *(unsigned int *)(v2 + 20)));
          *(_QWORD *)(v2 + 32) = v3;
          if (*(_QWORD *)(v2 + 24))
          {
            free(*(void **)(v2 + 24));
            *(_QWORD *)(v2 + 24) = 0;
            v3 = *(_QWORD *)(v2 + 32);
          }
          v4 = BOM_malloc(v3);
          *(_QWORD *)(v2 + 24) = v4;
          if (!v4)
          {
            v5 = __error();
            _BOMFatalException((uint64_t)"BOMTree iterator cannot cache keys. This is a fatal error (!it->key).\n", "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2550, *v5);
          }
          result = BOMStorageCopyFromBlock(**(_QWORD **)v2, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 24) + 4 * *(unsigned int *)(v2 + 20)), v4);
          if ((_DWORD)result)
          {
            v6 = __error();
            _BOMFatalException((uint64_t)"BOMTree iterator cannot cache keys. This is a fatal error (BOMStorageCopyFromBlock returned an error).\n", "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2554, *v6);
          }
        }
      }
      *(_BYTE *)(v2 + 65) = 1;
    }
  }
  return result;
}

void _removePageFromCache(uint64_t a1, _WORD *a2)
{
  uint64_t i;
  const __CFArray *v5;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  CFRange v9;

  if ((a2[2] & 8) == 0)
  {
    for (i = 32; i != 288; i += 8)
    {
      if (*(_WORD **)(a1 + i) == a2)
      {
        v5 = *(const __CFArray **)(a1 + 304);
        if (v5)
        {
          v6 = BOMCFArrayMaxRange(v5);
          v8 = v7;
          v9.location = v6;
          v9.length = v8;
          CFArrayApplyFunction(*(CFArrayRef *)(a1 + 304), v9, (CFArrayApplierFunction)_pageRemovedCallback, a2);
        }
        *(_QWORD *)(a1 + i) = 0;
      }
    }
    if ((a2[2] & 2) != 0)
      _WritePage(a1, (uint64_t)a2);
  }
}

uint64_t _pageRemovedCallback(uint64_t result, uint64_t a2)
{
  if (result && a2 && *(_QWORD *)(result + 8) == a2)
    *(_QWORD *)(result + 8) = 0;
  return result;
}

uint64_t _shiftKeysAndValues(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v4 = *(unsigned __int16 *)(a3 + 16);
  v5 = *(_DWORD *)(result + 324);
  v6 = v4 >= v5;
  v8 = v4 - v5;
  v7 = v8 != 0 && v6;
  v9 = (v8 + 1) >> 1;
  if (v7)
    v10 = v9;
  else
    v10 = *(unsigned __int16 *)(a3 + 16);
  v11 = *(unsigned __int16 *)(a2 + 16);
  v12 = v10 + v11;
  v13 = v4 - v10;
  if (a4)
  {
    v14 = 0;
    if (!v10)
      goto LABEL_15;
    goto LABEL_11;
  }
  v15 = *(_QWORD *)(a2 + 32);
  *(_DWORD *)(v15 + 4 * v12) = *(_DWORD *)(v15 + 4 * v11);
  if ((_DWORD)v11)
  {
    v16 = *(_QWORD *)(a2 + 24);
    do
    {
      v17 = v10 - 1 + v11--;
      *(_DWORD *)(v16 + 4 * v17) = *(_DWORD *)(v16 + 4 * v11);
      *(_DWORD *)(v15 + 4 * v17) = *(_DWORD *)(v15 + 4 * v11);
    }
    while (v11);
  }
  v14 = v4 - v10;
  if (v10)
  {
LABEL_11:
    v18 = *(_QWORD *)(a3 + 24);
    v19 = *(_QWORD *)(a3 + 32);
    v11 = v11;
    v20 = v10;
    v21 = *(_QWORD *)(a2 + 24);
    result = *(_QWORD *)(a2 + 32);
    do
    {
      *(_DWORD *)(v21 + 4 * v11) = *(_DWORD *)(v18 + 4 * v14);
      *(_DWORD *)(result + 4 * v11) = *(_DWORD *)(v19 + 4 * v14);
      if (!a4)
      {
        *(_DWORD *)(v18 + 4 * v14) = 0;
        *(_DWORD *)(v19 + 4 * v14) = 0;
      }
      ++v11;
      ++v14;
      --v20;
    }
    while (v20);
  }
LABEL_15:
  if (a4)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0 && (_DWORD)v4 == v10)
    {
      v22 = *(_QWORD *)(a3 + 32);
      *(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * v11) = *(_DWORD *)(v22 + 4 * v14);
      *(_DWORD *)(v22 + 4 * v14) = 0;
    }
    if ((_DWORD)v4 != v10)
    {
      if ((_DWORD)v4)
      {
        v23 = 0;
        v24 = 4 * v10;
        v25 = v13 + v10;
        do
        {
          if (v23 >= v13)
          {
            v27 = *(_QWORD *)(a3 + 24);
            if (v13 == v23)
            {
              *(_DWORD *)(v27 + 4 * v13) = 0;
              v26 = *(_QWORD *)(a3 + 32);
              *(_DWORD *)(v26 + 4 * v13) = *(_DWORD *)(v26 + 4 * v25);
            }
            else
            {
              *(_DWORD *)(v27 + 4 * v23) = 0;
              v26 = *(_QWORD *)(a3 + 32);
              *(_DWORD *)(v26 + 4 * v23) = 0;
            }
          }
          else
          {
            v26 = *(_QWORD *)(a3 + 32);
            *(_DWORD *)(*(_QWORD *)(a3 + 24) + 4 * v23) = *(_DWORD *)(*(_QWORD *)(a3 + 24) + 4 * v23 + v24);
            *(_DWORD *)(v26 + 4 * v23) = *(_DWORD *)(v26 + 4 * v23 + v24);
          }
          ++v23;
        }
        while (v4 != v23);
      }
      else
      {
        v26 = *(_QWORD *)(a3 + 32);
      }
      *(_DWORD *)(v26 + 4 * v4) = 0;
    }
  }
  *(_WORD *)(a2 + 16) = v12;
  *(_WORD *)(a2 + 4) |= 2u;
  *(_WORD *)(a3 + 16) = v13;
  *(_WORD *)(a3 + 4) |= 2u;
  return result;
}

uint64_t _findPagesForKey(uint64_t a1, char *a2, const void *a3, size_t a4)
{
  uint64_t v8;
  unsigned int IndexForKey;
  _QWORD *Page;
  __int16 v11;

  if (!a1)
    return 0;
  v8 = *(_QWORD *)(a1 + 24);
  if (a2)
    BOMStackPush(a2, v8);
  if ((*(_WORD *)(v8 + 4) & 1) == 0)
  {
    do
    {
      IndexForKey = _findIndexForKey(a1, v8, a3, a4, 0);
      Page = _findPage(a1, *(_DWORD *)(*(_QWORD *)(v8 + 32) + 4 * IndexForKey));
      v8 = (uint64_t)Page;
      if (!Page)
        break;
      if (a2)
      {
        BOMStackPush(a2, (uint64_t)Page);
        v11 = *(_WORD *)(v8 + 4) | 8;
      }
      else
      {
        v11 = *((_WORD *)Page + 2);
      }
      *(_WORD *)(v8 + 4) = v11 & 0xFFFB;
    }
    while ((v11 & 1) == 0);
  }
  return v8;
}

size_t BOMPathDump(char *__s)
{
  size_t v2;

  if (__s)
    v2 = strlen(__s);
  else
    v2 = 0;
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "\"%s\" (%lu bytes)\n", __s, v2);
  return v2;
}

uint64_t BOMPathIdDump(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 < 4)
    return BOMMemoryDump(a1, a2, "        ");
  if (a1)
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "0x%02x%02x%02x%02x (%lu bytes)\n", *a1, a1[1], a1[2], a1[3], 4);
  return 4;
}

uint64_t BOMPathKeyDump(uint64_t a1, unint64_t a2)
{
  size_t v2;

  if (!a1)
    return 0;
  if (a2 >= 5)
  {
    v2 = strlen((const char *)(a1 + 4)) + 5;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "0x%02x%02x%02x%02x \"%s\" (%lu bytes)\n");
    return v2;
  }
  if (a2 == 4)
  {
    v2 = 4;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "0x%02x%02x%02x%02x (NULL) (%lu bytes)\n");
    return v2;
  }
  return BOMMemoryDump((unsigned __int8 *)a1, a2, "        ");
}

_QWORD *data_archive_entry_new(uint64_t a1, uint64_t a2)
{
  _QWORD *result;

  if (a2)
    return 0;
  result = platform_calloc(a1, 1uLL, 0x80uLL);
  if (result)
  {
    *(_DWORD *)result = 1684369012;
    result[1] = a1;
    *((_DWORD *)result + 30) = 1953391972;
  }
  return result;
}

void data_archive_entry_free(_QWORD *__b)
{
  void *v2;
  uint64_t v3;

  if (__b && *(_DWORD *)__b == 1684369012 && *((_DWORD *)__b + 30) == 1953391972)
  {
    v2 = (void *)__b[3];
    if (v2)
      platform_free(__b[1], v2);
    v3 = __b[1];
    platform_memset(v3, __b, 0, 0x80uLL);
    platform_free(v3, __b);
  }
}

_DWORD *data_archive_entry_get_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1684369012 && result[30] == 1953391972)
      return (_DWORD *)result[4];
    else
      return 0;
  }
  return result;
}

uint64_t data_archive_entry_set_format_entry(uint64_t a1, int a2, int a3, _DWORD *a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v13;
  uint64_t v14;
  char v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  int v29;
  const char *v30;
  _QWORD *v31;
  int v32;
  unsigned int type;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t attribute;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  void *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  _DWORD *v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char v63;
  void *v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _DWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char v81;
  char *v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  __int16 v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  int *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  __int16 v134;
  int v135;
  char v136;
  _OWORD v137[3];
  __int128 v138;
  uint64_t v139;
  __int128 v140;
  __int128 v141;

  if (!a1 || *(_DWORD *)a1 != 1684369012 || *(_DWORD *)(a1 + 120) != 1953391972)
  {
    v30 = "Invalid data archive entry";
    v31 = a5;
    v32 = 214;
LABEL_27:
    capture_error(v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", v32, (uint64_t)"data_archive_entry_set_format_entry", v30, a6, a7, a8, v136);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    v30 = "Unknown format type";
    v31 = a5;
    v32 = 220;
    goto LABEL_27;
  }
  if (!a4)
  {
    v30 = "Invalid format entry";
    v31 = a5;
    v32 = 226;
    goto LABEL_27;
  }
  if (!darc_format_entry_get_type(a4))
  {
    v30 = "Unknown data entry type";
    v31 = a5;
    v32 = 235;
    goto LABEL_27;
  }
  if (a2 == 9)
  {
    type = darc_format_entry_get_type(a4);
    switch(type)
    {
      case 1u:
        goto LABEL_45;
      case 6u:
        attribute = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
        if (attribute <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 948, (uint64_t)"populate_pkzip_entry_local_header", "PKZip local header format entry is missing %s attribute", v38, v39, v40, (char)"name");
          return 0xFFFFFFFFLL;
        }
        v41 = attribute + 1;
        v42 = platform_calloc(*(_QWORD *)(a1 + 8), attribute + 1, 1uLL);
        if (!v42)
        {
          v111 = __error();
          strerror(*v111);
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 956, (uint64_t)"populate_pkzip_entry_local_header", "Could not allocate %ld bytes for name buffer: %s", v112, v113, v114, v41);
          return 0xFFFFFFFFLL;
        }
        v43 = v42;
        if (darc_format_entry_get_attribute((uint64_t)a4, "name", v42) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 963, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v44, v45, v46, (char)"name");
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(a1 + 24) = v43;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip local header", 0) <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 978, (uint64_t)"populate_pkzip_entry_local_header", "PKZip local header format entry is missing %s attribute", v47, v48, v49, (char)"pkzip local header");
          return 0xFFFFFFFFLL;
        }
        v140 = 0u;
        v141 = 0u;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip local header", &v140) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 987, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v50, v51, v52, (char)"pkzip local header");
          return 0xFFFFFFFFLL;
        }
        v53 = DWORD1(v141);
        *(_QWORD *)(a1 + 80) = DWORD2(v141);
        *(_QWORD *)(a1 + 112) = v53;
        v54 = convert_dos_to_unix_time(a1, WORD5(v140), WORD6(v140));
        *(_QWORD *)(a1 + 88) = v54;
        *(_QWORD *)(a1 + 72) = v54;
        v55 = BYTE6(v140);
        if ((BYTE6(v140) & 1) != 0)
          *(_BYTE *)(a1 + 104) = 1;
        if ((v55 & 8) != 0)
        {
          *(_BYTE *)(a1 + 105) = 1;
          v56 = (_DWORD *)(a1 + 108);
        }
        else
        {
          *(_DWORD *)(a1 + 108) = v141;
          v56 = (_DWORD *)(a1 + 108);
          if (!*(_BYTE *)(a1 + 105))
            goto LABEL_103;
        }
        *v56 = WORD5(v140);
LABEL_103:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field extended timestamp", 0) < 1)
          goto LABEL_106;
        memset(v137, 0, 24);
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field extended timestamp", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1041, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v119, v120, v121, (char)"pkzip extra field extended timestamp");
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(a1 + 72) = *(_QWORD *)&v137[0];
        *(_OWORD *)(a1 + 88) = *(_OWORD *)((char *)v137 + 8);
LABEL_106:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", 0) < 1)
          goto LABEL_112;
        memset(v137, 0, 32);
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1064, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v122, v123, v124, (char)"pkzip extra field InfoZIP UNIX v1");
          return 0xFFFFFFFFLL;
        }
        v125 = *((_QWORD *)&v137[0] + 1);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)&v137[0];
        *(_QWORD *)(a1 + 72) = v125;
        if (LOBYTE(v137[1]))
          *(_DWORD *)(a1 + 52) = DWORD1(v137[1]);
        if (BYTE8(v137[1]))
          *(_DWORD *)(a1 + 56) = HIDWORD(v137[1]);
LABEL_112:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v3", 0) < 1)
          goto LABEL_115;
        DWORD2(v137[0]) = 0;
        *(_QWORD *)&v137[0] = 0;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v3", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1096, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v126, v127, v128, (char)"pkzip extra field InfoZIP UNIX v3");
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(a1 + 52) = *(_QWORD *)((char *)v137 + 4);
LABEL_115:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field ZIP64", 0) < 1)
          goto LABEL_121;
        memset(v137, 0, 40);
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field ZIP64", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1118, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v129, v130, v131, (char)"pkzip extra field ZIP64");
          return 0xFFFFFFFFLL;
        }
        if (LOBYTE(v137[0]))
          *(_QWORD *)(a1 + 80) = *((_QWORD *)&v137[0] + 1);
        if (BYTE1(v137[0]))
          *(_QWORD *)(a1 + 112) = *(_QWORD *)&v137[1];
LABEL_121:
        v132 = platform_strlen(*(_QWORD *)(a1 + 8), *(char **)(a1 + 24));
        v133 = *(_QWORD *)(a1 + 24);
        v134 = *(_WORD *)(a1 + 48);
        if (*(_BYTE *)(v133 + v132 - 1) == 47)
        {
          *(_WORD *)(a1 + 48) = v134 | 0x41C0;
          *(_BYTE *)(v133 + v132 - 1) = 0;
        }
        else
        {
          *(_WORD *)(a1 + 48) = v134 | 0x8180;
        }
        *(_DWORD *)(a1 + 16) = 2;
        if (*(_BYTE *)(a1 + 104))
        {
          v135 = *(unsigned __int8 *)(a1 + 105);
          if (*(_BYTE *)(a1 + 105))
            v29 = 7;
          else
            v29 = 4;
          if (!WORD4(v140))
            goto LABEL_138;
        }
        else
        {
          v135 = *(unsigned __int8 *)(a1 + 105);
          if (!WORD4(v140))
          {
            if (*(_BYTE *)(a1 + 105))
            {
              v29 = 5;
            }
            else if (*(_QWORD *)(a1 + 80))
            {
              v29 = 2;
            }
            else
            {
              v29 = 1;
            }
            goto LABEL_138;
          }
        }
        if (v135)
          v29 = 6;
        else
          v29 = 3;
LABEL_138:
        result = 0;
        goto LABEL_25;
      case 7u:
      case 0xCu:
      case 0xDu:
      case 0xEu:
        goto LABEL_47;
      case 0xAu:
        *(_QWORD *)(a1 + 16) = 0x100000003;
        v77 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
        if (v77 <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1300, (uint64_t)"populate_pkzip_entry_central_directory_header", "PKZip local header format entry is missing %s attribute", v78, v79, v80, (char)"name");
          return 0xFFFFFFFFLL;
        }
        v81 = v77 + 1;
        v82 = (char *)platform_calloc(*(_QWORD *)(a1 + 8), v77 + 1, 1uLL);
        if (!v82)
        {
          v115 = __error();
          strerror(*v115);
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1308, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not allocate %ld bytes for name buffer: %s", v116, v117, v118, v81);
          return 0xFFFFFFFFLL;
        }
        v83 = v82;
        if (darc_format_entry_get_attribute((uint64_t)a4, "name", v82) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1315, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not get %s attribute", v84, v85, v86, (char)"name");
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(a1 + 24) = v83;
        v87 = platform_strlen(*(_QWORD *)(a1 + 8), v83) - 1;
        v88 = *(_QWORD *)(a1 + 24);
        v89 = *(unsigned __int8 *)(v88 + v87);
        if (v89 == 47)
          *(_BYTE *)(v88 + v87) = 0;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip central directory header", 0) <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1341, (uint64_t)"populate_pkzip_entry_central_directory_header", "PKZip local header format entry is missing %s attribute", v90, v91, v92, (char)"pkzip central directory header");
          return 0xFFFFFFFFLL;
        }
        memset(v137, 0, sizeof(v137));
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip central directory header", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1350, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not get %s attribute", v93, v94, v95, (char)"pkzip central directory header");
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(a1 + 80) = DWORD2(v137[1]);
        v96 = convert_dos_to_unix_time(a1, WORD6(v137[0]), HIWORD(v137[0]));
        *(_QWORD *)(a1 + 88) = v96;
        *(_QWORD *)(a1 + 72) = v96;
        v97 = (DWORD2(v137[2]) >> 4) & 1;
        if (v89 == 47)
          v97 = 1;
        if (v97)
          v98 = 16832;
        else
          v98 = -32384;
        if (DWORD2(v137[2]) >> 28)
          v98 = WORD5(v137[2]);
        *(_WORD *)(a1 + 48) = v98;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", 0) < 1)
          return 0;
        v140 = 0u;
        v141 = 0u;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", &v140) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1393, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not get %s attribute", v99, v100, v101, (char)"pkzip extra field InfoZIP UNIX v1");
          return 0xFFFFFFFFLL;
        }
        v102 = *((_QWORD *)&v140 + 1);
        *(_QWORD *)(a1 + 88) = v140;
        *(_QWORD *)(a1 + 72) = v102;
        if ((_BYTE)v141)
          *(_DWORD *)(a1 + 52) = DWORD1(v141);
        if (BYTE8(v141))
          *(_DWORD *)(a1 + 56) = HIDWORD(v141);
        return 0;
      default:
        capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 909, (uint64_t)"populate_pkzip_entry", "Unsupported format entry type: %d", v34, v35, v36, type);
        return 0xFFFFFFFFLL;
    }
  }
  if (a2 != 3)
  {
    if (a2 != 2)
    {
      capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 258, (uint64_t)"data_archive_entry_set_format_entry", "Unsupported format: %d", a6, a7, a8, a2);
      return 0xFFFFFFFFLL;
    }
    v13 = darc_format_entry_get_type(a4);
    if (v13 != 1 && (a3 != 3 || v13 != 3))
    {
      if (v13 != 3)
      {
        v14 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
        if (v14 >= 1)
        {
          v15 = v14 + 1;
          v16 = platform_calloc(*(_QWORD *)(a1 + 8), v14 + 1, 1uLL);
          if (!v16)
          {
            v107 = __error();
            strerror(*v107);
            capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 647, (uint64_t)"populate_posix_ustar_entry", "Could not allocate %ld bytes for name buffer: %s", v108, v109, v110, v15);
            return 0xFFFFFFFFLL;
          }
          v17 = v16;
          if (darc_format_entry_get_attribute((uint64_t)a4, "name", v16) == -1)
          {
            capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 654, (uint64_t)"populate_posix_ustar_entry", "Could not get %s attribute", v18, v19, v20, (char)"name");
            return 0xFFFFFFFFLL;
          }
          *(_QWORD *)(a1 + 24) = v17;
        }
        if (darc_format_entry_get_attribute((uint64_t)a4, "POSIX ustar header", 0) <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 670, (uint64_t)"populate_posix_ustar_entry", "POSIX ustar format entry is missing %s attribute", v21, v22, v23, (char)"POSIX ustar header");
        }
        else
        {
          memset(v137, 0, 40);
          if (darc_format_entry_get_attribute((uint64_t)a4, "POSIX ustar header", v137) != -1)
          {
            *(_WORD *)(a1 + 48) = WORD2(v137[0]);
            *(_QWORD *)(a1 + 52) = *((_QWORD *)&v137[0] + 1);
            v27 = *(_QWORD *)&v137[1];
            *(int8x16_t *)(a1 + 72) = vextq_s8((int8x16_t)v137[1], (int8x16_t)v137[1], 8uLL);
            if (LODWORD(v137[0]) <= 4)
              *(_DWORD *)(a1 + 16) = dword_2063CFF30[SLODWORD(v137[0])];
            result = 0;
            if (v27 <= 0)
              v29 = 1;
            else
              v29 = 2;
LABEL_25:
            *(_DWORD *)(a1 + 20) = v29;
            return result;
          }
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 679, (uint64_t)"populate_posix_ustar_entry", "Could not get %s attribute", v24, v25, v26, (char)"POSIX ustar header");
        }
        return 0xFFFFFFFFLL;
      }
      goto LABEL_47;
    }
    goto LABEL_45;
  }
  v57 = darc_format_entry_get_type(a4);
  if (v57 == 5)
  {
LABEL_47:
    result = 0;
    v58 = 0x100000004;
    goto LABEL_48;
  }
  if (v57 == 1)
  {
LABEL_45:
    result = 0;
    v58 = 0x100000001;
LABEL_48:
    *(_QWORD *)(a1 + 16) = v58;
    return result;
  }
  v59 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
  if (v59 <= 0)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 768, (uint64_t)"populate_cpio_entry", "CPIO format entry is missing %s attribute", v60, v61, v62, (char)"name");
    return 0xFFFFFFFFLL;
  }
  v63 = v59 + 1;
  v64 = platform_calloc(*(_QWORD *)(a1 + 8), v59 + 1, 1uLL);
  if (!v64)
  {
    v103 = __error();
    strerror(*v103);
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 776, (uint64_t)"populate_cpio_entry", "Could not allocate %ld bytes for name buffer: %s", v104, v105, v106, v63);
    return 0xFFFFFFFFLL;
  }
  v65 = v64;
  if (darc_format_entry_get_attribute((uint64_t)a4, "name", v64) == -1)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 783, (uint64_t)"populate_cpio_entry", "Could not get %s attribute", v66, v67, v68, (char)"name");
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 24) = v65;
  if (darc_format_entry_get_attribute((uint64_t)a4, "cpio header", 0) <= 0)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 798, (uint64_t)"populate_cpio_entry", "CPIO format entry is missing %s attribute", v69, v70, v71, (char)"cpio header");
    return 0xFFFFFFFFLL;
  }
  v139 = 0;
  v138 = 0u;
  memset(v137, 0, sizeof(v137));
  if (darc_format_entry_get_attribute((uint64_t)a4, "cpio header", v137) == -1)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 807, (uint64_t)"populate_cpio_entry", "Could not get %s attribute", v72, v73, v74, (char)"cpio header");
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 32) = DWORD2(v137[0]);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)&v137[1];
  *(_WORD *)(a1 + 48) = WORD4(v137[1]);
  *(_QWORD *)(a1 + 52) = *(_QWORD *)((char *)&v137[1] + 12);
  *(_WORD *)(a1 + 60) = WORD2(v137[2]);
  *(_DWORD *)(a1 + 64) = DWORD2(v137[2]);
  v75 = v139;
  *(_QWORD *)(a1 + 72) = v138;
  *(_QWORD *)(a1 + 80) = v75;
  if (platform_strlen(*(_QWORD *)(a1 + 8), *(char **)(a1 + 24)) == 10)
  {
    result = platform_strncmp(*(_QWORD *)(a1 + 8), "TRAILER!!!", *(char **)(a1 + 24), 0xAuLL);
    *(_DWORD *)(a1 + 20) = 1;
    v76 = (_DWORD *)(a1 + 20);
    if (!(_DWORD)result)
    {
      *(_DWORD *)(a1 + 16) = 4;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 1;
    v76 = (_DWORD *)(a1 + 20);
  }
  *(_DWORD *)(a1 + 16) = 2;
  if (*(uint64_t *)(a1 + 80) < 1)
    return 0;
  result = 0;
  *v76 = 2;
  return result;
}

_DWORD *data_archive_entry_get_data_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1684369012 && result[30] == 1953391972)
      return (_DWORD *)result[5];
    else
      return 0;
  }
  return result;
}

uint64_t data_archive_entry_path(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1684369012 && *(_DWORD *)(result + 120) == 1953391972)
      return *(_QWORD *)(result + 24);
    else
      return 0;
  }
  return result;
}

uint64_t data_archive_entry_dev(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972)
    return a1[8];
  else
    return 0xFFFFFFFFLL;
}

uint64_t data_archive_entry_inode(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(_QWORD *)(a1 + 40);
  else
    return -1;
}

uint64_t data_archive_entry_nlink(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(unsigned __int16 *)(a1 + 60);
  else
    return 0xFFFFLL;
}

uint64_t data_archive_entry_mode(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(unsigned __int16 *)(a1 + 48);
  else
    return 0xFFFFLL;
}

uint64_t data_archive_entry_uid(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972)
    return a1[13];
  else
    return 0xFFFFFFFFLL;
}

uint64_t data_archive_entry_gid(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972)
    return a1[14];
  else
    return 0xFFFFFFFFLL;
}

uint64_t data_archive_entry_size(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(_QWORD *)(a1 + 80);
  else
    return -1;
}

uint64_t data_archive_entry_atime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(_QWORD *)(a1 + 88);
  else
    return -1;
}

uint64_t data_archive_entry_atime_nsec(_DWORD *a1)
{
  if (!a1 || *a1 != 1684369012)
    return -1;
  if (a1[30] == 1953391972)
    return 0;
  return -1;
}

uint64_t data_archive_entry_mtime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(_QWORD *)(a1 + 72);
  else
    return -1;
}

uint64_t data_archive_entry_ctime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(_QWORD *)(a1 + 96);
  else
    return -1;
}

uint64_t data_archive_entry_compressed_size(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972)
    return *(_QWORD *)(a1 + 112);
  else
    return -1;
}

uint64_t data_archive_entry_crc32(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972)
    return a1[27];
  else
    return 0xFFFFFFFFLL;
}

BOOL data_archive_entry_is_streamed(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)result == 1684369012 && *(_DWORD *)(result + 120) == 1953391972 && *(_BYTE *)(result + 105) != 0;
  return result;
}

uint64_t convert_dos_to_unix_time(uint64_t a1, unsigned int a2, unsigned int a3)
{
  tm v7;

  memset(&v7, 0, sizeof(v7));
  platform_memset(*(_QWORD *)(a1 + 8), &v7, 0, 0x38uLL);
  v7.tm_mon = ((a2 >> 5) & 0xF) - 1;
  v7.tm_year = (a2 >> 9) + 80;
  v7.tm_hour = a3 >> 11;
  v7.tm_mday = a2 & 0x1F;
  v7.tm_sec = 2 * (a3 & 0x1F);
  v7.tm_min = (a3 >> 5) & 0x3F;
  v7.tm_isdst = -1;
  return platform_mktime(*(_QWORD *)(a1 + 8), &v7);
}

uint64_t BOMStreamWithBlockID(uint64_t a1, unsigned int a2, unint64_t a3, int a4)
{
  uint64_t v8;
  size_t v9;
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  FILE *v16;
  int *v17;
  FILE *v18;
  int *v19;
  char *v20;

  if (a3 > 0xE8D4A51000)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "stream maximum size exceeded: %lu > %lu");
    return 0;
  }
  v8 = BOMStorageSizeOfBlock(a1, a2);
  if (!(a3 | v8))
    return 0;
  v9 = v8;
  v10 = BOM_malloczero(0x58uLL);
  if (!v10)
  {
    v16 = (FILE *)*MEMORY[0x24BDAC8D8];
    v17 = __error();
    strerror(*v17);
    fprintf(v16, "malloc: %s\n");
    return 0;
  }
  v11 = (uint64_t)v10;
  v10[1] = 1;
  *((_QWORD *)v10 + 10) = BOMStorageGetSys(a1);
  *(_DWORD *)v11 = 0;
  *(_QWORD *)(v11 + 8) = a1;
  *(_DWORD *)(v11 + 16) = a2;
  if (a3)
    v12 = a3;
  else
    v12 = v9;
  *(_QWORD *)(v11 + 32) = v12;
  *(_DWORD *)(v11 + 40) = a4;
  if (v9 <= a3)
    v13 = a3;
  else
    v13 = v9;
  v14 = (char *)BOM_malloczero(v13);
  *(_QWORD *)(v11 + 48) = v14;
  if (!v14)
  {
    v18 = (FILE *)*MEMORY[0x24BDAC8D8];
    v19 = __error();
    v20 = strerror(*v19);
    fprintf(v18, "malloc: %s\n", v20);
LABEL_17:
    BOMStreamFree(v11);
    return 0;
  }
  *(_BYTE *)(v11 + 72) = 1;
  v15 = &v14[*(_QWORD *)(v11 + 32)];
  *(_QWORD *)(v11 + 56) = v14;
  *(_QWORD *)(v11 + 64) = v15;
  if ((*(_DWORD *)(v11 + 40) | 2) == 2 && BOMStorageCopyFromBlock(a1, a2, v14))
    goto LABEL_17;
  return v11;
}

uint64_t BOMStreamFree(uint64_t result)
{
  uint64_t v1;
  void *v2;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 73) && BOMStreamFlush((int *)result))
    {
      return 1;
    }
    else
    {
      v2 = *(void **)(v1 + 48);
      if (v2)
      {
        if (*(_BYTE *)(v1 + 72))
          free(v2);
      }
      free((void *)v1);
      return 0;
    }
  }
  return result;
}

uint64_t BOMStreamWithFile(int a1, uint64_t a2, unint64_t a3, int a4, char *a5)
{
  return BOMStreamWithFileAndSys(a1, a2, a3, a4, a5, 0);
}

uint64_t BOMStreamWithFileAndSys(int a1, uint64_t a2, unint64_t a3, int a4, char *a5, void *a6)
{
  size_t v6;
  void *v12;
  uint64_t v13;
  FILE *v14;
  int *v15;
  char *v16;
  const char *v17;
  FILE *v18;
  int *v19;
  char *v20;

  v6 = a3;
  if (a3 > 0xE8D4A51000)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "stream maximum size exceeded: %lu > %lu");
    return 0;
  }
  if (!a3)
    return 0;
  v12 = BOM_malloczero(0x58uLL);
  if (!v12)
  {
    v14 = (FILE *)*MEMORY[0x24BDAC8D8];
    v15 = __error();
    strerror(*v15);
    fprintf(v14, "malloc: %s\n");
    return 0;
  }
  v13 = (uint64_t)v12;
  if (!a6)
    a6 = BomSys_default();
  *(_QWORD *)(v13 + 80) = a6;
  *(_QWORD *)v13 = 0x100000001;
  *(_DWORD *)(v13 + 20) = a1;
  *(_QWORD *)(v13 + 24) = a2;
  *(_QWORD *)(v13 + 32) = v6;
  *(_DWORD *)(v13 + 40) = a4;
  if (a5)
  {
    *(_QWORD *)(v13 + 48) = a5;
    *(_BYTE *)(v13 + 72) = 0;
  }
  else
  {
    v16 = (char *)BOM_malloczero(v6);
    *(_QWORD *)(v13 + 48) = v16;
    if (!v16)
    {
      v17 = "malloc: %s\n";
      goto LABEL_19;
    }
    a5 = v16;
    *(_BYTE *)(v13 + 72) = 1;
    v6 = *(_QWORD *)(v13 + 32);
    a4 = *(_DWORD *)(v13 + 40);
  }
  *(_QWORD *)(v13 + 56) = a5;
  *(_QWORD *)(v13 + 64) = &a5[v6];
  if ((a4 | 2) == 2)
  {
    if ((*((uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))a6 + 8))(*((_QWORD *)a6 + 1), *(unsigned int *)(v13 + 20), *(_QWORD *)(v13 + 24), 0) == -1)
    {
      v17 = "lseek: %s\n";
      goto LABEL_19;
    }
    if ((*((uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))a6 + 6))(*((_QWORD *)a6 + 1), *(unsigned int *)(v13 + 20), *(_QWORD *)(v13 + 48), *(_QWORD *)(v13 + 32)) != *(_QWORD *)(v13 + 32))
    {
      v17 = "read: %s\n";
LABEL_19:
      v18 = (FILE *)*MEMORY[0x24BDAC8D8];
      v19 = __error();
      v20 = strerror(*v19);
      fprintf(v18, v17, v20);
      BOMStreamFree(v13);
      return 0;
    }
  }
  return v13;
}

_QWORD *BOMStreamWithAddress(uint64_t a1, unint64_t a2, int a3)
{
  _QWORD *result;
  FILE *v7;
  int *v8;

  if (a2 <= 0xE8D4A51000)
  {
    if (a2)
    {
      result = BOM_malloczero(0x58uLL);
      if (result)
      {
        *result = 0x100000002;
        result[4] = a2;
        *((_DWORD *)result + 10) = a3;
        *((_BYTE *)result + 72) = 0;
        result[6] = a1;
        result[7] = a1;
        result[8] = a1 + a2;
        return result;
      }
      v7 = (FILE *)*MEMORY[0x24BDAC8D8];
      v8 = __error();
      strerror(*v8);
      fprintf(v7, "malloc: %s\n");
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "stream maximum size exceeded: %lu > %lu");
  }
  return 0;
}

uint64_t BOMStreamFlush(int *a1)
{
  int v2;
  uint64_t v3;
  FILE *v4;
  int *v5;
  FILE *v7;
  int *v8;

  if (a1)
  {
    if (!a1[10])
      goto LABEL_12;
    v2 = *a1;
    if (*a1 == 2)
      goto LABEL_12;
    if (v2 != 1)
    {
      if (!v2)
      {
        v3 = BOMStorageSetBlockData(*((_QWORD *)a1 + 1), a1[4], *((_QWORD *)a1 + 6), *((_QWORD *)a1 + 4));
LABEL_13:
        *((_BYTE *)a1 + 73) = 0;
        return v3;
      }
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "unknown stream type: %d\n", *a1);
LABEL_12:
      v3 = 0;
      goto LABEL_13;
    }
    if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*((_QWORD *)a1 + 10) + 64))(*(_QWORD *)(*((_QWORD *)a1 + 10) + 8), a1[5], *((_QWORD *)a1 + 3), 0) == -1)
    {
      v7 = (FILE *)*MEMORY[0x24BDAC8D8];
      v8 = __error();
      strerror(*v8);
      fprintf(v7, "lseek: %s\n");
    }
    else
    {
      if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*((_QWORD *)a1 + 10) + 56))(*(_QWORD *)(*((_QWORD *)a1 + 10) + 8), a1[5], *((_QWORD *)a1 + 6), *((_QWORD *)a1 + 4)) == *((_QWORD *)a1 + 4))goto LABEL_12;
      v4 = (FILE *)*MEMORY[0x24BDAC8D8];
      v5 = __error();
      strerror(*v5);
      fprintf(v4, "write: %s\n");
    }
    return 1;
  }
  v3 = 1;
  fwrite("bad stream!\n", 0xCuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return v3;
}

uint64_t BOMStreamGetSys(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 80);
  return result;
}

uint64_t BOMStreamSetByteOrder(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = 1;
  if (a1)
  {
    if (a2 <= 2)
    {
      result = 0;
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
  return result;
}

uint64_t BOMStreamGetByteOrder(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 4);
  return result;
}

unint64_t BOMStreamReadUInt64(uint64_t a1)
{
  int v2;
  const char *v3;
  unsigned __int8 v4;
  int v5;
  unint64_t *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v2 = *__error();
    v3 = "read called on write-only buffer!\n";
    v4 = 0;
    v5 = 356;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    v8 = 0;
    goto LABEL_7;
  }
  v6 = *(unint64_t **)(a1 + 56);
  v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(_QWORD *)(a1 + 64))
  {
    v2 = *__error();
    v3 = "buffer overflow!";
    v4 = 1;
    v5 = 604;
    goto LABEL_5;
  }
  v8 = *v6;
  *(_QWORD *)(a1 + 56) = v7;
LABEL_7:
  v9 = bswap64(v8);
  if (*(_DWORD *)(a1 + 4) == 2)
    return v8;
  else
    return v9;
}

uint64_t BOMStreamReadUInt32(uint64_t a1)
{
  int v2;
  const char *v3;
  unsigned __int8 v4;
  int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v2 = *__error();
    v3 = "read called on write-only buffer!\n";
    v4 = 0;
    v5 = 378;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    v8 = 0;
    goto LABEL_7;
  }
  v6 = *(unsigned int **)(a1 + 56);
  v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(_QWORD *)(a1 + 64))
  {
    v2 = *__error();
    v3 = "buffer overflow!";
    v4 = 1;
    v5 = 604;
    goto LABEL_5;
  }
  v8 = *v6;
  *(_QWORD *)(a1 + 56) = v7;
LABEL_7:
  v9 = bswap32(v8);
  if (*(_DWORD *)(a1 + 4) == 2)
    return v8;
  else
    return v9;
}

uint64_t BOMStreamReadUInt16(uint64_t a1)
{
  int v2;
  const char *v3;
  unsigned __int8 v4;
  int v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned int v9;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v2 = *__error();
    v3 = "read called on write-only buffer!\n";
    v4 = 0;
    v5 = 400;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    v8 = 0;
    goto LABEL_7;
  }
  v6 = *(unsigned __int16 **)(a1 + 56);
  v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(_QWORD *)(a1 + 64))
  {
    v2 = *__error();
    v3 = "buffer overflow!";
    v4 = 1;
    v5 = 604;
    goto LABEL_5;
  }
  v8 = *v6;
  *(_QWORD *)(a1 + 56) = v7;
LABEL_7:
  v9 = __rev16(v8);
  if (*(_DWORD *)(a1 + 4) == 2)
    return v8;
  else
    return v9;
}

uint64_t BOMStreamReadUInt8(uint64_t a1)
{
  int v1;
  const char *v2;
  unsigned __int8 v3;
  int v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v1 = *__error();
    v2 = "read called on write-only buffer!\n";
    v3 = 0;
    v4 = 422;
  }
  else
  {
    v5 = *(unsigned __int8 **)(a1 + 56);
    v6 = v5 + 1;
    if ((unint64_t)(v5 + 1) <= *(_QWORD *)(a1 + 64))
    {
      v7 = *v5;
      *(_QWORD *)(a1 + 56) = v6;
      return v7;
    }
    v1 = *__error();
    v2 = "buffer overflow!";
    v3 = 1;
    v4 = 604;
  }
  _BOMExceptionHandlerCall((uint64_t)v2, v3, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v4, v1);
  return 0;
}

void *BOMStreamReadBuffer(uint64_t a1, void *__dst, size_t __len)
{
  int v3;
  const char *v4;
  unsigned __int8 v5;
  int v6;
  const void *v9;
  void *result;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v3 = *__error();
    v4 = "read called on write-only buffer!\n";
    v5 = 0;
    v6 = 441;
    return (void *)_BOMExceptionHandlerCall((uint64_t)v4, v5, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v6, v3);
  }
  if (__len >= 0xE8D4A51001)
  {
    v3 = *__error();
    v4 = "buffer overflow!";
    v5 = 1;
    v6 = 599;
    return (void *)_BOMExceptionHandlerCall((uint64_t)v4, v5, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v6, v3);
  }
  v9 = *(const void **)(a1 + 56);
  if ((unint64_t)v9 + __len > *(_QWORD *)(a1 + 64))
  {
    v3 = *__error();
    v4 = "buffer overflow!";
    v5 = 1;
    v6 = 604;
    return (void *)_BOMExceptionHandlerCall((uint64_t)v4, v5, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v6, v3);
  }
  result = memmove(__dst, v9, __len);
  *(_QWORD *)(a1 + 56) += __len;
  return result;
}

uint64_t BOMStreamReadAddress(uint64_t a1, unint64_t a2)
{
  int v2;
  const char *v3;
  unsigned __int8 v4;
  int v5;
  uint64_t v6;

  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v2 = *__error();
    v3 = "read called on write-only buffer!\n";
    v4 = 0;
    v5 = 464;
  }
  else if (*(_DWORD *)a1 == 2)
  {
    if (a2 < 0xE8D4A51001)
    {
      v6 = *(_QWORD *)(a1 + 56);
      if (v6 + a2 <= *(_QWORD *)(a1 + 64))
      {
        *(_QWORD *)(a1 + 56) = v6 + a2;
        return v6;
      }
      v2 = *__error();
      v3 = "buffer overflow!";
      v4 = 1;
      v5 = 604;
    }
    else
    {
      v2 = *__error();
      v3 = "buffer overflow!";
      v4 = 1;
      v5 = 599;
    }
  }
  else
  {
    v2 = *__error();
    v3 = "BOMStreamReadAddress: bad buffer type!\n";
    v4 = 0;
    v5 = 468;
  }
  _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
  return 0;
}

uint64_t BOMStreamWriteUInt32(uint64_t result, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  int *v5;
  int *v6;

  v2 = bswap32(a2);
  if (*(_DWORD *)(result + 4) == 2)
    v3 = a2;
  else
    v3 = v2;
  if (*(_DWORD *)(result + 40))
  {
    v4 = *(unsigned int **)(result + 56);
    if ((unint64_t)(v4 + 1) <= *(_QWORD *)(result + 64))
    {
      *v4 = v3;
      *(_QWORD *)(result + 56) += 4;
      *(_BYTE *)(result + 73) = 1;
    }
    else
    {
      v5 = __error();
      return _BOMExceptionHandlerCall((uint64_t)"buffer overflow!", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 614, *v5);
    }
  }
  else
  {
    v6 = __error();
    return _BOMExceptionHandlerCall((uint64_t)"write called on read-only buffer!\n", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 500, *v6);
  }
  return result;
}

uint64_t BOMStreamWriteUInt16(uint64_t result, __int16 a2)
{
  __int16 v2;
  __int16 v3;
  _WORD *v4;
  int *v5;
  int *v6;

  v2 = __rev16(a2);
  if (*(_DWORD *)(result + 4) == 2)
    v3 = a2;
  else
    v3 = v2;
  if (*(_DWORD *)(result + 40))
  {
    v4 = *(_WORD **)(result + 56);
    if ((unint64_t)(v4 + 1) <= *(_QWORD *)(result + 64))
    {
      *v4 = v3;
      *(_QWORD *)(result + 56) += 2;
      *(_BYTE *)(result + 73) = 1;
    }
    else
    {
      v5 = __error();
      return _BOMExceptionHandlerCall((uint64_t)"buffer overflow!", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 614, *v5);
    }
  }
  else
  {
    v6 = __error();
    return _BOMExceptionHandlerCall((uint64_t)"write called on read-only buffer!\n", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 527, *v6);
  }
  return result;
}

uint64_t BOMStreamWriteUInt8(uint64_t result, char a2)
{
  _BYTE *v2;
  int *v3;
  int *v4;

  if (*(_DWORD *)(result + 40))
  {
    v2 = *(_BYTE **)(result + 56);
    if ((unint64_t)(v2 + 1) <= *(_QWORD *)(result + 64))
    {
      *v2 = a2;
      ++*(_QWORD *)(result + 56);
      *(_BYTE *)(result + 73) = 1;
    }
    else
    {
      v3 = __error();
      return _BOMExceptionHandlerCall((uint64_t)"buffer overflow!", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 614, *v3);
    }
  }
  else
  {
    v4 = __error();
    return _BOMExceptionHandlerCall((uint64_t)"write called on read-only buffer!\n", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 545, *v4);
  }
  return result;
}

void *BOMStreamWriteBuffer(uint64_t a1, const void *a2, size_t __len)
{
  int v4;
  const char *v5;
  unsigned __int8 v6;
  int v7;
  void *v9;
  void *result;

  if (!*(_DWORD *)(a1 + 40))
  {
    v4 = *__error();
    v5 = "write called on read-only buffer!\n";
    v6 = 0;
    v7 = 563;
    return (void *)_BOMExceptionHandlerCall((uint64_t)v5, v6, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v7, v4);
  }
  if (__len >= 0xE8D4A51001)
  {
    v4 = *__error();
    v5 = "buffer overflow!";
    v6 = 1;
    v7 = 609;
    return (void *)_BOMExceptionHandlerCall((uint64_t)v5, v6, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v7, v4);
  }
  v9 = *(void **)(a1 + 56);
  if ((unint64_t)v9 + __len > *(_QWORD *)(a1 + 64))
  {
    v4 = *__error();
    v5 = "buffer overflow!";
    v6 = 1;
    v7 = 614;
    return (void *)_BOMExceptionHandlerCall((uint64_t)v5, v6, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v7, v4);
  }
  result = memmove(v9, a2, __len);
  *(_QWORD *)(a1 + 56) += __len;
  *(_BYTE *)(a1 + 73) = 1;
  return result;
}

uint64_t BOMStreamAdvance(uint64_t result, unint64_t a2)
{
  int *v2;
  unint64_t v3;
  int *v4;

  if (a2 < 0xE8D4A51001)
  {
    v3 = *(_QWORD *)(result + 56) + a2;
    if (v3 <= *(_QWORD *)(result + 64))
    {
      *(_QWORD *)(result + 56) = v3;
    }
    else
    {
      v4 = __error();
      return _BOMExceptionHandlerCall((uint64_t)"buffer overflow!", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 614, *v4);
    }
  }
  else
  {
    v2 = __error();
    return _BOMExceptionHandlerCall((uint64_t)"buffer overflow!", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", 609, *v2);
  }
  return result;
}

char *BOMBomEnumeratorNew(uint64_t a1, unsigned int *a2)
{
  return BOMBomEnumeratorNewWithOptions(a1, a2, 1);
}

char *BOMBomEnumeratorNewWithOptions(uint64_t a1, unsigned int *a2, int a3)
{
  char *v3;
  char *v7;
  void **v8;
  unsigned int *RootFSObject;
  signed int v10;
  char *v11;
  const char *v12;
  int v13;
  char *v14;
  unsigned int *Value;
  _QWORD *v16;
  unsigned __int8 *v17;
  _BYTE *v18;
  int v19;
  size_t v21;

  v3 = 0;
  if (a1)
  {
    if (a3)
    {
      v7 = (char *)BOM_malloczero(0x440uLL);
      v3 = v7;
      if (v7)
      {
        v21 = 0;
        *((_DWORD *)v7 + 11) = a3;
        *(_QWORD *)v7 = a1;
        *((_QWORD *)v7 + 1) = BOMBomPathsTree(a1);
        *((_QWORD *)v3 + 2) = BOMStackNew();
        *((_QWORD *)v3 + 3) = BOMStackNew();
        v8 = BOMStackNew();
        *((_QWORD *)v3 + 4) = v8;
        if (!*((_QWORD *)v3 + 2) || !*((_QWORD *)v3 + 3) || !v8)
          goto LABEL_20;
        RootFSObject = a2;
        if (!a2)
        {
          RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a1);
          if (!RootFSObject)
          {
            v3[49] = 1;
            return v3;
          }
        }
        v10 = BOMFSObjectParentPathID((uint64_t)RootFSObject);
        v11 = (char *)BOMFSObjectShortName((uint64_t)RootFSObject);
        v12 = (const char *)BOMFSObjectPathName((uint64_t)RootFSObject);
        v3[48] = BOMFSObjectType(RootFSObject) == 2;
        v13 = strlen(v12);
        memmove(v3 + 50, v12, v13);
        *((_QWORD *)v3 + 135) = &v3[v13 + 50];
        v14 = BOMNewPathKey(v10, v11, &v21);
        if ((a3 & 4) != 0)
        {
          Value = (unsigned int *)BOMTreeGetValue(*((_QWORD *)v3 + 1), v14, v21);
          free(v14);
          v10 = BOMPathIDFromPathKey(Value);
          v14 = BOMNewPathKey(v10, "", &v21);
        }
        if (!a2)
          BOMFSObjectFree((uint64_t)RootFSObject);
        v16 = BOMTreeIteratorNew(*((_QWORD *)v3 + 1), v14, v21, 0);
        free(v14);
        if (v16)
        {
          BOMStackPush(*((char **)v3 + 3), (uint64_t)v16);
          BOMStackPush(*((char **)v3 + 2), v10);
          BOMStackPush(*((char **)v3 + 4), 0);
          *((_DWORD *)v3 + 10) = v10;
          if ((a3 & 4) == 0)
          {
            v17 = (unsigned __int8 *)(*((_QWORD *)v3 + 135) - 1);
            while (1)
            {
              v18 = v17 + 1;
              if (v17 + 1 <= (unsigned __int8 *)v3 + 50)
                break;
              *((_QWORD *)v3 + 135) = v17;
              v19 = *v17--;
              if (v19 == 47)
              {
                v18 = v17 + 1;
                break;
              }
            }
            *v18 = 0;
          }
        }
        else
        {
LABEL_20:
          BOMBomEnumeratorFree(v3);
          return 0;
        }
      }
    }
  }
  return v3;
}

void BOMBomEnumeratorFree(void *a1)
{
  void **v2;
  uint64_t v3;
  uint64_t *v4;
  void **v5;

  if (a1)
  {
    v2 = (void **)*((_QWORD *)a1 + 2);
    if (v2)
      BOMStackFree(v2);
    v3 = *((_QWORD *)a1 + 3);
    if (v3)
    {
      while (!BOMStackIsEmpty(v3))
      {
        v4 = BOMStackPop(*((uint64_t **)a1 + 3));
        BOMTreeIteratorFree((char *)v4);
        v3 = *((_QWORD *)a1 + 3);
      }
      BOMStackFree(*((void ***)a1 + 3));
    }
    v5 = (void **)*((_QWORD *)a1 + 4);
    if (v5)
      BOMStackFree(v5);
    free(a1);
  }
}

_DWORD *BOMBomEnumeratorNext(uint64_t a1)
{
  _DWORD *FSObjectWithBlockID;
  unsigned int v4;
  unsigned int v5;
  int v6;
  unint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  const char *v13;
  size_t v14;
  size_t v15;
  _BYTE *v16;
  unsigned int *v17;
  uint64_t v18;
  int v19;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  _BYTE *v26;
  int v27;
  unsigned int *v28;
  unsigned __int8 *v29;
  _BYTE *v30;
  int v31;
  uint64_t *v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int *v35;
  char *v36;
  const char *v37;
  const char *v38;
  int v39;
  int v40;
  unsigned int *v41;
  char *v42;
  _QWORD *v43;
  unsigned int *v44;
  unsigned int *v45;
  char *v46;
  char *v47;
  char *v48;
  int *v49;
  char *v50;
  int *v51;
  size_t v52;
  char __s[1024];
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  if (!a1 || *(_BYTE *)(a1 + 49))
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v52 = 0;
  v7 = a1 + 50;
  v8 = 1;
  while (2)
  {
    v9 = BOMStackPeek(*(_QWORD **)(a1 + 24));
    if (!v9)
    {
      FSObjectWithBlockID = 0;
      *(_BYTE *)(a1 + 49) = 1;
      return FSObjectWithBlockID;
    }
    v10 = (uint64_t)v9;
    v11 = 0;
    switch(BOMStackPeek(*(_QWORD **)(a1 + 32)))
    {
      case 0u:
        if (BOMTreeIteratorIsAtEnd(v10))
          goto LABEL_60;
        v12 = (unsigned int *)BOMTreeIteratorKey(v10);
        v6 = BOMPathIDFromPathKey(v12);
        if (v6 != BOMStackPeek(*(_QWORD **)(a1 + 16)))
          goto LABEL_60;
        v11 = *(_DWORD *)(a1 + 44) & 1;
        if (v11)
          v8 = 1;
        v13 = (const char *)BOMShortNameFromPathKey((uint64_t)v12);
        v14 = strlen(v13);
        v15 = v14;
        v16 = *(_BYTE **)(a1 + 1080);
        if ((uint64_t)&v16[v14 - v7] >= 1024)
        {
          v48 = BOMExceptionHandlerMessage("%lu + %p - %p > %d", v14, v16, (const void *)(a1 + 50), 1024);
          v49 = __error();
          _BOMFatalException((uint64_t)v48, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBomEnumerator.c", 75, *v49);
        }
        if (v16 != (_BYTE *)v7)
        {
          *(_QWORD *)(a1 + 1080) = v16 + 1;
          *v16 = 47;
          **(_BYTE **)(a1 + 1080) = 0;
        }
        if ((unint64_t)__strlcat_chk() >= 0x401)
        {
          v50 = BOMExceptionHandlerMessage("strlcat(%p, %s, %lu) >= %lu)", (const void *)(a1 + 50), v13, 1025, 1025);
          v51 = __error();
          _BOMFatalException((uint64_t)v50, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBomEnumerator.c", 83, *v51);
        }
        *(_QWORD *)(a1 + 1080) += v15;
        if (v11)
          __strlcpy_chk();
        v17 = (unsigned int *)BOMTreeIteratorValue(v10);
        v5 = BOMPathIDFromPathKey(v17);
        v4 = BOMBlockIDFromPathValue((uint64_t)v17);
        v18 = BOMTreeStorage(*(_QWORD *)(a1 + 8));
        v19 = BOMStorageSizeOfBlock(v18, v4);
        v20 = BOM_malloc(v19);
        v21 = BOMTreeStorage(*(_QWORD *)(a1 + 8));
        if (BOMStorageCopyFromBlock(v21, v4, v20))
          goto LABEL_61;
        v22 = BOMFSObjectTypeFromRawData((unsigned __int8 *)v20);
        free(v20);
        if (v22 != 2 || (*(_BYTE *)(a1 + 44) & 4) != 0)
          goto LABEL_39;
        v23 = *(_QWORD **)(a1 + 32);
        v24 = 1;
        goto LABEL_40;
      case 1u:
        if (BOMTreeIteratorIsAtEnd(v10))
        {
          v25 = (unsigned __int8 *)(*(_QWORD *)(a1 + 1080) - 1);
          while (1)
          {
            v26 = v25 + 1;
            if ((unint64_t)(v25 + 1) <= v7)
              goto LABEL_59;
            *(_QWORD *)(a1 + 1080) = v25;
            v27 = *v25--;
            if (v27 == 47)
              goto LABEL_58;
          }
        }
        v35 = (unsigned int *)BOMTreeIteratorKey(v10);
        v6 = BOMPathIDFromPathKey(v35);
        if (v6 == BOMStackPeek(*(_QWORD **)(a1 + 16)))
        {
          v36 = strrchr((char *)(a1 + 50), 47);
          if (v36)
          {
            if (*v36)
            {
              v37 = v36 + 1;
              v38 = (const char *)BOMShortNameFromPathKey((uint64_t)v35);
              if (strcmp(v37, v38))
              {
                v25 = (unsigned __int8 *)(*(_QWORD *)(a1 + 1080) - 1);
                while (1)
                {
                  v26 = v25 + 1;
                  if ((unint64_t)(v25 + 1) <= v7)
                    goto LABEL_59;
                  *(_QWORD *)(a1 + 1080) = v25;
                  v39 = *v25--;
                  if (v39 == 47)
                    goto LABEL_58;
                }
              }
            }
          }
          v41 = (unsigned int *)BOMTreeIteratorValue(v10);
          v5 = BOMPathIDFromPathKey(v41);
          v42 = BOMNewPathKey(v5, "", &v52);
          v43 = BOMTreeIteratorNew(*(_QWORD *)(a1 + 8), v42, v52, 0);
          free(v42);
          BOMStackPush(*(char **)(a1 + 16), v5);
          BOMStackPush(*(char **)(a1 + 24), (uint64_t)v43);
          BOMStackPush(*(char **)(a1 + 32), 0);
          continue;
        }
        v25 = (unsigned __int8 *)(*(_QWORD *)(a1 + 1080) - 1);
        while (1)
        {
          v26 = v25 + 1;
          if ((unint64_t)(v25 + 1) <= v7)
            break;
          *(_QWORD *)(a1 + 1080) = v25;
          v40 = *v25--;
          if (v40 == 47)
          {
LABEL_58:
            v26 = v25 + 1;
            break;
          }
        }
LABEL_59:
        *v26 = 0;
LABEL_60:
        BOMStackPoke(*(_QWORD **)(a1 + 32), 3);
        v11 = 0;
LABEL_61:
        if (!v11)
          continue;
LABEL_67:
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(*(_QWORD *)a1, v4);
        if (FSObjectWithBlockID)
        {
          v46 = __s;
          v47 = strrchr(__s, 47);
          if (v47)
            v46 = v47 + 1;
          BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, __s, 1);
          BOMFSObjectSetShortName((uint64_t)FSObjectWithBlockID, v46, 1);
          BOMFSObjectSetPathID((uint64_t)FSObjectWithBlockID, v5);
          BOMFSObjectSetParentPathID((uint64_t)FSObjectWithBlockID, v6);
          BOMFSObjectSetBlockID((uint64_t)FSObjectWithBlockID, v4);
          BOMFSObjectSetVisitOrder((uint64_t)FSObjectWithBlockID, v8);
        }
        return FSObjectWithBlockID;
      case 2u:
        if (BOMTreeIteratorIsAtEnd(v10)
          || (v28 = (unsigned int *)BOMTreeIteratorKey(v10),
              v6 = BOMPathIDFromPathKey(v28),
              v6 != BOMStackPeek(*(_QWORD **)(a1 + 16))))
        {
          v11 = 0;
        }
        else
        {
          if ((*(_BYTE *)(a1 + 44) & 2) != 0)
          {
            v44 = (unsigned int *)BOMTreeIteratorKey(v10);
            v6 = BOMPathIDFromPathKey(v44);
            v45 = (unsigned int *)BOMTreeIteratorValue(v10);
            v5 = BOMPathIDFromPathKey(v45);
            v4 = BOMBlockIDFromPathValue((uint64_t)v45);
            __strlcpy_chk();
            v8 = 2;
            v11 = 1;
          }
          else
          {
            v11 = 0;
          }
          BOMTreeIteratorNext(v10);
        }
        v29 = (unsigned __int8 *)(*(_QWORD *)(a1 + 1080) - 1);
        while (1)
        {
          v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) <= v7)
            break;
          *(_QWORD *)(a1 + 1080) = v29;
          v31 = *v29--;
          if (v31 == 47)
          {
            v30 = v29 + 1;
            break;
          }
        }
        *v30 = 0;
LABEL_37:
        if (!BOMTreeIteratorIsAtEnd(v10)
          && *(_BYTE *)(a1 + 48)
          && (v33 = BOMStackPeek(*(_QWORD **)(a1 + 16)),
              v34 = (unsigned int *)BOMTreeIteratorKey(v10),
              BOMPathIDFromPathKey(v34) == v33)
          && ((*(_BYTE *)(a1 + 44) & 4) != 0 || *(_DWORD *)(a1 + 40) != BOMStackPeek(*(_QWORD **)(a1 + 16))))
        {
          v23 = *(_QWORD **)(a1 + 32);
          v24 = 0;
        }
        else
        {
          v32 = BOMStackPop(*(uint64_t **)(a1 + 24));
          BOMTreeIteratorFree((char *)v32);
          BOMStackPop(*(uint64_t **)(a1 + 16));
          BOMStackPop(*(uint64_t **)(a1 + 32));
LABEL_39:
          v23 = *(_QWORD **)(a1 + 32);
          v24 = 2;
        }
LABEL_40:
        BOMStackPoke(v23, v24);
        if (v11)
          goto LABEL_67;
        continue;
      case 3u:
        goto LABEL_37;
      default:
        goto LABEL_61;
    }
  }
}

_QWORD *BOMBomEnumeratorSkip(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = result;
    if (!*((_BYTE *)result + 49))
    {
      result = BOMStackPeek((_QWORD *)result[4]);
      if ((_DWORD)result == 1)
        return BOMStackPoke((_QWORD *)v1[4], 2);
    }
  }
  return result;
}

uint64_t BOMBomEnumeratorSkipAll(uint64_t result)
{
  if (result)
  {
    if (!*(_BYTE *)(result + 49))
      *(_DWORD *)(result + 44) |= 4u;
  }
  return result;
}

uint64_t BOMAppleDoublePathToADPath(char *__s, char *a2)
{
  uint64_t result;
  char *v5;
  size_t v6;
  char *v7;
  char *v8;
  const char *v9;
  size_t v10;

  result = 0xFFFFFFFFLL;
  if (__s && a2)
  {
    v5 = __s;
    if (__s == a2)
    {
      v6 = strlen(__s) + 1;
      v7 = (char *)BOM_malloc(v6);
      if (!v7)
        return 0xFFFFFFFFLL;
      v5 = v7;
      strlcpy(v7, __s, v6);
    }
    v8 = rindex(v5, 47);
    if (v8)
      v9 = v8 + 1;
    else
      v9 = v5;
    *a2 = 0;
    if (v8)
    {
      v10 = v8 - v5 + 1;
      memmove(a2, v5, v10);
      a2[v10] = 0;
    }
    strlcat(a2, "._", 0x400uLL);
    strlcat(a2, v9, 0x400uLL);
    if (__s == a2)
      free(v5);
    return 0;
  }
  return result;
}

uint64_t BOMAppleDoubleADPathToPath(char *a1, void *a2)
{
  uint64_t result;
  char *v5;
  char *v6;
  const char *v7;
  const char *v8;
  size_t v9;

  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    v5 = rindex(a1, 47);
    v6 = v5;
    if (v5)
      v7 = v5 + 1;
    else
      v7 = a1;
    v8 = &v7[2 * (strncmp("._", v7, 2uLL) == 0)];
    if (v6)
    {
      v9 = v6 - a1 + 1;
      memmove(a2, a1, v9);
      *((_BYTE *)a2 + v9) = 0;
    }
    strlcat((char *)a2, v8, 0x400uLL);
    return 0;
  }
  return result;
}

uint64_t BOMAppleDoubleIsADFile(const char *a1)
{
  char *v2;
  const char *v3;

  if (!a1)
    return 255;
  v2 = rindex(a1, 47);
  if (v2)
    v3 = v2 + 1;
  else
    v3 = a1;
  return strncmp(v3, "._", 2uLL) == 0;
}

uint64_t BOMAppleDoubleSize(int a1, int a2)
{
  return (a1 + a2 + 50);
}

uint64_t BOMAppleDoubleCopyHeader(unsigned int a1, unsigned int a2, _QWORD *a3, _QWORD *a4)
{
  char *v8;
  char *v9;
  uint64_t result;
  uint64_t v11;

  v8 = (char *)BOM_malloc(0x32uLL);
  if (!v8)
    return 0xFFFFFFFFLL;
  v9 = v8;
  result = 0;
  *(_QWORD *)v9 = 0x20007160500;
  *(_OWORD *)(v9 + 8) = 0uLL;
  *((_WORD *)v9 + 12) = 512;
  *(_QWORD *)(v9 + 26) = 0x3200000009000000;
  *(_DWORD *)(v9 + 34) = bswap32(a1);
  LODWORD(v11) = 0x2000000;
  HIDWORD(v11) = bswap32(a1 + 50);
  *(_QWORD *)(v9 + 38) = v11;
  *(_DWORD *)(v9 + 46) = bswap32(a2);
  *a3 = v9;
  *a4 = 50;
  return result;
}

uint64_t BOMAppleDoubleWriteHeader(uint64_t a1, unsigned int a2, unsigned int a3)
{
  CFIndex v5;
  CFIndex v6;
  UInt8 *v7;

  v6 = 0;
  v7 = 0;
  if (BOMAppleDoubleCopyHeader(a2, a3, &v7, &v6))
    return 0xFFFFFFFFLL;
  v5 = v6;
  if (BOMFileWrite(a1, v7, v6) == v5)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t BOMAppleDoubleReadHeader(int *a1, unsigned int *a2, unsigned int *a3)
{
  return BOMAppleDoubleReadHeaderWithOffsets(a1, a2, 0, a3, 0);
}

uint64_t BOMAppleDoubleReadHeaderWithOffsets(int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t result;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  unint64_t v19;
  unsigned int v20;
  _QWORD v21[3];
  unsigned __int16 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  result = 0xFFFFFFFFLL;
  if (a2 && a4)
  {
    v20 = 0;
    v19 = 0;
    *a2 = 0;
    *a4 = 0;
    memset(v21, 0, sizeof(v21));
    v22 = 0;
    if (BOMFileRead(a1, (char *)v21, 0x1AuLL) == 26)
    {
      v12 = v21[0];
      v11 = HIDWORD(v21[0]);
      v21[0] = _byteswap_uint64(__PAIR64__(v21[0], HIDWORD(v21[0])));
      v13 = v22;
      v22 = __rev16(v22);
      result = 0xFFFFFFFFLL;
      if (v12 == 118883584 && v11 == 512)
      {
        if (v13)
        {
          v14 = 0;
          while (1)
          {
            if (BOMFileRead(a1, (char *)&v19, 0xCuLL) != 12)
              return 0xFFFFFFFFLL;
            v15 = bswap32(v19);
            v16 = bswap32(HIDWORD(v19));
            v19 = __PAIR64__(v16, v15);
            v17 = bswap32(v20);
            v20 = v17;
            if (v15 != 2)
              break;
            *a4 = v17;
            v18 = a5;
            if (a5)
              goto LABEL_14;
LABEL_15:
            if (++v14 >= v22)
              return 0;
          }
          if (v15 != 9)
            goto LABEL_15;
          *a2 = v17;
          v18 = a3;
          if (!a3)
            goto LABEL_15;
LABEL_14:
          *v18 = v16;
          goto LABEL_15;
        }
        return 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t BOMCPIONew(uint64_t **a1, uint64_t a2, char a3, int a4)
{
  uint64_t *v8;
  uint64_t *v9;
  void *v10;
  uint64_t result;

  v8 = (uint64_t *)BOM_malloc(0x468uLL);
  if (v8)
  {
    v9 = v8;
    *v8 = a2;
    *((_BYTE *)v8 + 8) = a3;
    *((_DWORD *)v8 + 3) = a4;
    *((_BYTE *)v8 + 24) = 0;
    v10 = BOMHardLinkTableNew();
    v9[2] = (uint64_t)v10;
    if (v10)
    {
      result = 0;
      *a1 = v9;
      return result;
    }
    BOMCPIOFree(v9);
  }
  return 0xFFFFFFFFLL;
}

void BOMCPIOFree(uint64_t *a1)
{
  const void **v2;

  if (a1)
  {
    v2 = (const void **)a1[2];
    if (v2)
      BOMHardLinkTableFree(v2);
    if (*((_BYTE *)a1 + 8))
      BOMFileClose(*a1);
    free(a1);
  }
}

uint64_t BOMCPIOWriteHeader(uint64_t a1, char *__s, uint64_t a3)
{
  int v6;

  v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0, 0);
}

uint64_t BOMCPIOWriteHeaderAndData(uint64_t a1, uint64_t a2, void *a3, int a4, void *a5, int a6)
{
  const UInt8 *v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  int v16;
  CFIndex v18;
  uint64_t v19;
  UInt8 bytes[8];

  if ((*(_WORD *)(a2 + 4) & 0xF000) == 0x8000 && *(unsigned __int16 *)(a2 + 6) >= 2u)
  {
    v12 = BOMHardLinkTableGet(*(CFDictionaryRef **)(a1 + 16), *(_DWORD *)a2, *(_QWORD *)(a2 + 8));
    if (v12)
    {
      v13 = *(_QWORD *)v12;
    }
    else
    {
      v19 = *(unsigned int *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = v19 + 1;
      *(_QWORD *)bytes = v19;
      BOMHardLinkTableSet(*(CFDictionaryRef **)(a1 + 16), *(_DWORD *)a2, *(_QWORD *)(a2 + 8), bytes, 8);
      LODWORD(v13) = *(_DWORD *)bytes;
    }
  }
  else
  {
    LODWORD(v13) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v13 + 1;
  }
  *(_QWORD *)bytes = (unsigned __int16)v13;
  v14 = *(unsigned __int16 *)(a2 + 4);
  if ((v14 & 0xD000 | 0x2000) == 0xA000)
  {
    v15 = *(_QWORD *)(a2 + 96);
    if (v15 >> 33)
    {
      *__error() = 27;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v15 = 0;
  }
  snprintf((char *)(a1 + 25), 0x4DuLL, "%s%06ho%06ho%06ho%06ho%06ho%06ho%06ho%011o%06ho%011llo", "070707", WORD1(v13), (unsigned __int16)v13, v14, *(unsigned __int16 *)(a2 + 16), *(unsigned __int16 *)(a2 + 20), *(unsigned __int16 *)(a2 + 6), *(unsigned __int16 *)(a2 + 24), *(_QWORD *)(a2 + 48), (unsigned __int16)a4, v15);
  v16 = a4 + a6 + 76;
  if (v16 < 0x44D)
  {
    v18 = v16;
    memcpy((void *)(a1 + 101), a3, a4);
    if (a5)
      memcpy((void *)(a1 + 101 + a4), a5, a6);
    if (BOMFileWrite(*(_QWORD *)a1, (UInt8 *)(a1 + 25), v18) != v18)
      return 0xFFFFFFFFLL;
  }
  else if (BOMFileWrite(*(_QWORD *)a1, (UInt8 *)(a1 + 25), 76) != 76
         || BOMFileWrite(*(_QWORD *)a1, (UInt8 *)a3, a4) != a4
         || a5 && BOMFileWrite(*(_QWORD *)a1, (UInt8 *)a5, a6) != a6)
  {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t BOMCPIOWriteDirectory(uint64_t a1, char *__s, uint64_t a3)
{
  int v6;

  v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0, 0);
}

uint64_t BOMCPIOWriteDevice(uint64_t a1, char *__s, uint64_t a3)
{
  int v6;

  v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0, 0);
}

uint64_t BOMCPIOWriteSymlink(uint64_t a1, char *__s, uint64_t a3, char *a4)
{
  int v8;
  uint64_t v9;
  size_t v10;
  uint64_t result;

  v8 = strlen(__s);
  v9 = *(_QWORD *)(a3 + 96);
  v10 = strlen(a4);
  *(_QWORD *)(a3 + 96) = v10;
  result = BOMCPIOWriteHeaderAndData(a1, a3, __s, v8 + 1, a4, v10);
  *(_QWORD *)(a3 + 96) = v9;
  return result;
}

uint64_t BOMCPIOWriteTerminator(uint64_t *a1)
{
  _BOOL8 v2;
  UInt8 *v3;
  UInt8 *v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD v8[9];

  memset(v8, 0, sizeof(v8));
  WORD3(v8[0]) = 1;
  if (BOMCPIOWriteHeaderAndData((uint64_t)a1, (uint64_t)v8, "TRAILER!!!", 11, 0, 0))
    return 0xFFFFFFFFLL;
  v2 = 1;
  v3 = (UInt8 *)BOM_calloc(0x200uLL, 1uLL);
  if (v3)
  {
    v4 = v3;
    v5 = BOMFileUncompressedOffset(*a1);
    if (v5 <= 0)
      v6 = -(-v5 & 0x1FF);
    else
      v6 = v5 & 0x1FF;
    v2 = BOMFileWrite(*a1, v4, 512 - v6) != 512 - v6;
    free(v4);
  }
  return v2;
}

uint64_t BOMCPIOReadHeader(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  BOOL v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  FILE *v14;
  int *v15;
  char *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int16 v19;
  int v20;
  int v21;
  unsigned __int16 v22;
  _DWORD v23[2];
  char v24[77];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 24))
    return 4;
  v22 = 0;
  v20 = 0;
  v21 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  if (BOMFileRead(*(int **)a1, v24, 0x4CuLL) != 76)
    return 0xFFFFFFFFLL;
  v24[76] = 0;
  if (sscanf(v24, "%06s%06ho%06ho%06ho%06ho%06ho%06ho%06ho%011o%06ho%011llo", v23, (char *)&v21 + 2, &v21, a3 + 4, (char *)&v20 + 2, &v20, a3 + 6, &v19, &v18, &v22, &v17) != 11)return 3;
  *(_DWORD *)a3 = HIWORD(v21);
  *(_QWORD *)(a3 + 8) = (unsigned __int16)v21;
  v7 = (unsigned __int16)v20;
  *(_DWORD *)(a3 + 16) = HIWORD(v20);
  *(_DWORD *)(a3 + 20) = v7;
  *(_DWORD *)(a3 + 24) = v19;
  v8 = v23[0] == 925906736 && *(_DWORD *)((char *)v23 + 3) == 3616823;
  v9 = v18;
  *(_QWORD *)(a3 + 96) = v17;
  *(_DWORD *)(a3 + 116) = 0;
  *(_QWORD *)(a3 + 32) = v9;
  *(_QWORD *)(a3 + 40) = 0;
  *(_QWORD *)(a3 + 48) = v9;
  *(_QWORD *)(a3 + 56) = 0;
  if (!v8 || v22 > 0x400uLL)
    return 3;
  v10 = BOMFileRead(*(int **)a1, a2, v22);
  v11 = v22;
  if ((v10 & 0x8000000000000000) != 0 || (v12 = v10, v10 != v22))
  {
    v14 = (FILE *)*MEMORY[0x24BDAC8D8];
    v15 = __error();
    v16 = strerror(*v15);
    fprintf(v14, "can't read path of size %d: %s\n", v11, v16);
    return 0xFFFFFFFFLL;
  }
  v13 = 0;
  if (v22)
  {
    result = 3;
    while (a2[v13])
    {
      if (v12 == ++v13)
        return result;
    }
  }
  if (v13 == v12 || a2[v13])
    return 3;
  if (!strcmp(a2, "TRAILER!!!"))
  {
    *(_BYTE *)(a1 + 24) = 1;
    return 4;
  }
  return _sanitizePath(a2, v12);
}

uint64_t BOMCPIOGetFile(uint64_t a1)
{
  return *(_QWORD *)a1;
}

unint64_t BOMCPIORead(int **a1, char *a2, unint64_t a3)
{
  return BOMFileRead(*a1, a2, a3);
}

CFIndex BOMCPIOWrite(uint64_t *a1, UInt8 *a2, CFIndex a3)
{
  return BOMFileWrite(*a1, a2, a3);
}

unint64_t BOMCPIOSeek()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  int **v3;
  int v4;
  unint64_t v5;
  unint64_t result;
  char v7[131072];
  uint64_t v8;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = (int **)v0;
  v8 = *MEMORY[0x24BDAC8D0];
  if (v4 != 1)
    return BOMFileSeek();
  if (!v1)
    return 1;
  while (1)
  {
    v5 = v2 >= 0x20000 ? 0x20000 : v2;
    result = BOMFileRead(*v3, v7, v5);
    if (result == -1)
      break;
    if (result)
    {
      v2 -= result;
      if (v2)
        continue;
    }
    return 1;
  }
  return result;
}

uint64_t BOMPKZipNew(_QWORD *a1, uint64_t a2, char a3)
{
  _BYTE *v6;
  _BYTE *v7;
  void *v8;
  uint64_t result;

  v6 = BOM_malloczero(0x58uLL);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = v6;
  *(_QWORD *)v6 = a2;
  v6[8] = a3;
  *((_DWORD *)v6 + 12) = 16;
  v8 = BOM_calloc(0x10uLL, 0x40uLL);
  *((_QWORD *)v7 + 5) = v8;
  if (!v8)
    return 1;
  result = 0;
  *a1 = v7;
  return result;
}

void BOMPKZipFree(_QWORD *a1)
{
  unint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;

  if (*((_DWORD *)a1 + 13))
  {
    v2 = 0;
    v3 = 40;
    do
    {
      free(*(void **)(a1[5] + v3));
      ++v2;
      v3 += 64;
    }
    while (v2 < *((unsigned int *)a1 + 13));
  }
  v4 = (void *)a1[5];
  if (v4)
    free(v4);
  if (*((_BYTE *)a1 + 8))
    BOMFileClose(*a1);
  if (*((_DWORD *)a1 + 16))
  {
    v5 = 0;
    v6 = 0;
    do
    {
      free(*(void **)(a1[7] + v5));
      ++v6;
      v5 += 16;
    }
    while (v6 < *((unsigned int *)a1 + 16));
  }
  v7 = (void *)a1[7];
  if (v7)
    free(v7);
  v8 = (void *)a1[10];
  if (v8)
    free(v8);
  free(a1);
}

uint64_t BOMPKZipGetFile(uint64_t result)
{
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t BOMPKZipReadNextSignature(uint64_t a1, int *a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  int v7;
  __int16 v8;
  int v9;

  result = 1;
  if (a1 && a2)
  {
    v9 = 0;
    v8 = 0;
    while (1)
    {
      if (BOMFileRead(*(int **)a1, (char *)&v9, 4uLL) != 4)
        return 1;
      if (v9 <= 101010255)
      {
        switch(v9)
        {
          case 33639248:
            result = 0;
            v7 = 2;
            goto LABEL_30;
          case 67324752:
            goto LABEL_26;
          case 84233040:
            result = 0;
            v7 = 3;
            goto LABEL_30;
        }
      }
      else if (v9 > 117853007)
      {
        if (v9 == 117853008)
        {
          result = 0;
          v7 = 5;
          goto LABEL_30;
        }
        if (v9 == 808471376)
          return BOMPKZipReadNextSignature(a1, a2);
      }
      else
      {
        if (v9 == 101010256)
        {
          result = 0;
          v7 = 6;
          goto LABEL_30;
        }
        if (v9 == 101075792)
        {
          result = 0;
          v7 = 4;
LABEL_30:
          *a2 = v7;
          return result;
        }
      }
      v8 = 19280;
      if ((unsigned __int16)v9 == 19280)
      {
        if (BOMFileRead(*(int **)a1, (char *)&v8, 2uLL) != 2)
          return 1;
        if (v8 == 1027)
        {
LABEL_26:
          result = 0;
          v7 = 1;
          goto LABEL_30;
        }
      }
      v5 = *(_QWORD *)(a1 + 80);
      if (v5)
      {
        v6 = *(_DWORD *)(a1 + 12) - 1;
        if (*(_DWORD *)(a1 + 72) <= v6)
          LODWORD(v5) = 0;
        else
          LODWORD(v5) = *(_DWORD *)(v5 + 12 * v6);
      }
      if ((_DWORD)v5 != v9)
      {
        *a2 = 0;
        return 1;
      }
    }
  }
  return result;
}

uint64_t BOMPKZipGetNumLocalHeaders(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 12);
  else
    return 0xFFFFFFFFLL;
}

uint64_t BOMPKZipReadLocalHeader(uint64_t a1, char *a2, uint64_t a3, unint64_t *a4, _DWORD *a5, _BYTE *a6, int *a7, unsigned int *a8, _BYTE *a9)
{
  uint64_t result;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  time_t v23;
  unsigned int v24;
  uint64_t v25;
  __int16 v26;
  unsigned int v27;
  unint64_t v28;
  char *v29;
  _QWORD *v30;
  uint64_t v31;
  _BOOL4 v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int UInt32;
  unsigned int v41;
  unsigned int UInt16;
  unsigned int v43;
  char v44[26];
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  result = 1;
  if (a1 && a2 && a3 && a4)
  {
    if (BOMFileRead(*(int **)a1, v44, 0x1AuLL) != 26)
      return 1;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    v18 = BOMStreamWithAddress((uint64_t)v44, 0x1AuLL, 0);
    if (!v18)
      return 1;
    v19 = (uint64_t)v18;
    if (BOMStreamSetByteOrder((uint64_t)v18, 2u))
    {
      v20 = v19;
    }
    else
    {
      BOMStreamReadUInt16(v19);
      UInt16 = BOMStreamReadUInt16(v19);
      *a5 = BOMStreamReadUInt16(v19);
      v21 = BOMStreamReadUInt16(v19);
      v22 = BOMStreamReadUInt16(v19);
      UInt32 = BOMStreamReadUInt32(v19);
      *a4 = BOMStreamReadUInt32(v19);
      *(_QWORD *)(a3 + 96) = BOMStreamReadUInt32(v19);
      v43 = BOMStreamReadUInt16(v19);
      v41 = BOMStreamReadUInt16(v19);
      v23 = _dos2unixtime(v21 | (v22 << 16));
      *(_DWORD *)(a3 + 116) = 0;
      *(_QWORD *)(a3 + 32) = v23;
      *(_QWORD *)(a3 + 40) = 0;
      *(_QWORD *)(a3 + 48) = v23;
      *(_QWORD *)(a3 + 56) = 0;
      if (a6)
        *a6 = UInt16 & 1;
      if (a7)
        *a7 = (UInt16 >> 3) & 1;
      *a9 = 0;
      if (a8)
      {
        v24 = (v21 << 16) & 0xFF000000;
        if ((UInt16 & 8) == 0)
          v24 = UInt32;
        *a8 = v24;
      }
      BOMStreamFree(v19);
      if (v43)
      {
        if (v43 > 0x3FF)
          return 1;
        v25 = v43;
        if (BOMFileRead(*(int **)a1, a2, v43) != v43)
          return 1;
        v26 = *(_WORD *)(a3 + 4);
        if (a2[v43 - 1] == 47)
        {
          *(_WORD *)(a3 + 4) = v26 | 0x41C0;
          v25 = (unsigned __int16)(v43 - 1);
        }
        else
        {
          *(_WORD *)(a3 + 4) = v26 | 0x8180;
        }
        a2[v25] = 0;
        v32 = _sanitizePath(a2, v25);
        v27 = v41;
        if (v32)
          return 1;
      }
      else
      {
        *a2 = 0;
        v27 = v41;
      }
      if (!v27)
      {
LABEL_57:
        result = 0;
        ++*(_DWORD *)(a1 + 12);
        return result;
      }
      v28 = v27;
      if (v27 < 0x1B)
      {
        v29 = v44;
      }
      else
      {
        v29 = (char *)BOM_malloc(v27);
        if (!v29)
          return 1;
      }
      if (BOMFileRead(*(int **)a1, v29, v28) != v28)
      {
        if (v29 != v44)
          free(v29);
        return 1;
      }
      v30 = BOMStreamWithAddress((uint64_t)v29, v28, 0);
      if (!v30)
        return 1;
      v31 = (uint64_t)v30;
      if (!BOMStreamSetByteOrder((uint64_t)v30, 2u))
      {
        v33 = 0;
        v34 = v41;
        while (1)
        {
          v35 = BOMStreamReadUInt16(v31);
          v36 = BOMStreamReadUInt16(v31);
          v37 = v33 + 4;
          if (v36 + (unsigned __int16)v37 > v34)
            break;
          v38 = v36;
          if (v35 == 1)
          {
            if (*(_QWORD *)(a3 + 96) == 0xFFFFFFFFLL)
            {
              *(_QWORD *)(a3 + 96) = BOMStreamReadUInt64(v31);
              v39 = 8;
            }
            else
            {
              v39 = 0;
            }
            if (*a4 == 0xFFFFFFFF)
            {
              *a4 = BOMStreamReadUInt64(v31);
              v39 += 8;
            }
            *a9 = 1;
          }
          else if (v35 == 22613)
          {
            *(_QWORD *)(a3 + 32) = BOMStreamReadUInt32(v31);
            *(_QWORD *)(a3 + 48) = BOMStreamReadUInt32(v31);
            *(_DWORD *)(a3 + 16) = BOMStreamReadUInt16(v31);
            *(_DWORD *)(a3 + 20) = BOMStreamReadUInt16(v31);
            v39 = 12;
          }
          else
          {
            v39 = 0;
          }
          if (v38 != v39)
            BOMStreamAdvance(v31, (unsigned __int16)(v38 - v39));
          v33 = v38 + v37;
          v34 = v41;
          if (v41 == (unsigned __int16)v33)
          {
            BOMStreamFree(v31);
            if (v29 != v44)
              free(v29);
            goto LABEL_57;
          }
        }
      }
      v20 = v31;
    }
    BOMStreamFree(v20);
    return 1;
  }
  return result;
}

time_t _dos2unixtime(unsigned int a1)
{
  tm *v2;
  uint32x4_t v3;
  int8x16_t v4;
  time_t v6;

  v6 = time(0);
  v2 = localtime(&v6);
  v3.i32[0] = a1;
  v4 = (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(a1), (uint32x4_t)xmmword_2063CFF80);
  v4.i32[0] = vshlq_u32(v3, (uint32x4_t)xmmword_2063CFF70).u32[0];
  *(int8x16_t *)&v2->tm_sec = vandq_s8(v4, (int8x16_t)xmmword_2063CFF90);
  v2->tm_mon = ((a1 >> 21) & 0xF) - 1;
  v2->tm_year = (a1 >> 25) + 80;
  return mktime(v2);
}

uint64_t BOMPKZipWriteLocalHeader(uint64_t a1, char *__s, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  char *v6;
  __int16 v11;
  int v12;
  int v13;
  BOOL v14;
  __int16 v15;
  char *v16;
  unsigned __int16 v17;
  int v18;
  int v19;
  unsigned int v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;
  unint64_t v24;
  void *v25;
  void *v26;
  _QWORD *v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  CFIndex v35;
  __int16 v37;
  char *__src;
  __int16 v39;
  int v40[2];
  _BYTE v41[1026];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v5 = 1;
  if (a1)
  {
    v6 = __s;
    if (__s)
    {
      if (a3)
      {
        v11 = strlen(__s);
        v12 = *v6;
        if (v12 != 46 || v11 != 1)
        {
          if (v12 == 46)
          {
            if (v6[1] == 47)
            {
              v13 = v6[2];
              v6 += 2;
              v12 = v13;
              v11 -= 2;
            }
            else
            {
              v12 = 46;
            }
          }
          v14 = v12 == 47;
          v15 = v12 == 47;
          if (v14)
            v16 = v6 + 1;
          else
            v16 = v6;
          v17 = v11 - v15;
          v18 = (unsigned __int16)(v11 - v15);
          v19 = *(_WORD *)(a3 + 4) & 0xF000;
          if (v19 == 0x4000)
          {
            __memcpy_chk();
            v40[0] = 0;
            v23 = 0;
            v39 = 0;
            v41[v17++] = 47;
            v41[v17] = 0;
            v20 = v18 + 47;
            v22 = 10;
            __src = v41;
          }
          else
          {
            v20 = v18 + 46;
            __src = v16;
            if (v19 == 40960)
            {
              v23 = 0;
              v39 = 0;
              v40[0] = *(_DWORD *)(a3 + 96);
              v22 = 10;
            }
            else if (v19 == 0x8000)
            {
              *(_QWORD *)v40 = *(_QWORD *)(a3 + 96);
              v21 = *(_QWORD *)v40 != 0;
              if (*(_QWORD *)v40)
                v22 = 20;
              else
                v22 = 10;
              v23 = 8 * v21;
              v39 = 8 * v21;
            }
            else
            {
              v40[0] = 0;
              v39 = 0;
              v23 = 8;
              v22 = 20;
            }
          }
          v24 = v20;
          v25 = BOM_malloc(v20);
          if (v25)
          {
            v26 = v25;
            v37 = v22;
            v5 = 1;
            v27 = BOMStreamWithAddress((uint64_t)v25, v24, 1);
            if (!v27)
              return v5;
            v28 = (uint64_t)v27;
            if (BOMStreamSetByteOrder((uint64_t)v27, 2u))
            {
              BOMStreamFree(v28);
              free(v26);
              return v5;
            }
            BOMStreamWriteUInt32(v28, 0x4034B50u);
            BOMStreamWriteUInt16(v28, v37);
            BOMStreamWriteUInt16(v28, v23);
            BOMStreamWriteUInt16(v28, v39);
            v29 = _unix2dostime((_QWORD *)(a3 + 48));
            BOMStreamWriteUInt32(v28, v29);
            v30 = *(_WORD *)(a3 + 4) & 0xF000;
            if (v30 == 40960)
              v31 = a4;
            else
              v31 = 0;
            if (v30 == 40960)
              v32 = a5;
            else
              v32 = 0;
            if (v30 == 40960)
              v33 = v40[0];
            else
              v33 = 0;
            BOMStreamWriteUInt32(v28, v31);
            BOMStreamWriteUInt32(v28, v32);
            BOMStreamWriteUInt32(v28, v33);
            BOMStreamWriteUInt16(v28, v17);
            BOMStreamWriteUInt16(v28, 16 * ((*(_WORD *)(a3 + 4) & 0xF000) != 40960));
            BOMStreamWriteBuffer(v28, __src, v17);
            if ((*(_WORD *)(a3 + 4) & 0xF000) == 0xA000)
            {
              v24 = (v24 - 16);
            }
            else
            {
              BOMStreamWriteUInt16(v28, 22613);
              BOMStreamWriteUInt16(v28, 12);
              BOMStreamWriteUInt32(v28, *(_DWORD *)(a3 + 32));
              BOMStreamWriteUInt32(v28, *(_DWORD *)(a3 + 48));
              BOMStreamWriteUInt16(v28, *(_WORD *)(a3 + 16));
              BOMStreamWriteUInt16(v28, *(_WORD *)(a3 + 20));
            }
            BOMStreamFree(v28);
            v34 = BOMFileOffset(*(_QWORD *)a1);
            v35 = BOMFileWrite(*(_QWORD *)a1, (UInt8 *)v26, v24);
            free(v26);
            if (v35 == v24 && !_squirrelAwayInfo(a1, v34, v37, v39, a3, a4, a5, v40[0], v17, __src))
            {
              v5 = 0;
              ++*(_DWORD *)(a1 + 12);
              return v5;
            }
          }
          return 1;
        }
        return 0;
      }
    }
  }
  return v5;
}

uint64_t _unix2dostime(_QWORD *a1)
{
  tm *v1;
  int tm_year;
  time_t v4;

  v4 = (*a1 + 1) & 0xFFFFFFFFFFFFFFFELL;
  v1 = localtime(&v4);
  tm_year = v1->tm_year;
  if (tm_year >= 80)
    return ((tm_year << 25) + 1610612736) | (v1->tm_sec >> 1) | (32 * v1->tm_min) | (v1->tm_hour << 11) | (v1->tm_mday << 16) | ((v1->tm_mon << 21) + 0x200000);
  else
    return 2162688;
}

uint64_t _squirrelAwayInfo(uint64_t a1, int a2, __int16 a3, __int16 a4, uint64_t a5, int a6, int a7, int a8, unsigned __int16 a9, void *__src)
{
  unsigned int v18;
  unsigned int v19;
  void *v20;
  void *v21;
  void *v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  char v26;
  uint64_t result;

  v18 = *(_DWORD *)(a1 + 52);
  if (v18 == *(_DWORD *)(a1 + 48))
  {
    v19 = 2 * v18;
    if (v18 > 0x4000)
      v19 = v18 + 0x4000;
    *(_DWORD *)(a1 + 48) = v19;
    v20 = BOM_realloc(*(void **)(a1 + 40), (unint64_t)v19 << 6);
    *(_QWORD *)(a1 + 40) = v20;
    if (!v20)
      return 1;
    v18 = *(_DWORD *)(a1 + 52);
  }
  *(_DWORD *)(a1 + 52) = v18 + 1;
  v21 = BOM_malloc(a9);
  if (!v21)
    return 1;
  v22 = v21;
  memcpy(v21, __src, a9);
  v23 = *(_QWORD *)(a1 + 40) + ((unint64_t)v18 << 6);
  *(_WORD *)v23 = a3;
  *(_WORD *)(v23 + 2) = a4;
  v24 = *(_QWORD *)(a5 + 48);
  *(_QWORD *)(v23 + 8) = *(_QWORD *)(a5 + 32);
  *(_QWORD *)(v23 + 16) = v24;
  *(_DWORD *)(v23 + 24) = a6;
  *(_DWORD *)(v23 + 28) = a7;
  *(_DWORD *)(v23 + 32) = a8;
  *(_WORD *)(v23 + 36) = a9;
  *(_QWORD *)(v23 + 40) = v22;
  v25 = *(unsigned __int16 *)(a5 + 4);
  *(_DWORD *)(v23 + 48) = (v25 << 16) | 0x4000;
  *(_DWORD *)(v23 + 52) = a2;
  if ((v25 & 0xF000) == 0xA000)
  {
    v26 = 1;
  }
  else
  {
    v26 = 0;
    *(_DWORD *)(a1 + 36) += 12;
  }
  result = 0;
  *(_BYTE *)(v23 + 56) = v26;
  *(_DWORD *)(a1 + 36) += a9 + 46;
  return result;
}

uint64_t BOMPKZipReadDataDescriptor(int **a1, int a2, _DWORD *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v5;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t UInt64;
  char v15[20];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v5 = 1;
  if (a1 && a3 && a4 && a5)
  {
    v10 = a2 ? 20 : 12;
    if (BOMFileRead(*a1, v15, v10) == v10)
    {
      v11 = BOMStreamWithAddress((uint64_t)v15, v10, 0);
      if (v11)
      {
        v12 = (uint64_t)v11;
        if (!BOMStreamSetByteOrder((uint64_t)v11, 2u))
        {
          *a3 = BOMStreamReadUInt32(v12);
          if (a2)
          {
            *a4 = BOMStreamReadUInt64(v12);
            UInt64 = BOMStreamReadUInt64(v12);
          }
          else
          {
            *a4 = BOMStreamReadUInt32(v12);
            UInt64 = BOMStreamReadUInt32(v12);
          }
          v5 = 0;
          *a5 = UInt64;
        }
        BOMStreamFree(v12);
      }
    }
  }
  return v5;
}

BOOL BOMPKZipWriteDataDescriptor(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  _DWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  UInt8 v13[12];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  v8 = (_DWORD *)(*(_QWORD *)(a1 + 40) + ((unint64_t)(*(_DWORD *)(a1 + 52) - 1) << 6));
  v8[6] = a2;
  v8[7] = a3;
  v8[8] = a4;
  v9 = 1;
  v10 = BOMStreamWithAddress((uint64_t)v13, 0xCuLL, 1);
  if (v10)
  {
    v11 = (uint64_t)v10;
    if (BOMStreamSetByteOrder((uint64_t)v10, 2u))
    {
      BOMStreamFree(v11);
    }
    else
    {
      BOMStreamWriteUInt32(v11, a2);
      BOMStreamWriteUInt32(v11, a3);
      BOMStreamWriteUInt32(v11, a4);
      BOMStreamFree(v11);
      return BOMFileWrite(*(_QWORD *)a1, v13, 12) != 12;
    }
  }
  return v9;
}

uint64_t BOMPKZipReadCentralHeader(int **a1, char *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  _QWORD *v9;
  uint64_t v10;
  unsigned int UInt32;
  unsigned int UInt16;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  char v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  char *v20;
  char *v21;
  char v22[42];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  result = 1;
  if (a1 && a2 && a3)
  {
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    if (BOMFileRead(*a1, v22, 0x2AuLL) != 42)
      return 1;
    v9 = BOMStreamWithAddress((uint64_t)v22, 0x2AuLL, 0);
    if (!v9)
      return 1;
    v10 = (uint64_t)v9;
    if (BOMStreamSetByteOrder((uint64_t)v9, 2u))
    {
      BOMStreamFree(v10);
      return 1;
    }
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    UInt32 = BOMStreamReadUInt32(v10);
    *(_QWORD *)(a3 + 48) = _dos2unixtime(UInt32);
    BOMStreamReadUInt32(v10);
    *a4 = BOMStreamReadUInt32(v10);
    *(_QWORD *)(a3 + 96) = BOMStreamReadUInt32(v10);
    UInt16 = BOMStreamReadUInt16(v10);
    v13 = BOMStreamReadUInt16(v10);
    *(_DWORD *)(a3 + 116) = 0;
    v14 = BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    v15 = BOMStreamReadUInt32(v10);
    v16 = v15;
    *(_WORD *)(a3 + 4) = WORD1(v15);
    BOMStreamReadUInt32(v10);
    BOMStreamFree(v10);
    if (UInt16)
    {
      v17 = UInt16;
      if (UInt16 > 0x3FF)
        return 1;
      if (BOMFileRead(*a1, a2, UInt16) != UInt16)
        return 1;
      UInt16 = a2[UInt16 - 1] == 47;
      v18 = (unsigned __int16)(v17 - UInt16);
      a2[v18] = 0;
      if (_sanitizePath(a2, v18))
        return 1;
    }
    if (*(unsigned __int16 *)(a3 + 4) <= 0xFFFu)
    {
      if (UInt16 | ((v16 & 0x10) >> 4))
        v19 = 0x4000;
      else
        v19 = 0x8000;
      *(_WORD *)(a3 + 4) = v19;
    }
    if (v13)
    {
      if (v13 < 0x2B)
      {
        v20 = v22;
      }
      else
      {
        v20 = (char *)BOM_malloc(v13);
        if (!v20)
          return 1;
      }
      if (BOMFileRead(*a1, v20, v13) != v13)
        return 1;
      if (v20 != v22)
        free(v20);
    }
    if (!v14)
      return 0;
    if (v14 < 0x2B)
    {
      v21 = v22;
    }
    else
    {
      v21 = (char *)BOM_malloc(v14);
      if (!v21)
        return 1;
    }
    if (BOMFileRead(*a1, v21, v14) == v14)
    {
      if (v21 != v22)
        free(v21);
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t BOMPKZipWriteCentralDirectory(uint64_t a1)
{
  int v2;
  size_t v3;
  void *v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  _BOOL8 v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int16 v13;
  unsigned int v14;
  __int16 v15;
  unsigned int v16;

  if (!a1)
    return 1;
  v2 = *(_DWORD *)(a1 + 36);
  if (!v2)
    return 1;
  v3 = (v2 + 22);
  v4 = BOM_malloc(v3);
  if (!v4)
    return 1;
  v5 = v4;
  v6 = BOMStreamWithAddress((uint64_t)v4, v3, 1);
  if (!v6)
  {
LABEL_7:
    free(v5);
    return 1;
  }
  v7 = (uint64_t)v6;
  if (BOMStreamSetByteOrder((uint64_t)v6, 2u))
  {
    BOMStreamFree(v7);
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 52))
  {
    v10 = 0;
    v11 = 0;
    do
    {
      BOMStreamWriteUInt32(v7, 0x2014B50u);
      BOMStreamWriteUInt16(v7, 789);
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(_QWORD *)(a1 + 40) + v10));
      v12 = *(_QWORD *)(a1 + 40) + v10;
      if (*(_BYTE *)(v12 + 56))
        v13 = 0;
      else
        v13 = 8 * (*(_DWORD *)(v12 + 32) != 0);
      BOMStreamWriteUInt16(v7, v13);
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(_QWORD *)(a1 + 40) + v10 + 2));
      v14 = _unix2dostime((_QWORD *)(*(_QWORD *)(a1 + 40) + v10 + 16));
      BOMStreamWriteUInt32(v7, v14);
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(_QWORD *)(a1 + 40) + v10 + 24));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(_QWORD *)(a1 + 40) + v10 + 28));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(_QWORD *)(a1 + 40) + v10 + 32));
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(_QWORD *)(a1 + 40) + v10 + 36));
      if (*(_BYTE *)(*(_QWORD *)(a1 + 40) + v10 + 56))
        v15 = 0;
      else
        v15 = 12;
      BOMStreamWriteUInt16(v7, v15);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(_QWORD *)(a1 + 40) + v10 + 48));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(_QWORD *)(a1 + 40) + v10 + 52));
      BOMStreamWriteBuffer(v7, *(const void **)(*(_QWORD *)(a1 + 40) + v10 + 40), *(unsigned __int16 *)(*(_QWORD *)(a1 + 40) + v10 + 36));
      if (!*(_BYTE *)(*(_QWORD *)(a1 + 40) + v10 + 56))
      {
        BOMStreamWriteUInt16(v7, 22613);
        BOMStreamWriteUInt16(v7, 8);
        BOMStreamWriteUInt32(v7, *(_DWORD *)(*(_QWORD *)(a1 + 40) + v10 + 8));
        BOMStreamWriteUInt32(v7, *(_DWORD *)(*(_QWORD *)(a1 + 40) + v10 + 16));
      }
      ++v11;
      v10 += 64;
    }
    while (v11 < *(unsigned int *)(a1 + 52));
  }
  BOMStreamWriteUInt32(v7, 0x6054B50u);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamWriteUInt16(v7, *(_WORD *)(a1 + 52));
  BOMStreamWriteUInt16(v7, *(_WORD *)(a1 + 52));
  BOMStreamWriteUInt32(v7, *(_DWORD *)(a1 + 36));
  v16 = BOMFileOffset(*(_QWORD *)a1);
  BOMStreamWriteUInt32(v7, v16);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamFree(v7);
  v8 = BOMFileWrite(*(_QWORD *)a1, (UInt8 *)v5, v3) != v3;
  free(v5);
  return v8;
}

uint64_t BOMPKZipSkipDigitalSignature(int **a1)
{
  char *v2;
  char *v3;
  unint64_t v4;
  _BOOL8 v5;
  unsigned __int16 v7;

  if (!a1)
    return 1;
  v7 = 0;
  if (BOMFileRead(*a1, (char *)&v7, 2uLL) != 2)
    return 1;
  if (!v7)
    return 0;
  v2 = (char *)BOM_malloc(v7);
  if (!v2)
    return 1;
  v3 = v2;
  v4 = BOMFileRead(*a1, v2, v7);
  v5 = v4 != v7;
  free(v3);
  return v5;
}

uint64_t BOMPKZipSkipZIP64CentralDirectoryRecord(int **a1)
{
  char *v2;
  char *v3;
  _BOOL8 v4;
  uint64_t v6;

  if (!a1)
    return 1;
  v6 = 0;
  if (BOMFileRead(*a1, (char *)&v6, 8uLL) != 8)
    return 1;
  if (!v6)
    return 0;
  v2 = (char *)BOM_malloc(0x2CuLL);
  if (!v2)
    return 1;
  v3 = v2;
  v4 = BOMFileRead(*a1, v2, 0x2CuLL) != 44;
  free(v3);
  return v4;
}

BOOL BOMPKZipSkipZIP64CentralDirectoryLocation(int **a1)
{
  char v2[16];
  uint64_t v3;

  v3 = *MEMORY[0x24BDAC8D0];
  return !a1 || BOMFileRead(*a1, v2, 0x10uLL) != 16;
}

uint64_t BOMPKZipSkipEndOfCentralDirectoryRecord(int **a1)
{
  _BOOL8 v2;
  unint64_t v4;
  char *v5;
  unsigned __int16 v6;
  int v7;
  __int16 v8;
  char v9[18];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (BOMFileRead(*a1, v9, 0x12uLL) != 18)
    return 1;
  v6 = 0;
  if (_readEOCDRecord((uint64_t)v9, &v8, &v7, &v6))
    return 1;
  v4 = v6;
  if (!v6)
    return 0;
  v5 = v9;
  if (v6 >= 0x13u)
  {
    v5 = (char *)BOM_malloc(v6);
    if (!v5)
      return 1;
  }
  v2 = BOMFileRead(*a1, v5, v4) != v4;
  if (v5 != v9)
    free(v5);
  return v2;
}

uint64_t _readEOCDRecord(uint64_t a1, _WORD *a2, _DWORD *a3, _WORD *a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v7 = BOMStreamWithAddress(a1, 0x12uLL, 0);
  if (!v7)
    return 1;
  v8 = (uint64_t)v7;
  if (BOMStreamSetByteOrder((uint64_t)v7, 2u))
  {
    v9 = 1;
  }
  else
  {
    BOMStreamReadUInt16(v8);
    BOMStreamReadUInt16(v8);
    BOMStreamReadUInt16(v8);
    *a2 = BOMStreamReadUInt16(v8);
    BOMStreamReadUInt32(v8);
    *a3 = BOMStreamReadUInt32(v8);
    v9 = 0;
    *a4 = BOMStreamReadUInt16(v8);
  }
  BOMStreamFree(v8);
  return v9;
}

uint64_t BOMPKZipGetFileCompressedSize(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(result + 80);
    if (v2 && *(_DWORD *)(result + 72) > a2)
      return *(unsigned int *)(v2 + 12 * a2 + 4);
    else
      return 0;
  }
  return result;
}

uint64_t BOMPKZipGetFileUncompressedSize(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(result + 80);
    if (v2 && *(_DWORD *)(result + 72) > a2)
      return *(unsigned int *)(v2 + 12 * a2 + 8);
    else
      return 0;
  }
  return result;
}

uint64_t BOMPKZipLoadCentralDirectory(uint64_t a1)
{
  uint64_t v2;
  void *v4;
  unsigned int v5;
  unsigned int v6;
  void *v7;
  _QWORD *v8;
  uint64_t v9;
  int UInt32;
  int v11;
  int v12;
  unsigned int v13;
  _DWORD *v14;
  int v15;
  char v16[42];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  BOMFileOffset(*(_QWORD *)a1);
  if (BOMPKZipSeekToCentralDirectory() || (v15 = 0, BOMPKZipReadNextSignature(a1, &v15)))
  {
LABEL_3:
    v2 = 0xFFFFFFFFLL;
    goto LABEL_4;
  }
  while (v15 == 2)
  {
    if (BOMFileRead(*(int **)a1, v16, 0x2AuLL) != 42)
      goto LABEL_3;
    v4 = *(void **)(a1 + 80);
    if (v4)
    {
      v5 = *(_DWORD *)(a1 + 68);
      if (*(_DWORD *)(a1 + 72) + 1 <= v5)
        goto LABEL_12;
      v6 = v5 + 32;
      *(_DWORD *)(a1 + 68) = v6;
      v7 = BOM_realloc(v4, 12 * v6);
    }
    else
    {
      *(_QWORD *)(a1 + 68) = 32;
      v7 = BOM_malloczero(0x180uLL);
    }
    *(_QWORD *)(a1 + 80) = v7;
    if (!v7)
    {
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 72) = 0;
      goto LABEL_3;
    }
LABEL_12:
    v8 = BOMStreamWithAddress((uint64_t)v16, 0x2AuLL, 0);
    if (!v8)
      goto LABEL_3;
    v9 = (uint64_t)v8;
    if (BOMStreamSetByteOrder((uint64_t)v8, 2u))
    {
      BOMStreamFree(v9);
      goto LABEL_3;
    }
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    UInt32 = BOMStreamReadUInt32(v9);
    v11 = BOMStreamReadUInt32(v9);
    v12 = BOMStreamReadUInt32(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt32(v9);
    BOMStreamReadUInt32(v9);
    BOMStreamFree(v9);
    v13 = *(_DWORD *)(a1 + 72);
    v14 = (_DWORD *)(*(_QWORD *)(a1 + 80) + 12 * v13);
    *v14 = UInt32;
    v14[1] = v11;
    v14[2] = v12;
    *(_DWORD *)(a1 + 72) = v13 + 1;
    BOMFileSeek();
    v15 = 0;
    if (BOMPKZipReadNextSignature(a1, &v15))
      goto LABEL_3;
  }
  if (v15 == 6)
    v2 = 0;
  else
    v2 = 0xFFFFFFFFLL;
LABEL_4:
  BOMFileSeek();
  return v2;
}

uint64_t BOMPKZipSeekToCentralDirectory()
{
  uint64_t v0;
  _DWORD *v1;
  _DWORD *v2;
  int **v3;
  unint64_t v4;
  int64_t v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  char *v9;
  unsigned int v10;
  char *v11;
  size_t v12;
  char *v13;
  char *v14;
  int64_t v15;
  int v16;
  int64_t v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unsigned int v22;
  char v23[65558];
  uint64_t v24;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = (int **)v0;
  v24 = *MEMORY[0x24BDAC8D0];
  v4 = BOMFileSeek();
  if ((v4 & 0x8000000000000000) != 0)
    return 0xFFFFFFFFLL;
  v5 = v4;
  v6 = v4 >= 0x10016 ? 65558 : v4;
  if (BOMFileSeek() < 0 || BOMFileRead(*v3, v23, v6) != v6 || v6 < 0x16)
    return 0xFFFFFFFFLL;
  v7 = &v23[(v6 - 22)];
  if (*(_DWORD *)v7 != 101010256)
  {
    v8 = v6 & 0x3FF | 0x400;
    if (v6 < v8)
      LODWORD(v8) = v6;
    v9 = &v23[(int)v6 - (int)v8];
    if (v9 < v23)
      return 0xFFFFFFFFLL;
    v10 = v8 - 18;
    do
    {
      v7 = 0;
      v11 = v9;
LABEL_14:
      v12 = (int)v10 - 3;
      if (v10 != 3)
      {
        v13 = v11;
        do
        {
          v14 = (char *)memchr(v13, 80, v12);
          if (!v14)
            break;
          if (*(_DWORD *)v14 == 101010256)
          {
            v16 = (_DWORD)v14 - (_DWORD)v11 + 4;
            v10 -= v16;
            v11 += v16;
            v7 = v14;
            if (v10 > 3)
              goto LABEL_14;
            goto LABEL_25;
          }
          v15 = v14 - v13;
          v13 = v14 + 1;
          v12 += ~v15;
        }
        while (v12);
      }
      v9 -= 1024;
      if (v7)
        break;
      v10 = 1027;
    }
    while (v9 >= v23);
  }
  v14 = v7;
  if (!v7)
    return 0xFFFFFFFFLL;
LABEL_25:
  v21 = 0;
  v22 = 0;
  if (_readEOCDRecord((uint64_t)(v14 + 4), (_WORD *)&v21 + 1, &v22, &v21))
    return 0xFFFFFFFFLL;
  v18 = v22;
  v19 = v5 - v22;
  do
  {
    if (v18 >= v5)
      break;
    v18 += 0x100000000;
    v20 = HIDWORD(v19);
    v19 -= 0x100000000;
  }
  while (v20);
  if (v2)
    *v2 = HIWORD(v21);
  return BOMFileSeek() >> 63;
}

uint64_t BOMPKZipStoreQuarantinePath(uint64_t a1, char *__s)
{
  uint64_t result;
  unsigned __int8 v5;
  unsigned __int8 v6;
  int v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  unsigned int v13;
  char v14;
  void *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  char v19;
  unsigned int v20;

  result = 1;
  if (a1 && __s)
  {
    v5 = strlen(__s);
    v6 = v5;
    v7 = *(_DWORD *)(a1 + 64);
    if (v7)
    {
      v20 = 0;
      v19 = 0;
      _search(a1, 0, v7 - 1, __s, v5, &v20, &v19);
      if (v19)
        return 1;
      v8 = (char *)BOM_realloc(*(void **)(a1 + 56), 16 * (v7 + 1));
      *(_QWORD *)(a1 + 56) = v8;
      if (!v8)
        return 1;
      v9 = *(unsigned int *)(a1 + 64);
      v10 = v20;
      if (v9 > v20)
      {
        v11 = &v8[16 * v9 + 8];
        v12 = &v8[16 * (v9 - 1) + 8];
        v13 = *(_DWORD *)(a1 + 64);
        do
        {
          *((_QWORD *)v11 - 1) = *((_QWORD *)v12 - 1);
          v14 = *v12;
          v12 -= 16;
          *v11 = v14;
          v11 -= 16;
          --v13;
        }
        while (v10 < v13);
      }
      *(_DWORD *)(a1 + 64) = v9 + 1;
      v15 = BOM_malloc(v6);
      v16 = *(_QWORD **)(a1 + 56);
      v16[2 * v10] = v15;
      if (v15)
      {
        memcpy(v15, __s, v6);
        result = 0;
        *(_BYTE *)(*(_QWORD *)(a1 + 56) + 16 * v10 + 8) = v6;
        return result;
      }
    }
    else
    {
      v17 = BOM_malloc(0x10uLL);
      *(_QWORD *)(a1 + 56) = v17;
      if (!v17)
        return 1;
      v18 = BOM_malloc(v6);
      v16 = *(_QWORD **)(a1 + 56);
      *v16 = v18;
      if (v18)
      {
        memcpy(v18, __s, v6);
        result = 0;
        *(_BYTE *)(*(_QWORD *)(a1 + 56) + 8) = v6;
        ++*(_DWORD *)(a1 + 64);
        return result;
      }
    }
    free(v16);
    return 1;
  }
  return result;
}

uint64_t _search(uint64_t a1, unsigned int a2, unsigned int a3, void *__s1, unsigned int a5, unsigned int *a6, _BYTE *a7)
{
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  size_t v17;
  uint64_t result;
  _BOOL4 v20;
  unsigned int v21;

  v13 = *(_QWORD *)(a1 + 56);
  while (1)
  {
    while (1)
    {
      v14 = a2 + ((a3 - a2) >> 1);
      v15 = v13 + 16 * v14;
      v16 = *(unsigned __int8 *)(v15 + 8);
      v17 = v16 >= a5 ? a5 : *(unsigned __int8 *)(v15 + 8);
      result = memcmp(__s1, *(const void **)v15, v17);
      if ((result & 0x80000000) == 0)
        break;
      if (a3 == a2)
      {
        v20 = 0;
LABEL_21:
        *a6 = v14 + v20;
        return result;
      }
LABEL_15:
      a3 = v14 - (a3 - a2 > 1);
    }
    v20 = result != 0;
    if (!(_DWORD)result && v16 <= a5)
      break;
    if (a3 == a2)
      goto LABEL_21;
    if (!(_DWORD)result)
      goto LABEL_15;
LABEL_18:
    if (v14 == a3)
      a2 += (a3 - a2) >> 1;
    else
      a2 = v14 + 1;
  }
  if (a3 != a2)
  {
    if (v16 >= a5)
    {
      *a6 = v14;
LABEL_29:
      *a7 = 1;
      return result;
    }
    goto LABEL_18;
  }
  if (v16 >= a5)
    v21 = a2 + ((a3 - a2) >> 1);
  else
    v21 = v14 + 1;
  *a6 = v21;
  if (v16 >= a5)
    goto LABEL_29;
  return result;
}

uint64_t BOMPKZipLookupQuarantinePath(uint64_t a1, char *__s, _BYTE *a3)
{
  uint64_t result;
  int v7;
  unsigned __int8 v8;
  unsigned int v9;

  result = 1;
  if (a1 && __s && a3)
  {
    v7 = *(_DWORD *)(a1 + 64);
    *a3 = 0;
    if (v7)
    {
      v8 = strlen(__s);
      _search(a1, 0, *(_DWORD *)(a1 + 64) - 1, __s, v8, &v9, a3);
    }
    return 0;
  }
  return result;
}

uint64_t BOMPKZipQuarantinePathCount(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 64);
  else
    return 1;
}

uint64_t BOMPKZipCopyQuarantinePath(uint64_t a1, unsigned int a2, void *__dst)
{
  uint64_t result;
  uint64_t v7;

  if (!a1)
    return 1;
  if (*(_DWORD *)(a1 + 64) < a2)
    return 1;
  v7 = *(_QWORD *)(a1 + 56) + 16 * a2;
  memcpy(__dst, *(const void **)v7, *(unsigned __int8 *)(v7 + 8));
  result = 0;
  *((_BYTE *)__dst + *(unsigned __int8 *)(*(_QWORD *)(a1 + 56) + 16 * a2 + 8)) = 0;
  return result;
}

uint64_t decrypt_byte(uint64_t a1)
{
  return ((unsigned __int16)((*(_WORD *)(a1 + 8) & 0xFFFD ^ 3) * (*(_WORD *)(a1 + 8) | 2)) >> 8);
}

uint64_t update_keys(int *a1, uint64_t a2)
{
  int v2;
  unsigned int v3;

  v2 = PKZip_crctab_0[(*a1 ^ a2)] ^ (*a1 >> 8);
  v3 = 134775813 * (a1[1] + v2) + 1;
  *a1 = v2;
  a1[1] = v3;
  a1[2] = PKZip_crctab_0[a1[2] ^ HIBYTE(v3)] ^ (a1[2] >> 8);
  return a2;
}

uint64_t init_keys(uint64_t result, _BYTE *a2)
{
  char v2;
  int *v3;
  unsigned __int8 *v4;
  int v5;

  *(_QWORD *)result = 0x2345678912345678;
  *(_DWORD *)(result + 8) = 878082192;
  v2 = *a2;
  if (*a2)
  {
    v3 = (int *)result;
    v4 = a2 + 1;
    do
    {
      result = update_keys(v3, v2);
      v5 = *v4++;
      v2 = v5;
    }
    while (v5);
  }
  return result;
}

uint64_t *BOMCopierDataAnalyzerNew(int a1, _QWORD *a2)
{
  __int16 v3;
  uint64_t *v4;
  uint64_t *v5;
  int inited;
  int v7;
  int *v8;

  if (!a1)
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 90, (uint64_t)"BOMCopierDataAnalyzerNew", "No flag is set.");
    return 0;
  }
  v3 = a1;
  v4 = (uint64_t *)malloc_type_calloc(1uLL, 0x90uLL, 0x1030040F8F0F2B1uLL);
  if (!v4)
  {
    v7 = *__error();
    v8 = __error();
    strerror(*v8);
    BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 103, (uint64_t)"BOMCopierDataAnalyzerNew", "Could not allocate BOMCopierDataAnalyzer: %s");
    return 0;
  }
  v5 = v4;
  if ((v3 & 1) != 0)
  {
    *v4 |= 1uLL;
    if ((v3 & 2) == 0)
    {
LABEL_5:
      if ((v3 & 8) == 0)
        goto LABEL_6;
      goto LABEL_20;
    }
  }
  else if ((v3 & 2) == 0)
  {
    goto LABEL_5;
  }
  *v4 |= 2uLL;
  if ((v3 & 8) == 0)
  {
LABEL_6:
    if ((v3 & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_21;
  }
LABEL_20:
  *v4 |= 8uLL;
  if ((v3 & 0x10) == 0)
  {
LABEL_7:
    if ((v3 & 0x20) == 0)
      goto LABEL_8;
    goto LABEL_22;
  }
LABEL_21:
  *v4 |= 0x10uLL;
  if ((v3 & 0x20) == 0)
  {
LABEL_8:
    if ((v3 & 0x40) == 0)
      goto LABEL_9;
    goto LABEL_23;
  }
LABEL_22:
  *v4 |= 0x20uLL;
  if ((v3 & 0x40) == 0)
  {
LABEL_9:
    if ((v3 & 0x80) == 0)
      goto LABEL_10;
    goto LABEL_24;
  }
LABEL_23:
  *v4 |= 0x40uLL;
  if ((v3 & 0x80) == 0)
  {
LABEL_10:
    if ((v3 & 0x100) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_24:
  *v4 |= 0x80uLL;
  if ((v3 & 0x100) != 0)
LABEL_11:
    *v4 |= 0x100uLL;
LABEL_12:
  inited = init_data_analyzer(v4, a2);
  if (inited)
  {
    BOMCopierErrorCapture(a2, inited, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 112, (uint64_t)"BOMCopierDataAnalyzerNew", "Could not initialize BOMCopierDataAnalyzer");
    BOMCopierDataAnalyzerFree(v5);
    return 0;
  }
  return v5;
}

uint64_t init_data_analyzer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  int v5;
  _QWORD *v6;
  int v7;
  int *v8;
  int v9;
  int *v10;
  uint64_t v11;
  CC_MD5_CTX *v13;
  void *v14;
  CC_SHA1_CTX *v15;
  void *v16;
  CC_SHA256_CTX *v17;
  void *v18;
  CC_SHA256_CTX *v19;
  void *v20;
  CC_SHA512_CTX *v21;
  void *v22;
  int *v23;
  char *v24;
  CC_SHA512_CTX *v25;
  void *v26;
  int v27;
  int *v28;
  int v29;
  int *v30;
  int v31;
  int *v32;
  int v33;
  int *v34;
  int v35;
  int *v36;
  int v37;
  int *v38;
  int v39;
  int *v40;
  int v41;
  int *v42;
  int v43;
  int *v44;
  int v45;
  int *v46;
  int v47;
  int *v48;
  int v49;
  int *v50;

  v4 = *a1;
  if ((*a1 & 1) != 0)
  {
    v6 = a1 + 1;
    if (a1[1])
    {
      CNCRCRelease();
      *v6 = 0;
    }
    if (CNCRCInit())
    {
      v7 = *__error();
      v8 = __error();
      strerror(*v8);
      BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 474, (uint64_t)"init_data_analyzer", "Could not allocate CRC_32 context: %s");
      return 1;
    }
    *((_DWORD *)a1 + 4) = 0;
    v4 = *a1;
    v5 = 1;
    if ((*a1 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 8) == 0)
        goto LABEL_4;
      goto LABEL_21;
    }
  }
  else
  {
    v5 = 0;
    if ((v4 & 2) == 0)
      goto LABEL_3;
  }
  if (a1[3])
  {
    CNCRCRelease();
    a1[3] = 0;
  }
  if (CNCRCInit())
  {
    v9 = *__error();
    v10 = __error();
    strerror(*v10);
    BOMCopierErrorCapture(a2, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 498, (uint64_t)"init_data_analyzer", "Could not allocate CRC_32 POSIX context: %s");
    return 1;
  }
  *((_DWORD *)a1 + 10) = 0;
  a1[4] = 0;
  ++v5;
  v4 = *a1;
  if ((*a1 & 8) == 0)
  {
LABEL_4:
    if ((v4 & 0x10) == 0)
      goto LABEL_5;
    goto LABEL_26;
  }
LABEL_21:
  v13 = (CC_MD5_CTX *)a1[6];
  if (!v13)
  {
    v13 = (CC_MD5_CTX *)malloc_type_calloc(1uLL, 0x5CuLL, 0x100004034A301B9uLL);
    a1[6] = (uint64_t)v13;
    if (!v13)
    {
      v27 = *__error();
      v28 = __error();
      strerror(*v28);
      BOMCopierErrorCapture(a2, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 519, (uint64_t)"init_data_analyzer", "Could not allocate MD5 context: %s");
      return 1;
    }
  }
  CC_MD5_Init(v13);
  if (!a1[12])
  {
    v14 = malloc_type_malloc(0x10uLL, 0x53B91330uLL);
    a1[12] = (uint64_t)v14;
    if (!v14)
    {
      v29 = *__error();
      v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture(a2, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 534, (uint64_t)"init_data_analyzer", "Could not allocate MD5 digest: %s");
      return 1;
    }
  }
  ++v5;
  v4 = *a1;
  if ((*a1 & 0x10) == 0)
  {
LABEL_5:
    if ((v4 & 0x20) == 0)
      goto LABEL_6;
    goto LABEL_31;
  }
LABEL_26:
  v15 = (CC_SHA1_CTX *)a1[7];
  if (!v15)
  {
    v15 = (CC_SHA1_CTX *)malloc_type_calloc(1uLL, 0x60uLL, 0x1000040565EDBD2uLL);
    a1[7] = (uint64_t)v15;
    if (!v15)
    {
      v31 = *__error();
      v32 = __error();
      strerror(*v32);
      BOMCopierErrorCapture(a2, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 553, (uint64_t)"init_data_analyzer", "Could not allocate SHA1 context: %s");
      return 1;
    }
  }
  CC_SHA1_Init(v15);
  if (!a1[13])
  {
    v16 = malloc_type_malloc(0x14uLL, 0x40C8835uLL);
    a1[13] = (uint64_t)v16;
    if (!v16)
    {
      v33 = *__error();
      v34 = __error();
      strerror(*v34);
      BOMCopierErrorCapture(a2, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 565, (uint64_t)"init_data_analyzer", "Could not allocate SHA1 digest: %s");
      return 1;
    }
  }
  ++v5;
  v4 = *a1;
  if ((*a1 & 0x20) == 0)
  {
LABEL_6:
    if ((v4 & 0x40) == 0)
      goto LABEL_7;
LABEL_36:
    v19 = (CC_SHA256_CTX *)a1[9];
    if (!v19)
    {
      v19 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x68uLL, 0x1000040ED882C02uLL);
      a1[9] = (uint64_t)v19;
      if (!v19)
      {
        v39 = *__error();
        v40 = __error();
        strerror(*v40);
        BOMCopierErrorCapture(a2, v39, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 615, (uint64_t)"init_data_analyzer", "Could not allocate SHA256 context: %s");
        return 1;
      }
    }
    CC_SHA256_Init(v19);
    if (!a1[15])
    {
      v20 = malloc_type_malloc(0x20uLL, 0x1E2B12uLL);
      a1[15] = (uint64_t)v20;
      if (!v20)
      {
        v41 = *__error();
        v42 = __error();
        strerror(*v42);
        BOMCopierErrorCapture(a2, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 627, (uint64_t)"init_data_analyzer", "Could not allocate SHA256 digest: %s");
        return 1;
      }
    }
    ++v5;
    if ((*a1 & 0x80) == 0)
      goto LABEL_46;
    goto LABEL_41;
  }
LABEL_31:
  v17 = (CC_SHA256_CTX *)a1[8];
  if (!v17)
  {
    v17 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x68uLL, 0x1000040ED882C02uLL);
    a1[8] = (uint64_t)v17;
    if (!v17)
    {
      v35 = *__error();
      v36 = __error();
      strerror(*v36);
      BOMCopierErrorCapture(a2, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 584, (uint64_t)"init_data_analyzer", "Could not allocate SHA224 context: %s");
      return 1;
    }
  }
  CC_SHA224_Init(v17);
  if (!a1[14])
  {
    v18 = malloc_type_malloc(0x1CuLL, 0xA309EA1BuLL);
    a1[14] = (uint64_t)v18;
    if (!v18)
    {
      v37 = *__error();
      v38 = __error();
      strerror(*v38);
      BOMCopierErrorCapture(a2, v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 596, (uint64_t)"init_data_analyzer", "Could not allocate SHA224 digest: %s");
      return 1;
    }
  }
  ++v5;
  v4 = *a1;
  if ((*a1 & 0x40) != 0)
    goto LABEL_36;
LABEL_7:
  if ((v4 & 0x80) != 0)
  {
LABEL_41:
    v21 = (CC_SHA512_CTX *)a1[10];
    if (!v21)
    {
      v21 = (CC_SHA512_CTX *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10000400F93440CuLL);
      a1[10] = (uint64_t)v21;
      if (!v21)
      {
        v43 = *__error();
        v44 = __error();
        strerror(*v44);
        BOMCopierErrorCapture(a2, v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 646, (uint64_t)"init_data_analyzer", "Could not allocate SHA384 context: %s");
        return 1;
      }
    }
    CC_SHA384_Init(v21);
    if (!a1[16])
    {
      v22 = malloc_type_malloc(0x30uLL, 0xEBA7307EuLL);
      a1[16] = (uint64_t)v22;
      if (!v22)
      {
        v45 = *__error();
        v46 = __error();
        strerror(*v46);
        BOMCopierErrorCapture(a2, v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 658, (uint64_t)"init_data_analyzer", "Could not allocate SHA384 digest: %s");
        return 1;
      }
    }
    v5 = 1;
  }
LABEL_46:
  if ((*((_BYTE *)a1 + 1) & 1) == 0)
  {
    if (!v5)
    {
      v23 = __error();
      v24 = strerror(*v23);
      v11 = 22;
      BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 699, (uint64_t)"init_data_analyzer", "No method enabled", v24);
      return v11;
    }
    return 0;
  }
  v25 = (CC_SHA512_CTX *)a1[11];
  if (v25
    || (v25 = (CC_SHA512_CTX *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10000400F93440CuLL), (a1[11] = (uint64_t)v25) != 0))
  {
    CC_SHA512_Init(v25);
    if (a1[17])
      return 0;
    v26 = malloc_type_malloc(0x40uLL, 0x333D1066uLL);
    a1[17] = (uint64_t)v26;
    if (v26)
      return 0;
    v49 = *__error();
    v50 = __error();
    strerror(*v50);
    BOMCopierErrorCapture(a2, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 689, (uint64_t)"init_data_analyzer", "Could not allocate SHA512 digest: %s");
  }
  else
  {
    v47 = *__error();
    v48 = __error();
    strerror(*v48);
    BOMCopierErrorCapture(a2, v47, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 677, (uint64_t)"init_data_analyzer", "Could not allocate SHA512 context: %s");
  }
  return 1;
}

void BOMCopierDataAnalyzerFree(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  if (a1)
  {
    if (a1[1])
      CNCRCRelease();
    if (a1[3])
      CNCRCRelease();
    v2 = (void *)a1[6];
    if (v2)
      free(v2);
    v3 = (void *)a1[7];
    if (v3)
      free(v3);
    v4 = (void *)a1[8];
    if (v4)
      free(v4);
    v5 = (void *)a1[9];
    if (v5)
      free(v5);
    v6 = (void *)a1[10];
    if (v6)
      free(v6);
    v7 = (void *)a1[11];
    if (v7)
      free(v7);
    v8 = (void *)a1[12];
    if (v8)
      free(v8);
    v9 = (void *)a1[13];
    if (v9)
      free(v9);
    v10 = (void *)a1[14];
    if (v10)
      free(v10);
    v11 = (void *)a1[15];
    if (v11)
      free(v11);
    v12 = (void *)a1[16];
    if (v12)
      free(v12);
    v13 = (void *)a1[17];
    if (v13)
      free(v13);
    free(a1);
  }
}

uint64_t *BOMCopierDataAnalyzerReset(uint64_t *result)
{
  uint64_t v1;

  if (result)
  {
    v1 = 0;
    result = (uint64_t *)init_data_analyzer(result, &v1);
    if ((_DWORD)result)
      return BOMCopierErrorCapture(&v1, (int)result, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 219, (uint64_t)"BOMCopierDataAnalyzerReset", "Could not initialize BOMCopierDataAnalyzer");
  }
  return result;
}

uint64_t BOMCopierDataAnalyzerUpdate(uint64_t *a1, void *data, uint64_t len, _QWORD *a4)
{
  uint64_t v8;
  int v9;
  int *v10;
  uint64_t v11;
  int v13;
  int *v14;

  if (a1)
  {
    if (data)
    {
      if (len)
      {
        v8 = *a1;
        if ((*a1 & 1) != 0)
        {
          if (CNCRCUpdate())
          {
            v9 = *__error();
            v10 = __error();
            strerror(*v10);
            BOMCopierErrorCapture(a4, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 723, (uint64_t)"update_data_analyzer", "Could not update CRC_32 context: %s");
            return 1;
          }
          v8 = *a1;
        }
        if ((v8 & 2) != 0)
        {
          if (CNCRCUpdate())
          {
            v13 = *__error();
            v14 = __error();
            strerror(*v14);
            BOMCopierErrorCapture(a4, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 737, (uint64_t)"update_data_analyzer", "Could not update CRC_32 POSIX context: %s");
            return 1;
          }
          a1[4] += len;
          v8 = *a1;
        }
        if ((v8 & 8) != 0)
        {
          CC_MD5_Update((CC_MD5_CTX *)a1[6], data, len);
          v8 = *a1;
          if ((*a1 & 0x10) == 0)
          {
LABEL_19:
            if ((v8 & 0x20) == 0)
              goto LABEL_20;
            goto LABEL_27;
          }
        }
        else if ((v8 & 0x10) == 0)
        {
          goto LABEL_19;
        }
        CC_SHA1_Update((CC_SHA1_CTX *)a1[7], data, len);
        v8 = *a1;
        if ((*a1 & 0x20) == 0)
        {
LABEL_20:
          if ((v8 & 0x40) == 0)
            goto LABEL_21;
          goto LABEL_28;
        }
LABEL_27:
        CC_SHA224_Update((CC_SHA256_CTX *)a1[8], data, len);
        v8 = *a1;
        if ((*a1 & 0x40) == 0)
        {
LABEL_21:
          if ((v8 & 0x80) == 0)
            goto LABEL_22;
          goto LABEL_29;
        }
LABEL_28:
        CC_SHA256_Update((CC_SHA256_CTX *)a1[9], data, len);
        v8 = *a1;
        if ((*a1 & 0x80) == 0)
        {
LABEL_22:
          if ((v8 & 0x100) == 0)
            return 0;
LABEL_23:
          CC_SHA512_Update((CC_SHA512_CTX *)a1[11], data, len);
          return 0;
        }
LABEL_29:
        CC_SHA384_Update((CC_SHA512_CTX *)a1[10], data, len);
        if ((*a1 & 0x100) == 0)
          return 0;
        goto LABEL_23;
      }
      v11 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 249, (uint64_t)"BOMCopierDataAnalyzerUpdate", "data_size is 0");
    }
    else
    {
      v11 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 243, (uint64_t)"BOMCopierDataAnalyzerUpdate", "data is NULL");
    }
  }
  else
  {
    v11 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 237, (uint64_t)"BOMCopierDataAnalyzerUpdate", "data_analyzer is NULL");
  }
  return v11;
}

uint64_t BOMCopierDataAnalyzerFinalize(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  int v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  int v10;
  int *v11;
  int v12;
  int *v13;

  if (a1)
  {
    v4 = *a1;
    if ((*a1 & 1) != 0)
    {
      if (CNCRCFinal())
      {
        v5 = *__error();
        v6 = __error();
        strerror(*v6);
        BOMCopierErrorCapture(a2, v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 820, (uint64_t)"finalize_data_analyzer", "Could not finalize CRC_32 context: %s");
        return 1;
      }
      *((_DWORD *)a1 + 4) = 0;
      v4 = *a1;
    }
    if ((v4 & 2) != 0)
    {
      v8 = a1[4];
      if (v8)
      {
        while (!CNCRCUpdate())
        {
          v9 = (unint64_t)v8 > 0xFF;
          v8 >>= 8;
          if (!v9)
            goto LABEL_11;
        }
        v12 = *__error();
        v13 = __error();
        strerror(*v13);
        BOMCopierErrorCapture(a2, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 842, (uint64_t)"finalize_data_analyzer", "Could not update length for CRC_32 POSIX context: %s");
        return 1;
      }
LABEL_11:
      if (CNCRCFinal())
      {
        v10 = *__error();
        v11 = __error();
        strerror(*v11);
        BOMCopierErrorCapture(a2, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 851, (uint64_t)"finalize_data_analyzer", "Could not finalize CRC_32 POSIX context: %s");
        return 1;
      }
      *((_DWORD *)a1 + 10) = 0;
      v4 = *a1;
    }
    if ((v4 & 8) != 0)
    {
      CC_MD5_Final((unsigned __int8 *)a1[12], (CC_MD5_CTX *)a1[6]);
      v4 = *a1;
      if ((*a1 & 0x10) == 0)
      {
LABEL_18:
        if ((v4 & 0x20) == 0)
          goto LABEL_19;
        goto LABEL_27;
      }
    }
    else if ((v4 & 0x10) == 0)
    {
      goto LABEL_18;
    }
    CC_SHA1_Final((unsigned __int8 *)a1[13], (CC_SHA1_CTX *)a1[7]);
    v4 = *a1;
    if ((*a1 & 0x20) == 0)
    {
LABEL_19:
      if ((v4 & 0x40) == 0)
        goto LABEL_20;
      goto LABEL_28;
    }
LABEL_27:
    CC_SHA224_Final((unsigned __int8 *)a1[14], (CC_SHA256_CTX *)a1[8]);
    v4 = *a1;
    if ((*a1 & 0x40) == 0)
    {
LABEL_20:
      if ((v4 & 0x80) == 0)
        goto LABEL_21;
      goto LABEL_29;
    }
LABEL_28:
    CC_SHA256_Final((unsigned __int8 *)a1[15], (CC_SHA256_CTX *)a1[9]);
    v4 = *a1;
    if ((*a1 & 0x80) == 0)
    {
LABEL_21:
      if ((v4 & 0x100) == 0)
        return 0;
LABEL_22:
      CC_SHA512_Final((unsigned __int8 *)a1[17], (CC_SHA512_CTX *)a1[11]);
      return 0;
    }
LABEL_29:
    CC_SHA384_Final((unsigned __int8 *)a1[16], (CC_SHA512_CTX *)a1[10]);
    if ((*a1 & 0x100) == 0)
      return 0;
    goto LABEL_22;
  }
  v7 = 22;
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 267, (uint64_t)"BOMCopierDataAnalyzerFinalize", "data_analyzer is NULL");
  return v7;
}

uint64_t BOMCopierDataAnalyzerGetDigest(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  int v5;
  __int128 v6;
  __int128 *v7;
  __int128 *v8;
  __int128 *v9;
  __int128 v10;
  __int128 v11;
  __int128 *v12;
  __int128 v13;
  __int128 *v14;

  if (a1)
  {
    if (a3)
    {
      switch(a2)
      {
        case 1:
          if ((*(_BYTE *)a1 & 1) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 303, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "CRC32 is not supported");
            goto LABEL_23;
          }
          v4 = 0;
          v5 = *(_DWORD *)(a1 + 16);
          goto LABEL_27;
        case 2:
          if ((*(_BYTE *)a1 & 2) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 314, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "CRC32 POSIX is not supported");
            goto LABEL_23;
          }
          v4 = 0;
          v5 = *(_DWORD *)(a1 + 40);
LABEL_27:
          *(_DWORD *)a3 = v5;
          return v4;
        case 3:
          if ((*(_BYTE *)a1 & 8) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 325, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "MD5 is not supported");
            goto LABEL_23;
          }
          v4 = 0;
          v6 = *(_OWORD *)*(_QWORD *)(a1 + 96);
          goto LABEL_31;
        case 4:
          if ((*(_BYTE *)a1 & 0x10) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 336, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA1 is not supported");
            goto LABEL_23;
          }
          v4 = 0;
          v7 = *(__int128 **)(a1 + 104);
          v6 = *v7;
          *(_DWORD *)(a3 + 16) = *((_DWORD *)v7 + 4);
          goto LABEL_31;
        case 5:
          if ((*(_BYTE *)a1 & 0x20) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 347, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA224 is not supported");
            goto LABEL_23;
          }
          v4 = 0;
          v8 = *(__int128 **)(a1 + 112);
          v6 = *v8;
          *(_OWORD *)(a3 + 12) = *(__int128 *)((char *)v8 + 12);
LABEL_31:
          *(_OWORD *)a3 = v6;
          return v4;
        case 6:
          if ((*(_BYTE *)a1 & 0x40) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 358, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA256 is not supported");
            goto LABEL_23;
          }
          v4 = 0;
          v9 = *(__int128 **)(a1 + 120);
          v10 = *v9;
          v11 = v9[1];
          goto LABEL_36;
        case 7:
          if ((*(_BYTE *)a1 & 0x80) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 369, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA384 is not supported");
            goto LABEL_23;
          }
          v4 = 0;
          v12 = *(__int128 **)(a1 + 128);
          v10 = *v12;
          v11 = v12[1];
          v13 = v12[2];
          goto LABEL_35;
        case 8:
          if ((*(_BYTE *)(a1 + 1) & 1) != 0)
          {
            v4 = 0;
            v14 = *(__int128 **)(a1 + 136);
            v10 = *v14;
            v11 = v14[1];
            v13 = v14[2];
            *(_OWORD *)(a3 + 48) = v14[3];
LABEL_35:
            *(_OWORD *)(a3 + 32) = v13;
LABEL_36:
            *(_OWORD *)a3 = v10;
            *(_OWORD *)(a3 + 16) = v11;
          }
          else
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 380, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA512 is not supported");
LABEL_23:
            v4 = 22;
          }
          break;
        default:
          v4 = 22;
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 389, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "Unknown digest_type: %d");
          return v4;
      }
    }
    else
    {
      v4 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 293, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "message_digest is NULL");
    }
  }
  else
  {
    v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 287, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "data_analyzer is NULL");
  }
  return v4;
}

uint64_t BOMCopierMultiCopy()
{
  return 22;
}

uint64_t BOMCopierMultiCopyWithOptions()
{
  return 22;
}

uint64_t volume_has_data_protection(const char *a1)
{
  FILE *v2;
  int *v3;
  char *v4;
  statfs v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  memset(&v6, 0, 512);
  if (!statfs(a1, &v6))
    return LOBYTE(v6.f_flags) >> 7;
  v2 = (FILE *)*MEMORY[0x24BDAC8D8];
  v3 = __error();
  v4 = strerror(*v3);
  fprintf(v2, "Could not statfs %s: %s\n", a1, v4);
  return 0;
}

BOOL set_timestamps_0(const char *a1, __int128 *a2, _OWORD *a3)
{
  __int128 v3;
  _OWORD v5[2];
  __int128 v6;
  uint64_t v7;

  v7 = 0;
  v3 = *a2;
  v5[0] = *a3;
  v5[1] = v3;
  v6 = xmmword_2063D03C8;
  return setattrlist(a1, &v6, v5, 0x20uLL, 1u) != 0;
}

uint64_t _mkdirs_parent(uint64_t a1)
{
  char *v2;
  uint64_t result;
  char __s[1025];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  __strlcpy_chk();
  v2 = strrchr(__s, 47);
  result = 0;
  if (v2)
  {
    if (__s != v2)
    {
      *v2 = 0;
      return _mkdirs(a1, (uint64_t)__s);
    }
  }
  return result;
}

uint64_t _mkdirs(uint64_t a1, uint64_t a2)
{
  char *v3;
  char *v4;
  uint64_t result;
  const char *v6;
  int v7;
  char v8[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return 0xFFFFFFFFLL;
  if (!(*(unsigned int (**)(_QWORD))(*(_QWORD *)(a1 + 12832) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 12832)
                                                                                            + 8)))
  {
    *__error() = 20;
    return 0xFFFFFFFFLL;
  }
  if (*__error() != 2)
    return 0xFFFFFFFFLL;
  __strlcpy_chk();
  v3 = rindex(v8, 47);
  if (!v3 || v3 == v8)
    return (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 168))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v8, 511);
  v4 = v3;
  *v3 = 0;
  result = _mkdirs(a1, v8);
  *v4 = 47;
  if ((_DWORD)result == -1)
    return result;
  v7 = v4[1];
  v6 = v4 + 1;
  if (!v7)
    return 0;
  result = strcmp(v6, ".");
  if ((_DWORD)result)
  {
    result = strcmp(v6, "..");
    if ((_DWORD)result)
      return (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 168))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), v8, 511);
  }
  return result;
}

uint64_t _initGroupList(uint64_t a1)
{
  int v2;

  v2 = getgroups(16, (gid_t *)(a1 + 10500));
  *(_DWORD *)(a1 + 10564) = v2;
  if (v2 == -1)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t _chPerms(uint64_t a1, char *a2, uint64_t a3, _BYTE *a4, int a5)
{
  int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v8 = *(_DWORD *)(a3 + 20);
  v9 = *(unsigned __int16 *)(a3 + 4);
  if ((v9 & 0xF000) == 0x4000)
    v10 = 448;
  else
    v10 = 0;
  if (*(_DWORD *)(a1 + 10496))
  {
    v11 = *(unsigned int *)(a1 + 10564);
    if ((int)v11 >= 1)
    {
      v12 = (int *)(a1 + 10500);
      while (1)
      {
        v13 = *v12++;
        if (v13 == v8)
          break;
        if (!--v11)
          goto LABEL_9;
      }
      v15 = 0xFFFFFFFFLL;
      goto LABEL_16;
    }
LABEL_9:
    v8 = -1;
    v14 = 61951;
    v15 = 0xFFFFFFFFLL;
  }
  else
  {
    v15 = *(unsigned int *)(a3 + 16);
    if (*(_BYTE *)(a1 + 205) == 1)
    {
LABEL_16:
      v14 = 61951;
      goto LABEL_17;
    }
    v14 = 0xFFFF;
    if (*(_BYTE *)(a1 + 209) == 1)
    {
      if (*(_BYTE *)(a1 + 210))
        v14 = 0xFFFF;
      else
        v14 = 61951;
    }
  }
LABEL_17:
  if ((v9 & 0xF000) == 0x8000 && *(_BYTE *)(a1 + 206) == 1)
    v14 &= 0xFFB6u;
  v16 = v9 & v14;
  if (a4 && v10 > ((unsigned __int16)v9 & (unsigned __int16)v14 & 0x1C0u))
  {
    *(_WORD *)(a3 + 4) = v9 & v14;
    v16 = v16 | v10;
    *a4 = 1;
  }
  if (a5
    && (v15 & v8) != 0xFFFFFFFF
    && (*(unsigned int (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 192))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v15)&& (*__error() == 45 || *__error() == 1 && (v16 & 0xF000) == 0xA000))
  {
    *__error() = 0;
  }
  if ((v16 & 0xF000) == 0xA000)
    return lchmod(a2, v16);
  v18 = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 200))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v16);
  if ((_DWORD)v18)
  {
    if (*__error() == 45)
    {
      v18 = 0;
      *__error() = 0;
    }
  }
  return v18;
}

uint64_t _makeDestDir(uint64_t a1, char *a2, int a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  char *v10;
  char __s[1024];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    result = _mkdirs(a1, (uint64_t)a2);
    if ((_DWORD)result)
      return result;
    return _chPerms(a1, a2, a4, a5, 1);
  }
  v10 = rindex(a2, 47);
  if (!v10
    || strcmp(v10, "/.")
    || (__strlcpy_chk(),
        __s[strlen(__s) - 2] = 0,
        result = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 168))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), __s, 511), !(_DWORD)result))
  {
    result = (*(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(a1 + 12832) + 168))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, 511);
    if (!(_DWORD)result)
      return _chPerms(a1, a2, a4, a5, 1);
  }
  return result;
}

uint64_t _filterFatArchs(uint64_t a1, unsigned int a2, _DWORD *a3, _QWORD *a4)
{
  void *v8;
  uint64_t v9;
  _DWORD *v10;
  unint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  int v15;
  _DWORD *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  _DWORD *v22;
  int *v23;
  int v24;
  unsigned int v25;
  uint64_t v26;

  v8 = 0;
  v9 = 0;
  *a4 = 0;
  v10 = 0;
  if (a1 && a2)
  {
    v11 = 0;
    v12 = 0;
    v8 = 0;
    v13 = 0;
    do
    {
      v14 = 0;
      v10 = (_DWORD *)(a1 + 20 * v11);
      while (1)
      {
        v15 = a3[8 * v14];
        if (v15 == -1)
          break;
        if (!v15)
        {
          v9 = v13;
          v10 = v12;
          goto LABEL_17;
        }
        if (*v10 == v15)
        {
          v16 = &a3[8 * v14];
          if (*((_BYTE *)v16 + 4) || ((v16[2] ^ v10[1]) & 0xFFFFFF) == 0)
            break;
        }
        ++v14;
      }
      if ((_DWORD)v13)
      {
        v9 = (v13 + 1);
        v8 = BOM_realloc(v8, 8 * (int)v9);
        if (!v8)
          goto LABEL_41;
      }
      else
      {
        v8 = BOM_malloczero(8uLL);
        v9 = 1;
        if (!v8)
          goto LABEL_41;
      }
      *((_QWORD *)v8 + (int)v13) = v10;
      v12 = (_DWORD *)(a1 + 20 * v11);
      v13 = v9;
LABEL_17:
      ++v11;
    }
    while (v11 < a2);
  }
  if (a2 && !v10 && a1)
  {
    v17 = 0;
    v18 = a2;
    do
    {
      if (*a3)
      {
        v19 = 0;
        v20 = 0;
        v21 = a1 + 20 * v17;
        while (1)
        {
          v22 = &a3[8 * v19];
          v23 = (int *)*((_QWORD *)v22 + 2);
          if (v23 && v22[6] && (v24 = *v23) != 0)
          {
            v25 = 1;
            while (*(_DWORD *)(v21 + 4) != v24)
            {
              v24 = v23[v25++];
              if (!v24)
                goto LABEL_30;
            }
            if ((_DWORD)v9)
            {
              v26 = (v9 + 1);
              v8 = BOM_realloc(v8, 8 * (int)v26);
              if (!v8)
                goto LABEL_42;
            }
            else
            {
              v8 = BOM_malloczero(8uLL);
              v26 = 1;
              if (!v8)
                goto LABEL_42;
            }
            *((_QWORD *)v8 + (int)v9) = v21;
          }
          else
          {
LABEL_30:
            v26 = v9;
          }
          v19 = ++v20;
          v9 = v26;
          if (!a3[8 * v19])
            goto LABEL_39;
        }
      }
      v26 = v9;
LABEL_39:
      ++v17;
      v9 = v26;
    }
    while (v17 < v18);
  }
  else
  {
LABEL_41:
    v26 = v9;
  }
LABEL_42:
  *a4 = v8;
  return v26;
}

uint64_t _determine_thin_type_and_archs(uint64_t a1, unsigned int a2, _DWORD *a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, int a7)
{
  int v11;
  int v12;
  uint64_t result;
  _OWORD v14[4];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  memset(v14, 0, sizeof(v14));
  LODWORD(v14[0]) = -1;
  BYTE4(v14[0]) = 1;
  *a4 = 0;
  *a5 = 0;
  if (!a1 || !a2)
    goto LABEL_9;
  if (a3)
    goto LABEL_6;
  if (!a7)
  {
LABEL_9:
    result = 0;
    *a6 = 0;
    return result;
  }
  a3 = v14;
LABEL_6:
  v11 = _filterFatArchs(a1, a2, a3, a4);
  if (!v11)
    return 1;
  v12 = v11;
  if (!a7 && v11 == a2)
    goto LABEL_9;
  if (v11 == 1)
  {
    result = 0;
    *a6 = 1;
  }
  else
  {
    result = 0;
    *a6 = 2;
  }
  *a5 = v12;
  return result;
}

void *_sortFatArchsByOffset(void *result, int a2)
{
  if (result)
  {
    if (a2)
      return (void *)mergesort(result, a2, 8uLL, (int (__cdecl *)(const void *, const void *))_compareFatArchsByOffset);
  }
  return result;
}

uint64_t _compareFatArchsByOffset(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_DWORD *)(*(_QWORD *)a1 + 8);
  v3 = *(_DWORD *)(*(_QWORD *)a2 + 8);
  v4 = v2 >= v3;
  v5 = v2 > v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

double _createNewFatArchArray(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  double *v4;
  uint64_t v5;
  uint64_t v6;
  double result;
  uint64_t v8;
  uint64_t v9;

  if (a2 >= 1)
  {
    v4 = (double *)(a3 + 12);
    v5 = a2;
    do
    {
      v6 = *a1++;
      *(double *)((char *)v4 - 12) = *(double *)v6;
      result = *(double *)(v6 + 12);
      *v4 = result;
      v8 = *(unsigned int *)(v6 + 12);
      v9 = (a4 + (1 << *(_DWORD *)(v6 + 16)) - 1) & (0xFFFFFFFFLL << *(_DWORD *)(v6 + 16));
      *((_DWORD *)v4 - 1) = v9;
      a4 = v9 + v8;
      v4 = (double *)((char *)v4 + 20);
      --v5;
    }
    while (v5);
  }
  return result;
}

size_t _normalizeBomCopySpecification(uint64_t a1, unsigned int a2, unsigned int a3, size_t *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  int v11;
  uint64_t v12;
  BOOL v13;
  int v14;
  size_t result;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  _QWORD *v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  size_t v30;
  size_t v31;

  v6 = *(unsigned int *)(a1 + 48);
  v7 = a3;
  v8 = a2;
  if ((int)v6 < 1)
  {
    v9 = 0;
  }
  else
  {
    v9 = 0;
    v10 = (_QWORD *)(a1 + 64);
    do
    {
      switch(*((_DWORD *)v10 - 2))
      {
        case 0:
          v12 = *v10 % (uint64_t)a2;
          v13 = *v10 < (uint64_t)a2;
          goto LABEL_8;
        case 1:
        case 3:
        case 4:
          v11 = 1;
          break;
        case 2:
          v12 = *v10 % (uint64_t)a3;
          v13 = *v10 < (uint64_t)a3;
LABEL_8:
          v11 = !v13;
          if (v13)
            v14 = 1;
          else
            v14 = 2;
          if (v12)
            v11 = v14;
          break;
        default:
          v11 = 0;
          break;
      }
      v10 += 7;
      v9 += v11;
      --v6;
    }
    while (v6);
  }
  result = (size_t)BOM_calloc(56 * v9 + 56, 1uLL);
  v16 = result;
  *(_QWORD *)result = *(_QWORD *)a1;
  *(_QWORD *)(result + 8) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(result + 32) = v17;
  *(_QWORD *)(result + 40) = *(_QWORD *)(a1 + 40);
  *(_DWORD *)(result + 48) = v9;
  if (*(int *)(a1 + 48) >= 1)
  {
    v18 = 0;
    v19 = 0;
    v20 = *(_QWORD *)(a1 + 16);
    v21 = (_QWORD *)(a1 + 96);
    while (2)
    {
      if (*((_DWORD *)v21 - 6) <= 1u)
        v22 = 1;
      else
        v22 = *((_DWORD *)v21 - 6);
      v23 = *((_DWORD *)v21 - 10);
      v24 = 0;
      result = 0;
      v25 = *(v21 - 2);
      v26 = *v21;
      v27 = *(v21 - 4) * v22;
      switch(v23)
      {
        case 0:
          result = v27 / v8;
          v24 = v27 % v8;
          if (v27 != v27 % v8)
          {
            v28 = v16 + 56 * v19;
            *(_DWORD *)(v28 + 56) = 0;
            *(_QWORD *)(v28 + 64) = v8;
            *(_DWORD *)(v28 + 72) = result;
            *(_QWORD *)(v28 + 80) = v25;
            *(_QWORD *)(v28 + 88) = 0;
            *(_QWORD *)(v28 + 96) = v26;
            *(_QWORD *)(v28 + 104) = v20;
            ++v19;
          }
          if (v24)
          {
            result = 0;
            v26 = v27 + v26 - v24;
            goto LABEL_34;
          }
          goto LABEL_35;
        case 1:
          result = *(v21 - 1);
          v24 = v27;
          goto LABEL_34;
        case 2:
          result = v27 / v7;
          v24 = v27 % v7;
          v29 = v27 - v27 % v7;
          if (v29)
          {
            v30 = v16 + 56 * v19;
            *(_DWORD *)(v30 + 56) = 2;
            *(_QWORD *)(v30 + 64) = v7;
            *(_DWORD *)(v30 + 72) = result;
            *(_QWORD *)(v30 + 80) = v25;
            *(_QWORD *)(v30 + 88) = 0;
            *(_QWORD *)(v30 + 96) = v26;
            *(_QWORD *)(v30 + 104) = v20;
            ++v19;
          }
          if (!v24)
            goto LABEL_35;
          result = 0;
          v25 += v29;
          v26 += v29;
LABEL_34:
          v31 = v16 + 56 * v19;
          *(_DWORD *)(v31 + 56) = v23;
          *(_QWORD *)(v31 + 64) = v24;
          *(_DWORD *)(v31 + 72) = 1;
          *(_QWORD *)(v31 + 80) = v25;
          *(_QWORD *)(v31 + 88) = result;
          *(_QWORD *)(v31 + 96) = v26;
          *(_QWORD *)(v31 + 104) = v20;
          ++v19;
LABEL_35:
          v21 += 7;
          if (++v18 >= *(int *)(a1 + 48))
            goto LABEL_38;
          continue;
        case 3:
        case 4:
          goto LABEL_34;
        default:
          goto LABEL_35;
      }
    }
  }
  v19 = 0;
LABEL_38:
  if (v19 != v9)
    result = fwrite("BOMCopier: Inconsistency while preflighting copy\n", 0x31uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  *a4 = v16;
  return result;
}

uint64_t _printBomCopySpecification(const void **a1)
{
  uint64_t result;
  uint64_t v3;
  const void **v4;
  const char *v5;

  printf("_BOMCopySpecification %p:\n", a1);
  printf("\tcopier:\t%p\n", *a1);
  printf("\tsource:\t%p\n", a1[1]);
  printf("\tdest:\t%p\n", a1[2]);
  printf("\toriginalSourceSize:\t%lld\n", a1[4]);
  printf("\ttotalDestinationSize:\t%lld\n", a1[5]);
  printf("\tnumSteps:\t%d\n", *((_DWORD *)a1 + 12));
  result = puts("-------------------");
  if (*((int *)a1 + 12) >= 1)
  {
    v3 = 0;
    v4 = a1 + 11;
    do
    {
      result = printf("Step %d:\n", v3);
      switch(*((_DWORD *)v4 - 8))
      {
        case 0:
          v5 = "_BOMCopyStepZero";
          goto LABEL_7;
        case 1:
          printf("\ttype:\t%s\n", "_BOMCopyStepBuffer");
          printf("\tsize:\t%lld\n", *(v4 - 3));
          printf("\tbuffer:\t%p\n");
          goto LABEL_9;
        case 2:
          v5 = "_BOMCopyStepCopy";
LABEL_7:
          printf("\ttype:\t%s\n", v5);
          printf("\tsize:\t%lld\n", *(v4 - 3));
          printf("\titerationCount:\t%d\n");
          goto LABEL_9;
        case 3:
          printf("\ttype:\t%s\n");
LABEL_9:
          printf("\tsourceOffset:\t%lld\n", *(v4 - 1));
          result = printf("\tdestOffset:\t%lld\n");
          break;
        case 4:
          printf("\ttype:\t%s\n", "_BOMCopyStepSeekToEndOfSource");
          result = printf("\tsourceOffset:\t%lld\n");
          break;
        default:
          break;
      }
      v4 += 7;
      ++v3;
    }
    while (v3 < *((int *)a1 + 12));
  }
  return result;
}

uint64_t _executeBomCopySpecification(int *a1, unsigned int a2, unsigned int a3, unsigned int *a4, uint64_t a5, uint64_t a6)
{
  _DWORD *v8;
  uLong v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  _DWORD *v23;
  int v24;
  int v25;
  uint64_t *v26;
  CFIndex v27;
  CFIndex *v28;
  CFIndex v29;
  CFIndex v30;
  void (*v31)(uint64_t, _QWORD, uint64_t);
  uint64_t *v32;
  uint64_t *v33;
  CFIndex v34;
  CFIndex v35;
  CFIndex v36;
  void (*v37)(uint64_t, _QWORD, uint64_t);
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  unint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  CFIndex v45;
  unint64_t v46;
  CFIndex v47;
  unint64_t v48;
  void (*v49)(uint64_t, _QWORD, uint64_t);
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  CFIndex v53;
  CFIndex v54;
  uint64_t v55;
  void (*v56)(uint64_t, _QWORD, uint64_t);
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  int *v61;
  uint64_t v62;
  uint64_t (*v63)(uint64_t, uint64_t, uint64_t);
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int *v67;
  unsigned int v68;
  int *v69;
  uint64_t (*v70)(uint64_t, uint64_t, uint64_t);
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int *v74;
  unsigned int v75;
  uint64_t v77;
  int *v78;
  int64_t v79;
  uint64_t v80;
  uint64_t v81;
  _DWORD *v82;
  uLong crc;
  UInt8 *v84;
  char *buf;

  v8 = a4;
  if (a4)
    v11 = *a4;
  else
    v11 = 0;
  if (!a1)
  {
    v14 = 22;
    goto LABEL_124;
  }
  v84 = (UInt8 *)BOM_calloc(a2, 1uLL);
  if (!v84)
  {
    v14 = 12;
    goto LABEL_124;
  }
  v12 = *(_QWORD *)a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 3328))
    v13 = v12 + 3328;
  else
    v13 = *(_QWORD *)(v12 + 2296);
  v81 = *(_QWORD *)a1;
  v82 = v8;
  buf = *(char **)(v12 + 8);
  v15 = (int *)*((_QWORD *)a1 + 1);
  crc = v11;
  if (a5)
  {
    v16 = CNCRCInit();
    if ((_DWORD)v16)
    {
      v14 = v16;
      goto LABEL_123;
    }
  }
  if (a1[12] < 1)
  {
    v14 = 0;
    goto LABEL_123;
  }
  v77 = v13;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v79 = a3;
  v80 = a5;
  while (2)
  {
    v20 = (uint64_t *)&a1[14 * v17];
    v21 = v20[13];
    if (!v21)
      v21 = *((_QWORD *)a1 + 2);
    switch(*((_DWORD *)v20 + 14))
    {
      case 0:
        v22 = (uint64_t *)&a1[14 * v17];
        v24 = *((_DWORD *)v22 + 18);
        v23 = v22 + 9;
        if (v24 >= 1)
        {
          v25 = 0;
          v26 = (uint64_t *)&a1[14 * v17];
          v29 = v26[8];
          v28 = v26 + 8;
          v27 = v29;
          do
          {
            v30 = BOMFileWrite(v21, v84, v27);
            if (v30 != *v28)
              goto LABEL_114;
            v27 = v30;
            if (v82)
            {
              crc = crc32(crc, v84, v30);
              v27 = *v28;
            }
            if (a5)
            {
              CNCRCUpdate();
              v27 = *v28;
            }
            v18 += v27;
            ++v25;
          }
          while (v25 < *v23);
        }
        v31 = *(void (**)(uint64_t, _QWORD, uint64_t))(v81 + 104);
        if (!v31)
          goto LABEL_37;
        v31(v81, *((_QWORD *)a1 + 3), v18);
        if (!*(_BYTE *)(v81 + 168))
          goto LABEL_37;
        goto LABEL_127;
      case 1:
        v32 = (uint64_t *)&a1[14 * v17];
        v34 = v32[8];
        v33 = v32 + 8;
        v35 = BOMFileWrite(v21, (UInt8 *)v33[3], v34);
        if (v35 != *v33)
          goto LABEL_114;
        v36 = v35;
        if (v82)
        {
          crc = crc32(crc, (const Bytef *)v33[3], v35);
          v36 = *v33;
        }
        if (a5)
        {
          CNCRCUpdate();
          v36 = *v33;
        }
        v18 += v36;
        v37 = *(void (**)(uint64_t, _QWORD, uint64_t))(v81 + 104);
        if (v37)
        {
          v37(v81, *((_QWORD *)a1 + 3), v18);
          if (*(_BYTE *)(v81 + 168))
            goto LABEL_127;
        }
LABEL_37:
        v14 = 0;
        goto LABEL_97;
      case 2:
        v38 = (uint64_t *)&a1[14 * v17];
        v40 = v38[10];
        v39 = v38 + 10;
        if (v40 <= a6)
          goto LABEL_41;
        if (BOMFileSeek() < 0)
        {
LABEL_114:
          v74 = __error();
          v43 = v81;
          v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
          if (v70)
          {
LABEL_115:
            v71 = *v74;
            v72 = v43;
            v73 = v77;
LABEL_116:
            v75 = v70(v72, v73, v71);
            if (v75 == 1)
            {
              v75 = 0;
LABEL_120:
              if (*(_BYTE *)(v43 + 168))
                v14 = 2;
              else
                v14 = v75;
              goto LABEL_123;
            }
            if (v75)
              goto LABEL_120;
          }
          goto LABEL_118;
        }
        a6 = *v39;
LABEL_41:
        v78 = &a1[14 * v17 + 18];
        if (*v78 >= 1)
        {
          v41 = 0;
          v42 = (unint64_t *)&a1[14 * v17 + 16];
          while (1)
          {
            v43 = v81;
            v44 = *v42;
            if (*(_DWORD *)(v81 + 12776))
            {
              v45 = 0;
              while (1)
              {
                v46 = BOMFileRead(v15, buf, v44 - v45);
                if ((v46 & 0x8000000000000000) != 0)
                  goto LABEL_111;
                v45 += v46;
                if (!BOMFileEndOfCompressionStream((_BOOL8)v15))
                {
                  v44 = *v42;
                  if (v45 != *v42)
                    continue;
                }
                goto LABEL_50;
              }
            }
            v45 = BOMFileRead(v15, buf, v44);
LABEL_50:
            if (v45 != *v42)
              goto LABEL_111;
            v47 = BOMFileWrite(v21, (UInt8 *)buf, v45);
            if (v47 != *v42)
              break;
            v48 = v47;
            if (v82)
            {
              crc = crc32(crc, (const Bytef *)buf, v47);
              v48 = *v42;
            }
            if (v80)
            {
              CNCRCUpdate();
              v48 = *v42;
            }
            v18 += v48;
            v49 = *(void (**)(uint64_t, _QWORD, uint64_t))(v81 + 104);
            if (v49)
            {
              v49(v81, *((_QWORD *)a1 + 3), v18);
              if (*(_BYTE *)(v81 + 168))
              {
                v14 = 2;
                goto LABEL_123;
              }
            }
            v14 = 0;
            a6 += v45;
            if (++v41 >= *v78)
              goto LABEL_97;
          }
          v74 = __error();
          v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
          if (v70)
            goto LABEL_115;
          goto LABEL_118;
        }
        goto LABEL_96;
      case 3:
        v50 = *((_QWORD *)a1 + 4);
        v51 = v50 - a6;
        if (v50 - a6 >= v79)
          v51 = v79;
        if (v50 == -1)
          v52 = v79;
        else
          v52 = v51;
        v14 = v19;
        if (!v52)
          goto LABEL_97;
        while (2)
        {
          if ((*(_DWORD *)(v81 + 12776) || *(_BYTE *)(v81 + 12796))
            && *(_BYTE *)(v81 + 12769)
            && BOMFileEndOfCompressionStream((_BOOL8)v15))
          {
            goto LABEL_96;
          }
          v53 = BOMFileRead(v15, buf, v52);
          if (v53 < 0 || (v54 = v53, v55 = *((_QWORD *)a1 + 4), v52 != v53) && v55 != -1)
          {
            v61 = __error();
            v62 = v81;
            v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
            if (!v63)
              goto LABEL_105;
            v64 = *v61;
            v65 = v81;
            v66 = v81 + 248;
LABEL_103:
            v68 = v63(v65, v66, v64);
            if (v68 == 1)
            {
              v68 = 0;
LABEL_107:
              if (*(_BYTE *)(v62 + 168))
                v14 = 2;
              else
                v14 = v68;
              goto LABEL_97;
            }
            if (v68)
              goto LABEL_107;
LABEL_105:
            v68 = 1;
            goto LABEL_107;
          }
          a6 += v53;
          if (!v53 && v55 == -1)
            goto LABEL_96;
          if (BOMFileWrite(v21, (UInt8 *)buf, v53) != v53)
          {
            v67 = __error();
            v62 = v81;
            v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
            if (!v63)
              goto LABEL_105;
            v64 = *v67;
            v65 = v81;
            v66 = v77;
            goto LABEL_103;
          }
          if (v82)
            crc = crc32(crc, (const Bytef *)buf, v54);
          if (v80)
            CNCRCUpdate();
          v18 += v54;
          v56 = *(void (**)(uint64_t, _QWORD, uint64_t))(v81 + 104);
          if (!v56 || (v56(v81, *((_QWORD *)a1 + 3), v18), !*(_BYTE *)(v81 + 168)))
          {
            v19 = 0;
            v14 = 0;
            v57 = *((_QWORD *)a1 + 4);
            v58 = v57 - a6;
            if (v57 - a6 >= v79)
              v58 = v79;
            if (v57 == -1)
              v52 = v79;
            else
              v52 = v58;
            if (!v52)
              goto LABEL_97;
            continue;
          }
          break;
        }
LABEL_127:
        v14 = 2;
LABEL_123:
        free(v84);
        v8 = v82;
        LODWORD(v11) = crc;
LABEL_124:
        if (v8)
          *v8 = v11;
        return v14;
      case 4:
        v59 = *((_QWORD *)a1 + 4);
        if (v59 == -1)
        {
          v43 = v81;
          if (!BOMFileEndOfCompressionStream((_BOOL8)v15))
          {
            while (1)
            {
              v60 = BOMFileRead(v15, buf, v79);
              if ((v60 & 0x8000000000000000) != 0)
                break;
              a6 += v60;
              if (BOMFileEndOfCompressionStream((_BOOL8)v15))
                goto LABEL_96;
            }
LABEL_111:
            v69 = __error();
LABEL_112:
            v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v43 + 72);
            if (v70)
            {
              v71 = *v69;
              v72 = v43;
              v73 = v81 + 248;
              goto LABEL_116;
            }
LABEL_118:
            v75 = 1;
            goto LABEL_120;
          }
        }
        else if (v59 > a6)
        {
          if (BOMFileSeek() < 0)
          {
            v69 = __error();
            v43 = v81;
            goto LABEL_112;
          }
          a6 = *((_QWORD *)a1 + 4);
        }
LABEL_96:
        v14 = v19;
LABEL_97:
        ++v17;
        v19 = v14;
        a5 = v80;
        if (v17 >= a1[12])
          goto LABEL_123;
        continue;
      default:
        goto LABEL_96;
    }
  }
}

uint64_t _checkCopyFileError(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);
  uint64_t result;

  v2 = *(uint64_t (**)(uint64_t))(a1 + 72);
  if (!v2)
  {
LABEL_4:
    LODWORD(result) = 1;
    goto LABEL_6;
  }
  LODWORD(result) = v2(a1);
  if ((_DWORD)result != 1)
  {
    if ((_DWORD)result)
      goto LABEL_6;
    goto LABEL_4;
  }
  LODWORD(result) = 0;
LABEL_6:
  if (*(_BYTE *)(a1 + 168))
    return 2;
  else
    return result;
}

uint64_t _checkCopyFileConflictError(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(a1 + 80);
  if (v1)
    return v1();
  else
    return 0;
}

uint64_t _ignore_readdir_entry(uint64_t a1)
{
  unsigned int v1;
  const char *v2;
  const char *v3;
  size_t v4;
  const char *v5;

  v1 = *(unsigned __int16 *)(a1 + 18);
  if (v1 == 2)
  {
    v2 = (const char *)(a1 + 21);
    v3 = "..";
    v4 = 2;
    return !strncmp(v3, v2, v4);
  }
  if (v1 == 1)
    return *(_BYTE *)(a1 + 21) == 46;
  if (v1 < 4)
    return 0;
  v5 = (const char *)(a1 + 21);
  if (strncmp(".nfs", (const char *)(a1 + 21), 4uLL))
  {
    if (v1 < 0xB)
      return 0;
    v3 = ".afpDeleted";
    v2 = v5;
    v4 = 11;
    return !strncmp(v3, v2, v4);
  }
  return 1;
}

BOOL _sanitizePath(char *cStr, uint64_t a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  CFStringEncoding v10;
  const __CFAllocator *v11;
  CFStringRef v12;
  const __CFString *v13;
  CFStringEncoding SystemEncoding;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *MutableCopy;
  CFIndex Count;
  CFIndex v19;
  uint64_t i;
  CFIndex v21;
  uint64_t v22;
  CFIndex v23;
  const void *ValueAtIndex;
  int CString;
  CFStringRef v26;
  const __CFAllocator *alloc;
  CFStringEncoding v28;

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = cStr[v3];
    switch(v4)
    {
      case 0:
        if (v7 == 47)
          v4 = 0;
        else
          v4 = 3;
        if (v7 == 46)
          v4 = 1;
        break;
      case 1:
        if (v7 == 47)
          v4 = 0;
        else
          v4 = 3;
        if (v7 == 46)
          v4 = 2;
        break;
      case 2:
        if (v7 == 47)
          v8 = 1;
        else
          v8 = v5;
        if (v7 == 47)
          v9 = 0;
        else
          v9 = 3;
        if (cStr[v3])
          v5 = v8;
        else
          v5 = 1;
        if (cStr[v3])
          v4 = v9;
        else
          v4 = 0;
        break;
      case 3:
        if (v7 == 47)
          v4 = 0;
        else
          v4 = 3;
        break;
      default:
        break;
    }
    v6 |= cStr[v3++] < 0;
  }
  while (a2 + 1 != v3);
  if (((v6 | v5) & 1) == 0)
    return 0;
  v10 = 134217984;
  v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], cStr, 0x8000100u);
  if (v12)
  {
    v13 = v12;
    if ((v5 & 1) == 0)
      goto LABEL_54;
    goto LABEL_38;
  }
  SystemEncoding = CFStringGetSystemEncoding();
  v13 = CFStringCreateWithCString(v11, cStr, SystemEncoding);
  if (v13)
  {
    if ((v5 & 1) == 0)
    {
LABEL_54:
      CString = CFStringGetCString(v13, cStr, 1024, v10);
      CFRelease(v13);
      return CString == 0;
    }
LABEL_38:
    v28 = v10;
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v11, v13, CFSTR("/"));
    alloc = v11;
    MutableCopy = CFArrayCreateMutableCopy(v11, 0, ArrayBySeparatingStrings);
    CFRelease(v13);
    CFRelease(ArrayBySeparatingStrings);
    Count = CFArrayGetCount(MutableCopy);
    if (Count >= 1)
    {
      v19 = Count;
      for (i = 0; i != v19; ++i)
      {
        v21 = CFArrayGetCount(MutableCopy);
        if (v21 >= 1)
        {
          v22 = v21;
          v23 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, v23);
            if (CFEqual(ValueAtIndex, CFSTR("..")))
              break;
            if (v23 && (CFEqual(ValueAtIndex, CFSTR(".")) || CFEqual(ValueAtIndex, &stru_24BF08698)))
              goto LABEL_51;
            if (v22 == ++v23)
              goto LABEL_52;
          }
          CFArrayRemoveValueAtIndex(MutableCopy, v23);
          if (v22 >= 2)
          {
            if (v23)
            {
              --v23;
LABEL_51:
              CFArrayRemoveValueAtIndex(MutableCopy, v23);
              continue;
            }
          }
        }
LABEL_52:
        ;
      }
    }
    v13 = CFStringCreateByCombiningStrings(alloc, MutableCopy, CFSTR("/"));
    CFRelease(MutableCopy);
    v10 = v28;
    goto LABEL_54;
  }
  v26 = CFStringCreateWithCString(v11, cStr, 0x600u);
  if (v26)
  {
    v13 = v26;
    v10 = 3071;
    if ((v5 & 1) == 0)
      goto LABEL_54;
    goto LABEL_38;
  }
  return 1;
}

char *_parse_arch_list(uint64_t a1, CFArrayRef theArray, const __CFDictionary *a3, _DWORD *a4, void **a5)
{
  CFIndex Count;
  int v11;
  uint64_t v12;
  char *v13;
  void *v14;
  CFIndex v15;
  const __CFString *ValueAtIndex;
  const __CFString *v17;
  CFTypeID TypeID;
  char *UTF8String;
  char *v20;
  char **v21;
  int v22;
  char **v23;
  int v24;
  int v25;
  BOOL v26;
  int v27;
  char v28;
  int v29;
  BOOL v31;
  int v32;
  char v33;
  int v34;
  char *v35;
  _QWORD *v36;
  unsigned int *v37;
  const __CFDictionary *v38;
  const __CFArray *Value;
  const __CFArray *v40;
  CFTypeID v41;
  CFIndex v42;
  unsigned int v43;
  uint64_t v44;
  const __CFString *v45;
  const __CFString *v46;
  CFTypeID v47;
  char *v48;
  char *v49;
  char **v50;
  char **v51;
  void (*v52)(uint64_t, char *);
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  _DWORD *v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  char *v62;
  void **v63;
  char __str[2048];
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  Count = CFArrayGetCount(theArray);
  v11 = Count;
  if (!(_DWORD)Count)
  {
    v52 = *(void (**)(uint64_t, char *))(a1 + 56);
    if (v52)
    {
      strcpy(__str, "archs array is empty");
      v52(a1, __str);
    }
    return 0;
  }
  *a4 = Count;
  v12 = (Count << 32) + 0x100000000;
  v13 = (char *)BOM_malloczero(v12 >> 27);
  if (!v13)
    return v13;
  v14 = BOM_malloczero(v12 >> 29);
  *a5 = v14;
  if (!v14)
  {
    free(v13);
    return 0;
  }
  if (v11 < 1)
    return v13;
  v58 = a1;
  v62 = v13;
  v63 = a5;
  v15 = 0;
  v61 = v11;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v15);
    if (!ValueAtIndex || (v17 = ValueAtIndex, TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v17)))
    {
      v54 = v58;
      if (*(_QWORD *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't read arch #%d from archs list");
LABEL_65:
        (*(void (**)(uint64_t, char *))(v54 + 56))(v54, __str);
      }
LABEL_66:
      free(*v63);
      free(v13);
      v13 = 0;
      *a4 = 0;
      return v13;
    }
    UTF8String = (char *)BOMCFStringGetUTF8String(v17);
    if (!UTF8String)
    {
      v54 = v58;
      if (*(_QWORD *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't convert arch #%d from archs listinto UTF8 encoded C string");
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    v20 = UTF8String;
    v21 = BOMGetArchInfoFromName(UTF8String);
    if (!v21 || (v22 = *((_DWORD *)v21 + 3), (v23 = BOMGetArchInfoFromCpuType(*((_DWORD *)v21 + 2), -1)) == 0))
    {
      if (*(_QWORD *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't get arch info for '%s'", v20);
        (*(void (**)(uint64_t, char *))(v58 + 56))(v58, __str);
      }
      free(v20);
      goto LABEL_66;
    }
    v25 = *((_DWORD *)v23 + 2);
    v24 = *((_DWORD *)v23 + 3);
    v26 = v25 == 16777228 && v22 == 0;
    if (v26)
      v27 = 16777228;
    else
      v27 = *((_DWORD *)v23 + 2);
    v28 = !v26;
    if (v26)
      v29 = v22;
    else
      v29 = -1;
    if (v25 == 16777223 && v22 == 3)
    {
      v27 = 16777223;
      v28 = 0;
      v29 = v22;
    }
    v31 = v22 == v24;
    v32 = v22 == v24 ? v27 : *((_DWORD *)v23 + 2);
    v33 = v31 ? v28 : 0;
    v34 = v31 ? v29 : v22;
    v35 = &v13[32 * v15];
    *(_DWORD *)v35 = v32;
    v35[4] = v33;
    *((_QWORD *)v35 + 2) = 0;
    v36 = v35 + 16;
    *((_DWORD *)v35 + 2) = v34;
    *((_DWORD *)v35 + 6) = 0;
    v37 = (unsigned int *)(v35 + 24);
    *((_QWORD *)*v63 + v15) = v20;
    v38 = a3;
    if (a3)
    {
      Value = (const __CFArray *)CFDictionaryGetValue(a3, v17);
      if (Value)
      {
        v40 = Value;
        v41 = CFArrayGetTypeID();
        if (v41 == CFGetTypeID(v40))
        {
          v42 = CFArrayGetCount(v40);
          v43 = v42;
          if ((_DWORD)v42)
            break;
        }
      }
    }
LABEL_49:
    ++v15;
    a3 = v38;
    v13 = v62;
    if (v15 == v61)
      return v13;
  }
  v60 = (char *)BOM_malloczero((4 * v42 + 4) & 0x3FFFFFFFCLL);
  if (!v60)
    return 0;
  v56 = v43;
  v57 = a4;
  v44 = 0;
  v59 = 4 * v43;
  while (1)
  {
    v45 = (const __CFString *)CFArrayGetValueAtIndex(v40, v15);
    if (!v45 || (v46 = v45, v47 = CFStringGetTypeID(), v47 != CFGetTypeID(v46)))
    {
      v55 = v58;
      if (!*(_QWORD *)(v58 + 56))
        goto LABEL_73;
      snprintf(__str, 0x800uLL, "can't read fallback arch #%d from fallback archs list");
LABEL_69:
      (*(void (**)(uint64_t, char *))(v55 + 56))(v55, __str);
      goto LABEL_73;
    }
    v48 = (char *)BOMCFStringGetUTF8String(v46);
    if (!v48)
    {
      v55 = v58;
      if (!*(_QWORD *)(v58 + 56))
        goto LABEL_73;
      snprintf(__str, 0x800uLL, "can't convert fallback arch #%d from fallback archs listinto UTF8 encoded C string");
      goto LABEL_69;
    }
    v49 = v48;
    v50 = BOMGetArchInfoFromName(v48);
    if (!v50)
      break;
    v51 = v50;
    free(v49);
    *(_DWORD *)&v60[v44] = *((_DWORD *)v51 + 3);
    v44 += 4;
    if (v59 == v44)
    {
      *v36 = v60;
      a4 = v57;
      *v37 = v56;
      goto LABEL_49;
    }
  }
  if (*(_QWORD *)(v58 + 56))
  {
    snprintf(__str, 0x800uLL, "can't get arch info for '%s'", v49);
    (*(void (**)(uint64_t, char *))(v58 + 56))(v58, __str);
  }
  free(v49);
LABEL_73:
  free(v60);
  free(v20);
  free(*v63);
  free(v62);
  v13 = 0;
  *v57 = 0;
  return v13;
}

_DWORD *_BOMFreeListAllocate(const __CFDictionary *a1)
{
  const __CFString *Value;
  const __CFString *v2;
  CFTypeID v3;
  const __CFString *v4;
  const __CFString *v5;
  _QWORD *v7;
  _QWORD *v8;
  char *v9;
  const char *v10;
  pid_t v11;
  int v12;
  FILE *v13;
  FILE *v14;
  _QWORD *v15;
  _QWORD *v16;
  char __str[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a1 && (Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("Implementation"))) != 0)
  {
    v2 = Value;
    v3 = CFGetTypeID(Value);
    if (v3 == CFStringGetTypeID())
      v4 = v2;
    else
      v4 = 0;
  }
  else
  {
    v4 = 0;
  }
  if (v4)
    v5 = v4;
  else
    v5 = CFSTR("dense");
  if (CFEqual(v5, CFSTR("dense")))
    return _BOMFreeListAllocateDense();
  if (!CFEqual(v5, CFSTR("dense+trace")))
    _BOMFreeListAllocate_cold_1();
  v7 = BOM_malloc(0x48uLL);
  if (!v7)
    _BOMFreeListAllocate_cold_2(0);
  v8 = v7;
  v7[2] = _densetrace_initialize;
  v7[3] = _densetrace_serialize;
  v7[4] = _densetrace_deallocate;
  v7[5] = _densetrace_addFreeRange;
  v7[6] = _densetrace_allocateRange;
  v7[7] = _densetrace_clear;
  v7[8] = _densetrace_print;
  v9 = getenv("TMPDIR");
  if (v9)
    v10 = v9;
  else
    v10 = "/tmp";
  v11 = getpid();
  v12 = _BOMFreeListAllocateDenseTrace_objnumber++;
  snprintf(__str, 0x400uLL, "%s/bomfreelist.trace.%d.%d.txt", v10, v11, v12);
  v13 = fopen(__str, "w");
  if (!v13)
    _BOMFreeListAllocate_cold_3(0);
  v14 = v13;
  v15 = BOM_malloc(0x18uLL);
  if (!v15)
    _BOMFreeListAllocate_cold_4(0);
  v16 = v15;
  *v15 = _BOMFreeListAllocateDense();
  *((_DWORD *)v16 + 2) = 1;
  v16[2] = v14;
  *v8 = v16;
  *((_DWORD *)v8 + 2) = 0;
  return v8;
}

_DWORD *_BOMFreeListAllocateDense()
{
  _QWORD *v0;
  _DWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v0 = BOM_malloc(0x48uLL);
  v1 = v0;
  if (v0)
  {
    v0[2] = _dense_initialize;
    v0[3] = _dense_serialize;
    v0[4] = _dense_deallocate;
    v0[5] = _dense_addFreeRange;
    v0[6] = _dense_allocateRange;
    v0[7] = _dense_clear;
    v0[8] = _dense_print;
    v2 = BOM_malloc(0x18uLL);
    if (v2)
    {
      v3 = v2;
      v4 = BOM_calloc(0x20uLL, 8uLL);
      *v3 = v4;
      if (v4)
      {
        v3[1] = 0;
        *((_DWORD *)v3 + 4) = 32;
        *(_QWORD *)v1 = v3;
        v1[2] = 0;
        return v1;
      }
      free(v1);
      v5 = v3;
    }
    else
    {
      v5 = v1;
    }
    free(v5);
    return 0;
  }
  return v1;
}

uint64_t _dense_initialize(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;

  if ((a3 & 7) == 0 && (int)(a3 >> 3) >= 1)
  {
    v5 = result;
    v6 = (a3 >> 3);
    v7 = (unsigned int *)(a2 + 4);
    do
    {
      v8 = *(v7 - 1);
      v9 = bswap32(v8);
      v10 = bswap32(*v7);
      if (a4)
        v11 = v9;
      else
        v11 = v8;
      if (a4)
        v12 = v10;
      else
        v12 = *v7;
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 + 40))(v5, v11, v12);
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  return result;
}

_DWORD *_dense_serialize(uint64_t **a1, int a2, size_t *a3)
{
  uint64_t *v4;
  size_t v5;
  _DWORD *result;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t *v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;

  v4 = *a1;
  v5 = 8 * *((int *)a1 + 2);
  *a3 = v5;
  result = BOM_malloc(v5);
  if (result)
  {
    v7 = *((_DWORD *)v4 + 4);
    if (v7 < 1)
    {
      v9 = 0;
    }
    else
    {
      v8 = 0;
      v9 = 0;
      v10 = *v4;
      do
      {
        v11 = *(uint64_t **)(v10 + 8 * v8);
        if (v11)
        {
          v12 = 2 * v9;
          do
          {
            v13 = *((_DWORD *)v11 + 2);
            v14 = *((_DWORD *)v11 + 3);
            v15 = bswap32(v13);
            v16 = bswap32(v14);
            if (a2)
            {
              v13 = v15;
              v14 = v16;
            }
            result[v12] = v13;
            result[v12 + 1] = v14;
            v11 = (uint64_t *)*v11;
            v12 += 2;
            ++v9;
          }
          while (v11);
          v7 = *((_DWORD *)v4 + 4);
        }
        ++v8;
      }
      while (v8 < v7);
    }
    v17 = (uint64_t *)v4[1];
    if (v17)
    {
      v18 = 2 * v9;
      do
      {
        v19 = *((_DWORD *)v17 + 2);
        v20 = *((_DWORD *)v17 + 3);
        v21 = bswap32(v19);
        v22 = bswap32(v20);
        if (a2)
          v19 = v21;
        result[v18] = v19;
        if (a2)
          v23 = v22;
        else
          v23 = v20;
        result[v18 + 1] = v23;
        v17 = (uint64_t *)*v17;
        v18 += 2;
      }
      while (v17);
    }
  }
  return result;
}

void _dense_deallocate(uint64_t a1)
{
  void **v2;

  v2 = *(void ***)a1;
  (*(void (**)(void))(a1 + 56))();
  free(*v2);
  free(v2);
  *(_QWORD *)a1 = 0;
}

_QWORD *_dense_clear(uint64_t *a1)
{
  uint64_t v1;
  int v2;
  uint64_t i;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *result;
  _QWORD *v7;

  v1 = *a1;
  v2 = *(_DWORD *)(*a1 + 16);
  if (v2 >= 1)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD **)(*(_QWORD *)v1 + 8 * i);
      *(_QWORD *)(*(_QWORD *)v1 + 8 * i) = 0;
      if (v4)
      {
        do
        {
          v5 = (_QWORD *)*v4;
          free(v4);
          v4 = v5;
        }
        while (v5);
        v2 = *(_DWORD *)(v1 + 16);
      }
    }
  }
  result = *(_QWORD **)(v1 + 8);
  *(_QWORD *)(v1 + 8) = 0;
  if (result)
  {
    do
    {
      v7 = (_QWORD *)*result;
      free(result);
      result = v7;
    }
    while (v7);
  }
  return result;
}

_DWORD *_dense_addFreeRange(_DWORD *result, int a2, unint64_t a3)
{
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  char *v10;
  uint64_t v11;

  if (a3)
  {
    v5 = result;
    v6 = *(_QWORD *)result;
    if (a3 < 0x10000)
    {
      v8 = *(int *)(v6 + 16);
      if (v8 <= a3)
      {
        v9 = a3 + 1;
        v10 = (char *)BOM_realloc(*(void **)v6, (8 * (a3 + 1)));
        *(_QWORD *)v6 = v10;
        if ((int)v8 <= (int)a3)
          bzero(&v10[8 * *(int *)(v6 + 16)], 8 * (v9 - (int)v8));
        *(_DWORD *)(v6 + 16) = v9;
        v6 = *(_QWORD *)v5;
      }
      v11 = *(_QWORD *)(*(_QWORD *)v6 + 8 * a3);
      result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(_QWORD *)result = v11;
      *(_QWORD *)(*(_QWORD *)v6 + 8 * a3) = result;
    }
    else
    {
      v7 = *(_QWORD *)(v6 + 8);
      result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(_QWORD *)result = v7;
      *(_QWORD *)(v6 + 8) = result;
    }
    ++v5[2];
  }
  return result;
}

uint64_t _dense_allocateRange(uint64_t a1, unint64_t a2)
{
  _QWORD *v4;
  unint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  void **v13;
  _QWORD *v14;
  void **v15;
  unint64_t v16;
  void **v17;
  void **v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;

  v4 = *(_QWORD **)a1;
  v5 = *(int *)(*(_QWORD *)a1 + 16);
  if (v5 > a2)
  {
    v6 = *(unsigned int **)(*v4 + 8 * a2);
    if (v6)
    {
      v7 = v6[2];
      v8 = *(_QWORD *)v6;
      free(v6);
      *(_QWORD *)(*v4 + 8 * a2) = v8;
      --*(_DWORD *)(a1 + 8);
      return v7;
    }
  }
  LODWORD(v9) = 0;
  while (1)
  {
    v10 = (a2 + 1 + v9);
    if (v10 >= v5)
      break;
    v11 = *(unsigned int **)(*v4 + 8 * v10);
    v9 = (v9 + 1);
    if (v11)
    {
      v7 = v11[2];
      v12 = *(_QWORD *)v11;
      free(v11);
      *(_QWORD *)(*v4 + 8 * v10) = v12;
      --*(_DWORD *)(a1 + 8);
      (*(void (**)(uint64_t, _QWORD, uint64_t))(a1 + 40))(a1, (v7 + a2), v9);
      return v7;
    }
  }
  v15 = (void **)v4[1];
  v14 = v4 + 1;
  v13 = v15;
  if (!v15)
    return 0;
  v16 = *((unsigned int *)v13 + 3);
  if (v16 < a2)
  {
    while (1)
    {
      v17 = v13;
      v13 = (void **)*v13;
      if (!v13)
        return 0;
      v16 = *((unsigned int *)v13 + 3);
      if (v16 >= a2)
        goto LABEL_15;
    }
  }
  v17 = 0;
LABEL_15:
  v18 = (void **)*v13;
  v7 = *((unsigned int *)v13 + 2);
  v19 = (v7 + a2);
  v20 = (v16 - a2);
  free(v13);
  if (v17)
    v21 = v17;
  else
    v21 = v14;
  *v21 = v18;
  --*(_DWORD *)(a1 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v19, v20);
  return v7;
}

uint64_t _dense_print(uint64_t result, FILE *__stream, int a3)
{
  uint64_t v5;
  int v6;
  uint64_t i;
  _QWORD *v8;
  int v9;
  const char *v10;
  uint64_t *v11;
  int v12;
  const char *v13;

  v5 = *(_QWORD *)result;
  v6 = *(_DWORD *)(*(_QWORD *)result + 16);
  if (v6 >= 1)
  {
    for (i = 0; i < v6; ++i)
    {
      v8 = *(_QWORD **)(*(_QWORD *)v5 + 8 * i);
      if (v8)
      {
        v9 = 0;
        do
        {
          ++v9;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
        if (v9 == 1)
          v10 = "y";
        else
          v10 = "ies";
        result = fprintf(__stream, "Size %d: %d entr%s\n", i, v9, v10);
        v6 = *(_DWORD *)(v5 + 16);
      }
    }
  }
  v11 = *(uint64_t **)(v5 + 8);
  if (v11)
  {
    if (a3)
      fwrite("Large sizes:\n\t", 0xEuLL, 1uLL, __stream);
    v12 = 1;
    if (!a3)
      goto LABEL_17;
    while (1)
    {
      fprintf(__stream, "%d ", *((_DWORD *)v11 + 3));
      v11 = (uint64_t *)*v11;
      if (!v11)
        break;
      while (1)
      {
        ++v12;
        if (a3)
          break;
LABEL_17:
        v11 = (uint64_t *)*v11;
        if (!v11)
        {
          v13 = "ies";
          if (v12 == 1)
            v13 = "y";
          return fprintf(__stream, "Large sizes: %d entr%s\n", v12, v13);
        }
      }
    }
    return fputc(10, __stream);
  }
  return result;
}

uint64_t _densetrace_initialize(_DWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  result = (*(uint64_t (**)(void))(**(_QWORD **)a1 + 16))();
  a1[2] = *(_DWORD *)(*(_QWORD *)v2 + 8);
  return result;
}

uint64_t _densetrace_serialize(_DWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  result = (*(uint64_t (**)(void))(**(_QWORD **)a1 + 24))();
  a1[2] = *(_DWORD *)(*(_QWORD *)v2 + 8);
  return result;
}

void _densetrace_deallocate(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  (*(void (**)(void))(*(_QWORD *)*a1 + 32))();
  free(*(void **)v2);
  fclose(*(FILE **)(v2 + 16));
  free((void *)v2);
  *a1 = 0;
}

uint64_t _densetrace_clear(_DWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  result = (*(uint64_t (**)(void))(**(_QWORD **)a1 + 56))();
  a1[2] = *(_DWORD *)(*(_QWORD *)v2 + 8);
  return result;
}

uint64_t _densetrace_addFreeRange(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  FILE **v4;
  uint64_t result;

  v4 = *(FILE ***)a1;
  if (*(_DWORD *)(*(_QWORD *)a1 + 8))
    fprintf(v4[2], "Add\t\t%#zx\n", a3);
  result = (*(uint64_t (**)(void))&(*v4)->_lbfsize)();
  a1[2] = (*v4)->_r;
  return result;
}

uint64_t _densetrace_allocateRange(_DWORD *a1, uint64_t a2)
{
  FILE **v3;
  uint64_t result;

  v3 = *(FILE ***)a1;
  if (*(_DWORD *)(*(_QWORD *)a1 + 8))
    fprintf(v3[2], "Remove\t\t%#zx\n", a2);
  result = ((uint64_t (*)(void))(*v3)->_cookie)();
  a1[2] = (*v3)->_r;
  return result;
}

uint64_t _densetrace_print(_DWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  result = (*(uint64_t (**)(void))(**(_QWORD **)a1 + 64))();
  a1[2] = *(_DWORD *)(*(_QWORD *)v2 + 8);
  return result;
}

void OUTLINED_FUNCTION_0(uint64_t a1, const char *a2)
{
  err(1, a2);
}

void **BOMFilesystemInfoCreate(int a1)
{
  int v2;
  int v3;
  int v4;
  char *v6;
  void **v7;
  int v8;
  uint64_t i;
  void **v10;
  char *__endptr;
  size_t v13;
  int v14[3];
  char __str[100];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v13 = 100;
  *(_QWORD *)v14 = 0x200000001;
  if (sysctl(v14, 2u, __str, &v13, 0, 0))
  {
    fwrite("Could not determine kernel version\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
LABEL_3:
    v2 = -1;
    goto LABEL_10;
  }
  __endptr = 0;
  v3 = strtol(__str, &__endptr, 0);
  v4 = *__endptr;
  if (v4 != 46 && v4 != 0)
    goto LABEL_3;
  v2 = v3;
LABEL_10:
  v6 = (char *)BOM_calloc(0x328uLL, 1uLL);
  v7 = (void **)v6;
  if (v6)
  {
    if (v2 == -1)
      v8 = 7;
    else
      v8 = v2;
    *((_DWORD *)v6 + 2) = v8;
    *((_DWORD *)v6 + 3) = a1;
    if (pthread_mutex_init((pthread_mutex_t *)(v6 + 16), 0))
    {
      free(v7);
      return 0;
    }
    else
    {
      for (i = 0; i != 91; i += 13)
      {
        v10 = &v7[i];
        v7[i + 12] = 0;
        __strlcpy_chk();
        *(_OWORD *)(v10 + 13) = 0u;
        *(_OWORD *)(v10 + 15) = 0u;
        *(_OWORD *)(v10 + 17) = 0u;
        *(_OWORD *)(v10 + 19) = 0u;
        *(_OWORD *)(v10 + 21) = 0u;
      }
      *v7 = BomSys_default();
    }
  }
  return v7;
}

void BOMFilesystemInfoDestroy(uint64_t a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  free((void *)a1);
}

uint64_t BOMFilesystemInfoQuery(uint64_t a1, _BYTE *a2, _DWORD *a3, int a4, int a5)
{
  int v8;
  uint64_t v9;
  __int128 *v10;
  int v12;
  uint64_t v13;
  uint64_t result;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  int v19;
  _OWORD v20[4];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (a3 == (_DWORD *)&DEVICE_ARCHIVE)
  {
    v10 = (__int128 *)&archive;
  }
  else if (a3
         && (v8 = *a3 % 7, *(_DWORD *)(a1 + 104 * v8 + 96))
         && (v9 = a1 + 104 * v8, *(_DWORD *)(v9 + 100) == *a3))
  {
    v10 = (__int128 *)(v9 + 104);
  }
  else
  {
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    memset(v20, 0, sizeof(v20));
    v19 = 0;
    if (!a2 || _recursive_statfs(a2, v20, &v19, *(_QWORD *)a1))
      return 0xFFFFFFFFLL;
    if (DWORD2(v21) == 7562856)
    {
      v10 = &hfs7;
    }
    else if (DWORD2(v21) == 1718642273 && WORD6(v21) == 115)
    {
      v10 = &afp;
    }
    else if ((BYTE1(v21) & 0x10) != 0)
    {
      v10 = (__int128 *)&flatlocal;
    }
    else
    {
      v10 = (__int128 *)&flatnetwork;
    }
    v12 = v19;
    v13 = a1 + 104 * (v19 % 7);
    *(_DWORD *)(v13 + 96) = 1;
    *(_DWORD *)(v13 + 100) = v12;
    __strlcpy_chk();
    *(_OWORD *)(v13 + 120) = v10[1];
    *(_OWORD *)(v13 + 136) = v10[2];
    *(_OWORD *)(v13 + 152) = v10[3];
    *(_OWORD *)(v13 + 168) = v10[4];
    *(_OWORD *)(v13 + 104) = *v10;
  }
  result = 0xFFFFFFFFLL;
  if (a4 <= 1819173228)
  {
    if (a4 == 1633905696)
    {
      v15 = (unsigned int *)v10 + 13;
      v16 = (unsigned int *)v10 + 14;
      v17 = (unsigned int *)v10 + 15;
      v10 += 3;
    }
    else
    {
      if (a4 != 1718511215)
        return result;
      v15 = (unsigned int *)v10 + 5;
      v16 = (unsigned int *)v10 + 6;
      v17 = (unsigned int *)v10++ + 7;
    }
  }
  else
  {
    switch(a4)
    {
      case 1819173229:
        v15 = (unsigned int *)v10 + 17;
        v16 = (unsigned int *)v10 + 18;
        v17 = (unsigned int *)v10 + 19;
        v10 += 4;
        break;
      case 2020897906:
        v15 = (unsigned int *)v10 + 9;
        v16 = (unsigned int *)v10 + 10;
        v17 = (unsigned int *)v10 + 11;
        v10 += 2;
        break;
      case 1920168547:
        v15 = (unsigned int *)v10 + 1;
        v16 = (unsigned int *)v10 + 2;
        v17 = (unsigned int *)v10 + 3;
        break;
      default:
        return result;
    }
  }
  if (*(_DWORD *)v10 <= 1u)
    v18 = 1;
  else
    v18 = *(_DWORD *)v10;
  if (a4 != 1819173229 && *(_DWORD *)(a1 + 12) != 0)
    result = v18;
  else
    result = *(unsigned int *)v10;
  if (a5 > 1919905651)
  {
    if (a5 == 1919905652)
      return *v17;
    if (a5 != 1936749172)
      return 0xFFFFFFFFLL;
  }
  else
  {
    if (a5 != 1634756896)
    {
      if (a5 == 1853126245)
        return *v15;
      return 0xFFFFFFFFLL;
    }
    if (a4 != 1819173229 && *(_DWORD *)(a1 + 12) != 0)
      return 1633968748;
    else
      return *v16;
  }
  return result;
}

uint64_t _recursive_statfs(_BYTE *a1, void *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _OWORD v13[9];
  char __s[2];
  _BYTE v15[6];
  _BYTE __src[2168];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  memset(__src, 0, 512);
  bzero(v15, 0x3FEuLL);
  *(_WORD *)__s = 12078;
  if (*a1 == 47)
    __strlcpy_chk();
  else
    __strlcat_chk();
  v8 = (*(uint64_t (**)(_QWORD, char *, _BYTE *))(a4 + 104))(*(_QWORD *)(a4 + 8), __s, __src);
  if ((_DWORD)v8)
  {
    v9 = v8;
    if (*__error() != 2)
      return v9;
    v10 = strrchr(__s, 47);
    if (!v10)
      return v9;
    while (1)
    {
      if (v10 == __s)
        __strlcpy_chk();
      else
        *v10 = 0;
      v11 = (*(uint64_t (**)(_QWORD, char *, _BYTE *))(a4 + 104))(*(_QWORD *)(a4 + 8), __s, __src);
      if (!(_DWORD)v11)
        break;
      v9 = v11;
      v10 = strrchr(__s, 47);
      if (!v10)
        return v9;
    }
  }
  memset(v13, 0, sizeof(v13));
  memcpy(a2, __src, 0x878uLL);
  v9 = (*(uint64_t (**)(_QWORD, char *, _OWORD *))(a4 + 80))(*(_QWORD *)(a4 + 8), __s, v13);
  if (!(_DWORD)v9)
    *a3 = v13[0];
  return v9;
}

uint64_t BOMArchFlagForHeader(int *a1, unint64_t a2)
{
  uint64_t result;
  int v4;
  BOOL v5;
  unsigned int v6;
  unint64_t v7;
  BOOL v8;
  _BOOL4 v10;

  result = 0;
  if (a1 && a2 >= 8)
  {
    v4 = *a1;
    v5 = *a1 == -889275714 || v4 == -1095041334;
    if (!v5 || ((v6 = bswap32(a1[1]), v8 = v6 > 0x2A, v7 = 20 * v6 + 8, !v8) ? (v8 = v7 > a2) : (v8 = 1), v8))
    {
      if (a2 >= 0x1C)
      {
        result = 1;
        if (v4 != -822415874 && v4 != -17958194)
        {
          v10 = v4 == -17958193 || v4 == -805638658;
          return a2 >= 0x20 && v10;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t BOMArchFlagForFile(uint64_t a1)
{
  return BOMArchFlagForFileWithSys(a1, 0);
}

uint64_t BOMArchFlagForFileWithSys(uint64_t a1, void *a2)
{
  void *v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v8[8];
  uint64_t v9;

  v2 = a2;
  v9 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    v2 = BomSys_default();
  v4 = (*((uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))v2 + 2))(*((_QWORD *)v2 + 1), a1, 0, 0);
  if ((_DWORD)v4 == -1)
    return 0;
  v5 = v4;
  v6 = (*((uint64_t (**)(_QWORD, uint64_t, int *, uint64_t))v2 + 6))(*((_QWORD *)v2 + 1), v4, v8, 32);
  (*((void (**)(_QWORD, uint64_t))v2 + 4))(*((_QWORD *)v2 + 1), v5);
  if (v6 == -1)
    return 0;
  else
    return BOMArchFlagForHeader(v8, v6);
}

uint64_t _fat_header_big_to_host(unsigned int *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  unsigned int *v5;

  if (a2 < 8)
    return 0;
  v2 = a1[1];
  v3 = bswap32(v2);
  *a1 = bswap32(*a1);
  a1[1] = v3;
  if (20 * (unint64_t)v3 + 8 > a2)
    return 0;
  if (v2)
  {
    v5 = a1 + 6;
    do
    {
      *((int8x16_t *)v5 - 1) = vrev32q_s8(*((int8x16_t *)v5 - 1));
      *v5 = bswap32(*v5);
      v5 += 5;
      --v3;
    }
    while (v3);
  }
  return 1;
}

uint64_t _fat_header_host_to_big(unsigned int *a1, unint64_t a2)
{
  uint64_t v2;
  unsigned int *v4;

  if (a2 < 8)
    return 0;
  v2 = a1[1];
  *a1 = bswap32(*a1);
  a1[1] = bswap32(v2);
  if (20 * (unint64_t)v2 + 8 > a2)
    return 0;
  if ((_DWORD)v2)
  {
    v4 = a1 + 6;
    do
    {
      *((int8x16_t *)v4 - 1) = vrev32q_s8(*((int8x16_t *)v4 - 1));
      *v4 = bswap32(*v4);
      v4 += 5;
      --v2;
    }
    while (v2);
  }
  return 1;
}

uint64_t BOMHostByteOrder()
{
  return 1;
}

char **BOMGetArchInfoFromName(char *__s2)
{
  char **v2;
  const char *v3;
  const char *v4;

  if (!__s2)
    return 0;
  v2 = &BOMArchInfoTable;
  v3 = "hppa";
  while (strcmp(v3, __s2))
  {
    v4 = v2[4];
    v2 += 4;
    v3 = v4;
    if (!v4)
      return 0;
  }
  return v2;
}

char **BOMGetArchInfoFromCpuType(int a1, int a2)
{
  char **v3;
  char *v4;
  char **v5;
  char **v6;
  char *v8;

  v3 = &BOMArchInfoTable;
  while (*((_DWORD *)v3 + 2) != a1 || a2 != -1 && ((*((_DWORD *)v3 + 3) ^ a2) & 0xFFFFFF) != 0)
  {
    v4 = v3[4];
    v3 += 4;
    if (!v4)
    {
      if (a1 == 18)
      {
        v6 = (char **)malloc_type_malloc(0x20uLL, 0x1050040796EC678uLL);
        v3 = v6;
        if (!v6)
          return v3;
        *(_OWORD *)v6 = xmmword_24BF06F98;
        *((_OWORD *)v6 + 1) = unk_24BF06FA8;
        *((_DWORD *)v6 + 3) = a2;
        v8 = 0;
        asprintf(&v8, "PowerPC cpusubtype %u");
LABEL_12:
        if (v8)
        {
          v3[3] = v8;
          return v3;
        }
        free(v3);
      }
      else if (a1 == 7)
      {
        v5 = (char **)malloc_type_malloc(0x20uLL, 0x1050040796EC678uLL);
        v3 = v5;
        if (!v5)
          return v3;
        *(_OWORD *)v5 = xmmword_24BF06ED8;
        *((_OWORD *)v5 + 1) = unk_24BF06EE8;
        *((_DWORD *)v5 + 3) = a2;
        v8 = 0;
        asprintf(&v8, "Intel family %u model %u");
        goto LABEL_12;
      }
      return 0;
    }
  }
  return v3;
}

int8x8_t BOMSwapFatHeader(int8x8_t *a1, int a2)
{
  int8x8_t result;

  if (a1)
  {
    if (a2)
    {
      result = vrev32_s8(*a1);
      *a1 = result;
    }
  }
  return result;
}

uint64_t BOMSwapFatArch(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  unsigned int *v6;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    v5 = a2;
    v6 = (unsigned int *)(a1 + 16);
    do
    {
      *((int8x16_t *)v6 - 1) = vrev32q_s8(*((int8x16_t *)v6 - 1));
      *v6 = bswap32(*v6);
      v6 += 5;
      --v5;
    }
    while (v5);
    return 0;
  }
  return result;
}

uint64_t BOMSwapFatArch64(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3;

  v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    v3 = a2;
    do
    {
      *(int8x8_t *)a1 = vrev32_s8(*(int8x8_t *)a1);
      *(int8x16_t *)(a1 + 8) = vrev64q_s8(*(int8x16_t *)(a1 + 8));
      *(int8x8_t *)(a1 + 24) = vrev32_s8(*(int8x8_t *)(a1 + 24));
      a1 += 32;
      --v3;
    }
    while (v3);
  }
  return v3;
}

int8x8_t BOMSwapMachHeader(uint64_t a1, int a2)
{
  int8x8_t result;

  if (a1)
  {
    if (a2)
    {
      *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
      result = vrev32_s8(*(int8x8_t *)(a1 + 16));
      *(int8x8_t *)(a1 + 16) = result;
      *(_DWORD *)(a1 + 24) = bswap32(*(_DWORD *)(a1 + 24));
    }
  }
  return result;
}

int8x16_t BOMSwapMachHeader64(int8x16_t *a1, int a2)
{
  int8x16_t result;
  int8x16_t v3;

  if (a1)
  {
    if (a2)
    {
      result = vrev32q_s8(*a1);
      v3 = vrev32q_s8(a1[1]);
      *a1 = result;
      a1[1] = v3;
    }
  }
  return result;
}

_QWORD *BOMBufferAllocate(size_t a1)
{
  _QWORD *v2;
  void *v3;

  v2 = BOM_malloczero(0x48uLL);
  v3 = malloc_type_valloc(a1, 0x2E5E8A86uLL);
  v2[3] = v3;
  *v2 = a1;
  if (!v3)
  {
    free(v2);
    return 0;
  }
  return v2;
}

void BOMBufferDeallocate(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    a1[8] = 0;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
}

_QWORD *BOMBufferPoolAllocate(size_t a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v6;

  v4 = BOM_malloczero(0xA0uLL);
  if (pthread_cond_init((pthread_cond_t *)v4 + 1, 0))
    goto LABEL_4;
  if (pthread_mutex_init((pthread_mutex_t *)(v4 + 12), 0))
  {
    pthread_cond_destroy((pthread_cond_t *)v4 + 1);
LABEL_4:
    free(v4);
    return 0;
  }
  *v4 = 0;
  v4[1] = 0;
  v4[2] = a2;
  v4[3] = a1;
  v4[4] = 0;
  v4[5] = v4 + 4;
  if (a2 >= 0x40)
    a2 = 64;
  if (a2)
  {
    while (1)
    {
      v6 = BOMBufferAllocate(a1);
      if (!v6)
        break;
      --v4[2];
      BOMBufferPoolAddBuffer((uint64_t)v4, (uint64_t)v6);
      if (!--a2)
        return v4;
    }
    BOMBufferPoolDeallocate((uint64_t)v4);
    return 0;
  }
  return v4;
}

void BOMBufferPoolDeallocate(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  if (a1)
  {
    v2 = (pthread_mutex_t *)(a1 + 96);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)) && !pthread_mutex_unlock(v2))
    {
      pthread_cond_destroy((pthread_cond_t *)(a1 + 48));
      pthread_mutex_destroy(v2);
      while (1)
      {
        v3 = *(_QWORD *)(a1 + 32);
        if (!v3)
          break;
        v4 = *(_QWORD *)(v3 + 56);
        v5 = *(_QWORD **)(v3 + 64);
        if (v4)
        {
          *(_QWORD *)(v4 + 64) = v5;
          v5 = *(_QWORD **)(v3 + 64);
        }
        else
        {
          *(_QWORD *)(a1 + 40) = v5;
        }
        *v5 = v4;
        BOMBufferDeallocate((void **)v3);
      }
      *(_QWORD *)(a1 + 64) = 0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      free((void *)a1);
    }
  }
}

uint64_t BOMBufferPoolAddBuffer(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;

  v4 = (pthread_mutex_t *)(a1 + 96);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!(_DWORD)result)
  {
    v6 = (_QWORD *)(a1 + 32);
    v7 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a2 + 56) = v7;
    if (v7)
      v8 = (_QWORD *)(v7 + 64);
    else
      v8 = (_QWORD *)(a1 + 40);
    *v8 = a2 + 56;
    *v6 = a2;
    *(_QWORD *)(a2 + 64) = v6;
    *(int64x2_t *)a1 = vaddq_s64(*(int64x2_t *)a1, vdupq_n_s64(1uLL));
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  }
  return result;
}

_QWORD *BOMBufferPoolRequestBuffer(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;

  v2 = (pthread_mutex_t *)(a1 + 96);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)))
    return 0;
  while (1)
  {
    v5 = *(_QWORD *)(a1 + 8);
    if (v5)
      break;
    v6 = *(_QWORD *)(a1 + 16);
    if (v6)
    {
      *(_QWORD *)(a1 + 16) = v6 - 1;
      ++*(_QWORD *)a1;
      pthread_mutex_unlock(v2);
      v7 = BOMBufferAllocate(*(_QWORD *)(a1 + 24));
      if (v7)
        return v7;
      if (pthread_mutex_lock(v2))
        return 0;
      ++*(_QWORD *)(a1 + 16);
      --*(_QWORD *)a1;
    }
    else if (pthread_cond_wait((pthread_cond_t *)(a1 + 48), v2))
    {
      return 0;
    }
  }
  v3 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(v3 + 56);
  v9 = *(_QWORD **)(v3 + 64);
  if (v8)
  {
    *(_QWORD *)(v8 + 64) = v9;
    v9 = *(_QWORD **)(v3 + 64);
  }
  else
  {
    *(_QWORD *)(a1 + 40) = v9;
  }
  *v9 = v8;
  *(_QWORD *)(a1 + 8) = v5 - 1;
  pthread_mutex_unlock(v2);
  pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  return (_QWORD *)v3;
}

uint64_t BOMBufferPoolReturnBuffer(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;

  v4 = (pthread_mutex_t *)(a1 + 96);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!(_DWORD)result)
  {
    v7 = *(_QWORD *)(a1 + 32);
    v6 = a1 + 32;
    *(_QWORD *)(a2 + 56) = v7;
    v8 = (_QWORD *)(v7 + 64);
    if (v7)
      v9 = v8;
    else
      v9 = (_QWORD *)(v6 + 8);
    *v9 = a2 + 56;
    *(_QWORD *)v6 = a2;
    *(_QWORD *)(a2 + 64) = v6;
    ++*(_QWORD *)(v6 - 24);
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(v6 + 16));
  }
  return result;
}

char *BOMBufferFIFOCreate()
{
  char *v0;

  v0 = (char *)BOM_malloczero(0x88uLL);
  if (!pthread_cond_init((pthread_cond_t *)(v0 + 24), 0))
  {
    if (!pthread_mutex_init((pthread_mutex_t *)(v0 + 72), 0))
    {
      *(_QWORD *)v0 = 0;
      *((_QWORD *)v0 + 1) = 0;
      *((_QWORD *)v0 + 2) = v0 + 8;
      return v0;
    }
    pthread_cond_destroy((pthread_cond_t *)(v0 + 24));
  }
  free(v0);
  return 0;
}

void BOMBufferFIFODestroy(uint64_t a1)
{
  pthread_mutex_t *v2;
  char *v3;
  int *v4;

  if (a1)
  {
    v2 = (pthread_mutex_t *)(a1 + 72);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
    {
      if (*(_QWORD *)a1)
      {
        v3 = BOMExceptionHandlerMessage("Attempting to destroy a non-empty FIFO!");
        v4 = __error();
        _BOMFatalException((uint64_t)v3, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMBufferManager.c", 308, *v4);
      }
      if (!pthread_mutex_unlock(v2))
      {
        pthread_cond_destroy((pthread_cond_t *)(a1 + 24));
        pthread_mutex_destroy(v2);
        free((void *)a1);
      }
    }
  }
}

uint64_t BOMBufferFIFOEnqueue(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  _QWORD *v6;

  v4 = (pthread_mutex_t *)(a1 + 72);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a2 + 56) = 0;
    v6 = *(_QWORD **)(a1 + 16);
    *(_QWORD *)(a2 + 64) = v6;
    *v6 = a2;
    *(_QWORD *)(a1 + 16) = a2 + 56;
    ++*(_QWORD *)a1;
    pthread_mutex_unlock(v4);
    return pthread_cond_broadcast((pthread_cond_t *)(a1 + 24));
  }
  return result;
}

uint64_t BOMBufferFIFODequeue(uint64_t *a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  pthread_cond_t *v9;

  v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9)))
    return 0;
  while (1)
  {
    v3 = *a1;
    if (*a1)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 3), v2))
      return 0;
  }
  v4 = a1[1];
  v6 = *(_QWORD *)(v4 + 56);
  v7 = *(_QWORD **)(v4 + 64);
  if (v6)
  {
    *(_QWORD *)(v6 + 64) = v7;
    v7 = *(_QWORD **)(v4 + 64);
  }
  else
  {
    a1[2] = (uint64_t)v7;
  }
  *v7 = v6;
  v8 = v3 - 1;
  *a1 = v3 - 1;
  pthread_mutex_unlock(v2);
  v9 = (pthread_cond_t *)(a1 + 3);
  if (v8)
    pthread_cond_signal(v9);
  else
    pthread_cond_broadcast(v9);
  return v4;
}

uint64_t BOMBufferFIFOCount(uint64_t *a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;

  v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9)))
    return 0;
  v3 = *a1;
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t BomSys_init(_QWORD *a1, uint64_t a2)
{
  return BomSys_clone(a1, &gDefaultSys, a2);
}

uint64_t BomSys_clone(_QWORD *a1, const void *a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v6 = BOM_malloc(0x160uLL);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = v6;
  memcpy(v6, a2, 0x160uLL);
  result = 0;
  v7[1] = a3;
  *a1 = v7;
  return result;
}

void BomSys_free(void *a1)
{
  if (a1)
  {
    if (a1 != &gDefaultSys)
      free(a1);
  }
}

uint64_t BomSys_set_open(uint64_t result, uint64_t (*a2)(int a1, char *a2, int a3, unsigned int a4))
{
  uint64_t (*v2)(int, char *, int, unsigned int);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_open;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 16) = v2;
  }
  return result;
}

uint64_t BomSys_open(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

uint64_t BomSys_set_close(uint64_t result, uint64_t (*a2)(int a1, int a2))
{
  uint64_t (*v2)(int, int);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_close;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 32) = v2;
  }
  return result;
}

uint64_t BomSys_close(int a1, int a2)
{
  return close(a2);
}

uint64_t BomSys_set_read(uint64_t result, ssize_t (*a2)(int a1, int a2, void *a3, size_t a4))
{
  ssize_t (*v2)(int, int, void *, size_t);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_read;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 48) = v2;
  }
  return result;
}

ssize_t BomSys_read(int a1, int a2, void *a3, size_t a4)
{
  return read(a2, a3, a4);
}

uint64_t BomSys_set_lchown(uint64_t result, uint64_t (*a2)(int a1, char *a2, uid_t a3, gid_t a4))
{
  uint64_t (*v2)(int, char *, uid_t, gid_t);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_lchown;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 192) = v2;
  }
  return result;
}

uint64_t BomSys_lchown(int a1, char *a2, uid_t a3, gid_t a4)
{
  return lchown(a2, a3, a4);
}

uint64_t BomSys_set_chmod(uint64_t result, uint64_t (*a2)(int a1, char *a2, mode_t a3))
{
  uint64_t (*v2)(int, char *, mode_t);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_chmod;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 200) = v2;
  }
  return result;
}

uint64_t BomSys_chmod(int a1, char *a2, mode_t a3)
{
  return chmod(a2, a3);
}

uint64_t BomSys_set_symlink(uint64_t result, uint64_t (*a2)(int a1, char *a2, char *a3))
{
  uint64_t (*v2)(int, char *, char *);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_symlink;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 248) = v2;
  }
  return result;
}

uint64_t BomSys_symlink(int a1, char *a2, char *a3)
{
  return symlink(a2, a3);
}

uint64_t BomSys_set_opendir(uint64_t result, DIR *(*a2)(int a1, char *a2))
{
  DIR *(*v2)(int, char *);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_opendir;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 272) = v2;
  }
  return result;
}

DIR *BomSys_opendir(int a1, char *a2)
{
  return opendir(a2);
}

uint64_t BomSys_set_closedir(uint64_t result, uint64_t (*a2)(int a1, DIR *a2))
{
  uint64_t (*v2)(int, DIR *);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_closedir;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 280) = v2;
  }
  return result;
}

uint64_t BomSys_closedir(int a1, DIR *a2)
{
  return closedir(a2);
}

uint64_t BomSys_set_readdir(uint64_t result, dirent *(*a2)(int a1, DIR *a2))
{
  dirent *(*v2)(int, DIR *);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_readdir;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 288) = v2;
  }
  return result;
}

dirent *BomSys_readdir(int a1, DIR *a2)
{
  return readdir(a2);
}

uint64_t BomSys_set_readdir_r(uint64_t result, uint64_t (*a2)(int a1, DIR *a2, dirent *a3, dirent **a4))
{
  uint64_t (*v2)(int, DIR *, dirent *, dirent **);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_readdir_r;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 296) = v2;
  }
  return result;
}

uint64_t BomSys_readdir_r(int a1, DIR *a2, dirent *a3, dirent **a4)
{
  return readdir_r(a2, a3, a4);
}

uint64_t BomSys_set_copyfile(uint64_t result, uint64_t (*a2)(int a1, char *from, char *to, copyfile_state_t state, copyfile_flags_t flags))
{
  uint64_t (*v2)(int, char *, char *, copyfile_state_t, copyfile_flags_t);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_copyfile;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 344) = v2;
  }
  return result;
}

uint64_t BomSys_copyfile(int a1, char *from, char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return copyfile(from, to, state, flags);
}

uint64_t BomSys_set_access(uint64_t result, uint64_t (*a2)(int a1, char *a2, int a3))
{
  uint64_t (*v2)(int, char *, int);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_access;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 184) = v2;
  }
  return result;
}

uint64_t BomSys_access(int a1, char *a2, int a3)
{
  return access(a2, a3);
}

uint64_t BomSys_set_fstat(uint64_t result, uint64_t (*a2)(int a1, int a2, stat *a3))
{
  uint64_t (*v2)(int, int, stat *);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_fstat;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 88) = v2;
  }
  return result;
}

uint64_t BomSys_fstat(int a1, int a2, stat *a3)
{
  return fstat(a2, a3);
}

uint64_t BomSys_set_lseek(uint64_t result, off_t (*a2)(int a1, int a2, off_t a3, int a4))
{
  off_t (*v2)(int, int, off_t, int);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_lseek;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 64) = v2;
  }
  return result;
}

off_t BomSys_lseek(int a1, int a2, off_t a3, int a4)
{
  return lseek(a2, a3, a4);
}

uint64_t BomSys_set_mmap(uint64_t result, void *(*a2)(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7))
{
  void *(*v2)(int, void *, size_t, int, int, int, off_t);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_mmap;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 320) = v2;
  }
  return result;
}

void *BomSys_mmap(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

uint64_t BomSys_set_munmap(uint64_t result, uint64_t (*a2)(int a1, void *a2, size_t a3))
{
  uint64_t (*v2)(int, void *, size_t);

  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(_QWORD *)result)
  {
    v2 = BomSys_munmap;
    if (a2)
      v2 = a2;
    *(_QWORD *)(result + 328) = v2;
  }
  return result;
}

uint64_t BomSys_munmap(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

void *BomSys_default()
{
  return &gDefaultSys;
}

uint64_t BomSys_openFor(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

uint64_t BomSys_fcntl(int a1, int a2, int a3, uint64_t a4)
{
  return fcntl(a2, a3, a4);
}

ssize_t BomSys_write(int a1, int __fd, void *__buf, size_t __nbyte)
{
  return write(__fd, __buf, __nbyte);
}

uint64_t BomSys_fsync(int a1, int a2)
{
  return fsync(a2);
}

uint64_t BomSys_stat(int a1, char *a2, stat *a3)
{
  return stat(a2, a3);
}

uint64_t BomSys_lstat(int a1, char *a2, stat *a3)
{
  return lstat(a2, a3);
}

uint64_t BomSys_statfs(int a1, char *a2, statfs *a3)
{
  return statfs(a2, a3);
}

uint64_t BomSys_fstatfs(int a1, int a2, statfs *a3)
{
  return fstatfs(a2, a3);
}

uint64_t BomSys_getattrlist(int a1, char *a2, void *a3, void *a4, size_t a5, unsigned int a6)
{
  return getattrlist(a2, a3, a4, a5, a6);
}

ssize_t BomSys_getxattr(int a1, char *path, char *name, void *value, size_t size, u_int32_t position, int options)
{
  return getxattr(path, name, value, size, position, options);
}

uint64_t BomSys_setxattr(int a1, char *path, char *name, void *value, size_t size, u_int32_t position, int options)
{
  return setxattr(path, name, value, size, position, options);
}

ssize_t BomSys_listxattr(int a1, char *path, char *namebuff, size_t size, int options)
{
  return listxattr(path, namebuff, size, options);
}

uint64_t BomSys_removexattr(int a1, char *path, char *name, int options)
{
  return removexattr(path, name, options);
}

char *BomSys_realpath(int a1, char *a2, char *a3)
{
  return realpath_DARWIN_EXTSN(a2, a3);
}

uint64_t BomSys_mkdir(int a1, char *a2, mode_t a3)
{
  return mkdir(a2, a3);
}

uint64_t BomSys_mknod(int a1, char *a2, mode_t a3, dev_t a4)
{
  return mknod(a2, a3, a4);
}

uint64_t BomSys_chflags(int a1, char *a2, __uint32_t a3)
{
  return chflags(a2, a3);
}

uint64_t BomSys_utimes(int a1, char *a2, timeval *a3)
{
  return utimes(a2, a3);
}

uint64_t BomSys_unlink(int a1, char *a2)
{
  return unlink(a2);
}

uint64_t BomSys_rmdir(int a1, char *a2)
{
  return rmdir(a2);
}

uint64_t BomSys_link(int a1, char *a2, char *a3)
{
  return link(a2, a3);
}

ssize_t BomSys_readlink(int a1, char *a2, char *a3, size_t a4)
{
  return readlink(a2, a3, a4);
}

void BomSys_rename(int a1, std::__fs::filesystem::path *__from, std::__fs::filesystem::path *__to)
{
  rename(__from, __to, (std::error_code *)__to);
}

char *BomSys_getcwd(int a1, char *a2, size_t a3)
{
  return getcwd(a2, a3);
}

uint64_t BomSys_chdir(int a1, char *a2)
{
  return chdir(a2);
}

char *BomSys_mktemp(int a1, char *a2)
{
  return mktemp(a2);
}

uint64_t BomSys_log_attached(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)result)
      return *(_QWORD *)(*(_QWORD *)result + 352);
    else
      return 0;
  }
  return result;
}

_QWORD *BomSys_log_attach(_QWORD **a1, int a2, int a3, uint64_t a4, char a5)
{
  _QWORD **v9;
  _QWORD *v10;

  v9 = a1;
  if (!a1)
    v9 = (_QWORD **)BomSys_default();
  v10 = *v9;
  if (!*v9)
    v10 = BOM_malloczero(0x1A8uLL);
  memcpy(v10, &gLogSysSTDIO, 0x160uLL);
  *v10 = v10;
  v10[1] = v10;
  v10[44] = v9;
  v10[45] = a4;
  *((_BYTE *)v10 + 368) = a5;
  *((_DWORD *)v10 + 93) = a3;
  if ((a3 & 0x100) != 0)
  {
    *((_BYTE *)v10 + 394) = a2;
    if ((a3 & 0x10000) == 0)
    {
LABEL_7:
      if ((a3 & 0x2000) == 0)
        goto LABEL_8;
      goto LABEL_18;
    }
  }
  else if ((a3 & 0x10000) == 0)
  {
    goto LABEL_7;
  }
  *((_DWORD *)v10 + 95) = 16843009 * a2;
  if ((a3 & 0x2000) == 0)
  {
LABEL_8:
    if ((a3 & 0x8000) == 0)
      goto LABEL_9;
    goto LABEL_19;
  }
LABEL_18:
  *((_BYTE *)v10 + 388) = a2;
  *((_DWORD *)v10 + 96) = 16843009 * a2;
  if ((a3 & 0x8000) == 0)
  {
LABEL_9:
    if ((a3 & 0x200) == 0)
      goto LABEL_10;
    goto LABEL_20;
  }
LABEL_19:
  *((_BYTE *)v10 + 393) = a2;
  *(_DWORD *)((char *)v10 + 389) = 16843009 * a2;
  if ((a3 & 0x200) == 0)
  {
LABEL_10:
    if ((a3 & 0x400) == 0)
      goto LABEL_11;
    goto LABEL_21;
  }
LABEL_20:
  *((_BYTE *)v10 + 402) = a2;
  *((_BYTE *)v10 + 407) = a2;
  *((_DWORD *)v10 + 94) = 16843009 * a2;
  if ((a3 & 0x400) == 0)
  {
LABEL_11:
    if ((a3 & 0x1000) == 0)
      goto LABEL_12;
    goto LABEL_22;
  }
LABEL_21:
  *((_BYTE *)v10 + 395) = a2;
  *((_BYTE *)v10 + 403) = a2;
  *((_DWORD *)v10 + 102) = 16843009 * a2;
  *((_WORD *)v10 + 206) = 257 * a2;
  if ((a3 & 0x1000) == 0)
  {
LABEL_12:
    if ((a3 & 0x800) == 0)
      goto LABEL_13;
LABEL_23:
    *((_BYTE *)v10 + 404) = a2;
    *((_BYTE *)v10 + 405) = a2;
    *((_BYTE *)v10 + 406) = a2;
    if ((a3 & 0x4000) == 0)
      return v10;
    goto LABEL_14;
  }
LABEL_22:
  *((_BYTE *)v10 + 396) = a2;
  if ((a3 & 0x800) != 0)
    goto LABEL_23;
LABEL_13:
  if ((a3 & 0x4000) != 0)
  {
LABEL_14:
    *((_BYTE *)v10 + 401) = a2;
    *(_DWORD *)((char *)v10 + 397) = 16843009 * a2;
  }
  return v10;
}

uint64_t BomSys_log_detach(_QWORD **a1)
{
  _QWORD *v1;
  uint64_t v2;

  if (!a1)
    return 0;
  v1 = *a1;
  if (!v1)
    return 0;
  v2 = v1[44];
  free(v1);
  return v2;
}

uint64_t BomSys_log_config(uint64_t result, char *__s2, char a3)
{
  _BYTE *v4;

  if (result)
  {
    if (__s2)
    {
      v4 = *(_BYTE **)result;
      if (*(_QWORD *)result)
      {
        result = strcmp("realpath", __s2);
        if ((_DWORD)result)
        {
          result = strcmp("mkdir", __s2);
          if ((_DWORD)result)
          {
            result = strcmp("read", __s2);
            if ((_DWORD)result)
            {
              result = strcmp("write", __s2);
              if ((_DWORD)result)
              {
                result = strcmp("lseek", __s2);
                if ((_DWORD)result)
                {
                  result = strcmp("fsync", __s2);
                  if ((_DWORD)result)
                  {
                    result = strcmp("stat", __s2);
                    if ((_DWORD)result)
                    {
                      result = strcmp("fstat", __s2);
                      if ((_DWORD)result)
                      {
                        result = strcmp("lstat", __s2);
                        if ((_DWORD)result)
                        {
                          result = strcmp("statfs", __s2);
                          if ((_DWORD)result)
                          {
                            result = strcmp("fstatfs", __s2);
                            if ((_DWORD)result)
                            {
                              result = strcmp("getattrlist", __s2);
                              if ((_DWORD)result)
                              {
                                result = strcmp("getxattr", __s2);
                                if ((_DWORD)result)
                                {
                                  result = strcmp("setxattr", __s2);
                                  if ((_DWORD)result)
                                  {
                                    result = strcmp("listxattr", __s2);
                                    if ((_DWORD)result)
                                    {
                                      result = strcmp("removexattr", __s2);
                                      if ((_DWORD)result)
                                      {
                                        result = strcmp("open", __s2);
                                        if ((_DWORD)result)
                                        {
                                          result = strcmp("openFor", __s2);
                                          if ((_DWORD)result)
                                          {
                                            result = strcmp("close", __s2);
                                            if ((_DWORD)result)
                                            {
                                              result = strcmp("fcntl", __s2);
                                              if ((_DWORD)result)
                                              {
                                                result = strcmp("unlink", __s2);
                                                if ((_DWORD)result)
                                                {
                                                  result = strcmp("rename", __s2);
                                                  if ((_DWORD)result)
                                                  {
                                                    result = strcmp("opendir", __s2);
                                                    if ((_DWORD)result)
                                                    {
                                                      result = strcmp("closedir", __s2);
                                                      if ((_DWORD)result)
                                                      {
                                                        result = strcmp("readdir", __s2);
                                                        if ((_DWORD)result)
                                                        {
                                                          result = strcmp("readdir_r", __s2);
                                                          if ((_DWORD)result)
                                                          {
                                                            result = strcmp("getcwd", __s2);
                                                            if ((_DWORD)result)
                                                            {
                                                              result = strcmp("chdir", __s2);
                                                              if ((_DWORD)result)
                                                              {
                                                                result = strcmp("rmdir", __s2);
                                                                if ((_DWORD)result)
                                                                {
                                                                  result = strcmp("mknod", __s2);
                                                                  if ((_DWORD)result)
                                                                  {
                                                                    result = strcmp("link", __s2);
                                                                    if ((_DWORD)result)
                                                                    {
                                                                      result = strcmp("symlink", __s2);
                                                                      if ((_DWORD)result)
                                                                      {
                                                                        result = strcmp("readlink", __s2);
                                                                        if ((_DWORD)result)
                                                                        {
                                                                          result = strcmp("access", __s2);
                                                                          if ((_DWORD)result)
                                                                          {
                                                                            result = strcmp("lchown", __s2);
                                                                            if ((_DWORD)result)
                                                                            {
                                                                              result = strcmp("chmod", __s2);
                                                                              if ((_DWORD)result)
                                                                              {
                                                                                result = strcmp("chflags", __s2);
                                                                                if ((_DWORD)result)
                                                                                {
                                                                                  result = strcmp("utimes", __s2);
                                                                                  if ((_DWORD)result)
                                                                                  {
                                                                                    result = strcmp("mmap", __s2);
                                                                                    if ((_DWORD)result)
                                                                                    {
                                                                                      result = strcmp("munmap", __s2);
                                                                                      if ((_DWORD)result)
                                                                                      {
                                                                                        result = strcmp("mktemp", __s2);
                                                                                        if (!(_DWORD)result)
                                                                                          v4[416] = a3;
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v4[415] = a3;
                                                                                      }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v4[414] = a3;
                                                                                    }
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v4[401] = a3;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  v4[400] = a3;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                v4[399] = a3;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              v4[398] = a3;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            v4[397] = a3;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          v4[406] = a3;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        v4[405] = a3;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      v4[404] = a3;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    v4[396] = a3;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  v4[403] = a3;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                v4[413] = a3;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              v4[412] = a3;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            v4[411] = a3;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          v4[410] = a3;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v4[409] = a3;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v4[408] = a3;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v4[407] = a3;
                                                  }
                                                }
                                                else
                                                {
                                                  v4[402] = a3;
                                                }
                                              }
                                              else
                                              {
                                                v4[379] = a3;
                                              }
                                            }
                                            else
                                            {
                                              v4[378] = a3;
                                            }
                                          }
                                          else
                                          {
                                            v4[377] = a3;
                                          }
                                        }
                                        else
                                        {
                                          v4[376] = a3;
                                        }
                                      }
                                      else
                                      {
                                        v4[393] = a3;
                                      }
                                    }
                                    else
                                    {
                                      v4[392] = a3;
                                    }
                                  }
                                  else
                                  {
                                    v4[391] = a3;
                                  }
                                }
                                else
                                {
                                  v4[390] = a3;
                                }
                              }
                              else
                              {
                                v4[389] = a3;
                              }
                            }
                            else
                            {
                              v4[388] = a3;
                            }
                          }
                          else
                          {
                            v4[387] = a3;
                          }
                        }
                        else
                        {
                          v4[386] = a3;
                        }
                      }
                      else
                      {
                        v4[385] = a3;
                      }
                    }
                    else
                    {
                      v4[384] = a3;
                    }
                  }
                  else
                  {
                    v4[383] = a3;
                  }
                }
                else
                {
                  v4[382] = a3;
                }
              }
              else
              {
                v4[381] = a3;
              }
            }
            else
            {
              v4[380] = a3;
            }
          }
          else
          {
            v4[395] = a3;
          }
        }
        else
        {
          v4[394] = a3;
        }
      }
    }
  }
  return result;
}

uint64_t BomSys_log_resume(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)result)
      *(_BYTE *)(*(_QWORD *)result + 368) = 1;
  }
  return result;
}

uint64_t BomSys_log_pause(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)result)
      *(_BYTE *)(*(_QWORD *)result + 368) = 0;
  }
  return result;
}

uint64_t BomSysLog_open(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 376))
    fprintf(*(FILE **)(a1 + 360), "open(\"%s\", %d, %d) => %d\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_openFor(uint64_t a1, const char *a2, int a3, int a4, const char *a5)
{
  uint64_t v10;

  v10 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 377))
    fprintf(*(FILE **)(a1 + 360), "openFor(\"%s\", %d, %d, \"%s\") => %d\n", a2, a3, a4, a5, v10);
  return v10;
}

uint64_t BomSysLog_close(uint64_t a1, int a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 378))
    fprintf(*(FILE **)(a1 + 360), "close(%d) => %d\n", a2, v4);
  return v4;
}

uint64_t BomSysLog_fcntl(uint64_t a1, int a2, int a3, const void *a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 379))
    fprintf(*(FILE **)(a1 + 360), "fcntl(%d, %d, %p) => %d\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_read(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 48))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 380))
    fprintf(*(FILE **)(a1 + 360), "read(%d, %p, %zu) => %zd\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_write(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 56))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 381))
    fprintf(*(FILE **)(a1 + 360), "write(%d, %p, %zu) => %zd\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_lseek(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 382))
    fprintf(*(FILE **)(a1 + 360), "lseek(%d, %lld, %d) => %lld\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_fsync(uint64_t a1, int a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 72))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 383))
    fprintf(*(FILE **)(a1 + 360), "fsync(%d) => %d\n", a2, v4);
  return v4;
}

uint64_t BomSysLog_stat(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 384))
    fprintf(*(FILE **)(a1 + 360), "stat(\"%s\", %p) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_fstat(uint64_t a1, int a2, const void *a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 88))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 385))
    fprintf(*(FILE **)(a1 + 360), "fstat(%d, %p) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_lstat(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 386))
    fprintf(*(FILE **)(a1 + 360), "lstat(\"%s\", %p) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_statfs(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 104))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 387))
    fprintf(*(FILE **)(a1 + 360), "statfs(\"%s\", %p) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_fstatfs(uint64_t a1, int a2, const void *a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 112))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 388))
    fprintf(*(FILE **)(a1 + 360), "fstatfs(%d, %p) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_getattrlist(uint64_t a1, const char *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;

  v12 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 120))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 389))
    fprintf(*(FILE **)(a1 + 360), "getattrlist(\"%s\", %p, %p, %zu, %lu) => %d\n", a2, a3, a4, a5, a6, v12);
  return v12;
}

uint64_t BomSysLog_getxattr(uint64_t a1, const char *a2, const char *a3, const void *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v14;

  v14 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 128))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 390))
    fprintf(*(FILE **)(a1 + 360), "getxattr(\"%s\", \"%s\", %p, %zu, %u, %d) => %zd\n", a2, a3, a4, a5, a6, a7, v14);
  return v14;
}

uint64_t BomSysLog_setxattr(uint64_t a1, const char *a2, const char *a3, const void *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v14;

  v14 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 136))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 391))
    fprintf(*(FILE **)(a1 + 360), "setxattr(\"%s\", \"%s\", %p, %zu, %u, %d) => %d\n", a2, a3, a4, a5, a6, a7, v14);
  return v14;
}

uint64_t BomSysLog_listxattr(uint64_t a1, const char *a2, const char *a3, uint64_t a4, int a5)
{
  uint64_t v10;

  v10 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 144))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 392))
    fprintf(*(FILE **)(a1 + 360), "listxattr(\"%s\", \"%s\", %zu, %d) => %zd\n", a2, a3, a4, a5, v10);
  return v10;
}

uint64_t BomSysLog_removexattr(uint64_t a1, const char *a2, const char *a3, int a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 152))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 393))
    fprintf(*(FILE **)(a1 + 360), "removexattr(\"%s\", \"%s\", %d) => %d\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_realpath(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6;
  const char *v7;
  const char *v8;
  const char *v9;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 394))
  {
    v7 = "(null)";
    if (a2)
      v8 = a2;
    else
      v8 = "(null)";
    if (a3)
      v9 = a3;
    else
      v9 = "(null)";
    if (v6)
      v7 = (const char *)v6;
    fprintf(*(FILE **)(a1 + 360), "realpath(\"%s\", \"%s\") => \"%s\"\n", v8, v9, v7);
  }
  return v6;
}

uint64_t BomSysLog_mkdir(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 168))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 395))
    fprintf(*(FILE **)(a1 + 360), "mkdir(\"%s\", %d) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_mknod(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 176))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 396))
    fprintf(*(FILE **)(a1 + 360), "mknod(\"%s\", %d, %d) => %d\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_access(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 184))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 397))
    fprintf(*(FILE **)(a1 + 360), "access(\"%s\", %d) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_lchown(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 192))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 398))
    fprintf(*(FILE **)(a1 + 360), "chown(\"%s\", %d, %d) => %d\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_chmod(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 200))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 399))
    fprintf(*(FILE **)(a1 + 360), "chmod(\"%s\", %d) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_chflags(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 208))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 400))
    fprintf(*(FILE **)(a1 + 360), "chflags(\"%s\", %u) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_utimes(uint64_t a1, const char *a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 216))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 401))
    fprintf(*(FILE **)(a1 + 360), "utimes(\"%s\") => %d\n", a2, v4);
  return v4;
}

uint64_t BomSysLog_unlink(uint64_t a1, const char *a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 224))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 402))
    fprintf(*(FILE **)(a1 + 360), "unlink(\"%s\") => %d\n", a2, v4);
  return v4;
}

uint64_t BomSysLog_rmdir(uint64_t a1, const char *a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 232))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 403))
    fprintf(*(FILE **)(a1 + 360), "rmdir(\"%s\") => %d\n", a2, v4);
  return v4;
}

uint64_t BomSysLog_link(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6;
  const char *v7;
  const char *v8;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 240))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 404))
  {
    v7 = "(null)";
    if (a2)
      v8 = a2;
    else
      v8 = "(null)";
    if (a3)
      v7 = a3;
    fprintf(*(FILE **)(a1 + 360), "link(\"%s\", \"%s\") => %d\n", v8, v7, v6);
  }
  return v6;
}

uint64_t BomSysLog_symlink(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6;
  const char *v7;
  const char *v8;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 248))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 405))
  {
    v7 = "(null)";
    if (a2)
      v8 = a2;
    else
      v8 = "(null)";
    if (a3)
      v7 = a3;
    fprintf(*(FILE **)(a1 + 360), "symlink(\"%s\", \"%s\") => %d\n", v8, v7, v6);
  }
  return v6;
}

uint64_t BomSysLog_readlink(uint64_t a1, const char *a2, const void *a3, uint64_t a4)
{
  uint64_t v8;

  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 256))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 406))
    fprintf(*(FILE **)(a1 + 360), "readlink(\"%s\", %p, %zu) => %zd\n", a2, a3, a4, v8);
  return v8;
}

uint64_t BomSysLog_rename(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6;
  const char *v7;
  const char *v8;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 264))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 407))
  {
    v7 = "(null)";
    if (a2)
      v8 = a2;
    else
      v8 = "(null)";
    if (a3)
      v7 = a3;
    fprintf(*(FILE **)(a1 + 360), "rename(\"%s\", \"%s\") => %d\n", v8, v7, v6);
  }
  return v6;
}

uint64_t BomSysLog_opendir(uint64_t a1, const char *a2)
{
  uint64_t v4;
  char v6[64];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 272))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 408))
  {
    BomSysLog_DIR(v6, v4);
    fprintf(*(FILE **)(a1 + 360), "opendir(\"%s\") => %s\n", a2, v6);
  }
  return v4;
}

uint64_t BomSysLog_closedir(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v6[64];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 409))
    BomSysLog_DIR(v6, a2);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 352) + 280))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8), a2);
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 409))
    fprintf(*(FILE **)(a1 + 360), "closedir(%s) => %d\n", v6, v4);
  return v4;
}

uint64_t BomSysLog_readdir(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v6[1088];
  char v7[64];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 288))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 410))
  {
    BomSysLog_DIR(v7, a2);
    BomSysLog_DIRENT(v6, v4);
    fprintf(*(FILE **)(a1 + 360), "readdir(%s) => %s\n", v7, v6);
  }
  return v4;
}

uint64_t BomSysLog_readdir_r(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  char v11[1088];
  char v12[1088];
  char v13[64];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 296))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 411))
  {
    BomSysLog_DIR(v13, a2);
    BomSysLog_DIRENT(v12, a3);
    if (a4)
    {
      v9 = *a4;
      if (*a4 == a3)
      {
        strcpy(v11, "<same>");
LABEL_8:
        fprintf(*(FILE **)(a1 + 360), "readdir_r(%s, %s, %s) => %d\n", v13, v12, v11, v8);
        return v8;
      }
    }
    else
    {
      v9 = 0;
    }
    BomSysLog_DIRENT(v11, v9);
    goto LABEL_8;
  }
  return v8;
}

uint64_t BomSysLog_getcwd(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  const char *v7;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 304))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 412))
  {
    v7 = "(null)";
    if (v6)
      v7 = (const char *)v6;
    fprintf(*(FILE **)(a1 + 360), "getcwd(%p, %zu) => \"%s\"\n", a2, a3, v7);
  }
  return v6;
}

uint64_t BomSysLog_chdir(uint64_t a1, const char *a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 312))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 413))
    fprintf(*(FILE **)(a1 + 360), "chdir(\"%s\") => %d\n", a2, v4);
  return v4;
}

const void *BomSysLog_mmap(uint64_t a1, const void *a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  const void *v14;

  v14 = (const void *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 320))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 414))
    fprintf(*(FILE **)(a1 + 360), "mmap(%p, %zu, %d, %d, %d, %lld) => %p\n", a2, a3, a4, a5, a6, a7, v14);
  return v14;
}

uint64_t BomSysLog_munmap(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 328))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 415))
    fprintf(*(FILE **)(a1 + 360), "munmap(%p, %zd) => %d\n", a2, a3, v6);
  return v6;
}

uint64_t BomSysLog_mktemp(uint64_t a1, const char *a2)
{
  uint64_t v4;
  const char *v5;
  const char *v6;

  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 336))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 416))
  {
    v5 = "(null)";
    if (a2)
      v6 = a2;
    else
      v6 = "(null)";
    if (v4)
      v5 = (const char *)v4;
    fprintf(*(FILE **)(a1 + 360), "mktemp(\"%s\") => \"%s\"\n", v6, v5);
  }
  return v4;
}

uint64_t BomSysLog_copyfile(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 352) + 344))(*(_QWORD *)(*(_QWORD *)(a1 + 352) + 8));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 417))
    fprintf(*(FILE **)(a1 + 360), "copyfile(\"%s\", \"%s\")\n", a2, a3);
  return v6;
}

uint64_t BomSysLog_DIR(char *a1, uint64_t a2)
{
  if (a2)
    return snprintf(a1, 0x40uLL, "%p {%d}");
  else
    return snprintf(a1, 0x40uLL, "%p");
}

uint64_t BomSysLog_DIRENT(char *a1, uint64_t a2)
{
  if (a2)
    return snprintf(a1, 0x440uLL, "%p {%llu, %d, \"%s\"}");
  else
    return snprintf(a1, 0x440uLL, "%p");
}

void BOMCopierErrorFree(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    v2 = (void *)a1[4];
    if (v2)
      free(v2);
    free(a1);
  }
}

uint64_t BOMCopierErrorGetFileName(uint64_t result)
{
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t BOMCopierErrorGetLineNumber(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 8);
  return result;
}

uint64_t BOMCopierErrorGetCompilationDate(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t BOMCopierErrorGetFunctionName(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t BOMCopierErrorGetMessage(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

uint64_t BOMCopierErrorGetCode(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 40);
  return result;
}

_QWORD *BOMCopierErrorCapture(_QWORD *result, int a2, uint64_t a3, int a4, uint64_t a5, char *a6, ...)
{
  _QWORD *v6;
  FILE *v11;
  int *v12;
  char *v13;
  FILE *v14;
  const char *v15;
  size_t v16;
  char *v17[2];
  va_list va;

  va_start(va, a6);
  v17[0] = 0;
  if (result)
  {
    v6 = result;
    if (!*result)
    {
      va_copy((va_list)&v17[1], va);
      if (vasprintf(v17, a6, va) < 0)
      {
        v11 = (FILE *)*MEMORY[0x24BDAC8D8];
        v12 = __error();
        v13 = strerror(*v12);
        return (_QWORD *)fprintf(v11, "Could not create error message: %s\n", v13);
      }
      else
      {
        if (v17[0])
        {
          result = malloc_type_calloc(1uLL, 0x30uLL, 0x105004057D267B0uLL);
          if (result)
          {
            *result = a3;
            *((_DWORD *)result + 2) = a4;
            result[2] = "Aug  3 2024";
            result[3] = a5;
            result[4] = v17[0];
            *((_DWORD *)result + 10) = a2;
            *v6 = result;
            return result;
          }
          v14 = (FILE *)*MEMORY[0x24BDAC8D8];
          v15 = "Could not allocate empty _BOMCopierError\n";
          v16 = 41;
        }
        else
        {
          v14 = (FILE *)*MEMORY[0x24BDAC8D8];
          v15 = "Error message is NULL\n";
          v16 = 22;
        }
        return (_QWORD *)fwrite(v15, v16, 1uLL, v14);
      }
    }
  }
  return result;
}

uint64_t BOMCopierCopyWithOptions2(uint64_t a1, char *a2, char *a3, const void *a4)
{
  _BYTE *v8;
  NSObject *v9;
  const __CFAllocator *v10;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v12;
  CFTypeID TypeID;
  uint64_t v14;
  int v15;
  char *v16;
  int v17;
  int v18;
  int v19;
  __CFReadStream *Value;
  int i;
  CFStreamStatus Status;
  __CFWriteStream *v23;
  int j;
  CFStreamStatus v25;
  int v26;
  NSObject *v27;
  const void *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  NSObject *v34;
  uint64_t *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t *v54;
  unsigned int *v55;
  unsigned int Type;
  const char *Path;
  char *v58;
  int v59;
  NSObject *v60;
  int v61;
  __int16 Mode;
  uint64_t v63;
  int v64;
  uint64_t Size;
  uint64_t v66;
  int v67;
  const char *v68;
  char *v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  NSObject *v78;
  uint64_t v79;
  NSObject *v80;
  uint64_t v81;
  NSObject *v82;
  NSObject *v83;
  const char *v84;
  NSObject *v85;
  NSObject *v86;
  NSObject *v87;
  int v88;
  int *v89;
  char *v90;
  int *v91;
  int v92;
  int v93;
  int *v94;
  const char *v96;
  NSObject *v97;
  NSObject *v98;
  NSObject *v99;
  const char *v100;
  NSObject *v101;
  NSObject *v102;
  uint64_t v103;
  char *v104;
  char *v105;
  uint64_t v106;
  char *v107;
  _QWORD *v108;
  uint8_t v109[4];
  const char *v110;
  uint8_t buf[16];
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;

  v116 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 22;
  v8 = (_BYTE *)(a1 + 11616);
  v108 = 0;
  if ((os_variant_has_internal_content() & 1) != 0)
  {
    getenv("BOMCOPIER_LOGGING");
    goto LABEL_4;
  }
  v15 = v8[1442];
  v16 = getenv("BOMCOPIER_LOGGING");
  if (v16)
  {
    v17 = strcmp(v16, "1");
    if (!v15 && v17)
      goto LABEL_5;
    goto LABEL_4;
  }
  if (v15)
LABEL_4:
    *(_QWORD *)(a1 + 13000) = os_log_create("com.apple.Bom", "BOMCopier");
LABEL_5:
  v9 = *(NSObject **)(a1 + 13000);
  if (v9)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)
      || (*(_DWORD *)buf = 136315138,
          *(_QWORD *)&buf[4] = a2,
          _os_log_impl(&dword_206367000, v9, OS_LOG_TYPE_DEFAULT, "fromObj: %s", buf, 0xCu),
          (v9 = *(NSObject **)(a1 + 13000)) != 0))
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = a3;
        _os_log_impl(&dword_206367000, v9, OS_LOG_TYPE_DEFAULT, "toObj: %s", buf, 0xCu);
      }
    }
  }
  v10 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  *(_QWORD *)(a1 + 13008) = Mutable;
  if (!Mutable)
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 720, (uint64_t)"prepare_copy_state", "Could not create source options");
    goto LABEL_225;
  }
  v12 = CFDictionaryCreateMutable(v10, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  *(_QWORD *)(a1 + 13024) = v12;
  if (!v12)
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 727, (uint64_t)"prepare_copy_state", "Could not create destination options");
    goto LABEL_225;
  }
  if (!a4)
    goto LABEL_85;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a4))
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 735, (uint64_t)"prepare_copy_state", "The options dictionary is not a CFDictionary");
    goto LABEL_225;
  }
  if (parse_copier_options(a1, (const __CFDictionary *)a4, &v108))
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 742, (uint64_t)"prepare_copy_state", "Could not create parse copier options");
LABEL_225:
    v14 = 1;
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 188, (uint64_t)"BOMCopierCopyWithOptions2", "Could not parse the client options", v103);
    goto LABEL_226;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("compressCPIO"))
    && *(_DWORD *)(a1 + 12712) != 1
    && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3560, (uint64_t)"verify_copier_options", "Compression is only used for CPIO archives");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("skipCPIOTerminator")) && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3569, (uint64_t)"verify_copier_options", "SkipTerminator is only used for CPIO archives");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("skipCPIORoot")) && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3578, (uint64_t)"verify_copier_options", "SkipRoot is only used for CPIO archives");
    goto LABEL_224;
  }
  if (*(_DWORD *)(a1 + 12712) == 2 && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3589, (uint64_t)"verify_copier_options", "PKZip archives can only be extracted to filesystem destinations");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("sequesterResources"))
    && *(_DWORD *)(a1 + 12716) != 5
    && *(_DWORD *)(a1 + 12712) != 2)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3597, (uint64_t)"verify_copier_options", "sequesterResources is only for PKZip archives");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("keepParent")) && *(_DWORD *)(a1 + 12716) == 3)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3610, (uint64_t)"verify_copier_options", "keepParent is only for archives");
    goto LABEL_224;
  }
  v18 = CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("inputFD"));
  if (a2 && v18)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3623, (uint64_t)"verify_copier_options", "Cannot specify a fromObj with kBOMCopierOptionInputFileDescriptorKey");
    goto LABEL_224;
  }
  v19 = CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("outputFD"));
  if (a3 && v19)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3632, (uint64_t)"verify_copier_options", "Cannot specify a toObj with kBOMCopierOptionOutputFileDescriptorKey");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("inputStream")))
  {
    if (a2 || CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("inputFD")))
    {
      BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3645, (uint64_t)"verify_copier_options", "Cannot specify fromObj or kBOMCopierOptionInputFileDescriptorKey with kBOMCopierOptionInputCFReadStreamKey");
      goto LABEL_224;
    }
    Value = (__CFReadStream *)CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("inputStream"));
    for (i = 30; ; --i)
    {
      Status = CFReadStreamGetStatus(Value);
      if (Status != kCFStreamStatusOpening)
        break;
      if (!i)
      {
        BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3669, (uint64_t)"verify_copier_options", "Timed out waiting for the read stream to open");
        goto LABEL_224;
      }
      *(_OWORD *)buf = xmmword_2063CFD90;
      nanosleep((const timespec *)buf, 0);
    }
    if (Status != kCFStreamStatusOpen)
    {
      BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3685, (uint64_t)"verify_copier_options", "CFReadStream is not open: %u");
      goto LABEL_224;
    }
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("outputStream")))
  {
    if (a3 || CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("outputFD")))
    {
      BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3694, (uint64_t)"verify_copier_options", "Cannot specify toObj or kBOMCopierOptionOutputFileDescriptorKey with kBOMCopierOptionOutputCFWriteStreamKey");
      goto LABEL_224;
    }
    v23 = (__CFWriteStream *)CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("outputStream"));
    for (j = 30; ; --j)
    {
      v25 = CFWriteStreamGetStatus(v23);
      if (v25 != kCFStreamStatusOpening)
        break;
      if (!j)
      {
        BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3718, (uint64_t)"verify_copier_options", "Timed out waiting for the write stream to open");
        goto LABEL_224;
      }
      *(_OWORD *)buf = xmmword_2063CFD90;
      nanosleep((const timespec *)buf, 0);
    }
    if (v25 != kCFStreamStatusOpen)
    {
      BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3734, (uint64_t)"verify_copier_options", "CFWriteStream is not open: %u");
      goto LABEL_224;
    }
  }
  v26 = CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("output2Nowhere"));
  if (a3 && v26)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3743, (uint64_t)"verify_copier_options", "Cannot specify a toObj with kBOMCopierOptionOutputNowhereKey");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("setStaticContent")) && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3756, (uint64_t)"verify_copier_options", "setStaticContent is only for filesystem destinations");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("setSingleWriter")) && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3765, (uint64_t)"verify_copier_options", "setSingleWriter is only for filesystem destinations");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("applyProvenance")))
  {
    if (*(_DWORD *)(a1 + 12712))
    {
      if (*(_DWORD *)(a1 + 12716) == 3)
        goto LABEL_82;
      BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3780, (uint64_t)"verify_copier_options", "applyProvenance is only applicable when extracting from archives");
    }
    else
    {
      BOMCopierErrorCapture(&v108, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3774, (uint64_t)"verify_copier_options", "applyProvenance is only for extracting from archives");
    }
LABEL_224:
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 749, (uint64_t)"prepare_copy_state", "Could not verify copier options");
    goto LABEL_225;
  }
LABEL_82:
  v27 = *(NSObject **)(a1 + 13000);
  if (v27 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = a4;
    _os_log_impl(&dword_206367000, v27, OS_LOG_TYPE_DEFAULT, "options: %@", buf, 0xCu);
  }
LABEL_85:
  if (getenv("PRESERVECOMPRESSION"))
  {
    v28 = (const void *)*MEMORY[0x24BDBD270];
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverCompressionAttributes"), (const void *)*MEMORY[0x24BDBD270]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("preserveAppleFSCompression"), v28);
  }
  v29 = *(NSObject **)(a1 + 13000);
  if (v29)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)
      || (v30 = *(_QWORD *)(a1 + 13008),
          *(_DWORD *)buf = 138412290,
          *(_QWORD *)&buf[4] = v30,
          _os_log_impl(&dword_206367000, v29, OS_LOG_TYPE_DEFAULT, "source options: %@", buf, 0xCu),
          (v29 = *(NSObject **)(a1 + 13000)) != 0))
    {
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        v31 = *(_QWORD *)(a1 + 13024);
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v31;
        _os_log_impl(&dword_206367000, v29, OS_LOG_TYPE_DEFAULT, "destination options: %@", buf, 0xCu);
        v29 = *(NSObject **)(a1 + 13000);
      }
    }
  }
  v32 = BOMCopierSourceNew(a2, *(const __CFDictionary **)(a1 + 13008), (uint64_t)v29, &v108);
  *(_QWORD *)(a1 + 13016) = v32;
  if (!v32)
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 783, (uint64_t)"prepare_copy_state", "Could not create BOMCopierSource");
    goto LABEL_225;
  }
  v33 = BOMCopierDestinationNew(a3, *(const __CFDictionary **)(a1 + 13024), &v108);
  *(_QWORD *)(a1 + 13032) = v33;
  if (!v33)
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 790, (uint64_t)"prepare_copy_state", "Could not create BOMCopierDestination");
    goto LABEL_225;
  }
  BOMCopierDestinationSetLog(v33, *(_QWORD *)(a1 + 13000));
  if (BOMCopierSourceSetErrorHandler(*(_QWORD **)(a1 + 13016), (uint64_t)source_error_handler, a1, &v108))
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 803, (uint64_t)"prepare_copy_state", "Could not set BOMCopierSource error handler");
    goto LABEL_225;
  }
  if (*(_QWORD *)(a1 + 128))
  {
    if (BOMCopierSourceSetPassphraseCallback(*(_QWORD *)(a1 + 13016), (uint64_t)passphrase_callback, a1, &v108))
    {
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 816, (uint64_t)"prepare_copy_state", "Could not set BOMCopierSource passphrase callback");
      goto LABEL_225;
    }
    v34 = *(NSObject **)(a1 + 13000);
    if (v34 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_206367000, v34, OS_LOG_TYPE_DEFAULT, "Set passphrase callback", buf, 2u);
    }
  }
  v35 = (uint64_t *)(a1 + 13032);
  v36 = *(_QWORD *)(a1 + 13040);
  if (v36)
  {
    if (BOMCopierDestinationSetAllowBom(*v35, v36, &v108))
    {
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 832, (uint64_t)"prepare_copy_state", "Could not set allow bom for destination");
      goto LABEL_225;
    }
    v37 = *(NSObject **)(a1 + 13000);
    if (v37 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_206367000, v37, OS_LOG_TYPE_DEFAULT, "Set allow bom with destination", buf, 2u);
    }
  }
  v38 = *(_QWORD *)(a1 + 13048);
  if (v38)
  {
    if (BOMCopierDestinationSetDenyBom(*v35, v38, &v108))
    {
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 844, (uint64_t)"prepare_copy_state", "Could not set deny bom for destination");
      goto LABEL_225;
    }
    v39 = *(NSObject **)(a1 + 13000);
    if (v39 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_206367000, v39, OS_LOG_TYPE_DEFAULT, "Set deny bom with destination", buf, 2u);
    }
  }
  if (v8[1440])
  {
    v40 = *(_QWORD *)(a1 + 13040);
    if (!v40)
    {
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 855, (uint64_t)"prepare_copy_state", "The client did not provide an index bom to use for enumeration");
      goto LABEL_225;
    }
    if (BOMCopierSourceSetEnumerationBom(*(_QWORD *)(a1 + 13016), v40, &v108))
    {
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 862, (uint64_t)"prepare_copy_state", "Could not set enumeration bom for source");
      goto LABEL_225;
    }
    v41 = *(NSObject **)(a1 + 13000);
    if (v41 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_206367000, v41, OS_LOG_TYPE_DEFAULT, "Set enumeration bom with source", buf, 2u);
    }
  }
  if (v8[1441])
  {
    v42 = *(_QWORD *)(a1 + 13040);
    if (!v42)
    {
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 873, (uint64_t)"prepare_copy_state", "The client did not provide an index bom to use for checksum validation");
      goto LABEL_225;
    }
    if (BOMCopierDestinationSetChecksumBom(*v35, v42, &v108))
    {
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 880, (uint64_t)"prepare_copy_state", "Could not set checksum bom for destination");
      goto LABEL_225;
    }
    v43 = *(NSObject **)(a1 + 13000);
    if (v43 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_206367000, v43, OS_LOG_TYPE_DEFAULT, "Set enumeration bom with destination", buf, 2u);
    }
  }
  if (BOMCopierDestinationSetConflictResolver(*(_QWORD *)(a1 + 13032), (uint64_t)conflict_resolver, a1, &v108))
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 894, (uint64_t)"prepare_copy_state", "Could not set conflict resolver");
    goto LABEL_225;
  }
  if (BOMCopierDestinationSetDataWrittenCallback(*(_QWORD *)(a1 + 13032), (uint64_t)data_written_callback, a1, &v108))
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 905, (uint64_t)"prepare_copy_state", "Could not set data written callback");
    goto LABEL_225;
  }
  if (BOMCopierDestinationSetFinalizationCallback(*(_QWORD *)(a1 + 13032), (uint64_t)finalization_callback, a1, &v108))
  {
    BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 916, (uint64_t)"prepare_copy_state", "Could not set finalization callback");
    goto LABEL_225;
  }
  v14 = *(_QWORD *)(a1 + 13000);
  if (v14 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_206367000, (os_log_t)v14, OS_LOG_TYPE_DEFAULT, "Copy state prepared", buf, 2u);
    v14 = *(_QWORD *)(a1 + 13000);
  }
  bzero(buf, 0x430uLL);
  *(_DWORD *)buf = 1;
  v50 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)&buf[8] = a1 + 13032;
  v112 = v50;
  v51 = *(int *)(a1 + 16);
  v52 = *(_QWORD *)(a1 + 24);
  v114 = *(_QWORD *)(a1 + 32);
  v115 = v52;
  v113 = v51;
  if (v14 && os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v109 = 0;
    _os_log_impl(&dword_206367000, (os_log_t)v14, OS_LOG_TYPE_DEFAULT, "Starting copy", v109, 2u);
  }
  while (1)
  {
    v53 = *(NSObject **)(a1 + 13000);
    if (*(_BYTE *)(a1 + 168) == 1)
    {
      if (v53 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v109 = 0;
        v96 = "Client cancelled";
        v14 = 2;
        v97 = v53;
LABEL_245:
        _os_log_impl(&dword_206367000, v97, OS_LOG_TYPE_DEFAULT, v96, v109, 2u);
        goto LABEL_227;
      }
LABEL_274:
      v14 = 2;
      goto LABEL_227;
    }
    if (v53 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v109 = 0;
      _os_log_impl(&dword_206367000, v53, OS_LOG_TYPE_DEFAULT, "Retrieving the next source entry", v109, 2u);
    }
    v54 = BOMCopierSourceNext(*(_QWORD *)(a1 + 13016), &v108, v44, v45, v46, v47, v48, v49);
    v55 = (unsigned int *)v54;
    if (v108)
    {
      if (v54)
        BOMCopierSourceEntryFree((unsigned int *)v54);
      v14 = 1;
      BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 249, (uint64_t)"BOMCopierCopyWithOptions2", "Could not copy from %s to %s: %s", a2);
      goto LABEL_226;
    }
    if (!v54)
      break;
    Type = BOMCopierSourceEntryGetType((uint64_t)v54);
    if (Type == 6)
    {
      Mode = BOMCopierSourceEntryGetMode((uint64_t)v55);
      if ((Mode & 0x80) == 0)
        BOMCopierSourceEntrySetMode((uint64_t)v55, Mode | 0x80);
      goto LABEL_163;
    }
    if (Type == 8)
    {
      if (*(_DWORD *)(a1 + 12712) || !BOMCopierSourceEntryCheckAccess((uint64_t)v55, 0))
        goto LABEL_163;
      Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v55);
      v107 = 0;
      asprintf(&v107, "%s/%s", a2, Path);
      v90 = v107;
      if (!v107)
      {
        v93 = *__error();
        v94 = __error();
        v105 = strerror(*v94);
        BOMCopierErrorCapture(&v108, v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 358, (uint64_t)"BOMCopierCopyWithOptions2", "Could not create error path: %s", v105);
        goto LABEL_208;
      }
      v8[1443] = 1;
      v91 = __error();
      v92 = notify_file_error(a1, (uint64_t)v90, *v91);
      free(v107);
      if (v92 != 1)
      {
LABEL_214:
        BOMCopierSourceEntryFree(v55);
        release_copy_state_0(a1);
        v14 = 2;
        v61 = 1;
        goto LABEL_215;
      }
      v60 = *(NSObject **)(a1 + 13000);
      if (!v60 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
        goto LABEL_158;
LABEL_157:
      *(_DWORD *)v109 = 136315138;
      v110 = Path;
      _os_log_impl(&dword_206367000, v60, OS_LOG_TYPE_DEFAULT, "Skipping %s", v109, 0xCu);
LABEL_158:
      BOMCopierSourceEntryFree(v55);
      v61 = 2;
LABEL_215:
      if (v61 != 2)
        return v14;
    }
    else
    {
      if (Type <= 2)
      {
        Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v55);
        v107 = 0;
        asprintf(&v107, "%s/%s", a2, Path);
        v58 = v107;
        if (v107)
        {
          v8[1443] = 1;
          v59 = notify_file_error(a1, (uint64_t)v58, 13);
          free(v107);
          if (v59 != 1)
            goto LABEL_214;
          v60 = *(NSObject **)(a1 + 13000);
          if (!v60 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
            goto LABEL_158;
          goto LABEL_157;
        }
        v88 = *__error();
        v89 = __error();
        v104 = strerror(*v89);
        BOMCopierErrorCapture(&v108, v88, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 290, (uint64_t)"BOMCopierCopyWithOptions2", "Could not create error path: %s", v104);
LABEL_208:
        v61 = 1;
        v14 = 1;
        goto LABEL_215;
      }
LABEL_163:
      *v8 = 0;
      v8[1025] = 0;
      if (!*(_QWORD *)(a1 + 88))
        goto LABEL_169;
      v63 = BOMCopierSourceEntryGetPath((uint64_t)v55);
      v64 = BOMCopierSourceEntryGetType((uint64_t)v55);
      Size = BOMCopierSourceEntryGetSize((uint64_t)v55);
      if ((v64 - 5) > 5)
        v66 = 0;
      else
        v66 = dword_2063D0598[v64 - 5];
      v67 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(a1, v63, v66, Size);
      if (v67 == 1)
      {
        v85 = *(NSObject **)(a1 + 13000);
        if (v85 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v109 = 0;
          _os_log_impl(&dword_206367000, v85, OS_LOG_TYPE_DEFAULT, "Client skipped source entry", v109, 2u);
        }
        BOMCopierSourceEntryFree(v55);
      }
      else
      {
        if (v67 == 2)
        {
          v99 = *(NSObject **)(a1 + 13000);
          if (v99 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            v100 = "Client cancelled";
LABEL_272:
            _os_log_impl(&dword_206367000, v99, OS_LOG_TYPE_DEFAULT, v100, v109, 2u);
          }
LABEL_273:
          BOMCopierSourceEntryFree(v55);
          goto LABEL_274;
        }
LABEL_169:
        if (*(_BYTE *)(a1 + 168) == 1)
        {
          v99 = *(NSObject **)(a1 + 13000);
          if (v99 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            v100 = "Client cancelled";
            goto LABEL_272;
          }
          goto LABEL_273;
        }
        if (v8[1025] == 1)
        {
          v68 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v55);
          if (!v68)
          {
            v14 = 1;
            BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 460, (uint64_t)"BOMCopierCopyWithOptions2", "Could not get path for redirected source entry", v103, v106);
            goto LABEL_226;
          }
          v69 = strdup(v68);
          if (!v69)
          {
            v14 = 1;
            BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 468, (uint64_t)"BOMCopierCopyWithOptions2", "Could not duplicate path for redirected source entry", v103, v106);
            goto LABEL_226;
          }
          v70 = v69;
          BOMCopierSourceEntryFree(v55);
          if (BOMCopierSourceSetRedirectCallback(*(_QWORD *)(a1 + 13016), (uint64_t)source_redirection_callback, a1, &v108))
          {
            v14 = 1;
            BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 478, (uint64_t)"BOMCopierCopyWithOptions2", "Could not set source redirect callback", v103, v106);
            goto LABEL_268;
          }
          v77 = BOMCopierSourceNext(*(_QWORD *)(a1 + 13016), &v108, v71, v72, v73, v74, v75, v76);
          v55 = (unsigned int *)v77;
          if (v108)
          {
            if (v77)
              BOMCopierSourceEntryFree((unsigned int *)v77);
            v14 = 1;
            BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 493, (uint64_t)"BOMCopierCopyWithOptions2", "Could not copy from %s to %s: %s", a2);
LABEL_268:
            free(v70);
LABEL_226:
            notify_fatal_error(a1, v108);
            goto LABEL_227;
          }
          if (!v77)
          {
            free(v70);
            goto LABEL_258;
          }
          if (BOMCopierSourceEntrySetPath(v77, v70))
          {
            v14 = 1;
            BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 510, (uint64_t)"BOMCopierCopyWithOptions2", "Could not set the saved entry path");
            goto LABEL_268;
          }
          free(v70);
        }
        if (*v8 != 1)
          goto LABEL_183;
        if (BOMCopierDestinationSetRedirectCallback(*(_QWORD *)(a1 + 13032), (uint64_t)destination_redirection_callback, a1, &v108))
        {
          v14 = 1;
          BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 530, (uint64_t)"BOMCopierCopyWithOptions2", "Could not set destination redirect callback");
          notify_fatal_error(a1, v108);
          goto LABEL_253;
        }
        v78 = *(NSObject **)(a1 + 13000);
        if (v78)
        {
          if (os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            _os_log_impl(&dword_206367000, v78, OS_LOG_TYPE_DEFAULT, "Set destination redirect callback", v109, 2u);
LABEL_183:
            v78 = *(NSObject **)(a1 + 13000);
            if (!v78)
              goto LABEL_186;
          }
          if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            _os_log_impl(&dword_206367000, v78, OS_LOG_TYPE_DEFAULT, "Copying source entry to destination set", v109, 2u);
          }
        }
LABEL_186:
        v79 = BOMCopierSourceEntryGetPath((uint64_t)v55);
        v80 = *(NSObject **)(a1 + 13000);
        if (v80)
        {
          v81 = v79;
          if (os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v109 = 136315138;
            v110 = (const char *)v81;
            _os_log_impl(&dword_206367000, v80, OS_LOG_TYPE_DEFAULT, " %s", v109, 0xCu);
          }
        }
        if (BOMCopierCopySourceEntryToDestinationSet((uint64_t)v55, (unsigned int *)buf, &v108))
        {
          v14 = 1;
          BOMCopierErrorCapture(&v108, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 550, (uint64_t)"BOMCopierCopyWithOptions2", "Could not copy from %s to %s: %s", a2, a3, (const char *)0x8200102);
          notify_fatal_file_error(a1, (uint64_t)v55, v108);
LABEL_253:
          BOMCopierSourceEntryFree(v55);
          goto LABEL_227;
        }
        switch(BOMCopierDestinationGetCopyOperation(*v35))
        {
          case 0u:
            v82 = *(NSObject **)(a1 + 13000);
            if (!v82 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
              goto LABEL_205;
            *(_WORD *)v109 = 0;
            v83 = v82;
            v84 = "Source entry copied to destination set\n";
            break;
          case 1u:
            v86 = *(NSObject **)(a1 + 13000);
            if (!v86 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
              goto LABEL_205;
            *(_WORD *)v109 = 0;
            v83 = v86;
            v84 = "Source entry skipped\n";
            break;
          case 2u:
            v99 = *(NSObject **)(a1 + 13000);
            if (!v99 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
              goto LABEL_273;
            *(_WORD *)v109 = 0;
            v100 = "Client cancelled\n";
            goto LABEL_272;
          case 3u:
            v87 = *(NSObject **)(a1 + 13000);
            if (!v87 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
              goto LABEL_205;
            *(_WORD *)v109 = 0;
            v83 = v87;
            v84 = "Source entry retry?\n";
            break;
          default:
            goto LABEL_205;
        }
        _os_log_impl(&dword_206367000, v83, OS_LOG_TYPE_DEFAULT, v84, v109, 2u);
LABEL_205:
        BOMCopierSourceEntryFree(v55);
        if (*(_BYTE *)(a1 + 168) == 1)
        {
          v101 = *(NSObject **)(a1 + 13000);
          if (v101 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            v96 = "Client cancelled\n";
            v14 = 2;
            v97 = v101;
            goto LABEL_245;
          }
          goto LABEL_274;
        }
      }
    }
  }
  v98 = *(NSObject **)(a1 + 13000);
  if (v98 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v109 = 0;
    _os_log_impl(&dword_206367000, v98, OS_LOG_TYPE_DEFAULT, "Source exhausted", v109, 2u);
  }
LABEL_258:
  v102 = *(NSObject **)(a1 + 13000);
  if (v8[1443])
  {
    if (v102 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v109 = 0;
      _os_log_impl(&dword_206367000, v102, OS_LOG_TYPE_DEFAULT, "Copy complete but a file error occurred", v109, 2u);
    }
    v14 = 1;
  }
  else
  {
    if (v102)
    {
      v14 = 0;
      if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
        goto LABEL_227;
      *(_WORD *)v109 = 0;
      _os_log_impl(&dword_206367000, v102, OS_LOG_TYPE_DEFAULT, "Copy successful", v109, 2u);
    }
    v14 = 0;
  }
LABEL_227:
  release_copy_state_0(a1);
  return v14;
}

void notify_fatal_error(uint64_t a1, _QWORD *a2)
{
  uint64_t Message;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  NSObject *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    Message = BOMCopierErrorGetMessage((uint64_t)a2);
    if (Message)
    {
      v5 = Message;
      v6 = *(void (**)(uint64_t, uint64_t))(a1 + 56);
      if (v6)
        v6(a1, Message);
      v7 = *(NSObject **)(a1 + 13000);
      if (v7)
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8 = 136315138;
          v9 = v5;
          _os_log_impl(&dword_206367000, v7, OS_LOG_TYPE_DEFAULT, "fatal error: %s", (uint8_t *)&v8, 0xCu);
        }
      }
    }
    BOMCopierErrorFree(a2);
  }
}

void release_copy_state_0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  const void *v5;
  void *v6;
  const void *v7;

  v2 = *(_QWORD *)(a1 + 13048);
  if (v2)
  {
    BOMBomFree(v2);
    *(_QWORD *)(a1 + 13048) = 0;
  }
  v3 = *(_QWORD *)(a1 + 13040);
  if (v3)
  {
    BOMBomFree(v3);
    *(_QWORD *)(a1 + 13040) = 0;
  }
  v4 = *(unsigned int **)(a1 + 13032);
  if (v4)
  {
    BOMCopierDestinationFree(v4);
    *(_QWORD *)(a1 + 13032) = 0;
  }
  v5 = *(const void **)(a1 + 13024);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 13024) = 0;
  }
  v6 = *(void **)(a1 + 13016);
  if (v6)
  {
    BOMCopierSourceFree(v6);
    *(_QWORD *)(a1 + 13016) = 0;
  }
  v7 = *(const void **)(a1 + 13008);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 13008) = 0;
  }
  *(_BYTE *)(a1 + 13059) = 0;
}

uint64_t notify_file_error(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  NSObject *v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  int v15;
  __int16 v16;
  char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  v3 = a3;
  v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 72);
  if (v6)
  {
    v7 = v6(a1, a2, a3);
    if (v7 == 1)
      v8 = 0;
    else
      v8 = v7;
    if (v7)
      v9 = v8;
    else
      v9 = 1;
  }
  else
  {
    v9 = 1;
  }
  v10 = *(NSObject **)(a1 + 13000);
  if (v10 && os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 136315906;
    v13 = a2;
    v14 = 1024;
    v15 = v3;
    v16 = 2080;
    v17 = strerror(v3);
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_206367000, v10, OS_LOG_TYPE_DEFAULT, "file error: %s %d (%s) [%u]", (uint8_t *)&v12, 0x22u);
  }
  return v9;
}

void source_redirection_callback(uint64_t a1, char **a2, uint64_t a3)
{
  char *v4;

  if (a3)
  {
    v4 = strdup((const char *)(a3 + 11617));
    if (v4)
      *a2 = v4;
  }
}

void destination_redirection_callback(uint64_t a1, char **a2, uint64_t a3)
{
  char *v4;

  if (a3)
  {
    v4 = strdup((const char *)(a3 + 10592));
    if (v4)
      *a2 = v4;
  }
}

void notify_fatal_file_error(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t ActualPath;
  uint64_t Code;
  uint64_t Message;
  void (*v8)(uint64_t, uint64_t, uint64_t);
  NSObject *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  __int16 v14;
  char *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    ActualPath = BOMCopierSourceEntryGetActualPath(a2);
    Code = BOMCopierErrorGetCode((uint64_t)a3);
    Message = BOMCopierErrorGetMessage((uint64_t)a3);
    v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
    if (v8)
      v8(a1, ActualPath, Code);
    v9 = *(NSObject **)(a1 + 13000);
    if (v9)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = 136315906;
        v11 = ActualPath;
        v12 = 1024;
        v13 = Code;
        v14 = 2080;
        v15 = strerror(Code);
        v16 = 2080;
        v17 = Message;
        _os_log_impl(&dword_206367000, v9, OS_LOG_TYPE_DEFAULT, "fatal file error: %s %d (%s) [%s]", (uint8_t *)&v10, 0x26u);
      }
    }
    BOMCopierErrorFree(a3);
  }
}

uint64_t parse_copier_options(uint64_t a1, const __CFDictionary *a2, _QWORD *a3)
{
  CFTypeID TypeID;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  const void *Value;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  CFNumberRef v23;
  uint64_t v24;
  int v25;
  CFNumberRef v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  CFNumberRef v32;
  CFNumberRef v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  _BOOL4 v48;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  NSObject *v53;
  NSObject *v54;
  int v55;
  int v56;
  int v57;
  char *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  const void *v64;
  const void *v65;
  const void *v66;
  const __CFDictionary *v67;
  const __CFDictionary *v68;
  const void *v69;
  const void *v70;
  const __CFString *v71;
  const __CFString *v72;
  CFIndex v73;
  char *v74;
  const __CFString *v75;
  const __CFString *v76;
  CFIndex v77;
  char *v78;
  BOOL *v79;
  const void *v80;
  const void *v81;
  const void *v82;
  const void *v83;
  const void *v84;
  const void *v85;
  const void *v86;
  const void *v87;
  const __CFArray *v88;
  const __CFArray *v89;
  const void *v90;
  const void *v91;
  const void *v92;
  const void *v93;
  const void *v94;
  const void *v95;
  const void *v96;
  const void *v97;
  const void *v98;
  const void *v99;
  CFNumberRef v100;
  CFNumberRef v101;
  const void *v102;
  const void *v103;
  const void *v104;
  const void *v105;
  const void *v106;
  const void *v107;
  NSObject *v108;
  const char *v109;
  NSObject *v110;
  const char *v111;
  NSObject *v112;
  const char *v113;
  NSObject *v114;
  const char *v115;
  NSObject *v116;
  const char *v117;
  NSObject *v118;
  const char *v119;
  NSObject *v120;
  const char *v121;
  NSObject *v122;
  const char *v123;
  NSObject *v124;
  const char *v125;
  NSObject *v126;
  int v127;
  const char *v128;
  NSObject *v129;
  const char *v130;
  NSObject *v131;
  const char *v132;
  NSObject *v133;
  const char *v134;
  NSObject *v135;
  int v136;
  const char *v137;
  NSObject *v138;
  char *v139;
  const char *v140;
  NSObject *v141;
  char *v142;
  const char *v143;
  NSObject *v144;
  const char *v145;
  NSObject *v146;
  NSObject *v147;
  const char *v148;
  NSObject *v149;
  _BOOL4 v150;
  NSObject *v151;
  const char *v152;
  int v153;
  CFNumberRef v154;
  CFNumberRef v155;
  const void *v156;
  const void *v157;
  const void *v158;
  const void *v159;
  const void *v160;
  const void *v161;
  const void *v162;
  const void *v163;
  const void *v164;
  const void *v165;
  const void *v166;
  const void *v167;
  const void *v168;
  const void *v169;
  const void *v170;
  const void *v171;
  const void *v172;
  const void *v173;
  const void *v174;
  const void *v175;
  const void *v176;
  const void *v177;
  const void *v178;
  const void *v179;
  const void *v180;
  const void *v181;
  const void *v182;
  CFNumberRef v183;
  CFNumberRef v184;
  const void *v185;
  const void *v186;
  const void *v187;
  const void *v188;
  const void *v189;
  const void *v190;
  const void *v191;
  const void *v192;
  const void *v193;
  const void *v194;
  const void *v195;
  const void *v196;
  const void *v197;
  const void *v198;
  const void *v199;
  const void *v200;
  const __CFData *v201;
  const __CFData *v202;
  int v204;
  uint64_t v205;
  __int128 v206;
  uint64_t v207;
  uint64_t v208;
  __int128 v209;
  _BOOL4 v210;
  uint64_t v211;
  char *buffer;
  CFTypeID v213;
  CFTypeID v214;
  CFTypeID v215;
  uint8_t valuePtr[24];
  uint64_t v217;

  v217 = *MEMORY[0x24BDAC8D0];
  TypeID = CFBooleanGetTypeID();
  v7 = CFStringGetTypeID();
  v215 = CFDictionaryGetTypeID();
  v8 = CFNumberGetTypeID();
  v9 = CFWriteStreamGetTypeID();
  v10 = CFReadStreamGetTypeID();
  v214 = CFArrayGetTypeID();
  v11 = CFDataGetTypeID();
  *(_QWORD *)(a1 + 12712) = 0x300000000;
  Value = CFDictionaryGetValue(a2, CFSTR("inputFD"));
  if (Value)
  {
    v13 = Value;
    if (v8 != CFGetTypeID(Value))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 972, (uint64_t)"parse_copier_options", "kBOMCopierOptionInputFileDescriptorKey must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("inputFD"), v13);
  }
  v14 = CFDictionaryGetValue(a2, CFSTR("zipFileEncryptionKey"));
  if (v14)
  {
    v15 = v14;
    if (v7 != CFGetTypeID(v14))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1005, (uint64_t)"parse_copier_options", "kBOMCopierOptionEncryptionKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("passphrase"), v15);
  }
  v213 = v11;
  v16 = CFDictionaryGetValue(a2, CFSTR("extractCPIO"));
  if (v16)
  {
    v17 = v16;
    if (TypeID != CFGetTypeID(v16))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1063, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractCPIOKey must be a CFBooleanRef");
      return v24;
    }
    v18 = (const void *)*MEMORY[0x24BDBD270];
    if (CFEqual(v17, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      *(_DWORD *)(a1 + 12712) = 1;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("extractLibarchive"), v18);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("replaySymlinks"), v18);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("replayDirectories"), v18);
    }
  }
  v19 = CFDictionaryGetValue(a2, CFSTR("createCPIO"));
  if (v19)
  {
    v20 = v19;
    if (TypeID != CFGetTypeID(v19))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1125, (uint64_t)"parse_copier_options", "kBOMCopierOptionCreateCPIOKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("createArchive"), v20);
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
      *(_DWORD *)(a1 + 12716) = 4;
  }
  v21 = CFDictionaryGetValue(a2, CFSTR("compressCPIO"));
  if (v21)
  {
    v22 = v21;
    if (TypeID == CFGetTypeID(v21))
    {
      if (CFEqual(v22, (CFTypeRef)*MEMORY[0x24BDBD270]) != 1 || *(_DWORD *)(a1 + 12716) != 4)
        goto LABEL_34;
      *(_DWORD *)valuePtr = 1;
      v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, valuePtr);
      if (!v23)
      {
        v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1184, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
        return v24;
      }
      goto LABEL_33;
    }
    if (v7 != CFGetTypeID(v22))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1227, (uint64_t)"parse_copier_options", "kBOMCopierOptionCompressCPIOKey must be a CFBooleanRef or CFStringRef");
      return v24;
    }
    if (CFEqual(v22, CFSTR("auto")))
      goto LABEL_27;
    if (CFEqual(v22, CFSTR("none")))
    {
      *(_DWORD *)valuePtr = 0;
LABEL_32:
      v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, valuePtr);
      if (!v23)
      {
        v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1219, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
        return v24;
      }
LABEL_33:
      v26 = v23;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("libarchiveFilter"), v23);
      CFRelease(v26);
      goto LABEL_34;
    }
    if (CFEqual(v22, CFSTR("gzip")))
    {
LABEL_27:
      v25 = 1;
    }
    else
    {
      if (!CFEqual(v22, CFSTR("bzip2")))
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1212, (uint64_t)"parse_copier_options", "Unknown compression type");
        return v24;
      }
      v25 = 2;
    }
    *(_DWORD *)valuePtr = v25;
    goto LABEL_32;
  }
LABEL_34:
  v27 = CFDictionaryGetValue(a2, CFSTR("extractPKZip"));
  if (v27)
  {
    v28 = v27;
    if (TypeID != CFGetTypeID(v27))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1274, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractPKZipKey must be a CFBooleanRef");
      return v24;
    }
    v29 = (const void *)*MEMORY[0x24BDBD270];
    if (CFEqual(v28, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1282, (uint64_t)"parse_copier_options", "The source type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12712) = 2;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("extractDataArchive"), v29);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("enforceArchiveEntryPermissions"), v29);
    }
  }
  v30 = CFDictionaryGetValue(a2, CFSTR("createPKZip"));
  if (v30)
  {
    v31 = v30;
    if (TypeID != CFGetTypeID(v30))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1328, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractPKZipKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("createArchive"), v31);
    if (CFEqual(v31, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1338, (uint64_t)"parse_copier_options", "The destination type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12716) = 5;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("excludeRootDirectory"), v31);
      *(_DWORD *)valuePtr = 327680;
      v32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, valuePtr);
      if (!v32)
      {
        v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1359, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
        return v24;
      }
      v33 = v32;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("libarchiveFormat"), v32);
      CFRelease(v33);
    }
  }
  v34 = CFDictionaryGetValue(a2, CFSTR("createAppleArchive"));
  if (v34)
  {
    v35 = v34;
    if (TypeID != CFGetTypeID(v34))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1377, (uint64_t)"parse_copier_options", "kBOMCopierOptionCreateAppleArchiveKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("createAppleArchive"), v35);
    if (CFEqual(v35, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1387, (uint64_t)"parse_copier_options", "The destination type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12716) = 6;
    }
  }
  v36 = CFDictionaryGetValue(a2, CFSTR("compressAppleArchive"));
  if (v36)
  {
    v37 = v36;
    if (v7 != CFGetTypeID(v36))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1400, (uint64_t)"parse_copier_options", "kBOMCopierOptionCompressAppleArchiveKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("compressAppleArchive"), v37);
  }
  v38 = CFDictionaryGetValue(a2, CFSTR("extractAppleArchive"));
  if (v38)
  {
    v39 = v38;
    if (TypeID != CFGetTypeID(v38))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1412, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractAppleArchiveKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("extractAppleArchive"), v39);
    if (CFEqual(v39, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1422, (uint64_t)"parse_copier_options", "The source type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12712) = 3;
    }
  }
  v40 = CFDictionaryGetValue(a2, CFSTR("crossDevices"));
  if (v40)
  {
    v41 = v40;
    if (TypeID != CFGetTypeID(v40))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1457, (uint64_t)"parse_copier_options", "kBOMCopierSourceOptionUseFilesystemCacheKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("crossDevices"), v41);
  }
  v42 = CFDictionaryGetValue(a2, CFSTR("useFilesystemCache"));
  if (v42)
  {
    v43 = v42;
    if (TypeID != CFGetTypeID(v42))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1502, (uint64_t)"parse_copier_options", "kBOMCopierOptionUseFilesystemCacheKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("useFilesystemCache"), v43);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("useFilesystemCache"), v43);
  }
  v44 = CFDictionaryGetValue(a2, CFSTR("applySourcePermissions"));
  if (v44)
  {
    v45 = v44;
    if (TypeID != CFGetTypeID(v44))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1541, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplySourcePermissionsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("applySourcePermissions"), v45);
  }
  v46 = CFDictionaryGetValue(a2, CFSTR("copyResources"));
  if (v46)
  {
    v47 = v46;
    if (TypeID != CFGetTypeID(v46))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1601, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyResourcesKey must be a CFBooleanRef");
      return v24;
    }
    v48 = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v47) != 0;
  }
  else
  {
    v48 = 0;
  }
  v49 = CFDictionaryGetValue(a2, CFSTR("copyExtendedAttributes"));
  if (v49)
  {
    v50 = v49;
    if (TypeID != CFGetTypeID(v49))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1642, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyExtendedAttributesKey must be a CFBooleanRef");
      return v24;
    }
    HIDWORD(v211) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v50) != 0;
  }
  else
  {
    HIDWORD(v211) = 0;
  }
  v51 = CFDictionaryGetValue(a2, CFSTR("copyACLs"));
  if (v51)
  {
    v52 = v51;
    if (TypeID != CFGetTypeID(v51))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1683, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyACLsKey must be a CFBooleanRef");
      return v24;
    }
    LODWORD(v211) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v52) != 0;
  }
  else
  {
    LODWORD(v211) = 0;
  }
  v53 = CFDictionaryGetValue(a2, CFSTR("sequesterResources"));
  v54 = v53;
  if (v53)
  {
    if (TypeID != CFGetTypeID(v53))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1720, (uint64_t)"parse_copier_options", "kBOMCopierOptionSequesterResourcesKey must be a CFBooleanRef");
      return v24;
    }
    LODWORD(v54) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v54) != 0;
  }
  v55 = *(_DWORD *)(a1 + 12712);
  v56 = *(_DWORD *)(a1 + 12716);
  if (v55)
  {
    if (v56 == 3)
    {
      if (v55 == 2)
      {
        *(_QWORD *)&v206 = 0;
        v208 = 0;
        v209 = 0uLL;
        v207 = 0;
        v210 = 0;
        v205 = v48 | 0x100000000;
        *((_QWORD *)&v206 + 1) = __PAIR64__(v48, v211);
        LODWORD(v54) = v48;
      }
      else
      {
        v205 = 0;
        *(_QWORD *)&v206 = 0;
        v208 = 0;
        *(_QWORD *)&v209 = 0;
        v207 = v48;
        if (v55 == 3)
        {
          v210 = v48;
          v57 = v211;
          *((_QWORD *)&v209 + 1) = v211;
          HIDWORD(v206) = v48;
        }
        else
        {
          v210 = 0;
          *((_QWORD *)&v209 + 1) = 0;
          HIDWORD(v206) = v48;
          v57 = v211;
        }
        DWORD2(v206) = v57;
      }
    }
    else
    {
      v206 = 0uLL;
      v208 = 0;
      v209 = 0uLL;
      v207 = 0;
      v210 = 0;
      LODWORD(v54) = 0;
      v205 = 0;
    }
  }
  else
  {
    if (v56 == 3)
    {
      LODWORD(v206) = 0;
      DWORD1(v206) = v48;
      v208 = 0;
      *(_QWORD *)&v209 = 0;
      *((_QWORD *)&v206 + 1) = 0;
      LODWORD(v54) = 0;
      v205 = 0;
      v207 = 0x100000000;
    }
    else
    {
      if (v56 != 6)
      {
        HIDWORD(v206) = 0;
        v207 = 0;
        v210 = 0;
        HIDWORD(v209) = 0;
        v205 = 0;
        LODWORD(v209) = v48 | v54;
        *(_QWORD *)((char *)&v209 + 4) = v48 | HIDWORD(v211) | v211 | v54;
        LODWORD(v208) = v211;
        HIDWORD(v208) = HIDWORD(v211) | v54;
        LODWORD(v206) = (_DWORD)v54;
        *(_QWORD *)((char *)&v206 + 4) = v48 | v54;
        LODWORD(v54) = 0;
        goto LABEL_119;
      }
      v206 = 0uLL;
      v208 = 0;
      *(_QWORD *)&v209 = 0;
      v207 = 0;
      LODWORD(v54) = 0;
      v205 = 0;
    }
    v210 = v48;
    *((_QWORD *)&v209 + 1) = v211;
  }
LABEL_119:
  v58 = getenv("BOMCOPIER_LOG_OPTION_RESULTS");
  if (!v58)
    goto LABEL_121;
  if (strcmp(v58, "1"))
    goto LABEL_121;
  v108 = *(NSObject **)(a1 + 13000);
  if (!v108)
    goto LABEL_121;
  v204 = (int)v54;
  v54 = *(NSObject **)(a1 + 13000);
  if (!os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
  {
    v110 = v54;
    goto LABEL_235;
  }
  v109 = "false";
  if (v48)
    v109 = "true";
  *(_DWORD *)valuePtr = 136315138;
  *(_QWORD *)&valuePtr[4] = v109;
  _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, "copy_resources: %s", valuePtr, 0xCu);
  v110 = *(NSObject **)(a1 + 13000);
  LODWORD(v54) = v204;
  if (v110)
  {
LABEL_235:
    v54 = v110;
    if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
    {
      v111 = "false";
      if (HIDWORD(v211))
        v111 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v111;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, "copy_extended_attributes: %s", valuePtr, 0xCu);
      v112 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v112)
        goto LABEL_121;
    }
    else
    {
      v112 = v54;
    }
    v54 = v112;
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
    {
      v113 = "false";
      if ((_DWORD)v211)
        v113 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v113;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, "copy_acls: %s", valuePtr, 0xCu);
      v114 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v114)
        goto LABEL_121;
    }
    else
    {
      v114 = v54;
    }
    v54 = v114;
    if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
    {
      v115 = "false";
      if (v210)
        v115 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v115;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " discover_resource_attributes: %s", valuePtr, 0xCu);
      v116 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v116)
        goto LABEL_121;
    }
    else
    {
      v116 = v54;
    }
    v54 = v116;
    if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
    {
      v117 = "false";
      if (HIDWORD(v209))
        v117 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v117;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " discover_extended_attributes: %s", valuePtr, 0xCu);
      v118 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v118)
        goto LABEL_121;
    }
    else
    {
      v118 = v54;
    }
    v54 = v118;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
    {
      v119 = "false";
      if (DWORD2(v209))
        v119 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v119;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " discover_acls: %s", valuePtr, 0xCu);
      v120 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v120)
        goto LABEL_121;
    }
    else
    {
      v120 = v54;
    }
    v54 = v120;
    if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
    {
      v121 = "false";
      if (DWORD1(v209))
        v121 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v121;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " synthesize_apple_doubles: %s", valuePtr, 0xCu);
      v122 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v122)
        goto LABEL_121;
    }
    else
    {
      v122 = v54;
    }
    v54 = v122;
    if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
    {
      v123 = "false";
      if ((_DWORD)v209)
        v123 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v123;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " capture_resource_attributes: %s", valuePtr, 0xCu);
      v124 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v124)
        goto LABEL_121;
    }
    else
    {
      v124 = v54;
    }
    v54 = v124;
    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
    {
      v125 = "false";
      if (HIDWORD(v208))
        v125 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v125;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " capture_extended_attributes: %s", valuePtr, 0xCu);
      v126 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v126)
        goto LABEL_121;
    }
    else
    {
      v126 = v54;
    }
    v54 = v126;
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      v128 = "false";
      if ((_DWORD)v208)
        v128 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v128;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " capture_acls: %s", valuePtr, 0xCu);
      v129 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v129)
        goto LABEL_121;
    }
    else
    {
      v129 = v54;
    }
    v54 = v129;
    if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
    {
      v130 = "false";
      if (HIDWORD(v207))
        v130 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v130;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " defer_apple_doubles: %s", valuePtr, 0xCu);
      v131 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v131)
        goto LABEL_121;
    }
    else
    {
      v131 = v54;
    }
    v54 = v131;
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
    {
      v132 = "false";
      if ((_DWORD)v207)
        v132 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v132;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " replay_apple_doubles: %s", valuePtr, 0xCu);
      v133 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v133)
        goto LABEL_121;
    }
    else
    {
      v133 = v54;
    }
    v54 = v133;
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      v134 = "false";
      if (HIDWORD(v206))
        v134 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v134;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " use_apple_double_suffix: %s", valuePtr, 0xCu);
      v135 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v135)
        goto LABEL_121;
    }
    else
    {
      v135 = v54;
    }
    v54 = v135;
    if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
    {
      v137 = "false";
      if (DWORD2(v206))
        v137 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v137;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " merge_acls: %s", valuePtr, 0xCu);
      v138 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v138)
        goto LABEL_121;
    }
    else
    {
      v138 = v54;
    }
    v54 = v138;
    if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
    {
      v140 = "false";
      if (DWORD1(v206))
        v140 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v140;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " ignore_apple_doubles: %s", valuePtr, 0xCu);
      v141 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v141)
        goto LABEL_121;
    }
    else
    {
      v141 = v54;
    }
    v54 = v141;
    if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
    {
      v143 = "false";
      if ((_DWORD)v206)
        v143 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v143;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " sequester_apple_doubles: %s", valuePtr, 0xCu);
      v144 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v144)
        goto LABEL_121;
    }
    else
    {
      v144 = v54;
    }
    v54 = v144;
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      v145 = "false";
      if (v204)
        v145 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v145;
      v146 = v54;
      LODWORD(v54) = v204;
      _os_log_impl(&dword_206367000, v146, OS_LOG_TYPE_DEFAULT, " unsequester_apple_doubles: %s", valuePtr, 0xCu);
      v147 = *(NSObject **)(a1 + 13000);
      if (!v147)
        goto LABEL_121;
    }
    else
    {
      v147 = v54;
    }
    v54 = v147;
    if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
    {
      v148 = "false";
      if (HIDWORD(v205))
        v148 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v148;
      _os_log_impl(&dword_206367000, v54, OS_LOG_TYPE_DEFAULT, " reorder_extra_files: %s", valuePtr, 0xCu);
      v149 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v149)
        goto LABEL_121;
    }
    else
    {
      v149 = v54;
    }
    v54 = v149;
    v150 = os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT);
    v151 = v54;
    LODWORD(v54) = v204;
    if (v150)
    {
      v152 = "false";
      if ((_DWORD)v205)
        v152 = "true";
      *(_DWORD *)valuePtr = 136315138;
      *(_QWORD *)&valuePtr[4] = v152;
      _os_log_impl(&dword_206367000, v151, OS_LOG_TYPE_DEFAULT, " convert_extra_apple_doubles: %s", valuePtr, 0xCu);
    }
  }
LABEL_121:
  if (v210)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverResourceAttribute"), (const void *)*MEMORY[0x24BDBD270]);
  if (HIDWORD(v209))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverExtendedAttributes"), (const void *)*MEMORY[0x24BDBD270]);
  if (DWORD2(v209))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverACLs"), (const void *)*MEMORY[0x24BDBD270]);
  if (DWORD1(v209))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("synthesizeAppleDoubles"), (const void *)*MEMORY[0x24BDBD270]);
  if ((_DWORD)v209)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("appleDoublesCaptureResourceAttributes"), (const void *)*MEMORY[0x24BDBD270]);
  if (HIDWORD(v208))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("appleDoublesCaptureExtendedAttributes"), (const void *)*MEMORY[0x24BDBD270]);
  if ((_DWORD)v208)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("appleDoublesCaptureACLs"), (const void *)*MEMORY[0x24BDBD270]);
  if (HIDWORD(v207))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("deferAppleDoubles"), (const void *)*MEMORY[0x24BDBD270]);
  if ((_DWORD)v207)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("replayAppleDoubles"), (const void *)*MEMORY[0x24BDBD270]);
  if (HIDWORD(v206))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("appleDoubleSuffix"), CFSTR("__"));
  if (DWORD2(v206))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("appleDoubleMergeACLs"), (const void *)*MEMORY[0x24BDBD270]);
  if (DWORD1(v206))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("ignoreAppleDoubles"), (const void *)*MEMORY[0x24BDBD270]);
  if ((_DWORD)v206)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("sequesterAppleDoubles"), (const void *)*MEMORY[0x24BDBD270]);
  if ((_DWORD)v54)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("unsequesterAppleDoubles"), (const void *)*MEMORY[0x24BDBD270]);
  if (HIDWORD(v205))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("reorderExtraEntries"), (const void *)*MEMORY[0x24BDBD270]);
  if ((_DWORD)v205)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("replayExtraAppleDoubles"), (const void *)*MEMORY[0x24BDBD270]);
  v59 = CFDictionaryGetValue(a2, CFSTR("copyQuarantine"));
  if (v59)
  {
    v60 = v59;
    if (TypeID != CFGetTypeID(v59))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2048, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyQuarantineKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverQuarantine"), v60);
  }
  v61 = CFDictionaryGetValue(a2, CFSTR("quarantineFilePath"));
  if (v61)
  {
    v62 = v61;
    if (v7 != CFGetTypeID(v61))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2089, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyQuarantineKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("replayQuarantineFromPath"), v62);
  }
  v63 = CFDictionaryGetValue(a2, CFSTR("useHFSPlusCompression"));
  if (v63)
  {
    v64 = v63;
    if (TypeID != CFGetTypeID(v63))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2121, (uint64_t)"parse_copier_options", "kBOMCopierOptionUseHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("useAppleFSCompression"), v64);
  }
  v65 = CFDictionaryGetValue(a2, CFSTR("preserveHFSPlusCompression"));
  if (v65)
  {
    v66 = v65;
    if (TypeID != CFGetTypeID(v65))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2152, (uint64_t)"parse_copier_options", "kBOMCopierOptionPreserveHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverCompressionAttributes"), v66);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("preserveAppleFSCompression"), v66);
  }
  v67 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("hfsPlusCompressionOptions"));
  if (v67)
  {
    v68 = v67;
    if (v215 != CFGetTypeID(v67))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2185, (uint64_t)"parse_copier_options", "kBOMCopierOptionPreserveHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }
    v69 = CFDictionaryGetValue(v68, CFSTR("CompressionTypes"));
    if (v69)
    {
      v70 = v69;
      if (v8 != CFGetTypeID(v69))
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2206, (uint64_t)"parse_copier_options", "CompressionTypes must be a CFNumberRef");
        return v24;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("AppleFSCompressionType"), v70);
    }
  }
  v71 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("indexbom"));
  if (v71)
  {
    v72 = v71;
    if (v7 != CFGetTypeID(v71))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2252, (uint64_t)"parse_copier_options", "kBOMCopierOptionIndexBomKey must be a CFStringRef");
      return v24;
    }
    v73 = CFStringGetLength(v72) + 1;
    buffer = (char *)malloc_type_calloc(1uLL, v73, 0x1E606EADuLL);
    if (!buffer)
    {
      v127 = *__error();
      BOMCopierErrorCapture(a3, v127, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2267, (uint64_t)"parse_copier_options", "Could not allocate %ld bytes for kBOMCopierOptionIndexBomKey");
      return 1;
    }
    if (!CFStringGetCString(v72, buffer, v73, 0x8000100u))
    {
      v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2274, (uint64_t)"parse_copier_options", "Could not convert kBOMCopierOptionIndexBomKey to UTF8 C string");
      goto LABEL_330;
    }
    v74 = BOMBomOpenWithSys(buffer, 0, 0);
    *(_QWORD *)(a1 + 13040) = v74;
    if (!v74)
    {
      v139 = buffer;
      v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2282, (uint64_t)"parse_copier_options", "Could not open allow bom at %s");
LABEL_346:
      v142 = v139;
      goto LABEL_347;
    }
    free(buffer);
  }
  v75 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("skipbom"));
  if (v75)
  {
    v76 = v75;
    if (v7 != CFGetTypeID(v75))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2319, (uint64_t)"parse_copier_options", "kBOMCopierOptionSkipBomKey must be a CFStringRef");
      return v24;
    }
    v77 = CFStringGetLength(v76) + 1;
    buffer = (char *)malloc_type_calloc(1uLL, v77, 0x943C7056uLL);
    if (buffer)
    {
      if (CFStringGetCString(v76, buffer, v77, 0x8000100u))
      {
        v78 = BOMBomOpenWithSys(buffer, 0, 0);
        *(_QWORD *)(a1 + 13048) = v78;
        if (v78)
        {
          free(buffer);
          goto LABEL_182;
        }
        v139 = buffer;
        v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2349, (uint64_t)"parse_copier_options", "Could not open deny bom at %s");
        goto LABEL_346;
      }
      v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2341, (uint64_t)"parse_copier_options", "Could not convert kBOMCopierOptionIndexBomKey to UTF8 C string");
LABEL_330:
      v142 = buffer;
LABEL_347:
      free(v142);
      return v24;
    }
    v136 = *__error();
    BOMCopierErrorCapture(a3, v136, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2334, (uint64_t)"parse_copier_options", "Could not allocate %ld bytes for kBOMCopierOptionIndexBomKey");
    return 1;
  }
LABEL_182:
  v79 = (BOOL *)(a1 + 13056);
  v80 = CFDictionaryGetValue(a2, CFSTR("verifyFileDataPerIndexBom"));
  if (v80)
  {
    v81 = v80;
    if (TypeID != CFGetTypeID(v80))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2381, (uint64_t)"parse_copier_options", "kBOMCopierOptionVerifyFileDataPerIndexBomKey must be a CFStringRef");
      return v24;
    }
    *(_BYTE *)(a1 + 13057) = CFEqual(v81, (CFTypeRef)*MEMORY[0x24BDBD270]) != 0;
  }
  v82 = CFDictionaryGetValue(a2, CFSTR("outputFD"));
  if (v82)
  {
    v83 = v82;
    if (v8 != CFGetTypeID(v82))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2416, (uint64_t)"parse_copier_options", "kBOMCopierOptionOutputFileDescriptorKey must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("outputFD"), v83);
  }
  v84 = CFDictionaryGetValue(a2, CFSTR("outputStream"));
  if (v84)
  {
    v85 = v84;
    if (v9 != CFGetTypeID(v84))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2446, (uint64_t)"parse_copier_options", "kBOMCopierOptionOutputCFWriteStreamKey must be a CFWriteStream");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("outputStream"), v85);
  }
  v86 = CFDictionaryGetValue(a2, CFSTR("inputStream"));
  if (v86)
  {
    v87 = v86;
    if (v10 != CFGetTypeID(v86))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2477, (uint64_t)"parse_copier_options", "kBOMCopierOptionInputCFReadStreamKey must be a CFReadStream");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("inputStream"), v87);
  }
  v88 = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("archs"));
  if (v88)
  {
    v89 = v88;
    if (v214 != CFGetTypeID(v88))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2552, (uint64_t)"parse_copier_options", "kBOMCopierOptionArchitectureArrayKey must be a CFArrayRef");
      return v24;
    }
    if (!CFArrayGetCount(v89))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2560, (uint64_t)"parse_copier_options", "kBOMCopierOptionArchitectureArrayKey is empty");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverBinaries"), (const void *)*MEMORY[0x24BDBD270]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("archs"), v89);
  }
  v90 = CFDictionaryGetValue(a2, CFSTR("fallbackForSubtype"));
  if (v90)
  {
    v91 = v90;
    if (v215 != CFGetTypeID(v90))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2599, (uint64_t)"parse_copier_options", "kBOMCopierOptionArchitectureFallbackKey must be a CFDictionaryRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("fallbackForSubtype"), v91);
  }
  v92 = CFDictionaryGetValue(a2, CFSTR("keepBinaries"));
  if (v92)
  {
    v93 = v92;
    if (TypeID != CFGetTypeID(v92))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2638, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverBinaries"), v93);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("keepBinaries"), v93);
  }
  v94 = CFDictionaryGetValue(a2, CFSTR("keepBinariesList"));
  if (v94)
  {
    v95 = v94;
    if (v7 != CFGetTypeID(v94))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2670, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesListKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("keptFileList"), v95);
  }
  v96 = CFDictionaryGetValue(a2, CFSTR("keepBinariesPattern"));
  if (v96)
  {
    v97 = v96;
    if (v7 != CFGetTypeID(v96))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2701, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesPatternKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("keepFilePattern"), v97);
  }
  v98 = CFDictionaryGetValue(a2, CFSTR("keepBinariesDir"));
  if (v98)
  {
    v99 = v98;
    if (v7 != CFGetTypeID(v98))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2721, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesDirKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("keptFileDirectory"), v99);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("balanceKeptFiles"), (const void *)*MEMORY[0x24BDBD270]);
    *(_DWORD *)valuePtr = 50;
    v100 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, valuePtr);
    if (!v100)
    {
      v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2734, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
      return v24;
    }
    v101 = v100;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("keptFileBalanceLimit"), v100);
    CFRelease(v101);
  }
  v102 = CFDictionaryGetValue(a2, CFSTR("keepParent"));
  if (v102)
  {
    v103 = v102;
    if (TypeID != CFGetTypeID(v102))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2787, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepParentKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("keepParent"), v103);
  }
  v104 = CFDictionaryGetValue(a2, CFSTR("zlibCompressionLevel"));
  if (v104)
  {
    v105 = v104;
    if (v8 != CFGetTypeID(v104))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2822, (uint64_t)"parse_copier_options", "kBOMCopierOptionZlibCompressionLevel must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("zlibCompressionLevel"), v105);
  }
  v106 = CFDictionaryGetValue(a2, CFSTR("compress"));
  if (v106)
  {
    v107 = v106;
    if (v7 != CFGetTypeID(v106))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2851, (uint64_t)"parse_copier_options", "kBOMCopierOptionCompressDeprecatedKey must be a CFStringRef");
      return v24;
    }
    *(_DWORD *)valuePtr = 1;
    if (CFEqual(v107, CFSTR("none")) == 1)
    {
      *(_DWORD *)valuePtr = 0;
    }
    else
    {
      if (CFEqual(v107, CFSTR("auto")) == 1 || CFEqual(v107, CFSTR("gzip")) == 1)
      {
        v153 = 1;
      }
      else
      {
        if (CFEqual(v107, CFSTR("bzip2")) != 1)
        {
          v24 = 22;
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2871, (uint64_t)"parse_copier_options", "Unknown deprecated compression option");
          return v24;
        }
        v153 = 2;
      }
      *(_DWORD *)valuePtr = v153;
    }
    v154 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, valuePtr);
    if (!v154)
    {
      v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2878, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
      return v24;
    }
    v155 = v154;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("libarchiveFilter"), v154);
    CFRelease(v155);
  }
  v156 = CFDictionaryGetValue(a2, CFSTR("symlinkTreatment"));
  if (v156)
  {
    v157 = v156;
    if (v7 != CFGetTypeID(v156))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2925, (uint64_t)"parse_copier_options", "kBOMCopierOptionSymlinkTreatmentKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("symlinkTreatment"), v157);
  }
  v158 = CFDictionaryGetValue(a2, CFSTR("enforceDestinationEncapsulation"));
  if (v158)
  {
    v159 = v158;
    if (TypeID != CFGetTypeID(v158))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2964, (uint64_t)"parse_copier_options", "kBOMCopierOptionEnforceDestinationEncapsulationKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("enforceDestinationEncapsulation"), v159);
  }
  v160 = CFDictionaryGetValue(a2, CFSTR("enforceDestinationLocation"));
  if (v160)
  {
    v161 = v160;
    if (TypeID != CFGetTypeID(v160))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2988, (uint64_t)"parse_copier_options", "kBOMCopierOptionEnforceDestinationLocationKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("enforceDestinationLocation"), v161);
  }
  v162 = CFDictionaryGetValue(a2, CFSTR("nonatomicCopy"));
  if (v162)
  {
    v163 = v162;
    if (TypeID != CFGetTypeID(v162))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3037, (uint64_t)"parse_copier_options", "kBOMCopierOptionNonAtomicCopyKey must be a CFBooleanRef");
      return v24;
    }
    v164 = (const void *)*MEMORY[0x24BDBD270];
    if (CFEqual(v163, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("replaySymlinks"), v164);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("enableAtomicCopies"), (const void *)*MEMORY[0x24BDBD268]);
    }
  }
  v165 = CFDictionaryGetValue(a2, CFSTR("applyIndexBomOwnership"));
  if (v165)
  {
    v166 = v165;
    if (TypeID != CFGetTypeID(v165))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3076, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplyIndexBomOwnershipKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("applyBomOwnership"), v166);
    if (*(_QWORD *)(a1 + 13040))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("useEnumerationBom"), v166);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("allowAccessFailures"), v166);
      *v79 = CFEqual(v166, (CFTypeRef)*MEMORY[0x24BDBD270]) != 0;
    }
  }
  v167 = CFDictionaryGetValue(a2, CFSTR("sourceIsAppSandboxed"));
  if (v167)
  {
    v168 = v167;
    if (TypeID != CFGetTypeID(v167))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3124, (uint64_t)"parse_copier_options", "kBOMCopierOptionSourceIsAppSandboxed must be a CFBooleanRef");
      return v24;
    }
    if (*(_QWORD *)(a1 + 13040))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("useEnumerationBom"), v168);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("allowAccessFailures"), v168);
      *v79 = CFEqual(v168, (CFTypeRef)*MEMORY[0x24BDBD270]) != 0;
    }
  }
  v169 = CFDictionaryGetValue(a2, CFSTR("persistRestrictedFlags"));
  if (v169)
  {
    v170 = v169;
    if (TypeID != CFGetTypeID(v169))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3169, (uint64_t)"parse_copier_options", "kBOMCopierOptionPersistRestrictedFlagsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("persistRestrictedFlags"), v170);
  }
  v171 = CFDictionaryGetValue(a2, CFSTR("preserveRestrictedFlags"));
  if (v171)
  {
    v172 = v171;
    if (TypeID != CFGetTypeID(v171))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3200, (uint64_t)"parse_copier_options", "kBOMCopierOptionPreserveRestrictedFlagsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("preserveRestrictedFlags"), v172);
  }
  v173 = CFDictionaryGetValue(a2, CFSTR("persistRootlessEAs"));
  if (v173)
  {
    v174 = v173;
    if (TypeID != CFGetTypeID(v173))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3233, (uint64_t)"parse_copier_options", "kBOMCopierOptionPersistRootlessExtendedAttributesKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("persistRootless"), v174);
  }
  v175 = CFDictionaryGetValue(a2, CFSTR("initialCPIOInode"));
  if (v175)
  {
    v176 = v175;
    if (v8 != CFGetTypeID(v175))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3266, (uint64_t)"parse_copier_options", "kBOMCopierOptionInitialCPIOInodeRootKey must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("initialInode"), v176);
  }
  v177 = CFDictionaryGetValue(a2, CFSTR("skipCPIORoot"));
  if (v177)
  {
    v178 = v177;
    if (TypeID != CFGetTypeID(v177))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3298, (uint64_t)"parse_copier_options", "kBOMCopierOptionSkipCPIORootKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("skipRootDirectory"), v178);
  }
  v179 = CFDictionaryGetValue(a2, CFSTR("skipCPIOTerminator"));
  if (v179)
  {
    v180 = v179;
    if (TypeID != CFGetTypeID(v179))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3326, (uint64_t)"parse_copier_options", "kBOMCopierOptionSkipCPIOTerminatorKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("skipTerminator"), v180);
  }
  v181 = CFDictionaryGetValue(a2, CFSTR("segmentLargeFiles"));
  if (v181)
  {
    v182 = v181;
    if (TypeID != CFGetTypeID(v181))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3364, (uint64_t)"parse_copier_options", "kBOMCopierOptionSegmentLargeFilesKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), CFSTR("discoverSegmentedFiles"), v182);
    if (CFEqual(v182, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      *(_QWORD *)valuePtr = 0x40000000;
      v183 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberLongLongType, valuePtr);
      if (!v183)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3377, (uint64_t)"parse_copier_options", "Could not create number for %lld", *(_QWORD *)valuePtr);
        return 22;
      }
      v184 = v183;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("segmentFileSize"), v183);
      CFRelease(v184);
    }
  }
  v185 = CFDictionaryGetValue(a2, CFSTR("enableLogging"));
  if (v185)
  {
    v186 = v185;
    if (TypeID != CFGetTypeID(v185))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3391, (uint64_t)"parse_copier_options", "kBOMCopierOptionEnableLogging must be a CFBooleanRef");
      return v24;
    }
    *(_BYTE *)(a1 + 13058) = CFEqual((CFTypeRef)*MEMORY[0x24BDBD270], v186) != 0;
  }
  v187 = CFDictionaryGetValue(a2, CFSTR("output2Nowhere"));
  if (v187)
  {
    v188 = v187;
    if (TypeID != CFGetTypeID(v187))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3403, (uint64_t)"parse_copier_options", "kBOMCopierOptionOutputNowhereKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("output2Nowhere"), v188);
  }
  v189 = CFDictionaryGetValue(a2, CFSTR("cloneFiles"));
  if (v189)
  {
    v190 = v189;
    if (TypeID != CFGetTypeID(v189))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3415, (uint64_t)"parse_copier_options", "kBOMCopierOptionCloneFiles must be a CFBooleanRef");
      return v24;
    }
    if (CFEqual(v190, (CFTypeRef)*MEMORY[0x24BDBD270]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3423, (uint64_t)"parse_copier_options", "kBOMCopierOptionCloneFiles requires the source to be a filesystem");
        return v24;
      }
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3429, (uint64_t)"parse_copier_options", "kBOMCopierOptionCloneFiles requires the destination to be a filesystem");
        return v24;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("cloneFiles"), v190);
    }
  }
  v191 = CFDictionaryGetValue(a2, CFSTR("removeSetuidPermissions"));
  if (v191)
  {
    v192 = v191;
    if (TypeID != CFGetTypeID(v191))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3442, (uint64_t)"parse_copier_options", "kBOMCopierOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("removeSetuidPermissions"), v192);
  }
  v193 = CFDictionaryGetValue(a2, CFSTR("removeExecutablePermissions"));
  if (v193)
  {
    v194 = v193;
    if (TypeID != CFGetTypeID(v193))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3454, (uint64_t)"parse_copier_options", "kBOMCopierOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("removeExecutablePermissions"), v194);
  }
  v195 = CFDictionaryGetValue(a2, CFSTR("setStaticContent"));
  if (v195)
  {
    v196 = v195;
    if (TypeID != CFGetTypeID(v195))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3466, (uint64_t)"parse_copier_options", "kBOMCopierOptionSetStaticContentKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("setStaticContent"), v196);
  }
  v197 = CFDictionaryGetValue(a2, CFSTR("setSingleWriter"));
  if (v197)
  {
    v198 = v197;
    if (TypeID != CFGetTypeID(v197))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3478, (uint64_t)"parse_copier_options", "kBOMCopierOptionSetSingleWriterKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("setSingleWriter"), v198);
  }
  v199 = CFDictionaryGetValue(a2, CFSTR("setDataProtectionClass"));
  if (v199)
  {
    v200 = v199;
    if (v7 != CFGetTypeID(v199))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3490, (uint64_t)"parse_copier_options", "kBOMCopierOptionSetDataProtectionClassKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("setDataProtectionClass"), v200);
  }
  v201 = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("applyProvenance"));
  if (v201)
  {
    v202 = v201;
    if (v213 != CFGetTypeID(v201))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3502, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplyProvenanceKey must be a CFDataRef");
      return v24;
    }
    if (!CFDataGetLength(v202))
    {
      v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3510, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplyProvenanceKey has an invalid size");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), CFSTR("applyProvenance"), v202);
  }
  return 0;
}

uint64_t source_error_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  __int16 v14;
  char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  *(_BYTE *)(a2 + 13059) = 1;
  v5 = notify_file_error(a2, *(_QWORD *)(a3 + 8), *(unsigned int *)(a3 + 16));
  v6 = *(NSObject **)(a2 + 13000);
  if (v6 && os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(a3 + 8);
    v8 = *(_DWORD *)(a3 + 16);
    v10 = 136315906;
    v11 = v7;
    v12 = 1024;
    v13 = v8;
    v14 = 2080;
    v15 = strerror(v8);
    v16 = 1024;
    v17 = v5;
    _os_log_impl(&dword_206367000, v6, OS_LOG_TYPE_DEFAULT, "file error: %s %d (%s) [%d]", (uint8_t *)&v10, 0x22u);
  }
  return v5;
}

uint64_t passphrase_callback(int a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  unsigned int (*v5)(uint64_t, const char *, uint64_t);
  uint64_t v6;

  result = *(_QWORD *)(a2 + 12800);
  if (!result)
  {
    v5 = *(unsigned int (**)(uint64_t, const char *, uint64_t))(a2 + 128);
    if (!v5)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3847, (uint64_t)"passphrase_callback", "Client did not register password request callback");
      return 0;
    }
    v6 = a2 + 12800;
    if (v5(a2, "", a2 + 12800))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3856, (uint64_t)"passphrase_callback", "Could not request password from client");
      return 0;
    }
    return *(_QWORD *)v6;
  }
  return result;
}

uint64_t conflict_resolver(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  int Type;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Path;

  if (a4 && *(_QWORD *)(a4 + 80))
  {
    Type = BOMCopierSourceEntryGetType(a2);
    v9 = BOMCopierDestinationEntryGetType(a3, a5);
    if ((Type - 5) > 5)
      v10 = 0;
    else
      v10 = dword_2063D0598[Type - 5];
    if ((v9 - 5) > 5)
      v11 = 0;
    else
      v11 = dword_2063D0598[v9 - 5];
    Path = BOMCopierDestinationEntryGetPath(a3, a5);
    if (Path)
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(a4, Path, v10, v11);
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 4056, (uint64_t)"conflict_resolver", "Could not get destination path");
  }
  return 2;
}

void data_written_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Path;
  uint64_t TotalWritten;

  if (a4)
  {
    if (*(_QWORD *)(a4 + 104))
    {
      Path = BOMCopierSourceEntryGetPath(a2);
      TotalWritten = BOMCopierDestinationEntryGetTotalWritten(a3, 0);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 104))(a4, Path, TotalWritten);
    }
  }
}

void finalization_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t Path;
  unsigned int v10;
  uint64_t v11;
  uint64_t TotalWritten;

  if (a5 && *(_QWORD *)(a5 + 96))
  {
    Path = BOMCopierSourceEntryGetPath(a2);
    v10 = BOMCopierSourceEntryGetType(a2) - 5;
    if (v10 > 5)
      v11 = 0;
    else
      v11 = dword_2063D0598[v10];
    TotalWritten = BOMCopierDestinationEntryGetTotalWritten(a3, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(a5, Path, v11, TotalWritten, a4);
  }
}

void BOMCopierSandbox_boxup(uint64_t a1, const char *a2, uint64_t a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  const char *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  void **v14;
  uint64_t v15;
  FILE *v16;
  int *v17;
  char *v18;

  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v6 = BOM_malloczero(0x400uLL);
        if (v6)
        {
          v7 = v6;
          v8 = (*(uint64_t (**)(_QWORD, const char *, void *))(*(_QWORD *)(a1 + 12832) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 12832) + 8), a2, v6);
          if (v8)
          {
            v9 = (const char *)v8;
            v10 = BOM_malloczero(0x100uLL);
            if (v10)
            {
              v11 = v10;
              v12 = v10 + 8;
              BomSys_clone(v10 + 8, *(const void **)(a1 + 12832), (uint64_t)v10);
              BomSys_set_opendir(v11[8], (DIR *(*)(int, char *))BOMCopierSandbox_opendir);
              BomSys_set_closedir(v11[8], (uint64_t (*)(int, DIR *))BOMCopierSandbox_closedir);
              BomSys_set_readdir(v11[8], (dirent *(*)(int, DIR *))BOMCopierSandbox_readdir);
              BomSys_set_readdir_r(v11[8], (uint64_t (*)(int, DIR *, dirent *, dirent **))BOMCopierSandbox_readdir_r);
              v13 = *(_QWORD *)(a1 + 12832);
              *(_OWORD *)(v11 + 1) = *(_OWORD *)(v13 + 272);
              *(_OWORD *)(v11 + 3) = *(_OWORD *)(v13 + 288);
              v11[9] = v7;
              v11[10] = strlen(v9);
              v11[14] = v11;
              v11[28] = a3;
              v11[29] = BOMBomGetRootFSObject(a3);
              v14 = BOMStackNew();
              v11[31] = v14;
              if (v14)
              {
                *v11 = a1;
                v11[5] = *(_QWORD *)(a1 + 12832);
                *(_QWORD *)(a1 + 12840) = v11;
                v15 = v11[6];
                if (!v15)
                  v15 = *v12;
                *(_QWORD *)(a1 + 12832) = v15;
              }
            }
            else
            {
              free(v7);
            }
          }
          else
          {
            v16 = (FILE *)*MEMORY[0x24BDAC8D8];
            v17 = __error();
            v18 = strerror(*v17);
            fprintf(v16, "Cannot get the real path for %s: %s", a2, v18);
          }
        }
      }
    }
  }
}

unsigned int *BOMCopierSandbox_opendir(uint64_t a1, char *__s)
{
  size_t v5;
  unsigned int *FSObjectAtPath;
  unsigned int *v7;
  char *v8;
  _QWORD *v9;
  char __sa[1024];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (strlen(__s) <= *(_QWORD *)(a1 + 80) || strncmp(__s, *(const char **)(a1 + 72), *(_QWORD *)(a1 + 80)))
    return (unsigned int *)(*(uint64_t (**)(_QWORD, char *))(a1 + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8), __s);
  __strlcpy_chk();
  v5 = strlen(__sa) - 1;
  if (__sa[v5] == 47)
    __sa[v5] = 0;
  FSObjectAtPath = (unsigned int *)BOMBomGetFSObjectAtPath(*(_QWORD *)(a1 + 224), __sa);
  v7 = FSObjectAtPath;
  if (!FSObjectAtPath)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Could not lookup %s in sandbox bom\n", __sa);
    return v7;
  }
  if (BOMFSObjectType(FSObjectAtPath) != 2)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s is not a directory in the sandbox bom\n", __sa);
    goto LABEL_13;
  }
  v8 = BOMBomEnumeratorNewWithOptions(*(_QWORD *)(a1 + 224), v7, 5);
  BOMFSObjectFree((uint64_t)v7);
  if (!v8)
    return 0;
  v9 = BOM_malloczero(0x90uLL);
  if (!v9)
  {
LABEL_13:
    BOMFSObjectFree((uint64_t)v7);
    return 0;
  }
  *v9 = v8;
  v7 = (unsigned int *)(v9 + 1);
  BOMStackPush(*(char **)(a1 + 248), (uint64_t)v9);
  return v7;
}

uint64_t BOMCopierSandbox_closedir(uint64_t a1, void **a2)
{
  void **v4;
  void **v6;

  v4 = (void **)BOMStackPeek(*(_QWORD **)(a1 + 248));
  if (v4 + 1 != a2)
    return (*(uint64_t (**)(_QWORD, void **))(a1 + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8), a2);
  v6 = v4;
  BOMStackPop(*(uint64_t **)(a1 + 248));
  BOMBomEnumeratorFree(*v6);
  free(v6);
  return 0;
}

uint64_t BOMCopierSandbox_readdir(uint64_t a1, _QWORD *a2)
{
  if (BOMStackPeek(*(_QWORD **)(a1 + 248)) + 1 == a2)
    return 0;
  else
    return (*(uint64_t (**)(_QWORD, _QWORD *))(a1 + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8), a2);
}

uint64_t BOMCopierSandbox_readdir_r(uint64_t a1, uint64_t *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v8;
  _DWORD *v10;
  uint64_t v11;
  const char *v12;
  char *v13;

  v8 = BOMStackPeek(*(_QWORD **)(a1 + 248));
  if (v8 + 1 != a2)
    return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t, _QWORD *))(a1 + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8), a2, a3, a4);
  v10 = BOMBomEnumeratorNext(*v8);
  if (v10)
  {
    v11 = (uint64_t)v10;
    bzero((void *)a3, 0x418uLL);
    v12 = (const char *)BOMFSObjectShortName(v11);
    v13 = strcpy((char *)(a3 + 21), v12);
    *(_WORD *)(a3 + 18) = strlen(v13);
    *a4 = a3;
    BOMFSObjectFree(v11);
  }
  else
  {
    *a4 = 0;
  }
  return 0;
}

void BOMCopierSandbox_unbox(uint64_t a1)
{
  void *v2;
  uint64_t *v3;
  uint64_t *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  _QWORD **v8;
  void *v9;

  if (a1)
  {
    v2 = *(void **)(a1 + 12840);
    if (v2)
    {
      v3 = BOMStackPop(*((uint64_t **)v2 + 31));
      if (v3)
      {
        v4 = v3;
        do
        {
          BOMBomEnumeratorFree((void *)*v4);
          *((_OWORD *)v4 + 7) = 0u;
          *((_OWORD *)v4 + 8) = 0u;
          *((_OWORD *)v4 + 5) = 0u;
          *((_OWORD *)v4 + 6) = 0u;
          *((_OWORD *)v4 + 3) = 0u;
          *((_OWORD *)v4 + 4) = 0u;
          *((_OWORD *)v4 + 1) = 0u;
          *((_OWORD *)v4 + 2) = 0u;
          *(_OWORD *)v4 = 0u;
          free(v4);
          v4 = BOMStackPop(*((uint64_t **)v2 + 31));
        }
        while (v4);
      }
      BOMStackFree(*((void ***)v2 + 31));
      *(_QWORD *)(a1 + 12832) = *((_QWORD *)v2 + 5);
      *(_QWORD *)(a1 + 12840) = 0;
      *((_QWORD *)v2 + 5) = 0;
      *(_QWORD *)v2 = 0;
      v5 = (void *)*((_QWORD *)v2 + 30);
      if (v5)
      {
        BOMBomEnumeratorFree(v5);
        *((_QWORD *)v2 + 30) = 0;
      }
      v6 = (void *)*((_QWORD *)v2 + 9);
      if (v6)
      {
        free(v6);
        *((_QWORD *)v2 + 9) = 0;
      }
      v7 = *((_QWORD *)v2 + 29);
      if (v7)
      {
        BOMFSObjectFree(v7);
        *((_QWORD *)v2 + 29) = 0;
      }
      v8 = (_QWORD **)*((_QWORD *)v2 + 6);
      if (v8)
      {
        BomSys_log_detach(v8);
        *((_QWORD *)v2 + 6) = 0;
      }
      v9 = (void *)*((_QWORD *)v2 + 8);
      if (v9)
        BomSys_free(v9);
      free(v2);
    }
  }
}

void _BOMFreeListAllocate_cold_1()
{
  errx(1, "Unknown free list manager. Aborting");
}

void _BOMFreeListAllocate_cold_2(uint64_t a1)
{
  OUTLINED_FUNCTION_0(a1, "Can't allocate free list");
}

void _BOMFreeListAllocate_cold_3(uint64_t a1)
{
  OUTLINED_FUNCTION_0(a1, "Can't open trace file");
}

void _BOMFreeListAllocate_cold_4(uint64_t a1)
{
  OUTLINED_FUNCTION_0(a1, "Can't allocate data for free list");
}

int AAArchiveStreamClose(AAArchiveStream s)
{
  return MEMORY[0x24BED29E8](s);
}

int AAArchiveStreamReadBlob(AAArchiveStream s, AAFieldKey key, void *buf, size_t nbyte)
{
  return MEMORY[0x24BED29F8](s, *(_QWORD *)key.skey, buf, nbyte);
}

int AAArchiveStreamReadHeader(AAArchiveStream s, AAHeader *header)
{
  return MEMORY[0x24BED2A00](s, header);
}

int AAArchiveStreamWriteBlob(AAArchiveStream s, AAFieldKey key, const void *buf, size_t nbyte)
{
  return MEMORY[0x24BED2A08](s, *(_QWORD *)key.skey, buf, nbyte);
}

int AAArchiveStreamWriteHeader(AAArchiveStream s, AAHeader header)
{
  return MEMORY[0x24BED2A10](s, header);
}

int AAByteStreamClose(AAByteStream s)
{
  return MEMORY[0x24BED2A38](s);
}

AAByteStream AACompressionOutputStreamOpen(AAByteStream compressed_stream, AACompressionAlgorithm compression_algorithm, size_t block_size, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x24BED2A90](compressed_stream, *(_QWORD *)&compression_algorithm, block_size, flags, *(_QWORD *)&n_threads);
}

AAByteStream AACustomByteStreamOpen(void)
{
  return (AAByteStream)MEMORY[0x24BED2AE8]();
}

void AACustomByteStreamSetCloseProc(AAByteStream s, AAByteStreamCloseProc proc)
{
  MEMORY[0x24BED2B00](s, proc);
}

void AACustomByteStreamSetData(AAByteStream s, void *data)
{
  MEMORY[0x24BED2B10](s, data);
}

void AACustomByteStreamSetReadProc(AAByteStream s, AAByteStreamReadProc proc)
{
  MEMORY[0x24BED2B30](s, proc);
}

void AACustomByteStreamSetWriteProc(AAByteStream s, AAByteStreamWriteProc proc)
{
  MEMORY[0x24BED2B48](s, proc);
}

AAArchiveStream AADecodeArchiveInputStreamOpen(AAByteStream stream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  return (AAArchiveStream)MEMORY[0x24BED2B50](stream, msg_data, msg_proc, flags, *(_QWORD *)&n_threads);
}

AAByteStream AADecompressionInputStreamOpen(AAByteStream compressed_stream, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x24BED2B58](compressed_stream, flags, *(_QWORD *)&n_threads);
}

AAArchiveStream AAEncodeArchiveOutputStreamOpen(AAByteStream stream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  return (AAArchiveStream)MEMORY[0x24BED2B68](stream, msg_data, msg_proc, flags, *(_QWORD *)&n_threads);
}

int AAEntryACLBlobApplyToPath(AAEntryACLBlob acl, const char *dir, const char *path, AAFlagSet flags)
{
  return MEMORY[0x24BED2B70](acl, dir, path, flags);
}

int AAEntryACLBlobClear(AAEntryACLBlob acl)
{
  return MEMORY[0x24BED2B78](acl);
}

AAEntryACLBlob AAEntryACLBlobCreateWithEncodedData(const uint8_t *data, size_t data_size)
{
  return (AAEntryACLBlob)MEMORY[0x24BED2B80](data, data_size);
}

AAEntryACLBlob AAEntryACLBlobCreateWithPath(const char *dir, const char *path, AAFlagSet flags)
{
  return (AAEntryACLBlob)MEMORY[0x24BED2B88](dir, path, flags);
}

void AAEntryACLBlobDestroy(AAEntryACLBlob acl)
{
  MEMORY[0x24BED2B90](acl);
}

const uint8_t *__cdecl AAEntryACLBlobGetEncodedData(AAEntryACLBlob acl)
{
  return (const uint8_t *)MEMORY[0x24BED2B98](acl);
}

size_t AAEntryACLBlobGetEncodedSize(AAEntryACLBlob acl)
{
  return MEMORY[0x24BED2BA0](acl);
}

int AAEntryXATBlobAppendEntry(AAEntryXATBlob xat, const char *key, const uint8_t *data, size_t data_size)
{
  return MEMORY[0x24BED2BA8](xat, key, data, data_size);
}

int AAEntryXATBlobClear(AAEntryXATBlob xat)
{
  return MEMORY[0x24BED2BB8](xat);
}

AAEntryXATBlob AAEntryXATBlobCreate(void)
{
  return (AAEntryXATBlob)MEMORY[0x24BED2BC0]();
}

AAEntryXATBlob AAEntryXATBlobCreateWithEncodedData(const uint8_t *data, size_t data_size)
{
  return (AAEntryXATBlob)MEMORY[0x24BED2BC8](data, data_size);
}

void AAEntryXATBlobDestroy(AAEntryXATBlob xat)
{
  MEMORY[0x24BED2BD8](xat);
}

const uint8_t *__cdecl AAEntryXATBlobGetEncodedData(AAEntryXATBlob xat)
{
  return (const uint8_t *)MEMORY[0x24BED2BE0](xat);
}

size_t AAEntryXATBlobGetEncodedSize(AAEntryXATBlob xat)
{
  return MEMORY[0x24BED2BE8](xat);
}

int AAEntryXATBlobGetEntry(AAEntryXATBlob xat, uint32_t i, size_t key_capacity, char *key, size_t *key_length, size_t data_capacity, uint8_t *data, size_t *data_size)
{
  return MEMORY[0x24BED2BF0](xat, *(_QWORD *)&i, key_capacity, key, key_length, data_capacity, data, data_size);
}

uint32_t AAEntryXATBlobGetEntryCount(AAEntryXATBlob xat)
{
  return MEMORY[0x24BED2BF8](xat);
}

AAByteStream AAFileStreamOpenWithFD(int fd, int automatic_close)
{
  return (AAByteStream)MEMORY[0x24BED2C88](*(_QWORD *)&fd, *(_QWORD *)&automatic_close);
}

AAByteStream AAFileStreamOpenWithPath(const char *path, int open_flags, mode_t open_mode)
{
  return (AAByteStream)MEMORY[0x24BED2C90](path, *(_QWORD *)&open_flags, open_mode);
}

AAHeader AAHeaderCreate(void)
{
  return (AAHeader)MEMORY[0x24BED2CB0]();
}

void AAHeaderDestroy(AAHeader header)
{
  MEMORY[0x24BED2CC8](header);
}

int AAHeaderGetFieldBlob(AAHeader header, uint32_t i, uint64_t *size, uint64_t *offset)
{
  return MEMORY[0x24BED2CE0](header, *(_QWORD *)&i, size, offset);
}

uint32_t AAHeaderGetFieldCount(AAHeader header)
{
  return MEMORY[0x24BED2CE8](header);
}

AAFieldKey AAHeaderGetFieldKey(AAHeader header, uint32_t i)
{
  return (AAFieldKey)MEMORY[0x24BED2CF8](header, *(_QWORD *)&i);
}

int AAHeaderGetFieldString(AAHeader header, uint32_t i, size_t capacity, char *value, size_t *length)
{
  return MEMORY[0x24BED2D00](header, *(_QWORD *)&i, capacity, value, length);
}

int AAHeaderGetFieldTimespec(AAHeader header, uint32_t i, timespec *value)
{
  return MEMORY[0x24BED2D08](header, *(_QWORD *)&i, value);
}

int AAHeaderGetFieldType(AAHeader header, uint32_t i)
{
  return MEMORY[0x24BED2D10](header, *(_QWORD *)&i);
}

int AAHeaderGetFieldUInt(AAHeader header, uint32_t i, uint64_t *value)
{
  return MEMORY[0x24BED2D18](header, *(_QWORD *)&i, value);
}

int AAHeaderGetKeyIndex(AAHeader header, AAFieldKey key)
{
  return MEMORY[0x24BED2D20](header, *(_QWORD *)key.skey);
}

int AAHeaderSetFieldBlob(AAHeader header, uint32_t i, AAFieldKey key, uint64_t size)
{
  return MEMORY[0x24BED2D30](header, *(_QWORD *)&i, *(_QWORD *)key.skey, size);
}

int AAHeaderSetFieldString(AAHeader header, uint32_t i, AAFieldKey key, const char *value, size_t length)
{
  return MEMORY[0x24BED2D48](header, *(_QWORD *)&i, *(_QWORD *)key.skey, value, length);
}

int AAHeaderSetFieldTimespec(AAHeader header, uint32_t i, AAFieldKey key, const timespec *value)
{
  return MEMORY[0x24BED2D50](header, *(_QWORD *)&i, *(_QWORD *)key.skey, value);
}

int AAHeaderSetFieldUInt(AAHeader header, uint32_t i, AAFieldKey key, uint64_t value)
{
  return MEMORY[0x24BED2D58](header, *(_QWORD *)&i, *(_QWORD *)key.skey, value);
}

uint64_t AFSCLockFilePath()
{
  return MEMORY[0x24BE06040]();
}

uint64_t AFSCUnlockFile()
{
  return MEMORY[0x24BE06048]();
}

int BZ2_bzCompress(bz_stream *strm, int action)
{
  return MEMORY[0x24BEDA928](strm, *(_QWORD *)&action);
}

int BZ2_bzCompressEnd(bz_stream *strm)
{
  return MEMORY[0x24BEDA930](strm);
}

int BZ2_bzCompressInit(bz_stream *strm, int blockSize100k, int verbosity, int workFactor)
{
  return MEMORY[0x24BEDA938](strm, *(_QWORD *)&blockSize100k, *(_QWORD *)&verbosity, *(_QWORD *)&workFactor);
}

int BZ2_bzDecompress(bz_stream *strm)
{
  return MEMORY[0x24BEDA940](strm);
}

int BZ2_bzDecompressEnd(bz_stream *strm)
{
  return MEMORY[0x24BEDA948](strm);
}

int BZ2_bzDecompressInit(bz_stream *strm, int verbosity, int small)
{
  return MEMORY[0x24BEDA950](strm, *(_QWORD *)&verbosity, *(_QWORD *)&small);
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x24BDAC308](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x24BDAC310](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC318](c, data, *(_QWORD *)&len);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x24BDAC328](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x24BDAC330](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC338](c, data, *(_QWORD *)&len);
}

int CC_SHA224_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC340](md, c);
}

int CC_SHA224_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC348](c);
}

int CC_SHA224_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC350](c, data, *(_QWORD *)&len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC360](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC368](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC370](c, data, *(_QWORD *)&len);
}

int CC_SHA384_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x24BDAC380](md, c);
}

int CC_SHA384_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x24BDAC388](c);
}

int CC_SHA384_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC390](c, data, *(_QWORD *)&len);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x24BDAC3A0](md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x24BDAC3A8](c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC3B0](c, data, *(_QWORD *)&len);
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x24BDBB7C0](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x24BDBB7D8](theArray, range.location, range.length, applier, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x24BDBB7E8](theArray, range.location, range.length, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB810](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x24BDBB838](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x24BDBB850]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x24BDBB880](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x24BDBB898](theArray, idx, value);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x24BDBBC98](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x24BDBBCC0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x24BDBBD08]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x24BDBBDC0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDD8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x24BDBBE00](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x24BDBBE10](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x24BDBBE38](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x24BDBBE48](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x24BDBBE68](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x24BDBC1C0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC1E8](allocator, data, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x24BDBC218](stream);
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  return MEMORY[0x24BDBC240](stream);
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return MEMORY[0x24BDBC248]();
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x24BDBC260](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x24BDBC510](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x24BDBC518](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC600](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x24BDBC610](theString, *(_QWORD *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x24BDBC690]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  MEMORY[0x24BDBC968](stream);
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  return MEMORY[0x24BDBC998](stream);
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return MEMORY[0x24BDBC9A0]();
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x24BDBC9E0](stream, buffer, bufferLength);
}

uint64_t CNCRCFinal()
{
  return MEMORY[0x24BDAC3C0]();
}

uint64_t CNCRCInit()
{
  return MEMORY[0x24BDAC3C8]();
}

uint64_t CNCRCRelease()
{
  return MEMORY[0x24BDAC3D0]();
}

uint64_t CNCRCUpdate()
{
  return MEMORY[0x24BDAC3D8]();
}

uint64_t CloseStreamCompressor()
{
  return MEMORY[0x24BE06050]();
}

uint64_t CreateStreamCompressor()
{
  return MEMORY[0x24BE06058]();
}

uint64_t CreateStreamCompressorQueueWithOptions()
{
  return MEMORY[0x24BE06060]();
}

uint64_t FinishStreamCompressorQueue()
{
  return MEMORY[0x24BE06068]();
}

uint64_t ParallelCompressionAFSCStreamClose()
{
  return MEMORY[0x24BED8B90]();
}

uint64_t ParallelCompressionAFSCStreamOpen()
{
  return MEMORY[0x24BED8B98]();
}

uint64_t ParallelCompressionAFSCStreamWrite()
{
  return MEMORY[0x24BED8BA0]();
}

uint64_t VolumeSupportsCompression()
{
  return MEMORY[0x24BE06070]();
}

uint64_t WriteToStreamCompressor()
{
  return MEMORY[0x24BE06078]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x24BDAC838](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x24BDAC908]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x24BDAC910]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC930](*(_QWORD *)&a1);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void abort(void)
{
  MEMORY[0x24BDAD008]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x24BDAD038](a1, *(_QWORD *)&a2);
}

int acl_copy_entry(acl_entry_t dest_d, acl_entry_t src_d)
{
  return MEMORY[0x24BDAD048](dest_d, src_d);
}

int acl_create_entry(acl_t *acl_p, acl_entry_t *entry_p)
{
  return MEMORY[0x24BDAD058](acl_p, entry_p);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x24BDAD060](obj_p);
}

acl_t acl_from_text(const char *buf_p)
{
  return (acl_t)MEMORY[0x24BDAD068](buf_p);
}

int acl_get_entry(acl_t acl, int entry_id, acl_entry_t *entry_p)
{
  return MEMORY[0x24BDAD070](acl, *(_QWORD *)&entry_id, entry_p);
}

acl_t acl_get_file(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x24BDAD080](path_p, *(_QWORD *)&type);
}

int acl_get_flag_np(acl_flagset_t flagset_d, acl_flag_t flag)
{
  return MEMORY[0x24BDAD088](flagset_d, *(_QWORD *)&flag);
}

int acl_get_flagset_np(void *obj_p, acl_flagset_t *flagset_p)
{
  return MEMORY[0x24BDAD090](obj_p, flagset_p);
}

acl_t acl_get_link_np(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x24BDAD098](path_p, *(_QWORD *)&type);
}

acl_t acl_init(int count)
{
  return (acl_t)MEMORY[0x24BDAD0B8](*(_QWORD *)&count);
}

int acl_set_fd_np(int fd, acl_t acl, acl_type_t acl_type)
{
  return MEMORY[0x24BDAD0C8](*(_QWORD *)&fd, acl, *(_QWORD *)&acl_type);
}

int acl_set_file(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x24BDAD0D0](path_p, *(_QWORD *)&type, acl);
}

int acl_set_link_np(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x24BDAD0D8](path_p, *(_QWORD *)&type, acl);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x24BDAD100](acl, len_p);
}

uint64_t archive_entry_atime()
{
  return MEMORY[0x24BEDA2D8]();
}

uint64_t archive_entry_atime_nsec()
{
  return MEMORY[0x24BEDA2E0]();
}

uint64_t archive_entry_ctime()
{
  return MEMORY[0x24BEDA2F8]();
}

uint64_t archive_entry_ctime_nsec()
{
  return MEMORY[0x24BEDA308]();
}

uint64_t archive_entry_dev()
{
  return MEMORY[0x24BEDA310]();
}

uint64_t archive_entry_free()
{
  return MEMORY[0x24BEDA320]();
}

uint64_t archive_entry_gid()
{
  return MEMORY[0x24BEDA328]();
}

uint64_t archive_entry_ino()
{
  return MEMORY[0x24BEDA330]();
}

uint64_t archive_entry_mode()
{
  return MEMORY[0x24BEDA338]();
}

uint64_t archive_entry_mtime()
{
  return MEMORY[0x24BEDA340]();
}

uint64_t archive_entry_mtime_nsec()
{
  return MEMORY[0x24BEDA348]();
}

uint64_t archive_entry_new()
{
  return MEMORY[0x24BEDA350]();
}

uint64_t archive_entry_nlink()
{
  return MEMORY[0x24BEDA358]();
}

uint64_t archive_entry_pathname()
{
  return MEMORY[0x24BEDA360]();
}

uint64_t archive_entry_set_atime()
{
  return MEMORY[0x24BEDA380]();
}

uint64_t archive_entry_set_ctime()
{
  return MEMORY[0x24BEDA388]();
}

uint64_t archive_entry_set_dev()
{
  return MEMORY[0x24BEDA390]();
}

uint64_t archive_entry_set_filetype()
{
  return MEMORY[0x24BEDA398]();
}

uint64_t archive_entry_set_gid()
{
  return MEMORY[0x24BEDA3A0]();
}

uint64_t archive_entry_set_ino64()
{
  return MEMORY[0x24BEDA3A8]();
}

uint64_t archive_entry_set_mode()
{
  return MEMORY[0x24BEDA3B0]();
}

uint64_t archive_entry_set_mtime()
{
  return MEMORY[0x24BEDA3B8]();
}

uint64_t archive_entry_set_nlink()
{
  return MEMORY[0x24BEDA3C0]();
}

uint64_t archive_entry_set_pathname()
{
  return MEMORY[0x24BEDA3C8]();
}

uint64_t archive_entry_set_perm()
{
  return MEMORY[0x24BEDA3D8]();
}

uint64_t archive_entry_set_size()
{
  return MEMORY[0x24BEDA3E0]();
}

uint64_t archive_entry_set_symlink()
{
  return MEMORY[0x24BEDA3E8]();
}

uint64_t archive_entry_set_uid()
{
  return MEMORY[0x24BEDA3F0]();
}

uint64_t archive_entry_size()
{
  return MEMORY[0x24BEDA3F8]();
}

uint64_t archive_entry_symlink()
{
  return MEMORY[0x24BEDA410]();
}

uint64_t archive_entry_uid()
{
  return MEMORY[0x24BEDA418]();
}

uint64_t archive_errno()
{
  return MEMORY[0x24BEDA428]();
}

uint64_t archive_error_string()
{
  return MEMORY[0x24BEDA430]();
}

uint64_t archive_read_add_passphrase()
{
  return MEMORY[0x24BEDA448]();
}

uint64_t archive_read_data()
{
  return MEMORY[0x24BEDA458]();
}

uint64_t archive_read_free()
{
  return MEMORY[0x24BEDA4B8]();
}

uint64_t archive_read_has_encrypted_entries()
{
  return MEMORY[0x24BEDA4C0]();
}

uint64_t archive_read_new()
{
  return MEMORY[0x24BEDA4C8]();
}

uint64_t archive_read_next_header()
{
  return MEMORY[0x24BEDA4D0]();
}

uint64_t archive_read_open()
{
  return MEMORY[0x24BEDA4E0]();
}

uint64_t archive_read_open_fd()
{
  return MEMORY[0x24BEDA4F0]();
}

uint64_t archive_read_open_filename()
{
  return MEMORY[0x24BEDA4F8]();
}

uint64_t archive_read_set_options()
{
  return MEMORY[0x24BEDA510]();
}

uint64_t archive_read_set_passphrase_callback()
{
  return MEMORY[0x24BEDA518]();
}

uint64_t archive_read_support_filter_all()
{
  return MEMORY[0x24BEDA528]();
}

uint64_t archive_read_support_format_all()
{
  return MEMORY[0x24BEDA540]();
}

uint64_t archive_set_error()
{
  return MEMORY[0x24BEDA560]();
}

uint64_t archive_write_add_filter()
{
  return MEMORY[0x24BEDA568]();
}

uint64_t archive_write_close()
{
  return MEMORY[0x24BEDA580]();
}

uint64_t archive_write_data()
{
  return MEMORY[0x24BEDA588]();
}

uint64_t archive_write_free()
{
  return MEMORY[0x24BEDA5C0]();
}

uint64_t archive_write_header()
{
  return MEMORY[0x24BEDA5C8]();
}

uint64_t archive_write_new()
{
  return MEMORY[0x24BEDA5D0]();
}

uint64_t archive_write_open2()
{
  return MEMORY[0x24BEDA5E0]();
}

uint64_t archive_write_open_fd()
{
  return MEMORY[0x24BEDA5E8]();
}

uint64_t archive_write_open_filename()
{
  return MEMORY[0x24BEDA5F0]();
}

uint64_t archive_write_set_filter_option()
{
  return MEMORY[0x24BEDA620]();
}

uint64_t archive_write_set_format()
{
  return MEMORY[0x24BEDA628]();
}

uint64_t archive_write_set_format_option()
{
  return MEMORY[0x24BEDA640]();
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x24BDAD200](a1, a2);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x24BDAD2B8](a1, a2);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

int chdir(const char *a1)
{
  return MEMORY[0x24BDAD980](a1);
}

int chflags(const char *a1, __uint32_t a2)
{
  return MEMORY[0x24BDAD988](a1, *(_QWORD *)&a2);
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAD990](a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x24BDAD998](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x24BDAD9F0](a1);
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return MEMORY[0x24BDADBB8](from, to, state, *(_QWORD *)&flags);
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return MEMORY[0x24BEDF1C0](crc, buf, *(_QWORD *)&len);
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x24BDADC20](a1, a2);
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x24BEDF1C8](strm, *(_QWORD *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x24BEDF1D8](strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return MEMORY[0x24BEDF1E0](strm, *(_QWORD *)&level, *(_QWORD *)&method, *(_QWORD *)&windowBits, *(_QWORD *)&memLevel, *(_QWORD *)&strategy, version, *(_QWORD *)&stream_size);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x24BDADC48](a1, a2);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADDB8](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x24BDADDC8]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x24BDADDD0](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x24BDADDD8](group);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADDF0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void err(int a1, const char *a2, ...)
{
  MEMORY[0x24BDAE1C8](*(_QWORD *)&a1, a2);
}

void errx(int a1, const char *a2, ...)
{
  MEMORY[0x24BDAE1D0](*(_QWORD *)&a1, a2);
}

int faccessat(int a1, const char *a2, int a3, int a4)
{
  return MEMORY[0x24BDAE2A8](*(_QWORD *)&a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x24BDAE2E8](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x24BDAE380](a1, *(_QWORD *)&a2, a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x24BDAE438](*(_QWORD *)&a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x24BDAE4D0](a1, a2, a3, *(_QWORD *)&a4);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x24BDAE508](*(_QWORD *)&a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x24BDAE518](*(_QWORD *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x24BDAE528](*(_QWORD *)&a1);
}

int fts_close(FTS *a1)
{
  return MEMORY[0x24BDAE550](a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return (FTS *)MEMORY[0x24BDAE558](a1, *(_QWORD *)&a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return (FTSENT *)MEMORY[0x24BDAE568](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x24BDAE5A8](a1, a2, a3, a4, *(_QWORD *)&a5);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x24BDAE5D8](a1, a2);
}

gid_t getegid(void)
{
  return MEMORY[0x24BDAE5E8]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x24BDAE5F0](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x24BDAE5F8]();
}

group *__cdecl getgrgid(gid_t a1)
{
  return (group *)MEMORY[0x24BDAE618](*(_QWORD *)&a1);
}

int getgroups(int a1, gid_t a2[])
{
  return MEMORY[0x24BDAE638](*(_QWORD *)&a1, a2);
}

int getpagesize(void)
{
  return MEMORY[0x24BDAE6B8]();
}

pid_t getpid(void)
{
  return MEMORY[0x24BDAE6D0]();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x24BDAE720](*(_QWORD *)&a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x24BDAE730](*(_QWORD *)&a1, a2);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x24BDAE798](path, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x24BEDF260](strm, *(_QWORD *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x24BEDF268](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x24BEDF270](strm, *(_QWORD *)&windowBits, version, *(_QWORD *)&stream_size);
}

int issetugid(void)
{
  return MEMORY[0x24BDAE908]();
}

int lchmod(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAEA20](a1, a2);
}

int lchown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x24BDAEA28](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int link(const char *a1, const char *a2)
{
  return MEMORY[0x24BDAEA70](a1, a2);
}

ssize_t listxattr(const char *path, char *namebuff, size_t size, int options)
{
  return MEMORY[0x24BDAEA80](path, namebuff, size, *(_QWORD *)&options);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x24BDAEA98](a1);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x24BDAEB20](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAEB28](a1, a2);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED88](ptr, size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED90](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return MEMORY[0x24BDAEED0](__base, __nel, __width, __compar);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAEF28](a1, a2);
}

int mknod(const char *a1, mode_t a2, dev_t a3)
{
  return MEMORY[0x24BDAEF50](a1, a2, *(_QWORD *)&a3);
}

int mkstemp(char *a1)
{
  return MEMORY[0x24BDAEF70](a1);
}

char *__cdecl mktemp(char *a1)
{
  return (char *)MEMORY[0x24BDAEF90](a1);
}

time_t mktime(tm *a1)
{
  return MEMORY[0x24BDAEF98](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x24BDAEFA8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFF0](a1, a2);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x24BDAF010](__rqtp, __rmtp);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x24BDAF230](a1, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x24BDAF258](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x24BDAF368](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x24BDAF4D0]();
}

void perror(const char *a1)
{
  MEMORY[0x24BDAF5A8](a1);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF790](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x24BDAF798](__attr, *(_QWORD *)&__qos_class, *(_QWORD *)&__relative_priority);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x24BDAF7C8](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x24BDAF7D0](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x24BDAF7D8](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x24BDAF7E0](a1);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x24BDAF800](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x24BDAF818](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x24BDAF880](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8C0](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x24BDAF8C8](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x24BDAF910](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x24BDAFA10]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x24BDAFA80](*(_QWORD *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x24BDAFA88](a1);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x24BDAFA90](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x24BDAFA98](a1, a2, a3);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x24BDAFAB8](__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x24BDAFAC0](a1, a2);
}

int regcomp(regex_t *a1, const char *a2, int a3)
{
  return MEMORY[0x24BDAFAF8](a1, a2, *(_QWORD *)&a3);
}

int regexec(const regex_t *a1, const char *a2, size_t a3, regmatch_t __pmatch[], int a5)
{
  return MEMORY[0x24BDAFB08](a1, a2, a3, __pmatch, *(_QWORD *)&a5);
}

void regfree(regex_t *a1)
{
  MEMORY[0x24BDAFB10](a1);
}

int removexattr(const char *path, const char *name, int options)
{
  return MEMORY[0x24BDAFB68](path, name, *(_QWORD *)&options);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x24BDAFB80](__from, __to, __ec);
}

char *__cdecl rindex(const char *a1, int a2)
{
  return (char *)MEMORY[0x24BDAFBA8](a1, *(_QWORD *)&a2);
}

int rmdir(const char *a1)
{
  return MEMORY[0x24BDAFBB0](a1);
}

int setattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x24BDAFD00](a1, a2, a3, a4, *(_QWORD *)&a5);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x24BDAFD60](*(_QWORD *)&a1, a2);
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x24BDAFD98](path, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFEA0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAFEA8](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x24BDAFEB0](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFEE8](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x24BDAFF00](__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x24BDAFF10](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF30](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF38](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

void strmode(int __mode, char *__bp)
{
  MEMORY[0x24BDAFF48](*(_QWORD *)&__mode, __bp);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF60](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF70](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x24BDAFF80](__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFFA8](__s, *(_QWORD *)&__c);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return (char *)MEMORY[0x24BDAFFB0](__stringp, __delim);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0010](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t strtoq(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0028](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0030](__str, __endptr, *(_QWORD *)&__base);
}

int symlink(const char *a1, const char *a2)
{
  return MEMORY[0x24BDB0090](a1, a2);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x24BDB00F8](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x24BDB02B0](a1);
}

int utimes(const char *a1, const timeval *a2)
{
  return MEMORY[0x24BDB02F8](a1, a2);
}

void uuid_generate(uuid_t out)
{
  MEMORY[0x24BDB0318](out);
}

void uuid_generate_random(uuid_t out)
{
  MEMORY[0x24BDB0320](out);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x24BDB0338](uu, out);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0358](a1, a2, a3);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x24BDB0380](*(_QWORD *)&target_task, address, size, *(_QWORD *)&flags);
}

kern_return_t vm_copy(vm_map_t target_task, vm_address_t source_address, vm_size_t size, vm_address_t dest_address)
{
  return MEMORY[0x24BDB0388](*(_QWORD *)&target_task, source_address, size, dest_address);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x24BDB0390](*(_QWORD *)&target_task, address, size);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

void warnx(const char *a1, ...)
{
  MEMORY[0x24BDB0490](a1);
}

