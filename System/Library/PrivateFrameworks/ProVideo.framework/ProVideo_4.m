void HGeometryData::ClipPolygons(_QWORD *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  unsigned int *v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  int v30;
  int *v31;
  _BYTE *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  void *v39;
  void *v40;
  int v41;
  const void *v42;
  uint64_t v43;
  int v44;
  int v45;
  int *v46;
  _BYTE *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  void *v53;
  void *v54;
  int v55;
  const void *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  void *v62;
  void *v63;
  int v64;
  const void *v65;
  uint64_t v66;
  uint64_t v67;
  HGArrayDataRef *v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  void *v73;
  void *v74;
  int v75;
  const void *v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  void *v82;
  void *v83;
  const void *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  void *v90;
  void *v91;
  int v92;
  const void *v93;
  uint64_t v94;
  int v95;
  int v96;
  int v97;
  void *v98;
  void *v99;
  const void *v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  int v109;
  int v110;
  void *v111;
  void *v112;
  int v113;
  const void *v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  int v118;
  void *v119;
  void *v120;
  int v121;
  const void *v122;
  uint64_t v123;
  int v124;
  int v125;
  _OWORD *v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int *v134;
  unsigned int v135;
  uint64_t v136;
  unsigned int v137;
  unsigned int v138;
  uint64_t v139;
  uint64_t v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  int i;
  uint64_t v145;
  float32x4_t *v146;
  int v147;
  float32x4_t *v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  uint64_t v152;
  unsigned int v153;
  unsigned int v154;
  uint64_t v155;
  uint64_t v156;
  unsigned int v157;
  unsigned int v158;
  uint64_t v159;
  uint64_t v160;
  unsigned int v161;
  unsigned int v162;
  uint64_t v163;
  uint64_t v164;
  unsigned int v165;
  unsigned int v166;
  uint64_t v167;
  HGArrayDataRef *v170;
  HGArrayDataRef *v171;
  HGArrayDataRef *v172;
  int v173[2];
  HGArrayDataRef *v174;
  __int128 v175;
  int v176;
  int v177;
  int32x4_t v178;
  float32x4_t v179;
  _QWORD v180[2];
  _QWORD v181[2];
  _QWORD v182[35];
  _BYTE v183[280];
  _BYTE v184[24];
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  _QWORD v189[2];
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;

  v192 = 0;
  v193 = 0x2200000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v192, 4, 0, 0);
  v190 = 0;
  v191 = 0;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v190, 1, 0, 0);
  v12 = *(unsigned int **)a6;
  if (a7 != -1)
  {
    v189[0] = *(_QWORD *)a6;
    v13 = 1;
    if (!v12)
      goto LABEL_7;
    do
LABEL_6:
      v14 = __ldaxr(v12);
    while (__stlxr(v14 + 1, v12));
    goto LABEL_7;
  }
  if (v12)
  {
    a7 = 0;
    v13 = v12[2];
    v189[0] = *(_QWORD *)a6;
    goto LABEL_6;
  }
  v13 = 0;
  a7 = 0;
  v189[0] = 0;
LABEL_7:
  v189[1] = *(_QWORD *)(a6 + 8);
  HGeometryData::GetValidPolygons((uint64_t)&v192, (HGArrayDataRef *)&v190, a2, a3, (int *)v189, a7, v13);
  v15 = v189[0];
  if (v189[0])
  {
    do
    {
      v16 = __ldaxr((unsigned int *)v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, (unsigned int *)v15));
    if (!v17)
    {
      v18 = *(_QWORD *)(v15 + 16);
      if (v18)
        MEMORY[0x1B5E2914C](v18, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v15, 0x1080C4098BBCF0FLL);
    }
  }
  if (!v192)
    goto LABEL_239;
  v19 = *(unsigned int *)(v192 + 8);
  if (!(_DWORD)v19)
    goto LABEL_239;
  *(_QWORD *)v173 = *(unsigned int *)(v192 + 8);
  if ((int)v19 < 1)
  {
    v30 = 0;
    goto LABEL_26;
  }
  v20 = *(_QWORD *)(v192 + 16);
  v21 = *(int *)(v192 + 4);
  v22 = *(_QWORD *)(a4 + 48);
  v23 = *(_QWORD *)(v22 + 16);
  v24 = *(_DWORD *)(v22 + 4);
  v25 = v23 + *(int *)(a4 + 56);
  v26 = *(_QWORD *)(v190 + 16);
  v27 = *(int *)(v190 + 4);
  if ((_DWORD)v19 == 1 || ((_DWORD)v21 == 1 ? (v28 = (_DWORD)v27 == 1) : (v28 = 0), !v28))
  {
    v29 = 0;
    v30 = 0;
LABEL_22:
    v31 = (int *)(v20 + v29 * v21 + (int)v193);
    v32 = (_BYTE *)(v26 + (int)v191 + v29 * v27);
    v33 = v19 - v29;
    do
    {
      v30 += *(_DWORD *)(v25 + v24 * (uint64_t)*v31) << *v32;
      v31 = (int *)((char *)v31 + v21);
      v32 += v27;
      --v33;
    }
    while (v33);
    goto LABEL_26;
  }
  v44 = 0;
  v45 = 0;
  v46 = (int *)(v20 + (int)v193);
  v47 = (_BYTE *)(v26 + (int)v191);
  v29 = v19 & 0xFFFFFFFE;
  v48 = v29;
  do
  {
    v44 += *(_DWORD *)(v25 + v24 * (uint64_t)*v46) << *v47;
    v45 += *(_DWORD *)(v25 + v24 * (uint64_t)*(int *)((char *)v46 + v21)) << v47[v27];
    v46 = (int *)((char *)v46 + 2 * v21);
    v47 += 2 * v27;
    v48 -= 2;
  }
  while (v48);
  v30 = v45 + v44;
  v19 = *(unsigned int *)(v192 + 8);
  if (v29 != *(_QWORD *)v173)
    goto LABEL_22;
LABEL_26:
  v176 = v30;
  v34 = a1[8];
  v35 = *(_DWORD *)(a1[33] + 1068);
  v170 = (HGArrayDataRef *)(a1 + 8);
  if (v34)
  {
    v36 = *(_DWORD *)(v34 + 12);
    v37 = v30;
    if (v36 < v30)
    {
      v38 = *(_DWORD *)(v34 + 4);
      *(_DWORD *)(v34 + 12) = v30;
      if (v38 * v30)
      {
        v39 = (void *)operator new[]();
        v40 = v39;
        v41 = v38 * v36;
        if (v38 * v36)
        {
          v42 = *(const void **)(v34 + 16);
          if (v42)
          {
            if (v41 >= v38 * v176)
              v41 = v38 * v176;
            memcpy(v39, v42, v41);
          }
        }
      }
      else
      {
        v40 = 0;
      }
      v49 = *(_QWORD *)(v34 + 16);
      if (v49)
        MEMORY[0x1B5E2914C](v49, 0x1000C8077774924);
      *(_QWORD *)(v34 + 16) = v40;
      v37 = v176;
    }
    v43 = a1[10];
    v171 = (HGArrayDataRef *)(a1 + 10);
    if (v43)
      goto LABEL_49;
    if (v37 < 1)
      goto LABEL_63;
LABEL_57:
    HGArrayDataRef::allocate(v171, 16, v176, v176);
    v37 = v176;
    v57 = a1[12];
    v174 = (HGArrayDataRef *)(a1 + 12);
    if (v57)
      goto LABEL_64;
LABEL_72:
    HGArrayDataRef::allocate(v174, 16, v176, v176);
    v37 = v176;
    goto LABEL_77;
  }
  if (v30 <= 0)
  {
    v43 = a1[10];
    v171 = (HGArrayDataRef *)(a1 + 10);
    v37 = v30;
    if (!v43)
      goto LABEL_63;
    goto LABEL_49;
  }
  HGArrayDataRef::allocate((HGArrayDataRef *)(a1 + 8), 16, v30, v30);
  v37 = v176;
  v43 = a1[10];
  v171 = (HGArrayDataRef *)(a1 + 10);
  if (!v43)
    goto LABEL_57;
LABEL_49:
  v50 = *(_DWORD *)(v43 + 12);
  if (v50 < v37)
  {
    v51 = *(_DWORD *)(v43 + 4);
    v52 = v51 * v37;
    *(_DWORD *)(v43 + 12) = v37;
    if (v51 * v37)
    {
      v53 = (void *)operator new[]();
      v54 = v53;
      v55 = v51 * v50;
      if (v51 * v50)
      {
        v56 = *(const void **)(v43 + 16);
        if (v56)
        {
          if (v55 >= v52)
            v55 = v52;
          memcpy(v53, v56, v55);
        }
      }
    }
    else
    {
      v54 = 0;
    }
    v58 = *(_QWORD *)(v43 + 16);
    if (v58)
      MEMORY[0x1B5E2914C](v58, 0x1000C8077774924);
    *(_QWORD *)(v43 + 16) = v54;
    v37 = v176;
  }
LABEL_63:
  v57 = a1[12];
  v174 = (HGArrayDataRef *)(a1 + 12);
  if (v57)
  {
LABEL_64:
    v59 = *(_DWORD *)(v57 + 12);
    if (v59 < v37)
    {
      v60 = *(_DWORD *)(v57 + 4);
      v61 = v60 * v37;
      *(_DWORD *)(v57 + 12) = v37;
      if (v60 * v37)
      {
        v62 = (void *)operator new[]();
        v63 = v62;
        v64 = v60 * v59;
        if (v60 * v59)
        {
          v65 = *(const void **)(v57 + 16);
          if (v65)
          {
            if (v64 >= v61)
              v64 = v61;
            memcpy(v62, v65, v64);
          }
        }
      }
      else
      {
        v63 = 0;
      }
      v66 = *(_QWORD *)(v57 + 16);
      if (v66)
        MEMORY[0x1B5E2914C](v66, 0x1000C8077774924);
      *(_QWORD *)(v57 + 16) = v63;
      v37 = v176;
    }
    goto LABEL_77;
  }
  if (v37 >= 1)
    goto LABEL_72;
LABEL_77:
  v67 = 0;
  v172 = (HGArrayDataRef *)a1;
  v68 = (HGArrayDataRef *)(a1 + 14);
  do
  {
    if (((v35 >> v67) & 1) != 0)
    {
      v69 = *(_QWORD *)v68;
      if (*(_QWORD *)v68)
      {
        v70 = *(_DWORD *)(v69 + 12);
        if (v70 < v37)
        {
          v71 = *(_DWORD *)(v69 + 4);
          v72 = v71 * v37;
          *(_DWORD *)(v69 + 12) = v37;
          if (v71 * v37)
          {
            v73 = (void *)operator new[]();
            v74 = v73;
            v75 = v71 * v70;
            if (v71 * v70)
            {
              v76 = *(const void **)(v69 + 16);
              if (v76)
              {
                if (v75 >= v72)
                  v75 = v72;
                memcpy(v73, v76, v75);
              }
            }
            v77 = *(_QWORD *)(v69 + 16);
            if (!v77)
              goto LABEL_78;
LABEL_94:
            MEMORY[0x1B5E2914C](v77, 0x1000C8077774924);
          }
          else
          {
            v74 = 0;
            v77 = *(_QWORD *)(v69 + 16);
            if (v77)
              goto LABEL_94;
          }
LABEL_78:
          *(_QWORD *)(v69 + 16) = v74;
          v37 = v176;
        }
      }
      else if (v37 > 0)
      {
        HGArrayDataRef::allocate(v68, 16, v176, v176);
        v37 = v176;
      }
    }
    ++v67;
    v68 = (HGArrayDataRef *)((char *)v68 + 16);
  }
  while (v67 != 8);
  v78 = *((_QWORD *)v172 + 6);
  if (v78)
  {
    v79 = *(_DWORD *)(v78 + 12);
    v80 = v173[0];
    if (v79 < v173[0])
    {
      v81 = *(_DWORD *)(v78 + 4);
      *(_DWORD *)(v78 + 12) = v173[0];
      if (v81)
      {
        v82 = (void *)operator new[]();
        v83 = v82;
        if (v79)
        {
          v84 = *(const void **)(v78 + 16);
          if (v84)
          {
            v85 = v81 * v79;
            if (v81 * v79 >= v81 * v173[0])
              v85 = v81 * v173[0];
            memcpy(v82, v84, v85);
          }
        }
      }
      else
      {
        v83 = 0;
      }
      v86 = *(_QWORD *)(v78 + 16);
      if (v86)
        MEMORY[0x1B5E2914C](v86, 0x1000C8077774924);
      *(_QWORD *)(v78 + 16) = v83;
    }
    *(_DWORD *)(v78 + 8) = v173[0];
  }
  else
  {
    v80 = v173[0];
    if (v173[0] > 0)
      HGArrayDataRef::allocate((HGArrayDataRef *)((char *)v172 + 48), 4, v173[0], v173[0]);
  }
  v187 = 0;
  v188 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v187, 16, 0, 0);
  v185 = 0;
  v186 = 0x2200000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v185, 4, 0, 0);
  v87 = *((_QWORD *)v172 + 2);
  *((_DWORD *)v172 + 61) = v80;
  if (!v87)
  {
    if (v176 > 0)
      HGArrayDataRef::allocate((HGArrayDataRef *)((char *)v172 + 16), 2, v176, v176);
LABEL_120:
    v94 = *(_QWORD *)v172;
    if (!*(_QWORD *)v172)
      goto LABEL_132;
    goto LABEL_121;
  }
  v88 = *(_DWORD *)(v87 + 12);
  if (v88 >= v176)
    goto LABEL_120;
  v89 = *(_DWORD *)(v87 + 4);
  *(_DWORD *)(v87 + 12) = v176;
  if (v89 * v176)
  {
    v90 = (void *)operator new[]();
    v91 = v90;
    v92 = v89 * v88;
    if (v89 * v88)
    {
      v93 = *(const void **)(v87 + 16);
      if (v93)
      {
        if (v92 >= v89 * v176)
          v92 = v89 * v176;
        memcpy(v90, v93, v92);
      }
    }
  }
  else
  {
    v91 = 0;
  }
  v102 = *(_QWORD *)(v87 + 16);
  if (v102)
    MEMORY[0x1B5E2914C](v102, 0x1000C8077774924);
  *(_QWORD *)(v87 + 16) = v91;
  v94 = *(_QWORD *)v172;
  if (!*(_QWORD *)v172)
  {
LABEL_132:
    if (v173[0] > 0)
      HGArrayDataRef::allocate(v172, 4, v173[0], v173[0]);
    goto LABEL_139;
  }
LABEL_121:
  v95 = *(_DWORD *)(v94 + 12);
  v96 = v173[0];
  if (v95 < v173[0])
  {
    v97 = *(_DWORD *)(v94 + 4);
    *(_DWORD *)(v94 + 12) = v173[0];
    if (v97)
    {
      v98 = (void *)operator new[]();
      v99 = v98;
      if (v95)
      {
        v100 = *(const void **)(v94 + 16);
        if (v100)
        {
          v101 = v97 * v95;
          if (v97 * v95 >= v97 * v173[0])
            v101 = v97 * v173[0];
          memcpy(v98, v100, v101);
        }
      }
    }
    else
    {
      v99 = 0;
    }
    v103 = *(_QWORD *)(v94 + 16);
    if (v103)
      MEMORY[0x1B5E2914C](v103, 0x1000C8077774924);
    *(_QWORD *)(v94 + 16) = v99;
    v96 = v173[0];
  }
  *(_DWORD *)(v94 + 8) = v96;
LABEL_139:
  HGeometryData::HGeometryData((HGeometryData *)v183, *((HGRasterizer **)v172 + 33), 0);
  HGeometryData::HGeometryData((HGeometryData *)v182, *((HGRasterizer **)v172 + 33), 0);
  if (v173[0] >= 1)
  {
    v104 = 0;
    while (1)
    {
      v177 = *(_DWORD *)(*(_QWORD *)(v192 + 16) + *(int *)(v192 + 4) * (uint64_t)v104 + (int)v193);
      v105 = *(_QWORD *)(*(_QWORD *)(a4 + 48) + 16) + *(int *)(*(_QWORD *)(a4 + 48) + 4) * (uint64_t)v177;
      v106 = *(int *)(a4 + 56);
      v107 = *(_DWORD *)(v105 + v106);
      v108 = v185;
      if (v185)
        break;
      if (v107 > 0)
        HGArrayDataRef::allocate((HGArrayDataRef *)&v185, 4, *(_DWORD *)(v105 + v106), *(_DWORD *)(v105 + v106));
LABEL_157:
      v116 = v187;
      if (!v187)
      {
        if (v107 > 0)
          HGArrayDataRef::allocate((HGArrayDataRef *)&v187, 16, v107, v107);
        goto LABEL_171;
      }
      v117 = *(_DWORD *)(v187 + 12);
      if (v117 < v107)
      {
        v118 = *(_DWORD *)(v187 + 4);
        *(_DWORD *)(v187 + 12) = v107;
        if (v118 * v107)
        {
          v119 = (void *)operator new[]();
          v120 = v119;
          v121 = v118 * v117;
          if (v118 * v117)
          {
            v122 = *(const void **)(v116 + 16);
            if (v122)
            {
              if (v121 >= v118 * v107)
                v121 = v118 * v107;
              memcpy(v119, v122, v121);
            }
          }
          v123 = *(_QWORD *)(v116 + 16);
          if (v123)
LABEL_166:
            MEMORY[0x1B5E2914C](v123, 0x1000C8077774924);
        }
        else
        {
          v120 = 0;
          v123 = *(_QWORD *)(v116 + 16);
          if (v123)
            goto LABEL_166;
        }
        *(_QWORD *)(v116 + 16) = v120;
      }
      *(_DWORD *)(v116 + 8) = v107;
LABEL_171:
      if (v107 >= 1)
      {
        v124 = 0;
        v125 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a4 + 16)
                         + *(int *)(*(_QWORD *)a4 + 4) * (uint64_t)v177
                         + *(int *)(a4 + 8));
        do
        {
          v127 = *(__int16 *)(*(_QWORD *)(*(_QWORD *)(a4 + 16) + 16)
                            + *(int *)(*(_QWORD *)(a4 + 16) + 4) * (uint64_t)(v125 + v124)
                            + *(int *)(a4 + 24));
          *(_DWORD *)(*(_QWORD *)(v185 + 16) + *(int *)(v185 + 4) * (uint64_t)v124 + (int)v186) = v127;
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a5 + 224))(a5) || *(_BYTE *)(a4 + 248))
          {
            v126 = (_OWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 80) + 16)
                            + *(int *)(*(_QWORD *)(a4 + 80) + 4) * (uint64_t)v127
                            + *(int *)(a4 + 88));
          }
          else
          {
            v128 = *(_QWORD *)(a4 + 80);
            if (v128 && (v129 = *(_QWORD *)(v128 + 16)) != 0)
              v130 = v129 + *(int *)(v128 + 4) * (uint64_t)v127 + *(int *)(a4 + 88);
            else
              v130 = 0;
            v126 = v184;
            (*(void (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)a5 + 208))(a5, v184, v130, 1);
          }
          *(_OWORD *)(*(_QWORD *)(v187 + 16) + *(int *)(v187 + 4) * (uint64_t)v124++ + (int)v188) = *v126;
        }
        while (v107 != v124);
      }
      v131 = *(_QWORD *)v171;
      if (*(_QWORD *)v171)
        LODWORD(v131) = *(_DWORD *)(v131 + 8);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v172 + 16)
                + *(int *)(*(_QWORD *)v172 + 4) * (uint64_t)v104
                + *((int *)v172 + 2)) = v131;
      if (*(_BYTE *)(*(_QWORD *)(v190 + 16) + *(int *)(v190 + 4) * (uint64_t)v104 + (int)v191))
      {
        HGeometryData::AllocArrays((uint64_t)v172, v107 + 4, v35);
        v132 = (unsigned int *)v185;
        v181[0] = v185;
        if (v185)
        {
          do
            v133 = __ldaxr(v132);
          while (__stlxr(v133 + 1, v132));
        }
        v181[1] = v186;
        v134 = (unsigned int *)v187;
        v180[0] = v187;
        if (v187)
        {
          do
            v135 = __ldaxr(v134);
          while (__stlxr(v135 + 1, v134));
        }
        v180[1] = v188;
        *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v172 + 6) + 16)
                  + *(int *)(*((_QWORD *)v172 + 6) + 4) * (uint64_t)v104
                  + *((int *)v172 + 14)) = HGeometryData::ClipPoly(v172, (int *)v181, a2, a3, (int *)v180, v107, (HGArrayDataRef *)a4, (uint64_t)v183, v182);
        v136 = v180[0];
        if (v180[0])
        {
          do
          {
            v137 = __ldaxr((unsigned int *)v136);
            v138 = v137 - 1;
          }
          while (__stlxr(v138, (unsigned int *)v136));
          if (!v138)
          {
            v139 = *(_QWORD *)(v136 + 16);
            if (v139)
              MEMORY[0x1B5E2914C](v139, 0x1000C8077774924);
            MEMORY[0x1B5E29170](v136, 0x1080C4098BBCF0FLL);
          }
        }
        v140 = v181[0];
        if (v181[0])
        {
          do
          {
            v141 = __ldaxr((unsigned int *)v140);
            v142 = v141 - 1;
          }
          while (__stlxr(v142, (unsigned int *)v140));
          if (!v142)
          {
            v143 = *(_QWORD *)(v140 + 16);
            if (v143)
              MEMORY[0x1B5E2914C](v143, 0x1000C8077774924);
            MEMORY[0x1B5E29170](v140, 0x1080C4098BBCF0FLL);
          }
        }
      }
      else
      {
        *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v172 + 6) + 16)
                  + *(int *)(*((_QWORD *)v172 + 6) + 4) * (uint64_t)v104
                  + *((int *)v172 + 14)) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 48) + 16)
                                                     + *(int *)(*(_QWORD *)(a4 + 48) + 4) * (uint64_t)v177
                                                     + *(int *)(a4 + 56));
        if (v107 >= 1)
        {
          for (i = 0; i != v107; ++i)
          {
            if (v187 && (v145 = *(_QWORD *)(v187 + 16)) != 0)
              v146 = (float32x4_t *)(v145 + *(int *)(v187 + 4) * (uint64_t)i + (int)v188);
            else
              v146 = 0;
            v147 = *(_DWORD *)(*(_QWORD *)(v185 + 16) + *(int *)(v185 + 4) * (uint64_t)i + (int)v186);
            v178 = *(int32x4_t *)v146;
            v148 = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v174);
            v149 = (float32x4_t)vdupq_laneq_s32(v178, 3);
            v150 = vrecpeq_f32(v149);
            v151 = vmulq_f32(v150, vrecpsq_f32(v149, v150));
            v179 = vmulq_f32(vrecpsq_f32(v149, v151), v151);
            *v148 = v179;
            *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v171) = vmulq_f32(v179, *v146);
            v175 = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 64) + 16)
                             + *(int *)(*(_QWORD *)(a4 + 64) + 4) * (uint64_t)v147
                             + *(int *)(a4 + 72));
            *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v170) = v175;
            if ((v35 & 1) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 112)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 112) + 16) + *(int *)(*(_QWORD *)(a4 + 112) + 4) * (uint64_t)v147 + *(int *)(a4 + 120)));
            if ((v35 & 2) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 128)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 128) + 16) + *(int *)(*(_QWORD *)(a4 + 128) + 4) * (uint64_t)v147 + *(int *)(a4 + 136)));
            if ((v35 & 4) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 144)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 144) + 16) + *(int *)(*(_QWORD *)(a4 + 144) + 4) * (uint64_t)v147 + *(int *)(a4 + 152)));
            if ((v35 & 8) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 160)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 160) + 16) + *(int *)(*(_QWORD *)(a4 + 160) + 4) * (uint64_t)v147 + *(int *)(a4 + 168)));
            if ((v35 & 0x10) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 176)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 176) + 16) + *(int *)(*(_QWORD *)(a4 + 176) + 4) * (uint64_t)v147 + *(int *)(a4 + 184)));
            if ((v35 & 0x20) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 192)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 192) + 16) + *(int *)(*(_QWORD *)(a4 + 192) + 4) * (uint64_t)v147 + *(int *)(a4 + 200)));
            if ((v35 & 0x40) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 208)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 208) + 16) + *(int *)(*(_QWORD *)(a4 + 208) + 4) * (uint64_t)v147 + *(int *)(a4 + 216)));
            if ((v35 & 0x80) != 0)
              *(float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)((char *)v172 + 224)) = vmulq_f32(v179, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 224) + 16) + *(int *)(*(_QWORD *)(a4 + 224) + 4) * (uint64_t)v147 + *(int *)(a4 + 232)));
          }
        }
      }
      if (++v104 == v173[0])
        goto LABEL_227;
    }
    v109 = *(_DWORD *)(v185 + 12);
    if (v109 < v107)
    {
      v110 = *(_DWORD *)(v185 + 4);
      *(_DWORD *)(v185 + 12) = v107;
      if (v110 * v107)
      {
        v111 = (void *)operator new[]();
        v112 = v111;
        v113 = v110 * v109;
        if (v110 * v109)
        {
          v114 = *(const void **)(v108 + 16);
          if (v114)
          {
            if (v113 >= v110 * v107)
              v113 = v110 * v107;
            memcpy(v111, v114, v113);
          }
        }
        v115 = *(_QWORD *)(v108 + 16);
        if (v115)
LABEL_152:
          MEMORY[0x1B5E2914C](v115, 0x1000C8077774924);
      }
      else
      {
        v112 = 0;
        v115 = *(_QWORD *)(v108 + 16);
        if (v115)
          goto LABEL_152;
      }
      *(_QWORD *)(v108 + 16) = v112;
    }
    *(_DWORD *)(v108 + 8) = v107;
    goto LABEL_157;
  }
LABEL_227:
  HGeometryData::~HGeometryData((HGeometryData *)v182);
  HGeometryData::~HGeometryData((HGeometryData *)v183);
  v152 = v185;
  if (v185)
  {
    do
    {
      v153 = __ldaxr((unsigned int *)v152);
      v154 = v153 - 1;
    }
    while (__stlxr(v154, (unsigned int *)v152));
    if (!v154)
    {
      v155 = *(_QWORD *)(v152 + 16);
      if (v155)
        MEMORY[0x1B5E2914C](v155, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v152, 0x1080C4098BBCF0FLL);
    }
  }
  v156 = v187;
  if (v187)
  {
    do
    {
      v157 = __ldaxr((unsigned int *)v156);
      v158 = v157 - 1;
    }
    while (__stlxr(v158, (unsigned int *)v156));
    if (!v158)
    {
      v159 = *(_QWORD *)(v156 + 16);
      if (v159)
        MEMORY[0x1B5E2914C](v159, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v156, 0x1080C4098BBCF0FLL);
    }
  }
LABEL_239:
  v160 = v190;
  if (v190)
  {
    do
    {
      v161 = __ldaxr((unsigned int *)v160);
      v162 = v161 - 1;
    }
    while (__stlxr(v162, (unsigned int *)v160));
    if (!v162)
    {
      v163 = *(_QWORD *)(v160 + 16);
      if (v163)
        MEMORY[0x1B5E2914C](v163, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v160, 0x1080C4098BBCF0FLL);
    }
  }
  v164 = v192;
  if (v192)
  {
    do
    {
      v165 = __ldaxr((unsigned int *)v164);
      v166 = v165 - 1;
    }
    while (__stlxr(v166, (unsigned int *)v164));
    if (!v166)
    {
      v167 = *(_QWORD *)(v164 + 16);
      if (v167)
        MEMORY[0x1B5E2914C](v167, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v164, 0x1080C4098BBCF0FLL);
    }
  }
}

void sub_1B29C7D0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 120));
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t HGeometryData::AllocArrays(uint64_t this, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t v5;
  uint64_t v6;
  HGArrayDataRef *v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  void *v13;
  void *v14;
  const void *v15;
  int v16;
  HGArrayDataRef *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  void *v24;
  void *v25;
  const void *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  void *v35;
  void *v36;
  const void *v37;
  int v38;
  uint64_t v39;
  HGArrayDataRef *i;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  void *v47;
  void *v48;
  const void *v49;
  int v50;

  v3 = *(_DWORD *)(this + 260);
  if (v3 < a2)
  {
    v5 = this;
    if (v3)
    {
      LODWORD(v6) = 2 * v3;
    }
    else
    {
      v6 = *(_QWORD *)(this + 272);
      if (!v6)
      {
        v7 = (HGArrayDataRef *)(this + 64);
        v8 = *(_QWORD *)(v5 + 64);
        LODWORD(v6) = 256;
        *(_DWORD *)(v5 + 260) = 256;
        if (v8)
        {
LABEL_6:
          v9 = *(_DWORD *)(v8 + 12);
          if (v9 < (int)v6)
          {
            v10 = *(_DWORD *)(v8 + 4);
            v11 = v10 * v6;
            *(_DWORD *)(v8 + 12) = v6;
            if (v10 * (_DWORD)v6)
            {
              v12 = v10 * v9;
              v13 = (void *)operator new[]();
              v14 = v13;
              if (v12)
              {
                v15 = *(const void **)(v8 + 16);
                if (v15)
                {
                  if (v12 >= v11)
                    v16 = v11;
                  else
                    v16 = v12;
                  memcpy(v13, v15, v16);
                }
              }
            }
            else
            {
              v14 = 0;
            }
            v28 = *(_QWORD *)(v8 + 16);
            if (v28)
              MEMORY[0x1B5E2914C](v28, 0x1000C8077774924);
            *(_QWORD *)(v8 + 16) = v14;
            v17 = (HGArrayDataRef *)(v5 + 80);
            v18 = *(_QWORD *)(v5 + 80);
            v19 = *(_DWORD *)(v5 + 260);
            if (!v18)
              goto LABEL_31;
            goto LABEL_17;
          }
LABEL_16:
          v17 = (HGArrayDataRef *)(v5 + 80);
          v18 = *(_QWORD *)(v5 + 80);
          v19 = *(_DWORD *)(v5 + 260);
          if (!v18)
          {
LABEL_31:
            if (v19 < 1)
            {
LABEL_38:
              this = v5 + 96;
              v30 = *(_QWORD *)(v5 + 96);
              if (v30)
              {
                v31 = *(_DWORD *)(v30 + 12);
                if (v31 < v19)
                {
                  v32 = *(_DWORD *)(v30 + 4);
                  v33 = v32 * v19;
                  *(_DWORD *)(v30 + 12) = v19;
                  if (v32 * v19)
                  {
                    v34 = v32 * v31;
                    v35 = (void *)operator new[]();
                    v36 = v35;
                    if (v34)
                    {
                      v37 = *(const void **)(v30 + 16);
                      if (v37)
                      {
                        if (v34 >= v33)
                          v38 = v33;
                        else
                          v38 = v34;
                        memcpy(v35, v37, v38);
                      }
                    }
                  }
                  else
                  {
                    v36 = 0;
                  }
                  this = *(_QWORD *)(v30 + 16);
                  if (this)
                    this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
                  *(_QWORD *)(v30 + 16) = v36;
                }
              }
              else if (v19 >= 1)
              {
                this = HGArrayDataRef::allocate((HGArrayDataRef *)this, 16, v19, v19);
              }
              v39 = 0;
              for (i = (HGArrayDataRef *)(v5 + 112); ; i = (HGArrayDataRef *)((char *)i + 16))
              {
                if (((a3 >> v39) & 1) != 0)
                {
                  v41 = *(_DWORD *)(v5 + 260);
                  v42 = *(_QWORD *)i;
                  if (!*(_QWORD *)i)
                  {
                    if (v41 > 0)
                      this = HGArrayDataRef::allocate(i, 16, v41, *(_DWORD *)(v5 + 260));
                    goto LABEL_55;
                  }
                  v43 = *(_DWORD *)(v42 + 12);
                  if (v43 < v41)
                    break;
                }
LABEL_55:
                if (++v39 == 8)
                  return this;
              }
              v44 = *(_DWORD *)(v42 + 4);
              v45 = v44 * v41;
              *(_DWORD *)(v42 + 12) = v41;
              if (v44 * v41)
              {
                v46 = v44 * v43;
                v47 = (void *)operator new[]();
                v48 = v47;
                if (v46)
                {
                  v49 = *(const void **)(v42 + 16);
                  if (v49)
                  {
                    if (v46 >= v45)
                      v50 = v45;
                    else
                      v50 = v46;
                    memcpy(v47, v49, v50);
                  }
                }
                this = *(_QWORD *)(v42 + 16);
                if (!this)
                  goto LABEL_54;
              }
              else
              {
                v48 = 0;
                this = *(_QWORD *)(v42 + 16);
                if (!this)
                {
LABEL_54:
                  *(_QWORD *)(v42 + 16) = v48;
                  goto LABEL_55;
                }
              }
              this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
              goto LABEL_54;
            }
            HGArrayDataRef::allocate(v17, 16, v19, v19);
LABEL_37:
            v19 = *(_DWORD *)(v5 + 260);
            goto LABEL_38;
          }
LABEL_17:
          v20 = *(_DWORD *)(v18 + 12);
          if (v20 < v19)
          {
            v21 = *(_DWORD *)(v18 + 4);
            v22 = v21 * v19;
            *(_DWORD *)(v18 + 12) = v19;
            if (v21 * v19)
            {
              v23 = v21 * v20;
              v24 = (void *)operator new[]();
              v25 = v24;
              if (v23)
              {
                v26 = *(const void **)(v18 + 16);
                if (v26)
                {
                  if (v23 >= v22)
                    v27 = v22;
                  else
                    v27 = v23;
                  memcpy(v24, v26, v27);
                }
              }
            }
            else
            {
              v25 = 0;
            }
            v29 = *(_QWORD *)(v18 + 16);
            if (v29)
              MEMORY[0x1B5E2914C](v29, 0x1000C8077774924);
            *(_QWORD *)(v18 + 16) = v25;
          }
          goto LABEL_37;
        }
LABEL_15:
        HGArrayDataRef::allocate(v7, 16, v6, v6);
        goto LABEL_16;
      }
    }
    v7 = (HGArrayDataRef *)(this + 64);
    v8 = *(_QWORD *)(v5 + 64);
    *(_DWORD *)(v5 + 260) = v6;
    if (v8)
      goto LABEL_6;
    if ((int)v6 <= 0)
      goto LABEL_16;
    goto LABEL_15;
  }
  return this;
}

uint64_t HGeometryData::ClipPolyW(HGRasterizer **this, int a2, HGeometryData *a3)
{
  unsigned int v6;
  float v7;
  uint64_t v8;
  int v9;
  HGRasterizer *v10;
  int v11;
  int v12;
  int v13;
  void *v14;
  void *v15;
  int v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  void *v25;
  void *v26;
  int v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  HGArrayDataRef *v31;
  HGArrayDataRef *v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  void *v37;
  void *v38;
  int v39;
  const void *v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  void *v45;
  void *v46;
  int v47;
  const void *v48;
  uint64_t v49;
  int i;
  uint64_t v51;
  _OWORD *v52;
  uint64_t v53;
  int *v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  void *v59;
  void *v60;
  int v61;
  const void *v62;
  uint64_t v63;
  _OWORD *v64;
  HGArrayDataRef *v65;
  uint64_t v66;
  uint64_t v67;
  _OWORD *v68;
  uint64_t v69;
  char *v70;
  HGArrayDataRef *v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  int v76;
  void *v77;
  void *v78;
  int v79;
  const void *v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  int v84;
  int v85;
  int v86;
  void *v87;
  void *v88;
  int v89;
  const void *v90;
  uint64_t v91;
  int j;
  uint64_t v93;
  int v94;
  uint64_t v95;
  float32x4_t *v96;
  int8x16_t v97;
  unsigned __int32 v98;
  _BOOL4 v99;
  unsigned int v100;
  int v101;
  float32x4_t v102;
  int v103;
  int v104;
  int8x16_t v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v123;
  HGeometryData *v124;
  HGArrayDataRef *v125;
  unsigned int v126;
  int v127[4];
  int v128[4];
  int v129[4];
  int v130[4];
  int v131[4];
  int v132[4];
  int v133[4];
  int v134[4];
  int v135[4];
  int v136[4];
  int v137[4];
  unsigned int v138;
  _OWORD v139[4];
  uint64_t v140;
  int v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  int v145;
  uint64_t v146;
  int v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  int v153;
  uint64_t v154;
  int v155;
  uint64_t v156;
  int v157;
  uint64_t v158;
  int v159;
  uint64_t v160;
  int v161;
  char v162;
  _OWORD v163[4];
  uint64_t v164;
  int v165;
  uint64_t v166;
  int v167;
  char v168;

  HGeometryData::HGeometryData((HGeometryData *)v163, this[33], 0);
  HGeometryData::HGeometryData((HGeometryData *)v139, this[33], 0);
  v168 = 1;
  v162 = 1;
  v6 = *(_DWORD *)(*((_QWORD *)this[6] + 2) + *((int *)this[6] + 1) * (uint64_t)a2 + *((int *)this + 14));
  v7 = (float)((float)v6 * 1.5) + 4.0;
  v8 = v7;
  v9 = *(_DWORD *)(*((_QWORD *)*this + 2) + *((int *)*this + 1) * (uint64_t)a2 + *((int *)this + 2));
  v10 = this[12];
  v126 = v7;
  if (v10)
  {
    v11 = *((_DWORD *)v10 + 3);
    if (v11 < (int)v8)
    {
      v12 = *((_DWORD *)v10 + 1);
      v13 = v12 * v8;
      *((_DWORD *)v10 + 3) = v8;
      if (v12 * (_DWORD)v8)
      {
        v14 = (void *)operator new[]();
        v8 = v126;
        v15 = v14;
        v16 = v12 * v11;
        if (v12 * v11)
        {
          v17 = (const void *)*((_QWORD *)v10 + 2);
          if (v17)
          {
            if (v16 >= v13)
              v16 = v13;
            memcpy(v14, v17, v16);
            v8 = v126;
          }
        }
      }
      else
      {
        v15 = 0;
      }
      v18 = *((_QWORD *)v10 + 2);
      if (v18)
      {
        MEMORY[0x1B5E2914C](v18, 0x1000C8077774924, v8);
        v8 = v126;
      }
      *((_QWORD *)v10 + 2) = v15;
    }
    *((_DWORD *)v10 + 2) = v8;
  }
  else if ((int)v8 > 0)
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)(this + 12), 16, v8, v126);
    v8 = v126;
  }
  v123 = a2;
  v19 = 0;
  v20 = 0;
  v124 = a3;
  v125 = (HGeometryData *)((char *)a3 + 64);
  do
  {
    v21 = *(uint64_t *)((char *)&v164 + v19);
    if (!v21)
    {
      if ((int)v8 <= 0)
      {
        v30 = *(uint64_t *)((char *)&v140 + v19);
        if (!v30)
          goto LABEL_49;
      }
      else
      {
        HGArrayDataRef::allocate((HGArrayDataRef *)((char *)&v164 + v19), 16, v8, v126);
        v8 = v126;
        v31 = (HGArrayDataRef *)((char *)&v140 + v19);
        v30 = *(uint64_t *)((char *)&v140 + v19);
        if (!v30)
          goto LABEL_35;
      }
LABEL_38:
      v34 = *(_DWORD *)(v30 + 12);
      if (v34 >= (int)v8)
      {
LABEL_48:
        *(_DWORD *)(v30 + 8) = v8;
        goto LABEL_49;
      }
      v35 = *(_DWORD *)(v30 + 4);
      v36 = v35 * v8;
      *(_DWORD *)(v30 + 12) = v8;
      if (v35 * (_DWORD)v8)
      {
        v37 = (void *)operator new[]();
        v8 = v126;
        v38 = v37;
        v39 = v35 * v34;
        if (v35 * v34)
        {
          v40 = *(const void **)(v30 + 16);
          if (v40)
          {
            if (v39 >= v36)
              v39 = v36;
            memcpy(v37, v40, v39);
            v8 = v126;
          }
        }
        v41 = *(_QWORD *)(v30 + 16);
        if (!v41)
          goto LABEL_47;
      }
      else
      {
        v38 = 0;
        v41 = *(_QWORD *)(v30 + 16);
        if (!v41)
          goto LABEL_47;
      }
      MEMORY[0x1B5E2914C](v41, 0x1000C8077774924, v8);
      v8 = v126;
LABEL_47:
      *(_QWORD *)(v30 + 16) = v38;
      goto LABEL_48;
    }
    v22 = *(_DWORD *)(v21 + 12);
    if (v22 >= (int)v8)
      goto LABEL_30;
    v23 = *(_DWORD *)(v21 + 4);
    v24 = v23 * v8;
    *(_DWORD *)(v21 + 12) = v8;
    if (v23 * (_DWORD)v8)
    {
      v25 = (void *)operator new[]();
      v8 = v126;
      v26 = v25;
      v27 = v23 * v22;
      if (v23 * v22)
      {
        v28 = *(const void **)(v21 + 16);
        if (v28)
        {
          if (v27 >= v24)
            v27 = v24;
          memcpy(v25, v28, v27);
          v8 = v126;
        }
      }
      v29 = *(_QWORD *)(v21 + 16);
      if (!v29)
        goto LABEL_29;
    }
    else
    {
      v26 = 0;
      v29 = *(_QWORD *)(v21 + 16);
      if (!v29)
        goto LABEL_29;
    }
    MEMORY[0x1B5E2914C](v29, 0x1000C8077774924, v8);
    v8 = v126;
LABEL_29:
    *(_QWORD *)(v21 + 16) = v26;
LABEL_30:
    *(_DWORD *)(v21 + 8) = v8;
    v30 = *(uint64_t *)((char *)&v140 + v19);
    if (v30)
      goto LABEL_38;
    if ((int)v8 > 0)
    {
      v31 = (HGArrayDataRef *)&v139[v20 + 4];
LABEL_35:
      HGArrayDataRef::allocate(v31, 16, v8, v126);
      v8 = v126;
      v32 = (HGArrayDataRef *)((char *)v125 + v19);
      v33 = *(_QWORD *)((char *)v125 + v19);
      if (!v33)
        goto LABEL_61;
      goto LABEL_50;
    }
LABEL_49:
    v33 = *(_QWORD *)((char *)v125 + v19);
    if (!v33)
    {
      if ((int)v8 <= 0)
        goto LABEL_18;
      v32 = (HGeometryData *)((char *)v124 + 16 * v20 + 64);
LABEL_61:
      HGArrayDataRef::allocate(v32, 16, v8, v126);
      v8 = v126;
      goto LABEL_18;
    }
LABEL_50:
    v42 = *(_DWORD *)(v33 + 12);
    if (v42 < (int)v8)
    {
      v43 = *(_DWORD *)(v33 + 4);
      v44 = v43 * v8;
      *(_DWORD *)(v33 + 12) = v8;
      if (v43 * (_DWORD)v8)
      {
        v45 = (void *)operator new[]();
        v8 = v126;
        v46 = v45;
        v47 = v43 * v42;
        if (v43 * v42)
        {
          v48 = *(const void **)(v33 + 16);
          if (v48)
          {
            if (v47 >= v44)
              v47 = v44;
            memcpy(v45, v48, v47);
            v8 = v126;
          }
        }
        v49 = *(_QWORD *)(v33 + 16);
        if (!v49)
          goto LABEL_17;
LABEL_67:
        MEMORY[0x1B5E2914C](v49, 0x1000C8077774924, v8);
        v8 = v126;
      }
      else
      {
        v46 = 0;
        v49 = *(_QWORD *)(v33 + 16);
        if (v49)
          goto LABEL_67;
      }
LABEL_17:
      *(_QWORD *)(v33 + 16) = v46;
    }
LABEL_18:
    ++v20;
    v19 += 16;
  }
  while (v19 != 48);
  if (v6)
  {
    for (i = 0; i != v6; ++i)
    {
      *(_OWORD *)(*(_QWORD *)(v166 + 16) + *(int *)(v166 + 4) * (uint64_t)i + v167) = *(_OWORD *)(*((_QWORD *)this[10] + 2)
                                                                                               + *((int *)this[10] + 1)
                                                                                               * (uint64_t)*(__int16 *)(*((_QWORD *)this[2] + 2) + *((int *)this[2] + 1) * (uint64_t)(v9 + i) + *((int *)this + 6))
                                                                                               + *((int *)this + 22));
      *(_OWORD *)(*(_QWORD *)(v164 + 16) + *(int *)(v164 + 4) * (uint64_t)i + v165) = *(_OWORD *)(*((_QWORD *)this[8] + 2)
                                                                                               + *((int *)this[8] + 1)
                                                                                               * (uint64_t)*(__int16 *)(*((_QWORD *)this[2] + 2) + *((int *)this[2] + 1) * (uint64_t)(v9 + i) + *((int *)this + 6))
                                                                                               + *((int *)this + 18));
    }
  }
  v51 = 0;
  while (2)
  {
    if (((*((_DWORD *)this[33] + 267) >> v51) & 1) == 0)
      goto LABEL_72;
    v52 = &v163[v51];
    v55 = *((_QWORD *)v52 + 14);
    v54 = (int *)(v52 + 7);
    v53 = v55;
    if (!v55)
    {
      if ((int)v8 <= 0)
      {
        v66 = *(&v146 + 2 * v51);
        if (!v66)
          goto LABEL_104;
      }
      else
      {
        HGArrayDataRef::allocate((HGArrayDataRef *)v54, 16, v8, v126);
        v8 = v126;
        v68 = &v139[v51];
        v69 = *((_QWORD *)v68 + 14);
        v65 = (HGArrayDataRef *)(v68 + 7);
        v66 = v69;
        if (!v69)
        {
LABEL_90:
          HGArrayDataRef::allocate(v65, 16, v8, v126);
          v8 = v126;
          v70 = (char *)v124 + 16 * v51;
          v73 = *((_QWORD *)v70 + 14);
          v71 = (HGArrayDataRef *)(v70 + 112);
          v72 = v73;
          if (v73)
            goto LABEL_105;
          goto LABEL_116;
        }
      }
LABEL_93:
      v74 = *(_DWORD *)(v66 + 12);
      if (v74 >= (int)v8)
      {
LABEL_103:
        *(_DWORD *)(v66 + 8) = v8;
        goto LABEL_104;
      }
      v75 = *(_DWORD *)(v66 + 4);
      v76 = v75 * v8;
      *(_DWORD *)(v66 + 12) = v8;
      if (v75 * (_DWORD)v8)
      {
        v77 = (void *)operator new[]();
        v8 = v126;
        v78 = v77;
        v79 = v75 * v74;
        if (v75 * v74)
        {
          v80 = *(const void **)(v66 + 16);
          if (v80)
          {
            if (v79 >= v76)
              v79 = v76;
            memcpy(v77, v80, v79);
            v8 = v126;
          }
        }
        v81 = *(_QWORD *)(v66 + 16);
        if (!v81)
          goto LABEL_102;
      }
      else
      {
        v78 = 0;
        v81 = *(_QWORD *)(v66 + 16);
        if (!v81)
          goto LABEL_102;
      }
      MEMORY[0x1B5E2914C](v81, 0x1000C8077774924, v8);
      v8 = v126;
LABEL_102:
      *(_QWORD *)(v66 + 16) = v78;
      goto LABEL_103;
    }
    v56 = *(_DWORD *)(v53 + 12);
    if (v56 < (int)v8)
    {
      v57 = *(_DWORD *)(v53 + 4);
      v58 = v57 * v8;
      *(_DWORD *)(v53 + 12) = v8;
      if (v57 * (_DWORD)v8)
      {
        v59 = (void *)operator new[]();
        v8 = v126;
        v60 = v59;
        v61 = v57 * v56;
        if (v57 * v56)
        {
          v62 = *(const void **)(v53 + 16);
          if (v62)
          {
            if (v61 >= v58)
              v61 = v58;
            memcpy(v59, v62, v61);
            v8 = v126;
          }
        }
        v63 = *(_QWORD *)(v53 + 16);
        if (v63)
        {
LABEL_83:
          MEMORY[0x1B5E2914C](v63, 0x1000C8077774924, v8);
          v8 = v126;
        }
      }
      else
      {
        v60 = 0;
        v63 = *(_QWORD *)(v53 + 16);
        if (v63)
          goto LABEL_83;
      }
      *(_QWORD *)(v53 + 16) = v60;
    }
    *(_DWORD *)(v53 + 8) = v8;
    v64 = &v139[v51];
    v67 = *((_QWORD *)v64 + 14);
    v65 = (HGArrayDataRef *)(v64 + 7);
    v66 = v67;
    if (v67)
      goto LABEL_93;
    if ((int)v8 > 0)
      goto LABEL_90;
LABEL_104:
    v82 = (char *)v124 + 16 * v51;
    v83 = *((_QWORD *)v82 + 14);
    v71 = (HGArrayDataRef *)(v82 + 112);
    v72 = v83;
    if (!v83)
    {
      if ((int)v8 <= 0)
        goto LABEL_117;
LABEL_116:
      HGArrayDataRef::allocate(v71, 16, v8, v126);
      v8 = v126;
      goto LABEL_117;
    }
LABEL_105:
    v84 = *(_DWORD *)(v72 + 12);
    if (v84 < (int)v8)
    {
      v85 = *(_DWORD *)(v72 + 4);
      v86 = v85 * v8;
      *(_DWORD *)(v72 + 12) = v8;
      if (v85 * (_DWORD)v8)
      {
        v87 = (void *)operator new[]();
        v8 = v126;
        v88 = v87;
        v89 = v85 * v84;
        if (v85 * v84)
        {
          v90 = *(const void **)(v72 + 16);
          if (v90)
          {
            if (v89 >= v86)
              v89 = v86;
            memcpy(v87, v90, v89);
            v8 = v126;
          }
        }
        v91 = *(_QWORD *)(v72 + 16);
        if (v91)
        {
LABEL_113:
          MEMORY[0x1B5E2914C](v91, 0x1000C8077774924, v8);
          v8 = v126;
        }
      }
      else
      {
        v88 = 0;
        v91 = *(_QWORD *)(v72 + 16);
        if (v91)
          goto LABEL_113;
      }
      *(_QWORD *)(v72 + 16) = v88;
    }
LABEL_117:
    if (v6)
    {
      for (j = 0; j != v6; ++j)
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)v54 + 16) + *(int *)(*(_QWORD *)v54 + 4) * (uint64_t)j + v54[2]) = *(_OWORD *)(*((_QWORD *)this[2 * v51 + 14] + 2) + *((int *)this[2 * v51 + 14] + 1) * (uint64_t)*(__int16 *)(*((_QWORD *)this[2] + 2) + *((int *)this[2] + 1) * (uint64_t)(v9 + j) + *((int *)this + 6)) + SLODWORD(this[2 * v51 + 15]));
    }
LABEL_72:
    if (++v51 != 8)
      continue;
    break;
  }
  v138 = 0;
  HGeometryData::ClipToEdge(0, 3, (uint64_t)v163, v6, (uint64_t)v139, (int *)&v138, *((_DWORD *)this[33] + 267), *((float *)this[33] + 102));
  v93 = v138;
  if (v138 >= 2)
  {
    v94 = 0;
    v95 = v142;
    v96 = (float32x4_t *)(*(_QWORD *)(v142 + 16) + v143);
    v97 = vmvnq_s8((int8x16_t)vceqq_f32(*v96, *(float32x4_t *)((char *)v96 + (int)(*(_DWORD *)(v142 + 4) * (v138 - 1)))));
    *(int32x2_t *)v97.i8 = vpmin_s32(*(int32x2_t *)v97.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v97, v97, 8uLL));
    v98 = vpmin_s32(*(int32x2_t *)v97.i8, *(int32x2_t *)v97.i8).u32[0];
    v99 = v98 == 0;
    v100 = v99 - v138;
    if (v98)
      v93 = v138;
    else
      v93 = v138 - 1;
    if (v98)
      v101 = 0;
    else
      v101 = *(_DWORD *)(v142 + 4);
    v102 = *(float32x4_t *)((char *)v96 + v101);
    v103 = v143;
    do
    {
      while (1)
      {
        v104 = v99 + v94;
        if (!v94)
          break;
        v105 = vmvnq_s8((int8x16_t)vceqq_f32(v102, *(float32x4_t *)(*(_QWORD *)(v95 + 16) + *(int *)(v95 + 4) * (uint64_t)v104 + v103)));
        *(int32x2_t *)v105.i8 = vpmin_s32(*(int32x2_t *)v105.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v105, v105, 8uLL));
        if (vpmin_s32(*(int32x2_t *)v105.i8, *(int32x2_t *)v105.i8).u32[0])
          break;
        v93 = (v93 - 1);
        ++v94;
        if (!(v100 + v94))
          goto LABEL_155;
      }
      *(_OWORD *)v127 = *(_OWORD *)(*(_QWORD *)(v140 + 16) + *(int *)(v140 + 4) * (uint64_t)v104 + v141);
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 64)) = *(_OWORD *)v127;
      *(_OWORD *)v128 = *(_OWORD *)(*(_QWORD *)(v142 + 16) + *(int *)(v142 + 4) * (uint64_t)v104 + v143);
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 80)) = *(_OWORD *)v128;
      *(_OWORD *)v129 = *(_OWORD *)(*(_QWORD *)(v144 + 16) + *(int *)(v144 + 4) * (uint64_t)v104 + v145);
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 96)) = *(_OWORD *)v129;
      v106 = *((_DWORD *)this[33] + 267);
      if ((v106 & 1) != 0)
      {
        *(_OWORD *)v130 = *(_OWORD *)(*(_QWORD *)(v146 + 16) + *(int *)(v146 + 4) * (uint64_t)v104 + v147);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 112)) = *(_OWORD *)v130;
        v106 = *((_DWORD *)this[33] + 267);
      }
      if ((v106 & 2) != 0)
      {
        *(_OWORD *)v131 = *(_OWORD *)(*(_QWORD *)(v148 + 16) + *(int *)(v148 + 4) * (uint64_t)v104 + v149);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 128)) = *(_OWORD *)v131;
        v106 = *((_DWORD *)this[33] + 267);
      }
      if ((v106 & 4) != 0)
      {
        *(_OWORD *)v132 = *(_OWORD *)(*(_QWORD *)(v150 + 16) + *(int *)(v150 + 4) * (uint64_t)v104 + v151);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 144)) = *(_OWORD *)v132;
        v106 = *((_DWORD *)this[33] + 267);
      }
      if ((v106 & 8) != 0)
      {
        *(_OWORD *)v133 = *(_OWORD *)(*(_QWORD *)(v152 + 16) + *(int *)(v152 + 4) * (uint64_t)v104 + v153);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 160)) = *(_OWORD *)v133;
        v106 = *((_DWORD *)this[33] + 267);
      }
      if ((v106 & 0x10) != 0)
      {
        *(_OWORD *)v134 = *(_OWORD *)(*(_QWORD *)(v154 + 16) + *(int *)(v154 + 4) * (uint64_t)v104 + v155);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 176)) = *(_OWORD *)v134;
        v106 = *((_DWORD *)this[33] + 267);
      }
      if ((v106 & 0x20) != 0)
      {
        *(_OWORD *)v135 = *(_OWORD *)(*(_QWORD *)(v156 + 16) + *(int *)(v156 + 4) * (uint64_t)v104 + v157);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 192)) = *(_OWORD *)v135;
        v106 = *((_DWORD *)this[33] + 267);
      }
      if ((v106 & 0x40) != 0)
      {
        *(_OWORD *)v136 = *(_OWORD *)(*(_QWORD *)(v158 + 16) + *(int *)(v158 + 4) * (uint64_t)v104 + v159);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 208)) = *(_OWORD *)v136;
        v106 = *((_DWORD *)this[33] + 267);
      }
      if ((v106 & 0x80) != 0)
      {
        *(_OWORD *)v137 = *(_OWORD *)(*(_QWORD *)(v160 + 16) + *(int *)(v160 + 4) * (uint64_t)v104 + v161);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGeometryData *)((char *)v124 + 224)) = *(_OWORD *)v137;
      }
      v95 = v142;
      v103 = v143;
      v102 = *(float32x4_t *)(*(_QWORD *)(v142 + 16) + *(int *)(v142 + 4) * (uint64_t)v104 + v143);
      ++v94;
    }
    while (v100 + v94);
  }
LABEL_155:
  v107 = *((_QWORD *)v124 + 6);
  v108 = *(_QWORD *)(v107 + 16);
  *(_DWORD *)(v108 + *(int *)(v107 + 4) * (uint64_t)v123 + *((int *)v124 + 14)) = v93;
  v109 = *(_QWORD *)v124;
  v110 = *(_QWORD *)(*(_QWORD *)v124 + 16);
  if (v123)
    *(_DWORD *)(v110 + *(_DWORD *)(*(_QWORD *)v124 + 4) * v123 + *((int *)v124 + 2)) = *(_DWORD *)(v108 + *(int *)(v107 + 4) * (uint64_t)(v123 - 1) + *((int *)v124 + 14))
                                                                                       + *(_DWORD *)(v110 + *(_DWORD *)(*(_QWORD *)v124 + 4) * (v123 - 1) + *((int *)v124 + 2));
  else
    *(_DWORD *)(v110 + *((int *)v124 + 2)) = 0;
  v111 = *(_DWORD *)(v110 + *(int *)(v109 + 4) * (uint64_t)v123 + *((int *)v124 + 2));
  HGeometryData::SizeIndexArrays((uint64_t)v124, 0, v93);
  if ((_DWORD)v93)
  {
    v112 = *((_QWORD *)v124 + 2);
    v113 = *(_QWORD *)(v112 + 16);
    v114 = *(_DWORD *)(v112 + 4);
    v115 = v113 + *((int *)v124 + 6);
    if ((_DWORD)v93 == 1)
    {
      v116 = 0;
      goto LABEL_166;
    }
    v116 = 0;
    if (v114 != 1)
      goto LABEL_166;
    if ((int)v93 + v111 - 1 < v111)
      goto LABEL_166;
    v116 = v93 & 0xFFFFFFFE;
    v117 = v93 & 0xFFFFFFFE;
    v118 = v111;
    do
    {
      *(_WORD *)(v115 + v118) = v118;
      *(_WORD *)(v115 + v118 + 1) = v118 + 1;
      v118 += 2;
      v117 -= 2;
    }
    while (v117);
    if ((_DWORD)v93 != v116)
    {
LABEL_166:
      v119 = v93 - v116;
      v120 = v116 + v111;
      v121 = v114 * v120;
      do
      {
        *(_WORD *)(v115 + v121) = v120;
        v121 += v114;
        ++v120;
        --v119;
      }
      while (v119);
    }
  }
  HGeometryData::~HGeometryData((HGeometryData *)v139);
  HGeometryData::~HGeometryData((HGeometryData *)v163);
  return v93;
}

void sub_1B29C8EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  HGeometryData::~HGeometryData((HGeometryData *)&a22);
  HGeometryData::~HGeometryData((HGeometryData *)&a57);
  _Unwind_Resume(a1);
}

uint64_t HGeometryData::SizeIndexArrays(uint64_t this, unsigned int a2, int a3)
{
  uint64_t v5;
  HGArrayDataRef *v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  void *v15;
  void *v16;
  const void *v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  void *v24;
  void *v25;
  const void *v26;
  int v27;
  HGArrayDataRef *v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  void *v37;
  void *v38;
  const void *v39;
  int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  void *v48;
  void *v49;
  const void *v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  void *v57;
  void *v58;
  const void *v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  int v65;
  int v66;
  void *v67;
  void *v68;
  const void *v69;
  int v70;

  v5 = this;
  v6 = (HGArrayDataRef *)(this + 48);
  v7 = *(_QWORD *)(this + 48);
  if (v7)
  {
    v8 = *(_DWORD *)(this + 252);
    if (*(_DWORD *)(v7 + 8) + a2 <= v8)
      goto LABEL_37;
  }
  else
  {
    v8 = *(_DWORD *)(this + 252);
    if (a2 <= v8)
      goto LABEL_37;
  }
  v9 = 2 * v8;
  if (2 * v8 <= v8 + a2)
    v9 = v8 + a2;
  if (v8)
    v10 = v9;
  else
    v10 = a2;
  *(_DWORD *)(this + 252) = v10;
  if (v7)
  {
    v11 = *(_DWORD *)(v7 + 12);
    if (v11 >= v10)
      goto LABEL_26;
    v12 = *(_DWORD *)(v7 + 4);
    v13 = v12 * v10;
    *(_DWORD *)(v7 + 12) = v10;
    if (v12 * v10)
    {
      v14 = v12 * v11;
      v15 = (void *)operator new[]();
      v16 = v15;
      if (v14)
      {
        v17 = *(const void **)(v7 + 16);
        if (v17)
        {
          if (v14 >= v13)
            v18 = v13;
          else
            v18 = v14;
          memcpy(v15, v17, v18);
        }
      }
    }
    else
    {
      v16 = 0;
    }
    this = *(_QWORD *)(v7 + 16);
    if (this)
      this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
    *(_QWORD *)(v7 + 16) = v16;
  }
  else
  {
    if (v10 <= 0)
      goto LABEL_26;
    this = HGArrayDataRef::allocate((HGArrayDataRef *)(this + 48), 4, v10, v10);
  }
  v10 = *(_DWORD *)(v5 + 252);
LABEL_26:
  v19 = *(_QWORD *)v5;
  if (!*(_QWORD *)v5)
  {
    if (v10 > 0)
      this = HGArrayDataRef::allocate((HGArrayDataRef *)v5, 4, v10, v10);
LABEL_37:
    v28 = (HGArrayDataRef *)(v5 + 16);
    v29 = *(_QWORD *)(v5 + 16);
    if (v29)
      goto LABEL_38;
    goto LABEL_44;
  }
  v20 = *(_DWORD *)(v19 + 12);
  if (v20 >= v10)
    goto LABEL_37;
  v21 = *(_DWORD *)(v19 + 4);
  v22 = v21 * v10;
  *(_DWORD *)(v19 + 12) = v10;
  if (v21 * v10)
  {
    v23 = v21 * v20;
    v24 = (void *)operator new[]();
    v25 = v24;
    if (v23)
    {
      v26 = *(const void **)(v19 + 16);
      if (v26)
      {
        if (v23 >= v22)
          v27 = v22;
        else
          v27 = v23;
        memcpy(v24, v26, v27);
      }
    }
  }
  else
  {
    v25 = 0;
  }
  this = *(_QWORD *)(v19 + 16);
  if (this)
    this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
  *(_QWORD *)(v19 + 16) = v25;
  v28 = (HGArrayDataRef *)(v5 + 16);
  v29 = *(_QWORD *)(v5 + 16);
  if (v29)
  {
LABEL_38:
    v30 = *(_DWORD *)(v5 + 256);
    if (*(_DWORD *)(v29 + 8) + a3 <= v30)
      goto LABEL_61;
    goto LABEL_45;
  }
LABEL_44:
  v30 = *(_DWORD *)(v5 + 256);
  if (a3 <= v30)
    goto LABEL_61;
LABEL_45:
  v31 = 2 * v30;
  if (2 * v30 <= v30 + a3)
    v31 = v30 + a3;
  if (v30)
    v32 = v31;
  else
    v32 = a3;
  *(_DWORD *)(v5 + 256) = v32;
  if (v29)
  {
    v33 = *(_DWORD *)(v29 + 12);
    if (v33 < v32)
    {
      v34 = *(_DWORD *)(v29 + 4);
      v35 = v34 * v32;
      *(_DWORD *)(v29 + 12) = v32;
      if (v34 * v32)
      {
        v36 = v34 * v33;
        v37 = (void *)operator new[]();
        v38 = v37;
        if (v36)
        {
          v39 = *(const void **)(v29 + 16);
          if (v39)
          {
            if (v36 >= v35)
              v40 = v35;
            else
              v40 = v36;
            memcpy(v37, v39, v40);
          }
        }
      }
      else
      {
        v38 = 0;
      }
      this = *(_QWORD *)(v29 + 16);
      if (this)
        this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
      *(_QWORD *)(v29 + 16) = v38;
      v41 = *(_DWORD *)(v5 + 244) + a2;
      *(_DWORD *)(v5 + 244) = v41;
      v42 = *(_QWORD *)(v5 + 16);
      if (v42)
        goto LABEL_62;
      goto LABEL_79;
    }
  }
  else if (v32 > 0)
  {
    this = HGArrayDataRef::allocate(v28, 2, v32, v32);
  }
LABEL_61:
  v41 = *(_DWORD *)(v5 + 244) + a2;
  *(_DWORD *)(v5 + 244) = v41;
  v42 = *(_QWORD *)(v5 + 16);
  if (v42)
  {
LABEL_62:
    v43 = *(_DWORD *)(v42 + 12);
    v44 = *(_DWORD *)(v42 + 8) + a3;
    if (v43 < v44)
    {
      v45 = *(_DWORD *)(v42 + 4);
      v46 = v45 * v44;
      *(_DWORD *)(v42 + 12) = v44;
      if (v45 * v44)
      {
        v47 = v45 * v43;
        v48 = (void *)operator new[]();
        v49 = v48;
        if (v47)
        {
          v50 = *(const void **)(v42 + 16);
          if (v50)
          {
            if (v47 >= v46)
              v51 = v46;
            else
              v51 = v47;
            memcpy(v48, v50, v51);
          }
        }
      }
      else
      {
        v49 = 0;
      }
      this = *(_QWORD *)(v42 + 16);
      if (this)
        this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
      *(_QWORD *)(v42 + 16) = v49;
    }
    *(_DWORD *)(v42 + 8) = v44;
    goto LABEL_81;
  }
LABEL_79:
  if (a3 <= 0)
    goto LABEL_82;
  this = HGArrayDataRef::allocate(v28, 2, a3, a3);
LABEL_81:
  v41 = *(_DWORD *)(v5 + 244);
LABEL_82:
  v52 = *(_QWORD *)v6;
  if (*(_QWORD *)v6)
  {
    v53 = *(_DWORD *)(v52 + 12);
    if (v53 < v41)
    {
      v54 = *(_DWORD *)(v52 + 4);
      v55 = v54 * v41;
      *(_DWORD *)(v52 + 12) = v41;
      if (v54 * v41)
      {
        v56 = v54 * v53;
        v57 = (void *)operator new[]();
        v58 = v57;
        if (v56)
        {
          v59 = *(const void **)(v52 + 16);
          if (v59)
          {
            if (v56 >= v55)
              v60 = v55;
            else
              v60 = v56;
            memcpy(v57, v59, v60);
          }
        }
      }
      else
      {
        v58 = 0;
      }
      this = *(_QWORD *)(v52 + 16);
      if (this)
        this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
      *(_QWORD *)(v52 + 16) = v58;
    }
    *(_DWORD *)(v52 + 8) = v41;
    v61 = *(_DWORD *)(v5 + 244);
    v62 = *(_QWORD *)v5;
    if (!*(_QWORD *)v5)
    {
LABEL_107:
      if (v61 > 0)
        return HGArrayDataRef::allocate((HGArrayDataRef *)v5, 4, v61, v61);
      return this;
    }
  }
  else
  {
    if (v41 > 0)
      this = HGArrayDataRef::allocate(v6, 4, v41, v41);
    v61 = *(_DWORD *)(v5 + 244);
    v62 = *(_QWORD *)v5;
    if (!*(_QWORD *)v5)
      goto LABEL_107;
  }
  v63 = *(_DWORD *)(v62 + 12);
  if (v63 < v61)
  {
    v64 = *(_DWORD *)(v62 + 4);
    v65 = v64 * v61;
    *(_DWORD *)(v62 + 12) = v61;
    if (v64 * v61)
    {
      v66 = v64 * v63;
      v67 = (void *)operator new[]();
      v68 = v67;
      if (v66)
      {
        v69 = *(const void **)(v62 + 16);
        if (v69)
        {
          if (v66 >= v65)
            v70 = v65;
          else
            v70 = v66;
          memcpy(v67, v69, v70);
        }
      }
    }
    else
    {
      v68 = 0;
    }
    this = *(_QWORD *)(v62 + 16);
    if (this)
      this = MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
    *(_QWORD *)(v62 + 16) = v68;
  }
  *(_DWORD *)(v62 + 8) = v61;
  return this;
}

void HGeometryData::ClipW(HGeometryData *this)
{
  signed int v2;
  uint64_t v3;
  int v4;
  int i;
  _BYTE v6[280];

  v2 = *((_DWORD *)this + 61);
  HGeometryData::HGeometryData((HGeometryData *)v6, *((HGRasterizer **)this + 33), 0);
  v3 = *((_QWORD *)this + 10);
  if (v3)
    v4 = *(_DWORD *)(v3 + 8);
  else
    v4 = 0;
  HGeometryData::SizeIndexArrays((uint64_t)v6, v2, v4);
  v6[248] = 1;
  if (v2 >= 1)
  {
    for (i = 0; i != v2; ++i)
      HGeometryData::ClipPolyW((HGRasterizer **)this, i, (HGeometryData *)v6);
  }
  HGeometryData::operator=((unsigned int **)this, (uint64_t)v6);
  HGeometryData::~HGeometryData((HGeometryData *)v6);
}

void sub_1B29C94C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGeometryData::~HGeometryData((HGeometryData *)va);
  _Unwind_Resume(a1);
}

void sub_1B29C94DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGeometryData::~HGeometryData((HGeometryData *)va);
  _Unwind_Resume(a1);
}

void HGeometryData::BuildShapeEdgeList(uint64_t a1, HGArrayDataRef *this, int a3)
{
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  void *v13;
  const void *v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  double v27;
  float32x4_t *v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  size_t v37;
  int v38;
  float v39;

  v5 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16)
                 + *(int *)(*(_QWORD *)(a1 + 48) + 4) * (uint64_t)a3
                 + *(int *)(a1 + 56));
  v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 16) + *(int *)(*(_QWORD *)a1 + 4) * (uint64_t)a3 + *(int *)(a1 + 8));
  v7 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
  {
    if (v5 <= 0)
      return;
    HGArrayDataRef::allocate(this, 560, v5, v5);
    goto LABEL_17;
  }
  v8 = *(_DWORD *)(v7 + 12);
  if (v8 < v5)
  {
    v9 = *(_DWORD *)(v7 + 4);
    v10 = v9 * v5;
    *(_DWORD *)(v7 + 12) = v5;
    if (v9 * v5)
    {
      v11 = v9 * v8;
      v12 = (void *)operator new[]();
      v13 = v12;
      if (v11)
      {
        v14 = *(const void **)(v7 + 16);
        if (v14)
        {
          if (v11 >= v10)
            v15 = v10;
          else
            v15 = v11;
          memcpy(v12, v14, v15);
        }
      }
    }
    else
    {
      v13 = 0;
    }
    v16 = *(_QWORD *)(v7 + 16);
    if (v16)
      MEMORY[0x1B5E2914C](v16, 0x1000C8077774924);
    *(_QWORD *)(v7 + 16) = v13;
  }
  if (v5 >= 1)
  {
LABEL_17:
    v17 = 0;
    v18 = 0;
    v19 = -v5;
    do
    {
      v20 = v6 + v17;
      if (v19 + v17 == -1)
        v21 = v6;
      else
        v21 = v20 + 1;
      v22 = *(_QWORD *)(a1 + 80);
      v23 = *(_QWORD *)(v22 + 16);
      LODWORD(v22) = *(_DWORD *)(v22 + 4);
      v24 = *(int *)(a1 + 88);
      v25 = *(float *)(v23 + (int)v22 * v20 + v24 + 4);
      v26 = *(float *)(v23 + (int)v22 * v21 + v24 + 4);
      if (v25 != v26)
      {
        HGArray<HEdge,(HGFormat)0>::append(this);
        v28 = (float32x4_t *)(*(_QWORD *)(*(_QWORD *)this + 16)
                            + *(int *)(*(_QWORD *)this + 4) * (uint64_t)v18
                            + *((int *)this + 2));
        v28[34].i64[0] = a1;
        if (v25 >= v26)
          v29 = v21;
        else
          v29 = v6 + v17;
        if (v25 >= v26)
          v30 = v6 + v17;
        else
          v30 = v21;
        v28->i32[0] = v29;
        v28->i32[1] = v30;
        v31 = *(_QWORD *)(a1 + 80);
        if (v31)
        {
          v32 = *(_QWORD *)(v31 + 16);
          if (v32)
            v32 += *(int *)(v31 + 4) * (uint64_t)v29 + *(int *)(a1 + 88);
          v28->i64[1] = v32;
          v33 = *(_QWORD *)(v31 + 16);
          if (v33)
            v31 = v33 + *(int *)(v31 + 4) * (uint64_t)v30 + *(int *)(a1 + 88);
          else
            v31 = 0;
        }
        else
        {
          v28->i64[1] = 0;
        }
        v28[1].i64[0] = v31;
        HGeometryData::InitEdge(a1, v29, v30, *(_DWORD *)(*(_QWORD *)(a1 + 264) + 1068), (uint64_t)&v28[2], v28 + 18, &v39, &v38, v27);
        ++v18;
      }
      ++v17;
    }
    while (v19 + v17);
    if (v18 >= 2)
    {
      v34 = *(_QWORD *)this;
      if (*(_QWORD *)this)
      {
        v35 = *(_QWORD *)(v34 + 16);
        if (v35)
          v36 = (void *)(v35 + *((int *)this + 2));
        else
          v36 = 0;
        v37 = *(int *)(v34 + 4);
      }
      else
      {
        v36 = 0;
        v37 = 0;
      }
      qsort(v36, v18, v37, (int (__cdecl *)(const void *, const void *))CompareEdgeY);
    }
  }
}

uint64_t HGArray<HEdge,(HGFormat)0>::append(HGArrayDataRef *this)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v8;
  int v9;
  int v10;
  void *v11;
  void *v12;
  const void *v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  void *v20;
  void *v21;
  const void *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
  {
    HGArrayDataRef::allocate(this, 560, 2, 2);
    v4 = 0;
    v2 = *(_QWORD *)this;
    v5 = 1;
    if (*(_QWORD *)this)
      goto LABEL_20;
LABEL_36:
    HGArrayDataRef::allocate(this, 560, v5, v5);
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(v2 + 8);
  v3 = *(_DWORD *)(v2 + 12);
  v5 = v4 + 1;
  v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    v8 = *(_DWORD *)(v2 + 4);
    v9 = v8 * v6;
    *(_DWORD *)(v2 + 12) = v6;
    if (v8 * v6)
    {
      v10 = v8 * v3;
      v11 = (void *)operator new[]();
      v12 = v11;
      if (v10)
      {
        v13 = *(const void **)(v2 + 16);
        if (v13)
        {
          if (v10 >= v9)
            v14 = v9;
          else
            v14 = v10;
          memcpy(v11, v13, v14);
        }
      }
    }
    else
    {
      v12 = 0;
    }
    v15 = *(_QWORD *)(v2 + 16);
    if (v15)
      MEMORY[0x1B5E2914C](v15, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v12;
    v2 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
    {
      if (v4 < 0)
        return 0;
      goto LABEL_36;
    }
  }
LABEL_20:
  v16 = *(_DWORD *)(v2 + 12);
  if (v16 >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
  else
  {
    v17 = *(_DWORD *)(v2 + 4);
    v18 = v17 * v5;
    *(_DWORD *)(v2 + 12) = v5;
    if (v17 * v5)
    {
      v19 = v17 * v16;
      v20 = (void *)operator new[]();
      v21 = v20;
      if (v19)
      {
        v22 = *(const void **)(v2 + 16);
        if (v22)
        {
          if (v19 >= v18)
            v23 = v18;
          else
            v23 = v19;
          memcpy(v20, v22, v23);
        }
      }
    }
    else
    {
      v21 = 0;
    }
    v25 = *(_QWORD *)(v2 + 16);
    if (v25)
      MEMORY[0x1B5E2914C](v25, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v21;
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
LABEL_37:
  v26 = *(_QWORD *)(v24 + 16);
  if (v26)
    return v26 + *(int *)(v24 + 4) * (uint64_t)v4 + *((int *)this + 2);
  return 0;
}

float HGeometryData::InitEdge(uint64_t a1, int a2, int a3, char a4, uint64_t a5, float32x4_t *a6, float *a7, _DWORD *a8, double a9)
{
  float32x4_t v15;
  float v16;
  float v17;
  float v18;
  float result;

  LODWORD(a9) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 16)
                          + *(int *)(*(_QWORD *)(a1 + 80) + 4) * (uint64_t)a3
                          + *(int *)(a1 + 88)
                          + 4);
  *a8 = LODWORD(a9);
  HGeometryData::GetEdgeDeltas(a1, a2, a3, (uint64_t)a6, a9);
  *(_OWORD *)(a5 + 144) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 16)
                                    + *(int *)(*(_QWORD *)(a1 + 64) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 72));
  v15 = *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 16)
                       + *(int *)(*(_QWORD *)(a1 + 80) + 4) * (uint64_t)a2
                       + *(int *)(a1 + 88));
  *(float32x4_t *)a5 = v15;
  *(_OWORD *)(a5 + 208) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 16)
                                    + *(int *)(*(_QWORD *)(a1 + 80) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 88));
  *(_OWORD *)(a5 + 240) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 16)
                                    + *(int *)(*(_QWORD *)(a1 + 96) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 104));
  if ((a4 & 1) != 0)
  {
    *(_OWORD *)(a5 + 16) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 16)
                                     + *(int *)(*(_QWORD *)(a1 + 112) + 4) * (uint64_t)a2
                                     + *(int *)(a1 + 120));
    if ((a4 & 2) == 0)
    {
LABEL_3:
      if ((a4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_17;
    }
  }
  else if ((a4 & 2) == 0)
  {
    goto LABEL_3;
  }
  *(_OWORD *)(a5 + 32) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 16)
                                   + *(int *)(*(_QWORD *)(a1 + 128) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 136));
  if ((a4 & 4) == 0)
  {
LABEL_4:
    if ((a4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_18;
  }
LABEL_17:
  *(_OWORD *)(a5 + 48) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 16)
                                   + *(int *)(*(_QWORD *)(a1 + 144) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 152));
  if ((a4 & 8) == 0)
  {
LABEL_5:
    if ((a4 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_19;
  }
LABEL_18:
  *(_OWORD *)(a5 + 64) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 16)
                                   + *(int *)(*(_QWORD *)(a1 + 160) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 168));
  if ((a4 & 0x10) == 0)
  {
LABEL_6:
    if ((a4 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_20;
  }
LABEL_19:
  *(_OWORD *)(a5 + 80) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 176) + 16)
                                   + *(int *)(*(_QWORD *)(a1 + 176) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 184));
  if ((a4 & 0x20) == 0)
  {
LABEL_7:
    if ((a4 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_21;
  }
LABEL_20:
  *(_OWORD *)(a5 + 96) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 16)
                                   + *(int *)(*(_QWORD *)(a1 + 192) + 4) * (uint64_t)a2
                                   + *(int *)(a1 + 200));
  if ((a4 & 0x40) == 0)
  {
LABEL_8:
    v16 = v15.f32[1];
    if ((a4 & 0x80) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_21:
  *(_OWORD *)(a5 + 112) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 208) + 16)
                                    + *(int *)(*(_QWORD *)(a1 + 208) + 4) * (uint64_t)a2
                                    + *(int *)(a1 + 216));
  v16 = v15.f32[1];
  if (a4 < 0)
  {
LABEL_9:
    v15 = *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 16)
                         + *(int *)(*(_QWORD *)(a1 + 224) + 4) * (uint64_t)a2
                         + *(int *)(a1 + 232));
    *(float32x4_t *)(a5 + 128) = v15;
  }
LABEL_10:
  v15.f32[0] = v16 - floorf(v16);
  v17 = 0.5;
  if (v15.f32[0] > 0.5)
    v17 = 1.5;
  v18 = v17 - v15.f32[0];
  if ((float)(v17 - v15.f32[0]) > 0.0)
  {
    v15.f32[0] = v17 - v15.f32[0];
    HGeometryData::IncrementEdge(a1, (float32x4_t *)a5, a6, v15);
  }
  result = v16 + v18;
  *a7 = v16 + v18;
  return result;
}

uint64_t CompareEdgeY(_QWORD *a1, _QWORD *a2)
{
  float v2;
  float v3;

  v2 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1[68] + 80) + 16)
                + *(int *)(*(_QWORD *)(a1[68] + 80) + 4) * (uint64_t)*(int *)a1
                + *(int *)(a1[68] + 88)
                + 4);
  v3 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2[68] + 80) + 16)
                + *(int *)(*(_QWORD *)(a2[68] + 80) + 4) * (uint64_t)*(int *)a2
                + *(int *)(a2[68] + 88)
                + 4);
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  else
    return v2 > v3;
}

float32x4_t HGeometryData::GetEdgeDeltas(uint64_t a1, int a2, int a3, uint64_t a4, double a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t result;
  uint64_t v16;
  uint64_t v17;
  float32x4_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v5 = *(_QWORD *)(a1 + 80);
  v6 = *(_QWORD *)(v5 + 16);
  LODWORD(v5) = *(_DWORD *)(v5 + 4);
  v7 = *(int *)(a1 + 88);
  v8 = v6 + (int)v5 * (uint64_t)a2 + v7;
  v9 = v6 + (int)v5 * (uint64_t)a3 + v7;
  v10 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 1068);
  LODWORD(a5) = *(_DWORD *)(v9 + 4);
  v11 = *(float *)(v8 + 4);
  if (*(float *)&a5 == v11)
  {
    result = 0uLL;
    *(_OWORD *)(a4 + 144) = 0u;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 208) = 0u;
    *(_OWORD *)(a4 + 240) = 0u;
    if ((v10 & 1) != 0)
    {
      *(_QWORD *)(a4 + 16) = 0;
      *(_QWORD *)(a4 + 24) = 0;
      if ((v10 & 2) == 0)
      {
LABEL_13:
        if ((v10 & 4) == 0)
          goto LABEL_14;
        goto LABEL_30;
      }
    }
    else if ((v10 & 2) == 0)
    {
      goto LABEL_13;
    }
    *(_QWORD *)(a4 + 32) = 0;
    *(_QWORD *)(a4 + 40) = 0;
    if ((v10 & 4) == 0)
    {
LABEL_14:
      if ((v10 & 8) == 0)
        goto LABEL_15;
      goto LABEL_31;
    }
LABEL_30:
    *(_QWORD *)(a4 + 48) = 0;
    *(_QWORD *)(a4 + 56) = 0;
    if ((v10 & 8) == 0)
    {
LABEL_15:
      if ((v10 & 0x10) == 0)
        goto LABEL_16;
      goto LABEL_32;
    }
LABEL_31:
    *(_QWORD *)(a4 + 64) = 0;
    *(_QWORD *)(a4 + 72) = 0;
    if ((v10 & 0x10) == 0)
    {
LABEL_16:
      if ((v10 & 0x20) == 0)
        goto LABEL_17;
      goto LABEL_33;
    }
LABEL_32:
    *(_QWORD *)(a4 + 80) = 0;
    *(_QWORD *)(a4 + 88) = 0;
    if ((v10 & 0x20) == 0)
    {
LABEL_17:
      if ((v10 & 0x40) == 0)
        goto LABEL_18;
      goto LABEL_34;
    }
LABEL_33:
    *(_QWORD *)(a4 + 96) = 0;
    *(_QWORD *)(a4 + 104) = 0;
    if ((v10 & 0x40) == 0)
    {
LABEL_18:
      if ((v10 & 0x80) == 0)
        return result;
      goto LABEL_19;
    }
LABEL_34:
    *(_QWORD *)(a4 + 112) = 0;
    *(_QWORD *)(a4 + 120) = 0;
    if ((v10 & 0x80) == 0)
      return result;
LABEL_19:
    *(_OWORD *)(a4 + 128) = 0uLL;
    return result;
  }
  *(float *)&a5 = *(float *)&a5 - v11;
  v12 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
  v13 = vrecpeq_f32(v12);
  v14 = vmulq_f32(v13, vrecpsq_f32(v12, v13));
  result = vmulq_f32(vrecpsq_f32(v12, v14), v14);
  v16 = *(_QWORD *)(a1 + 64);
  *(float32x4_t *)(a4 + 144) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v16 + 16)+ *(int *)(v16 + 4) * (uint64_t)a3+ *(int *)(a1 + 72)), *(float32x4_t *)(*(_QWORD *)(v16 + 16)+ *(int *)(v16 + 4) * (uint64_t)a2+ *(int *)(a1 + 72))));
  v17 = *(_QWORD *)(a1 + 80);
  v18 = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v17 + 16) + *(int *)(v17 + 4) * (uint64_t)a3 + *(int *)(a1 + 88)), *(float32x4_t *)(*(_QWORD *)(v17 + 16) + *(int *)(v17 + 4) * (uint64_t)a2 + *(int *)(a1 + 88))));
  *(float32x4_t *)a4 = v18;
  v19 = *(_QWORD *)(a1 + 96);
  *(float32x4_t *)(a4 + 240) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v19 + 16)+ *(int *)(v19 + 4) * (uint64_t)a3+ *(int *)(a1 + 104)), *(float32x4_t *)(*(_QWORD *)(v19 + 16)+ *(int *)(v19 + 4) * (uint64_t)a2+ *(int *)(a1 + 104))));
  *(float32x4_t *)(a4 + 208) = v18;
  if ((v10 & 1) != 0)
  {
    v20 = *(_QWORD *)(a1 + 112);
    *(float32x4_t *)(a4 + 16) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v20 + 16)+ *(int *)(v20 + 4) * (uint64_t)a3+ *(int *)(a1 + 120)), *(float32x4_t *)(*(_QWORD *)(v20 + 16)+ *(int *)(v20 + 4) * (uint64_t)a2+ *(int *)(a1 + 120))));
    if ((v10 & 2) == 0)
    {
LABEL_4:
      if ((v10 & 4) == 0)
        goto LABEL_5;
      goto LABEL_22;
    }
  }
  else if ((v10 & 2) == 0)
  {
    goto LABEL_4;
  }
  v21 = *(_QWORD *)(a1 + 128);
  *(float32x4_t *)(a4 + 32) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v21 + 16)+ *(int *)(v21 + 4) * (uint64_t)a3+ *(int *)(a1 + 136)), *(float32x4_t *)(*(_QWORD *)(v21 + 16)+ *(int *)(v21 + 4) * (uint64_t)a2+ *(int *)(a1 + 136))));
  if ((v10 & 4) == 0)
  {
LABEL_5:
    if ((v10 & 8) == 0)
      goto LABEL_6;
    goto LABEL_23;
  }
LABEL_22:
  v22 = *(_QWORD *)(a1 + 144);
  *(float32x4_t *)(a4 + 48) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v22 + 16)+ *(int *)(v22 + 4) * (uint64_t)a3+ *(int *)(a1 + 152)), *(float32x4_t *)(*(_QWORD *)(v22 + 16)+ *(int *)(v22 + 4) * (uint64_t)a2+ *(int *)(a1 + 152))));
  if ((v10 & 8) == 0)
  {
LABEL_6:
    if ((v10 & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_24;
  }
LABEL_23:
  v23 = *(_QWORD *)(a1 + 160);
  *(float32x4_t *)(a4 + 64) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v23 + 16)+ *(int *)(v23 + 4) * (uint64_t)a3+ *(int *)(a1 + 168)), *(float32x4_t *)(*(_QWORD *)(v23 + 16)+ *(int *)(v23 + 4) * (uint64_t)a2+ *(int *)(a1 + 168))));
  if ((v10 & 0x10) == 0)
  {
LABEL_7:
    if ((v10 & 0x20) == 0)
      goto LABEL_8;
LABEL_25:
    v25 = *(_QWORD *)(a1 + 192);
    *(float32x4_t *)(a4 + 96) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v25 + 16)+ *(int *)(v25 + 4) * (uint64_t)a3+ *(int *)(a1 + 200)), *(float32x4_t *)(*(_QWORD *)(v25 + 16)+ *(int *)(v25 + 4) * (uint64_t)a2+ *(int *)(a1 + 200))));
    if ((v10 & 0x40) == 0)
    {
LABEL_9:
      if ((v10 & 0x80) == 0)
        return result;
LABEL_27:
      v27 = *(_QWORD *)(a1 + 224);
      result = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v27 + 16) + *(int *)(v27 + 4) * (uint64_t)a3 + *(int *)(a1 + 232)), *(float32x4_t *)(*(_QWORD *)(v27 + 16) + *(int *)(v27 + 4) * (uint64_t)a2 + *(int *)(a1 + 232))));
      *(float32x4_t *)(a4 + 128) = result;
      return result;
    }
    goto LABEL_26;
  }
LABEL_24:
  v24 = *(_QWORD *)(a1 + 176);
  *(float32x4_t *)(a4 + 80) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v24 + 16)+ *(int *)(v24 + 4) * (uint64_t)a3+ *(int *)(a1 + 184)), *(float32x4_t *)(*(_QWORD *)(v24 + 16)+ *(int *)(v24 + 4) * (uint64_t)a2+ *(int *)(a1 + 184))));
  if ((v10 & 0x20) != 0)
    goto LABEL_25;
LABEL_8:
  if ((v10 & 0x40) == 0)
    goto LABEL_9;
LABEL_26:
  v26 = *(_QWORD *)(a1 + 208);
  *(float32x4_t *)(a4 + 112) = vmulq_f32(result, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(v26 + 16)+ *(int *)(v26 + 4) * (uint64_t)a3+ *(int *)(a1 + 216)), *(float32x4_t *)(*(_QWORD *)(v26 + 16)+ *(int *)(v26 + 4) * (uint64_t)a2+ *(int *)(a1 + 216))));
  if ((v10 & 0x80) != 0)
    goto LABEL_27;
  return result;
}

float32x4_t HGeometryData::IncrementEdge(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t result)
{
  int v4;

  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 1068);
  if (result.f32[0] != 1.0)
  {
    *a2 = vaddq_f32(*a2, vmulq_n_f32(*a3, result.f32[0]));
    a2[9] = vaddq_f32(a2[9], vmulq_n_f32(a3[9], result.f32[0]));
    a2[15] = vaddq_f32(a2[15], vmulq_n_f32(a3[15], result.f32[0]));
    a2[13] = vaddq_f32(a2[13], vmulq_n_f32(a3[13], result.f32[0]));
    if ((v4 & 1) != 0)
    {
      a2[1] = vaddq_f32(a2[1], vmulq_n_f32(a3[1], result.f32[0]));
      if ((v4 & 2) == 0)
      {
LABEL_13:
        if ((v4 & 4) == 0)
          goto LABEL_14;
        goto LABEL_30;
      }
    }
    else if ((v4 & 2) == 0)
    {
      goto LABEL_13;
    }
    a2[2] = vaddq_f32(a2[2], vmulq_n_f32(a3[2], result.f32[0]));
    if ((v4 & 4) == 0)
    {
LABEL_14:
      if ((v4 & 8) == 0)
        goto LABEL_15;
      goto LABEL_31;
    }
LABEL_30:
    a2[3] = vaddq_f32(a2[3], vmulq_n_f32(a3[3], result.f32[0]));
    if ((v4 & 8) == 0)
    {
LABEL_15:
      if ((v4 & 0x10) == 0)
        goto LABEL_16;
      goto LABEL_32;
    }
LABEL_31:
    a2[4] = vaddq_f32(a2[4], vmulq_n_f32(a3[4], result.f32[0]));
    if ((v4 & 0x10) == 0)
    {
LABEL_16:
      if ((v4 & 0x20) == 0)
        goto LABEL_17;
      goto LABEL_33;
    }
LABEL_32:
    a2[5] = vaddq_f32(a2[5], vmulq_n_f32(a3[5], result.f32[0]));
    if ((v4 & 0x20) == 0)
    {
LABEL_17:
      if ((v4 & 0x40) == 0)
        goto LABEL_18;
      goto LABEL_34;
    }
LABEL_33:
    a2[6] = vaddq_f32(a2[6], vmulq_n_f32(a3[6], result.f32[0]));
    if ((v4 & 0x40) == 0)
    {
LABEL_18:
      if ((v4 & 0x80) == 0)
        return result;
      goto LABEL_35;
    }
LABEL_34:
    a2[7] = vaddq_f32(a2[7], vmulq_n_f32(a3[7], result.f32[0]));
    if ((v4 & 0x80) == 0)
      return result;
LABEL_35:
    result = vaddq_f32(a2[8], vmulq_n_f32(a3[8], result.f32[0]));
    a2[8] = result;
    return result;
  }
  *a2 = vaddq_f32(*a3, *a2);
  a2[9] = vaddq_f32(a3[9], a2[9]);
  a2[15] = vaddq_f32(a3[15], a2[15]);
  result = vaddq_f32(a3[13], a2[13]);
  a2[13] = result;
  if ((v4 & 1) != 0)
  {
    result = vaddq_f32(a3[1], a2[1]);
    a2[1] = result;
    if ((v4 & 2) == 0)
    {
LABEL_4:
      if ((v4 & 4) == 0)
        goto LABEL_5;
      goto LABEL_22;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_4;
  }
  result = vaddq_f32(a3[2], a2[2]);
  a2[2] = result;
  if ((v4 & 4) == 0)
  {
LABEL_5:
    if ((v4 & 8) == 0)
      goto LABEL_6;
    goto LABEL_23;
  }
LABEL_22:
  result = vaddq_f32(a3[3], a2[3]);
  a2[3] = result;
  if ((v4 & 8) == 0)
  {
LABEL_6:
    if ((v4 & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_24;
  }
LABEL_23:
  result = vaddq_f32(a3[4], a2[4]);
  a2[4] = result;
  if ((v4 & 0x10) == 0)
  {
LABEL_7:
    if ((v4 & 0x20) == 0)
      goto LABEL_8;
LABEL_25:
    result = vaddq_f32(a3[6], a2[6]);
    a2[6] = result;
    if ((v4 & 0x40) == 0)
    {
LABEL_9:
      if ((v4 & 0x80) == 0)
        return result;
LABEL_27:
      result = vaddq_f32(a3[8], a2[8]);
      a2[8] = result;
      return result;
    }
    goto LABEL_26;
  }
LABEL_24:
  result = vaddq_f32(a3[5], a2[5]);
  a2[5] = result;
  if ((v4 & 0x20) != 0)
    goto LABEL_25;
LABEL_8:
  if ((v4 & 0x40) == 0)
    goto LABEL_9;
LABEL_26:
  result = vaddq_f32(a3[7], a2[7]);
  a2[7] = result;
  if ((v4 & 0x80) != 0)
    goto LABEL_27;
  return result;
}

void HGeometryData::RenderPolygon(uint64_t a1, int a2, int32x2_t *a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  float v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  void *v22;
  void *v23;
  const void *v24;
  int v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  void *v46;
  int32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int v50;
  uint64_t v51;
  int v52;
  float32x4_t *v53;
  float32x4_t *v54;
  _DWORD *v55;
  unsigned int v56;
  float v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  float v70;
  float v71;
  float32x4_t v72;
  float32x4_t v73;
  float v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int v82;
  float32x4_t v83;
  int v84;
  float32x4_t v85;
  float32x4_t v86;
  int v87;
  float32x4_t v88;
  int v89;
  __int32 v90;
  int32x2_t v91;
  int32x2_t v92;
  __int32 v93;
  int32x4_t v94;
  _BOOL4 v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int32x4_t v103;
  __int32 v104;
  uint64_t v105;
  __int32 v106;
  int8x16_t v107;
  int32x4_t v108;
  int32x4_t v109;
  int32x4_t v110;
  int32x4_t v111;
  int32x4_t v112;
  int32x4_t v113;
  int32x4_t v114;
  uint64_t v115;
  float32x4_t *v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  __int128 v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  int v137;
  float32x4_t v138;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  int v147;
  float32x4_t v148;
  int v149;
  int v150;
  int v151;
  float32x4_t v152;
  float32x4_t v153;
  int8x16_t v154;
  float32x4_t v155;
  int8x16_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  int8x16_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  uint64_t v165;
  unsigned int v166;
  unsigned int v167;
  uint64_t v168;
  unsigned int v169;
  unsigned int v170;
  uint64_t v171;
  char v172;
  int v173;
  int8x16_t v174;
  float32x4_t v175;
  int v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  int8x16_t v184;
  int8x16_t v185;
  int8x16_t v186;
  int8x16_t v187;
  int8x16_t v188;
  int8x16_t v189;
  int8x16_t v190;
  int32x2_t v191;
  _BOOL4 v192;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  int v204;
  int v205;
  int v206;
  int v207;
  int v208;
  uint64_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  float32x4_t v221;
  float32x4_t v222;
  float32x4_t v223;
  uint64_t v224;
  uint64_t v225;
  _QWORD v226[2];
  uint64_t v227;
  uint64_t v228;
  float32x4_t v229;

  v227 = 0;
  v228 = 0;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v227, 560, 0, 0);
  v8 = (unsigned int *)v227;
  v226[0] = v227;
  if (v227)
  {
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
  }
  v226[1] = v228;
  HGeometryData::BuildShapeEdgeList(a1, (HGArrayDataRef *)v226, a2);
  v10 = v226[0];
  if (v226[0])
  {
    do
    {
      v11 = __ldaxr((unsigned int *)v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, (unsigned int *)v10));
    if (!v12)
    {
      v13 = *(_QWORD *)(v10 + 16);
      if (v13)
        MEMORY[0x1B5E2914C](v13, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v10, 0x1080C4098BBCF0FLL);
    }
  }
  v14 = v227;
  if (v227)
  {
    v15 = *(_DWORD *)(v227 + 8);
    if (!v15)
      goto LABEL_202;
    v16 = *(float *)(*(_QWORD *)(v227 + 16) + (int)v228 + 36);
    v17 = a3[1].i32[1];
    v18 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 1068);
    v224 = 0;
    v225 = 0;
    HGArrayDataRef::allocate((HGArrayDataRef *)&v224, 8, 0, 0);
    v19 = v224;
    if (v224)
    {
      v20 = *(_DWORD *)(v224 + 12);
      if (v20 < v15)
      {
        v21 = *(_DWORD *)(v224 + 4);
        *(_DWORD *)(v224 + 12) = v15;
        if (v21)
        {
          v22 = (void *)operator new[]();
          v23 = v22;
          if (v20)
          {
            v24 = *(const void **)(v19 + 16);
            if (v24)
            {
              v25 = v21 * v20;
              if (v21 * v20 >= v21 * v15)
                v25 = v21 * v15;
              memcpy(v22, v24, v25);
            }
          }
        }
        else
        {
          v23 = 0;
        }
        v27 = *(_QWORD *)(v19 + 16);
        if (v27)
          MEMORY[0x1B5E2914C](v27, 0x1000C8077774924);
        *(_QWORD *)(v19 + 16) = v23;
      }
      *(_DWORD *)(v19 + 8) = v15;
      v26 = (float)v17;
      if (v16 < v26)
        goto LABEL_28;
    }
    else
    {
      if (v15 > 0)
        HGArrayDataRef::allocate((HGArrayDataRef *)&v224, 8, v15, v15);
      v26 = (float)v17;
      if (v16 < v26)
      {
LABEL_28:
        v210 = a1;
        v172 = v18;
        while (1)
        {
          v28 = v224;
          if (v224)
          {
            do
              v29 = __ldaxr((unsigned int *)v28);
            while (__stlxr(v29 + 1, (unsigned int *)v28));
          }
          v30 = v227;
          if (v227)
          {
            v31 = (int)v225;
            do
              v32 = __ldaxr((unsigned int *)v30);
            while (__stlxr(v32 + 1, (unsigned int *)v30));
            v33 = *(unsigned int *)(v30 + 8);
            if ((int)v33 < 1)
            {
              v34 = 0;
            }
            else
            {
              v34 = 0;
              v35 = (int)v228;
              v36 = *(int *)(v30 + 4);
              do
              {
                v37 = *(_QWORD *)(v30 + 16) + v35;
                if (*(float *)(*(_QWORD *)(v37 + 8) + 4) <= v16 && *(float *)(*(_QWORD *)(v37 + 16) + 4) > v16)
                  *(_QWORD *)(*(_QWORD *)(v28 + 16) + *(int *)(v28 + 4) * (uint64_t)v34++ + v31) = v37;
                v35 += v36;
                --v33;
              }
              while (v33);
            }
            do
            {
              v38 = __ldaxr((unsigned int *)v30);
              v39 = v38 - 1;
            }
            while (__stlxr(v39, (unsigned int *)v30));
            if (!v39)
            {
              v40 = *(_QWORD *)(v30 + 16);
              if (v40)
                MEMORY[0x1B5E2914C](v40, 0x1000C8077774924);
              MEMORY[0x1B5E29170](v30, 0x1080C4098BBCF0FLL);
            }
          }
          else
          {
            v34 = 0;
          }
          if (v28)
          {
            do
            {
              v41 = __ldaxr((unsigned int *)v28);
              v42 = v41 - 1;
            }
            while (__stlxr(v42, (unsigned int *)v28));
            if (!v42)
            {
              v43 = *(_QWORD *)(v28 + 16);
              if (v43)
                MEMORY[0x1B5E2914C](v43, 0x1000C8077774924);
              MEMORY[0x1B5E29170](v28, 0x1080C4098BBCF0FLL);
            }
          }
          if (!v34)
            goto LABEL_188;
          v44 = v224;
          if (v224)
          {
            v45 = *(_QWORD *)(v224 + 16);
            v46 = v45 ? (void *)(v45 + (int)v225) : 0;
            v44 = *(_DWORD *)(v224 + 4);
          }
          else
          {
            v46 = 0;
          }
          qsort(v46, v34, v44, (int (__cdecl *)(const void *, const void *))CompareEdgeX);
          if (v34 >= 1)
            break;
LABEL_29:
          v16 = v16 + 1.0;
          if (v16 >= v26)
            goto LABEL_188;
        }
        v50 = 0;
        v173 = v34;
        while (1)
        {
          v51 = *(_QWORD *)(v224 + 16);
          v52 = *(_DWORD *)(v224 + 4);
          v53 = *(float32x4_t **)(v51 + v52 * (uint64_t)v50 + (int)v225);
          v54 = *(float32x4_t **)(v51 + v52 * (uint64_t)(v50 | 1) + (int)v225);
          v55 = *(_DWORD **)(a1 + 264);
          v56 = v55[267];
          v48.i32[0] = v54[2].i32[0];
          v57 = v53[2].f32[0];
          if (v48.f32[0] == v57)
          {
            v48.i32[0] = 0;
            v49.i32[0] = v55[267] & 1;
            v62 = vandq_s8(v190, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v49, (int32x4_t)v48), 0));
            v203 = 0u;
            v63 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)(v56 & 2), (int32x4_t)v48), 0);
            v189 = vandq_s8(v189, v63);
            v190 = v62;
            v63.i32[0] = v55[267] & 4;
            v64 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v63, (int32x4_t)v48), 0);
            v65 = vandq_s8(v188, v64);
            v64.i32[0] = v55[267] & 8;
            v66 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v64, (int32x4_t)v48), 0);
            v187 = vandq_s8(v187, v66);
            v188 = v65;
            v66.i32[0] = v55[267] & 0x10;
            v67 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v66, (int32x4_t)v48), 0);
            v68 = vandq_s8(v186, v67);
            v67.i32[0] = v55[267] & 0x20;
            v69 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v67, (int32x4_t)v48), 0);
            v185 = vandq_s8(v185, v69);
            v186 = v68;
            v69.i32[0] = v55[267] & 0x40;
            v184 = vandq_s8(v184, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v69, (int32x4_t)v48), 0));
            v202 = (float32x4_t)xmmword_1B304F230;
            v61.i32[1] = 0;
            v61.i64[1] = 0;
            if ((v56 & 0x80) == 0)
              goto LABEL_77;
            goto LABEL_76;
          }
          v48.f32[0] = v48.f32[0] - v57;
          v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 0);
          v59 = vrecpeq_f32(v58);
          v60 = vmulq_f32(v59, vrecpsq_f32(v58, v59));
          v61 = vmulq_f32(vrecpsq_f32(v58, v60), v60);
          if ((v56 & 1) != 0)
          {
            v190 = (int8x16_t)vmulq_f32(v61, vsubq_f32(v54[3], v53[3]));
            if ((v56 & 2) == 0)
            {
LABEL_67:
              if ((v56 & 4) == 0)
                goto LABEL_68;
              goto LABEL_181;
            }
          }
          else if ((v56 & 2) == 0)
          {
            goto LABEL_67;
          }
          v189 = (int8x16_t)vmulq_f32(v61, vsubq_f32(v54[4], v53[4]));
          if ((v56 & 4) == 0)
          {
LABEL_68:
            if ((v56 & 8) == 0)
              goto LABEL_69;
            goto LABEL_182;
          }
LABEL_181:
          v188 = (int8x16_t)vmulq_f32(v61, vsubq_f32(v54[5], v53[5]));
          if ((v56 & 8) == 0)
          {
LABEL_69:
            if ((v56 & 0x10) == 0)
              goto LABEL_70;
            goto LABEL_183;
          }
LABEL_182:
          v187 = (int8x16_t)vmulq_f32(v61, vsubq_f32(v54[6], v53[6]));
          if ((v56 & 0x10) == 0)
          {
LABEL_70:
            if ((v56 & 0x20) != 0)
              goto LABEL_184;
            goto LABEL_71;
          }
LABEL_183:
          v186 = (int8x16_t)vmulq_f32(v61, vsubq_f32(v54[7], v53[7]));
          if ((v56 & 0x20) != 0)
          {
LABEL_184:
            v185 = (int8x16_t)vmulq_f32(v61, vsubq_f32(v54[8], v53[8]));
            if ((v56 & 0x40) == 0)
              goto LABEL_73;
LABEL_72:
            v184 = (int8x16_t)vmulq_f32(v61, vsubq_f32(v54[9], v53[9]));
            goto LABEL_73;
          }
LABEL_71:
          if ((v56 & 0x40) != 0)
            goto LABEL_72;
LABEL_73:
          v202 = vmulq_f32(v61, vsubq_f32(v54[2], v53[2]));
          v203 = vmulq_f32(v61, vsubq_f32(v54[11], v53[11]));
          if ((v56 & 0x80) == 0)
            goto LABEL_77;
          v61 = vmulq_f32(v61, vsubq_f32(v54[10], v53[10]));
LABEL_76:
          v174 = (int8x16_t)v61;
LABEL_77:
          v70 = v57 - floorf(v57);
          if (v70 <= 0.5)
            v71 = 0.5;
          else
            v71 = 1.5;
          v72 = v53[2];
          v73 = v53[11];
          if ((v18 & 1) != 0)
          {
            v177 = v53[3];
            if ((v18 & 2) == 0)
            {
LABEL_82:
              if ((v18 & 4) == 0)
                goto LABEL_83;
              goto LABEL_93;
            }
          }
          else if ((v18 & 2) == 0)
          {
            goto LABEL_82;
          }
          v178 = v53[4];
          if ((v18 & 4) == 0)
          {
LABEL_83:
            if ((v18 & 8) == 0)
              goto LABEL_84;
            goto LABEL_94;
          }
LABEL_93:
          v179 = v53[5];
          if ((v18 & 8) == 0)
          {
LABEL_84:
            if ((v18 & 0x10) == 0)
              goto LABEL_85;
            goto LABEL_95;
          }
LABEL_94:
          v180 = v53[6];
          if ((v18 & 0x10) == 0)
          {
LABEL_85:
            if ((v18 & 0x20) == 0)
              goto LABEL_86;
            goto LABEL_96;
          }
LABEL_95:
          v181 = v53[7];
          if ((v18 & 0x20) == 0)
          {
LABEL_86:
            if ((v18 & 0x40) == 0)
              goto LABEL_87;
            goto LABEL_97;
          }
LABEL_96:
          v182 = v53[8];
          if ((v18 & 0x40) == 0)
          {
LABEL_87:
            if ((v18 & 0x80) == 0)
              goto LABEL_88;
            goto LABEL_98;
          }
LABEL_97:
          v183 = v53[9];
          if ((v18 & 0x80) == 0)
          {
LABEL_88:
            v74 = v71 - v70;
            v176 = v50;
            if (v74 <= 0.0)
              goto LABEL_99;
            goto LABEL_89;
          }
LABEL_98:
          v175 = v53[10];
          v74 = v71 - v70;
          v176 = v50;
          if (v74 <= 0.0)
          {
LABEL_99:
            v220 = v53[11];
            v222 = v53[2];
            v207 = v55[267] & 1;
            v206 = v55[267] & 2;
            v205 = v55[267] & 4;
            v204 = v55[267] & 8;
            v82 = v55[267] & 0x10;
            v84 = v55[267] & 0x20;
            v87 = v55[267] & 0x40;
            v89 = v55[267] & 0x80;
LABEL_100:
            v208 = v89;
            goto LABEL_101;
          }
LABEL_89:
          if (v74 == 1.0)
          {
            v47.i32[0] = 0;
            v207 = v55[267] & 1;
            v61.i32[0] = v207;
            v222 = vaddq_f32(v202, v72);
            v75.i64[0] = 0x8000000080000000;
            v75.i64[1] = 0x8000000080000000;
            v76 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v61, v47), 0), v75, v190);
            v77 = vaddq_f32(v177, v76);
            v206 = v55[267] & 2;
            v76.i32[0] = v206;
            v78 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v76, v47), 0), v75, v189);
            v177 = v77;
            v178 = vaddq_f32(v178, v78);
            v205 = v55[267] & 4;
            v78.i32[0] = v205;
            v79 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v78, v47), 0), v75, v188);
            v80 = vaddq_f32(v179, v79);
            v204 = v55[267] & 8;
            v79.i32[0] = v204;
            v81 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v79, v47), 0), v75, v187);
            v179 = v80;
            v180 = vaddq_f32(v180, v81);
            v82 = v55[267] & 0x10;
            v81.i32[0] = v82;
            v83 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v81, v47), 0), v75, v186);
            v181 = vaddq_f32(v181, v83);
            v84 = v55[267] & 0x20;
            v83.i32[0] = v84;
            v220 = vaddq_f32(v203, v73);
            v85 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v83, v47), 0), v75, v185);
            v86 = vaddq_f32(v182, v85);
            v87 = v55[267] & 0x40;
            v85.i32[0] = v87;
            v88 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v85, v47), 0), v75, v184);
            v182 = v86;
            v183 = vaddq_f32(v183, v88);
            v88.i32[0] = v55[267] & 0x80;
            v208 = (v56 >> 7) & 1;
            v175 = vaddq_f32(v175, (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v88, v47), 0), v75, v174));
            goto LABEL_101;
          }
          v61.i32[0] = 0;
          v208 = 0;
          v152 = vmulq_n_f32(v203, v74);
          v153 = vaddq_f32(v152, v73);
          v207 = v55[267] & 1;
          v152.i32[0] = v207;
          v154.i64[0] = 0x8000000080000000;
          v154.i64[1] = 0x8000000080000000;
          v155 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v152, (int32x4_t)v61), 0), v154, (int8x16_t)vmulq_n_f32((float32x4_t)v190, v74));
          v177 = vaddq_f32(v177, v155);
          v206 = v55[267] & 2;
          v155.i32[0] = v206;
          v156 = (int8x16_t)vmulq_n_f32((float32x4_t)v189, v74);
          v157 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v155, (int32x4_t)v61), 0), v154, v156);
          v205 = v55[267] & 4;
          v156.i32[0] = v205;
          v158 = vaddq_f32(v178, v157);
          v159 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v156, (int32x4_t)v61), 0), v154, (int8x16_t)vmulq_n_f32((float32x4_t)v188, v74));
          v178 = v158;
          v179 = vaddq_f32(v179, v159);
          v204 = v55[267] & 8;
          v159.i32[0] = v204;
          v160 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v159, (int32x4_t)v61), 0), v154, (int8x16_t)vmulq_n_f32((float32x4_t)v187, v74));
          v180 = vaddq_f32(v180, v160);
          v82 = v55[267] & 0x10;
          v160.i32[0] = v82;
          v161 = (int8x16_t)vmulq_n_f32((float32x4_t)v186, v74);
          v162 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v160, (int32x4_t)v61), 0), v154, v161);
          v84 = v55[267] & 0x20;
          v161.i32[0] = v84;
          v163 = vaddq_f32(v181, v162);
          v164 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v161, (int32x4_t)v61), 0), v154, (int8x16_t)vmulq_n_f32((float32x4_t)v185, v74));
          v181 = v163;
          v182 = vaddq_f32(v182, v164);
          v87 = v55[267] & 0x40;
          v164.i32[0] = v87;
          v183 = vaddq_f32(v183, (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v164, (int32x4_t)v61), 0), v154, (int8x16_t)vmulq_n_f32((float32x4_t)v184, v74)));
          v220 = v153;
          v222 = vaddq_f32(v72, vmulq_n_f32(v202, v74));
          if ((v56 & 0x80) != 0)
          {
            v175 = vaddq_f32(vmulq_n_f32((float32x4_t)v174, v74), v175);
            v89 = 1;
            goto LABEL_100;
          }
LABEL_101:
          v90 = a3[3].i32[0];
          v91 = *a3;
          v191 = a3[2];
          a3[2] = (int32x2_t)&v229;
          v92 = a3[4];
          v93 = a3[5].i32[0];
          v229 = 0uLL;
          v96 = ((*(uint64_t (**)(_DWORD *))(*(_QWORD *)v55 + 592))(v55) & 0xA) != 0
             && *(_QWORD *)&v92 != 0;
          v192 = v96;
          v98 = v220;
          v97 = v222;
          if (v222.f32[0] < v54[2].f32[0])
          {
            v94.i32[0] = 0;
            *(float32x2_t *)v99.f32 = vadd_f32(vcvt_f32_s32(v91), (float32x2_t)0x3F0000003F000000);
            v99.i64[1] = 0x3F80000000000000;
            v100.i64[0] = 0x3F0000003F000000;
            v100.i64[1] = 0x3F0000003F000000;
            v101 = vaddq_f32(vsubq_f32(v222, v99), v100);
            v102 = vcvtq_f32_s32(vcvtq_s32_f32(v101));
            v103 = vcvtq_s32_f32(vaddq_f32(v102, vcvtq_f32_s32(vcgtq_f32(v102, v101))));
            v104 = v103.i32[1];
            v105 = v103.i32[0];
            v106 = v103.i32[0] + v103.i32[1] * v93;
            v103.i32[0] = v208;
            v107.i64[0] = 0x8000000080000000;
            v107.i64[1] = 0x8000000080000000;
            v108 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v103, v94), 0), v107, v174);
            v201 = (float32x4_t)v108;
            v108.i32[0] = v87;
            v109 = (int32x4_t)v184;
            v110 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v108, v94), 0), v107, v184);
            v200 = (float32x4_t)v110;
            v110.i32[0] = v84;
            v109.i32[0] = v82;
            v199 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v110, v94), 0), v107, v185);
            v111 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v109, v94), 0), v107, v186);
            v198 = (float32x4_t)v111;
            v111.i32[0] = v204;
            v112 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v111, v94), 0), v107, v187);
            v197 = (float32x4_t)v112;
            v112.i32[0] = v205;
            v113 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v112, v94), 0), v107, v188);
            v196 = (float32x4_t)v113;
            v113.i32[0] = v206;
            v114 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v113, v94), 0), v107, v189);
            v195 = (float32x4_t)v114;
            v114.i32[0] = v207;
            v94.i64[0] = vceqq_s32(v114, v94).u64[0];
            if (v192)
              v115 = v106;
            else
              v115 = 0;
            v116 = (float32x4_t *)(*(_QWORD *)&v191 + 16 * (v105 + v90 * (uint64_t)v104));
            v117 = v175;
            v119 = v182;
            v118 = v183;
            v121 = v180;
            v120 = v181;
            v194 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v94.i8, 0), v107, v190);
            v123 = v178;
            v122 = v179;
            v124 = v177;
            v125 = v222;
            do
            {
              *(float32x4_t *)a4 = v125;
              *(float32x4_t *)(a4 + 144) = v98;
              if (v207)
                *(float32x4_t *)(a4 + 16) = v124;
              if (v206)
                *(float32x4_t *)(a4 + 32) = v123;
              if (v205)
                *(float32x4_t *)(a4 + 48) = v122;
              if (v204)
                *(float32x4_t *)(a4 + 64) = v121;
              if (v82)
                *(float32x4_t *)(a4 + 80) = v120;
              if (v84)
                *(float32x4_t *)(a4 + 96) = v119;
              if (v87)
                *(float32x4_t *)(a4 + 112) = v118;
              v211 = v125;
              v212 = v124;
              v213 = v123;
              v214 = v122;
              v215 = v121;
              v216 = v120;
              v217 = v119;
              v218 = v118;
              v221 = v98;
              v223 = v97;
              if (v208)
                *(float32x4_t *)(a4 + 128) = v117;
              v219 = v117;
              (*(void (**)(_QWORD, uint64_t, int32x2_t *, uint64_t))(**(_QWORD **)(v210 + 264) + 576))(*(_QWORD *)(v210 + 264), a4, a3, a5);
              if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v210 + 264) + 592))(*(_QWORD *)(v210 + 264)) & 4) != 0)
              {
                v137 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v210 + 264) + 600))(*(_QWORD *)(v210 + 264));
                v129 = v218;
                v127 = v221;
                v97 = v223;
                v128 = v219;
                v131 = v216;
                v130 = v217;
                v132 = v214;
                v133 = v215;
                v135 = v212;
                v134 = v213;
                v136 = v211;
                switch(v137)
                {
                  case 0:
                    v138 = v229;
                    __asm { FMOV            V1.4S, #1.0 }
                    v143 = vsubq_f32(_Q1, v229);
                    v144 = *v116;
                    goto LABEL_141;
                  case 1:
                    v138 = *v116;
                    __asm { FMOV            V1.4S, #1.0 }
                    v143 = vsubq_f32(_Q1, *v116);
                    v144 = v229;
LABEL_141:
                    v145 = vmulq_laneq_f32(v144, v143, 3);
                    goto LABEL_142;
                  case 2:
                    v138 = *v116;
                    v145 = v229;
LABEL_142:
                    *v116 = vaddq_f32(v138, v145);
                    break;
                  case 3:
                    *v116 = vmaxq_f32(*v116, v229);
                    break;
                  case 4:
                    *v116 = vminq_f32(*v116, v229);
                    break;
                  default:
                    v127 = v221;
                    v97 = v223;
                    v128 = v219;
                    goto LABEL_144;
                }
              }
              else if (v192)
              {
                v126 = *(_OWORD *)(a4 + 208);
                v127 = v221;
                v97 = v223;
                v129 = v218;
                v128 = v219;
                v131 = v216;
                v130 = v217;
                v132 = v214;
                v133 = v215;
                v135 = v212;
                v134 = v213;
                v136 = v211;
                if (COERCE_FLOAT(*(_QWORD *)(a4 + 216)) < *(float *)(*(_QWORD *)&v92 + 16 * v115 + 8))
                {
                  *v116 = v229;
                  *(_OWORD *)(*(_QWORD *)&v92 + 16 * v115) = v126;
                }
                ++v115;
              }
              else
              {
                *v116 = v229;
                v127 = v221;
                v97 = v223;
                v129 = v218;
                v128 = v219;
LABEL_144:
                v131 = v216;
                v130 = v217;
                v132 = v214;
                v133 = v215;
                v135 = v212;
                v134 = v213;
                v136 = v211;
              }
              v124 = vaddq_f32(v194, v135);
              v123 = vaddq_f32(v195, v134);
              v122 = vaddq_f32(v196, v132);
              v121 = vaddq_f32(v197, v133);
              v120 = vaddq_f32(v198, v131);
              v119 = vaddq_f32(v199, v130);
              v118 = vaddq_f32(v200, v129);
              v117 = vaddq_f32(v201, v128);
              v125 = vaddq_f32(v202, v136);
              v98 = vaddq_f32(v203, v127);
              v97.f32[0] = v97.f32[0] + 1.0;
              ++v116;
            }
            while (v97.f32[0] < v54[2].f32[0]);
          }
          a3[2] = v191;
          a1 = v210;
          v147 = *(_DWORD *)(*(_QWORD *)(v210 + 264) + 1068);
          v148 = v53[17];
          v53[2] = vaddq_f32(v53[18], v53[2]);
          v53[11] = vaddq_f32(v53[27], v53[11]);
          v53[17] = vaddq_f32(v53[33], v148);
          v53[15] = vaddq_f32(v53[31], v53[15]);
          if ((v147 & 1) != 0)
          {
            v53[3] = vaddq_f32(v53[19], v53[3]);
            LOBYTE(v18) = v172;
            v149 = v173;
            v150 = v176;
            if ((v147 & 2) == 0)
            {
LABEL_147:
              if ((v147 & 4) == 0)
                goto LABEL_148;
              goto LABEL_165;
            }
          }
          else
          {
            LOBYTE(v18) = v172;
            v149 = v173;
            v150 = v176;
            if ((v147 & 2) == 0)
              goto LABEL_147;
          }
          v53[4] = vaddq_f32(v53[20], v53[4]);
          if ((v147 & 4) == 0)
          {
LABEL_148:
            if ((v147 & 8) == 0)
              goto LABEL_149;
            goto LABEL_166;
          }
LABEL_165:
          v53[5] = vaddq_f32(v53[21], v53[5]);
          if ((v147 & 8) == 0)
          {
LABEL_149:
            if ((v147 & 0x10) == 0)
              goto LABEL_150;
            goto LABEL_167;
          }
LABEL_166:
          v53[6] = vaddq_f32(v53[22], v53[6]);
          if ((v147 & 0x10) == 0)
          {
LABEL_150:
            if ((v147 & 0x20) == 0)
              goto LABEL_151;
            goto LABEL_168;
          }
LABEL_167:
          v53[7] = vaddq_f32(v53[23], v53[7]);
          if ((v147 & 0x20) == 0)
          {
LABEL_151:
            if ((v147 & 0x40) == 0)
              goto LABEL_152;
            goto LABEL_169;
          }
LABEL_168:
          v53[8] = vaddq_f32(v53[24], v53[8]);
          if ((v147 & 0x40) == 0)
          {
LABEL_152:
            if ((v147 & 0x80) == 0)
              goto LABEL_154;
LABEL_153:
            v53[10] = vaddq_f32(v53[26], v53[10]);
            goto LABEL_154;
          }
LABEL_169:
          v53[9] = vaddq_f32(v53[25], v53[9]);
          if ((v147 & 0x80) != 0)
            goto LABEL_153;
LABEL_154:
          v151 = *(_DWORD *)(*(_QWORD *)(v210 + 264) + 1068);
          v49 = v54[17];
          v54[2] = vaddq_f32(v54[18], v54[2]);
          v54[11] = vaddq_f32(v54[27], v54[11]);
          v54[17] = vaddq_f32(v54[33], v49);
          v48 = v54[15];
          v47 = (int32x4_t)vaddq_f32(v54[31], v48);
          v54[15] = (float32x4_t)v47;
          if ((v151 & 1) != 0)
          {
            v48 = v54[3];
            v47 = (int32x4_t)vaddq_f32(v54[19], v48);
            v54[3] = (float32x4_t)v47;
            if ((v151 & 2) == 0)
            {
LABEL_156:
              if ((v151 & 4) == 0)
                goto LABEL_157;
              goto LABEL_173;
            }
          }
          else if ((v151 & 2) == 0)
          {
            goto LABEL_156;
          }
          v48 = v54[4];
          v47 = (int32x4_t)vaddq_f32(v54[20], v48);
          v54[4] = (float32x4_t)v47;
          if ((v151 & 4) == 0)
          {
LABEL_157:
            if ((v151 & 8) == 0)
              goto LABEL_158;
            goto LABEL_174;
          }
LABEL_173:
          v48 = v54[5];
          v47 = (int32x4_t)vaddq_f32(v54[21], v48);
          v54[5] = (float32x4_t)v47;
          if ((v151 & 8) == 0)
          {
LABEL_158:
            if ((v151 & 0x10) == 0)
              goto LABEL_159;
            goto LABEL_175;
          }
LABEL_174:
          v48 = v54[6];
          v47 = (int32x4_t)vaddq_f32(v54[22], v48);
          v54[6] = (float32x4_t)v47;
          if ((v151 & 0x10) == 0)
          {
LABEL_159:
            if ((v151 & 0x20) == 0)
              goto LABEL_160;
            goto LABEL_176;
          }
LABEL_175:
          v48 = v54[7];
          v47 = (int32x4_t)vaddq_f32(v54[23], v48);
          v54[7] = (float32x4_t)v47;
          if ((v151 & 0x20) == 0)
          {
LABEL_160:
            if ((v151 & 0x40) == 0)
              goto LABEL_161;
            goto LABEL_177;
          }
LABEL_176:
          v48 = v54[8];
          v47 = (int32x4_t)vaddq_f32(v54[24], v48);
          v54[8] = (float32x4_t)v47;
          if ((v151 & 0x40) == 0)
          {
LABEL_161:
            if ((v151 & 0x80) != 0)
              goto LABEL_178;
            goto LABEL_63;
          }
LABEL_177:
          v48 = v54[9];
          v47 = (int32x4_t)vaddq_f32(v54[25], v48);
          v54[9] = (float32x4_t)v47;
          if ((v151 & 0x80) != 0)
          {
LABEL_178:
            v48 = v54[10];
            v47 = (int32x4_t)vaddq_f32(v54[26], v48);
            v54[10] = (float32x4_t)v47;
          }
LABEL_63:
          v50 = v150 + 2;
          if (v50 >= v149)
            goto LABEL_29;
        }
      }
    }
LABEL_188:
    v165 = v224;
    if (v224)
    {
      do
      {
        v166 = __ldaxr((unsigned int *)v165);
        v167 = v166 - 1;
      }
      while (__stlxr(v167, (unsigned int *)v165));
      if (!v167)
      {
        v168 = *(_QWORD *)(v165 + 16);
        if (v168)
          MEMORY[0x1B5E2914C](v168, 0x1000C8077774924);
        MEMORY[0x1B5E29170](v165, 0x1080C4098BBCF0FLL);
      }
    }
    v14 = v227;
    if (v227)
    {
LABEL_202:
      do
      {
        v169 = __ldaxr((unsigned int *)v14);
        v170 = v169 - 1;
      }
      while (__stlxr(v170, (unsigned int *)v14));
      if (!v170)
      {
        v171 = *(_QWORD *)(v14 + 16);
        if (v171)
          MEMORY[0x1B5E2914C](v171, 0x1000C8077774924);
        MEMORY[0x1B5E29170](v14, 0x1080C4098BBCF0FLL);
      }
    }
  }
}

void sub_1B29CB1E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 224));
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 192));
  _Unwind_Resume(a1);
}

uint64_t CompareEdgeX(const void *a1, const void *a2)
{
  float v2;
  float v3;

  v2 = *(float *)(*(_QWORD *)a1 + 32);
  v3 = *(float *)(*(_QWORD *)a2 + 32);
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  else
    return v2 > v3;
}

void HGeometryData::RenderPolygons(HGeometryData *this, int32x2_t *a2, HGSampleRectStat *a3)
{
  int v6;
  HGRenderer *v7;
  const void *v8;
  DepthBufferManager *v9;
  int v10;
  int32x2_t v11;
  int32x2_t v12;
  uint64_t v13;
  uint64_t DepthBuffer;
  HGRenderer *v15;
  uint64_t ActiveShaderNode;
  uint64_t v17;
  unsigned int v18;
  int i;
  _QWORD v20[28];
  int v21;
  int Target;

  v6 = *(_DWORD *)(*(_QWORD *)&a2[42] + 160);
  v7 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  v8 = (const void *)HGRenderer::DepthManager(v7, v6);
  if (v8)
  else
    v9 = 0;
  v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 33) + 592))(*((_QWORD *)this + 33)) & 0xA;
  if (v10)
  {
    v11 = *a2;
    v12 = a2[1];
    v13 = HGTile::Renderer((HGTile *)a2);
    DepthBufferManager::init((uint64_t)v9, v13);
    if (v10 == 2)
      (*(void (**)(DepthBufferManager *))(*(_QWORD *)v9 + 24))(v9);
    (*(void (**)(DepthBufferManager *, _QWORD, int32x2_t, int32x2_t))(*(_QWORD *)v9 + 40))(v9, 0, v11, v12);
    DepthBuffer = DepthBufferManager::getDepthBuffer(v9);
    a2[5].i32[0] = *(_DWORD *)(DepthBuffer + 64) / *(_DWORD *)(DepthBuffer + 56);
    a2[4] = *(int32x2_t *)((char *)v9 + 64);
  }
  v15 = (HGRenderer *)HGTile::Renderer((HGTile *)a2);
  Target = HGRenderer::GetTarget(v15, 0);
  ActiveShaderNode = HGRasterizer::getActiveShaderNode(*((HGRasterizer **)this + 33));
  v17 = HGTile::Renderer((HGTile *)a2);
  v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)ActiveShaderNode + 312))(ActiveShaderNode, v17);
  v20[26] = 0;
  v20[27] = 0;
  v18 = *((_DWORD *)this + 61);
  if (v18)
  {
    for (i = 0; i < v18; ++i)
    {
      if (*(int *)(*(_QWORD *)(*((_QWORD *)this + 6) + 16)
                  + *(int *)(*((_QWORD *)this + 6) + 4) * (uint64_t)i
                  + *((int *)this + 14)) >= 3)
      {
        HGeometryData::RenderPolygon((uint64_t)this, i, a2, (uint64_t)v20, (uint64_t)a3);
        v18 = *((_DWORD *)this + 61);
      }
    }
  }
  if (v10)
  {
    (*(void (**)(DepthBufferManager *))(*(_QWORD *)v9 + 48))(v9);
    if (v10 == 2)
      (*(void (**)(DepthBufferManager *))(*(_QWORD *)v9 + 32))(v9);
  }
}

void HGeometryData::~HGeometryData(HGeometryData *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;

  v2 = *((_QWORD *)this + 28);
  if (v2)
  {
    do
    {
      v3 = __ldaxr((unsigned int *)v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, (unsigned int *)v2));
    if (!v4)
    {
      v5 = *(_QWORD *)(v2 + 16);
      if (v5)
        MEMORY[0x1B5E2914C](v5, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v2, 0x1080C4098BBCF0FLL);
    }
  }
  v6 = *((_QWORD *)this + 26);
  if (v6)
  {
    do
    {
      v7 = __ldaxr((unsigned int *)v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, (unsigned int *)v6));
    if (!v8)
    {
      v9 = *(_QWORD *)(v6 + 16);
      if (v9)
        MEMORY[0x1B5E2914C](v9, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v6, 0x1080C4098BBCF0FLL);
    }
  }
  v10 = *((_QWORD *)this + 24);
  if (v10)
  {
    do
    {
      v11 = __ldaxr((unsigned int *)v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, (unsigned int *)v10));
    if (!v12)
    {
      v13 = *(_QWORD *)(v10 + 16);
      if (v13)
        MEMORY[0x1B5E2914C](v13, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v10, 0x1080C4098BBCF0FLL);
    }
  }
  v14 = *((_QWORD *)this + 22);
  if (v14)
  {
    do
    {
      v15 = __ldaxr((unsigned int *)v14);
      v16 = v15 - 1;
    }
    while (__stlxr(v16, (unsigned int *)v14));
    if (!v16)
    {
      v17 = *(_QWORD *)(v14 + 16);
      if (v17)
        MEMORY[0x1B5E2914C](v17, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v14, 0x1080C4098BBCF0FLL);
    }
  }
  v18 = *((_QWORD *)this + 20);
  if (v18)
  {
    do
    {
      v19 = __ldaxr((unsigned int *)v18);
      v20 = v19 - 1;
    }
    while (__stlxr(v20, (unsigned int *)v18));
    if (!v20)
    {
      v21 = *(_QWORD *)(v18 + 16);
      if (v21)
        MEMORY[0x1B5E2914C](v21, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v18, 0x1080C4098BBCF0FLL);
    }
  }
  v22 = *((_QWORD *)this + 18);
  if (v22)
  {
    do
    {
      v23 = __ldaxr((unsigned int *)v22);
      v24 = v23 - 1;
    }
    while (__stlxr(v24, (unsigned int *)v22));
    if (!v24)
    {
      v25 = *(_QWORD *)(v22 + 16);
      if (v25)
        MEMORY[0x1B5E2914C](v25, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v22, 0x1080C4098BBCF0FLL);
    }
  }
  v26 = *((_QWORD *)this + 16);
  if (v26)
  {
    do
    {
      v27 = __ldaxr((unsigned int *)v26);
      v28 = v27 - 1;
    }
    while (__stlxr(v28, (unsigned int *)v26));
    if (!v28)
    {
      v29 = *(_QWORD *)(v26 + 16);
      if (v29)
        MEMORY[0x1B5E2914C](v29, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v26, 0x1080C4098BBCF0FLL);
    }
  }
  v30 = *((_QWORD *)this + 14);
  if (v30)
  {
    do
    {
      v31 = __ldaxr((unsigned int *)v30);
      v32 = v31 - 1;
    }
    while (__stlxr(v32, (unsigned int *)v30));
    if (!v32)
    {
      v33 = *(_QWORD *)(v30 + 16);
      if (v33)
        MEMORY[0x1B5E2914C](v33, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v30, 0x1080C4098BBCF0FLL);
    }
  }
  v34 = *((_QWORD *)this + 12);
  if (v34)
  {
    do
    {
      v35 = __ldaxr((unsigned int *)v34);
      v36 = v35 - 1;
    }
    while (__stlxr(v36, (unsigned int *)v34));
    if (!v36)
    {
      v37 = *(_QWORD *)(v34 + 16);
      if (v37)
        MEMORY[0x1B5E2914C](v37, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v34, 0x1080C4098BBCF0FLL);
    }
  }
  v38 = *((_QWORD *)this + 10);
  if (v38)
  {
    do
    {
      v39 = __ldaxr((unsigned int *)v38);
      v40 = v39 - 1;
    }
    while (__stlxr(v40, (unsigned int *)v38));
    if (!v40)
    {
      v41 = *(_QWORD *)(v38 + 16);
      if (v41)
        MEMORY[0x1B5E2914C](v41, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v38, 0x1080C4098BBCF0FLL);
    }
  }
  v42 = *((_QWORD *)this + 8);
  if (v42)
  {
    do
    {
      v43 = __ldaxr((unsigned int *)v42);
      v44 = v43 - 1;
    }
    while (__stlxr(v44, (unsigned int *)v42));
    if (!v44)
    {
      v45 = *(_QWORD *)(v42 + 16);
      if (v45)
        MEMORY[0x1B5E2914C](v45, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v42, 0x1080C4098BBCF0FLL);
    }
  }
  v46 = *((_QWORD *)this + 6);
  if (v46)
  {
    do
    {
      v47 = __ldaxr((unsigned int *)v46);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, (unsigned int *)v46));
    if (!v48)
    {
      v49 = *(_QWORD *)(v46 + 16);
      if (v49)
        MEMORY[0x1B5E2914C](v49, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v46, 0x1080C4098BBCF0FLL);
    }
  }
  v50 = *((_QWORD *)this + 4);
  if (v50)
  {
    do
    {
      v51 = __ldaxr((unsigned int *)v50);
      v52 = v51 - 1;
    }
    while (__stlxr(v52, (unsigned int *)v50));
    if (!v52)
    {
      v53 = *(_QWORD *)(v50 + 16);
      if (v53)
        MEMORY[0x1B5E2914C](v53, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v50, 0x1080C4098BBCF0FLL);
    }
  }
  v54 = *((_QWORD *)this + 2);
  if (v54)
  {
    do
    {
      v55 = __ldaxr((unsigned int *)v54);
      v56 = v55 - 1;
    }
    while (__stlxr(v56, (unsigned int *)v54));
    if (!v56)
    {
      v57 = *(_QWORD *)(v54 + 16);
      if (v57)
        MEMORY[0x1B5E2914C](v57, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v54, 0x1080C4098BBCF0FLL);
    }
  }
  v58 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    do
    {
      v59 = __ldaxr((unsigned int *)v58);
      v60 = v59 - 1;
    }
    while (__stlxr(v60, (unsigned int *)v58));
    if (!v60)
    {
      v61 = *(_QWORD *)(v58 + 16);
      if (v61)
        MEMORY[0x1B5E2914C](v61, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v58, 0x1080C4098BBCF0FLL);
    }
  }
}

uint64_t HGArrayDataRef::allocate(HGArrayDataRef *this, int a2, int a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;

  result = operator new();
  v9 = result;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = 0;
  *(_QWORD *)(result + 16) = 0;
  if (a4)
  {
    *(_DWORD *)(result + 12) = a4;
    if (a2)
    {
      v10 = operator new[]();
      result = *(_QWORD *)(v9 + 16);
      if (result)
        result = MEMORY[0x1B5E2914C](result, 0x1000C8077774924);
    }
    else
    {
      v10 = 0;
    }
    *(_QWORD *)(v9 + 16) = v10;
  }
  do
    v11 = __ldaxr((unsigned int *)v9);
  while (__stlxr(v11 + 1, (unsigned int *)v9));
  v12 = *(_QWORD *)this;
  if (*(_QWORD *)this == v9)
  {
    do
    {
      v16 = __ldaxr((unsigned int *)v9);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, (unsigned int *)v9));
    if (!v17)
    {
      v18 = *(_QWORD *)(v9 + 16);
      if (v18)
        MEMORY[0x1B5E2914C](v18, 0x1000C8077774924);
      JUMPOUT(0x1B5E29170);
    }
  }
  else
  {
    if (v12)
    {
      do
      {
        v13 = __ldaxr((unsigned int *)v12);
        v14 = v13 - 1;
      }
      while (__stlxr(v14, (unsigned int *)v12));
      if (!v14)
      {
        v15 = *(_QWORD *)(v12 + 16);
        if (v15)
          MEMORY[0x1B5E2914C](v15, 0x1000C8077774924);
        result = MEMORY[0x1B5E29170](v12, 0x1080C4098BBCF0FLL);
      }
    }
    *(_QWORD *)this = v9;
  }
  return result;
}

void sub_1B29CBAC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1080C4098BBCF0FLL);
  _Unwind_Resume(a1);
}

uint64_t HGArray<__simd128_float32_t,(HGFormat)28>::append(HGArrayDataRef *this)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v8;
  int v9;
  int v10;
  void *v11;
  void *v12;
  const void *v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  void *v20;
  void *v21;
  const void *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
  {
    HGArrayDataRef::allocate(this, 16, 2, 2);
    v4 = 0;
    v2 = *(_QWORD *)this;
    v5 = 1;
    if (*(_QWORD *)this)
      goto LABEL_20;
LABEL_36:
    HGArrayDataRef::allocate(this, 16, v5, v5);
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(v2 + 8);
  v3 = *(_DWORD *)(v2 + 12);
  v5 = v4 + 1;
  v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    v8 = *(_DWORD *)(v2 + 4);
    v9 = v8 * v6;
    *(_DWORD *)(v2 + 12) = v6;
    if (v8 * v6)
    {
      v10 = v8 * v3;
      v11 = (void *)operator new[]();
      v12 = v11;
      if (v10)
      {
        v13 = *(const void **)(v2 + 16);
        if (v13)
        {
          if (v10 >= v9)
            v14 = v9;
          else
            v14 = v10;
          memcpy(v11, v13, v14);
        }
      }
    }
    else
    {
      v12 = 0;
    }
    v15 = *(_QWORD *)(v2 + 16);
    if (v15)
      MEMORY[0x1B5E2914C](v15, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v12;
    v2 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
    {
      if (v4 < 0)
        return 0;
      goto LABEL_36;
    }
  }
LABEL_20:
  v16 = *(_DWORD *)(v2 + 12);
  if (v16 >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
  else
  {
    v17 = *(_DWORD *)(v2 + 4);
    v18 = v17 * v5;
    *(_DWORD *)(v2 + 12) = v5;
    if (v17 * v5)
    {
      v19 = v17 * v16;
      v20 = (void *)operator new[]();
      v21 = v20;
      if (v19)
      {
        v22 = *(const void **)(v2 + 16);
        if (v22)
        {
          if (v19 >= v18)
            v23 = v18;
          else
            v23 = v19;
          memcpy(v20, v22, v23);
        }
      }
    }
    else
    {
      v21 = 0;
    }
    v25 = *(_QWORD *)(v2 + 16);
    if (v25)
      MEMORY[0x1B5E2914C](v25, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v21;
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
LABEL_37:
  v26 = *(_QWORD *)(v24 + 16);
  if (v26)
    return v26 + *(int *)(v24 + 4) * (uint64_t)v4 + *((int *)this + 2);
  return 0;
}

uint64_t HGArray<int,(HGFormat)34>::append(HGArrayDataRef *this)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v8;
  int v9;
  int v10;
  void *v11;
  void *v12;
  const void *v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  void *v20;
  void *v21;
  const void *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
  {
    HGArrayDataRef::allocate(this, 4, 2, 2);
    v4 = 0;
    v2 = *(_QWORD *)this;
    v5 = 1;
    if (*(_QWORD *)this)
      goto LABEL_20;
LABEL_36:
    HGArrayDataRef::allocate(this, 4, v5, v5);
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(v2 + 8);
  v3 = *(_DWORD *)(v2 + 12);
  v5 = v4 + 1;
  v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    v8 = *(_DWORD *)(v2 + 4);
    v9 = v8 * v6;
    *(_DWORD *)(v2 + 12) = v6;
    if (v8 * v6)
    {
      v10 = v8 * v3;
      v11 = (void *)operator new[]();
      v12 = v11;
      if (v10)
      {
        v13 = *(const void **)(v2 + 16);
        if (v13)
        {
          if (v10 >= v9)
            v14 = v9;
          else
            v14 = v10;
          memcpy(v11, v13, v14);
        }
      }
    }
    else
    {
      v12 = 0;
    }
    v15 = *(_QWORD *)(v2 + 16);
    if (v15)
      MEMORY[0x1B5E2914C](v15, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v12;
    v2 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
    {
      if (v4 < 0)
        return 0;
      goto LABEL_36;
    }
  }
LABEL_20:
  v16 = *(_DWORD *)(v2 + 12);
  if (v16 >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
  else
  {
    v17 = *(_DWORD *)(v2 + 4);
    v18 = v17 * v5;
    *(_DWORD *)(v2 + 12) = v5;
    if (v17 * v5)
    {
      v19 = v17 * v16;
      v20 = (void *)operator new[]();
      v21 = v20;
      if (v19)
      {
        v22 = *(const void **)(v2 + 16);
        if (v22)
        {
          if (v19 >= v18)
            v23 = v18;
          else
            v23 = v19;
          memcpy(v20, v22, v23);
        }
      }
    }
    else
    {
      v21 = 0;
    }
    v25 = *(_QWORD *)(v2 + 16);
    if (v25)
      MEMORY[0x1B5E2914C](v25, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v21;
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
LABEL_37:
  v26 = *(_QWORD *)(v24 + 16);
  if (v26)
    return v26 + *(int *)(v24 + 4) * (uint64_t)v4 + *((int *)this + 2);
  return 0;
}

uint64_t HGArray<BOOL,(HGFormat)0>::append(HGArrayDataRef *this)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v8;
  int v9;
  int v10;
  void *v11;
  void *v12;
  const void *v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  void *v20;
  void *v21;
  const void *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
  {
    v5 = 1;
    HGArrayDataRef::allocate(this, 1, 2, 2);
    v4 = 0;
    v2 = *(_QWORD *)this;
    if (*(_QWORD *)this)
      goto LABEL_20;
LABEL_36:
    HGArrayDataRef::allocate(this, 1, v5, v5);
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(v2 + 8);
  v3 = *(_DWORD *)(v2 + 12);
  v5 = v4 + 1;
  v6 = 2 * (v4 + 1);
  if (v4 >= v3 && v3 < v6)
  {
    v8 = *(_DWORD *)(v2 + 4);
    v9 = v8 * v6;
    *(_DWORD *)(v2 + 12) = v6;
    if (v8 * v6)
    {
      v10 = v8 * v3;
      v11 = (void *)operator new[]();
      v12 = v11;
      if (v10)
      {
        v13 = *(const void **)(v2 + 16);
        if (v13)
        {
          if (v10 >= v9)
            v14 = v9;
          else
            v14 = v10;
          memcpy(v11, v13, v14);
        }
      }
    }
    else
    {
      v12 = 0;
    }
    v15 = *(_QWORD *)(v2 + 16);
    if (v15)
      MEMORY[0x1B5E2914C](v15, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v12;
    v2 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
    {
      if (v4 < 0)
        return 0;
      goto LABEL_36;
    }
  }
LABEL_20:
  v16 = *(_DWORD *)(v2 + 12);
  if (v16 >= v5)
  {
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
  else
  {
    v17 = *(_DWORD *)(v2 + 4);
    v18 = v17 * v5;
    *(_DWORD *)(v2 + 12) = v5;
    if (v17 * v5)
    {
      v19 = v17 * v16;
      v20 = (void *)operator new[]();
      v21 = v20;
      if (v19)
      {
        v22 = *(const void **)(v2 + 16);
        if (v22)
        {
          if (v19 >= v18)
            v23 = v18;
          else
            v23 = v19;
          memcpy(v20, v22, v23);
        }
      }
    }
    else
    {
      v21 = 0;
    }
    v25 = *(_QWORD *)(v2 + 16);
    if (v25)
      MEMORY[0x1B5E2914C](v25, 0x1000C8077774924);
    *(_QWORD *)(v2 + 16) = v21;
    *(_DWORD *)(v2 + 8) = v5;
    v24 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      return 0;
  }
LABEL_37:
  v26 = *(_QWORD *)(v24 + 16);
  if (v26)
    return v26 + *(int *)(v24 + 4) * (uint64_t)v4 + *((int *)this + 2);
  return 0;
}

void OUTLINED_FUNCTION_0_0()
{
  JUMPOUT(0x1B5E29170);
}

void OUTLINED_FUNCTION_1()
{
  JUMPOUT(0x1B5E2914CLL);
}

void OUTLINED_FUNCTION_4()
{
  unsigned int *v0;

  __ldaxr(v0);
}

void OUTLINED_FUNCTION_5()
{
  uint64_t v0;
  int v1;
  uint64_t v2;

  *(_QWORD *)v0 = v2;
  *(_DWORD *)(v0 + 8) = v1;
}

void OUTLINED_FUNCTION_6()
{
  JUMPOUT(0x1B5E29170);
}

uint64_t OUTLINED_FUNCTION_7()
{
  uint64_t v0;

  return v0;
}

uint64_t HGeometryData::HGeometryData(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;

  do
  {
    v1 = __ldaxr((unsigned int *)result);
    v2 = v1 - 1;
  }
  while (__stlxr(v2, (unsigned int *)result));
  if (!v2)
  {
    if (*(_QWORD *)(result + 16))
      OUTLINED_FUNCTION_1();
    OUTLINED_FUNCTION_7();
    OUTLINED_FUNCTION_6();
  }
  return result;
}

void HGeometryData::HGeometryData()
{
  uint64_t v0;
  char v1;
  unsigned int v2;

  OUTLINED_FUNCTION_2();
  do
    OUTLINED_FUNCTION_4();
  while (__stlxr(v2, (unsigned int *)v0));
  if (v1)
  {
    if (*(_QWORD *)(v0 + 16))
      OUTLINED_FUNCTION_1();
    OUTLINED_FUNCTION_0_0();
  }
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
}

void HGGLNode::HGGLNode(HGGLNode *this, unint64_t a2)
{
  _QWORD *v4;
  HGRasterizer *v5;

  HGNode::HGNode((HGNode *)this);
  *v4 = off_1E6514338;
  v4[52] = 0;
  v5 = (HGRasterizer *)HGObject::operator new(0x4D0uLL);
  HGRasterizer::HGRasterizer(v5, a2);
  *((_QWORD *)this + 51) = v5;
  *((_DWORD *)this + 106) = 1;
}

void sub_1B29CC22C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  HGObject::operator delete(v2);
  v4 = *(_QWORD *)(v1 + 416);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGGLNode::~HGGLNode(HGGLNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6514338;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode((HGNode *)this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6514338;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode((HGNode *)this);
  HGObject::operator delete(v3);
}

void HGGLNode::addFragmentShader(HGRasterizer **this, HGNode3D *a2)
{
  HGRasterizer::addFragmentShader(this[51], a2);
}

uint64_t HGGLNode::enableXFormConcatenation(HGGLNode *this, HGNode3D *a2)
{
  return HGRasterizer::enableXFormConcatenation(*((_QWORD *)this + 51), (uint64_t)a2);
}

uint64_t HGGLNode::enableInplaceBlending(HGGLNode *this)
{
  return HGRasterizer::enableInplaceBlending(*((_QWORD *)this + 51));
}

uint64_t HGGLNode::SetParameter(HGGLNode *this, uint64_t a2, float a3, float a4, float a5, float a6)
{
  float v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  int v13;
  float v15[4];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v9 = fmaxf(fminf(a4, 4.0), 0.0);
  (*(void (**)(_QWORD, uint64_t, float *))(**((_QWORD **)this + 51) + 104))(*((_QWORD *)this + 51), a2, v15);
  if ((int)v9 > 4)
    v13 = 1;
  else
    v13 = dword_1B309BA60[v9];
  if ((a3 == 1.0) != (v15[0] != 1.0) && *((_DWORD *)this + 106) == v13)
    return 0;
  *((_DWORD *)this + 106) = v13;
  v10.n128_u32[0] = 0;
  if (a3 == 1.0)
    v10.n128_f32[0] = 1.0;
  v11.n128_u32[0] = *((_DWORD *)&xmmword_1B304EFF0 + v13);
  v12.n128_u32[0] = dword_1B309BA80[v13];
  (*(void (**)(_QWORD, _QWORD, __n128, __n128, __n128, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, v10, v11, v12, 0.0);
  return 1;
}

uint64_t HGGLNode::SetActiveShaderNodeParameter(HGRasterizer **this, uint64_t a2, float a3, float a4, float a5, float a6)
{
  return HGRasterizer::SetActiveShaderNodeParameter(this[51], a2, a3, a4, a5, a6);
}

HGXForm *HGGLNode::GetOutput(HGGLNode *this, HGRenderer *a2)
{
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  int v8;
  void *v9;
  void *v10;
  const void *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  HGTextureWrap *v16;
  HGNode *Input;
  uint64_t v18;
  uint64_t DOD;
  uint64_t v20;
  uint64_t v21;
  HGNode *v22;
  const HGTransform *v23;
  uint64_t v24;
  int v25;
  int TextureWrapMode;
  int v27;
  BOOL v28;
  BOOL v29;
  char *v30;
  char v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  HGXForm *v57;
  HGXForm **v58;
  HGXForm *v59;
  float SuperSampleScale;
  int MatrixMode;
  HGXForm *v62;
  HGXForm *v63;
  unsigned int NPolys;
  HGXForm *v65;
  uint64_t v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v71[18];
  uint64_t v72;
  uint64_t v73;

  v4 = (_BYTE *)*((_QWORD *)this + 51);
  if (v4[1141])
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v4 + 16))(*((_QWORD *)this + 51));
    v5 = (_BYTE *)*((_QWORD *)this + 52);
    if (v5 == v4)
    {
      (*(void (**)(_BYTE *))(*(_QWORD *)v4 + 24))(v4);
    }
    else
    {
      if (v5)
        (*(void (**)(_BYTE *))(*(_QWORD *)v5 + 24))(v5);
      *((_QWORD *)this + 52) = v4;
    }
  }
  v72 = 0;
  v73 = 0;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v72, 8, 0, 0);
  v6 = v72;
  if (v72)
  {
    v7 = *(_DWORD *)(v72 + 12);
    if (v7 <= 7)
    {
      v8 = *(_DWORD *)(v72 + 4);
      *(_DWORD *)(v72 + 12) = 8;
      if (v8)
      {
        v9 = (void *)operator new[]();
        v10 = v9;
        if (v7)
        {
          v11 = *(const void **)(v6 + 16);
          if (v11)
          {
            v12 = v8 * v7;
            if (v8 * v7 >= 8 * v8)
              v12 = 8 * v8;
            memcpy(v9, v11, v12);
          }
        }
      }
      else
      {
        v10 = 0;
      }
      v13 = *(_QWORD *)(v6 + 16);
      if (v13)
        MEMORY[0x1B5E2914C](v13, 0x1000C8077774924);
      *(_QWORD *)(v6 + 16) = v10;
    }
    *(_DWORD *)(v6 + 8) = 8;
  }
  else
  {
    HGArrayDataRef::allocate((HGArrayDataRef *)&v72, 8, 8, 8);
  }
  v14 = 0;
  v15 = v73;
  do
  {
    *(_QWORD *)(*(_QWORD *)(v72 + 16) + *(int *)(v72 + 4) * (uint64_t)(int)v14 + v15) = 0;
    Input = HGRenderer::GetInput(a2, (HGNode *)this, v14);
    if (!Input)
    {
      v16 = 0;
      goto LABEL_23;
    }
    if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0
      && *((_DWORD *)Input + 3) == 1481003597
      && ((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 51) + 592))(*((_QWORD *)this + 51)) & 0x80) != 0
      && (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 22))
    {
      v18 = *((_QWORD *)this + 51);
      DOD = HGRenderer::GetDOD(a2, Input);
      v21 = v20;
      if (HGXForm::IsAnisotropic((HGXForm *)Input)
        || (v21 - DOD) < 0x11
        || (HIDWORD(v21) - HIDWORD(DOD)) < 0x11
        || (v22 = HGRenderer::GetInput(a2, Input, 0)) == 0)
      {
        v22 = Input;
      }
      else
      {
        v23 = (const HGTransform *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)Input + 584))(Input);
        (*(void (**)(HGNode *))(*(_QWORD *)Input + 16))(Input);
        v71[0] = (uint64_t)Input;
        HGRasterizer::addInputTransform(v18, v14, v23, v71);
        if (v71[0])
          (*(void (**)(uint64_t))(*(_QWORD *)v71[0] + 24))(v71[0]);
      }
      Input = v22;
    }
    (*(void (**)(HGNode *))(*(_QWORD *)Input + 16))(Input);
    v24 = *(_QWORD *)(*((_QWORD *)this + 51) + 8 * v14 + 432);
    v25 = *(_DWORD *)(v24 + 168);
    if (!v25)
    {
LABEL_22:
      v16 = (HGTextureWrap *)Input;
      goto LABEL_23;
    }
    if (*((_DWORD *)Input + 3) == -1814136143)
    {
      TextureWrapMode = HGTextureWrap::GetTextureWrapMode((HGTextureWrap *)Input);
      v27 = HGTextureWrap::GetTextureWrapMode((HGTextureWrap *)Input);
      v28 = TextureWrapMode != 1;
      v29 = v27 != 0;
      v25 = *(_DWORD *)(v24 + 168);
      if (v25 != 2)
        goto LABEL_45;
    }
    else
    {
      v28 = 0;
      v29 = 0;
      if (v25 != 2)
        goto LABEL_45;
    }
    if (v29)
    {
LABEL_45:
      v31 = v25 != 1 || v28;
      if ((v31 & 1) != 0)
        goto LABEL_22;
      v16 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
      HGTextureWrap::HGTextureWrap(v16);
      HGTextureWrap::SetTextureWrapMode((uint64_t)v16, (const char *)1, v32);
      goto LABEL_50;
    }
    v16 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
    HGTextureWrap::HGTextureWrap(v16);
    HGTextureWrap::SetTextureWrapMode((uint64_t)v16, 0, v30);
    HGTextureWrap::SetTextureBorderColor(v16, (float *)(v24 + 196));
LABEL_50:
    if (!v16)
      goto LABEL_22;
    (*(void (**)(HGTextureWrap *, _QWORD, HGNode *))(*(_QWORD *)v16 + 120))(v16, 0, Input);
    (*(void (**)(HGNode *))(*(_QWORD *)Input + 24))(Input);
LABEL_23:
    v15 = v73;
    *(_QWORD *)(*(_QWORD *)(v72 + 16) + *(int *)(v72 + 4) * (uint64_t)(int)v14++ + (int)v73) = v16;
  }
  while (v14 != 8);
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) + (int)v73))
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 0);
    v33 = *((_QWORD *)this + 51);
    v34 = (*(uint64_t (**)(HGGLNode *, _QWORD))(*(_QWORD *)this + 152))(this, 0);
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v33 + 136))(v33, 0, v34);
    v35 = *(_QWORD *)(*(_QWORD *)(v72 + 16) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
  }
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) + *(int *)(v72 + 4) + (int)v73))
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 1);
    v36 = *((_QWORD *)this + 51);
    v37 = (*(uint64_t (**)(HGGLNode *, uint64_t))(*(_QWORD *)this + 152))(this, 1);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v36 + 136))(v36, 1, v37);
    v38 = *(_QWORD *)(*(_QWORD *)(v72 + 16) + *(int *)(v72 + 4) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v38 + 24))(v38);
  }
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) + 2 * *(int *)(v72 + 4) + (int)v73))
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 2);
    v39 = *((_QWORD *)this + 51);
    v40 = (*(uint64_t (**)(HGGLNode *, uint64_t))(*(_QWORD *)this + 152))(this, 2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v39 + 136))(v39, 2, v40);
    v41 = *(_QWORD *)(*(_QWORD *)(v72 + 16) + 2 * *(int *)(v72 + 4) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v41 + 24))(v41);
  }
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) + 3 * *(int *)(v72 + 4) + (int)v73))
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 3);
    v42 = *((_QWORD *)this + 51);
    v43 = (*(uint64_t (**)(HGGLNode *, uint64_t))(*(_QWORD *)this + 152))(this, 3);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v42 + 136))(v42, 3, v43);
    v44 = *(_QWORD *)(*(_QWORD *)(v72 + 16) + 3 * *(int *)(v72 + 4) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  }
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) + 4 * *(int *)(v72 + 4) + (int)v73))
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 4);
    v45 = *((_QWORD *)this + 51);
    v46 = (*(uint64_t (**)(HGGLNode *, uint64_t))(*(_QWORD *)this + 152))(this, 4);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v45 + 136))(v45, 4, v46);
    v47 = *(_QWORD *)(*(_QWORD *)(v72 + 16) + 4 * *(int *)(v72 + 4) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v47 + 24))(v47);
  }
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) + 5 * *(int *)(v72 + 4) + (int)v73))
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 5);
    v48 = *((_QWORD *)this + 51);
    v49 = (*(uint64_t (**)(HGGLNode *, uint64_t))(*(_QWORD *)this + 152))(this, 5);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v48 + 136))(v48, 5, v49);
    v50 = *(_QWORD *)(*(_QWORD *)(v72 + 16) + 5 * *(int *)(v72 + 4) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v50 + 24))(v50);
  }
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) + 6 * *(int *)(v72 + 4) + (int)v73))
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 6);
    v51 = *((_QWORD *)this + 51);
    v52 = (*(uint64_t (**)(HGGLNode *, uint64_t))(*(_QWORD *)this + 152))(this, 6);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v51 + 136))(v51, 6, v52);
    v53 = *(_QWORD *)(*(_QWORD *)(v72 + 16) + 6 * *(int *)(v72 + 4) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v53 + 24))(v53);
  }
  if (*(_QWORD *)(*(_QWORD *)(v72 + 16) - *(int *)(v72 + 4) + 8 * *(int *)(v72 + 4) + (int)v73))
  {
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 7);
    v54 = *((_QWORD *)this + 51);
    v55 = (*(uint64_t (**)(HGGLNode *, uint64_t))(*(_QWORD *)this + 152))(this, 7);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v54 + 136))(v54, 7, v55);
    v56 = *(_QWORD *)(*(_QWORD *)(v72 + 16) - *(int *)(v72 + 4) + 8 * *(int *)(v72 + 4) + (int)v73);
    (*(void (**)(uint64_t))(*(_QWORD *)v56 + 24))(v56);
  }
  v57 = (HGXForm *)*((_QWORD *)this + 51);
  if (v57)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v57 + 16))(*((_QWORD *)this + 51));
    v58 = (HGXForm **)((char *)this + 416);
    v59 = (HGXForm *)*((_QWORD *)this + 52);
    if (v59 == v57)
    {
      (*(void (**)(HGXForm *))(*(_QWORD *)v57 + 24))(v57);
      goto LABEL_75;
    }
LABEL_72:
    if (v59)
      (*(void (**)(HGXForm *))(*(_QWORD *)v59 + 24))(v59);
    *v58 = v57;
  }
  else
  {
    v58 = (HGXForm **)((char *)this + 416);
    v59 = (HGXForm *)*((_QWORD *)this + 52);
    if (v59)
      goto LABEL_72;
  }
LABEL_75:
  SuperSampleScale = HGRasterizer::getSuperSampleScale(*((_QWORD *)this + 51));
  if (SuperSampleScale > 1.0)
  {
    MatrixMode = HGRasterizer::getMatrixMode(*((HGRasterizer **)this + 51));
    HGRasterizer::matrixMode(*((_QWORD *)this + 51), 5888);
    HGRasterizer::scalef(*((_QWORD *)this + 51), SuperSampleScale, SuperSampleScale, SuperSampleScale);
    HGRasterizer::matrixMode(*((_QWORD *)this + 51), MatrixMode);
    HGTransform::HGTransform((HGTransform *)v71);
    HGTransform::Scale((HGTransform *)v71, (float)(1.0 / SuperSampleScale), (float)(1.0 / SuperSampleScale), 1.0);
    v62 = (HGXForm *)HGObject::operator new(0x210uLL);
    HGXForm::HGXForm(v62);
    (*(void (**)(HGXForm *, _QWORD, HGXForm *))(*(_QWORD *)v62 + 120))(v62, 0, *v58);
    (*(void (**)(HGXForm *, uint64_t *))(*(_QWORD *)v62 + 576))(v62, v71);
    v63 = *v58;
    if (*v58 != v62)
    {
      if (v63)
        (*(void (**)(HGXForm *))(*(_QWORD *)v63 + 24))(v63);
      *v58 = v62;
      (*(void (**)(HGXForm *))(*(_QWORD *)v62 + 16))(v62);
    }
    (*(void (**)(HGXForm *))(*(_QWORD *)v62 + 24))(v62);
    HGTransform::~HGTransform((HGTransform *)v71);
  }
  if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2))
  {
    NPolys = HGRasterizer::GetNPolys(*((_QWORD **)this + 51));
    if ((*(int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 5) < 4 || NPolys >= 0x3A99)
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 51) + 136))(*((_QWORD *)this + 51), 0xFFFFFFFFLL, 128);
  }
  v65 = *v58;
  v66 = v72;
  if (v72)
  {
    do
    {
      v67 = __ldaxr((unsigned int *)v66);
      v68 = v67 - 1;
    }
    while (__stlxr(v68, (unsigned int *)v66));
    if (!v68)
    {
      v69 = *(_QWORD *)(v66 + 16);
      if (v69)
        MEMORY[0x1B5E2914C](v69, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v66, 0x1080C4098BBCF0FLL);
    }
  }
  return v65;
}

void sub_1B29CCE98(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void sub_1B29CCF94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGTransform::~HGTransform((HGTransform *)va);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v3 - 120));
  _Unwind_Resume(a1);
}

void sub_1B29CCFCC(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  HGObject::operator delete(v1);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v2 - 120));
  _Unwind_Resume(a1);
}

void sub_1B29CCFFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t HGGLNode::hglMatrixMode(HGGLNode *this, int a2)
{
  return HGRasterizer::matrixMode(*((_QWORD *)this + 51), a2);
}

const char *HGGLNode::hglBegin(const char **this, int a2)
{
  return HGRasterizer::begin(this[51], a2);
}

const char *HGGLNode::hglEnd(HGRasterizer **this)
{
  return HGRasterizer::end(this[51]);
}

double HGGLNode::hglColor4f(HGGLNode *this, __n128 a2, float a3, float a4, float a5)
{
  double result;

  *(_QWORD *)&result = HGRasterizer::color4f((__n128 *)*((_QWORD *)this + 51), a2, a3, a4, a5).n128_u64[0];
  return result;
}

uint64_t HGGLNode::hglActiveTexture(HGGLNode *this, char a2)
{
  return HGRasterizer::activeTexture(*((_QWORD *)this + 51), a2);
}

uint64_t HGGLNode::hglLoadTransform(HGGLNode *this, const HGTransform *a2)
{
  return HGRasterizer::loadTransform(*((_QWORD *)this + 51));
}

uint64_t HGGLNode::hglTranslatef(HGGLNode *this, float a2, float a3, float a4)
{
  return HGRasterizer::translatef(*((_QWORD *)this + 51), a2, a3, a4);
}

uint64_t HGGLNode::hglTexCoord2f(__n128 **this, __n128 a2, float a3)
{
  return HGRasterizer::texCoord2f(this[51], a2, a3);
}

float32x4_t *HGGLNode::hglVertex2f(float32x4_t **this, float a2, float a3)
{
  return HGRasterizer::vertex4f(this[51], a2, a3, 0.0, 1.0);
}

float32x4_t *HGGLNode::hglVertex3f(float32x4_t **this, float a2, float a3, float a4)
{
  return HGRasterizer::vertex4f(this[51], a2, a3, a4, 1.0);
}

_QWORD *HGGLNode::hglVertexArray(HGGLNode *this, const HGArrayDataRef *a2, char *a3)
{
  return HGRasterizer::vertexArray(*((_QWORD **)this + 51), a2, a3);
}

HGArrayDataRef *HGGLNode::hglTexCoordArray(HGArrayDataRef **this, const HGArrayDataRef *a2)
{
  return HGRasterizer::texCoordArray(this[51], a2);
}

const char *HGGLNode::hglTexParameteri(const char **this, const char *a2, char *a3, float a4)
{
  float v5;

  v5 = a4;
  return HGRasterizer::texParameterfv(this[51], a2, a3, &v5);
}

uint64_t HGGLNode::hglEnableTexCoordGen(HGGLNode *this, int a2)
{
  return HGRasterizer::enableTexCoordGen(*((_QWORD *)this + 51), a2);
}

const char *HGGLNode::hglEnableClientState(const char **this, int a2)
{
  return HGRasterizer::enableClientState(this[51], a2, 1);
}

uint64_t HGGLNode::hglDrawArrays(HGGLNode *this, int a2, int a3, unsigned int a4)
{
  return HGRasterizer::drawArrays(*((_QWORD *)this + 51), a2, a3, a4);
}

uint64_t HGGLNode::hglDrawElements(HGGLNode *this, int a2, unsigned int **a3)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;

  v3 = *((_QWORD *)this + 51);
  v11 = 0;
  v12 = 0x300000000;
  v4 = *a3;
  if (*a3)
  {
    v11 = *a3;
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  LODWORD(v12) = *((_DWORD *)a3 + 2);
  result = HGRasterizer::drawElements(v3, a2, (uint64_t *)&v11);
  v7 = (uint64_t)v11;
  if (v11)
  {
    do
    {
      v8 = __ldaxr((unsigned int *)v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, (unsigned int *)v7));
    if (!v9)
    {
      v10 = *(_QWORD *)(v7 + 16);
      if (v10)
        MEMORY[0x1B5E2914C](v10, 0x1000C8077774924);
      return MEMORY[0x1B5E29170](v7, 0x1080C4098BBCF0FLL);
    }
  }
  return result;
}

void sub_1B29CD16C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(&a9);
  _Unwind_Resume(a1);
}

const char *HGGLNode::hglDisableClientState(const char **this, int a2)
{
  return HGRasterizer::enableClientState(this[51], a2, 0);
}

uint64_t HGGLNode::hglClearToBlack(HGGLNode *this)
{
  return HGRasterizer::clearToBlack(*((_QWORD *)this + 51));
}

uint64_t HGGLNode::hglEnableBlending(uint64_t a1, int a2, int a3)
{
  return HGRasterizer::enableBlending(*(_QWORD *)(a1 + 408), a2, a3);
}

uint64_t HGGLNode::GetOutput(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  v7 = result;
  do
  {
    v8 = __ldaxr((unsigned int *)result);
    v9 = v8 - 1;
  }
  while (__stlxr(v9, (unsigned int *)result));
  if (!v9)
  {
    v10 = *(_QWORD *)(result + 16);
    if (v10)
      MEMORY[0x1B5E2914C](v10, 0x1000C8077774924);
    result = MEMORY[0x1B5E29170](v7, 0x1080C4098BBCF0FLL);
  }
  *(_QWORD *)a4 = a2;
  *(_DWORD *)(a4 + 8) = a3;
  return result;
}

void HGRasterizer::HGRasterizer(HGRasterizer *this, unint64_t a2)
{
  uint64_t v4;
  HGObject *v5;
  HGeometryData *v6;
  HGeometryData *v7;
  uint64_t v8;
  HGTransform *v9;
  uint64_t v10;
  HGTransform *v11;
  uint64_t v12;
  HGTransform *v13;
  uint64_t v14;
  HGTransform *v15;
  uint64_t v16;
  HGTransform *v17;
  uint64_t v18;
  HGTransform *v19;
  uint64_t v20;
  HGTransform *v21;
  uint64_t v22;
  HGTransform *v23;
  HRasterizerGenerator *v24;
  int v25;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v4 = off_1E65145A0;
  *(_DWORD *)(v4 + 408) = 897988541;
  *(_QWORD *)(v4 + 416) = 0;
  *(_QWORD *)(v4 + 424) = 0;
  HGArrayDataRef::allocate((HGArrayDataRef *)(v4 + 416), 16, 0, 0);
  *((_QWORD *)this + 74) = 0;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 47) = 0u;
  HGTransform::HGTransform((HGRasterizer *)((char *)this + 768));
  HGTransform::HGTransform((HGRasterizer *)((char *)this + 912));
  *((_DWORD *)this + 264) = 0;
  *((_BYTE *)this + 1064) = 0;
  *((_DWORD *)this + 267) = 0;
  *((_WORD *)this + 538) = 0;
  *((_QWORD *)this + 135) = 0;
  *((_BYTE *)this + 1088) = 0;
  *((_QWORD *)this + 138) = 5888;
  *((_DWORD *)this + 278) = 0;
  *((_BYTE *)this + 1120) = 0;
  *((_WORD *)this + 570) = 1;
  *(_OWORD *)((char *)this + 1144) = 0u;
  *((_DWORD *)this + 289) = 34;
  HGArrayDataRef::allocate((HGRasterizer *)((char *)this + 1144), 4, 0, 0);
  *(_OWORD *)((char *)this + 1160) = 0u;
  *((_DWORD *)this + 293) = 34;
  HGArrayDataRef::allocate((HGRasterizer *)((char *)this + 1160), 4, 0, 0);
  *(_OWORD *)((char *)this + 1176) = 0u;
  *((_DWORD *)this + 297) = 34;
  HGArrayDataRef::allocate((HGRasterizer *)((char *)this + 1176), 4, 0, 0);
  *((_DWORD *)this + 298) = 4;
  *((_QWORD *)this + 150) = 0;
  *((_QWORD *)this + 152) = 0;
  *((_QWORD *)this + 151) = 0;
  v5 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v5);
  *(_QWORD *)v5 = off_1E6514860;
  *((_BYTE *)v5 + 12) = 0;
  *((_QWORD *)v5 + 2) = 0x400000000;
  *((_QWORD *)this + 153) = v5;
  v6 = (HGeometryData *)operator new();
  HGeometryData::HGeometryData(v6, this, a2);
  *((_QWORD *)this + 63) = v6;
  v7 = (HGeometryData *)operator new();
  HGeometryData::HGeometryData(v7, this, a2);
  *((_QWORD *)this + 62) = v7;
  v8 = operator new();
  v9 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v9);
  *(_QWORD *)v8 = v9;
  HGTransform::HGTransform((HGTransform *)(v8 + 8));
  *(_QWORD *)(v8 + 152) = 0;
  *(_OWORD *)(v8 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v8 + 176) = HGRectNull;
  *(_WORD *)(v8 + 192) = 0;
  *(_BYTE *)(v8 + 194) = 0;
  *(_QWORD *)(v8 + 204) = 0;
  *(_QWORD *)(v8 + 196) = 0;
  *((_QWORD *)this + 54) = v8;
  v10 = operator new();
  v11 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v11);
  *(_QWORD *)v10 = v11;
  HGTransform::HGTransform((HGTransform *)(v10 + 8));
  *(_QWORD *)(v10 + 152) = 0;
  *(_OWORD *)(v10 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v10 + 176) = HGRectNull;
  *(_WORD *)(v10 + 192) = 0;
  *(_BYTE *)(v10 + 194) = 0;
  *(_QWORD *)(v10 + 204) = 0;
  *(_QWORD *)(v10 + 196) = 0;
  *((_QWORD *)this + 55) = v10;
  v12 = operator new();
  v13 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v13);
  *(_QWORD *)v12 = v13;
  HGTransform::HGTransform((HGTransform *)(v12 + 8));
  *(_QWORD *)(v12 + 152) = 0;
  *(_OWORD *)(v12 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v12 + 176) = HGRectNull;
  *(_WORD *)(v12 + 192) = 0;
  *(_BYTE *)(v12 + 194) = 0;
  *(_QWORD *)(v12 + 204) = 0;
  *(_QWORD *)(v12 + 196) = 0;
  *((_QWORD *)this + 56) = v12;
  v14 = operator new();
  v15 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v15);
  *(_QWORD *)v14 = v15;
  HGTransform::HGTransform((HGTransform *)(v14 + 8));
  *(_QWORD *)(v14 + 152) = 0;
  *(_OWORD *)(v14 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v14 + 176) = HGRectNull;
  *(_WORD *)(v14 + 192) = 0;
  *(_BYTE *)(v14 + 194) = 0;
  *(_QWORD *)(v14 + 204) = 0;
  *(_QWORD *)(v14 + 196) = 0;
  *((_QWORD *)this + 57) = v14;
  v16 = operator new();
  v17 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v17);
  *(_QWORD *)v16 = v17;
  HGTransform::HGTransform((HGTransform *)(v16 + 8));
  *(_QWORD *)(v16 + 152) = 0;
  *(_OWORD *)(v16 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v16 + 176) = HGRectNull;
  *(_WORD *)(v16 + 192) = 0;
  *(_BYTE *)(v16 + 194) = 0;
  *(_QWORD *)(v16 + 204) = 0;
  *(_QWORD *)(v16 + 196) = 0;
  *((_QWORD *)this + 58) = v16;
  v18 = operator new();
  v19 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v19);
  *(_QWORD *)v18 = v19;
  HGTransform::HGTransform((HGTransform *)(v18 + 8));
  *(_QWORD *)(v18 + 152) = 0;
  *(_OWORD *)(v18 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v18 + 176) = HGRectNull;
  *(_WORD *)(v18 + 192) = 0;
  *(_BYTE *)(v18 + 194) = 0;
  *(_QWORD *)(v18 + 204) = 0;
  *(_QWORD *)(v18 + 196) = 0;
  *((_QWORD *)this + 59) = v18;
  v20 = operator new();
  v21 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v21);
  *(_QWORD *)v20 = v21;
  HGTransform::HGTransform((HGTransform *)(v20 + 8));
  *(_QWORD *)(v20 + 152) = 0;
  *(_OWORD *)(v20 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v20 + 176) = HGRectNull;
  *(_WORD *)(v20 + 192) = 0;
  *(_BYTE *)(v20 + 194) = 0;
  *(_QWORD *)(v20 + 204) = 0;
  *(_QWORD *)(v20 + 196) = 0;
  *((_QWORD *)this + 60) = v20;
  v22 = operator new();
  v23 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v23);
  *(_QWORD *)v22 = v23;
  HGTransform::HGTransform((HGTransform *)(v22 + 8));
  *(_QWORD *)(v22 + 152) = 0;
  *(_OWORD *)(v22 + 160) = xmmword_1B3050F80;
  *(_OWORD *)(v22 + 176) = HGRectNull;
  *(_WORD *)(v22 + 192) = 0;
  *(_BYTE *)(v22 + 194) = 0;
  *(_QWORD *)(v22 + 204) = 0;
  *(_QWORD *)(v22 + 196) = 0;
  *((_QWORD *)this + 61) = v22;
  v24 = (HRasterizerGenerator *)HGObject::operator new(0x1B0uLL);
  HRasterizerGenerator::HRasterizerGenerator(v24);
  *((_QWORD *)this + 94) = v24;
  v25 = *((_DWORD *)this + 4) | 0x631;
  *((_DWORD *)this + 3) = 1869263964;
  *((_DWORD *)this + 4) = v25;
  *((_DWORD *)this + 275) = 0;
  *((_DWORD *)this + 150) = 1065353216;
  __asm { FMOV            V0.4S, #1.0 }
  *((_OWORD *)this + 38) = _Q0;
  *(_OWORD *)((char *)this + 1124) = HGRectNull;
}

void sub_1B29CD750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11;
  uint64_t *v12;
  HGTransform *v13;
  HGTransform *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  void *v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  HGObject::operator delete(v18);
  v20 = *(_QWORD *)(v11 + 1224);
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
  if (*(char *)(v11 + 1223) < 0)
    operator delete(*(void **)(v11 + 1200));
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v17);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v16);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v15);
  HGTransform::~HGTransform(v14);
  HGTransform::~HGTransform(v13);
  v21 = *(_QWORD *)(v11 + 592);
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
  v22 = *(_QWORD *)(v11 + 584);
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  v23 = *(_QWORD *)(v11 + 576);
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
  v24 = *(_QWORD *)(v11 + 568);
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
  v25 = *(_QWORD *)(v11 + 560);
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
  v26 = *(_QWORD *)(v11 + 552);
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 24))(v26);
  v27 = *(_QWORD *)(v11 + 544);
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
  v28 = *(_QWORD *)(v11 + 536);
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
  v29 = *(_QWORD *)(v11 + 528);
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 24))(v29);
  v30 = *(_QWORD *)(v11 + 520);
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 24))(v30);
  v31 = *(_QWORD *)(v11 + 512);
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 24))(v31);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(v12);
  HGNode::~HGNode((HGNode *)v11);
  _Unwind_Resume(a1);
}

void HGRasterizer::~HGRasterizer(HGRasterizer *this)
{
  HGeometryData *v2;
  HGeometryData *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;

  *(_QWORD *)this = off_1E65145A0;
  v2 = (HGeometryData *)*((_QWORD *)this + 62);
  if (v2)
  {
    HGeometryData::~HGeometryData(v2);
    MEMORY[0x1B5E29170]();
  }
  v3 = (HGeometryData *)*((_QWORD *)this + 63);
  if (v3)
  {
    HGeometryData::~HGeometryData(v3);
    MEMORY[0x1B5E29170]();
  }
  v4 = (_QWORD *)*((_QWORD *)this + 54);
  if (v4)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 24))(*v4);
    v5 = v4[19];
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    HGTransform::~HGTransform((HGTransform *)(v4 + 1));
    MEMORY[0x1B5E29170](v4, 0x10A0C408B9E766ELL);
  }
  v6 = (_QWORD *)*((_QWORD *)this + 55);
  if (v6)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v6 + 24))(*v6);
    v7 = v6[19];
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    HGTransform::~HGTransform((HGTransform *)(v6 + 1));
    MEMORY[0x1B5E29170](v6, 0x10A0C408B9E766ELL);
  }
  v8 = (_QWORD *)*((_QWORD *)this + 56);
  if (v8)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v8 + 24))(*v8);
    v9 = v8[19];
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    HGTransform::~HGTransform((HGTransform *)(v8 + 1));
    MEMORY[0x1B5E29170](v8, 0x10A0C408B9E766ELL);
  }
  v10 = (_QWORD *)*((_QWORD *)this + 57);
  if (v10)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v10 + 24))(*v10);
    v11 = v10[19];
    if (v11)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
    HGTransform::~HGTransform((HGTransform *)(v10 + 1));
    MEMORY[0x1B5E29170](v10, 0x10A0C408B9E766ELL);
  }
  v12 = (_QWORD *)*((_QWORD *)this + 58);
  if (v12)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 24))(*v12);
    v13 = v12[19];
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
    HGTransform::~HGTransform((HGTransform *)(v12 + 1));
    MEMORY[0x1B5E29170](v12, 0x10A0C408B9E766ELL);
  }
  v14 = (_QWORD *)*((_QWORD *)this + 59);
  if (v14)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v14 + 24))(*v14);
    v15 = v14[19];
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
    HGTransform::~HGTransform((HGTransform *)(v14 + 1));
    MEMORY[0x1B5E29170](v14, 0x10A0C408B9E766ELL);
  }
  v16 = (_QWORD *)*((_QWORD *)this + 60);
  if (v16)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v16 + 24))(*v16);
    v17 = v16[19];
    if (v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
    HGTransform::~HGTransform((HGTransform *)(v16 + 1));
    MEMORY[0x1B5E29170](v16, 0x10A0C408B9E766ELL);
  }
  v18 = (_QWORD *)*((_QWORD *)this + 61);
  if (v18)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)*v18 + 24))(*v18);
    v19 = v18[19];
    if (v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
    HGTransform::~HGTransform((HGTransform *)(v18 + 1));
    MEMORY[0x1B5E29170](v18, 0x10A0C408B9E766ELL);
  }
  v20 = *((_QWORD *)this + 94);
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
  v21 = *((_QWORD *)this + 95);
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
  v22 = *((_QWORD *)this + 153);
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  if (*((char *)this + 1223) < 0)
    operator delete(*((void **)this + 150));
  v23 = *((_QWORD *)this + 147);
  if (v23)
  {
    do
    {
      v24 = __ldaxr((unsigned int *)v23);
      v25 = v24 - 1;
    }
    while (__stlxr(v25, (unsigned int *)v23));
    if (!v25)
    {
      v26 = *(_QWORD *)(v23 + 16);
      if (v26)
        MEMORY[0x1B5E2914C](v26, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v23, 0x1080C4098BBCF0FLL);
    }
  }
  v27 = *((_QWORD *)this + 145);
  if (v27)
  {
    do
    {
      v28 = __ldaxr((unsigned int *)v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, (unsigned int *)v27));
    if (!v29)
    {
      v30 = *(_QWORD *)(v27 + 16);
      if (v30)
        MEMORY[0x1B5E2914C](v30, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v27, 0x1080C4098BBCF0FLL);
    }
  }
  v31 = *((_QWORD *)this + 143);
  if (v31)
  {
    do
    {
      v32 = __ldaxr((unsigned int *)v31);
      v33 = v32 - 1;
    }
    while (__stlxr(v33, (unsigned int *)v31));
    if (!v33)
    {
      v34 = *(_QWORD *)(v31 + 16);
      if (v34)
        MEMORY[0x1B5E2914C](v34, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v31, 0x1080C4098BBCF0FLL);
    }
  }
  HGTransform::~HGTransform((HGRasterizer *)((char *)this + 912));
  HGTransform::~HGTransform((HGRasterizer *)((char *)this + 768));
  v35 = *((_QWORD *)this + 74);
  if (v35)
    (*(void (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
  v36 = *((_QWORD *)this + 73);
  if (v36)
    (*(void (**)(uint64_t))(*(_QWORD *)v36 + 24))(v36);
  v37 = *((_QWORD *)this + 72);
  if (v37)
    (*(void (**)(uint64_t))(*(_QWORD *)v37 + 24))(v37);
  v38 = *((_QWORD *)this + 71);
  if (v38)
    (*(void (**)(uint64_t))(*(_QWORD *)v38 + 24))(v38);
  v39 = *((_QWORD *)this + 70);
  if (v39)
    (*(void (**)(uint64_t))(*(_QWORD *)v39 + 24))(v39);
  v40 = *((_QWORD *)this + 69);
  if (v40)
    (*(void (**)(uint64_t))(*(_QWORD *)v40 + 24))(v40);
  v41 = *((_QWORD *)this + 68);
  if (v41)
    (*(void (**)(uint64_t))(*(_QWORD *)v41 + 24))(v41);
  v42 = *((_QWORD *)this + 67);
  if (v42)
    (*(void (**)(uint64_t))(*(_QWORD *)v42 + 24))(v42);
  v43 = *((_QWORD *)this + 66);
  if (v43)
    (*(void (**)(uint64_t))(*(_QWORD *)v43 + 24))(v43);
  v44 = *((_QWORD *)this + 65);
  if (v44)
    (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  v45 = *((_QWORD *)this + 64);
  if (v45)
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 24))(v45);
  v46 = *((_QWORD *)this + 52);
  if (v46)
  {
    do
    {
      v47 = __ldaxr((unsigned int *)v46);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, (unsigned int *)v46));
    if (!v48)
    {
      v49 = *(_QWORD *)(v46 + 16);
      if (v49)
        MEMORY[0x1B5E2914C](v49, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v46, 0x1080C4098BBCF0FLL);
    }
  }
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;

  HGRasterizer::~HGRasterizer(this);
  HGObject::operator delete(v1);
}

uint64_t HGRasterizer::getActiveShaderNode(HGRasterizer *this)
{
  if (*((_BYTE *)this + 1077) && *((_QWORD *)this + 95))
    return *((_QWORD *)this + 95);
  else
    return *((_QWORD *)this + 94);
}

uint64_t HGRasterizer::enableXFormConcatenation(uint64_t result, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)(result + 1108) |= 0x80u;
  if (!*(_BYTE *)(result + 1141))
  {
    v3 = result;
    result = *(_QWORD *)(result + 760);
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    if (a2)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    *(_QWORD *)(v3 + 760) = a2;
  }
  return result;
}

uint64_t HGRasterizer::RenderInputOrder(HGRasterizer *this, unsigned int a2)
{
  unsigned int v2;

  if (a2 == 1)
    v2 = 0;
  else
    v2 = a2;
  if (a2)
    return v2;
  else
    return 1;
}

uint64_t HGRasterizer::GetProgram(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 1077) && (v2 = *(_QWORD *)(a1 + 760)) != 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 184))(v2);
  else
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 752) + 184))(*(_QWORD *)(a1 + 752));
}

uint64_t HGRasterizer::InitProgramDescriptor(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 1077) && (v2 = *(_QWORD *)(a1 + 760)) != 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 328))(v2);
  else
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 752) + 328))(*(_QWORD *)(a1 + 752));
}

uint64_t HGRasterizer::RenderTile(HGRasterizer *this, HGTile *a2)
{
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[44];

  if (((*(uint64_t (**)(HGRasterizer *, uint64_t))(*(_QWORD *)this + 152))(this, 0xFFFFFFFFLL) & 0x80) == 0)
    return (*(uint64_t (**)(HGRasterizer *, HGTile *, uint64_t))(*(_QWORD *)this + 656))(this, a2, 1);
  v5 = (unsigned int *)((char *)this + 1116);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + 1, v5));
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*((_QWORD *)a2 + 42) + 152) + 128))(*(_QWORD *)(*((_QWORD *)a2 + 42) + 152), 5);
  v8 = *((_DWORD *)a2 + 1);
  v9 = (*((_DWORD *)a2 + 3) - v8) / v7;
  v10 = v9 * v6;
  v11 = v9 * v6 + v8;
  v12 = v11 + v9;
  if (v6 == v7 - 1)
    v13 = *((_DWORD *)a2 + 3);
  else
    v13 = v12;
  v14 = HGRectMake4i(*(_DWORD *)a2, v11, *((_DWORD *)a2 + 2), v13);
  v16 = v15;
  memcpy(v17, a2, sizeof(v17));
  v17[0] = v14;
  v17[1] = v16;
  v17[2] += 16 * (*((_DWORD *)a2 + 6) * v10);
  return (*(uint64_t (**)(HGRasterizer *, _QWORD *, _QWORD))(*(_QWORD *)this + 656))(this, v17, 0);
}

uint64_t HGRasterizer::RenderTile(HGRasterizer *this, HGTile *a2, int a3)
{
  uint64_t v6;
  HGeometryData *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t *v27;
  int v28;
  int v29;
  int v31;
  char *v32;
  size_t v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  _QWORD v38[2];
  _BYTE v39[151];
  char v40;
  _QWORD *v41;
  _QWORD v42[8];
  _BYTE v43[64];
  _BYTE v44[64];
  _BYTE v45[64];
  _BYTE v46[64];
  _BYTE v47[64];
  _BYTE v48[64];
  _BYTE v49[64];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v6 = HGTile::Renderer(a2);
  v7 = (HGeometryData *)operator new();
  HGeometryData::HGeometryData(v7, this, 0);
  HGTransform::HGTransform((HGTransform *)v39);
  v8 = *(_QWORD *)a2;
  v9 = *((_QWORD *)a2 + 1);
  v10 = *((_QWORD *)this + 63);
  v11 = (unsigned int *)*((_QWORD *)this + 52);
  v38[0] = v11;
  if (v11)
  {
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
  }
  v38[1] = *((_QWORD *)this + 53);
  HGeometryData::ClipPolygons(v7, v8, v9, v10, (uint64_t)this + 768, (uint64_t)v38, 0xFFFFFFFF);
  v13 = v38[0];
  if (v38[0])
  {
    do
    {
      v14 = __ldaxr((unsigned int *)v13);
      v15 = v14 - 1;
    }
    while (__stlxr(v15, (unsigned int *)v13));
    if (!v15)
    {
      v16 = *(_QWORD *)(v13 + 16);
      if (v16)
        MEMORY[0x1B5E2914C](v16, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v13, 0x1080C4098BBCF0FLL);
    }
  }
  v17 = 0;
  v18 = 0;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  do
  {
    if (((*((_DWORD *)this + 264) >> v18) & 1) != 0)
    {
      if (a3)
        HGExecutionUnit::CommitStack(*((_QWORD *)a2 + 42), *(_QWORD *)((char *)a2 + v17 + 16), *(int *)((char *)a2 + v17 + 24) * (*((int *)a2 + 3) - (uint64_t)*((int *)a2 + 1)));
      if (((*(uint64_t (**)(HGRasterizer *, uint64_t))(*(_QWORD *)this + 152))(this, v18) & 4) != 0)
      {
        if (v18 < *((int *)this + 22))
        {
          v24 = *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v18);
          if (v24)
          {
            v25 = *(_QWORD *)(v24 + 48);
            if (v25)
              *(_OWORD *)((char *)a2 + v17 + 208) = *(_OWORD *)(v25 + 20);
          }
        }
      }
      else
      {
        v21 = (*(uint64_t (**)(HGRasterizer *, uint64_t, uint64_t, _QWORD, _QWORD, HGeometryData *, uint64_t, uint64_t))(*(_QWORD *)this + 624))(this, v6, v18, *(_QWORD *)a2, *((_QWORD *)a2 + 1), v7, 0xFFFFFFFFLL, 0xFFFFFFFFLL);
        v22 = (char *)a2 + v17;
        *((_QWORD *)v22 + 26) = v21;
        *((_QWORD *)v22 + 27) = v23;
      }
      v26 = (char *)a2 + v17;
      if (!HGRectIsNull(*(_QWORD *)((char *)a2 + v17 + 208), *(_QWORD *)((char *)a2 + v17 + 216)))
      {
        v27 = (uint64_t *)((char *)a2 + v17 + 80);
        HGRenderer::RenderInput(v6, *((_QWORD *)a2 + 42), (uint64_t)this, v18, (uint64_t)v27, *((_QWORD *)v26 + 26), *((_QWORD *)v26 + 27), 0);
        v19 = *(_DWORD *)a2
            - *((_DWORD *)v26 + 52)
            + (*((_DWORD *)a2 + 1) - *(_DWORD *)((char *)a2 + v17 + 212)) * *(_DWORD *)((char *)a2 + v17 + 88);
        v20 = *v27;
        *((_QWORD *)&v50 + v18) = *v27;
        *v27 = v20 + 16 * v19;
      }
    }
    ++v18;
    v17 += 16;
  }
  while (v17 != 128);
  if ((*((_BYTE *)this + 1108) & 1) != 0)
  {
    v28 = *((_DWORD *)a2 + 2);
    v29 = *(_DWORD *)a2;
    if (*((_DWORD *)a2 + 3) > *((_DWORD *)a2 + 1) && v28 > v29)
    {
      v31 = 0;
      v32 = (char *)*((_QWORD *)a2 + 2);
      v33 = 16 * (v28 + ~v29) + 16;
      v34 = 16 * *((int *)a2 + 6);
      do
      {
        bzero(v32, v33);
        ++v31;
        v32 += v34;
      }
      while (v31 < *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1));
    }
  }
  v35 = atomic_load(HGRasterizer::getIsROIDebug(void)::envCheck);
  if (v35 != -1)
  {
    v42[0] = &v40;
    v41 = v42;
    std::__call_once(HGRasterizer::getIsROIDebug(void)::envCheck, &v41, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGRasterizer::getIsROIDebug(void)::$_0 &&>>);
  }
  if (HGRasterizer::_isROIDebug)
  {
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v42, *(HGRect *)a2, *((HGRect *)a2 + 13), (const HGNode *)this, 0);
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v43, *(HGRect *)a2, *((HGRect *)a2 + 14), (const HGNode *)this, 1);
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v44, *(HGRect *)a2, *((HGRect *)a2 + 15), (const HGNode *)this, 2);
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v45, *(HGRect *)a2, *((HGRect *)a2 + 16), (const HGNode *)this, 3);
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v46, *(HGRect *)a2, *((HGRect *)a2 + 17), (const HGNode *)this, 4);
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v47, *(HGRect *)a2, *((HGRect *)a2 + 18), (const HGNode *)this, 5);
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v48, *(HGRect *)a2, *((HGRect *)a2 + 19), (const HGNode *)this, 6);
    HGSampleRectStat::HGSampleRectStat((HGSampleRectStat *)v49, *(HGRect *)a2, *((HGRect *)a2 + 20), (const HGNode *)this, 7);
    HGeometryData::RenderPolygons(v7, (int32x2_t *)a2, (HGSampleRectStat *)v42);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v49);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v48);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v47);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v46);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v45);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v44);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v43);
    HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)v42);
  }
  else
  {
    HGeometryData::RenderPolygons(v7, (int32x2_t *)a2, 0);
  }
  v36 = *((_DWORD *)this + 264);
  if ((v36 & 1) != 0)
  {
    *((_QWORD *)a2 + 10) = v50;
    if ((v36 & 2) == 0)
    {
LABEL_36:
      if ((v36 & 4) == 0)
        goto LABEL_37;
      goto LABEL_46;
    }
  }
  else if ((v36 & 2) == 0)
  {
    goto LABEL_36;
  }
  *((_QWORD *)a2 + 12) = *((_QWORD *)&v50 + 1);
  if ((v36 & 4) == 0)
  {
LABEL_37:
    if ((v36 & 8) == 0)
      goto LABEL_38;
    goto LABEL_47;
  }
LABEL_46:
  *((_QWORD *)a2 + 14) = v51;
  if ((v36 & 8) == 0)
  {
LABEL_38:
    if ((v36 & 0x10) == 0)
      goto LABEL_39;
    goto LABEL_48;
  }
LABEL_47:
  *((_QWORD *)a2 + 16) = *((_QWORD *)&v51 + 1);
  if ((v36 & 0x10) == 0)
  {
LABEL_39:
    if ((v36 & 0x20) == 0)
      goto LABEL_40;
    goto LABEL_49;
  }
LABEL_48:
  *((_QWORD *)a2 + 18) = v52;
  if ((v36 & 0x20) == 0)
  {
LABEL_40:
    if ((v36 & 0x40) == 0)
      goto LABEL_41;
LABEL_50:
    *((_QWORD *)a2 + 22) = v53;
    if ((v36 & 0x80) == 0)
      goto LABEL_43;
    goto LABEL_42;
  }
LABEL_49:
  *((_QWORD *)a2 + 20) = *((_QWORD *)&v52 + 1);
  if ((v36 & 0x40) != 0)
    goto LABEL_50;
LABEL_41:
  if ((v36 & 0x80) != 0)
LABEL_42:
    *((_QWORD *)a2 + 24) = *((_QWORD *)&v53 + 1);
LABEL_43:
  HGeometryData::~HGeometryData(v7);
  MEMORY[0x1B5E29170]();
  HGTransform::~HGTransform((HGTransform *)v39);
  return 0;
}

void sub_1B29CE6D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, HGSampleRectStat *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  HGSampleRectStat *v33;
  HGSampleRectStat *v34;
  HGSampleRectStat *v35;
  HGSampleRectStat *v36;
  HGSampleRectStat *v37;
  HGSampleRectStat *v38;

  HGSampleRectStat::~HGSampleRectStat(v37);
  HGSampleRectStat::~HGSampleRectStat(v38);
  HGSampleRectStat::~HGSampleRectStat(v36);
  HGSampleRectStat::~HGSampleRectStat(v35);
  HGSampleRectStat::~HGSampleRectStat(v34);
  HGSampleRectStat::~HGSampleRectStat(v33);
  HGSampleRectStat::~HGSampleRectStat(a10);
  HGSampleRectStat::~HGSampleRectStat((HGSampleRectStat *)&a33);
  HGTransform::~HGTransform((HGTransform *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B29CE724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTransform::~HGTransform((HGTransform *)va);
  _Unwind_Resume(a1);
}

const char *HGRasterizer::begin(const char *this, int a2)
{
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  char *v6;
  char __str[256];
  uint64_t v8;

  v2 = this;
  v8 = *MEMORY[0x1E0C80C00];
  if (this[1140])
  {
    *((_BYTE *)this + 1140) = 0;
    *((_DWORD *)this + 274) = a2;
    *((_DWORD *)this + 298) = a2;
  }
  else
  {
    v3 = *((_QWORD *)this + 62);
    *(_BYTE *)(v3 + 240) = 1;
    v4 = *(_QWORD *)(v3 + 80);
    if (v4)
      LODWORD(v4) = *(_DWORD *)(v4 + 8);
    HGRasterizer::drawArrays((uint64_t)this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), v4 - *((_DWORD *)this + 278));
    *((_BYTE *)v2 + 1140) = 1;
    snprintf(__str, 0x100uLL, "%s: invalid call between hglBegin/hglEnd", "hglBegin");
    *((_DWORD *)v2 + 275) = 1282;
    return HGLogger::warning((HGLogger *)"%s", v5, v6, __str);
  }
  return this;
}

const char *HGRasterizer::end(HGRasterizer *this)
{
  const char *v2;
  char *v3;
  const char *result;
  uint64_t v5;
  uint64_t v6;
  char __str[256];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 1140))
  {
    snprintf(__str, 0x100uLL, "%s: invalid call outside hglBegin/hglEnd", "hglEnd");
    *((_DWORD *)this + 275) = 1282;
    return HGLogger::warning((HGLogger *)"%s", v2, v3, __str);
  }
  else
  {
    v5 = *((_QWORD *)this + 62);
    *(_BYTE *)(v5 + 240) = 1;
    v6 = *(_QWORD *)(v5 + 80);
    if (v6)
      LODWORD(v6) = *(_DWORD *)(v6 + 8);
    result = (const char *)HGRasterizer::drawArrays((uint64_t)this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), (int)v6 - *((_DWORD *)this + 278));
    *((_BYTE *)this + 1140) = 1;
  }
  return result;
}

uint64_t HGRasterizer::drawArrays(uint64_t this, int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  HGArrayDataRef *v13;
  uint64_t v14;
  uint64_t v15;
  signed int v16;
  signed int v17;
  int v18;
  int v19;
  int v20;
  void *v21;
  const void *v22;
  int v23;
  void *v24;
  uint64_t v25;
  unsigned int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int i;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  uint64_t v76;
  __int16 v77;
  unsigned int v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  __int128 v90;

  v4 = a4 - 2;
  if ((int)a4 < 2)
    return this;
  v8 = this;
  v9 = *(_QWORD *)(this + 496);
  v10 = *(_QWORD *)(v9 + 16);
  if (v10)
  {
    v11 = *(_DWORD *)(v10 + 8);
    v12 = *(_DWORD *)(v9 + 244);
    if (!*(_BYTE *)(v9 + 240))
      goto LABEL_7;
  }
  else
  {
    v11 = 0;
    v12 = *(_DWORD *)(v9 + 244);
    if (!*(_BYTE *)(v9 + 240))
    {
LABEL_7:
      v15 = *(_QWORD *)(v9 + 64);
      v13 = (HGArrayDataRef *)(v9 + 64);
      v14 = v15;
      if (v15)
      {
        v16 = *(_DWORD *)(v14 + 12);
        v17 = *(_DWORD *)(v14 + 8) + a4;
        if (v16 < v17)
        {
          v18 = *(_DWORD *)(v14 + 4);
          v19 = v18 * v17;
          *(_DWORD *)(v14 + 12) = v17;
          if (v18 * v17)
          {
            v20 = v18 * v16;
            v21 = (void *)operator new[]();
            if (v20 && (v22 = *(const void **)(v14 + 16)) != 0)
            {
              if (v20 >= v19)
                v23 = v19;
              else
                v23 = v20;
              v24 = v21;
              memcpy(v21, v22, v23);
            }
            else
            {
              v24 = v21;
            }
          }
          else
          {
            v24 = 0;
          }
          v25 = *(_QWORD *)(v14 + 16);
          if (v25)
            MEMORY[0x1B5E2914C](v25, 0x1000C8077774924);
          *(_QWORD *)(v14 + 16) = v24;
        }
      }
      else
      {
        HGArrayDataRef::allocate(v13, 16, a4, a4);
      }
      __asm { FMOV            V0.4S, #1.0 }
      v90 = _Q0;
      v31 = a4;
      do
      {
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*(_QWORD *)(v8 + 496) + 64)) = v90;
        --v31;
      }
      while (v31);
    }
  }
  if (a2 == 1)
    return HGRasterizer::drawLines(v8, a3, a4);
  *(_DWORD *)(v8 + 1112) += a4;
  v32 = a2 - 4;
  switch(a2)
  {
    case 4:
      v4 = a4 / 3;
      v33 = 3 * (a4 / 3);
      v34 = *(_QWORD *)(v8 + 496);
      if (*(_DWORD *)(v34 + 244))
        goto LABEL_34;
      goto LABEL_37;
    case 5:
    case 6:
      v33 = 3 * v4;
      v34 = *(_QWORD *)(v8 + 496);
      if (!*(_DWORD *)(v34 + 244))
        goto LABEL_37;
      goto LABEL_34;
    case 7:
      v4 = (a4 >> 1) & 0x7FFFFFFE;
      v33 = 3 * v4;
      v34 = *(_QWORD *)(v8 + 496);
      if (*(_DWORD *)(v34 + 244))
        goto LABEL_34;
      goto LABEL_37;
    default:
      puts("Unknown polygon mode in drawArrays");
      v33 = 0;
      v4 = 0;
      v34 = *(_QWORD *)(v8 + 496);
      if (!*(_DWORD *)(v34 + 244))
        goto LABEL_37;
LABEL_34:
      if (*(_DWORD *)(v8 + 1092) == 4)
      {
        v35 = *(_QWORD *)(*(_QWORD *)(v8 + 1144) + 16)
            + *(int *)(*(_QWORD *)(v8 + 1144) + 4) * (*(int *)(*(_QWORD *)(v8 + 1144) + 8) - 1);
        *(_DWORD *)(v35 + *(int *)(v8 + 1152)) += v33;
        this = HGeometryData::SizeIndexArrays(v34, v4, v33);
        if (v32 > 3)
          return puts("Unknown polygon mode in drawArrays");
      }
      else
      {
LABEL_37:
        *(_DWORD *)(v8 + 1092) = 4;
        *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(v8 + 1144)) = v33;
        *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(v8 + 1160)) = 4;
        v36 = *(_DWORD *)(*(_QWORD *)(v8 + 496) + 244);
        *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(v8 + 1176)) = v36;
        this = HGeometryData::SizeIndexArrays(*(_QWORD *)(v8 + 496), v4, v33);
      }
      switch(v32)
      {
        case 0u:
          if (v4)
          {
            v37 = *(uint64_t **)(v8 + 496);
            v38 = v37[2];
            v39 = *(_QWORD *)(v38 + 16);
            v40 = *v37;
            v41 = *(_QWORD *)(*v37 + 16);
            v42 = v37[6];
            v43 = *(_QWORD *)(v42 + 16);
            do
            {
              v44 = *(_DWORD *)(v38 + 4);
              v45 = *((int *)v37 + 6);
              *(_WORD *)(v39 + v44 * v11 + v45) = a3;
              *(_WORD *)(v39 + v44 + v44 * v11 + v45) = a3 + 1;
              this = (v11 + 2);
              *(_WORD *)(v39 + v44 * (int)this + v45) = a3 + 2;
              *(_DWORD *)(v41 + *(int *)(v40 + 4) * (uint64_t)v12 + *((int *)v37 + 2)) = v11;
              *(_DWORD *)(v43 + *(int *)(v42 + 4) * (uint64_t)v12 + *((int *)v37 + 14)) = 3;
              a3 += 3;
              v11 += 3;
              ++v12;
              --v4;
            }
            while (v4);
          }
          break;
        case 1u:
          if (v4)
          {
            v46 = 0;
            v47 = *(uint64_t **)(v8 + 496);
            v48 = v47[2];
            v49 = *(_QWORD *)(v48 + 16);
            v50 = *v47;
            v51 = *(_QWORD *)(*v47 + 16);
            v52 = v47[6];
            v53 = *(_QWORD *)(v52 + 16);
            do
            {
              v54 = *(_DWORD *)(v48 + 4);
              v55 = *((int *)v47 + 6);
              *(_WORD *)(v49 + v54 * v11 + v55) = a3 + v46;
              *(_WORD *)(v49 + v54 + v54 * v11 + v55) = a3 + v46 + 1;
              *(_WORD *)(v49 + v54 * (v11 + 2) + v55) = a3 + v46 + 2;
              *(_DWORD *)(v51 + *(int *)(v50 + 4) * (uint64_t)(int)(v12 + v46) + *((int *)v47 + 2)) = v11;
              this = *((int *)v47 + 14);
              *(_DWORD *)(v53 + *(int *)(v52 + 4) * (uint64_t)(int)(v12 + v46) + this) = 3;
              v11 += 3;
              v46 += 2;
            }
            while (v46 < v4);
            if (v4 >= 2)
            {
              v56 = *(uint64_t **)(v8 + 496);
              v57 = v56[2];
              v58 = *(_QWORD *)(v57 + 16);
              v59 = *v56;
              v60 = *(_QWORD *)(*v56 + 16);
              v61 = v56[6];
              v62 = *(_QWORD *)(v61 + 16);
              for (i = 1; i < v4; i += 2)
              {
                v64 = *(_DWORD *)(v57 + 4);
                v65 = v64 * v11;
                v66 = *((int *)v56 + 6);
                *(_WORD *)(v58 + v65 + v66) = a3 + i + 1;
                *(_WORD *)(v58 + v64 + v65 + v66) = a3 + i;
                *(_WORD *)(v58 + v64 * (v11 + 2) + v66) = a3 + i + 2;
                *(_DWORD *)(v60 + *(int *)(v59 + 4) * (uint64_t)(int)(v12 + i) + *((int *)v56 + 2)) = v11;
                this = *((int *)v56 + 14);
                *(_DWORD *)(v62 + *(int *)(v61 + 4) * (uint64_t)(int)(v12 + i) + this) = 3;
                v11 += 3;
              }
            }
          }
          break;
        case 2u:
          if (v4)
          {
            v67 = *(uint64_t **)(v8 + 496);
            v68 = v67[2];
            v69 = *(_QWORD *)(v68 + 16);
            v70 = *v67;
            v71 = *(_QWORD *)(*v67 + 16);
            v72 = v67[6];
            v73 = *(_QWORD *)(v72 + 16);
            v74 = a3;
            do
            {
              v75 = *(_DWORD *)(v68 + 4);
              v76 = *((int *)v67 + 6);
              *(_WORD *)(v69 + v75 * v11 + v76) = a3;
              v77 = v74++ + 2;
              *(_WORD *)(v69 + v75 + v75 * v11 + v76) = v74;
              *(_WORD *)(v69 + v75 * (v11 + 2) + v76) = v77;
              *(_DWORD *)(v71 + *(int *)(v70 + 4) * (uint64_t)v12 + *((int *)v67 + 2)) = v11;
              this = *((int *)v67 + 14);
              *(_DWORD *)(v73 + *(int *)(v72 + 4) * (uint64_t)v12 + this) = 3;
              v11 += 3;
              ++v12;
              --v4;
            }
            while (v4);
          }
          break;
        case 3u:
          if (a4 >= 4)
          {
            v78 = a4 >> 2;
            v79 = *(uint64_t **)(v8 + 496);
            v80 = *v79;
            v81 = *(_QWORD *)(*v79 + 16);
            v82 = v79[6];
            v83 = *(_QWORD *)(v82 + 16);
            v84 = v79[2];
            v85 = *(_QWORD *)(v84 + 16);
            do
            {
              *(_DWORD *)(v81 + *(int *)(v80 + 4) * (uint64_t)v12 + *((int *)v79 + 2)) = v11;
              *(_DWORD *)(v83 + *(int *)(v82 + 4) * (uint64_t)v12 + *((int *)v79 + 14)) = 3;
              v86 = *(_DWORD *)(v84 + 4);
              v87 = *((int *)v79 + 6);
              *(_WORD *)(v85 + v86 * v11 + v87) = a3;
              *(_WORD *)(v85 + v86 + v86 * v11 + v87) = a3 + 1;
              *(_WORD *)(v85 + v86 * (v11 + 2) + v87) = a3 + 2;
              *(_DWORD *)(v81 + *(int *)(v80 + 4) * (uint64_t)(v12 + 1) + *((int *)v79 + 2)) = v11 + 3;
              *(_DWORD *)(v83 + *(int *)(v82 + 4) * (uint64_t)(v12 + 1) + *((int *)v79 + 14)) = 3;
              v12 += 2;
              v88 = *(_DWORD *)(v84 + 4);
              v89 = *((int *)v79 + 6);
              *(_WORD *)(v85 + v88 * (v11 + 3) + v89) = a3;
              *(_WORD *)(v85 + v88 * (v11 + 4) + v89) = a3 + 2;
              this = (a3 + 3);
              *(_WORD *)(v85 + v88 * (v11 + 5) + v89) = a3 + 3;
              a3 += 4;
              v11 += 6;
              --v78;
            }
            while (v78);
          }
          break;
        default:
          return puts("Unknown polygon mode in drawArrays");
      }
      break;
  }
  return this;
}

uint64_t HGRasterizer::activeTexture(uint64_t this, char a2)
{
  *(_BYTE *)(this + 1088) = a2 + 64;
  return this;
}

uint64_t HGRasterizer::matrixMode(uint64_t this, int a2)
{
  *(_DWORD *)(this + 1104) = a2;
  return this;
}

uint64_t HGRasterizer::getMatrixMode(HGRasterizer *this)
{
  return *((unsigned int *)this + 276);
}

uint64_t HGRasterizer::loadTransform(uint64_t result)
{
  int v1;

  v1 = *(_DWORD *)(result + 1104);
  if (v1 == 5890)
  {
    result = **(_QWORD **)(result + 8 * *(unsigned __int8 *)(result + 1088) + 432);
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 96))(result);
  }
  else if (v1 == 5888)
  {
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 768) + 96))(result + 768);
  }
  return result;
}

uint64_t HGRasterizer::translatef(uint64_t this, float a2, float a3, float a4)
{
  int v4;

  v4 = *(_DWORD *)(this + 1104);
  if (v4 == 5890)
  {
    this = **(_QWORD **)(this + 8 * *(unsigned __int8 *)(this + 1088) + 432);
    if (this)
      return (*(uint64_t (**)(uint64_t, double, double, double))(*(_QWORD *)this + 120))(this, a2, a3, a4);
  }
  else if (v4 == 5888)
  {
    return (*(uint64_t (**)(uint64_t, double, double, double))(*(_QWORD *)(this + 768) + 120))(this + 768, a2, a3, a4);
  }
  return this;
}

uint64_t HGRasterizer::scalef(uint64_t this, float a2, float a3, float a4)
{
  int v4;

  v4 = *(_DWORD *)(this + 1104);
  if (v4 == 5890)
  {
    this = **(_QWORD **)(this + 8 * *(unsigned __int8 *)(this + 1088) + 432);
    if (this)
      return (*(uint64_t (**)(uint64_t, double, double, double))(*(_QWORD *)this + 144))(this, a2, a3, a4);
  }
  else if (v4 == 5888)
  {
    return (*(uint64_t (**)(uint64_t, double, double, double))(*(_QWORD *)(this + 768) + 144))(this + 768, a2, a3, a4);
  }
  return this;
}

float HGRasterizer::getSuperSampleScale(uint64_t a1)
{
  uint64_t v1;
  float result;

  v1 = *(_QWORD *)(a1 + 1224);
  result = 1.0;
  if (*(_BYTE *)(v1 + 12))
  {
    if (*(_DWORD *)(v1 + 16) == 1)
      return (float)*(unsigned int *)(v1 + 20);
  }
  return result;
}

uint64_t HGRasterizer::enableInplaceBlending(uint64_t this)
{
  *(_DWORD *)(this + 1108) |= 0x40u;
  return this;
}

BOOL HGRasterizer::SupportsInplaceHardwareBlending(HGRasterizer *this, float a2)
{
  return (*((_DWORD *)this + 277) & 0x44) == 64;
}

const char *HGRasterizer::label_B(HGRasterizer *this)
{
  uint64_t v2;
  const std::string::value_type *v3;
  std::string *v4;
  std::string::size_type v5;
  char v6;
  void **v7;
  std::string __p;
  _QWORD v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 1077))
  {
    if (*((_QWORD *)this + 95) || *((_QWORD *)this + 94))
    {
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = 8;
      strcpy((char *)&__p, "Shader: ");
      v2 = *((_QWORD *)this + 95);
      if (v2)
        goto LABEL_9;
      goto LABEL_8;
    }
    return "No shader";
  }
  if (!*((_QWORD *)this + 94))
    return "No shader";
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = 8;
  strcpy((char *)&__p, "Shader: ");
LABEL_8:
  v2 = *((_QWORD *)this + 94);
LABEL_9:
  v3 = (const std::string::value_type *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v4 = std::string::append(&__p, v3);
  v5 = v4->__r_.__value_.__r.__words[0];
  v10[0] = v4->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v10 + 7) = *(std::string::size_type *)((char *)&v4->__r_.__value_.__r.__words[1] + 7);
  v6 = HIBYTE(v4->__r_.__value_.__r.__words[2]);
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  v7 = (void **)((char *)this + 1200);
  if (*((char *)this + 1223) < 0)
    operator delete(*v7);
  *((_QWORD *)this + 150) = v5;
  *((_QWORD *)this + 151) = v10[0];
  *(_QWORD *)((char *)this + 1215) = *(_QWORD *)((char *)v10 + 7);
  *((_BYTE *)this + 1223) = v6;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((*((_BYTE *)this + 1223) & 0x80) == 0)
      return (const char *)v7;
    return (const char *)*v7;
  }
  if (v6 < 0)
    return (const char *)*v7;
  return (const char *)v7;
}

void sub_1B29CF2F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGRasterizer::addFragmentShader(HGRasterizer *this, HGNode3D *a2)
{
  uint64_t v4;

  if (!*((_BYTE *)this + 1141))
  {
    *((_BYTE *)this + 1064) = 1;
    v4 = *((_QWORD *)this + 94);
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    if (a2)
    {
      (*(void (**)(HGNode3D *))(*(_QWORD *)a2 + 16))(a2);
    }
    else
    {
      a2 = (HGNode3D *)HGObject::operator new(0x1B0uLL);
      HRasterizerGenerator::HRasterizerGenerator(a2);
    }
    *((_QWORD *)this + 94) = a2;
  }
}

void sub_1B29CF394(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 HGRasterizer::color4f(__n128 *this, __n128 result, float a3, float a4, float a5)
{
  result.n128_f32[1] = a3;
  result.n128_u64[1] = __PAIR64__(LODWORD(a5), LODWORD(a4));
  this[38] = result;
  return result;
}

uint64_t HGRasterizer::texCoord2f(__n128 *this, __n128 a2, float a3)
{
  _QWORD *v4;
  uint64_t result;

  a2.n128_f32[1] = a3;
  a2.n128_u32[2] = 0;
  a2.n128_u32[3] = 1.0;
  this[66].n128_u32[3] |= 1u;
  this[39] = a2;
  v4 = (_QWORD *)this[27].n128_u64[0];
  result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v4 + 224))(*v4);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(_QWORD, __n128 *, __n128 *, uint64_t))(*(_QWORD *)*v4 + 208))(*v4, this + 39, this + 39, 1);
  return result;
}

uint64_t HGRasterizer::enableTexCoordGen(uint64_t this, int a2)
{
  *(_BYTE *)(*(_QWORD *)(this + 8 * (a2 - 33984) + 432) + 193) = 1;
  return this;
}

float32x4_t *HGRasterizer::addVertex(float32x4_t *this, float a2, float a3, float a4, float a5)
{
  __int128 v6;
  float32x4_t *result;
  __int32 v13;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;

  HGeometryData::AllocArrays(this[31].i64[0], this[67].i32[2] + 1, this[66].u32[3]);
  *(_QWORD *)&v6 = __PAIR64__(LODWORD(a3), LODWORD(a2));
  *((_QWORD *)&v6 + 1) = __PAIR64__(LODWORD(a5), LODWORD(a4));
  *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 80)) = v6;
  __asm { FMOV            V1.4S, #1.0 }
  v18 = vmaxq_f32(vminq_f32(this[38], _Q1), (float32x4_t)0);
  result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 64));
  *result = v18;
  v13 = this[66].i32[3];
  if ((v13 & 1) != 0)
  {
    v20 = this[39];
    result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 112));
    *result = v20;
    v13 = this[66].i32[3];
    if ((v13 & 2) == 0)
    {
LABEL_3:
      if ((v13 & 4) == 0)
        goto LABEL_4;
      goto LABEL_13;
    }
  }
  else if ((v13 & 2) == 0)
  {
    goto LABEL_3;
  }
  v21 = this[40];
  result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 128));
  *result = v21;
  v13 = this[66].i32[3];
  if ((v13 & 4) == 0)
  {
LABEL_4:
    if ((v13 & 8) == 0)
      goto LABEL_5;
    goto LABEL_14;
  }
LABEL_13:
  v22 = this[41];
  result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 144));
  *result = v22;
  v13 = this[66].i32[3];
  if ((v13 & 8) == 0)
  {
LABEL_5:
    if ((v13 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_15;
  }
LABEL_14:
  v23 = this[42];
  result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 160));
  *result = v23;
  v13 = this[66].i32[3];
  if ((v13 & 0x10) == 0)
  {
LABEL_6:
    if ((v13 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_16;
  }
LABEL_15:
  v24 = this[43];
  result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 176));
  *result = v24;
  v13 = this[66].i32[3];
  if ((v13 & 0x20) == 0)
  {
LABEL_7:
    if ((v13 & 0x40) == 0)
      goto LABEL_8;
LABEL_17:
    v26 = this[45];
    result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 208));
    *result = v26;
    if ((this[66].i32[3] & 0x80) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_16:
  v25 = this[44];
  result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 192));
  *result = v25;
  v13 = this[66].i32[3];
  if ((v13 & 0x40) != 0)
    goto LABEL_17;
LABEL_8:
  if ((v13 & 0x80) != 0)
  {
LABEL_9:
    v19 = this[46];
    result = (float32x4_t *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(this[31].i64[0] + 224));
    *result = v19;
  }
LABEL_10:
  ++this[67].i32[2];
  return result;
}

float32x4_t *HGRasterizer::vertex4f(float32x4_t *this, float a2, float a3, float a4, float a5)
{
  const char *v6;
  char *v7;
  char __str[256];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!this[71].i8[4])
    return HGRasterizer::addVertex(this, a2, a3, a4, a5);
  snprintf(__str, 0x100uLL, "%s: invalid call outside hglBegin/hglEnd", "hglVertex4f");
  this[68].i32[3] = 1282;
  return (float32x4_t *)HGLogger::warning((HGLogger *)"%s", v6, v7, __str);
}

uint64_t HGRasterizer::clearToBlack(uint64_t this)
{
  *(_DWORD *)(this + 1108) |= 1u;
  return this;
}

uint64_t HGRasterizer::forceNoClearToBlack(uint64_t this)
{
  *(_DWORD *)(this + 1108) |= 0x10u;
  return this;
}

HGNode *HGRasterizer::EnableInplaceHardwareBlending(HGNode *this)
{
  (*(void (**)(HGNode *))(*(_QWORD *)this + 584))(this);
  return HGNode::EnableInplaceHardwareBlending(this);
}

uint64_t HGRasterizer::enableBlending(uint64_t result, int a2, int a3)
{
  int v3;

  if (a3)
    v3 = 37;
  else
    v3 = 5;
  *(_DWORD *)(result + 1108) |= v3;
  *(_DWORD *)(result + 1060) = a2;
  return result;
}

uint64_t HGRasterizer::SetParameter(HGRasterizer *this, const char *a2, float a3, float a4, float a5, float a6, char *a7)
{
  float v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v20;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v10 = 0.0;
  if (a4 < 0.0)
    a4 = 0.0;
  if (a5 >= 0.0)
    v10 = a5;
  v11 = *((_QWORD *)this + 153);
  v12 = *(unsigned __int8 *)(v11 + 12);
  v13 = *(_DWORD *)(v11 + 16);
  v14 = *(_DWORD *)(v11 + 20);
  v15 = a4 != 0.0;
  LODWORD(v11) = vcvtps_s32_f32(v10);
  v16 = v11 & 0xFFFFFFFE;
  if ((v11 & 0xFFFFFFFC) != 0)
    v16 = 4;
  if (v10 == 0.0)
    v17 = 4;
  else
    v17 = v16;
  if ((_DWORD)v17 != v10)
    HGLogger::warning((HGLogger *)"Requested raster sample count for anti-aliasing was reduced from %3.2f to %d.\n", a2, a7, v10, v17);
  if ((a3 == 1.0) != (v12 == 0) && v13 == v15 && v14 == (_DWORD)v17)
    return 0;
  v20 = *((_QWORD *)this + 153);
  *(_BYTE *)(v20 + 12) = a3 == 1.0;
  *(_DWORD *)(v20 + 16) = v15;
  *(_DWORD *)(v20 + 20) = v17;
  return 1;
}

float HGRasterizer::GetParameter(HGRasterizer *this, int a2, float *a3, float result)
{
  uint64_t v4;
  float v5;
  float v6;

  if (!a2)
  {
    v4 = *((_QWORD *)this + 153);
    v5 = 0.0;
    if (*(_BYTE *)(v4 + 12))
      v6 = 1.0;
    else
      v6 = 0.0;
    if (*(_DWORD *)(v4 + 16))
      v5 = 1.0;
    *a3 = v6;
    a3[1] = v5;
    result = (float)*(unsigned int *)(v4 + 20);
    a3[2] = result;
    a3[3] = 0.0;
  }
  return result;
}

uint64_t HGRasterizer::SetActiveShaderNodeParameter(HGRasterizer *this, uint64_t a2, float a3, float a4, float a5, float a6)
{
  uint64_t v12;

  v12 = *((_QWORD *)this + 95);
  if (v12)
    (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(_QWORD *)v12 + 96))(v12, a2, a3, a4, a5, a6);
  return (*(uint64_t (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 94) + 96))(*((_QWORD *)this + 94), a2, a3, a4, a5, a6);
}

uint64_t HGRasterizer::GetROI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;

  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 304))(a2) & 1) == 0
    && (*(_BYTE *)(a1 + 1109) & 4) != 0
    && (v10 = *(_QWORD *)(a1 + 752)) != 0)
  {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 400))(v10, a2, a3, a4, a5);
  }
  else
  {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 632))(a1, 0xFFFFFFFFLL, a2, a3, a4, a5);
  }
}

unint64_t HGRasterizer::GetROI(HGRasterizer *this, uint64_t a2, HGRenderer *a3, uint64_t a4, HGRect a5)
{
  unint64_t v5;
  unint64_t v6;
  HGNode *Input;
  char *v12;
  uint64_t DOD;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t (*v17)(void);
  HGeometryData *v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v27;
  HGeometryData *v28;
  unsigned int v29;
  unint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  HGeometryData *v39;
  uint64_t v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  HGeometryData *v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int *v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  HGeometryData *v63;
  uint64_t v64;
  unsigned int *v65;
  unsigned int v66;
  unsigned int *v67;
  unsigned int v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  uint64_t v79;
  char *v80;
  _QWORD v81[2];
  unsigned int *v82;
  uint64_t v83;
  HGRect v84;
  HGRect v85;
  HGRect v86;
  HGRect v87;

  v5 = *(_QWORD *)&a5.var2;
  v6 = *(_QWORD *)&a5.var0;
  if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a3 + 304))(a3) & 1) != 0)
  {
LABEL_14:
    if ((_DWORD)a2 == -1 && (v27 = *(_QWORD *)(*((_QWORD *)this + 63) + 80)) != 0 && *(_DWORD *)(v27 + 8) >= 0xF4241u)
    {
      v28 = (HGeometryData *)operator new();
      HGeometryData::HGeometryData(v28, this, 0);
      v29 = vcvtps_s32_f32((float)((int)v5 - (int)v6) * 0.5);
      v78 = vcvtps_s32_f32((float)(HIDWORD(v5) - HIDWORD(v6)) * 0.5);
      v30 = (unint64_t)(v78 + HIDWORD(v6)) << 32;
      v79 = v29 + v6;
      v80 = (char *)this + 768;
      v31 = *((_QWORD *)this + 63);
      v32 = (unsigned int *)*((_QWORD *)this + 52);
      v82 = v32;
      if (v32)
      {
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 + 1, v32));
      }
      v83 = *((_QWORD *)this + 53);
      HGeometryData::ClipPolygons(v28, v6, v30 | v79, v31, (uint64_t)v80, (uint64_t)&v82, 0xFFFFFFFF);
      v34 = v82;
      if (v82)
      {
        do
        {
          v35 = __ldaxr(v34);
          v36 = v35 - 1;
        }
        while (__stlxr(v36, v34));
        if (!v36)
        {
          v37 = *((_QWORD *)v34 + 2);
          if (v37)
            MEMORY[0x1B5E2914C](v37, 0x1000C8077774924);
          MEMORY[0x1B5E29170](v34, 0x1080C4098BBCF0FLL);
        }
      }
      *(_QWORD *)&v84.var0 = (*(uint64_t (**)(HGRasterizer *, HGRenderer *, uint64_t, unint64_t, unint64_t, HGeometryData *, uint64_t, uint64_t))(*(_QWORD *)this + 624))(this, a3, a4, v6, v5, v28, 0xFFFFFFFFLL, 0xFFFFFFFFLL);
      *(_QWORD *)&v84.var2 = v38;
      HGeometryData::~HGeometryData(v28);
      MEMORY[0x1B5E29170]();
      v39 = (HGeometryData *)operator new();
      HGeometryData::HGeometryData(v39, this, 0);
      v77 = v6 + 2 * v29;
      v40 = *((_QWORD *)this + 63);
      v41 = (unsigned int *)*((_QWORD *)this + 52);
      v82 = v41;
      if (v41)
      {
        do
          v42 = __ldaxr(v41);
        while (__stlxr(v42 + 1, v41));
      }
      v83 = *((_QWORD *)this + 53);
      HGeometryData::ClipPolygons(v39, v6 & 0xFFFFFFFF00000000 | v79, v30 | v77, v40, (uint64_t)v80, (uint64_t)&v82, 0xFFFFFFFF);
      v43 = v82;
      if (v82)
      {
        do
        {
          v44 = __ldaxr(v43);
          v45 = v44 - 1;
        }
        while (__stlxr(v45, v43));
        if (!v45)
        {
          v46 = *((_QWORD *)v43 + 2);
          if (v46)
            MEMORY[0x1B5E2914C](v46, 0x1000C8077774924);
          MEMORY[0x1B5E29170](v43, 0x1080C4098BBCF0FLL);
        }
      }
      v47 = (*(uint64_t (**)(HGRasterizer *, HGRenderer *, uint64_t, unint64_t, unint64_t, HGeometryData *, uint64_t, uint64_t))(*(_QWORD *)this + 624))(this, a3, a4, v6, v5, v39, 0xFFFFFFFFLL, 0xFFFFFFFFLL);
      v49 = v48;
      *(_QWORD *)&v85.var0 = v47;
      *(_QWORD *)&v85.var2 = v49;
      HGRect::Union(&v84, v85);
      HGeometryData::~HGeometryData(v39);
      MEMORY[0x1B5E29170]();
      v50 = (HGeometryData *)operator new();
      HGeometryData::HGeometryData(v50, this, 0);
      v51 = (unint64_t)(HIDWORD(v6) + 2 * v78) << 32;
      v52 = (unint64_t)(v78 + HIDWORD(v6)) << 32;
      v53 = *((_QWORD *)this + 63);
      v54 = (unsigned int *)*((_QWORD *)this + 52);
      v82 = v54;
      if (v54)
      {
        do
          v55 = __ldaxr(v54);
        while (__stlxr(v55 + 1, v54));
      }
      v83 = *((_QWORD *)this + 53);
      HGeometryData::ClipPolygons(v50, v52 | v6, v51 | v79, v53, (uint64_t)v80, (uint64_t)&v82, 0xFFFFFFFF);
      v56 = v82;
      if (v82)
      {
        do
        {
          v57 = __ldaxr(v56);
          v58 = v57 - 1;
        }
        while (__stlxr(v58, v56));
        if (!v58)
        {
          v59 = *((_QWORD *)v56 + 2);
          if (v59)
            MEMORY[0x1B5E2914C](v59, 0x1000C8077774924);
          MEMORY[0x1B5E29170](v56, 0x1080C4098BBCF0FLL);
        }
      }
      v60 = (*(uint64_t (**)(HGRasterizer *, HGRenderer *, uint64_t, unint64_t, unint64_t, HGeometryData *, uint64_t, uint64_t))(*(_QWORD *)this + 624))(this, a3, a4, v6, v5, v50, 0xFFFFFFFFLL, 0xFFFFFFFFLL);
      v62 = v61;
      *(_QWORD *)&v86.var0 = v60;
      *(_QWORD *)&v86.var2 = v62;
      HGRect::Union(&v84, v86);
      HGeometryData::~HGeometryData(v50);
      MEMORY[0x1B5E29170]();
      v63 = (HGeometryData *)operator new();
      HGeometryData::HGeometryData(v63, this, 0);
      v64 = *((_QWORD *)this + 63);
      v65 = (unsigned int *)*((_QWORD *)this + 52);
      v82 = v65;
      if (v65)
      {
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 + 1, v65));
      }
      v83 = *((_QWORD *)this + 53);
      HGeometryData::ClipPolygons(v63, v52 | v79, v51 | v77, v64, (uint64_t)v80, (uint64_t)&v82, 0xFFFFFFFF);
      v67 = v82;
      if (v82)
      {
        do
        {
          v68 = __ldaxr(v67);
          v69 = v68 - 1;
        }
        while (__stlxr(v69, v67));
        if (!v69)
        {
          v70 = *((_QWORD *)v67 + 2);
          if (v70)
            MEMORY[0x1B5E2914C](v70, 0x1000C8077774924);
          MEMORY[0x1B5E29170](v67, 0x1080C4098BBCF0FLL);
        }
      }
      v71 = (*(uint64_t (**)(HGRasterizer *, HGRenderer *, uint64_t, unint64_t, unint64_t, HGeometryData *, uint64_t, uint64_t))(*(_QWORD *)this + 624))(this, a3, a4, v6, v5, v63, 0xFFFFFFFFLL, 0xFFFFFFFFLL);
      v73 = v72;
      *(_QWORD *)&v87.var0 = v71;
      *(_QWORD *)&v87.var2 = v73;
      HGRect::Union(&v84, v87);
      HGeometryData::~HGeometryData(v63);
      MEMORY[0x1B5E29170]();
      return *(_QWORD *)&v84.var0;
    }
    else
    {
      v18 = (HGeometryData *)operator new();
      HGeometryData::HGeometryData(v18, this, 0);
      v19 = *((_QWORD *)this + 63);
      v20 = (unsigned int *)*((_QWORD *)this + 52);
      v81[0] = v20;
      if (v20)
      {
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 + 1, v20));
      }
      v81[1] = *((_QWORD *)this + 53);
      HGeometryData::ClipPolygons(v18, v6, v5, v19, (uint64_t)this + 768, (uint64_t)v81, a2);
      v22 = v81[0];
      if (v81[0])
      {
        do
        {
          v23 = __ldaxr((unsigned int *)v22);
          v24 = v23 - 1;
        }
        while (__stlxr(v24, (unsigned int *)v22));
        if (!v24)
        {
          v25 = *(_QWORD *)(v22 + 16);
          if (v25)
            MEMORY[0x1B5E2914C](v25, 0x1000C8077774924);
          MEMORY[0x1B5E29170](v22, 0x1080C4098BBCF0FLL);
        }
      }
      v5 = (*(uint64_t (**)(HGRasterizer *, HGRenderer *, uint64_t, unint64_t, unint64_t, HGeometryData *, uint64_t, uint64_t))(*(_QWORD *)this + 624))(this, a3, a4, v6, v5, v18, a2, 0xFFFFFFFFLL);
      HGeometryData::~HGeometryData(v18);
      MEMORY[0x1B5E29170]();
    }
    return v5;
  }
  Input = HGRenderer::GetInput(a3, (HGNode *)this, a4);
  v12 = (char *)this + 8 * (int)a4;
  if (*(_DWORD *)(*((_QWORD *)v12 + 54) + 168))
    Input = HGRenderer::GetInput(a3, Input, 0);
  if ((*((_BYTE *)this + 1109) & 2) != 0)
  {
    if (!Input)
      goto LABEL_14;
  }
  else if (!Input
         || ((*(uint64_t (**)(HGNode *, uint64_t))(*(_QWORD *)Input + 152))(Input, 0xFFFFFFFFLL) & 4) == 0)
  {
    goto LABEL_14;
  }
  DOD = HGRenderer::GetDOD(a3, Input);
  v15 = v14;
  if (HGRectIsInfinite(DOD, v14) || (HIDWORD(v15) - HIDWORD(DOD)) * ((int)v15 - (int)DOD) > 0x4000)
    goto LABEL_14;
  v16 = v12 + 432;
  if (!HGRectIsNull(DOD, v15))
  {
    if (HGTransform::IsIdentity((HGTransform *)(*(_QWORD *)v16 + 8)) || (v74 = *((_QWORD *)this + 95)) == 0)
    {
      v17 = *(uint64_t (**)(void))(**((_QWORD **)this + 94) + 400);
    }
    else
    {
      (*(void (**)(uint64_t, HGRenderer *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v74 + 400))(v74, a3, a4, DOD, v15);
      v17 = *(uint64_t (**)(void))(**(_QWORD **)(*(_QWORD *)v16 + 152) + 400);
    }
    v5 = v17();
    *(_QWORD *)&v84.var0 = v5;
    *(_QWORD *)&v84.var2 = v75;
  }
  v76 = *(_QWORD *)v16;
  *(_BYTE *)(v76 + 194) = 1;
  *(HGRect *)(v76 + 176) = v84;
  return v5;
}

void sub_1B29D01CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D01E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1020C40A6B7C7A9);
  _Unwind_Resume(a1);
}

unint64_t HGRasterizer::GetROI(HGRasterizer *this, HGRenderer *a2, uint64_t a3, HGRect a4, HGeometryData *a5, double a6, double a7, double a8, double a9, double a10, __n128 a11)
{
  char *v13;
  uint64_t v14;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  int *v23;
  uint64_t v24;
  unint64_t v25;
  float32x2_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t Content;
  char *v35;
  int8x16_t v36;
  const float *v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  unint64_t v41;
  unsigned __int32 v42;
  unint64_t v43;
  uint64_t (*v44)(void);
  uint64_t v45;
  unint64_t v46;
  __n128 v47;
  char v48;
  int8x8_t v49;
  __int32 v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (((*((_DWORD *)this + 267) >> a3) & 1) == 0)
    return 0;
  v13 = (char *)this + 8 * (int)a3;
  v14 = *((_QWORD *)v13 + 54);
  if (*(_BYTE *)(v14 + 194))
    return *(_QWORD *)(v14 + 176);
  v17 = *((_QWORD *)this + 64);
  if (v17)
  {
    v18 = *(_DWORD *)(v17 + 28) - *(_DWORD *)(v17 + 20);
    if (!v18)
      return 0;
  }
  else
  {
    v19 = *((_QWORD *)a5 + 10);
    if (!v19)
      return 0;
    v18 = *(_DWORD *)(v19 + 8);
    if (!v18)
      return 0;
  }
  v20 = 0;
  v21 = v13 + 432;
  v22 = (uint64_t *)((char *)this + 8 * (int)a3 + 536);
  v23 = (int *)((char *)a5 + 16 * (int)a3 + 112);
  v24 = v18;
  a11.n128_u64[0] = 0x8000000080000000;
  v25 = 0x8000000080000000;
  __asm { FMOV            V8.2S, #-1.0 }
  do
  {
    v33 = *v22;
    if (*v22)
    {
      if ((*(_BYTE *)(v33 + 12) & 0x20) != 0)
      {
        v47 = a11;
        Content = HGMetalBuffer::GetContent((id *)v33);
        a11 = v47;
      }
      else
      {
        Content = *(_QWORD *)(v33 + 80);
      }
      v36 = *(int8x16_t *)(Content + 16 * v20);
      v49 = vext_s8(*(int8x8_t *)v36.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), 4uLL);
      v35 = &v48;
      v50 = v36.i32[3];
    }
    else
    {
      v35 = (char *)(*(_QWORD *)(*(_QWORD *)v23 + 16) + *(int *)(*(_QWORD *)v23 + 4) * (uint64_t)(int)v20 + v23[2]);
      v36.i32[0] = *(_DWORD *)v35;
    }
    v37 = (const float *)(v35 + 12);
    v38.i32[0] = *((_DWORD *)v35 + 1);
    v38.i32[1] = v36.i32[0];
    v39 = vld1_dup_f32(v37);
    v40 = vdiv_f32(v38, v39);
    if (v40.f32[1] > (float)(int)v25)
      v25 = v25 & 0xFFFFFFFF00000000 | (int)(float)(ceilf(v40.f32[1]) + 1.0);
    v31 = vrndm_f32(v40);
    a11.n128_u64[0] = (unint64_t)vbsl_s8((int8x8_t)vcgt_f32(vcvt_f32_s32((int32x2_t)a11.n128_u64[0]), v40), (int8x8_t)vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_f32(vsub_f32(v40, v31)), (int8x8_t)vadd_f32(v31, _D8), (int8x8_t)v31)), (int8x8_t)a11.n128_u64[0]);
    v32 = (int)(float)(ceilf(v40.f32[0]) + 1.0);
    if (v40.f32[0] > (float)SHIDWORD(v25))
      v25 = v25 | ((unint64_t)v32 << 32);
    ++v20;
  }
  while (v24 != v20);
  v41 = a11.n128_u32[0];
  v42 = a11.n128_u32[1];
  v43 = a11.n128_u32[1] | ((unint64_t)a11.n128_u32[0] << 32);
  if (!HGRectIsNull(v43, v25))
  {
    if (HGTransform::IsIdentity((HGTransform *)(*(_QWORD *)v21 + 8)) || (v45 = *((_QWORD *)this + 95)) == 0)
    {
      v44 = *(uint64_t (**)(void))(**((_QWORD **)this + 94) + 400);
    }
    else
    {
      (*(void (**)(uint64_t, HGRenderer *, uint64_t, unint64_t, unint64_t))(*(_QWORD *)v45 + 400))(v45, a2, a3, v43, v25);
      v44 = *(uint64_t (**)(void))(**(_QWORD **)(*(_QWORD *)v21 + 152) + 400);
    }
    v46 = v44();
    v41 = HIDWORD(v46);
    v42 = v46;
  }
  return v42 | (v41 << 32);
}

uint64_t HGRasterizer::GetDOD(HGRasterizer *this, HGRenderer *a2, int a3, HGRect a4)
{
  if ((*((_BYTE *)this + 1109) & 8) != 0)
    return *(_QWORD *)&a4.var0;
  if (a3 || HGRectIsNull(*(uint64_t *)&a4.var0, *(uint64_t *)&a4.var2) && HGRenderer::GetInput(a2, (HGNode *)this, 0))
  {
    *(_QWORD *)&a4.var0 = 0;
    return *(_QWORD *)&a4.var0;
  }
  return (*(uint64_t (**)(HGRasterizer *, HGRenderer *))(*(_QWORD *)this + 640))(this, a2);
}

uint64_t HGRasterizer::GetDOD(HGNode *this, int a2, HGRenderer *a3, int a4, HGRect a5)
{
  __int128 *v5;
  uint64_t v10;

  if (a4)
  {
    v5 = &HGRectNull;
    return *(_QWORD *)v5;
  }
  if (HGRectIsNull(*(uint64_t *)&a5.var0, *(uint64_t *)&a5.var2) && HGRenderer::GetInput(a3, this, 0))
    return 0;
  (*(void (**)(HGNode *, HGRenderer *))(*(_QWORD *)this + 640))(this, a3);
  v5 = (__int128 *)*((_QWORD *)this + 52);
  if (!v5)
    return *(_QWORD *)v5;
  v10 = *((_QWORD *)v5 + 2);
  if (v10)
    return *(_QWORD *)(v10 + *((int *)v5 + 1) * (uint64_t)a2 + *((int *)this + 106));
  else
    return MEMORY[0];
}

unint64_t HGRasterizer::CalculatePolygonDODs(HGRasterizer *this, HGRenderer *a2)
{
  char *v2;
  uint64_t v3;
  unint64_t v4;
  HGTransformUtils *v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  HGTransformUtils *Content;
  uint64_t v13;
  const char *v14;
  char *v15;
  double v16;
  int32x2_t v17;
  __int128 v18;
  unint64_t v19;
  HGArrayDataRef *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  void *v28;
  void *v29;
  const void *v30;
  int v31;
  __int128 *v32;
  uint64_t v33;
  __int128 v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  float v38;
  unint64_t DOD;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int32x2_t v44;
  uint64_t v45;
  int v46;
  float32x2_t *v47;
  int32x2_t v48;
  int v49;
  int v50;
  int v51;
  int32x2_t v52;
  uint64_t v53;
  uint64_t v54;
  float v55;
  unint64_t v56;
  int32x2_t v57;
  int v58;
  uint64_t v59;
  unint64_t v60;
  float v61;
  double v62;
  float v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  __int32 *v86;
  float32x2_t v87;
  __int32 v88;
  int v89;
  float32x2_t *v90;
  float v91;
  int v92;
  float32x2_t *v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  int *v97;
  int v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  float v103;
  int *v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  double v109;
  float v110;
  BOOL v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t *v115;
  _BOOL4 IsNull;
  uint64_t v117;
  uint64_t v118;
  __int128 v119;
  float32x2_t v120;
  __int32 v121;
  float v122;
  float32x2_t v123;
  __int32 v124;
  float v125;
  float32x2_t v126;
  __int32 v127;
  float v128;
  uint64_t v129;
  HGRect v130;
  HGRect v131;

  v129 = *MEMORY[0x1E0C80C00];
  v2 = (char *)this + 1124;
  if (*((_BYTE *)this + 1076))
    goto LABEL_2;
  v8 = (HGRasterizer *)((char *)this + 768);
  v9 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 96) + 224))((char *)this + 768);
  if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0)
  {
    v10 = *((_QWORD *)this + 64);
    if (v10)
    {
      LODWORD(v3) = 0;
      v4 = 0;
      v11 = 0;
      if ((*(_BYTE *)(v10 + 12) & 0x20) != 0)
      {
        Content = (HGTransformUtils *)HGMetalBuffer::GetContent(*((id **)this + 64));
        v13 = (*(_DWORD *)(*((_QWORD *)this + 64) + 28) - *(_DWORD *)(*((_QWORD *)this + 64) + 20));
        if (!(_DWORD)v13)
        {
LABEL_39:
          if (!v9)
          {
            v38 = HGTransformUtils::MinW(Content);
            *(_QWORD *)&v130.var0 = v11;
            DOD = HGTransformUtils::GetDOD(v8, (const HGTransform *)(v3 | (v4 << 32)), v130, 0.5, v38);
            v11 = v40;
            v4 = HIDWORD(DOD);
            LODWORD(v3) = DOD;
          }
          *(_QWORD *)v2 = v3 | (v4 << 32);
          *((_QWORD *)v2 + 1) = v11;
          return v3 | (v4 << 32);
        }
      }
      else
      {
        Content = *(HGTransformUtils **)(v10 + 80);
        v13 = (*(_DWORD *)(v10 + 28) - *(_DWORD *)(v10 + 20));
        if (!(_DWORD)v13)
          goto LABEL_39;
      }
      v3 = (int)COERCE_FLOAT(*(_OWORD *)Content);
      v4 = (int)COERCE_FLOAT(HIDWORD(*(_QWORD *)Content));
      v11 = v3 | (v4 << 32);
      if ((_DWORD)v13 != 1)
      {
        v32 = (__int128 *)((char *)Content + 16);
        v33 = v13 - 1;
        do
        {
          v34 = *v32++;
          v35 = *((float *)&v34 + 1);
          LODWORD(v36) = (int)*(float *)&v34;
          if ((int)v3 >= (int)*(float *)&v34)
            LODWORD(v3) = v36;
          LODWORD(v37) = (int)v35;
          if ((int)v4 >= (int)v35)
            v4 = v37;
          else
            v4 = v4;
          if ((int)v11 <= (int)v36)
            v36 = v36;
          else
            v36 = v11;
          if (SHIDWORD(v11) <= (int)v37)
            v37 = v37;
          else
            v37 = HIDWORD(v11);
          v11 = v36 | (v37 << 32);
          --v33;
        }
        while (v33);
      }
      goto LABEL_39;
    }
  }
  if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2)
    && *((_QWORD *)this + 64)
    && (HGRasterizer::transformBuffersToGeometryInfo((float32x4_t *)this, v14, v15) & 1) == 0)
  {
    LODWORD(v3) = 0;
    v4 = 0;
    return v3 | (v4 << 32);
  }
  v16 = HGeometryData::operator=(*((unsigned int ***)this + 63), *((_QWORD *)this + 62));
  if ((*(unsigned int (**)(HGRenderer *, double))(*(_QWORD *)a2 + 304))(a2, v16))
  {
    v19 = (*(uint64_t (**)(HGRasterizer *, HGRenderer *))(*(_QWORD *)this + 648))(this, a2);
    v4 = HIDWORD(v19);
    LODWORD(v3) = v19;
    return v3 | (v4 << 32);
  }
  *((_BYTE *)this + 1076) = 1;
  v20 = (HGRasterizer *)((char *)this + 416);
  if ((*((_BYTE *)this + 1109) & 1) != 0)
  {
    v41 = *(_QWORD *)v20;
    if (*(_QWORD *)v20)
    {
      if ((*(_DWORD *)(v41 + 12) & 0x80000000) != 0)
      {
        *(_DWORD *)(v41 + 12) = 0;
        v20 = *(HGArrayDataRef **)(v41 + 16);
        if (v20)
          v20 = (HGArrayDataRef *)MEMORY[0x1B5E2914C](v20, 0x1000C8077774924);
        *(_QWORD *)(v41 + 16) = 0;
        *(_DWORD *)(v41 + 8) = 0;
      }
      else
      {
        *(_DWORD *)(v41 + 8) = 0;
      }
    }
  }
  else
  {
    v21 = *((_QWORD *)this + 63);
    v22 = *(_DWORD *)(v21 + 244);
    v23 = *((_QWORD *)this + 52);
    if (v23)
    {
      v24 = *(_DWORD *)(v23 + 12);
      if (v24 < v22)
      {
        v25 = *(_DWORD *)(v23 + 4);
        v26 = v25 * v22;
        *(_DWORD *)(v23 + 12) = v22;
        if (v25 * v22)
        {
          v27 = v25 * v24;
          v28 = (void *)operator new[]();
          v29 = v28;
          if (v27)
          {
            v30 = *(const void **)(v23 + 16);
            if (v30)
            {
              if (v27 >= v26)
                v31 = v26;
              else
                v31 = v27;
              memcpy(v28, v30, v31);
            }
          }
        }
        else
        {
          v29 = 0;
        }
        v20 = *(HGArrayDataRef **)(v23 + 16);
        if (v20)
          v20 = (HGArrayDataRef *)MEMORY[0x1B5E2914C](v20, 0x1000C8077774924);
        *(_QWORD *)(v23 + 16) = v29;
      }
      *(_DWORD *)(v23 + 8) = v22;
    }
    else if (v22 > 0)
    {
      v20 = (HGArrayDataRef *)HGArrayDataRef::allocate(v20, 16, *(_DWORD *)(v21 + 244), *(_DWORD *)(v21 + 244));
    }
  }
  v42 = *((_QWORD *)this + 63);
  v43 = *(_DWORD *)(v42 + 244);
  if ((*((_BYTE *)this + 1109) & 1) == 0 || v43 < 0x65)
  {
    if (!v43)
    {
LABEL_2:
      LODWORD(v3) = *(_DWORD *)v2;
      v4 = *((unsigned int *)v2 + 1);
      return v3 | (v4 << 32);
    }
    v58 = 0;
    while (1)
    {
      v61 = 0.0;
      HIDWORD(v62) = 0;
      *(int32x2_t *)&v18 = vrev64_s32(0);
      v63 = 0.0;
      v64 = *(_QWORD *)(v42 + 48);
      v65 = *(_QWORD *)(v64 + 16);
      v66 = *(_DWORD *)(v64 + 4);
      v67 = v58;
      v68 = *(int *)(v42 + 56);
      if (*(int *)(v65 + v66 * (uint64_t)v58 + v68) >= 1)
        break;
      v70 = 0;
LABEL_141:
      v112 = HGRectIntegral(v42, v61, *((float *)&v18 + 1), *(float *)&v18, v63);
      v59 = v112;
      v60 = v113;
      if (v70)
      {
        v114 = (v113 + 1) | v113 & 0xFFFFFFFF00000000;
        if ((_DWORD)v112 != (_DWORD)v113)
          v114 = v113;
        if (HIDWORD(v112) == HIDWORD(v114))
          v60 = v114 | ((v113 & 0xFFFFFFFF00000000) + 0x100000000);
        else
          v60 = v114;
      }
      if ((*((_BYTE *)this + 1109) & 1) == 0)
      {
        v115 = (uint64_t *)(*(_QWORD *)(*((_QWORD *)this + 52) + 16)
                         + *(int *)(*((_QWORD *)this + 52) + 4) * (uint64_t)v67
                         + *((int *)this + 106));
        *v115 = v112;
        v115[1] = v60;
      }
      if (v67 && !HGRectIsNull(*(_QWORD *)v2, *((_QWORD *)v2 + 1)))
      {
        IsNull = HGRectIsNull(v59, v60);
        v117 = *(_QWORD *)v2;
        v118 = *((_QWORD *)v2 + 1);
        if (!IsNull)
          v117 = HGRectUnion(v117, v118, v59, v60);
        v59 = v117;
        v60 = v118;
      }
      *(_QWORD *)v2 = v59;
      *((_QWORD *)v2 + 1) = v60;
      v58 = v67 + 1;
      v42 = *((_QWORD *)this + 63);
      if ((v67 + 1) >= *(_DWORD *)(v42 + 244))
        goto LABEL_2;
    }
    v69 = 0;
    v70 = 0;
    while (1)
    {
      v72 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v42 + 16)
                      + *(int *)(*(_QWORD *)v42 + 4) * (uint64_t)v67
                      + *(int *)(v42 + 8));
      v73 = *(_DWORD *)(v65 + v67 * (uint64_t)v66 + (int)v68);
      if (v73 <= v69)
        v74 = 0;
      else
        v74 = v69;
      v75 = v74 + v72;
      v76 = *(_QWORD *)(v42 + 16);
      v77 = *(_QWORD *)(v76 + 16);
      v78 = *(_DWORD *)(v76 + 4);
      v79 = v77 + v75 * v78;
      v80 = *(int *)(v42 + 24);
      v81 = *(__int16 *)(v79 + v80);
      v82 = *(_QWORD *)(v42 + 80);
      if (v9)
      {
        v83 = *(_QWORD *)(v82 + 16);
        v84 = *(_DWORD *)(v82 + 4);
        v85 = *(int *)(v42 + 88);
        v86 = (__int32 *)(v83 + v84 * (uint64_t)v81 + v85);
        v87.i32[0] = *v86;
        v126.i32[0] = *v86;
        v88 = v86[1];
        v126.i32[1] = v88;
        v127 = v86[2];
        v17.i32[0] = v86[3];
        v128 = *(float *)v17.i32;
        LODWORD(v62) = *((_DWORD *)this + 102);
        if (*(float *)v17.i32 >= *(float *)&v62)
        {
          v87.i32[1] = v88;
          goto LABEL_110;
        }
        v89 = v69 - 1;
        if (v73 < v69)
          v89 = 0;
        if (!v69)
          v89 = v73 - 1;
        v90 = (float32x2_t *)(v83 + v84 * (uint64_t)*(__int16 *)(v77 + (v89 + v72) * v78 + v80) + v85);
        v123 = *v90;
        v124 = v90[1].i32[0];
        v91 = v90[1].f32[1];
        v125 = v91;
        if (v73 > v69 + 1)
          v92 = v69 + 1;
        else
          v92 = 0;
        v93 = (float32x2_t *)(v83 + v84 * (uint64_t)*(__int16 *)(v77 + (v92 + v72) * v78 + v80) + v85);
        v120 = *v93;
        v121 = v93[1].i32[0];
        v122 = v93[1].f32[1];
        if (v91 < *(float *)&v62)
          goto LABEL_132;
      }
      else
      {
        v119 = v18;
        if (v82 && (v94 = *(_QWORD *)(v82 + 16)) != 0)
          v95 = v94 + *(int *)(v82 + 4) * (uint64_t)*(__int16 *)(v79 + v80) + *(int *)(v42 + 88);
        else
          v95 = 0;
        (*(void (**)(HGTransformUtils *, float32x2_t *, uint64_t, uint64_t))(*((_QWORD *)this + 96) + 208))(v8, &v126, v95, 1);
        *(float *)v17.i32 = v128;
        if (v128 >= *((float *)this + 102))
        {
          v87 = v126;
          v18 = v119;
LABEL_110:
          v62 = COERCE_DOUBLE(vdiv_f32(v87, (float32x2_t)vdup_lane_s32(v17, 0)));
          if (*(float *)v17.i32 != 1.0)
            *(double *)&v87 = v62;
          v103 = v87.f32[0];
          if (v70)
            goto LABEL_136;
          goto LABEL_79;
        }
        v96 = v69 - 1;
        v97 = (int *)*((_QWORD *)this + 63);
        v98 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v97 + 6) + 16)
                        + *(int *)(*((_QWORD *)v97 + 6) + 4) * (uint64_t)v67
                        + v97[14]);
        v99 = v98 - 1;
        if (v98 < v69)
          v96 = 0;
        if (v69)
          v99 = v96;
        v100 = *((_QWORD *)v97 + 10);
        if (v100 && (v101 = *(_QWORD *)(v100 + 16)) != 0)
          v102 = v101
               + *(int *)(v100 + 4)
               * (uint64_t)*(__int16 *)(*(_QWORD *)(*((_QWORD *)v97 + 2) + 16)
                                     + *(int *)(*((_QWORD *)v97 + 2) + 4)
                                     * (uint64_t)(v99
                                               + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v97 + 16)
                                                           + *(int *)(*(_QWORD *)v97 + 4) * (uint64_t)v67
                                                           + v97[2]))
                                     + v97[6])
               + v97[22];
        else
          v102 = 0;
        (*(void (**)(HGTransformUtils *, float32x2_t *, uint64_t, uint64_t))(*((_QWORD *)this + 96) + 208))(v8, &v123, v102, 1);
        v104 = (int *)*((_QWORD *)this + 63);
        if (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)v104 + 6) + 16)
                       + *(int *)(*((_QWORD *)v104 + 6) + 4) * (uint64_t)v67
                       + v104[14]) > v69 + 1)
          v105 = v69 + 1;
        else
          v105 = 0;
        v106 = *((_QWORD *)v104 + 10);
        if (v106 && (v107 = *(_QWORD *)(v106 + 16)) != 0)
          v108 = v107
               + *(int *)(v106 + 4)
               * (uint64_t)*(__int16 *)(*(_QWORD *)(*((_QWORD *)v104 + 2) + 16)
                                     + *(int *)(*((_QWORD *)v104 + 2) + 4)
                                     * (uint64_t)(v105
                                               + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v104 + 16)
                                                           + *(int *)(*(_QWORD *)v104 + 4) * (uint64_t)v67
                                                           + v104[2]))
                                     + v104[6])
               + v104[22];
        else
          v108 = 0;
        (*(void (**)(HGTransformUtils *, float32x2_t *, uint64_t, uint64_t))(*((_QWORD *)this + 96) + 208))(v8, &v120, v108, 1);
        v91 = v125;
        LODWORD(v62) = *((_DWORD *)this + 102);
        v18 = v119;
        if (v125 < *(float *)&v62)
          goto LABEL_132;
      }
      v109 = COERCE_DOUBLE(vadd_f32(v126, vmul_n_f32(vsub_f32(v123, v126), (float)(*(float *)&v62 - v128) / (float)(v91 - v128))));
      v17 = (int32x2_t)vdiv_f32(*(float32x2_t *)&v109, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v62, 0));
      if (*(float *)&v62 == 1.0)
        *(double *)&v17 = v109;
      v110 = *(float *)v17.i32;
      if (!v70)
      {
        v70 = 1;
        *(int32x2_t *)&v18 = v17;
LABEL_131:
        v63 = *(float *)&v17.i32[1];
        v61 = v110;
        goto LABEL_132;
      }
      if (*(float *)v17.i32 >= v61)
        v110 = v61;
      *(int8x8_t *)&v18 = vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(DWORD1(v18), v17.u32[0]), (float32x2_t)__PAIR64__(v17.u32[1], v18)), (int8x8_t)v17, *(int8x8_t *)&v18);
      v61 = v110;
      if (*(float *)&v17.i32[1] > v63)
        goto LABEL_131;
LABEL_132:
      if (v122 < *(float *)&v62)
        goto LABEL_81;
      v17 = (int32x2_t)vsub_f32(v120, v126);
      v87 = vadd_f32(v126, vmul_n_f32((float32x2_t)v17, (float)(*(float *)&v62 - v128) / (float)(v122 - v128)));
      v111 = *(float *)&v62 == 1.0;
      v62 = COERCE_DOUBLE(vdiv_f32(v87, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v62, 0)));
      if (!v111)
        *(double *)&v87 = v62;
      v103 = v87.f32[0];
      if (v70)
      {
LABEL_136:
        if (v103 >= v61)
          v103 = v61;
        v17 = vcgt_f32((float32x2_t)__PAIR64__(DWORD1(v18), v87.u32[0]), (float32x2_t)__PAIR64__(v87.u32[1], v18));
        *(int8x8_t *)&v18 = vbsl_s8((int8x8_t)v17, (int8x8_t)v87, *(int8x8_t *)&v18);
        v61 = v103;
        if (v87.f32[1] <= v63)
          goto LABEL_81;
        goto LABEL_80;
      }
LABEL_79:
      v70 = 1;
      *(float32x2_t *)&v18 = v87;
LABEL_80:
      v63 = v87.f32[1];
      v61 = v103;
LABEL_81:
      ++v69;
      v42 = *((_QWORD *)this + 63);
      v71 = *(_QWORD *)(v42 + 48);
      v65 = *(_QWORD *)(v71 + 16);
      v66 = *(_DWORD *)(v71 + 4);
      v68 = *(int *)(v42 + 56);
      if (v69 >= *(_DWORD *)(v65 + v66 * (uint64_t)v67 + v68))
        goto LABEL_141;
    }
  }
  LODWORD(v3) = 0;
  v4 = 0;
  v44 = 0;
  v45 = *(_QWORD *)(v42 + 80);
  if (v45)
  {
    v46 = *(_DWORD *)(v45 + 8);
    if (v46)
    {
      v47 = (float32x2_t *)(*(_QWORD *)(v45 + 16) + *(int *)(v42 + 88));
      v48 = vcvt_s32_f32(*v47);
      LODWORD(v3) = v48.i32[0];
      v4 = v48.u32[1];
      v44 = v48;
      v49 = v46 - 1;
      if (v49)
      {
        v50 = *(_DWORD *)(v45 + 4);
        v51 = v50;
        do
        {
          v52 = vcvt_s32_f32(*(float32x2_t *)((char *)v47 + v51));
          v48 = vmin_s32(v48, v52);
          if (v44.i32[0] <= v52.i32[0])
            v53 = v52.u32[0];
          else
            v53 = v44.u32[0];
          if (v44.i32[1] <= v52.i32[1])
            v54 = v52.u32[1];
          else
            v54 = v44.u32[1];
          v44 = (int32x2_t)(v53 | (v54 << 32));
          v51 += v50;
          --v49;
        }
        while (v49);
        v4 = v48.u32[1];
        LODWORD(v3) = v48.i32[0];
      }
    }
  }
  if (!v9)
  {
    v55 = HGTransformUtils::MinW(v20);
    *(int32x2_t *)&v131.var0 = v44;
    v56 = HGTransformUtils::GetDOD(v8, (const HGTransform *)(v3 | (v4 << 32)), v131, 0.5, v55);
    v44 = v57;
    v4 = HIDWORD(v56);
    LODWORD(v3) = v56;
  }
  *(_QWORD *)v2 = v3 | (v4 << 32);
  *((int32x2_t *)v2 + 1) = v44;
  return v3 | (v4 << 32);
}

uint64_t HGRasterizer::transformBuffersToGeometryInfo(float32x4_t *this, const char *a2, char *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int16x8_t *v19;
  uint64_t v20;
  int v21;
  char *v22;
  unint64_t v23;
  float32x4_t *v24;
  float32x4_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t v34;
  _QWORD *v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  const float *v38;
  float32x4_t v39;
  uint64_t v40;
  uint64_t v41;
  int16x8_t *v42;
  int32x4_t v43;
  int16x8_t v44;
  int8x16_t v45;
  uint64_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  uint16x8_t v50;
  uint16x8_t v51;
  __int16 *v52;
  uint64_t v53;
  int v54;
  int v55;
  uint64_t v56;
  HGArrayDataRef *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  int v63;
  void *v64;
  void *v65;
  const void *v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  float32x4_t v78;
  uint64_t v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;

  if (this[67].i32[2])
    return 0;
  v5 = this[32].i64[0];
  if (!v5)
  {
    v22 = "Rasterizer::transformBuffersToGeometryInfo - no populated vertexBuffer set.";
LABEL_53:
    HGLogger::warning((HGLogger *)v22, a2, a3);
    return 0;
  }
  v79 = *(_QWORD *)(v5 + 80);
  v6 = this[33].i64[0];
  if (v6 && *(_DWORD *)(v6 + 28) - *(_DWORD *)(v6 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
  {
    v22 = "Rasterizer::transformBuffersToGeometryInfo - size mismatch between color and vertex buffers.";
    goto LABEL_53;
  }
  v77 = *(_QWORD *)(v6 + 80);
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v7 = this[33].i64[1];
  if (v7)
  {
    if (*(_DWORD *)(v7 + 28) - *(_DWORD *)(v7 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
      goto LABEL_30;
    v7 = *(_QWORD *)(v7 + 80);
  }
  *(_QWORD *)&v80 = v7;
  v8 = this[34].i64[0];
  if (v8)
  {
    if (*(_DWORD *)(v8 + 28) - *(_DWORD *)(v8 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
      goto LABEL_30;
    v8 = *(_QWORD *)(v8 + 80);
  }
  *((_QWORD *)&v80 + 1) = v8;
  v9 = this[34].i64[1];
  if (v9)
  {
    if (*(_DWORD *)(v9 + 28) - *(_DWORD *)(v9 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
      goto LABEL_30;
    v9 = *(_QWORD *)(v9 + 80);
  }
  *(_QWORD *)&v81 = v9;
  v10 = this[35].i64[0];
  if (v10)
  {
    if (*(_DWORD *)(v10 + 28) - *(_DWORD *)(v10 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
      goto LABEL_30;
    v10 = *(_QWORD *)(v10 + 80);
  }
  *((_QWORD *)&v81 + 1) = v10;
  v11 = this[35].i64[1];
  if (v11)
  {
    if (*(_DWORD *)(v11 + 28) - *(_DWORD *)(v11 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
      goto LABEL_30;
    v11 = *(_QWORD *)(v11 + 80);
  }
  *(_QWORD *)&v82 = v11;
  v12 = this[36].i64[0];
  if (v12)
  {
    if (*(_DWORD *)(v12 + 28) - *(_DWORD *)(v12 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
      goto LABEL_30;
    v12 = *(_QWORD *)(v12 + 80);
  }
  *((_QWORD *)&v82 + 1) = v12;
  v13 = this[36].i64[1];
  if (v13)
  {
    if (*(_DWORD *)(v13 + 28) - *(_DWORD *)(v13 + 20) != *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
      goto LABEL_30;
    v13 = *(_QWORD *)(v13 + 80);
  }
  *(_QWORD *)&v83 = v13;
  v14 = this[37].i64[0];
  if (!v14)
    goto LABEL_31;
  if (*(_DWORD *)(v14 + 28) - *(_DWORD *)(v14 + 20) == *(_DWORD *)(v5 + 28) - *(_DWORD *)(v5 + 20))
  {
    *((_QWORD *)&v83 + 1) = *(_QWORD *)(v14 + 80);
    goto LABEL_31;
  }
LABEL_30:
  HGLogger::warning((HGLogger *)"Rasterizer::transformBuffersToGeometryInfo - size mismatch between color and tex coord buffers.", a2, a3);
  v5 = this[32].i64[0];
LABEL_31:
  if (*(_DWORD *)(v5 + 28) != *(_DWORD *)(v5 + 20))
  {
    v23 = 0;
    v24 = this + 39;
    __asm { FMOV            V0.4S, #1.0 }
    v78 = _Q0;
    do
    {
      v30 = v78;
      if (this[33].i64[0])
        v30 = *(float32x4_t *)(v77 + 16 * v23);
      v31 = 0;
      this[38] = v30;
      v32 = 39;
      do
      {
        v33 = *((_QWORD *)&v80 + v31);
        if (v33)
        {
          v34 = *(float32x4_t *)(v33 + 16 * v23);
          this[66].i32[3] |= 1 << v31;
          v24[v31] = v34;
          v35 = (_QWORD *)this[27].i64[v31];
          if (!(*(unsigned int (**)(_QWORD))(*(_QWORD *)*v35 + 224))(*v35))
            (*(void (**)(_QWORD, float32x4_t *, float32x4_t *, uint64_t))(*(_QWORD *)*v35 + 208))(*v35, &this[v32], &this[v32], 1);
        }
        else
        {
          v36 = atomic_load((unsigned __int8 *)&qword_1ED4D9498);
          if ((v36 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9498))
          {
            _MergedGlobals_1 = nanf("");
            __cxa_guard_release(&qword_1ED4D9498);
          }
          v37 = atomic_load((unsigned __int8 *)qword_1ED4D94A0);
          if ((v37 & 1) == 0 && __cxa_guard_acquire(qword_1ED4D94A0))
          {
            v38 = (const float *)&_MergedGlobals_1;
            v39 = vld1q_dup_f32(v38);
            xmmword_1ED4D94B0 = (__int128)v39;
            __cxa_guard_release(qword_1ED4D94A0);
          }
          v24[v31] = (float32x4_t)xmmword_1ED4D94B0;
        }
        ++v31;
        ++v32;
      }
      while (v31 != 8);
      HGRasterizer::addVertex(this, *(float *)(v79 + 16 * v23), *(float *)(v79 + 16 * v23 + 4), *(float *)(v79 + 16 * v23 + 8), *(float *)(v79 + 16 * v23 + 12));
      ++v23;
    }
    while (v23 < (*(_DWORD *)(this[32].i64[0] + 28) - *(_DWORD *)(this[32].i64[0] + 20)));
  }
  v15 = this[31].i64[0];
  *(_BYTE *)(v15 + 240) = 1;
  v16 = this[32].i64[1];
  if (!v16)
  {
    v40 = *(_QWORD *)(v15 + 80);
    if (v40)
      LODWORD(v40) = *(_DWORD *)(v40 + 8);
    HGRasterizer::drawArrays((uint64_t)this, this[68].i32[2], this[69].i32[2], v40 - this[69].i32[2]);
    return 1;
  }
  v17 = *(_DWORD *)(v16 + 28);
  v18 = *(_DWORD *)(v16 + 20);
  (*(void (**)(uint64_t))(*(_QWORD *)v16 + 16))(this[32].i64[1]);
  v19 = *(int16x8_t **)(v16 + 80);
  (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  v20 = (v17 - v18);
  if (v17 == v18)
  {
    v21 = 0;
    goto LABEL_66;
  }
  if (v20 >= 0x10)
  {
    v41 = v20 & 0xFFFFFFF0;
    v42 = v19 + 1;
    v43 = 0uLL;
    v44.i64[0] = -1;
    v44.i64[1] = -1;
    v45.i64[0] = 0x100000001;
    v45.i64[1] = 0x100000001;
    v46 = v41;
    v47 = 0uLL;
    v48 = 0uLL;
    v49 = 0uLL;
    do
    {
      v50 = (uint16x8_t)vceqq_s16(v42[-1], v44);
      v51 = (uint16x8_t)vceqq_s16(*v42, v44);
      v47 = vaddq_s32(v47, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v50), v45));
      v43 = vaddq_s32(v43, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v50.i8), v45));
      v49 = vaddq_s32(v49, (int32x4_t)vandq_s8((int8x16_t)vmovl_high_u16(v51), v45));
      v48 = vaddq_s32(v48, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v51.i8), v45));
      v42 += 2;
      v46 -= 16;
    }
    while (v46);
    v21 = vaddvq_s32(vaddq_s32(vaddq_s32(v48, v43), vaddq_s32(v49, v47)));
    if (v41 == v20)
      goto LABEL_66;
  }
  else
  {
    v41 = 0;
    v21 = 0;
  }
  v52 = &v19->i16[v41];
  v53 = v20 - v41;
  do
  {
    v54 = *v52++;
    if (v54 == -1)
      ++v21;
    --v53;
  }
  while (v53);
LABEL_66:
  v55 = v21 + v20;
  v56 = this[31].i64[0];
  v59 = *(_QWORD *)(v56 + 32);
  v57 = (HGArrayDataRef *)(v56 + 32);
  v58 = v59;
  if (v59)
  {
    v60 = *(_DWORD *)(v58 + 12);
    if (v60 < v55)
    {
      v61 = *(_DWORD *)(v58 + 4);
      v62 = v61 * v55;
      *(_DWORD *)(v58 + 12) = v55;
      if (v61 * v55)
      {
        v63 = v61 * v60;
        v64 = (void *)operator new[]();
        v65 = v64;
        if (v63)
        {
          v66 = *(const void **)(v58 + 16);
          if (v66)
          {
            if (v63 >= v62)
              v67 = v62;
            else
              v67 = v63;
            memcpy(v64, v66, v67);
          }
        }
      }
      else
      {
        v65 = 0;
      }
      v69 = *(_QWORD *)(v58 + 16);
      if (v69)
        MEMORY[0x1B5E2914C](v69, 0x1000C8077774924);
      *(_QWORD *)(v58 + 16) = v65;
    }
    *(_DWORD *)(v58 + 8) = v55;
    if (v17 != v18)
      goto LABEL_84;
  }
  else
  {
    if (v55 > 0)
      HGArrayDataRef::allocate(v57, 2, v21 + v20, v21 + v20);
    if (v17 != v18)
    {
LABEL_84:
      v70 = 0;
      v71 = 0;
      do
      {
        while (1)
        {
          v72 = v19->u16[v70];
          if (v72 == 0xFFFF)
            break;
          v68 = this[31].i64[0];
          *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v68 + 32) + 16)
                   + *(int *)(*(_QWORD *)(v68 + 32) + 4) * (uint64_t)v71
                   + *(int *)(v68 + 40)) = v72;
          ++v70;
          ++v71;
          if (v70 == v20)
            goto LABEL_88;
        }
        v68 = this[31].i64[0];
        v73 = *(_QWORD *)(v68 + 32);
        v74 = *(_QWORD *)(v73 + 16);
        v75 = *(int *)(v73 + 4);
        v76 = *(int *)(v68 + 40);
        *(_WORD *)(v74 + (int)v75 * (uint64_t)v71 + v76) = v19->i16[v70++ - 1];
        *(_WORD *)(v74 + v75 * (v71 + 1) + v76) = v19->i16[v70];
        v71 += 2;
      }
      while (v70 != v20);
      goto LABEL_88;
    }
  }
  v68 = this[31].i64[0];
LABEL_88:
  HGRasterizer::drawElements((uint64_t)this, this[68].i32[2], (uint64_t *)(v68 + 32));
  return 1;
}

uint64_t HGRasterizer::CalculatePolygonDODsCPU(HGRasterizer *this, HGRenderer *a2)
{
  uint64_t *v2;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  void *v13;
  const void *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  void *v22;
  void *v23;
  int v24;
  const void *v25;
  uint64_t v26;
  int v27;
  char v28;
  uint64_t v29;
  int v30;
  int v31;
  char v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  float v47;
  float v48;
  float v49;
  float v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  float *v62;
  float v63;
  float v64;
  float v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t *v70;
  _BOOL4 IsNull;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;

  v2 = (uint64_t *)((char *)this + 1124);
  if (*((_BYTE *)this + 1076))
    return *v2;
  *((_BYTE *)this + 1076) = 1;
  v5 = *((_QWORD *)this + 63);
  v6 = *(_DWORD *)(v5 + 244);
  v7 = *((_QWORD *)this + 52);
  if (v7)
  {
    v8 = *(_DWORD *)(v7 + 12);
    if (v8 < v6)
    {
      v9 = *(_DWORD *)(v7 + 4);
      v10 = v9 * v6;
      *(_DWORD *)(v7 + 12) = v6;
      if (v9 * v6)
      {
        v11 = v9 * v8;
        v12 = (void *)operator new[]();
        v13 = v12;
        if (v11)
        {
          v14 = *(const void **)(v7 + 16);
          if (v14)
          {
            if (v11 >= v10)
              v15 = v10;
            else
              v15 = v11;
            memcpy(v12, v14, v15);
          }
        }
      }
      else
      {
        v13 = 0;
      }
      v16 = *(_QWORD *)(v7 + 16);
      if (v16)
        MEMORY[0x1B5E2914C](v16, 0x1000C8077774924);
      *(_QWORD *)(v7 + 16) = v13;
    }
    *(_DWORD *)(v7 + 8) = v6;
  }
  else if (v6 > 0)
  {
    HGArrayDataRef::allocate((HGRasterizer *)((char *)this + 416), 16, *(_DWORD *)(v5 + 244), *(_DWORD *)(v5 + 244));
  }
  v78 = 0;
  v79 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v78, 16, 0, 0);
  v17 = *(_QWORD *)(*((_QWORD *)this + 63) + 80);
  if (v17)
  {
    v18 = *(_DWORD *)(v17 + 8);
    v19 = v78;
    if (!v78)
    {
      if (v18 > 0)
        HGArrayDataRef::allocate((HGArrayDataRef *)&v78, 16, *(_DWORD *)(v17 + 8), *(_DWORD *)(v17 + 8));
      goto LABEL_36;
    }
  }
  else
  {
    v18 = 0;
    v19 = v78;
    if (!v78)
      goto LABEL_36;
  }
  v20 = *(_DWORD *)(v19 + 12);
  if (v20 < v18)
  {
    v21 = *(_DWORD *)(v19 + 4);
    *(_DWORD *)(v19 + 12) = v18;
    if (v21 * v18)
    {
      v22 = (void *)operator new[]();
      v23 = v22;
      v24 = v21 * v20;
      if (v21 * v20)
      {
        v25 = *(const void **)(v19 + 16);
        if (v25)
        {
          if (v24 >= v21 * v18)
            v24 = v21 * v18;
          memcpy(v22, v25, v24);
        }
      }
    }
    else
    {
      v23 = 0;
    }
    v26 = *(_QWORD *)(v19 + 16);
    if (v26)
      MEMORY[0x1B5E2914C](v26, 0x1000C8077774924);
    *(_QWORD *)(v19 + 16) = v23;
  }
  *(_DWORD *)(v19 + 8) = v18;
LABEL_36:
  if (!(*(unsigned int (**)(char *))(*((_QWORD *)this + 96) + 224))((char *)this + 768))
  {
    if (v18)
    {
      v33 = 0;
      v32 = 0;
      do
      {
        *(_OWORD *)(*(_QWORD *)(v78 + 16) + *(int *)(v78 + 4) * (uint64_t)v33 + (int)v79) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 63) + 80) + 16) + *(int *)(*(_QWORD *)(*((_QWORD *)this + 63) + 80) + 4) * (uint64_t)v33 + *(int *)(*((_QWORD *)this + 63) + 88));
        if (v78 && (v34 = *(_QWORD *)(v78 + 16)) != 0)
          v35 = v34 + *(int *)(v78 + 4) * (uint64_t)v33 + (int)v79;
        else
          v35 = 0;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*((_QWORD *)this + 96) + 208))((char *)this + 768, v35, v35, 1);
        v32 |= *(float *)(v35 + 12) < *((float *)this + 102);
        ++v33;
      }
      while (v18 != v33);
      goto LABEL_52;
    }
LABEL_51:
    v32 = 0;
    goto LABEL_52;
  }
  if (!v18)
    goto LABEL_51;
  v27 = 0;
  v28 = 0;
  v29 = *(_QWORD *)(v78 + 16);
  v30 = *(_DWORD *)(v78 + 4);
  v31 = v79;
  do
  {
    *(_OWORD *)(v29 + v30 * (uint64_t)v27 + v31) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 63) + 80)
                                                                        + 16)
                                                            + *(int *)(*(_QWORD *)(*((_QWORD *)this + 63) + 80) + 4)
                                                            * (uint64_t)v27
                                                            + *(int *)(*((_QWORD *)this + 63) + 88));
    v29 = *(_QWORD *)(v78 + 16);
    v30 = *(_DWORD *)(v78 + 4);
    v31 = v79;
    if (*(float *)(v29 + v30 * (uint64_t)v27 + (int)v79 + 12) < *((float *)this + 102))
      v28 = 1;
    ++v27;
  }
  while (v18 != v27);
  v32 = v28;
LABEL_52:
  v36 = *((_QWORD *)this + 63);
  *(_BYTE *)(v36 + 248) = 1;
  v37 = *(_QWORD *)(v36 + 80);
  v38 = (unsigned int *)v78;
  if (v37 != v78)
  {
    if (v37)
    {
      do
      {
        v39 = __ldaxr((unsigned int *)v37);
        v40 = v39 - 1;
      }
      while (__stlxr(v40, (unsigned int *)v37));
      if (!v40)
      {
        v41 = *(_QWORD *)(v37 + 16);
        if (v41)
          MEMORY[0x1B5E2914C](v41, 0x1000C8077774924);
        MEMORY[0x1B5E29170](v37, 0x1080C4098BBCF0FLL);
      }
      v38 = (unsigned int *)v78;
    }
    *(_QWORD *)(v36 + 80) = v38;
    if (v38)
    {
      do
        v42 = __ldaxr(v38);
      while (__stlxr(v42 + 1, v38));
    }
  }
  *(_QWORD *)(v36 + 88) = v79;
  if ((v32 & 1) != 0)
    HGeometryData::ClipW(*((HGeometryData **)this + 63));
  v43 = *((_QWORD *)this + 63);
  if (*(_DWORD *)(v43 + 244))
  {
    v44 = 0;
    while (1)
    {
      v47 = 0.0;
      v48 = 0.0;
      v49 = 0.0;
      v50 = 0.0;
      v51 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v43 + 48) + 16)
                            + *(int *)(*(_QWORD *)(v43 + 48) + 4) * (uint64_t)(int)v44
                            + *(int *)(v43 + 56));
      if ((int)v51 >= 1)
        break;
      v53 = 0;
LABEL_88:
      v66 = HGRectIntegral(v51, v47, v48, v49, v50);
      v45 = v66;
      v68 = (v67 + 1) | v67 & 0xFFFFFFFF00000000;
      if ((_DWORD)v66 != (_DWORD)v67)
        v68 = v67;
      v69 = v68 | ((v67 & 0xFFFFFFFF00000000) + 0x100000000);
      if (HIDWORD(v66) != HIDWORD(v68))
        v69 = v68;
      if (v53)
        v46 = v69;
      else
        v46 = v67;
      v70 = (uint64_t *)(*(_QWORD *)(*((_QWORD *)this + 52) + 16)
                      + *(int *)(*((_QWORD *)this + 52) + 4) * (uint64_t)(int)v44
                      + *((int *)this + 106));
      *v70 = v66;
      v70[1] = v46;
      if (v44 && !HGRectIsNull(*v2, v2[1]))
      {
        IsNull = HGRectIsNull(v45, v46);
        v72 = *v2;
        v73 = v2[1];
        if (!IsNull)
          v72 = HGRectUnion(v72, v73, v45, v46);
        v45 = v72;
        v46 = v73;
      }
      *v2 = v45;
      v2[1] = v46;
      ++v44;
      v43 = *((_QWORD *)this + 63);
      if (v44 >= *(_DWORD *)(v43 + 244))
        goto LABEL_99;
    }
    v52 = 0;
    v53 = 0;
    v54 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v43 + 16)
                    + *(int *)(*(_QWORD *)v43 + 4) * (uint64_t)(int)v44
                    + *(int *)(v43 + 8));
    v55 = *(_QWORD *)(v43 + 16);
    v56 = *(_QWORD *)(v55 + 16) + *(int *)(v43 + 24);
    v57 = *(_QWORD *)(v43 + 80);
    v58 = *(_QWORD *)(v57 + 16) + *(int *)(v43 + 88);
    v59 = *(_DWORD *)(v55 + 4);
    v60 = *(_DWORD *)(v57 + 4);
    while (1)
    {
      if ((int)v51 <= v52)
        v61 = 0;
      else
        v61 = v52;
      v62 = (float *)(v58 + v60 * (uint64_t)*(__int16 *)(v56 + v59 * (uint64_t)(v61 + v54)));
      v63 = *v62;
      v64 = v62[1];
      v65 = v62[3];
      if (v65 != 1.0)
      {
        v63 = v63 / v65;
        v64 = v64 / v65;
      }
      if (v53)
      {
        if (v63 < v47)
          v47 = v63;
        if (v63 <= v49)
          v63 = v49;
        if (v64 < v48)
          v48 = v64;
        v49 = v63;
        if (v64 <= v50)
          goto LABEL_72;
      }
      else
      {
        v53 = 1;
        v48 = v64;
        v47 = v63;
      }
      v50 = v64;
      v49 = v63;
LABEL_72:
      if ((_DWORD)v51 == ++v52)
        goto LABEL_88;
    }
  }
LABEL_99:
  v74 = v78;
  if (v78)
  {
    do
    {
      v75 = __ldaxr((unsigned int *)v74);
      v76 = v75 - 1;
    }
    while (__stlxr(v76, (unsigned int *)v74));
    if (!v76)
    {
      v77 = *(_QWORD *)(v74 + 16);
      if (v77)
        MEMORY[0x1B5E2914C](v77, 0x1000C8077774924);
      MEMORY[0x1B5E29170](v74, 0x1080C4098BBCF0FLL);
    }
  }
  return *v2;
}

void sub_1B29D1C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(&a9);
  _Unwind_Resume(a1);
}

void sub_1B29D1C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *a11)
{
  if (a9)
  {
    HGRasterizer::HGRasterizer();
    exception_object = a11;
  }
  _Unwind_Resume(exception_object);
}

void sub_1B29D1CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(&a9);
  _Unwind_Resume(a1);
}

void sub_1B29D1CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(&a9);
  _Unwind_Resume(a1);
}

void sub_1B29D1CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(&a9);
  _Unwind_Resume(a1);
}

void sub_1B29D1CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGArray<__simd128_float32_t,(HGFormat)28>::~HGArray(&a9);
  _Unwind_Resume(a1);
}

uint64_t HGRasterizer::BindTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v6;
  uint64_t v7;

  if (!(_DWORD)a3 && (*(_BYTE *)(a1 + 1108) & 0x40) != 0)
  {
    v6 = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 288))(a1);
    (*(void (**)(uint64_t, _QWORD, double, float, float, float))(*(_QWORD *)a2 + 136))(a2, 0, v6, *(float *)&v6, *(float *)&v6, *(float *)&v6);
  }
  if (!*(_BYTE *)(a1 + 1077) || (v7 = *(_QWORD *)(a1 + 760)) == 0)
    v7 = *(_QWORD *)(a1 + 752);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 208))(v7, a2, a3);
}

uint64_t HGRasterizer::Bind(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 1077) && (v2 = *(_QWORD *)(a1 + 760)) != 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 200))(v2);
  else
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 752) + 200))(*(_QWORD *)(a1 + 752));
}

uint64_t HGRasterizer::UnBind(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 1077) && (v2 = *(_QWORD *)(a1 + 760)) != 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 216))(v2);
  else
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 752) + 216))(*(_QWORD *)(a1 + 752));
}

void HGRasterizer::GeometryRenderPageMetal(HGRasterizer *this, HGPage *a2, HGMetalHandler *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  const void *v59;
  uint64_t v60;
  int v61;
  int i;
  const void *v63;
  int v64;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;

  v5 = *((_QWORD *)this + 64);
  if (v5)
  {
    (*(void (**)(_QWORD, HGPage *))(*(_QWORD *)v5 + 16))(*((_QWORD *)this + 64), a2);
    v79 = v5;
    HGMetalHandler::SetVertices((uint64_t)a3, &v79);
    if (v79)
      (*(void (**)(uint64_t))(*(_QWORD *)v79 + 24))(v79);
    if (!*((_QWORD *)this + 64))
      goto LABEL_19;
  }
  else
  {
    v8 = *((_QWORD *)this + 63);
    v9 = *(_QWORD *)(v8 + 80);
    if (v9)
    {
      v10 = *(_QWORD *)(v9 + 16);
      if (v10)
      {
        HGMetalHandler::SetVertices(a3, (const void *)(v10 + *(int *)(v8 + 88)), *(int *)(v9 + 4), *(_DWORD *)(v9 + 8));
        if (!*((_QWORD *)this + 64))
          goto LABEL_19;
      }
      else
      {
        HGMetalHandler::SetVertices(a3, 0, *(int *)(v9 + 4), *(_DWORD *)(v9 + 8));
        if (!*((_QWORD *)this + 64))
          goto LABEL_19;
      }
    }
    else
    {
      HGMetalHandler::SetVertices(a3, 0, 0, 0);
      if (!*((_QWORD *)this + 64))
        goto LABEL_19;
    }
  }
  v6 = *((_QWORD *)this + 65);
  if (v6)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v6 + 16))(*((_QWORD *)this + 65));
    v78 = v6;
    HGMetalHandler::SetIndices((uint64_t)a3, &v78);
    if (v78)
      (*(void (**)(uint64_t))(*(_QWORD *)v78 + 24))(v78);
  }
  if (*((_QWORD *)this + 64))
  {
    v7 = *((_QWORD *)this + 66);
    if (v7)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)v7 + 16))(*((_QWORD *)this + 66));
      v77 = v7;
      HGMetalHandler::SetColors((uint64_t)a3, &v77);
      if (v77)
        (*(void (**)(uint64_t))(*(_QWORD *)v77 + 24))(v77);
      goto LABEL_27;
    }
  }
LABEL_19:
  v11 = *((_QWORD *)this + 63);
  if (*(_BYTE *)(v11 + 240))
  {
    v12 = *(_QWORD *)(v11 + 64);
    if (v12)
    {
      v13 = *(_QWORD *)(v12 + 16);
      if (v13)
        v14 = (const void *)(v13 + *(int *)(v11 + 72));
      else
        v14 = 0;
      v16 = *(_DWORD *)(v12 + 8);
      v15 = *(int *)(v12 + 4);
    }
    else
    {
      v15 = 0;
      v14 = 0;
      v16 = 0;
    }
    HGMetalHandler::SetColors(a3, v14, v15, v16);
  }
LABEL_27:
  if (!*((_QWORD *)this + 64))
  {
    v25 = *((_DWORD *)this + 267);
    if ((v25 & 1) == 0)
    {
      if ((v25 & 2) == 0)
        goto LABEL_70;
LABEL_91:
      v32 = *((_QWORD *)this + 63);
      v33 = *(_QWORD *)(v32 + 128);
      if (v33)
      {
        v34 = *(_QWORD *)(v33 + 16);
        if (v34)
          v35 = (const void *)(v34 + *(int *)(v32 + 136));
        else
          v35 = 0;
        HGMetalHandler::SetTextureCoords(a3, v35, *(int *)(v33 + 4), *(_DWORD *)(v33 + 8), 1u);
        v25 = *((_DWORD *)this + 267);
        if ((v25 & 4) != 0)
          goto LABEL_98;
      }
      else
      {
        HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 1u);
        v25 = *((_DWORD *)this + 267);
        if ((v25 & 4) != 0)
          goto LABEL_98;
      }
LABEL_71:
      if ((v25 & 8) == 0)
        goto LABEL_72;
LABEL_105:
      v40 = *((_QWORD *)this + 63);
      v41 = *(_QWORD *)(v40 + 160);
      if (v41)
      {
        v42 = *(_QWORD *)(v41 + 16);
        if (v42)
          v43 = (const void *)(v42 + *(int *)(v40 + 168));
        else
          v43 = 0;
        HGMetalHandler::SetTextureCoords(a3, v43, *(int *)(v41 + 4), *(_DWORD *)(v41 + 8), 3u);
        v25 = *((_DWORD *)this + 267);
        if ((v25 & 0x10) != 0)
          goto LABEL_112;
      }
      else
      {
        HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 3u);
        v25 = *((_DWORD *)this + 267);
        if ((v25 & 0x10) != 0)
          goto LABEL_112;
      }
LABEL_73:
      if ((v25 & 0x20) == 0)
        goto LABEL_74;
LABEL_119:
      v48 = *((_QWORD *)this + 63);
      v49 = *(_QWORD *)(v48 + 192);
      if (v49)
      {
        v50 = *(_QWORD *)(v49 + 16);
        if (v50)
          v51 = (const void *)(v50 + *(int *)(v48 + 200));
        else
          v51 = 0;
        HGMetalHandler::SetTextureCoords(a3, v51, *(int *)(v49 + 4), *(_DWORD *)(v49 + 8), 5u);
        v25 = *((_DWORD *)this + 267);
        if ((v25 & 0x40) != 0)
          goto LABEL_126;
      }
      else
      {
        HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 5u);
        v25 = *((_DWORD *)this + 267);
        if ((v25 & 0x40) != 0)
          goto LABEL_126;
      }
LABEL_75:
      if ((v25 & 0x80) == 0)
        goto LABEL_76;
      goto LABEL_133;
    }
    v28 = *((_QWORD *)this + 63);
    v29 = *(_QWORD *)(v28 + 112);
    if (v29)
    {
      v30 = *(_QWORD *)(v29 + 16);
      if (v30)
        v31 = (const void *)(v30 + *(int *)(v28 + 120));
      else
        v31 = 0;
      HGMetalHandler::SetTextureCoords(a3, v31, *(int *)(v29 + 4), *(_DWORD *)(v29 + 8), 0);
      v25 = *((_DWORD *)this + 267);
      if ((v25 & 2) != 0)
        goto LABEL_91;
    }
    else
    {
      HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 0);
      v25 = *((_DWORD *)this + 267);
      if ((v25 & 2) != 0)
        goto LABEL_91;
    }
LABEL_70:
    if ((v25 & 4) == 0)
      goto LABEL_71;
LABEL_98:
    v36 = *((_QWORD *)this + 63);
    v37 = *(_QWORD *)(v36 + 144);
    if (v37)
    {
      v38 = *(_QWORD *)(v37 + 16);
      if (v38)
        v39 = (const void *)(v38 + *(int *)(v36 + 152));
      else
        v39 = 0;
      HGMetalHandler::SetTextureCoords(a3, v39, *(int *)(v37 + 4), *(_DWORD *)(v37 + 8), 2u);
      v25 = *((_DWORD *)this + 267);
      if ((v25 & 8) != 0)
        goto LABEL_105;
    }
    else
    {
      HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 2u);
      v25 = *((_DWORD *)this + 267);
      if ((v25 & 8) != 0)
        goto LABEL_105;
    }
LABEL_72:
    if ((v25 & 0x10) == 0)
      goto LABEL_73;
LABEL_112:
    v44 = *((_QWORD *)this + 63);
    v45 = *(_QWORD *)(v44 + 176);
    if (v45)
    {
      v46 = *(_QWORD *)(v45 + 16);
      if (v46)
        v47 = (const void *)(v46 + *(int *)(v44 + 184));
      else
        v47 = 0;
      HGMetalHandler::SetTextureCoords(a3, v47, *(int *)(v45 + 4), *(_DWORD *)(v45 + 8), 4u);
      v25 = *((_DWORD *)this + 267);
      if ((v25 & 0x20) != 0)
        goto LABEL_119;
    }
    else
    {
      HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 4u);
      v25 = *((_DWORD *)this + 267);
      if ((v25 & 0x20) != 0)
        goto LABEL_119;
    }
LABEL_74:
    if ((v25 & 0x40) == 0)
      goto LABEL_75;
LABEL_126:
    v52 = *((_QWORD *)this + 63);
    v53 = *(_QWORD *)(v52 + 208);
    if (v53)
    {
      v54 = *(_QWORD *)(v53 + 16);
      if (v54)
        v55 = (const void *)(v54 + *(int *)(v52 + 216));
      else
        v55 = 0;
      HGMetalHandler::SetTextureCoords(a3, v55, *(int *)(v53 + 4), *(_DWORD *)(v53 + 8), 6u);
      if ((*((_DWORD *)this + 267) & 0x80) == 0)
        goto LABEL_76;
    }
    else
    {
      HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 6u);
      if ((*((_DWORD *)this + 267) & 0x80) == 0)
        goto LABEL_76;
    }
LABEL_133:
    v56 = *((_QWORD *)this + 63);
    v57 = *(_QWORD *)(v56 + 224);
    if (v57)
    {
      v58 = *(_QWORD *)(v57 + 16);
      if (v58)
        v59 = (const void *)(v58 + *(int *)(v56 + 232));
      else
        v59 = 0;
      HGMetalHandler::SetTextureCoords(a3, v59, *(int *)(v57 + 4), *(_DWORD *)(v57 + 8), 7u);
      if (*((_QWORD *)this + 64))
        goto LABEL_77;
    }
    else
    {
      HGMetalHandler::SetTextureCoords(a3, 0, 0, 0, 7u);
      if (*((_QWORD *)this + 64))
        goto LABEL_77;
    }
    goto LABEL_140;
  }
  if ((*((_BYTE *)this + 1068) & 1) != 0)
  {
    v17 = *((_QWORD *)this + 67);
    if (v17)
      (*(void (**)(_QWORD))(*(_QWORD *)v17 + 16))(*((_QWORD *)this + 67));
    v76 = v17;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 0);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
  if ((*((_BYTE *)this + 1068) & 2) != 0)
  {
    v18 = *((_QWORD *)this + 68);
    if (v18)
      (*(void (**)(_QWORD))(*(_QWORD *)v18 + 16))(*((_QWORD *)this + 68));
    v76 = v18;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 1u);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
  if ((*((_BYTE *)this + 1068) & 4) != 0)
  {
    v19 = *((_QWORD *)this + 69);
    if (v19)
      (*(void (**)(_QWORD))(*(_QWORD *)v19 + 16))(*((_QWORD *)this + 69));
    v76 = v19;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 2u);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
  if ((*((_BYTE *)this + 1068) & 8) != 0)
  {
    v20 = *((_QWORD *)this + 70);
    if (v20)
      (*(void (**)(_QWORD))(*(_QWORD *)v20 + 16))(*((_QWORD *)this + 70));
    v76 = v20;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 3u);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
  if ((*((_BYTE *)this + 1068) & 0x10) != 0)
  {
    v21 = *((_QWORD *)this + 71);
    if (v21)
      (*(void (**)(_QWORD))(*(_QWORD *)v21 + 16))(*((_QWORD *)this + 71));
    v76 = v21;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 4u);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
  if ((*((_BYTE *)this + 1068) & 0x20) != 0)
  {
    v22 = *((_QWORD *)this + 72);
    if (v22)
      (*(void (**)(_QWORD))(*(_QWORD *)v22 + 16))(*((_QWORD *)this + 72));
    v76 = v22;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 5u);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
  if ((*((_BYTE *)this + 1068) & 0x40) != 0)
  {
    v23 = *((_QWORD *)this + 73);
    if (v23)
      (*(void (**)(_QWORD))(*(_QWORD *)v23 + 16))(*((_QWORD *)this + 73));
    v76 = v23;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 6u);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
  if ((*((_BYTE *)this + 1068) & 0x80) != 0)
  {
    v24 = *((_QWORD *)this + 74);
    if (v24)
      (*(void (**)(_QWORD))(*(_QWORD *)v24 + 16))(*((_QWORD *)this + 74));
    v76 = v24;
    HGMetalHandler::SetTextureCoords((uint64_t)a3, &v76, 7u);
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 24))(v76);
  }
LABEL_76:
  if (*((_QWORD *)this + 64))
  {
LABEL_77:
    v26 = *((_DWORD *)this + 298);
    if ((v26 & 0xFFFFFFFE) != 4)
      return;
    if (v26 == 4)
      v27 = 3;
    else
      v27 = 4;
    HGMetalHandler::PrimitivesStart(a3);
    if (*((_QWORD *)this + 65))
      HGMetalHandler::PrimitivesIndexed(a3, v27, 0, 0);
    else
      HGMetalHandler::Primitives(a3, v27);
    goto LABEL_161;
  }
LABEL_140:
  v60 = *((_QWORD *)this + 143);
  if (!v60)
  {
    HGMetalHandler::PrimitivesStart(a3);
    goto LABEL_161;
  }
  v61 = *(_DWORD *)(v60 + 8);
  HGMetalHandler::PrimitivesStart(a3);
  if (v61 >= 1)
  {
    for (i = 0; v61 != i; ++i)
    {
      v70 = (int *)*((_QWORD *)this + 63);
      v71 = *((_QWORD *)v70 + 2);
      if (v71 && (v72 = *(_QWORD *)(v71 + 16)) != 0)
      {
        v73 = v72
            + *(int *)(v71 + 4)
            * (uint64_t)*(int *)(*(_QWORD *)(*(_QWORD *)v70 + 16)
                              + *(int *)(*(_QWORD *)v70 + 4)
                              * (uint64_t)*(int *)(*(_QWORD *)(*((_QWORD *)this + 147) + 16)
                                                + *(int *)(*((_QWORD *)this + 147) + 4) * (uint64_t)i
                                                + *((int *)this + 296))
                              + v70[2]);
        v74 = v70[6];
        v64 = v70[7];
        v63 = (const void *)(v73 + v74);
        if (v64 != 34 && v64 != 3)
          continue;
      }
      else
      {
        v63 = 0;
        v64 = v70[7];
        if (v64 != 34 && v64 != 3)
          continue;
      }
      if (v64 == 34)
        v66 = 4;
      else
        v66 = 2;
      v67 = *(_QWORD *)(*((_QWORD *)this + 143) + 16) + *(int *)(*((_QWORD *)this + 143) + 4) * (uint64_t)i;
      v68 = *((int *)this + 288);
      v69 = *(unsigned int *)(v67 + v68);
      HGMetalHandler::SetIndices(a3, v63, v66, *(_DWORD *)(v67 + v68));
      HGMetalHandler::PrimitivesIndexed(a3, 3, 0, v69);
    }
  }
LABEL_161:
  HGMetalHandler::PrimitivesEnd(a3);
}

void sub_1B29D26A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t HGRasterizer::drawElements(uint64_t a1, int a2, uint64_t *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  HGArrayDataRef *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  void *v28;
  const void *v29;
  int v30;
  void *v31;
  uint64_t result;
  unsigned int v33;
  int v34;
  int v35;
  HGArrayDataRef *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  void *v43;
  const void *v44;
  int v45;
  void *v46;
  unsigned int v47;
  int v48;
  HGArrayDataRef *v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  void *v56;
  const void *v57;
  int v58;
  void *v59;
  unsigned int v60;
  int v61;
  int v62;
  HGArrayDataRef *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  int v68;
  int v69;
  void *v70;
  const void *v71;
  int v72;
  void *v73;
  int v74;
  uint64_t v75;
  int v76;
  int v77;
  int v78;
  int v79;
  void *v80;
  const void *v81;
  int v82;
  void *v83;
  uint64_t v84;
  HGArrayDataRef *v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  void *v93;
  const void *v94;
  int v95;
  void *v96;
  HGArrayDataRef *v97;
  int v98;
  uint64_t v99;
  int v100;
  int v101;
  int v102;
  int v103;
  void *v104;
  const void *v105;
  int v106;
  void *v107;
  uint64_t v108;
  HGArrayDataRef *v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  void *v117;
  const void *v118;
  int v119;
  void *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  int v127;
  int v128;
  int v129;
  int v130;
  void *v131;
  const void *v132;
  int v133;
  void *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  void *v144;
  const void *v145;
  int v146;
  void *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  int v153;
  int v154;
  int v155;
  int v156;
  void *v157;
  const void *v158;
  int v159;
  void *v160;
  uint64_t *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  unsigned int v166;
  int v167;
  _QWORD *v168;
  uint64_t v169;
  unsigned int *v170;
  unsigned int v171;
  unsigned int v172;
  uint64_t v173;
  unsigned int v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unsigned int v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190;
  int v191;
  uint64_t v192;
  int v193;
  int v194;
  uint64_t v195;
  int v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  int v206;
  unsigned int v207;
  int v208;
  uint64_t v209;
  int v210;
  int v211;
  uint64_t v212;
  int v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  int v223;
  _WORD *v224;
  int v225;
  uint64_t v226;
  int v227;
  uint64_t *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  int v237;
  int v238;
  int v239;
  uint64_t v240;
  uint64_t v241;
  int v242;
  uint64_t v243;
  unsigned int v244;
  uint64_t v245;
  uint64_t v246;
  __int128 v247;
  int v248;
  int v249;

  if (*a3)
  {
    v6 = *(_DWORD *)(*a3 + 8);
    v7 = *(_QWORD *)(a1 + 496);
    if (*(_BYTE *)(v7 + 240))
      goto LABEL_10;
  }
  else
  {
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 496);
    if (*(_BYTE *)(v7 + 240))
      goto LABEL_10;
  }
  *(_BYTE *)(v7 + 240) = 1;
  v8 = *(_QWORD *)(v7 + 80);
  if (v8)
  {
    v9 = *(_DWORD *)(v8 + 8);
    if (v9 >= 1)
    {
      __asm { FMOV            V0.4S, #1.0 }
      v247 = _Q0;
      do
      {
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*(_QWORD *)(a1 + 496) + 64)) = v247;
        --v9;
      }
      while (v9);
      v7 = *(_QWORD *)(a1 + 496);
    }
  }
LABEL_10:
  v15 = *(_DWORD *)(v7 + 244);
  v16 = *(_QWORD *)(v7 + 16);
  if (v16)
  {
    v17 = *(_DWORD *)(v16 + 8);
    v18 = a2 - 4;
  }
  else
  {
    v17 = 0;
    v18 = a2 - 4;
    if ((a2 - 4) > 3)
    {
LABEL_23:
      result = puts("Unknown polygon mode in hglEnd");
      goto LABEL_240;
    }
  }
  switch(v18)
  {
    case 0:
      v19 = v6 / 3;
      v20 = v15 + v6 / 3;
      v23 = *(_QWORD *)(v7 + 48);
      v21 = (HGArrayDataRef *)(v7 + 48);
      v22 = v23;
      *((_DWORD *)v21 + 49) = v20;
      if (v23)
      {
        v24 = *(_DWORD *)(v22 + 12);
        if (v24 < v20)
        {
          v25 = *(_DWORD *)(v22 + 4);
          v26 = v25 * v20;
          *(_DWORD *)(v22 + 12) = v20;
          if (v25 * v20)
          {
            v27 = v25 * v24;
            v28 = (void *)operator new[]();
            if (v27 && (v29 = *(const void **)(v22 + 16)) != 0)
            {
              if (v27 >= v26)
                v30 = v26;
              else
                v30 = v27;
              v31 = v28;
              memcpy(v28, v29, v30);
            }
            else
            {
              v31 = v28;
            }
          }
          else
          {
            v31 = 0;
          }
          v121 = *(_QWORD *)(v22 + 16);
          if (v121)
            MEMORY[0x1B5E2914C](v121, 0x1000C8077774924);
          *(_QWORD *)(v22 + 16) = v31;
        }
        *(_DWORD *)(v22 + 8) = v20;
        result = *(_QWORD *)(a1 + 496);
        v74 = *(_DWORD *)(result + 244);
        v75 = *(_QWORD *)result;
        if (!*(_QWORD *)result)
        {
LABEL_101:
          if (v74 > 0)
            result = HGArrayDataRef::allocate((HGArrayDataRef *)result, 4, v74, v74);
          goto LABEL_160;
        }
      }
      else
      {
        if (v20 > 0)
          HGArrayDataRef::allocate(v21, 4, v15 + v19, v15 + v19);
        result = *(_QWORD *)(a1 + 496);
        v74 = *(_DWORD *)(result + 244);
        v75 = *(_QWORD *)result;
        if (!*(_QWORD *)result)
          goto LABEL_101;
      }
      v76 = *(_DWORD *)(v75 + 12);
      if (v76 < v74)
      {
        v77 = *(_DWORD *)(v75 + 4);
        v78 = v77 * v74;
        *(_DWORD *)(v75 + 12) = v74;
        if (v77 * v74)
        {
          v79 = v77 * v76;
          v80 = (void *)operator new[]();
          if (v79 && (v81 = *(const void **)(v75 + 16)) != 0)
          {
            if (v79 >= v78)
              v82 = v78;
            else
              v82 = v79;
            v83 = v80;
            memcpy(v80, v81, v82);
          }
          else
          {
            v83 = v80;
          }
        }
        else
        {
          v83 = 0;
        }
        result = *(_QWORD *)(v75 + 16);
        if (result)
          result = MEMORY[0x1B5E2914C](result, 0x1000C8077774924);
        *(_QWORD *)(v75 + 16) = v83;
      }
      *(_DWORD *)(v75 + 8) = v74;
LABEL_160:
      v34 = 3 * v19;
      v161 = *(uint64_t **)(a1 + 496);
      if (v6 >= 3)
      {
        v162 = v161[6];
        v163 = *(_QWORD *)(v162 + 16);
        v164 = *v161;
        v165 = *(_QWORD *)(*v161 + 16);
        if (v19 <= 1)
          v166 = 1;
        else
          v166 = v6 / 3;
        v167 = v15;
        do
        {
          *(_DWORD *)(v163 + *(int *)(v162 + 4) * (uint64_t)v167 + *((int *)v161 + 14)) = 3;
          *(_DWORD *)(v165 + *(int *)(v164 + 4) * (uint64_t)v167 + *((int *)v161 + 2)) = v17;
          v17 += 3;
          ++v167;
          --v166;
        }
        while (v166);
      }
      v168 = v161 + 2;
      v169 = v161[2];
      if (!v169)
      {
        v170 = (unsigned int *)*a3;
        if (!*a3)
          goto LABEL_179;
        *v168 = v170;
        goto LABEL_178;
      }
      if (*(_DWORD *)(v169 + 8))
      {
        result = (uint64_t)HGArray<short,(HGFormat)3>::append((HGArrayDataRef *)(v161 + 2), a3);
        goto LABEL_241;
      }
      if (v169 != *a3)
      {
        do
        {
          v171 = __ldaxr((unsigned int *)v169);
          v172 = v171 - 1;
        }
        while (__stlxr(v172, (unsigned int *)v169));
        if (!v172)
        {
          v173 = *(_QWORD *)(v169 + 16);
          if (v173)
            MEMORY[0x1B5E2914C](v173, 0x1000C8077774924);
          result = MEMORY[0x1B5E29170](v169, 0x1080C4098BBCF0FLL);
        }
        v170 = (unsigned int *)*a3;
        *v168 = *a3;
        if (v170)
        {
          do
LABEL_178:
            v174 = __ldaxr(v170);
          while (__stlxr(v174 + 1, v170));
        }
      }
LABEL_179:
      v161[3] = a3[1];
      goto LABEL_241;
    case 1:
      v33 = v6 - 2;
      v34 = 3 * v33;
      v35 = v15 + v33;
      v38 = *(_QWORD *)(v7 + 48);
      v36 = (HGArrayDataRef *)(v7 + 48);
      v37 = v38;
      *((_DWORD *)v36 + 49) = v15 + v33;
      if (v38)
      {
        v39 = *(_DWORD *)(v37 + 12);
        if (v39 < v35)
        {
          v40 = *(_DWORD *)(v37 + 4);
          v41 = v40 * v35;
          *(_DWORD *)(v37 + 12) = v35;
          if (v40 * v35)
          {
            v42 = v40 * v39;
            v43 = (void *)operator new[]();
            if (v42 && (v44 = *(const void **)(v37 + 16)) != 0)
            {
              if (v42 >= v41)
                v45 = v41;
              else
                v45 = v42;
              v46 = v43;
              memcpy(v43, v44, v45);
            }
            else
            {
              v46 = v43;
            }
          }
          else
          {
            v46 = 0;
          }
          v122 = *(_QWORD *)(v37 + 16);
          if (v122)
            MEMORY[0x1B5E2914C](v122, 0x1000C8077774924);
          *(_QWORD *)(v37 + 16) = v46;
        }
        *(_DWORD *)(v37 + 8) = v35;
        v123 = *(_QWORD *)(a1 + 496);
        v124 = *(_QWORD *)(v123 + 16);
        v85 = (HGArrayDataRef *)(v123 + 16);
        v86 = v124;
        if (!v124)
          goto LABEL_109;
      }
      else
      {
        if (v35 > 0)
          HGArrayDataRef::allocate(v36, 4, v15 + v33, v15 + v33);
        v84 = *(_QWORD *)(a1 + 496);
        v87 = *(_QWORD *)(v84 + 16);
        v85 = (HGArrayDataRef *)(v84 + 16);
        v86 = v87;
        if (!v87)
        {
LABEL_109:
          if (v34 > 0)
            HGArrayDataRef::allocate(v85, 2, 3 * v33, 3 * v33);
          result = *(_QWORD *)(a1 + 496);
          v125 = *(_DWORD *)(result + 244);
          v126 = *(_QWORD *)result;
          if (*(_QWORD *)result)
            goto LABEL_112;
LABEL_186:
          if (v125 > 0)
            result = HGArrayDataRef::allocate((HGArrayDataRef *)result, 4, v125, v125);
          if (v33)
            goto LABEL_216;
          goto LABEL_240;
        }
      }
      v88 = *(_DWORD *)(v86 + 12);
      v89 = *(_DWORD *)(v86 + 8) + v34;
      if (v88 < v89)
      {
        v90 = *(_DWORD *)(v86 + 4);
        v91 = v90 * v89;
        *(_DWORD *)(v86 + 12) = v89;
        if (v90 * v89)
        {
          v92 = v90 * v88;
          v93 = (void *)operator new[]();
          if (v92 && (v94 = *(const void **)(v86 + 16)) != 0)
          {
            if (v92 >= v91)
              v95 = v91;
            else
              v95 = v92;
            v96 = v93;
            memcpy(v93, v94, v95);
          }
          else
          {
            v96 = v93;
          }
        }
        else
        {
          v96 = 0;
        }
        v175 = *(_QWORD *)(v86 + 16);
        if (v175)
          MEMORY[0x1B5E2914C](v175, 0x1000C8077774924);
        *(_QWORD *)(v86 + 16) = v96;
      }
      *(_DWORD *)(v86 + 8) = v89;
      result = *(_QWORD *)(a1 + 496);
      v125 = *(_DWORD *)(result + 244);
      v126 = *(_QWORD *)result;
      if (!*(_QWORD *)result)
        goto LABEL_186;
LABEL_112:
      v127 = *(_DWORD *)(v126 + 12);
      if (v127 < v125)
      {
        v128 = *(_DWORD *)(v126 + 4);
        v129 = v128 * v125;
        *(_DWORD *)(v126 + 12) = v125;
        if (v128 * v125)
        {
          v130 = v128 * v127;
          v131 = (void *)operator new[]();
          if (v130 && (v132 = *(const void **)(v126 + 16)) != 0)
          {
            if (v130 >= v129)
              v133 = v129;
            else
              v133 = v130;
            v134 = v131;
            memcpy(v131, v132, v133);
          }
          else
          {
            v134 = v131;
          }
        }
        else
        {
          v134 = 0;
        }
        result = *(_QWORD *)(v126 + 16);
        if (result)
          result = MEMORY[0x1B5E2914C](result, 0x1000C8077774924);
        *(_QWORD *)(v126 + 16) = v134;
      }
      *(_DWORD *)(v126 + 8) = v125;
      if (v33)
      {
LABEL_216:
        v180 = 0;
        v181 = *a3;
        v182 = *(_QWORD *)(*a3 + 16);
        v183 = *(uint64_t **)(a1 + 496);
        v184 = v183[2];
        v185 = *(_QWORD *)(v184 + 16);
        v186 = *v183;
        v187 = *(_QWORD *)(*v183 + 16);
        v188 = v183[6];
        v189 = *(_QWORD *)(v188 + 16);
        result = 3;
        v190 = v17;
        do
        {
          v191 = *(_DWORD *)(v181 + 4);
          v192 = *((int *)a3 + 2);
          v193 = *(_DWORD *)(v184 + 4);
          v194 = v193 * v190;
          v195 = *((int *)v183 + 6);
          *(_WORD *)(v185 + v194 + v195) = *(_WORD *)(v182 + (int)(v191 * v180) + v192);
          *(_WORD *)(v185 + v193 + v194 + v195) = *(_WORD *)(v182 + (int)(v191 + v191 * v180) + v192);
          v196 = v15 + v180;
          *(_WORD *)(v185 + v193 * (v190 + 2) + v195) = *(_WORD *)(v182 + (int)(v191 * (v180 + 2)) + v192);
          *(_DWORD *)(v187 + *(int *)(v186 + 4) * (uint64_t)v196 + *((int *)v183 + 2)) = v190;
          *(_DWORD *)(v189 + *(int *)(v188 + 4) * (uint64_t)v196 + *((int *)v183 + 14)) = 3;
          v190 += 6;
          v180 += 2;
        }
        while (v180 < v33);
        if (v33 >= 2)
        {
          v197 = *a3;
          v198 = *(_QWORD *)(*a3 + 16);
          v199 = *(uint64_t **)(a1 + 496);
          v200 = v199[2];
          v201 = *(_QWORD *)(v200 + 16);
          v202 = *v199;
          v203 = *(_QWORD *)(*v199 + 16);
          v204 = v199[6];
          v205 = *(_QWORD *)(v204 + 16);
          v206 = v17 + 3;
          v207 = 1;
          result = 3;
          do
          {
            v208 = *(_DWORD *)(v197 + 4);
            v209 = *((int *)a3 + 2);
            v210 = *(_DWORD *)(v200 + 4);
            v211 = v210 * v206;
            v212 = *((int *)v199 + 6);
            *(_WORD *)(v201 + v211 + v212) = *(_WORD *)(v198 + (int)(v208 + v208 * v207) + v209);
            *(_WORD *)(v201 + v210 + v211 + v212) = *(_WORD *)(v198 + (int)(v208 * v207) + v209);
            v213 = v15 + v207;
            *(_WORD *)(v201 + v210 * (v206 + 2) + v212) = *(_WORD *)(v198 + (int)(v208 * (v207 + 2)) + v209);
            *(_DWORD *)(v203 + *(int *)(v202 + 4) * (uint64_t)v213 + *((int *)v199 + 2)) = v206;
            *(_DWORD *)(v205 + *(int *)(v204 + 4) * (uint64_t)v213 + *((int *)v199 + 14)) = 3;
            v206 += 6;
            v207 += 2;
          }
          while (v207 < v33);
        }
        goto LABEL_241;
      }
LABEL_240:
      v34 = 0;
LABEL_241:
      if (v15 && *(_DWORD *)(a1 + 1092) == 4)
      {
        v246 = *(_QWORD *)(*(_QWORD *)(a1 + 1144) + 16)
             + *(int *)(*(_QWORD *)(a1 + 1144) + 4) * (*(int *)(*(_QWORD *)(a1 + 1144) + 8) - 1);
        *(_DWORD *)(v246 + *(int *)(a1 + 1152)) += v34;
      }
      else
      {
        *(_DWORD *)(a1 + 1092) = 4;
        *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(a1 + 1144)) = v34;
        *(_DWORD *)HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(a1 + 1160)) = 4;
        result = HGArray<int,(HGFormat)34>::append((HGArrayDataRef *)(a1 + 1176));
        *(_DWORD *)result = v15;
      }
      return result;
    case 2:
      v47 = v6 - 2;
      v48 = v15 + v6 - 2;
      v51 = *(_QWORD *)(v7 + 48);
      v49 = (HGArrayDataRef *)(v7 + 48);
      v50 = v51;
      *((_DWORD *)v49 + 49) = v48;
      if (v51)
      {
        v52 = *(_DWORD *)(v50 + 12);
        if (v52 < v48)
        {
          v53 = *(_DWORD *)(v50 + 4);
          v54 = v53 * v48;
          *(_DWORD *)(v50 + 12) = v48;
          if (v53 * v48)
          {
            v55 = v53 * v52;
            v56 = (void *)operator new[]();
            if (v55 && (v57 = *(const void **)(v50 + 16)) != 0)
            {
              if (v55 >= v54)
                v58 = v54;
              else
                v58 = v55;
              v59 = v56;
              memcpy(v56, v57, v58);
            }
            else
            {
              v59 = v56;
            }
          }
          else
          {
            v59 = 0;
          }
          v135 = *(_QWORD *)(v50 + 16);
          if (v135)
            MEMORY[0x1B5E2914C](v135, 0x1000C8077774924);
          *(_QWORD *)(v50 + 16) = v59;
        }
        *(_DWORD *)(v50 + 8) = v48;
        v34 = 3 * v47;
        v97 = *(HGArrayDataRef **)(a1 + 496);
        v98 = *((_DWORD *)v97 + 61);
        v99 = *(_QWORD *)v97;
        if (!*(_QWORD *)v97)
          goto LABEL_126;
      }
      else
      {
        if (v48 > 0)
          HGArrayDataRef::allocate(v49, 4, v15 + v47, v15 + v47);
        v34 = 3 * v47;
        v97 = *(HGArrayDataRef **)(a1 + 496);
        v98 = *((_DWORD *)v97 + 61);
        v99 = *(_QWORD *)v97;
        if (!*(_QWORD *)v97)
        {
LABEL_126:
          if (v98 > 0)
            HGArrayDataRef::allocate(v97, 4, v98, v98);
          v136 = *(_QWORD *)(a1 + 496);
          v138 = *(_QWORD *)(v136 + 16);
          result = v136 + 16;
          v137 = v138;
          if (v138)
            goto LABEL_129;
          goto LABEL_196;
        }
      }
      v100 = *(_DWORD *)(v99 + 12);
      if (v100 < v98)
      {
        v101 = *(_DWORD *)(v99 + 4);
        v102 = v101 * v98;
        *(_DWORD *)(v99 + 12) = v98;
        if (v101 * v98)
        {
          v248 = v34;
          v103 = v101 * v100;
          v104 = (void *)operator new[]();
          if (v103 && (v105 = *(const void **)(v99 + 16)) != 0)
          {
            if (v103 >= v102)
              v106 = v102;
            else
              v106 = v103;
            v107 = v104;
            memcpy(v104, v105, v106);
            v34 = v248;
          }
          else
          {
            v34 = v248;
            v107 = v104;
          }
        }
        else
        {
          v107 = 0;
        }
        v176 = *(_QWORD *)(v99 + 16);
        if (v176)
          MEMORY[0x1B5E2914C](v176, 0x1000C8077774924);
        *(_QWORD *)(v99 + 16) = v107;
      }
      *(_DWORD *)(v99 + 8) = v98;
      v177 = *(_QWORD *)(a1 + 496);
      v178 = *(_QWORD *)(v177 + 16);
      result = v177 + 16;
      v137 = v178;
      if (v178)
      {
LABEL_129:
        v139 = *(_DWORD *)(v137 + 12);
        v140 = *(_DWORD *)(v137 + 8) + v34;
        if (v139 < v140)
        {
          v141 = *(_DWORD *)(v137 + 4);
          v142 = v141 * v140;
          *(_DWORD *)(v137 + 12) = v140;
          if (v141 * v140)
          {
            v249 = v34;
            v143 = v141 * v139;
            v144 = (void *)operator new[]();
            if (v143 && (v145 = *(const void **)(v137 + 16)) != 0)
            {
              if (v143 >= v142)
                v146 = v142;
              else
                v146 = v143;
              v147 = v144;
              memcpy(v144, v145, v146);
              v34 = v249;
            }
            else
            {
              v34 = v249;
              v147 = v144;
            }
          }
          else
          {
            v147 = 0;
          }
          result = *(_QWORD *)(v137 + 16);
          if (result)
            result = MEMORY[0x1B5E2914C](result, 0x1000C8077774924);
          *(_QWORD *)(v137 + 16) = v147;
        }
        *(_DWORD *)(v137 + 8) = v140;
        if (v6 == 2)
          goto LABEL_240;
LABEL_228:
        v214 = *a3;
        v215 = *(_QWORD *)(*a3 + 16);
        v216 = *(uint64_t **)(a1 + 496);
        v217 = v216[2];
        v218 = *(_QWORD *)(v217 + 16);
        v219 = *v216;
        v220 = *(_QWORD *)(*v216 + 16);
        v221 = v216[6];
        v222 = *(_QWORD *)(v221 + 16);
        v223 = 2;
        result = 3;
        do
        {
          v224 = (_WORD *)(v215 + *((int *)a3 + 2));
          v225 = *(_DWORD *)(v217 + 4);
          v226 = *((int *)v216 + 6);
          *(_WORD *)(v218 + v225 * v17 + v226) = *v224;
          v227 = *(_DWORD *)(v214 + 4);
          *(_WORD *)(v218 + v225 + v225 * v17 + v226) = *(_WORD *)((char *)v224 + v227 * (v223 - 1));
          *(_WORD *)(v218 + v225 * (v17 + 2) + v226) = *(_WORD *)((char *)v224 + v227 * v223);
          LODWORD(v224) = v15 + v223 - 2;
          *(_DWORD *)(v220 + *(int *)(v219 + 4) * (uint64_t)(int)v224 + *((int *)v216 + 2)) = v17;
          *(_DWORD *)(v222 + *(int *)(v221 + 4) * (uint64_t)(int)v224 + *((int *)v216 + 14)) = 3;
          ++v223;
          v17 += 3;
        }
        while (v6 != v223);
        goto LABEL_241;
      }
LABEL_196:
      if (v34 > 0)
        result = HGArrayDataRef::allocate((HGArrayDataRef *)result, 2, v34, v34);
      if (v6 == 2)
        goto LABEL_240;
      goto LABEL_228;
    case 3:
      v60 = (v6 >> 1) & 0x7FFFFFFE;
      v61 = 3 * v60;
      v62 = v15 + v60;
      v65 = *(_QWORD *)(v7 + 48);
      v63 = (HGArrayDataRef *)(v7 + 48);
      v64 = v65;
      *((_DWORD *)v63 + 49) = v15 + v60;
      if (v65)
      {
        v66 = *(_DWORD *)(v64 + 12);
        if (v66 < v62)
        {
          v67 = *(_DWORD *)(v64 + 4);
          v68 = v67 * v62;
          *(_DWORD *)(v64 + 12) = v62;
          if (v67 * v62)
          {
            v69 = v67 * v66;
            v70 = (void *)operator new[]();
            if (v69 && (v71 = *(const void **)(v64 + 16)) != 0)
            {
              if (v69 >= v68)
                v72 = v68;
              else
                v72 = v69;
              v73 = v70;
              memcpy(v70, v71, v72);
            }
            else
            {
              v73 = v70;
            }
          }
          else
          {
            v73 = 0;
          }
          v148 = *(_QWORD *)(v64 + 16);
          if (v148)
            MEMORY[0x1B5E2914C](v148, 0x1000C8077774924);
          *(_QWORD *)(v64 + 16) = v73;
        }
        *(_DWORD *)(v64 + 8) = v62;
        v149 = *(_QWORD *)(a1 + 496);
        v150 = *(_QWORD *)(v149 + 16);
        v109 = (HGArrayDataRef *)(v149 + 16);
        v110 = v150;
        if (!v150)
          goto LABEL_143;
      }
      else
      {
        if (v62 > 0)
          HGArrayDataRef::allocate(v63, 4, v15 + v60, v15 + v60);
        v108 = *(_QWORD *)(a1 + 496);
        v111 = *(_QWORD *)(v108 + 16);
        v109 = (HGArrayDataRef *)(v108 + 16);
        v110 = v111;
        if (!v111)
        {
LABEL_143:
          if (v61 > 0)
            HGArrayDataRef::allocate(v109, 2, 3 * v60, 3 * v60);
          result = *(_QWORD *)(a1 + 496);
          v151 = *(_DWORD *)(result + 244);
          v152 = *(_QWORD *)result;
          if (*(_QWORD *)result)
            goto LABEL_146;
          goto LABEL_206;
        }
      }
      v112 = *(_DWORD *)(v110 + 12);
      v113 = *(_DWORD *)(v110 + 8) + v61;
      if (v112 < v113)
      {
        v114 = *(_DWORD *)(v110 + 4);
        v115 = v114 * v113;
        *(_DWORD *)(v110 + 12) = v113;
        if (v114 * v113)
        {
          v116 = v114 * v112;
          v117 = (void *)operator new[]();
          if (v116 && (v118 = *(const void **)(v110 + 16)) != 0)
          {
            if (v116 >= v115)
              v119 = v115;
            else
              v119 = v116;
            v120 = v117;
            memcpy(v117, v118, v119);
          }
          else
          {
            v120 = v117;
          }
        }
        else
        {
          v120 = 0;
        }
        v179 = *(_QWORD *)(v110 + 16);
        if (v179)
          MEMORY[0x1B5E2914C](v179, 0x1000C8077774924);
        *(_QWORD *)(v110 + 16) = v120;
      }
      *(_DWORD *)(v110 + 8) = v113;
      result = *(_QWORD *)(a1 + 496);
      v151 = *(_DWORD *)(result + 244);
      v152 = *(_QWORD *)result;
      if (*(_QWORD *)result)
      {
LABEL_146:
        v153 = *(_DWORD *)(v152 + 12);
        if (v153 < v151)
        {
          v154 = *(_DWORD *)(v152 + 4);
          v155 = v154 * v151;
          *(_DWORD *)(v152 + 12) = v151;
          if (v154 * v151)
          {
            v156 = v154 * v153;
            v157 = (void *)operator new[]();
            if (v156 && (v158 = *(const void **)(v152 + 16)) != 0)
            {
              if (v156 >= v155)
                v159 = v155;
              else
                v159 = v156;
              v160 = v157;
              memcpy(v157, v158, v159);
            }
            else
            {
              v160 = v157;
            }
          }
          else
          {
            v160 = 0;
          }
          result = *(_QWORD *)(v152 + 16);
          if (result)
            result = MEMORY[0x1B5E2914C](result, 0x1000C8077774924);
          *(_QWORD *)(v152 + 16) = v160;
        }
        *(_DWORD *)(v152 + 8) = v151;
        if (!v60)
          goto LABEL_240;
LABEL_237:
        v228 = *(uint64_t **)(a1 + 496);
        v229 = *v228;
        v230 = *(_QWORD *)(*v228 + 16);
        v231 = v228[6];
        v232 = *(_QWORD *)(v231 + 16);
        v233 = *a3;
        v234 = *(_QWORD *)(*a3 + 16);
        v235 = v228[2];
        v236 = *(_QWORD *)(v235 + 16);
        v237 = v17 + 2;
        LODWORD(result) = 1;
        do
        {
          v238 = v15 + result - 1;
          *(_DWORD *)(v230 + *(int *)(v229 + 4) * (uint64_t)v238 + *((int *)v228 + 2)) = v237 - 2;
          *(_DWORD *)(v230 + *(int *)(v229 + 4) * (uint64_t)(v15 + (int)result) + *((int *)v228 + 2)) = v237 + 1;
          *(_DWORD *)(v232 + *(int *)(v231 + 4) * (uint64_t)v238 + *((int *)v228 + 14)) = 3;
          *(_DWORD *)(v232 + *(int *)(v231 + 4) * (uint64_t)(v15 + (int)result) + *((int *)v228 + 14)) = 3;
          v239 = *(_DWORD *)(v233 + 4);
          v240 = v234 + v239 * ((int)result - 1);
          v241 = *((int *)a3 + 2);
          v242 = *(_DWORD *)(v235 + 4);
          v243 = *((int *)v228 + 6);
          *(_WORD *)(v236 + v242 * (v237 - 2) + v243) = *(_WORD *)(v240 + v241);
          *(_WORD *)(v236 + v242 * (v237 - 1) + v243) = *(_WORD *)(v234 + v239 * (int)result + v241);
          v244 = result + 1;
          v245 = v234 + v239 * ((int)result + 1);
          *(_WORD *)(v236 + v242 * v237 + v243) = *(_WORD *)(v245 + v241);
          *(_WORD *)(v236 + v242 * (v237 + 1) + v243) = *(_WORD *)(v240 + v241);
          *(_WORD *)(v236 + v242 * (v237 + 2) + v243) = *(_WORD *)(v245 + v241);
          result = (result + 2);
          *(_WORD *)(v236 + v242 * (v237 + 3) + v243) = *(_WORD *)(v234 + v239 * (int)result + v241);
          v237 += 6;
        }
        while (v244 < v60);
        v34 = 3 * v60;
        goto LABEL_241;
      }
LABEL_206:
      if (v151 > 0)
        result = HGArrayDataRef::allocate((HGArrayDataRef *)result, 4, v151, v151);
      if (!v60)
        goto LABEL_240;
      goto LABEL_237;
    default:
      goto LABEL_23;
  }
}

void HGRasterizer::GeometryRenderPage(HGRasterizer *this, HGPage *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  GLint v7;
  uint64_t v8;
  uint64_t v9;
  GLsizeiptr v10;
  uint64_t v11;
  const GLvoid *v12;
  uint64_t v13;
  int v14;
  int v15;
  GLint v16;
  uint64_t v17;
  uint64_t v18;
  GLsizeiptr v19;
  uint64_t v20;
  const GLvoid *v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  GLint v28;
  GLsizeiptr v29;
  const GLvoid *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  GLuint v36;
  int i;
  const GLvoid *v38;
  int v39;
  GLenum v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  GLuint v47;
  GLuint buffers[2];
  GLuint buffer[8];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)this + 143);
  if (v3)
    v4 = *(_DWORD *)(v3 + 8);
  else
    v4 = 0;
  buffers[1] = 0;
  glGenVertexArraysOES();
  glBindVertexArrayOES();
  v5 = *(_DWORD *)(*((_QWORD *)this + 63) + 92);
  if (v5 == 21)
    v6 = 3;
  else
    v6 = 2;
  if (v5 == 28)
    v7 = 4;
  else
    v7 = v6;
  buffers[0] = 0;
  glGenBuffers(1, buffers);
  glBindBuffer(0x8892u, buffers[0]);
  v8 = *((_QWORD *)this + 63);
  v9 = *(_QWORD *)(v8 + 80);
  if (v9)
  {
    v10 = *(int *)(v9 + 8) * (uint64_t)*(int *)(v9 + 4);
    v11 = *(_QWORD *)(v9 + 16);
    if (v11)
    {
      v12 = (const GLvoid *)(v11 + *(int *)(v8 + 88));
      goto LABEL_15;
    }
  }
  else
  {
    v10 = 0;
  }
  v12 = 0;
LABEL_15:
  glBufferData(0x8892u, v10, v12, 0x88E4u);
  glEnableVertexAttribArray(0);
  glVertexAttribPointer(0, v7, 0x1406u, 0, 0, 0);
  v13 = *((_QWORD *)this + 63);
  v45 = v4;
  if (*(_BYTE *)(v13 + 240))
  {
    v14 = *(_DWORD *)(v13 + 76);
    if (v14 == 21)
      v15 = 3;
    else
      v15 = 2;
    if (v14 == 28)
      v16 = 4;
    else
      v16 = v15;
    buffer[0] = 0;
    glGenBuffers(1, buffer);
    glBindBuffer(0x8892u, buffer[0]);
    v17 = *((_QWORD *)this + 63);
    v18 = *(_QWORD *)(v17 + 64);
    if (v18)
    {
      v19 = *(int *)(v18 + 8) * (uint64_t)*(int *)(v18 + 4);
      v20 = *(_QWORD *)(v18 + 16);
      if (v20)
      {
        v21 = (const GLvoid *)(v20 + *(int *)(v17 + 72));
LABEL_28:
        glBufferData(0x8892u, v19, v21, 0x88E4u);
        glEnableVertexAttribArray(1u);
        glVertexAttribPointer(1u, v16, 0x1406u, 0, 0, 0);
        goto LABEL_29;
      }
    }
    else
    {
      v19 = 0;
    }
    v21 = 0;
    goto LABEL_28;
  }
  glDisableVertexAttribArray(1u);
LABEL_29:
  v22 = 0;
  v23 = 0;
  v24 = 0;
  do
  {
    buffer[v22] = 0;
    if (((*((_DWORD *)this + 267) >> v22) & 1) == 0)
    {
      v25 = v22 + 1;
      goto LABEL_31;
    }
    v26 = *(_DWORD *)(*((_QWORD *)this + 63) + 16 * v22 + 124);
    if (v26 == 21)
      v27 = 3;
    else
      v27 = 2;
    if (v26 == 28)
      v28 = 4;
    else
      v28 = v27;
    v25 = v22 + 1;
    v24 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)a2 + 29) + 168))(*((_QWORD *)a2 + 29), 10, v22 + 1);
    if (v23 < v24)
    {
      while (1)
      {
        glGenBuffers(1, &buffer[v22]);
        glBindBuffer(0x8892u, buffer[v22]);
        v31 = *((_QWORD *)this + 63) + 16 * v22;
        v34 = *(_QWORD *)(v31 + 112);
        v32 = v31 + 112;
        v33 = v34;
        if (v34)
        {
          v29 = *(int *)(v33 + 8) * (uint64_t)*(int *)(v33 + 4);
          v35 = *(_QWORD *)(v33 + 16);
          if (v35)
          {
            v30 = (const GLvoid *)(v35 + *(int *)(v32 + 8));
            goto LABEL_43;
          }
        }
        else
        {
          v29 = 0;
        }
        v30 = 0;
LABEL_43:
        glBufferData(0x8892u, v29, v30, 0x88E4u);
        glEnableVertexAttribArray(v23 + 8);
        glVertexAttribPointer(v23 + 8, v28, 0x1406u, 0, 0, 0);
        if (v24 == ++v23)
        {
          v23 = v24;
          break;
        }
      }
    }
LABEL_31:
    v22 = v25;
  }
  while (v25 != 8);
  if (v24 <= 7)
  {
    v36 = v24 + 8;
    do
      glDisableVertexAttribArray(v36++);
    while (v36 != 16);
  }
  glDisableVertexAttribArray(2u);
  if (v45)
  {
    for (i = 0; i != v45; ++i)
    {
      v39 = *(_DWORD *)(*(_QWORD *)(**((_QWORD **)this + 63) + 16)
                      + *(int *)(**((_QWORD **)this + 63) + 4)
                      * (uint64_t)*(int *)(*(_QWORD *)(*((_QWORD *)this + 147) + 16)
                                        + *(int *)(*((_QWORD *)this + 147) + 4) * (uint64_t)i
                                        + *((int *)this + 296))
                      + *(int *)(*((_QWORD *)this + 63) + 8));
      v40 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 145) + 16)
                      + *(int *)(*((_QWORD *)this + 145) + 4) * (uint64_t)i
                      + *((int *)this + 292));
      v41 = *(unsigned int *)(*(_QWORD *)(*((_QWORD *)this + 143) + 16)
                            + *(int *)(*((_QWORD *)this + 143) + 4) * (uint64_t)i
                            + *((int *)this + 288));
      v47 = 0;
      glGenBuffers(1, &v47);
      glBindBuffer(0x8893u, v47);
      v42 = *((_QWORD *)this + 63);
      v43 = *(_QWORD *)(v42 + 16);
      if (v43 && (v44 = *(_QWORD *)(v43 + 16)) != 0)
        v38 = (const GLvoid *)(v44 + *(int *)(v43 + 4) * (uint64_t)v39 + *(int *)(v42 + 24));
      else
        v38 = 0;
      glBufferData(0x8893u, 2 * v41, v38, 0x88E4u);
      glDrawElements(v40, v41, 0x1403u, 0);
    }
  }
  glDisableVertexAttribArray(0);
  glDisableVertexAttribArray(1u);
  glDisableVertexAttribArray(2u);
  glDisableVertexAttribArray(8u);
  glDisableVertexAttribArray(9u);
  glDisableVertexAttribArray(0xAu);
  glDisableVertexAttribArray(0xBu);
  glDisableVertexAttribArray(0xCu);
  glDisableVertexAttribArray(0xDu);
  glDisableVertexAttribArray(0xEu);
  glDisableVertexAttribArray(0xFu);
  v47 = 0;
  glBindVertexArrayOES();
  glGetVertexAttribiv(0, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(1u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(2u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(3u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(4u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(5u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(6u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(7u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(8u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(9u, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(0xAu, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(0xBu, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(0xCu, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(0xDu, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(0xEu, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetVertexAttribiv(0xFu, 0x889Fu, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glGetIntegerv(0x8895u, (GLint *)&v47);
  if (v47)
    glDeleteBuffers(1, &v47);
  glDeleteVertexArraysOES();
  glDisable(0xBE2u);
}

uint64_t HGRasterizer::RenderPageMetal(HGNode *this, HGPage *a2)
{
  uint64_t v4;
  _QWORD *v5;
  const char *v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  HGBitmap *v12;
  const void *v13;
  std::string *v14;
  std::string *v15;
  unsigned int v16;
  const char *v17;
  size_t v18;
  size_t v19;
  simd::float4x4 *p_dst;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  __n128 v24;
  HGBitmap *v25;
  HGBitmap *v26;
  HGBitmap *v27;
  HGBitmap *v28;
  HGBitmap *v29;
  HGBitmap *v30;
  HGBitmap *v31;
  HGBitmap *v32;
  float64x2_t Matrixfloat4x4;
  HGPage *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  simd_float4 v38;
  __n128 v39;
  __n128 *v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t MatrixPtr;
  __n128 v49;
  __int128 v50;
  uint64_t v51;
  simd_float4 v53;
  simd_float4 v54;
  uint64_t v55;
  simd_float4 v56;
  unsigned int v57;
  uint64_t v58;
  __int128 v59;
  uint64_t v60;
  simd::float4x4 __dst;
  _BYTE v62[16];
  HGPage *v63;
  char __str[256];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD *)((char *)a2 + 8);
  v4 = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = 0;
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v63, this, a2);
  *v5 = v4;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)a2 + 144))(*(_QWORD *)a2, 0);
  v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPageMetal( [%d %d %d %d])", v6, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v62, "gpu", 1, __str);
  v7 = *((_QWORD *)this + 153);
  if (*(_BYTE *)(v7 + 12) && !*(_DWORD *)(v7 + 16))
    v8 = *(_DWORD *)(v7 + 20);
  else
    v8 = 1;
  if (((*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 592))(this) & 2) != 0)
  {
    v9 = 1;
    if (!v4)
      goto LABEL_7;
LABEL_9:
    (*(void (**)(_QWORD))(**((_QWORD **)a2 + 1) + 16))(*((_QWORD *)a2 + 1));
    goto LABEL_10;
  }
  v9 = ((*(unsigned int (**)(HGNode *))(*(_QWORD *)this + 592))(this) >> 3) & 1;
  if (v4)
    goto LABEL_9;
LABEL_7:
  *((_QWORD *)a2 + 1) = HGGPURenderer::CreateBuffer(*(_QWORD *)a2, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 1, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
LABEL_10:
  if (((*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 592))(this) & 1) != 0
    && ((*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 592))(this) & 0x10) == 0)
  {
    HGGPURenderer::ClearMetal(*(HGGPURenderer **)a2, *((HGBitmap **)a2 + 1), *((HGRect *)a2 + 1), v10);
  }
  if (!*((_BYTE *)this + 1077) || (v11 = *((_QWORD *)this + 95)) == 0)
    v11 = *((_QWORD *)this + 94);
  v12 = (HGBitmap *)*((_QWORD *)a2 + 1);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 160))(v11, *(unsigned int *)(*((_QWORD *)this + 54) + 160));
  v13 = (const void *)(*(uint64_t (**)(_QWORD, _QWORD, HGNode *))(**(_QWORD **)a2 + 368))(*(_QWORD *)a2, *((_QWORD *)this + 8), this);
  if (v13)
  {
    if (v14)
    {
      v15 = v14;
      v57 = v8;
      v16 = v9;
      v17 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
      v18 = strlen(v17);
      if (v18 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      v19 = v18;
      if (v18 >= 0x17)
      {
        v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v18 | 7) != 0x17)
          v21 = v18 | 7;
        v22 = v21 + 1;
        p_dst = (simd::float4x4 *)operator new(v21 + 1);
        __dst.columns[0].i64[1] = v19;
        __dst.columns[1].i64[0] = v22 | 0x8000000000000000;
        __dst.columns[0].i64[0] = (uint64_t)p_dst;
      }
      else
      {
        __dst.columns[1].i8[7] = v18;
        p_dst = &__dst;
        if (!v18)
        {
LABEL_26:
          p_dst->columns[0].i8[v19] = 0;
          HGMetalHandler::SetDebugLabel(v15, (const std::string *)&__dst);
          v23 = v16;
          if (__dst.columns[1].i8[7] < 0)
            operator delete((void *)__dst.columns[0].i64[0]);
          HGMetalHandler::BindBuffer((HGMetalHandler *)v15, v12, (const char *)v57);
          if (v16)
            HGMetalHandler::EnableDepthBuffer(v15);
          v25 = (HGBitmap *)*((_QWORD *)a2 + 21);
          if (v25)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 0, v25);
          v26 = (HGBitmap *)*((_QWORD *)a2 + 22);
          if (v26)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 1, v26);
          v27 = (HGBitmap *)*((_QWORD *)a2 + 23);
          if (v27)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 2, v27);
          v28 = (HGBitmap *)*((_QWORD *)a2 + 24);
          if (v28)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 3, v28);
          v29 = (HGBitmap *)*((_QWORD *)a2 + 25);
          if (v29)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 4, v29);
          v30 = (HGBitmap *)*((_QWORD *)a2 + 26);
          if (v30)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 5, v30);
          v31 = (HGBitmap *)*((_QWORD *)a2 + 27);
          if (v31)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 6, v31);
          v32 = (HGBitmap *)*((_QWORD *)a2 + 28);
          if (v32)
            v24 = HGMetalHandler::BindTexture((HGMetalTexture ***)v15, 7, v32);
          (*(void (**)(HGNode *, HGPage *, _QWORD, std::string *, __n128))(*(_QWORD *)this + 488))(this, a2, 0, v15, v24);
          if (!HGTransform::IsIdentity((HGTransform *)((char *)this + 768)))
          {
            memset(&__dst, 0, sizeof(__dst));
            Matrixfloat4x4 = HGTransform::GetMatrixfloat4x4((float64x2_t *)this + 48, &__dst);
            (*(void (**)(std::string *, simd::float4x4 *, float64x2_t))(v15->__r_.__value_.__r.__words[0]
                                                                                 + 176))(v15, &__dst, Matrixfloat4x4);
          }
          HGMetalHandler::SetScissorRect((HGMetalHandler *)v15, (__n128 *)a2 + 1);
          HGMetalHandler::SetScissorTest((uint64_t)v15, 1);
          __dst.columns[0].i64[0] = 0;
          *(simd_float4 *)((char *)__dst.columns + 8) = (simd_float4)xmmword_1B309BAB0;
          __dst.columns[1].i64[1] = 0;
          if (*((_BYTE *)this + 1141))
            goto LABEL_53;
          v35 = HGNode::IsInPlaceHardwareBlendingEnabled(this);
          v36 = *(_QWORD *)this;
          if (v35)
          {
            v37 = (*(uint64_t (**)(HGNode *))(v36 + 256))(this);
            v38 = *(simd_float4 *)(v37 + 16);
            __dst.columns[0] = *(simd_float4 *)v37;
            __dst.columns[1] = v38;
          }
          else
          {
            if (((*(uint64_t (**)(HGNode *))(v36 + 592))(this) & 4) == 0)
            {
LABEL_53:
              if (*((_BYTE *)this + 1077))
              {
                v41 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)a2 + 29) + 168))(*((_QWORD *)a2 + 29), 3, 0);
                if (v41)
                {
                  v42 = 0;
                  v43 = 0;
                  v44 = v41;
                  do
                  {
                    v45 = v42 + 1;
                    v46 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)a2 + 29) + 168))(*((_QWORD *)a2 + 29), 10, v42 + 1);
                    if ((int)v43 < (int)v46)
                    {
                      v47 = (char *)this + 8 * v42 + 432;
                      do
                      {
                        (*(void (**)(std::string *, uint64_t))(v15->__r_.__value_.__r.__words[0] + 80))(v15, v43);
                        MatrixPtr = HGTransform::GetMatrixPtr((HGTransform *)(*(_QWORD *)v47 + 8));
                        (*(void (**)(std::string *, uint64_t))(v15->__r_.__value_.__r.__words[0] + 112))(v15, MatrixPtr);
                        v43 = (v43 + 1);
                      }
                      while ((_DWORD)v46 != (_DWORD)v43);
                      v43 = v46;
                    }
                    v42 = v45;
                  }
                  while (v45 != v44);
                }
              }
              HGRasterizer::GeometryRenderPageMetal((HGRasterizer *)this, v34, (HGMetalHandler *)v15);
              HGMetalHandler::SetScissorTest((uint64_t)v15, 0);
              HGMetalHandler::DisableBlending((uint64_t)v15);
              if (v23)
                HGMetalHandler::DisableDepthBuffer((HGMetalHandler *)v15);
              if (((*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 592))(this) & 4) != 0)
              {
                v58 = 0;
                *(_QWORD *)&v50 = 0x100000001;
                *((_QWORD *)&v50 + 1) = 0x100000001;
                v59 = v50;
                v60 = 0;
                v49 = HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v15, (const HGBlendingInfo *)&v58);
              }
              (*(void (**)(HGNode *, HGPage *, _QWORD, std::string *, __n128))(*(_QWORD *)this + 496))(this, a2, 0, v15, v49);
              goto LABEL_66;
            }
            switch((*(unsigned int (**)(HGNode *))(*(_QWORD *)this + 600))(this))
            {
              case 0u:
                __dst.columns[0].i64[0] = 0;
                v53 = (simd_float4)xmmword_1B3056FC0;
                goto LABEL_74;
              case 1u:
                __dst.columns[0].i64[0] = 0;
                v53 = (simd_float4)xmmword_1B309BAA0;
                goto LABEL_74;
              case 2u:
                __dst.columns[0].i64[0] = 0;
                v53.i64[0] = 0x100000001;
                v53.i64[1] = 0x100000001;
LABEL_74:
                *(simd_float4 *)((char *)__dst.columns + 8) = v53;
                __dst.columns[1].i64[1] = 0;
                break;
              case 3u:
                __dst.columns[0].i64[0] = 0;
                v56.i64[0] = 0x100000001;
                v56.i64[1] = 0x100000001;
                *(simd_float4 *)((char *)__dst.columns + 8) = v56;
                v55 = 0x400000004;
                goto LABEL_72;
              case 4u:
                __dst.columns[0].i64[0] = 0;
                v54.i64[0] = 0x100000001;
                v54.i64[1] = 0x100000001;
                *(simd_float4 *)((char *)__dst.columns + 8) = v54;
                v55 = 0x300000003;
LABEL_72:
                __dst.columns[1].i64[1] = v55;
                break;
              default:
                break;
            }
          }
          HGMetalHandler::EnableBlending((uint64_t)v15);
          v39 = HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v15, (const HGBlendingInfo *)&__dst);
          v40 = (__n128 *)(*(uint64_t (**)(HGNode *, __n128))(*(_QWORD *)this + 272))(this, v39);
          HGMetalHandler::SetBlendingColor((__n128 *)v15, v40);
          goto LABEL_53;
        }
      }
      memmove(p_dst, v17, v19);
      goto LABEL_26;
    }
  }
LABEL_66:
  v51 = *((_QWORD *)a2 + 1);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v62);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v63);
  return v51;
}

void sub_1B29D434C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,HGPage *a33)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a31);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&a33);
  _Unwind_Resume(a1);
}

uint64_t HGRasterizer::RenderPage(HGRasterizer *this, HGPage *a2)
{
  const char *v4;
  HGGPURenderer *v5;
  uint64_t v6;
  char *Buffer;
  char *v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  const char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  float64x2_t Matrixfloat4x4;
  char *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  const HGBlendingInfo *v40;
  GLenum Size;
  GLenum DstRGBFactor;
  GLenum v43;
  GLenum DstAlphaFactor;
  GLenum RGBOperation;
  GLenum AlphaOperation;
  int v47;
  GLenum v48;
  GLenum v49;
  GLenum v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t MatrixPtr;
  uint64_t v59;
  simd::float4x4 v61;
  HGPage *v62;
  char v63[16];
  char __str[256];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v4 = (const char *)(*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPage( [%d %d %d %d])", v4, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v63, "gpu", 1, __str);
  v5 = *(HGGPURenderer **)a2;
  v6 = *((_QWORD *)a2 + 1);
  if (v6)
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v5 + 144))(*(_QWORD *)a2, *((_QWORD *)a2 + 1));
  *((_QWORD *)a2 + 1) = 0;
  HGPagePullTexturesGuard::HGPagePullTexturesGuard((HGPagePullTexturesGuard *)&v62, (HGNode *)this, a2);
  *((_QWORD *)a2 + 1) = v6;
  if (v6)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
    Buffer = (char *)*((_QWORD *)a2 + 1);
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v5, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    *((_QWORD *)a2 + 1) = Buffer;
  }
  (*(void (**)(HGGPURenderer *, char *))(*(_QWORD *)v5 + 144))(v5, Buffer);
  if (((*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 592))(this) & 2) == 0)
    (*(void (**)(HGRasterizer *))(*(_QWORD *)this + 592))(this);
  v9 = *((_QWORD *)this + 153);
  if (!*(_BYTE *)(v9 + 12) || *(_DWORD *)(v9 + 16) || (v10 = *(_DWORD *)(v9 + 20), v10 < 2))
  {
    v11 = 0;
  }
  else
  {
    HGGPURenderer::BindMultiSampleBuffer(v5, v10, 0, 0, v8);
    v11 = 1;
  }
  if (((*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 592))(this) & 1) != 0
    && ((*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 592))(this) & 0x10) == 0)
  {
    HGGPURenderer::Clear(v5, *((HGRect *)a2 + 1), v12, v13);
  }
  v14 = (char *)*((_QWORD *)a2 + 1);
  v15 = *((_QWORD *)a2 + 21);
  v16 = *(_DWORD *)(*((_QWORD *)this + 54) + 160);
  if (v16 == -1)
    v16 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, _QWORD, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 0, v15, 0, v16 == 1);
  v17 = *((_QWORD *)a2 + 22);
  v18 = *(_DWORD *)(*((_QWORD *)this + 55) + 160);
  if (v18 == -1)
    v18 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 1, v17, 0, v18 == 1);
  v19 = *((_QWORD *)a2 + 23);
  v20 = *(_DWORD *)(*((_QWORD *)this + 56) + 160);
  if (v20 == -1)
    v20 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 2, v19, 0, v20 == 1);
  v21 = *((_QWORD *)a2 + 24);
  v22 = *(_DWORD *)(*((_QWORD *)this + 57) + 160);
  if (v22 == -1)
    v22 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 3, v21, 0, v22 == 1);
  v23 = *((_QWORD *)a2 + 25);
  v24 = *(_DWORD *)(*((_QWORD *)this + 58) + 160);
  if (v24 == -1)
    v24 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 4, v23, 0, v24 == 1);
  v25 = *((_QWORD *)a2 + 26);
  v26 = *(_DWORD *)(*((_QWORD *)this + 59) + 160);
  if (v26 == -1)
    v26 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 5, v25, 0, v26 == 1);
  v27 = *((_QWORD *)a2 + 27);
  v28 = *(_DWORD *)(*((_QWORD *)this + 60) + 160);
  if (v28 == -1)
    v28 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 6, v27, 0, v28 == 1);
  v29 = *((_QWORD *)a2 + 28);
  v30 = *(_DWORD *)(*((_QWORD *)this + 61) + 160);
  if (v30 == -1)
    v30 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(_QWORD *)v5 + 128))(v5, 23);
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t, _QWORD, BOOL))(*(_QWORD *)v5 + 152))(v5, 7, v29, 0, v30 == 1);
  glActiveTexture(0x84C0u);
  if (!*((_BYTE *)this + 1077) || (v31 = *((_QWORD *)this + 95)) == 0)
    v31 = *((_QWORD *)this + 94);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v31 + 160))(v31, *(unsigned int *)(*((_QWORD *)this + 54) + 160));
  v32 = (*(uint64_t (**)(HGGPURenderer *, _QWORD, HGRasterizer *))(*(_QWORD *)v5 + 368))(v5, *((_QWORD *)this + 8), this);
  (*(void (**)(HGRasterizer *, HGPage *, _QWORD, uint64_t))(*(_QWORD *)this + 488))(this, a2, 0, v32);
  if (!HGTransform::IsIdentity((HGRasterizer *)((char *)this + 768)))
  {
    memset(&v61, 0, sizeof(v61));
    Matrixfloat4x4 = HGTransform::GetMatrixfloat4x4((float64x2_t *)this + 48, &v61);
    (*(void (**)(uint64_t, simd::float4x4 *, float64x2_t))(*(_QWORD *)v32 + 176))(v32, &v61, Matrixfloat4x4);
  }
  if (v14)
  else
    v34 = 0;
  v35 = (uint64_t *)(v34 + 136);
  if (!v34)
    v35 = (uint64_t *)(v14 + 20);
  v36 = *v35;
  v37 = HGRectIntersection(*((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3), *v35, v35[1]);
  glScissor(v37 - v36, HIDWORD(v37) - HIDWORD(v36), v38 - v37, v39 - HIDWORD(v37));
  glEnable(0xC11u);
  if (!*((_BYTE *)this + 1141))
  {
    if (HGNode::IsInPlaceHardwareBlendingEnabled((HGNode *)this))
    {
      v40 = (const HGBlendingInfo *)(*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 256))(this);
      HGGLBlendingInfo::HGGLBlendingInfo((HGGLBlendingInfo *)&v61, v40);
      Size = PVPerfStats::FrameStats::GetSize((PVPerfStats::FrameStats *)&v61);
      DstRGBFactor = HGGLBlendingInfo::GetDstRGBFactor((HGGLBlendingInfo *)&v61);
      v43 = LiImageSource::imageSpace((LiImageSource *)&v61);
      DstAlphaFactor = HGGLBlendingInfo::GetDstAlphaFactor((HGGLBlendingInfo *)&v61);
      glBlendFuncSeparate(Size, DstRGBFactor, v43, DstAlphaFactor);
      RGBOperation = HGGLBlendingInfo::GetRGBOperation((HGGLBlendingInfo *)&v61);
      AlphaOperation = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)&v61);
      glBlendEquationSeparate(RGBOperation, AlphaOperation);
      glEnable(0xBE2u);
    }
    else if (((*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 592))(this) & 4) != 0)
    {
      glEnable(0xBE2u);
      v47 = (*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 600))(this);
      v48 = 32774;
      switch(v47)
      {
        case 0:
          glBlendEquation(0x8006u);
          v49 = 771;
          v50 = 1;
          goto LABEL_53;
        case 1:
          glBlendEquation(0x8006u);
          v49 = 1;
          v50 = 773;
          goto LABEL_53;
        case 2:
          goto LABEL_52;
        case 3:
          v48 = 32776;
          goto LABEL_52;
        case 4:
          v48 = 32775;
LABEL_52:
          glBlendEquation(v48);
          v50 = 1;
          v49 = 1;
LABEL_53:
          glBlendFunc(v50, v49);
          break;
        default:
          break;
      }
    }
    else
    {
      glDisable(0xBE2u);
    }
  }
  glEnable(0xDE1u);
  if (*((_BYTE *)this + 1077))
  {
    v51 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)a2 + 29) + 168))(*((_QWORD *)a2 + 29), 3, 0);
    if (v51)
    {
      v52 = 0;
      v53 = 0;
      v54 = v51;
      do
      {
        v55 = v52 + 1;
        v56 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)a2 + 29) + 168))(*((_QWORD *)a2 + 29), 10, v52 + 1);
        if ((int)v53 < (int)v56)
        {
          v57 = (char *)this + 8 * v52 + 432;
          do
          {
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v32 + 80))(v32, v53);
            MatrixPtr = HGTransform::GetMatrixPtr((HGTransform *)(*(_QWORD *)v57 + 8));
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v32 + 112))(v32, MatrixPtr);
            v53 = (v53 + 1);
          }
          while ((_DWORD)v56 != (_DWORD)v53);
          v53 = v56;
        }
        v52 = v55;
      }
      while (v55 != v54);
    }
  }
  (*(void (**)(HGRasterizer *, HGPage *))(*(_QWORD *)this + 616))(this, a2);
  if (v11)
    HGGPURenderer::ResolveMultiSampleBuffer(v5);
  glDisable(0xBE2u);
  glDisable(0xC11u);
  glFlush();
  if (((*(uint64_t (**)(HGRasterizer *))(*(_QWORD *)this + 592))(this) & 4) != 0)
  {
    glBlendEquation(0x8006u);
    glBlendFunc(1u, 1u);
  }
  (*(void (**)(HGRasterizer *, HGPage *, _QWORD, uint64_t))(*(_QWORD *)this + 496))(this, a2, 0, v32);
  v59 = *((_QWORD *)a2 + 1);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(&v62);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v63);
  return v59;
}

void sub_1B29D4BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  HGPage *v17;
  va_list va;
  va_list va1;

  va_start(va1, a16);
  va_start(va, a16);
  v17 = va_arg(va1, HGPage *);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

uint64_t HGRasterizer::SetState(HGRasterizer *this, HGRenderer *a2, int a3)
{
  if (a3 == 1)
    atomic_store(0, (unsigned int *)this + 279);
  if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) != 0 || !*((_QWORD *)this + 64))
    (*(void (**)(HGRasterizer *, HGRenderer *))(*(_QWORD *)this + 640))(this, a2);
  return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
}

uint64_t HGRasterizer::RenderFragment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  char v12;
  char **v13;
  char *v14;

  v8 = atomic_load(HGRasterizer::getIsROIDebug(void)::envCheck);
  if (v8 != -1)
  {
    v14 = &v12;
    v13 = &v14;
    std::__call_once(HGRasterizer::getIsROIDebug(void)::envCheck, &v13, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGRasterizer::getIsROIDebug(void)::$_0 &&>>);
  }
  if (HGRasterizer::_isROIDebug)
  {
    if (!*(_BYTE *)(a1 + 1077) || (v9 = *(_QWORD *)(a1 + 760)) == 0)
      v9 = *(_QWORD *)(a1 + 752);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 584))(v9, a2, a3, a4);
  }
  else
  {
    if (!*(_BYTE *)(a1 + 1077) || (v11 = *(_QWORD *)(a1 + 760)) == 0)
      v11 = *(_QWORD *)(a1 + 752);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 576))(v11, a2, a3);
  }
}

uint64_t HGRasterizer::GetNPolys(_QWORD *a1)
{
  (*(void (**)(_QWORD *))(*a1 + 640))(a1);
  return *(unsigned int *)(a1[62] + 244);
}

_QWORD *HGRasterizer::vertexArray(_QWORD *this, const HGArrayDataRef *a2, char *a3)
{
  uint64_t v3;
  char v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;

  v3 = (uint64_t)this;
  if ((*((_BYTE *)this + 1084) & 8) != 0)
  {
    v15 = *((_DWORD *)a2 + 3);
    switch(v15)
    {
      case 13:
        this = CopyArray2f((HGArrayDataRef *)(this[62] + 80), (int *)a2, 0);
        break;
      case 21:
        this = CopyArray3f((HGArrayDataRef *)(this[62] + 80), (int *)a2, 0);
        break;
      case 28:
        v16 = this[62];
        v17 = *(_QWORD *)(v16 + 80);
        v18 = *(unsigned int **)a2;
        if (v17 != *(_QWORD *)a2)
        {
          if (v17)
          {
            do
            {
              v19 = __ldaxr((unsigned int *)v17);
              v20 = v19 - 1;
            }
            while (__stlxr(v20, (unsigned int *)v17));
            if (!v20)
            {
              v21 = *(_QWORD *)(v17 + 16);
              if (v21)
                MEMORY[0x1B5E2914C](v21, 0x1000C8077774924);
              this = (_QWORD *)MEMORY[0x1B5E29170](v17, 0x1080C4098BBCF0FLL);
            }
            v18 = *(unsigned int **)a2;
          }
          *(_QWORD *)(v16 + 80) = v18;
          if (v18)
          {
            do
              v22 = __ldaxr(v18);
            while (__stlxr(v22 + 1, v18));
          }
        }
        *(_DWORD *)(v16 + 88) = *((_DWORD *)a2 + 2);
        break;
      default:
        *((_DWORD *)this + 275) = 1280;
        this = HGLogger::warning((HGLogger *)"%s", (const char *)a2, a3, "hglVertexArray: invalid type");
        break;
    }
  }
  v4 = *(_BYTE *)(v3 + 1088);
  v5 = *(_DWORD *)(v3 + 1084);
  *(_DWORD *)(v3 + 1084) = 4;
  v6 = *(_QWORD *)(v3 + 432);
  if (*(_BYTE *)(v6 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 1u;
    *(_BYTE *)(v6 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 0;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  v7 = *(_QWORD *)(v3 + 440);
  if (*(_BYTE *)(v7 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 2u;
    *(_BYTE *)(v7 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 1;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  v8 = *(_QWORD *)(v3 + 448);
  if (*(_BYTE *)(v8 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 4u;
    *(_BYTE *)(v8 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 2;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  v9 = *(_QWORD *)(v3 + 456);
  if (*(_BYTE *)(v9 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 8u;
    *(_BYTE *)(v9 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 3;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  v10 = *(_QWORD *)(v3 + 464);
  if (*(_BYTE *)(v10 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x10u;
    *(_BYTE *)(v10 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 4;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  v11 = *(_QWORD *)(v3 + 472);
  if (*(_BYTE *)(v11 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x20u;
    *(_BYTE *)(v11 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 5;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  v12 = *(_QWORD *)(v3 + 480);
  if (*(_BYTE *)(v12 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x40u;
    *(_BYTE *)(v12 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 6;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  v13 = *(_QWORD *)(v3 + 488);
  if (*(_BYTE *)(v13 + 193))
  {
    *(_DWORD *)(v3 + 1068) |= 0x80u;
    *(_BYTE *)(v13 + 192) = 1;
    *(_BYTE *)(v3 + 1088) = 7;
    this = HGRasterizer::texCoordArray((HGArrayDataRef *)v3, (const HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 80));
  }
  *(_BYTE *)(v3 + 1088) = v4;
  *(_DWORD *)(v3 + 1084) = v5;
  return this;
}

HGArrayDataRef *CopyArray3f(HGArrayDataRef *this, int *a2, uint64_t a3)
{
  int *v5;
  int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  void *v16;
  void *v17;
  const void *v18;
  int v19;
  int i;
  _DWORD *v21;
  _DWORD *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _DWORD *v29;
  _DWORD *v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;

  v5 = (int *)this;
  if (*(_QWORD *)a2)
  {
    v6 = *(_DWORD *)(*(_QWORD *)a2 + 8);
    v7 = *(unsigned int **)this;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
    v9 = *(unsigned int **)this;
    if (!*(_QWORD *)this)
    {
      if (v6 > 0)
      {
        this = (HGArrayDataRef *)HGArrayDataRef::allocate(this, 16, v6, v6);
LABEL_26:
        if (a3)
        {
          for (i = 0; i != v6; ++i)
          {
            v21 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 16) + *(int *)(*(_QWORD *)a2 + 4) * (uint64_t)i + a2[2]);
            v22 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)v5 + 16) + *(int *)(*(_QWORD *)v5 + 4) * (uint64_t)i + v5[2]);
            *v22 = *v21;
            v22[1] = v21[1];
            v22[2] = v21[2];
            v22[3] = 1065353216;
            this = (HGArrayDataRef *)(*(uint64_t (**)(uint64_t, _DWORD *, _DWORD *, uint64_t))(*(_QWORD *)a3 + 208))(a3, v22, v22, 1);
          }
        }
        else
        {
          v23 = 0;
          v24 = 0;
          v25 = *(_DWORD *)(*(_QWORD *)a2 + 4);
          v26 = *(_QWORD *)(*(_QWORD *)a2 + 16) + a2[2];
          v27 = *(_DWORD *)(*(_QWORD *)v5 + 4);
          v28 = *(_QWORD *)(*(_QWORD *)v5 + 16) + v5[2];
          do
          {
            v29 = (_DWORD *)(v26 + v23);
            v30 = (_DWORD *)(v28 + v24);
            *v30 = *v29;
            v30[1] = v29[1];
            v30[2] = v29[2];
            v30[3] = 1065353216;
            v24 += v27;
            v23 += v25;
            --v6;
          }
          while (v6);
        }
        goto LABEL_32;
      }
LABEL_25:
      if (!v6)
        goto LABEL_32;
      goto LABEL_26;
    }
    v10 = v9[3];
    if (v10 >= v6)
    {
LABEL_24:
      v9[2] = v6;
      goto LABEL_25;
    }
LABEL_11:
    v13 = v9[1];
    v14 = v13 * v6;
    v9[3] = v6;
    if (v13 * v6)
    {
      v15 = v13 * v10;
      v16 = (void *)operator new[]();
      v17 = v16;
      if (v15)
      {
        v18 = (const void *)*((_QWORD *)v9 + 2);
        if (v18)
        {
          if (v15 >= v14)
            v19 = v14;
          else
            v19 = v15;
          memcpy(v16, v18, v19);
        }
      }
    }
    else
    {
      v17 = 0;
    }
    this = (HGArrayDataRef *)*((_QWORD *)v9 + 2);
    if (this)
      this = (HGArrayDataRef *)MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
    *((_QWORD *)v9 + 2) = v17;
    goto LABEL_24;
  }
  v11 = *(unsigned int **)this;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 + 1, v11));
  v9 = *(unsigned int **)this;
  if (*(_QWORD *)this)
  {
    v6 = 0;
    v10 = v9[3];
    if (v10 >= 0)
      goto LABEL_24;
    goto LABEL_11;
  }
LABEL_32:
  v31 = *(_QWORD *)v5;
  do
    v32 = __ldaxr((unsigned int *)v31);
  while (__stlxr(v32 - 1, (unsigned int *)v31));
  if (v31 && v32 == 1)
  {
    v33 = *(_QWORD *)(v31 + 16);
    if (v33)
      MEMORY[0x1B5E2914C](v33, 0x1000C8077774924);
    JUMPOUT(0x1B5E29170);
  }
  return this;
}

HGArrayDataRef *CopyArray2f(HGArrayDataRef *this, int *a2, uint64_t a3)
{
  int *v5;
  int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  void *v16;
  void *v17;
  const void *v18;
  int v19;
  int i;
  _DWORD *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;

  v5 = (int *)this;
  if (*(_QWORD *)a2)
  {
    v6 = *(_DWORD *)(*(_QWORD *)a2 + 8);
    v7 = *(unsigned int **)this;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
    v9 = *(unsigned int **)this;
    if (!*(_QWORD *)this)
    {
      if (v6 > 0)
      {
        this = (HGArrayDataRef *)HGArrayDataRef::allocate(this, 16, v6, v6);
LABEL_26:
        if (a3)
        {
          for (i = 0; i != v6; ++i)
          {
            v21 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 16) + *(int *)(*(_QWORD *)a2 + 4) * (uint64_t)i + a2[2]);
            v22 = *(_QWORD *)(*(_QWORD *)v5 + 16) + *(int *)(*(_QWORD *)v5 + 4) * (uint64_t)i + v5[2];
            *(_DWORD *)v22 = *v21;
            *(_DWORD *)(v22 + 4) = v21[1];
            *(_QWORD *)(v22 + 8) = 0x3F80000000000000;
            this = (HGArrayDataRef *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 208))(a3, v22, v22, 1);
          }
        }
        else
        {
          v23 = 0;
          v24 = 0;
          v25 = *(_DWORD *)(*(_QWORD *)a2 + 4);
          v26 = *(_QWORD *)(*(_QWORD *)a2 + 16) + a2[2];
          v27 = *(_DWORD *)(*(_QWORD *)v5 + 4);
          v28 = *(_QWORD *)(*(_QWORD *)v5 + 16) + v5[2];
          do
          {
            v29 = (_DWORD *)(v26 + v23);
            v30 = v28 + v24;
            *(_DWORD *)v30 = *v29;
            *(_DWORD *)(v30 + 4) = v29[1];
            *(_QWORD *)(v30 + 8) = 0x3F80000000000000;
            v24 += v27;
            v23 += v25;
            --v6;
          }
          while (v6);
        }
        goto LABEL_32;
      }
LABEL_25:
      if (!v6)
        goto LABEL_32;
      goto LABEL_26;
    }
    v10 = v9[3];
    if (v10 >= v6)
    {
LABEL_24:
      v9[2] = v6;
      goto LABEL_25;
    }
LABEL_11:
    v13 = v9[1];
    v14 = v13 * v6;
    v9[3] = v6;
    if (v13 * v6)
    {
      v15 = v13 * v10;
      v16 = (void *)operator new[]();
      v17 = v16;
      if (v15)
      {
        v18 = (const void *)*((_QWORD *)v9 + 2);
        if (v18)
        {
          if (v15 >= v14)
            v19 = v14;
          else
            v19 = v15;
          memcpy(v16, v18, v19);
        }
      }
    }
    else
    {
      v17 = 0;
    }
    this = (HGArrayDataRef *)*((_QWORD *)v9 + 2);
    if (this)
      this = (HGArrayDataRef *)MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
    *((_QWORD *)v9 + 2) = v17;
    goto LABEL_24;
  }
  v11 = *(unsigned int **)this;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 + 1, v11));
  v9 = *(unsigned int **)this;
  if (*(_QWORD *)this)
  {
    v6 = 0;
    v10 = v9[3];
    if (v10 >= 0)
      goto LABEL_24;
    goto LABEL_11;
  }
LABEL_32:
  v31 = *(_QWORD *)v5;
  do
    v32 = __ldaxr((unsigned int *)v31);
  while (__stlxr(v32 - 1, (unsigned int *)v31));
  if (v31 && v32 == 1)
  {
    v33 = *(_QWORD *)(v31 + 16);
    if (v33)
      MEMORY[0x1B5E2914C](v33, 0x1000C8077774924);
    JUMPOUT(0x1B5E29170);
  }
  return this;
}

HGArrayDataRef *HGRasterizer::texCoordArray(HGArrayDataRef *this, const HGArrayDataRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  const char *v6;
  char *v7;
  int v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  void *v26;
  void *v27;
  const void *v28;
  int v29;
  int i;
  _DWORD *v31;
  _DWORD *v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  _DWORD *v39;
  _DWORD *v40;

  if ((*((_BYTE *)this + 1084) & 4) != 0)
  {
    v3 = (uint64_t)this;
    v4 = *((unsigned __int8 *)this + 1088);
    *((_DWORD *)this + 267) |= 1 << v4;
    v5 = (uint64_t *)*((_QWORD *)this + v4 + 54);
    this = (HGArrayDataRef *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*v5 + 224))(*v5);
    v8 = *((_DWORD *)a2 + 3);
    if (v8 == 13)
    {
      if ((_DWORD)this)
        v17 = 0;
      else
        v17 = *v5;
      this = CopyArray2f((HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 16 * *(unsigned __int8 *)(v3 + 1088) + 112), (int *)a2, v17);
      goto LABEL_30;
    }
    if (v8 == 21)
    {
      if ((_DWORD)this)
        v18 = 0;
      else
        v18 = *v5;
      this = CopyArray3f((HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 16 * *(unsigned __int8 *)(v3 + 1088) + 112), (int *)a2, v18);
      goto LABEL_30;
    }
    if (v8 != 28)
    {
      *(_DWORD *)(v3 + 1100) = 1280;
      return (HGArrayDataRef *)HGLogger::warning((HGLogger *)"%s", v6, v7, "hglTexCoordArray: invalid type");
    }
    v9 = *(unsigned __int8 *)(v3 + 1088);
    v10 = (int *)(*(_QWORD *)(v3 + 496) + 16 * v9 + 112);
    v11 = *(_QWORD *)a2;
    if ((_DWORD)this)
    {
      v12 = *(_QWORD *)v10;
      if (*(_QWORD *)v10 != v11)
      {
        if (v12)
        {
          do
          {
            v13 = __ldaxr((unsigned int *)v12);
            v14 = v13 - 1;
          }
          while (__stlxr(v14, (unsigned int *)v12));
          if (!v14)
          {
            v15 = *(_QWORD *)(v12 + 16);
            if (v15)
              MEMORY[0x1B5E2914C](v15, 0x1000C8077774924);
            this = (HGArrayDataRef *)MEMORY[0x1B5E29170](v12, 0x1080C4098BBCF0FLL);
          }
          v11 = *(_QWORD *)a2;
        }
        *(_QWORD *)v10 = v11;
        if (v11)
        {
          do
            v16 = __ldaxr((unsigned int *)v11);
          while (__stlxr(v16 + 1, (unsigned int *)v11));
        }
      }
      v10[2] = *((_DWORD *)a2 + 2);
      goto LABEL_30;
    }
    v19 = *v5;
    if (v11)
    {
      v20 = *(_DWORD *)(v11 + 8);
      v21 = *(_QWORD *)v10;
      if (!*(_QWORD *)v10)
      {
        if (v20 > 0)
        {
          this = (HGArrayDataRef *)HGArrayDataRef::allocate((HGArrayDataRef *)(*(_QWORD *)(v3 + 496) + 16 * v9 + 112), 16, *(_DWORD *)(v11 + 8), *(_DWORD *)(v11 + 8));
          goto LABEL_48;
        }
        goto LABEL_47;
      }
    }
    else
    {
      v21 = *(_QWORD *)v10;
      if (!*(_QWORD *)v10)
        goto LABEL_30;
      v20 = 0;
    }
    v22 = *(_DWORD *)(v21 + 12);
    if (v22 < v20)
    {
      v23 = *(_DWORD *)(v21 + 4);
      v24 = v23 * v20;
      *(_DWORD *)(v21 + 12) = v20;
      if (v23 * v20)
      {
        v25 = v23 * v22;
        v26 = (void *)operator new[]();
        v27 = v26;
        if (v25)
        {
          v28 = *(const void **)(v21 + 16);
          if (v28)
          {
            if (v25 >= v24)
              v29 = v24;
            else
              v29 = v25;
            memcpy(v26, v28, v29);
          }
        }
      }
      else
      {
        v27 = 0;
      }
      this = *(HGArrayDataRef **)(v21 + 16);
      if (this)
        this = (HGArrayDataRef *)MEMORY[0x1B5E2914C](this, 0x1000C8077774924);
      *(_QWORD *)(v21 + 16) = v27;
    }
    *(_DWORD *)(v21 + 8) = v20;
LABEL_47:
    if (v20)
    {
LABEL_48:
      if (v19)
      {
        for (i = 0; i != v20; ++i)
        {
          v31 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 16)
                         + *(int *)(*(_QWORD *)a2 + 4) * (uint64_t)i
                         + *((int *)a2 + 2));
          v32 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)v10 + 16) + *(int *)(*(_QWORD *)v10 + 4) * (uint64_t)i + v10[2]);
          *v32 = *v31;
          v32[1] = v31[1];
          v32[2] = v31[2];
          v32[3] = v31[3];
          this = (HGArrayDataRef *)(*(uint64_t (**)(uint64_t, _DWORD *, _DWORD *, uint64_t))(*(_QWORD *)v19 + 208))(v19, v32, v32, 1);
        }
      }
      else
      {
        v33 = 0;
        v34 = 0;
        v35 = *(_DWORD *)(*(_QWORD *)a2 + 4);
        v36 = *(_QWORD *)(*(_QWORD *)a2 + 16) + *((int *)a2 + 2);
        v37 = *(_DWORD *)(*(_QWORD *)v10 + 4);
        v38 = *(_QWORD *)(*(_QWORD *)v10 + 16) + v10[2];
        do
        {
          v39 = (_DWORD *)(v36 + v33);
          v40 = (_DWORD *)(v38 + v34);
          *v40 = *v39;
          v40[1] = v39[1];
          v40[2] = v39[2];
          v40[3] = v39[3];
          v34 += v37;
          v33 += v35;
          --v20;
        }
        while (v20);
      }
    }
LABEL_30:
    *(_BYTE *)(*(_QWORD *)(v3 + 8 * *(unsigned __int8 *)(v3 + 1088) + 432) + 192) = 1;
  }
  return this;
}

const char *HGRasterizer::texParameterfv(const char *this, const char *a2, char *a3, float *a4)
{
  const char *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  char *v10;
  int v11;
  float *v12;
  uint64_t v13;
  int *v14;
  float v15;
  int v16;
  float v17;
  char __str[256];
  uint64_t v19;

  v4 = this;
  v19 = *MEMORY[0x1E0C80C00];
  if (!this[1140])
  {
    v7 = *((_QWORD *)this + 62);
    *(_BYTE *)(v7 + 240) = 1;
    v8 = *(_QWORD *)(v7 + 80);
    if (v8)
      LODWORD(v8) = *(_DWORD *)(v8 + 8);
    HGRasterizer::drawArrays((uint64_t)this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), v8 - *((_DWORD *)this + 278));
    *((_BYTE *)v4 + 1140) = 1;
    snprintf(__str, 0x100uLL, "%s: invalid call between hglBegin/hglEnd", "hglTexParameteri");
    v11 = 1282;
    goto LABEL_23;
  }
  if ((_DWORD)a2 != 3553)
  {
LABEL_22:
    snprintf(__str, 0x100uLL, "%s: invalid type", "hglTexParameteri");
    v11 = 1280;
LABEL_23:
    *((_DWORD *)v4 + 275) = v11;
    return HGLogger::warning((HGLogger *)"%s", v9, v10, __str);
  }
  switch((int)a3)
  {
    case 10240:
      if (this[1088])
      {
        *((_DWORD *)this + 275) = 1281;
        this = HGLogger::warning((HGLogger *)"%s", a2, a3, "hglTexParameterfv: HGL_TEXTURE_MAG_FILTER invalid unit.  Currently filter type can only be set on unit 0 and it applies to all inputs.");
        v6 = *((unsigned __int8 *)v4 + 1088);
      }
      else
      {
        v6 = 0;
      }
      v14 = (int *)(*(_QWORD *)&v4[8 * v6 + 432] + 160);
      v17 = *a4;
      if (*a4 == 9728.0)
        goto LABEL_27;
      goto LABEL_21;
    case 10241:
      if (this[1088])
      {
        *((_DWORD *)this + 275) = 1281;
        this = HGLogger::warning((HGLogger *)"%s", a2, a3, "hglTexParameterfv: HGL_TEXTURE_MIN_FILTER invalid unit.  Currently filter type can only be set on unit 0 and it applies to all inputs.");
        v13 = *((unsigned __int8 *)v4 + 1088);
      }
      else
      {
        v13 = 0;
      }
      v14 = (int *)(*(_QWORD *)&v4[8 * v13 + 432] + 164);
      v17 = *a4;
      if (*a4 == 9728.0)
      {
LABEL_27:
        *v14 = 0;
        return this;
      }
LABEL_21:
      if (v17 == 9729.0)
        goto LABEL_15;
      goto LABEL_22;
    case 10242:
      v14 = (int *)(*(_QWORD *)&this[8 * *((unsigned __int8 *)this + 1088) + 432] + 168);
      v15 = *a4;
      if (*a4 != 33069.0)
        goto LABEL_14;
      goto LABEL_17;
    case 10243:
      v14 = (int *)(*(_QWORD *)&this[8 * *((unsigned __int8 *)this + 1088) + 432] + 172);
      v15 = *a4;
      if (*a4 == 33069.0)
      {
LABEL_17:
        v16 = 2;
      }
      else
      {
LABEL_14:
        if (v15 != 33071.0)
          goto LABEL_22;
LABEL_15:
        v16 = 1;
      }
      *v14 = v16;
      break;
    default:
      if ((_DWORD)a3 != 4100)
        goto LABEL_22;
      v12 = *(float **)&this[8 * *((unsigned __int8 *)this + 1088) + 432];
      v12[49] = *a4;
      v12[50] = a4[1];
      v12[51] = a4[2];
      v12[52] = a4[3];
      return this;
  }
  return this;
}

void *HGArray<short,(HGFormat)3>::append(HGArrayDataRef *this, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  void *v13;
  const void *v14;
  int v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;

  v4 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v5 = *(_DWORD *)(v4 + 8);
    v6 = *a2;
    if (*a2)
      goto LABEL_3;
  }
  else
  {
    v5 = 0;
    v6 = *a2;
    if (*a2)
    {
LABEL_3:
      v7 = *(_DWORD *)(v6 + 8);
      if (v4)
        goto LABEL_4;
      goto LABEL_14;
    }
  }
  v7 = 0;
  if (v4)
  {
LABEL_4:
    v8 = *(_DWORD *)(v4 + 4);
    v9 = v7 + v5;
    v10 = *(_DWORD *)(v4 + 12);
    if (v10 < v7 + v5)
    {
      *(_DWORD *)(v4 + 12) = v9;
      if (v8 * v9)
      {
        v11 = v8 * v10;
        v12 = (void *)operator new[]();
        v13 = v12;
        if (v11)
        {
          v14 = *(const void **)(v4 + 16);
          if (v14)
          {
            if (v11 >= v8 * v9)
              v15 = v8 * v9;
            else
              v15 = v11;
            memcpy(v12, v14, v15);
          }
        }
      }
      else
      {
        v13 = 0;
      }
      v20 = *(_QWORD *)(v4 + 16);
      if (v20)
        MEMORY[0x1B5E2914C](v20, 0x1000C8077774924);
      *(_QWORD *)(v4 + 16) = v13;
    }
    *(_DWORD *)(v4 + 8) = v9;
    v16 = *(_QWORD *)this;
    if (*(_QWORD *)this)
      goto LABEL_24;
    goto LABEL_17;
  }
LABEL_14:
  if (!((v7 + v5 < 0) ^ __OFADD__(v7, v5) | (v7 + v5 == 0)))
    HGArrayDataRef::allocate(this, 2, v7 + v5, v7 + v5);
  v8 = 0;
  v16 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
LABEL_24:
    v17 = (void *)(*(_QWORD *)(v16 + 16) + *(int *)(v16 + 4) * (uint64_t)v5);
    v18 = *a2;
    if (*a2)
      goto LABEL_25;
    goto LABEL_18;
  }
LABEL_17:
  v17 = 0;
  v18 = *a2;
  if (*a2)
  {
LABEL_25:
    v19 = *(const void **)(v18 + 16);
    return memmove(v17, v19, v8 * v7);
  }
LABEL_18:
  v19 = 0;
  return memmove(v17, v19, v8 * v7);
}

uint64_t HGRasterizer::drawLines(uint64_t this, int a2, int a3)
{
  uint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  void *v13;
  void *v14;
  int v15;
  const void *v16;
  uint64_t v17;
  int v18;
  int v19;
  void *v20;
  void *v21;
  int v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  HGArrayDataRef *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  void *v31;
  void *v32;
  int v33;
  const void *v34;
  uint64_t v35;
  uint64_t v36;
  HGArrayDataRef *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  void *v42;
  void *v43;
  int v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t i;
  uint64_t v49;
  int v50;
  int v51;
  void *v52;
  void *v53;
  int v54;
  const void *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  int v60;
  void *v61;
  void *v62;
  int v63;
  const void *v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  int8x16_t v70;
  int v71;
  int8x16_t v72;
  float32x2_t v73;
  float32x2_t v74;
  float32x2_t v75;
  float32x2_t v76;
  int32x2_t v77;
  int32x2_t v78;
  float32x2_t v79;
  float v80;
  char v81;
  float32x2_t v82;
  __int128 v83;
  __int128 v84;
  char v85;
  char v86;
  int v87;
  int v88;
  int v89;
  uint64_t j;
  int *v91;
  uint64_t v92;
  unsigned int v93;
  unsigned int v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  unsigned int v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  unsigned int v105;
  unsigned int v106;
  uint64_t v107;
  uint64_t v108;
  unsigned int v109;
  unsigned int v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  unsigned int v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int v117;
  unsigned int v118;
  uint64_t v119;
  uint64_t v120;
  unsigned int v121;
  unsigned int v122;
  uint64_t v123;
  uint64_t v124;
  unsigned int v125;
  unsigned int v126;
  uint64_t v127;
  uint64_t v128;
  unsigned int v129;
  unsigned int v130;
  uint64_t v131;
  uint64_t v132;
  unsigned int v133;
  unsigned int v134;
  uint64_t v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  _QWORD v163[4];

  v163[2] = *MEMORY[0x1E0C80C00];
  if (*(float *)(this + 600) < 1.0)
    return this;
  v5 = this;
  v159 = 0;
  v160 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v159, 16, 0, 0);
  v161 = 0;
  v162 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v161, 16, 0, 0);
  v163[0] = 0;
  v163[1] = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)v163, 16, 0, 0);
  v143 = 0;
  v144 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v143, 16, 0, 0);
  v145 = 0;
  v146 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v145, 16, 0, 0);
  v147 = 0;
  v148 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v147, 16, 0, 0);
  v149 = 0;
  v150 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v149, 16, 0, 0);
  v151 = 0;
  v152 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v151, 16, 0, 0);
  v153 = 0;
  v154 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v153, 16, 0, 0);
  v155 = 0;
  v156 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v155, 16, 0, 0);
  v157 = 0;
  v158 = 0x1C00000000;
  HGArrayDataRef::allocate((HGArrayDataRef *)&v157, 16, 0, 0);
  if (a3 >= 0)
    v6 = a3;
  else
    v6 = a3 + 1;
  v7 = v6 >> 1;
  v141 = 8 * (v6 >> 1);
  v8 = *(_DWORD *)(v5 + 1080) + v141 - a3;
  *(_DWORD *)(v5 + 1080) = v8;
  HGeometryData::AllocArrays(*(_QWORD *)(v5 + 496), v8, *(_DWORD *)(v5 + 1068));
  v9 = 2 * v7;
  v10 = v159;
  if (v159)
  {
    v11 = *(_DWORD *)(v159 + 12);
    if (v11 < v9)
    {
      v12 = *(_DWORD *)(v159 + 4);
      *(_DWORD *)(v159 + 12) = v9;
      if (v12 * v9)
      {
        v13 = (void *)operator new[]();
        v14 = v13;
        v15 = v12 * v11;
        if (v12 * v11)
        {
          v16 = *(const void **)(v10 + 16);
          if (v16)
          {
            if (v15 >= v12 * v9)
              v15 = v12 * v9;
            memcpy(v13, v16, v15);
          }
        }
      }
      else
      {
        v14 = 0;
      }
      v24 = *(_QWORD *)(v10 + 16);
      if (v24)
        MEMORY[0x1B5E2914C](v24, 0x1000C8077774924);
      *(_QWORD *)(v10 + 16) = v14;
    }
    *(_DWORD *)(v10 + 8) = v9;
    v17 = v161;
    if (!v161)
      goto LABEL_28;
LABEL_16:
    v18 = *(_DWORD *)(v17 + 12);
    if (v18 < v9)
    {
      v19 = *(_DWORD *)(v17 + 4);
      *(_DWORD *)(v17 + 12) = v9;
      if (v19 * v9)
      {
        v20 = (void *)operator new[]();
        v21 = v20;
        v22 = v19 * v18;
        if (v19 * v18)
        {
          v23 = *(const void **)(v17 + 16);
          if (v23)
          {
            if (v22 >= v19 * v9)
              v22 = v19 * v9;
            memcpy(v20, v23, v22);
          }
        }
      }
      else
      {
        v21 = 0;
      }
      v35 = *(_QWORD *)(v17 + 16);
      if (v35)
        MEMORY[0x1B5E2914C](v35, 0x1000C8077774924);
      *(_QWORD *)(v17 + 16) = v21;
    }
    *(_DWORD *)(v17 + 8) = v9;
    v25 = *(_QWORD *)(v5 + 496);
    v26 = (HGArrayDataRef *)(v25 + 64);
    v27 = *(_QWORD *)(v25 + 64);
    v28 = *(_DWORD *)(v5 + 1080);
    if (v27)
      goto LABEL_31;
    goto LABEL_43;
  }
  if (a3 > 1)
    HGArrayDataRef::allocate((HGArrayDataRef *)&v159, 16, 2 * v7, 2 * v7);
  v17 = v161;
  if (v161)
    goto LABEL_16;
LABEL_28:
  if (a3 > 1)
    HGArrayDataRef::allocate((HGArrayDataRef *)&v161, 16, v9, v9);
  v25 = *(_QWORD *)(v5 + 496);
  v26 = (HGArrayDataRef *)(v25 + 64);
  v27 = *(_QWORD *)(v25 + 64);
  v28 = *(_DWORD *)(v5 + 1080);
  if (v27)
  {
LABEL_31:
    v29 = *(_DWORD *)(v27 + 12);
    if (v29 < v28)
    {
      v30 = *(_DWORD *)(v27 + 4);
      *(_DWORD *)(v27 + 12) = v28;
      if (v30 * v28)
      {
        v31 = (void *)operator new[]();
        v32 = v31;
        v33 = v30 * v29;
        if (v30 * v29)
        {
          v34 = *(const void **)(v27 + 16);
          if (v34)
          {
            if (v33 >= v30 * v28)
              v33 = v30 * v28;
            memcpy(v31, v34, v33);
          }
        }
      }
      else
      {
        v32 = 0;
      }
      v36 = *(_QWORD *)(v27 + 16);
      if (v36)
        MEMORY[0x1B5E2914C](v36, 0x1000C8077774924);
      *(_QWORD *)(v27 + 16) = v32;
    }
    *(_DWORD *)(v27 + 8) = v28;
    goto LABEL_50;
  }
LABEL_43:
  if (v28 > 0)
  {
    HGArrayDataRef::allocate(v26, 16, v28, v28);
LABEL_50:
    v28 = *(_DWORD *)(v5 + 1080);
    v25 = *(_QWORD *)(v5 + 496);
  }
  v39 = *(_QWORD *)(v25 + 80);
  v37 = (HGArrayDataRef *)(v25 + 80);
  v38 = v39;
  if (v39)
  {
    v40 = *(_DWORD *)(v38 + 12);
    if (v40 < v28)
    {
      v41 = *(_DWORD *)(v38 + 4);
      *(_DWORD *)(v38 + 12) = v28;
      if (v41 * v28)
      {
        v42 = (void *)operator new[]();
        v43 = v42;
        v44 = v41 * v40;
        if (v41 * v40)
        {
          v45 = *(const void **)(v38 + 16);
          if (v45)
          {
            if (v44 >= v41 * v28)
              v44 = v41 * v28;
            memcpy(v42, v45, v44);
          }
        }
      }
      else
      {
        v43 = 0;
      }
      v46 = *(_QWORD *)(v38 + 16);
      if (v46)
        MEMORY[0x1B5E2914C](v46, 0x1000C8077774924);
      *(_QWORD *)(v38 + 16) = v43;
    }
    *(_DWORD *)(v38 + 8) = v28;
  }
  else if (v28 > 0)
  {
    HGArrayDataRef::allocate(v37, 16, v28, v28);
  }
  v142 = a3;
  v140 = a2;
  v47 = 0;
  for (i = 0; i != 8; ++i)
  {
    if (((*(_DWORD *)(v5 + 1068) >> i) & 1) == 0)
      goto LABEL_69;
    v49 = *(uint64_t *)((char *)&v143 + v47);
    if (!v49)
    {
      if (v142 > 1)
        HGArrayDataRef::allocate((HGArrayDataRef *)((char *)&v143 + v47), 16, v9, v9);
      goto LABEL_85;
    }
    v50 = *(_DWORD *)(v49 + 12);
    if (v50 < v9)
    {
      v51 = *(_DWORD *)(v49 + 4);
      *(_DWORD *)(v49 + 12) = v9;
      if (v51 * v9)
      {
        v52 = (void *)operator new[]();
        v53 = v52;
        v54 = v51 * v50;
        if (v51 * v50)
        {
          v55 = *(const void **)(v49 + 16);
          if (v55)
          {
            if (v54 >= v51 * v9)
              v54 = v51 * v9;
            memcpy(v52, v55, v54);
          }
        }
        v56 = *(_QWORD *)(v49 + 16);
        if (!v56)
          goto LABEL_81;
      }
      else
      {
        v53 = 0;
        v56 = *(_QWORD *)(v49 + 16);
        if (!v56)
          goto LABEL_81;
      }
      MEMORY[0x1B5E2914C](v56, 0x1000C8077774924);
LABEL_81:
      *(_QWORD *)(v49 + 16) = v53;
    }
    *(_DWORD *)(v49 + 8) = v9;
LABEL_85:
    v57 = *(_QWORD *)(*(_QWORD *)(v5 + 496) + v47 + 112);
    v58 = *(_DWORD *)(v5 + 1080);
    if (v57)
    {
      v59 = *(_DWORD *)(v57 + 12);
      if (v59 >= v58)
        goto LABEL_68;
      v60 = *(_DWORD *)(v57 + 4);
      *(_DWORD *)(v57 + 12) = v58;
      if (v60 * v58)
      {
        v61 = (void *)operator new[]();
        v62 = v61;
        v63 = v60 * v59;
        if (v60 * v59)
        {
          v64 = *(const void **)(v57 + 16);
          if (v64)
          {
            if (v63 >= v60 * v58)
              v63 = v60 * v58;
            memcpy(v61, v64, v63);
          }
        }
        v65 = *(_QWORD *)(v57 + 16);
        if (!v65)
        {
LABEL_67:
          *(_QWORD *)(v57 + 16) = v62;
LABEL_68:
          *(_DWORD *)(v57 + 8) = v58;
          goto LABEL_69;
        }
      }
      else
      {
        v62 = 0;
        v65 = *(_QWORD *)(v57 + 16);
        if (!v65)
          goto LABEL_67;
      }
      MEMORY[0x1B5E2914C](v65, 0x1000C8077774924);
      goto LABEL_67;
    }
    if (v58 > 0)
      HGArrayDataRef::allocate((HGArrayDataRef *)(*(_QWORD *)(v5 + 496) + v47 + 112), 16, *(_DWORD *)(v5 + 1080), *(_DWORD *)(v5 + 1080));
LABEL_69:
    v47 += 16;
  }
  if ((v142 + 1) >= 3)
  {
    v136 = 0;
    if (v9 <= 1)
      v137 = 1;
    else
      v137 = v9;
    do
    {
      v138 = v140 + v136;
      *(_OWORD *)(*(_QWORD *)(v159 + 16) + *(int *)(v159 + 4) * (uint64_t)v136 + (int)v160) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 4) * (uint64_t)(v140 + v136) + *(int *)(*(_QWORD *)(v5 + 496) + 72));
      *(_OWORD *)(*(_QWORD *)(v161 + 16) + *(int *)(v161 + 4) * (uint64_t)v136 + (int)v162) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 4) * (uint64_t)(v140 + v136) + *(int *)(*(_QWORD *)(v5 + 496) + 88));
      v139 = *(_DWORD *)(v5 + 1068);
      if ((v139 & 1) != 0)
      {
        *(_OWORD *)(*(_QWORD *)(v143 + 16) + *(int *)(v143 + 4) * (uint64_t)v136 + (int)v144) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 112) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 112) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 120));
        v139 = *(_DWORD *)(v5 + 1068);
        if ((v139 & 2) == 0)
        {
LABEL_184:
          if ((v139 & 4) == 0)
            goto LABEL_185;
          goto LABEL_193;
        }
      }
      else if ((v139 & 2) == 0)
      {
        goto LABEL_184;
      }
      *(_OWORD *)(*(_QWORD *)(v145 + 16) + *(int *)(v145 + 4) * (uint64_t)v136 + (int)v146) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 128) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 128) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 136));
      v139 = *(_DWORD *)(v5 + 1068);
      if ((v139 & 4) == 0)
      {
LABEL_185:
        if ((v139 & 8) == 0)
          goto LABEL_186;
        goto LABEL_194;
      }
LABEL_193:
      *(_OWORD *)(*(_QWORD *)(v147 + 16) + *(int *)(v147 + 4) * (uint64_t)v136 + (int)v148) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 144) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 144) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 152));
      v139 = *(_DWORD *)(v5 + 1068);
      if ((v139 & 8) == 0)
      {
LABEL_186:
        if ((v139 & 0x10) == 0)
          goto LABEL_187;
        goto LABEL_195;
      }
LABEL_194:
      *(_OWORD *)(*(_QWORD *)(v149 + 16) + *(int *)(v149 + 4) * (uint64_t)v136 + (int)v150) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 160) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 160) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 168));
      v139 = *(_DWORD *)(v5 + 1068);
      if ((v139 & 0x10) == 0)
      {
LABEL_187:
        if ((v139 & 0x20) == 0)
          goto LABEL_188;
        goto LABEL_196;
      }
LABEL_195:
      *(_OWORD *)(*(_QWORD *)(v151 + 16) + *(int *)(v151 + 4) * (uint64_t)v136 + (int)v152) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 176) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 176) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 184));
      v139 = *(_DWORD *)(v5 + 1068);
      if ((v139 & 0x20) == 0)
      {
LABEL_188:
        if ((v139 & 0x40) == 0)
          goto LABEL_189;
        goto LABEL_197;
      }
LABEL_196:
      *(_OWORD *)(*(_QWORD *)(v153 + 16) + *(int *)(v153 + 4) * (uint64_t)v136 + (int)v154) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 192) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 192) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 200));
      v139 = *(_DWORD *)(v5 + 1068);
      if ((v139 & 0x40) == 0)
      {
LABEL_189:
        if ((v139 & 0x80) != 0)
          goto LABEL_198;
        goto LABEL_181;
      }
LABEL_197:
      *(_OWORD *)(*(_QWORD *)(v155 + 16) + *(int *)(v155 + 4) * (uint64_t)v136 + (int)v156) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 208) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 208) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 216));
      if ((*(_DWORD *)(v5 + 1068) & 0x80) != 0)
LABEL_198:
        *(_OWORD *)(*(_QWORD *)(v157 + 16) + *(int *)(v157 + 4) * (uint64_t)v136 + (int)v158) = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 224) + 16) + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 224) + 4) * (uint64_t)v138 + *(int *)(*(_QWORD *)(v5 + 496) + 232));
LABEL_181:
      ++v136;
    }
    while (v137 != v136);
  }
  if (v142 >= 1)
  {
    v66 = 0;
    v67 = v140;
    do
    {
      v68 = *(_QWORD *)(v161 + 16);
      v69 = *(_DWORD *)(v161 + 4);
      v70 = *(int8x16_t *)(v68 + v69 * (uint64_t)v66 + (int)v162);
      v71 = v66 | 1;
      v72 = *(int8x16_t *)(v68 + v69 * (uint64_t)(v66 | 1) + (int)v162);
      v73 = vsub_f32(*(float32x2_t *)v72.i8, *(float32x2_t *)v70.i8);
      v74 = vmul_f32(v73, v73);
      v74.i32[0] = vadd_f32(v74, (float32x2_t)vdup_lane_s32((int32x2_t)v74, 1)).u32[0];
      v75 = vrsqrte_f32((float32x2_t)v74.u32[0]);
      v76 = vmul_f32(v75, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v75, v75)));
      v77 = (int32x2_t)vmul_f32(v76, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v76, v76)));
      v78 = (int32x2_t)vmul_n_f32(v73, *(float *)v77.i32);
      *(float *)v77.i32 = -*(float *)&v78.i32[1];
      v79 = (float32x2_t)vzip1_s32(v77, v78);
      v80 = *(float *)(v5 + 600) * 0.5;
      v81 = 1;
      do
      {
        v85 = 0;
        v86 = v81;
        v87 = v67 + 1;
        v88 = v67 + 2;
        v89 = v67 + 3;
        for (j = 120; j != 248; j += 16)
        {
          if (((*(_DWORD *)(v5 + 1068) >> v85) & 1) != 0)
          {
            *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + j - 8) + 16)
                      + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + j - 8) + 4) * (uint64_t)v67
                      + *(int *)(*(_QWORD *)(v5 + 496) + j)) = *(_OWORD *)(*(_QWORD *)(*(uint64_t *)((char *)&v143
                                                                                                  + j
                                                                                                  - 120)
                                                                                     + 16)
                                                                         + *(int *)(*(uint64_t *)((char *)&v143 + j - 120)
                                                                                  + 4)
                                                                         * (uint64_t)v66
                                                                         + *(int *)((char *)&v143 + j - 112));
            *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + j - 8) + 16)
                      + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + j - 8) + 4) * (uint64_t)v87
                      + *(int *)(*(_QWORD *)(v5 + 496) + j)) = *(_OWORD *)(*(_QWORD *)(*(uint64_t *)((char *)&v143
                                                                                                  + j
                                                                                                  - 120)
                                                                                     + 16)
                                                                         + *(int *)(*(uint64_t *)((char *)&v143 + j - 120)
                                                                                  + 4)
                                                                         * (uint64_t)v71
                                                                         + *(int *)((char *)&v143 + j - 112));
            v91 = (int *)(*(_QWORD *)(v5 + 496) + j);
            *(_OWORD *)(*(_QWORD *)(*((_QWORD *)v91 - 1) + 16)
                      + *(int *)(*((_QWORD *)v91 - 1) + 4) * (uint64_t)v88
                      + *v91) = *(_OWORD *)(*(_QWORD *)(*(uint64_t *)((char *)&v143 + j - 120) + 16)
                                          + *(int *)(*(uint64_t *)((char *)&v143 + j - 120) + 4) * (uint64_t)v71
                                          + *(int *)((char *)&v143 + j - 112));
            *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + j - 8) + 16)
                      + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + j - 8) + 4) * (uint64_t)v89
                      + *(int *)(*(_QWORD *)(v5 + 496) + j)) = *(_OWORD *)(*(_QWORD *)(*(uint64_t *)((char *)&v143
                                                                                                  + j
                                                                                                  - 120)
                                                                                     + 16)
                                                                         + *(int *)(*(uint64_t *)((char *)&v143 + j - 120)
                                                                                  + 4)
                                                                         * (uint64_t)v66
                                                                         + *(int *)((char *)&v143 + j - 112));
          }
          ++v85;
        }
        v81 = 0;
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 16)
                  + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 4) * (uint64_t)v67
                  + *(int *)(*(_QWORD *)(v5 + 496) + 72)) = *(_OWORD *)(*(_QWORD *)(v159 + 16)
                                                                        + *(int *)(v159 + 4) * (uint64_t)v66
                                                                        + (int)v160);
        *(int8x16_t *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 16)
                     + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 4) * (uint64_t)v67
                     + *(int *)(*(_QWORD *)(v5 + 496) + 88)) = v70;
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 16)
                  + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 4) * (uint64_t)v87
                  + *(int *)(*(_QWORD *)(v5 + 496) + 72)) = *(_OWORD *)(*(_QWORD *)(v159 + 16)
                                                                        + *(int *)(v159 + 4) * (uint64_t)v71
                                                                        + (int)v160);
        *(int8x16_t *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 16)
                     + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 4) * (uint64_t)v87
                     + *(int *)(*(_QWORD *)(v5 + 496) + 88)) = v72;
        v82 = vmul_n_f32(v79, v80);
        *(float32x2_t *)&v83 = vadd_f32(*(float32x2_t *)v72.i8, v82);
        *(float32x2_t *)&v84 = vadd_f32(*(float32x2_t *)v70.i8, v82);
        *((_QWORD *)&v84 + 1) = vextq_s8(v70, v70, 8uLL).u64[0];
        *((_QWORD *)&v83 + 1) = vextq_s8(v72, v72, 8uLL).u64[0];
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 16)
                  + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 4) * (uint64_t)v88
                  + *(int *)(*(_QWORD *)(v5 + 496) + 72)) = *(_OWORD *)(*(_QWORD *)(v159 + 16)
                                                                        + *(int *)(v159 + 4) * (uint64_t)v71
                                                                        + (int)v160);
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 16)
                  + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 4) * (uint64_t)v88
                  + *(int *)(*(_QWORD *)(v5 + 496) + 88)) = v83;
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 16)
                  + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 64) + 4) * (uint64_t)v89
                  + *(int *)(*(_QWORD *)(v5 + 496) + 72)) = *(_OWORD *)(*(_QWORD *)(v159 + 16)
                                                                        + *(int *)(v159 + 4) * (uint64_t)v66
                                                                        + (int)v160);
        v67 += 4;
        *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 16)
                  + *(int *)(*(_QWORD *)(*(_QWORD *)(v5 + 496) + 80) + 4) * (uint64_t)v89
                  + *(int *)(*(_QWORD *)(v5 + 496) + 88)) = v84;
        v79 = vneg_f32(v79);
      }
      while ((v86 & 1) != 0);
      v66 += 2;
    }
    while (v66 < v142);
  }
  this = HGRasterizer::drawArrays((HGRasterizer *)v5, 7u, v140, v141);
  v92 = v157;
  if (v157)
  {
    do
    {
      v93 = __ldaxr((unsigned int *)v92);
      v94 = v93 - 1;
    }
    while (__stlxr(v94, (unsigned int *)v92));
    if (!v94)
    {
      v95 = *(_QWORD *)(v92 + 16);
      if (v95)
        MEMORY[0x1B5E2914C](v95, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v92, 0x1080C4098BBCF0FLL);
    }
  }
  v96 = v155;
  if (v155)
  {
    do
    {
      v97 = __ldaxr((unsigned int *)v96);
      v98 = v97 - 1;
    }
    while (__stlxr(v98, (unsigned int *)v96));
    if (!v98)
    {
      v99 = *(_QWORD *)(v96 + 16);
      if (v99)
        MEMORY[0x1B5E2914C](v99, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v96, 0x1080C4098BBCF0FLL);
    }
  }
  v100 = v153;
  if (v153)
  {
    do
    {
      v101 = __ldaxr((unsigned int *)v100);
      v102 = v101 - 1;
    }
    while (__stlxr(v102, (unsigned int *)v100));
    if (!v102)
    {
      v103 = *(_QWORD *)(v100 + 16);
      if (v103)
        MEMORY[0x1B5E2914C](v103, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v100, 0x1080C4098BBCF0FLL);
    }
  }
  v104 = v151;
  if (v151)
  {
    do
    {
      v105 = __ldaxr((unsigned int *)v104);
      v106 = v105 - 1;
    }
    while (__stlxr(v106, (unsigned int *)v104));
    if (!v106)
    {
      v107 = *(_QWORD *)(v104 + 16);
      if (v107)
        MEMORY[0x1B5E2914C](v107, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v104, 0x1080C4098BBCF0FLL);
    }
  }
  v108 = v149;
  if (v149)
  {
    do
    {
      v109 = __ldaxr((unsigned int *)v108);
      v110 = v109 - 1;
    }
    while (__stlxr(v110, (unsigned int *)v108));
    if (!v110)
    {
      v111 = *(_QWORD *)(v108 + 16);
      if (v111)
        MEMORY[0x1B5E2914C](v111, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v108, 0x1080C4098BBCF0FLL);
    }
  }
  v112 = v147;
  if (v147)
  {
    do
    {
      v113 = __ldaxr((unsigned int *)v112);
      v114 = v113 - 1;
    }
    while (__stlxr(v114, (unsigned int *)v112));
    if (!v114)
    {
      v115 = *(_QWORD *)(v112 + 16);
      if (v115)
        MEMORY[0x1B5E2914C](v115, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v112, 0x1080C4098BBCF0FLL);
    }
  }
  v116 = v145;
  if (v145)
  {
    do
    {
      v117 = __ldaxr((unsigned int *)v116);
      v118 = v117 - 1;
    }
    while (__stlxr(v118, (unsigned int *)v116));
    if (!v118)
    {
      v119 = *(_QWORD *)(v116 + 16);
      if (v119)
        MEMORY[0x1B5E2914C](v119, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v116, 0x1080C4098BBCF0FLL);
    }
  }
  v120 = v143;
  if (v143)
  {
    do
    {
      v121 = __ldaxr((unsigned int *)v120);
      v122 = v121 - 1;
    }
    while (__stlxr(v122, (unsigned int *)v120));
    if (!v122)
    {
      v123 = *(_QWORD *)(v120 + 16);
      if (v123)
        MEMORY[0x1B5E2914C](v123, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v120, 0x1080C4098BBCF0FLL);
    }
  }
  v124 = v163[0];
  if (v163[0])
  {
    do
    {
      v125 = __ldaxr((unsigned int *)v124);
      v126 = v125 - 1;
    }
    while (__stlxr(v126, (unsigned int *)v124));
    if (!v126)
    {
      v127 = *(_QWORD *)(v124 + 16);
      if (v127)
        MEMORY[0x1B5E2914C](v127, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v124, 0x1080C4098BBCF0FLL);
    }
  }
  v128 = v161;
  if (v161)
  {
    do
    {
      v129 = __ldaxr((unsigned int *)v128);
      v130 = v129 - 1;
    }
    while (__stlxr(v130, (unsigned int *)v128));
    if (!v130)
    {
      v131 = *(_QWORD *)(v128 + 16);
      if (v131)
        MEMORY[0x1B5E2914C](v131, 0x1000C8077774924);
      this = MEMORY[0x1B5E29170](v128, 0x1080C4098BBCF0FLL);
    }
  }
  v132 = v159;
  if (v159)
  {
    do
    {
      v133 = __ldaxr((unsigned int *)v132);
      v134 = v133 - 1;
    }
    while (__stlxr(v134, (unsigned int *)v132));
    if (!v134)
    {
      v135 = *(_QWORD *)(v132 + 16);
      if (v135)
        MEMORY[0x1B5E2914C](v135, 0x1000C8077774924);
      return MEMORY[0x1B5E29170](v132, 0x1080C4098BBCF0FLL);
    }
  }
  return this;
}

void sub_1B29D6E28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  unsigned int v62;
  unsigned int v63;
  uint64_t v64;

  if (a25)
  {
    do
    {
      v32 = __ldaxr((unsigned int *)a25);
      v33 = v32 - 1;
    }
    while (__stlxr(v33, (unsigned int *)a25));
    if (!v33)
    {
      v34 = *(_QWORD *)(a25 + 16);
      if (v34)
        MEMORY[0x1B5E2914C](v34, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a25, 0x1080C4098BBCF0FLL);
    }
  }
  if (a23)
  {
    do
    {
      v35 = __ldaxr((unsigned int *)a23);
      v36 = v35 - 1;
    }
    while (__stlxr(v36, (unsigned int *)a23));
    if (!v36)
    {
      v37 = *(_QWORD *)(a23 + 16);
      if (v37)
        MEMORY[0x1B5E2914C](v37, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a23, 0x1080C4098BBCF0FLL);
    }
  }
  if (a21)
  {
    do
    {
      v38 = __ldaxr((unsigned int *)a21);
      v39 = v38 - 1;
    }
    while (__stlxr(v39, (unsigned int *)a21));
    if (!v39)
    {
      v40 = *(_QWORD *)(a21 + 16);
      if (v40)
        MEMORY[0x1B5E2914C](v40, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a21, 0x1080C4098BBCF0FLL);
    }
  }
  if (a19)
  {
    do
    {
      v41 = __ldaxr((unsigned int *)a19);
      v42 = v41 - 1;
    }
    while (__stlxr(v42, (unsigned int *)a19));
    if (!v42)
    {
      v43 = *(_QWORD *)(a19 + 16);
      if (v43)
        MEMORY[0x1B5E2914C](v43, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a19, 0x1080C4098BBCF0FLL);
    }
  }
  if (a17)
  {
    do
    {
      v44 = __ldaxr((unsigned int *)a17);
      v45 = v44 - 1;
    }
    while (__stlxr(v45, (unsigned int *)a17));
    if (!v45)
    {
      v46 = *(_QWORD *)(a17 + 16);
      if (v46)
        MEMORY[0x1B5E2914C](v46, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a17, 0x1080C4098BBCF0FLL);
    }
  }
  if (a15)
  {
    do
    {
      v47 = __ldaxr((unsigned int *)a15);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, (unsigned int *)a15));
    if (!v48)
    {
      v49 = *(_QWORD *)(a15 + 16);
      if (v49)
        MEMORY[0x1B5E2914C](v49, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a15, 0x1080C4098BBCF0FLL);
    }
  }
  if (a13)
  {
    do
    {
      v50 = __ldaxr((unsigned int *)a13);
      v51 = v50 - 1;
    }
    while (__stlxr(v51, (unsigned int *)a13));
    if (!v51)
    {
      v52 = *(_QWORD *)(a13 + 16);
      if (v52)
        MEMORY[0x1B5E2914C](v52, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a13, 0x1080C4098BBCF0FLL);
    }
  }
  if (a11)
  {
    do
    {
      v53 = __ldaxr((unsigned int *)a11);
      v54 = v53 - 1;
    }
    while (__stlxr(v54, (unsigned int *)a11));
    if (!v54)
    {
      v55 = *(_QWORD *)(a11 + 16);
      if (v55)
        MEMORY[0x1B5E2914C](v55, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a11, 0x1080C4098BBCF0FLL);
    }
  }
  if (a31)
  {
    do
    {
      v56 = __ldaxr((unsigned int *)a31);
      v57 = v56 - 1;
    }
    while (__stlxr(v57, (unsigned int *)a31));
    if (!v57)
    {
      v58 = *(_QWORD *)(a31 + 16);
      if (v58)
        MEMORY[0x1B5E2914C](v58, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a31, 0x1080C4098BBCF0FLL);
    }
  }
  if (a29)
  {
    do
    {
      v59 = __ldaxr((unsigned int *)a29);
      v60 = v59 - 1;
    }
    while (__stlxr(v60, (unsigned int *)a29));
    if (!v60)
    {
      v61 = *(_QWORD *)(a29 + 16);
      if (v61)
        MEMORY[0x1B5E2914C](v61, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a29, 0x1080C4098BBCF0FLL);
    }
  }
  if (a27)
  {
    do
    {
      v62 = __ldaxr((unsigned int *)a27);
      v63 = v62 - 1;
    }
    while (__stlxr(v63, (unsigned int *)a27));
    if (!v63)
    {
      v64 = *(_QWORD *)(a27 + 16);
      if (v64)
        MEMORY[0x1B5E2914C](v64, 0x1000C8077774924);
      MEMORY[0x1B5E29170](a27, 0x1080C4098BBCF0FLL);
    }
  }
  _Unwind_Resume(exception_object);
}

const char *HGRasterizer::enableClientState(const char *this, int a2, int a3)
{
  const char *v3;
  const char *v4;
  int v6;
  const char *v7;
  char *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  char __str[256];
  uint64_t v16;

  v3 = this;
  v16 = *MEMORY[0x1E0C80C00];
  if (a3)
    v4 = "hglEnableClientState";
  else
    v4 = "hglDisableClientState";
  if (this[1140])
  {
    v6 = a2 - 32884;
    if ((a2 - 32884) < 5 && ((0x17u >> v6) & 1) != 0)
    {
      v9 = *(_DWORD *)&asc_1B309BB14[4 * v6];
      if (a3)
        goto LABEL_8;
    }
    else
    {
      snprintf(__str, 0x100uLL, "%s: invalid parameter passed to function", v4);
      *((_DWORD *)v3 + 275) = 1280;
      this = HGLogger::warning((HGLogger *)"%s", v7, v8, __str);
      v9 = 0;
      if (a3)
      {
LABEL_8:
        v10 = *((_DWORD *)v3 + 271) | v9;
LABEL_14:
        *((_DWORD *)v3 + 271) = v10;
        return this;
      }
    }
    v10 = *((_DWORD *)v3 + 271) & ~v9;
    goto LABEL_14;
  }
  v11 = *((_QWORD *)this + 62);
  *(_BYTE *)(v11 + 240) = 1;
  v12 = *(_QWORD *)(v11 + 80);
  if (v12)
    LODWORD(v12) = *(_DWORD *)(v12 + 8);
  HGRasterizer::drawArrays((uint64_t)this, *((_DWORD *)this + 274), *((_DWORD *)this + 278), v12 - *((_DWORD *)this + 278));
  *((_BYTE *)v3 + 1140) = 1;
  snprintf(__str, 0x100uLL, "%s: invalid call between hglBegin/hglEnd", v4);
  *((_DWORD *)v3 + 275) = 1282;
  return HGLogger::warning((HGLogger *)"%s", v13, v14, __str);
}

uint64_t HGRasterizer::SetInput(HGNode *this, unsigned int a2, HGNode *a3)
{
  uint64_t v6;
  uint64_t v7;
  HRasterizerTexture *v8;
  HRasterizerTexture *v9;
  int v10;
  int v11;

  if (!a2 && a3)
  {
    if (!*((_BYTE *)this + 1064))
    {
      v6 = *((_QWORD *)this + 94);
      if (v6)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
      if (*((_QWORD *)this + 64))
      {
        v7 = *((_QWORD *)this + 66);
        v8 = (HRasterizerTexture *)HGObject::operator new(0x1C0uLL);
        v9 = v8;
        if (v7)
          HRasterizerTexture::HRasterizerTexture(v8);
        else
          HRasterizerTextureNoColor::HRasterizerTextureNoColor(v8);
      }
      else
      {
        v9 = (HRasterizerTexture *)HGObject::operator new(0x1C0uLL);
        HRasterizerTexture::HRasterizerTexture(v9);
      }
      *((_QWORD *)this + 94) = v9;
    }
    v10 = 1;
    goto LABEL_15;
  }
  v10 = 1 << a2;
  if (a3)
  {
LABEL_15:
    v11 = *((_DWORD *)this + 264) | v10;
    goto LABEL_16;
  }
  v11 = *((_DWORD *)this + 264) & ~v10;
LABEL_16:
  *((_DWORD *)this + 264) = v11;
  return HGNode::SetInput(this, a2, a3);
}

void sub_1B29D7448(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D745C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D7470(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRasterizer::addInputTransform(uint64_t a1, int a2, const HGTransform *a3, uint64_t *a4)
{
  uint64_t v6;
  __n128 v7;
  uint64_t v8;
  uint64_t result;

  *(_BYTE *)(a1 + 1077) = 1;
  v6 = *(_QWORD *)(a1 + 8 * a2 + 432);
  HGTransform::LoadIdentity((HGTransform *)(v6 + 8));
  HGTransform::LoadTransform((HGTransform *)(v6 + 8), a3);
  v7.n128_f64[0] = HGTransform::Invert2D((HGTransform *)(v6 + 8));
  v8 = *(_QWORD *)(v6 + 152);
  result = *a4;
  if (v8 != *a4)
  {
    if (v8)
    {
      (*(void (**)(_QWORD, double))(*(_QWORD *)v8 + 24))(*(_QWORD *)(v6 + 152), v7.n128_f64[0]);
      result = *a4;
    }
    *(_QWORD *)(v6 + 152) = result;
    if (result)
      return (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)result + 16))(result, v7);
  }
  return result;
}

uint64_t HGRasterizer::GetRasterizerFlags(HGRasterizer *this)
{
  return *((unsigned int *)this + 277);
}

uint64_t HGRasterizer::getBlendMode(HGRasterizer *this)
{
  return *((unsigned int *)this + 265);
}

void HGRasterizerAntiAliasingImplementation::~HGRasterizerAntiAliasingImplementation(HGRasterizerAntiAliasingImplementation *this)
{
  void *v1;

  HGObject::~HGObject(this);
  HGObject::operator delete(v1);
}

const char *std::__call_once_proxy[abi:ne180100]<std::tuple<HGRasterizer::getIsROIDebug(void)::$_0 &&>>()
{
  const char *result;

  result = getenv("ROI_DEBUG");
  if (result)
  {
    result = (const char *)atoi(result);
    HGRasterizer::_isROIDebug = (_DWORD)result == 1;
  }
  else
  {
    HGRasterizer::_isROIDebug = 0;
  }
  return result;
}

void OUTLINED_FUNCTION_1_0()
{
  JUMPOUT(0x1B5E29170);
}

void HGRasterizer::HGRasterizer()
{
  uint64_t v0;
  char v1;
  unsigned int v2;

  OUTLINED_FUNCTION_2();
  do
    OUTLINED_FUNCTION_4();
  while (__stlxr(v2, (unsigned int *)v0));
  if (v1)
  {
    if (*(_QWORD *)(v0 + 16))
      OUTLINED_FUNCTION_1();
    OUTLINED_FUNCTION_1_0();
  }
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
}

uint64_t HGRasterizer::drawLines(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;

  do
  {
    v1 = __ldaxr((unsigned int *)result);
    v2 = v1 - 1;
  }
  while (__stlxr(v2, (unsigned int *)result));
  if (!v2)
  {
    if (*(_QWORD *)(result + 16))
      OUTLINED_FUNCTION_1();
    OUTLINED_FUNCTION_1_0();
  }
  return result;
}

uint64_t HGMetalDeviceInfo::getMainDevice(HGMetalDeviceInfo *this)
{
  id v1;
  unint64_t v2;
  std::mutex *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  char v8;
  char **v9;
  char *v10;

  v1 = MTLCreateSystemDefaultDevice();
  v2 = atomic_load(&_MergedGlobals_2);
  if (v2 != -1)
  {
    v10 = &v8;
    v9 = &v10;
    std::__call_once(&_MergedGlobals_2, &v9, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMetalDeviceInfo::_initAllDevices(void)::$_0 &&>>);
  }
  v3 = (std::mutex *)qword_1ED4D94C8;
  std::mutex::lock((std::mutex *)qword_1ED4D94C8);
  v4 = *(uint64_t **)qword_1ED4D94D0;
  v5 = *(uint64_t **)(qword_1ED4D94D0 + 8);
  if (*(uint64_t **)qword_1ED4D94D0 == v5)
  {
LABEL_6:
    v6 = 0;
  }
  else
  {
    while (1)
    {
      v6 = *v4;
      if (*(id *)(*v4 + 16) == v1)
        break;
      if (++v4 == v5)
        goto LABEL_6;
    }
  }
  std::mutex::unlock(v3);

  return v6;
}

uint64_t HGMetalDeviceInfo::getDeviceInfo(uint64_t a1)
{
  unint64_t v2;
  std::mutex *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  char v8;
  char **v9;
  char *v10;

  v2 = atomic_load(&_MergedGlobals_2);
  if (v2 != -1)
  {
    v10 = &v8;
    v9 = &v10;
    std::__call_once(&_MergedGlobals_2, &v9, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMetalDeviceInfo::_initAllDevices(void)::$_0 &&>>);
  }
  v3 = (std::mutex *)qword_1ED4D94C8;
  std::mutex::lock((std::mutex *)qword_1ED4D94C8);
  v4 = *(uint64_t **)qword_1ED4D94D0;
  v5 = *(uint64_t **)(qword_1ED4D94D0 + 8);
  if (*(uint64_t **)qword_1ED4D94D0 == v5)
  {
LABEL_6:
    v6 = 0;
  }
  else
  {
    while (1)
    {
      v6 = *v4;
      if (*(_QWORD *)(*v4 + 16) == a1)
        break;
      if (++v4 == v5)
        goto LABEL_6;
    }
  }
  std::mutex::unlock(v3);
  return v6;
}

void HGMetalDeviceInfo::_init(HGMetalDeviceInfo *this)
{
  const char *v2;
  unsigned __int8 v3;
  const char *v4;
  char *v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  uint64_t v8;
  const char *v9;
  char *v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  const char *v15;
  unsigned __int8 v16;
  const char *v17;
  unsigned __int8 v18;
  const char *v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  int v24;
  const char *v25;
  char *v26;
  const char *v27;
  unsigned __int8 v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  const char *v37;
  unsigned __int8 v38;
  const char *v39;
  char *v40;
  unsigned __int8 v41;
  const char *v42;
  unsigned __int8 v43;
  const char *v44;
  unsigned __int8 v45;
  const char *v46;
  unsigned __int8 v47;
  const char *v48;
  unsigned __int8 v49;
  const char *v50;
  unsigned __int8 v51;
  const char *v52;
  unsigned __int8 v53;
  const char *v54;
  unsigned __int8 v55;
  const char *v56;
  unsigned __int8 v57;
  const char *v58;
  unsigned __int8 v59;
  const char *v60;
  unsigned __int8 v61;
  const char *v62;
  int v63;
  void *v64;
  const char *v65;
  char *v66;
  unsigned __int8 v67;
  unsigned __int8 v68;
  int v69;
  unsigned __int8 v70;
  unsigned __int8 v71;
  unsigned __int8 v72;
  const char *v73;
  unsigned __int8 v74;
  const char *v75;
  unsigned __int8 v76;
  const char *v77;
  int v78;
  int v79;
  int v80;
  size_t v81;
  uint64_t v82;
  _BYTE v83[16];
  int v84[2];
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v83, "metal", 1, "HGMetalDeviceInfo::_init()");
  *((_QWORD *)this + 3) = objc_msgSend(*((id *)this + 2), "registryID");
  *((_DWORD *)this + 8) = 4203;
  v81 = 8;
  v82 = 0;
  *(_QWORD *)v84 = 0x1800000006;
  sysctl(v84, 2u, &v82, &v81, 0, 0);
  *((_QWORD *)this + 5) = v82;
  v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"metal", v2) >= 1)
  {
    v6 = atomic_load(HGLogger::_enabled);
    if ((v6 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"device          : %p\n", v4, v5, *((_QWORD *)this + 2));
    v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) != 0)
    {
      v8 = objc_msgSend((id)objc_msgSend(*((id *)this + 2), "name"), "UTF8String");
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"name            : %s\n", v9, v10, v8);
    }
    v11 = atomic_load(HGLogger::_enabled);
    if ((v11 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"registryID      : 0x%llx\n", v4, v5, *((_QWORD *)this + 3));
    v12 = atomic_load(HGLogger::_enabled);
    if ((v12 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"  vendorID      : 0x%4x\n", v4, v5, *((unsigned int *)this + 8));
    v13 = atomic_load(HGLogger::_enabled);
    if ((v13 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"  deviceID      : 0x%4x\n", v4, v5, *((unsigned int *)this + 9));
    v14 = atomic_load(HGLogger::_enabled);
    if ((v14 & 1) != 0)
    {
      v15 = "no";
      if (*((_DWORD *)this + 8) == 4098)
        v15 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"AMD             : %s\n", v4, v5, v15);
    }
    v16 = atomic_load(HGLogger::_enabled);
    if ((v16 & 1) != 0)
    {
      v17 = "no";
      if (*((_DWORD *)this + 8) == 32902)
        v17 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"Intel           : %s\n", v4, v5, v17);
    }
    v18 = atomic_load(HGLogger::_enabled);
    if ((v18 & 1) != 0)
    {
      v19 = "no";
      if (*((_DWORD *)this + 8) == 4203)
        v19 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"Apple           : %s\n", v4, v5, v19);
    }
    v20 = atomic_load(HGLogger::_enabled);
    if ((v20 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"headless        : %s\n", v4, v5, "no");
    v21 = atomic_load(HGLogger::_enabled);
    if ((v21 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"lowPower        : %s\n", v4, v5, "no");
    v22 = atomic_load(HGLogger::_enabled);
    if ((v22 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"removable       : %s\n", v4, v5, "no");
    v23 = atomic_load(HGLogger::_enabled);
    if ((v23 & 1) != 0)
    {
      v24 = objc_msgSend(*((id *)this + 2), "hasUnifiedMemory");
      v27 = "no";
      if (v24)
        v27 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"unifiedMemory   : %s\n", v25, v26, v27);
    }
    v28 = atomic_load(HGLogger::_enabled);
    if ((v28 & 1) != 0)
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"memory          : %.1f GB\n", v4, v5, (float)((float)*((unint64_t *)this + 5) * 9.3132e-10));
  }
  v29 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 1001);
  v30 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 1002);
  v31 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 1003);
  v32 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 1004);
  v33 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 1005);
  v34 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 1006);
  v35 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 1007);
  v36 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 2002);
  v80 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 3001);
  v79 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 3002);
  v78 = objc_msgSend(*((id *)this + 2), "supportsFamily:", 3003);
  v38 = atomic_load(HGLogger::_enabled);
  if ((v38 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"metal", v37) >= 1)
  {
    v41 = atomic_load(HGLogger::_enabled);
    if ((v41 & 1) != 0)
    {
      v42 = "no";
      if (v29)
        v42 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple1 : %s\n", v39, v40, v42);
    }
    v43 = atomic_load(HGLogger::_enabled);
    if ((v43 & 1) != 0)
    {
      v44 = "no";
      if (v30)
        v44 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple2 : %s\n", v39, v40, v44);
    }
    v45 = atomic_load(HGLogger::_enabled);
    if ((v45 & 1) != 0)
    {
      v46 = "no";
      if (v31)
        v46 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple3 : %s\n", v39, v40, v46);
    }
    v47 = atomic_load(HGLogger::_enabled);
    if ((v47 & 1) != 0)
    {
      v48 = "no";
      if (v32)
        v48 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple4 : %s\n", v39, v40, v48);
    }
    v49 = atomic_load(HGLogger::_enabled);
    if ((v49 & 1) != 0)
    {
      v50 = "no";
      if (v33)
        v50 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple5 : %s\n", v39, v40, v50);
    }
    v51 = atomic_load(HGLogger::_enabled);
    if ((v51 & 1) != 0)
    {
      v52 = "no";
      if (v34)
        v52 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple6 : %s\n", v39, v40, v52);
    }
    v53 = atomic_load(HGLogger::_enabled);
    if ((v53 & 1) != 0)
    {
      v54 = "no";
      if (v35)
        v54 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyApple7 : %s\n", v39, v40, v54);
    }
    v55 = atomic_load(HGLogger::_enabled);
    if ((v55 & 1) != 0)
    {
      v56 = "no";
      if (v36)
        v56 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyMac2 : %s\n", v39, v40, v56);
    }
    v57 = atomic_load(HGLogger::_enabled);
    if ((v57 & 1) != 0)
    {
      v58 = "no";
      if (v80)
        v58 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyCommon1 : %s\n", v39, v40, v58);
    }
    v59 = atomic_load(HGLogger::_enabled);
    if ((v59 & 1) != 0)
    {
      v60 = "no";
      if (v79)
        v60 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyCommon2 : %s\n", v39, v40, v60);
    }
    v61 = atomic_load(HGLogger::_enabled);
    if ((v61 & 1) != 0)
    {
      v62 = "no";
      if (v78)
        v62 = "yes";
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"gpuFamilyCommon3 : %s\n", v39, v40, v62);
    }
  }
  if (v31)
    v63 = 0x4000;
  else
    v63 = 0x2000;
  *((_DWORD *)this + 12) = v63;
  *((_BYTE *)this + 56) = v30;
  *((_BYTE *)this + 57) = v32;
  v64 = (void *)*((_QWORD *)this + 2);
  if ((objc_msgSend(v64, "supportsTextureSampleCount:", 8) & 1) != 0)
  {
    *((_DWORD *)this + 13) = 8;
    v67 = atomic_load(HGLogger::_enabled);
    if ((v67 & 1) == 0)
      goto LABEL_97;
LABEL_96:
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"maxTextureSize = %d\n", v65, v66, *((unsigned int *)this + 12));
    goto LABEL_97;
  }
  if ((objc_msgSend(v64, "supportsTextureSampleCount:", 4) & 1) != 0)
  {
    *((_DWORD *)this + 13) = 4;
    v68 = atomic_load(HGLogger::_enabled);
    if ((v68 & 1) != 0)
      goto LABEL_96;
  }
  else
  {
    if (objc_msgSend(v64, "supportsTextureSampleCount:", 2))
      v69 = 2;
    else
      v69 = 1;
    *((_DWORD *)this + 13) = v69;
    v70 = atomic_load(HGLogger::_enabled);
    if ((v70 & 1) != 0)
      goto LABEL_96;
  }
LABEL_97:
  v71 = atomic_load(HGLogger::_enabled);
  if ((v71 & 1) != 0)
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"maxSampleCount = %d\n", v65, v66, *((unsigned int *)this + 13));
  v72 = atomic_load(HGLogger::_enabled);
  if ((v72 & 1) != 0)
  {
    if (*((_BYTE *)this + 56))
      v73 = "yes";
    else
      v73 = "no";
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"clampToZeroBuffers = %s\n", v65, v66, v73);
  }
  v74 = atomic_load(HGLogger::_enabled);
  if ((v74 & 1) != 0)
  {
    if (*((_BYTE *)this + 57))
      v75 = "yes";
    else
      v75 = "no";
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"quadShuffleSupported = %s\n", v65, v66, v75);
  }
  v76 = atomic_load(HGLogger::_enabled);
  if ((v76 & 1) != 0)
  {
    if (*((_BYTE *)this + 58))
      v77 = "yes";
    else
      v77 = "no";
    HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"bufferlessClientStorageSupported = %s\n", v65, v66, v77);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v83);
}

void sub_1B29D8050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D8064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D8078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D808C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D80A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D80B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D80C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D80DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D80F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D8104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D8118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D8130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29D8144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalDeviceInfo::~HGMetalDeviceInfo(id *this)
{
  *this = off_1E65148B0;

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;

  *this = off_1E65148B0;

  HGObject::~HGObject((HGObject *)this);
  HGObject::operator delete(v2);
}

uint64_t HGMetalDeviceInfo::name(id *this)
{
  return objc_msgSend((id)objc_msgSend(this[2], "name"), "UTF8String");
}

BOOL HGMetalDeviceInfo::isAMD(HGMetalDeviceInfo *this)
{
  return *((_DWORD *)this + 8) == 4098;
}

BOOL HGMetalDeviceInfo::isIntel(HGMetalDeviceInfo *this)
{
  return *((_DWORD *)this + 8) == 32902;
}

BOOL HGMetalDeviceInfo::isApple(HGMetalDeviceInfo *this)
{
  return *((_DWORD *)this + 8) == 4203;
}

uint64_t HGMetalDeviceInfo::validateTextureSampleCount(HGMetalDeviceInfo *this, const char *a2, char *a3)
{
  unsigned int v3;
  uint64_t v4;

  v3 = *((_DWORD *)this + 13);
  if (v3 >= a2)
    v4 = a2;
  else
    v4 = v3;
  if (v3 < a2)
    HGLogger::warning((HGLogger *)"Requested sample count: %d, differs from final sample count: %d", a2, a3, a2, v4);
  return v4;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<HGMetalDeviceInfo::_initAllDevices(void)::$_0 &&>>()
{
  uint64_t v0;
  _QWORD *v1;
  id v2;
  const char *v3;
  char *v4;
  void *v5;
  HGObject *v6;
  id v7;
  char **v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _BYTE *v18;
  HGObject **v19;
  char *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  _OWORD *v26;
  char *v27;
  uint64_t v28;
  __int128 v29;
  HGObject *v30;

  v0 = operator new();
  *(_QWORD *)v0 = 850045863;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_QWORD *)(v0 + 56) = 0;
  qword_1ED4D94C8 = v0;
  v1 = (_QWORD *)operator new();
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  qword_1ED4D94D0 = (uint64_t)v1;
  v2 = MTLCreateSystemDefaultDevice();
  if (!v2)
    goto LABEL_25;
  v5 = v2;
  v6 = (HGObject *)HGObject::operator new(0x40uLL);
  HGObject::HGObject(v6);
  *(_QWORD *)v6 = off_1E65148B0;
  *((_QWORD *)v6 + 2) = v5;
  *((_QWORD *)v6 + 3) = 0;
  *((_QWORD *)v6 + 4) = 0;
  *((_QWORD *)v6 + 5) = 0;
  *((_QWORD *)v6 + 6) = 0x100000001;
  *((_WORD *)v6 + 28) = 0;
  *((_BYTE *)v6 + 58) = 0;
  v7 = v5;
  HGMetalDeviceInfo::_init(v6);
  v8 = (char **)qword_1ED4D94D0;
  v10 = *(char **)(qword_1ED4D94D0 + 8);
  v9 = *(_QWORD *)(qword_1ED4D94D0 + 16);
  if ((unint64_t)v10 >= v9)
  {
    v12 = *(char **)qword_1ED4D94D0;
    v13 = (uint64_t)&v10[-*(_QWORD *)qword_1ED4D94D0];
    v14 = v13 >> 3;
    v15 = (v13 >> 3) + 1;
    if (v15 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v16 = v9 - (_QWORD)v12;
    if (v16 >> 2 > v15)
      v15 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v15;
    if (v17)
    {
      if (v17 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v18 = operator new(8 * v17);
      v19 = (HGObject **)&v18[8 * v14];
      v20 = &v18[8 * v17];
      *v19 = v6;
      v11 = (uint64_t)(v19 + 1);
      v21 = (char *)(v10 - v12);
      if (v10 == v12)
        goto LABEL_22;
    }
    else
    {
      v18 = 0;
      v19 = (HGObject **)(8 * v14);
      v20 = 0;
      *(_QWORD *)(8 * v14) = v6;
      v11 = 8 * v14 + 8;
      v21 = (char *)(v10 - v12);
      if (v10 == v12)
      {
LABEL_22:
        *v8 = (char *)v19;
        v8[1] = (char *)v11;
        v8[2] = v20;
        if (v10)
          operator delete(v10);
        goto LABEL_24;
      }
    }
    v22 = (unint64_t)(v21 - 8);
    if (v22 < 0x58)
      goto LABEL_31;
    if ((unint64_t)(v10 - &v18[v13]) < 0x20)
      goto LABEL_31;
    v23 = (v22 >> 3) + 1;
    v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = &v10[-v24];
    v19 = (HGObject **)((char *)v19 - v24);
    v26 = &v18[8 * v14 - 16];
    v27 = v10 - 16;
    v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v29 = *(_OWORD *)v27;
      *(v26 - 1) = *((_OWORD *)v27 - 1);
      *v26 = v29;
      v26 -= 2;
      v27 -= 32;
      v28 -= 4;
    }
    while (v28);
    v10 = v25;
    if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        v30 = (HGObject *)*((_QWORD *)v10 - 1);
        v10 -= 8;
        *--v19 = v30;
      }
      while (v10 != v12);
    }
    v10 = *v8;
    goto LABEL_22;
  }
  *(_QWORD *)v10 = v6;
  v11 = (uint64_t)(v10 + 8);
LABEL_24:
  v8[1] = (char *)v11;

LABEL_25:
  if (*(_QWORD *)qword_1ED4D94D0 == *(_QWORD *)(qword_1ED4D94D0 + 8))
    HGLogger::warning((HGLogger *)"HGMetalDeviceInfo - No MTLDevice available.", v3, v4);
}

void sub_1B29D84CC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D84E0(_Unwind_Exception *a1)
{
  HGObject *v1;
  void *v3;

  HGObject::~HGObject(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void HGYUVPlanarToRGBA::HGYUVPlanarToRGBA(HGNode *a1, int a2, char a3)
{
  uint64_t v5;

  HGNode::HGNode(a1);
  *(_QWORD *)v5 = off_1E6514900;
  *(_QWORD *)(v5 + 408) = 0;
  *(_DWORD *)(v5 + 416) = a2;
  *(_QWORD *)(v5 + 420) = 0x300000001;
  *(_BYTE *)(v5 + 432) = 0;
  *(_BYTE *)(v5 + 433) = a3;
  *(_DWORD *)(v5 + 436) = 1;
}

void HGYUVPlanarToRGBA::~HGYUVPlanarToRGBA(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6514900;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6514900;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

HGColorConform *HGYUVPlanarToRGBA::GetOutputForXRsRGB(HGYUVPlanarToRGBA *this, HGRenderer *a2, HGNode *a3)
{
  HGNode *v3;
  int v5;
  int v6;
  _DWORD *v7;
  HGColorConform *v8;
  HGColorClamp *v9;
  HGColorConform *v10;
  char *v11;
  HGGamutMap *v13;

  v3 = a3;
  v5 = *((_DWORD *)this + 109);
  if (!v5)
  {
    v6 = 2;
LABEL_7:
    v7 = (_DWORD *)((char *)this + 428);
    goto LABEL_8;
  }
  if (v5 != 2)
  {
    if (v5 == 3)
      v6 = 3;
    else
      v6 = 0;
    goto LABEL_7;
  }
  v7 = (_DWORD *)((char *)this + 428);
  if (*((_DWORD *)this + 107) == 2)
  {
    v13 = (HGGamutMap *)HGObject::operator new(0x1E0uLL);
    HGGamutMap::HGGamutMap(v13);
    v6 = 5;
    HGGamutMap::SetConversion((uint64_t)v13, 5, 1, 0, 0, 8, 0);
    (*(void (**)(HGGamutMap *, _QWORD, HGNode *))(*(_QWORD *)v13 + 120))(v13, 0, v3);
    v3 = (HGNode *)v13;
    goto LABEL_9;
  }
  v6 = 5;
LABEL_8:
  (*(void (**)(HGNode *, HGRenderer *))(*(_QWORD *)a3 + 16))(a3, a2);
LABEL_9:
  v8 = (HGColorConform *)HGObject::operator new(0x320uLL);
  HGColorConform::HGColorConform(v8);
  HGColorConform::SetConversion((uint64_t)v8, v6, 1, 0, 0, 8, 0);
  (*(void (**)(HGColorConform *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, v3);
  if (*v7 == 1 && *((_DWORD *)this + 109) == 2)
  {
    v9 = (HGColorClamp *)HGObject::operator new(0x1C0uLL);
    HGColorClamp::HGColorClamp(v9);
    (*(void (**)(HGColorClamp *, _QWORD, HGColorConform *))(*(_QWORD *)v9 + 120))(v9, 0, v8);
  }
  else
  {
    (*(void (**)(HGColorConform *))(*(_QWORD *)v8 + 16))(v8);
    v9 = v8;
  }
  v10 = (HGColorConform *)HGObject::operator new(0x320uLL);
  HGColorConform::HGColorConform(v10);
  HGColorConform::SetConversion((uint64_t)v10, 11, v11);
  (*(void (**)(HGColorConform *, _QWORD, HGColorClamp *))(*(_QWORD *)v10 + 120))(v10, 0, v9);
  (*(void (**)(HGNode *))(*(_QWORD *)v3 + 24))(v3);
  (*(void (**)(HGColorConform *))(*(_QWORD *)v8 + 24))(v8);
  (*(void (**)(HGColorClamp *))(*(_QWORD *)v9 + 24))(v9);
  return v10;
}

void sub_1B29D87B8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D87CC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D87E4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D87FC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGNode *HGYUVPlanarToRGBA::GetOutputForPlanar(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HGNode *v5;
  HGNode *v6;
  int v7;
  int v8;
  HGNode *v9;
  HGNode *v10;
  uint64_t (**v11)();
  int v12;
  HGNode *v13;
  int v14;
  HGNode *v15;
  HGNode *v16;
  HGNode *v17;
  HGNode *v18;
  HGNode *v19;
  HGNode *v20;
  HGNode *v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;
  HGBitmapLoader *v27;
  int BitmapFormat;
  int v29;
  unsigned int v30;
  unsigned int v31;
  _BOOL4 v33;
  float v34;
  float v35;

  Input = HGRenderer::GetInput(a2, this, 0);
  v5 = HGRenderer::GetInput(a2, this, 1u);
  if (*((_BYTE *)this + 433))
  {
    v6 = HGRenderer::GetInput(a2, this, 2u);
    v7 = *((_DWORD *)this + 104);
    if (v7 != 1)
      goto LABEL_3;
  }
  else
  {
    v6 = 0;
    v7 = *((_DWORD *)this + 104);
    if (v7 != 1)
    {
LABEL_3:
      if (v7 == 2)
      {
        v8 = *((_DWORD *)this + 105);
        if (v8 == 2)
        {
          v16 = (HGNode *)HGObject::operator new(0x1A0uLL);
          v10 = v16;
          *(_OWORD *)v16 = 0u;
          *((_OWORD *)v16 + 1) = 0u;
          *((_OWORD *)v16 + 2) = 0u;
          *((_OWORD *)v16 + 3) = 0u;
          *((_OWORD *)v16 + 4) = 0u;
          *((_OWORD *)v16 + 5) = 0u;
          *((_OWORD *)v16 + 6) = 0u;
          *((_OWORD *)v16 + 7) = 0u;
          *((_OWORD *)v16 + 8) = 0u;
          *((_OWORD *)v16 + 9) = 0u;
          *((_OWORD *)v16 + 10) = 0u;
          *((_OWORD *)v16 + 11) = 0u;
          *((_OWORD *)v16 + 12) = 0u;
          *((_OWORD *)v16 + 13) = 0u;
          *((_OWORD *)v16 + 14) = 0u;
          *((_OWORD *)v16 + 15) = 0u;
          *((_OWORD *)v16 + 16) = 0u;
          *((_OWORD *)v16 + 17) = 0u;
          *((_OWORD *)v16 + 18) = 0u;
          *((_OWORD *)v16 + 19) = 0u;
          *((_OWORD *)v16 + 20) = 0u;
          *((_OWORD *)v16 + 21) = 0u;
          *((_OWORD *)v16 + 22) = 0u;
          *((_OWORD *)v16 + 23) = 0u;
          *((_OWORD *)v16 + 24) = 0u;
          *((_OWORD *)v16 + 25) = 0u;
          if (v6)
          {
            HgcYUV444TriPlanar_2020ToRGB::HgcYUV444TriPlanar_2020ToRGB((HgcYUV444TriPlanar_2020ToRGB *)v16);
            v11 = off_1E6515508;
          }
          else
          {
            HgcYUV444BiPlanar_2020ToRGB::HgcYUV444BiPlanar_2020ToRGB((HgcYUV444BiPlanar_2020ToRGB *)v16);
            v11 = off_1E6515770;
          }
        }
        else if (v8)
        {
          v17 = (HGNode *)HGObject::operator new(0x1A0uLL);
          v10 = v17;
          *(_OWORD *)v17 = 0u;
          *((_OWORD *)v17 + 1) = 0u;
          *((_OWORD *)v17 + 2) = 0u;
          *((_OWORD *)v17 + 3) = 0u;
          *((_OWORD *)v17 + 4) = 0u;
          *((_OWORD *)v17 + 5) = 0u;
          *((_OWORD *)v17 + 6) = 0u;
          *((_OWORD *)v17 + 7) = 0u;
          *((_OWORD *)v17 + 8) = 0u;
          *((_OWORD *)v17 + 9) = 0u;
          *((_OWORD *)v17 + 10) = 0u;
          *((_OWORD *)v17 + 11) = 0u;
          *((_OWORD *)v17 + 12) = 0u;
          *((_OWORD *)v17 + 13) = 0u;
          *((_OWORD *)v17 + 14) = 0u;
          *((_OWORD *)v17 + 15) = 0u;
          *((_OWORD *)v17 + 16) = 0u;
          *((_OWORD *)v17 + 17) = 0u;
          *((_OWORD *)v17 + 18) = 0u;
          *((_OWORD *)v17 + 19) = 0u;
          *((_OWORD *)v17 + 20) = 0u;
          *((_OWORD *)v17 + 21) = 0u;
          *((_OWORD *)v17 + 22) = 0u;
          *((_OWORD *)v17 + 23) = 0u;
          *((_OWORD *)v17 + 24) = 0u;
          *((_OWORD *)v17 + 25) = 0u;
          if (v6)
          {
            HgcYUV444TriPlanar_709ToRGB::HgcYUV444TriPlanar_709ToRGB((HgcYUV444TriPlanar_709ToRGB *)v17);
            v11 = off_1E65159D8;
          }
          else
          {
            HgcYUV444BiPlanar_709ToRGB::HgcYUV444BiPlanar_709ToRGB((HgcYUV444BiPlanar_709ToRGB *)v17);
            v11 = off_1E6515C40;
          }
        }
        else
        {
          v9 = (HGNode *)HGObject::operator new(0x1A0uLL);
          v10 = v9;
          *(_OWORD *)v9 = 0u;
          *((_OWORD *)v9 + 1) = 0u;
          *((_OWORD *)v9 + 2) = 0u;
          *((_OWORD *)v9 + 3) = 0u;
          *((_OWORD *)v9 + 4) = 0u;
          *((_OWORD *)v9 + 5) = 0u;
          *((_OWORD *)v9 + 6) = 0u;
          *((_OWORD *)v9 + 7) = 0u;
          *((_OWORD *)v9 + 8) = 0u;
          *((_OWORD *)v9 + 9) = 0u;
          *((_OWORD *)v9 + 10) = 0u;
          *((_OWORD *)v9 + 11) = 0u;
          *((_OWORD *)v9 + 12) = 0u;
          *((_OWORD *)v9 + 13) = 0u;
          *((_OWORD *)v9 + 14) = 0u;
          *((_OWORD *)v9 + 15) = 0u;
          *((_OWORD *)v9 + 16) = 0u;
          *((_OWORD *)v9 + 17) = 0u;
          *((_OWORD *)v9 + 18) = 0u;
          *((_OWORD *)v9 + 19) = 0u;
          *((_OWORD *)v9 + 20) = 0u;
          *((_OWORD *)v9 + 21) = 0u;
          *((_OWORD *)v9 + 22) = 0u;
          *((_OWORD *)v9 + 23) = 0u;
          *((_OWORD *)v9 + 24) = 0u;
          *((_OWORD *)v9 + 25) = 0u;
          if (v6)
          {
            HgcYUV444TriPlanar_601ToRGB::HgcYUV444TriPlanar_601ToRGB((HgcYUV444TriPlanar_601ToRGB *)v9);
            v11 = off_1E6515038;
          }
          else
          {
            HgcYUV444BiPlanar_601ToRGB::HgcYUV444BiPlanar_601ToRGB((HgcYUV444BiPlanar_601ToRGB *)v9);
            v11 = off_1E65152A0;
          }
        }
      }
      else
      {
        v14 = *((_DWORD *)this + 105);
        if (v14 == 2)
        {
          v20 = (HGNode *)HGObject::operator new(0x1A0uLL);
          v10 = v20;
          *(_OWORD *)v20 = 0u;
          *((_OWORD *)v20 + 1) = 0u;
          *((_OWORD *)v20 + 2) = 0u;
          *((_OWORD *)v20 + 3) = 0u;
          *((_OWORD *)v20 + 4) = 0u;
          *((_OWORD *)v20 + 5) = 0u;
          *((_OWORD *)v20 + 6) = 0u;
          *((_OWORD *)v20 + 7) = 0u;
          *((_OWORD *)v20 + 8) = 0u;
          *((_OWORD *)v20 + 9) = 0u;
          *((_OWORD *)v20 + 10) = 0u;
          *((_OWORD *)v20 + 11) = 0u;
          *((_OWORD *)v20 + 12) = 0u;
          *((_OWORD *)v20 + 13) = 0u;
          *((_OWORD *)v20 + 14) = 0u;
          *((_OWORD *)v20 + 15) = 0u;
          *((_OWORD *)v20 + 16) = 0u;
          *((_OWORD *)v20 + 17) = 0u;
          *((_OWORD *)v20 + 18) = 0u;
          *((_OWORD *)v20 + 19) = 0u;
          *((_OWORD *)v20 + 20) = 0u;
          *((_OWORD *)v20 + 21) = 0u;
          *((_OWORD *)v20 + 22) = 0u;
          *((_OWORD *)v20 + 23) = 0u;
          *((_OWORD *)v20 + 24) = 0u;
          *((_OWORD *)v20 + 25) = 0u;
          if (v6)
          {
            HgcYUV420TriPlanar_2020ToRGB::HgcYUV420TriPlanar_2020ToRGB((HgcYUV420TriPlanar_2020ToRGB *)v20);
            v11 = off_1E65171E8;
          }
          else
          {
            HgcYUV420BiPlanar_2020ToRGB::HgcYUV420BiPlanar_2020ToRGB((HgcYUV420BiPlanar_2020ToRGB *)v20);
            v11 = off_1E6517450;
          }
        }
        else if (v14)
        {
          v21 = (HGNode *)HGObject::operator new(0x1A0uLL);
          v10 = v21;
          *(_OWORD *)v21 = 0u;
          *((_OWORD *)v21 + 1) = 0u;
          *((_OWORD *)v21 + 2) = 0u;
          *((_OWORD *)v21 + 3) = 0u;
          *((_OWORD *)v21 + 4) = 0u;
          *((_OWORD *)v21 + 5) = 0u;
          *((_OWORD *)v21 + 6) = 0u;
          *((_OWORD *)v21 + 7) = 0u;
          *((_OWORD *)v21 + 8) = 0u;
          *((_OWORD *)v21 + 9) = 0u;
          *((_OWORD *)v21 + 10) = 0u;
          *((_OWORD *)v21 + 11) = 0u;
          *((_OWORD *)v21 + 12) = 0u;
          *((_OWORD *)v21 + 13) = 0u;
          *((_OWORD *)v21 + 14) = 0u;
          *((_OWORD *)v21 + 15) = 0u;
          *((_OWORD *)v21 + 16) = 0u;
          *((_OWORD *)v21 + 17) = 0u;
          *((_OWORD *)v21 + 18) = 0u;
          *((_OWORD *)v21 + 19) = 0u;
          *((_OWORD *)v21 + 20) = 0u;
          *((_OWORD *)v21 + 21) = 0u;
          *((_OWORD *)v21 + 22) = 0u;
          *((_OWORD *)v21 + 23) = 0u;
          *((_OWORD *)v21 + 24) = 0u;
          *((_OWORD *)v21 + 25) = 0u;
          if (v6)
          {
            HgcYUV420TriPlanar_709ToRGB::HgcYUV420TriPlanar_709ToRGB((HgcYUV420TriPlanar_709ToRGB *)v21);
            v11 = off_1E65176B8;
          }
          else
          {
            HgcYUV420BiPlanar_709ToRGB::HgcYUV420BiPlanar_709ToRGB((HgcYUV420BiPlanar_709ToRGB *)v21);
            v11 = off_1E6517920;
          }
        }
        else
        {
          v15 = (HGNode *)HGObject::operator new(0x1A0uLL);
          v10 = v15;
          *(_OWORD *)v15 = 0u;
          *((_OWORD *)v15 + 1) = 0u;
          *((_OWORD *)v15 + 2) = 0u;
          *((_OWORD *)v15 + 3) = 0u;
          *((_OWORD *)v15 + 4) = 0u;
          *((_OWORD *)v15 + 5) = 0u;
          *((_OWORD *)v15 + 6) = 0u;
          *((_OWORD *)v15 + 7) = 0u;
          *((_OWORD *)v15 + 8) = 0u;
          *((_OWORD *)v15 + 9) = 0u;
          *((_OWORD *)v15 + 10) = 0u;
          *((_OWORD *)v15 + 11) = 0u;
          *((_OWORD *)v15 + 12) = 0u;
          *((_OWORD *)v15 + 13) = 0u;
          *((_OWORD *)v15 + 14) = 0u;
          *((_OWORD *)v15 + 15) = 0u;
          *((_OWORD *)v15 + 16) = 0u;
          *((_OWORD *)v15 + 17) = 0u;
          *((_OWORD *)v15 + 18) = 0u;
          *((_OWORD *)v15 + 19) = 0u;
          *((_OWORD *)v15 + 20) = 0u;
          *((_OWORD *)v15 + 21) = 0u;
          *((_OWORD *)v15 + 22) = 0u;
          *((_OWORD *)v15 + 23) = 0u;
          *((_OWORD *)v15 + 24) = 0u;
          *((_OWORD *)v15 + 25) = 0u;
          if (v6)
          {
            HgcYUV420TriPlanar_601ToRGB::HgcYUV420TriPlanar_601ToRGB((HgcYUV420TriPlanar_601ToRGB *)v15);
            v11 = off_1E6516D18;
          }
          else
          {
            HgcYUV420BiPlanar_601ToRGB::HgcYUV420BiPlanar_601ToRGB((HgcYUV420BiPlanar_601ToRGB *)v15);
            v11 = off_1E6516F80;
          }
        }
      }
      goto LABEL_38;
    }
  }
  v12 = *((_DWORD *)this + 105);
  if (v12 == 2)
  {
    v18 = (HGNode *)HGObject::operator new(0x1A0uLL);
    v10 = v18;
    *(_OWORD *)v18 = 0u;
    *((_OWORD *)v18 + 1) = 0u;
    *((_OWORD *)v18 + 2) = 0u;
    *((_OWORD *)v18 + 3) = 0u;
    *((_OWORD *)v18 + 4) = 0u;
    *((_OWORD *)v18 + 5) = 0u;
    *((_OWORD *)v18 + 6) = 0u;
    *((_OWORD *)v18 + 7) = 0u;
    *((_OWORD *)v18 + 8) = 0u;
    *((_OWORD *)v18 + 9) = 0u;
    *((_OWORD *)v18 + 10) = 0u;
    *((_OWORD *)v18 + 11) = 0u;
    *((_OWORD *)v18 + 12) = 0u;
    *((_OWORD *)v18 + 13) = 0u;
    *((_OWORD *)v18 + 14) = 0u;
    *((_OWORD *)v18 + 15) = 0u;
    *((_OWORD *)v18 + 16) = 0u;
    *((_OWORD *)v18 + 17) = 0u;
    *((_OWORD *)v18 + 18) = 0u;
    *((_OWORD *)v18 + 19) = 0u;
    *((_OWORD *)v18 + 20) = 0u;
    *((_OWORD *)v18 + 21) = 0u;
    *((_OWORD *)v18 + 22) = 0u;
    *((_OWORD *)v18 + 23) = 0u;
    *((_OWORD *)v18 + 24) = 0u;
    *((_OWORD *)v18 + 25) = 0u;
    if (v6)
    {
      HgcYUV422TriPlanar_2020ToRGB::HgcYUV422TriPlanar_2020ToRGB((HgcYUV422TriPlanar_2020ToRGB *)v18);
      v11 = off_1E6516378;
    }
    else
    {
      HgcYUV422BiPlanar_2020ToRGB::HgcYUV422BiPlanar_2020ToRGB((HgcYUV422BiPlanar_2020ToRGB *)v18);
      v11 = off_1E65165E0;
    }
  }
  else if (v12)
  {
    v19 = (HGNode *)HGObject::operator new(0x1A0uLL);
    v10 = v19;
    *(_OWORD *)v19 = 0u;
    *((_OWORD *)v19 + 1) = 0u;
    *((_OWORD *)v19 + 2) = 0u;
    *((_OWORD *)v19 + 3) = 0u;
    *((_OWORD *)v19 + 4) = 0u;
    *((_OWORD *)v19 + 5) = 0u;
    *((_OWORD *)v19 + 6) = 0u;
    *((_OWORD *)v19 + 7) = 0u;
    *((_OWORD *)v19 + 8) = 0u;
    *((_OWORD *)v19 + 9) = 0u;
    *((_OWORD *)v19 + 10) = 0u;
    *((_OWORD *)v19 + 11) = 0u;
    *((_OWORD *)v19 + 12) = 0u;
    *((_OWORD *)v19 + 13) = 0u;
    *((_OWORD *)v19 + 14) = 0u;
    *((_OWORD *)v19 + 15) = 0u;
    *((_OWORD *)v19 + 16) = 0u;
    *((_OWORD *)v19 + 17) = 0u;
    *((_OWORD *)v19 + 18) = 0u;
    *((_OWORD *)v19 + 19) = 0u;
    *((_OWORD *)v19 + 20) = 0u;
    *((_OWORD *)v19 + 21) = 0u;
    *((_OWORD *)v19 + 22) = 0u;
    *((_OWORD *)v19 + 23) = 0u;
    *((_OWORD *)v19 + 24) = 0u;
    *((_OWORD *)v19 + 25) = 0u;
    if (v6)
    {
      HgcYUV422TriPlanar_709ToRGB::HgcYUV422TriPlanar_709ToRGB((HgcYUV422TriPlanar_709ToRGB *)v19);
      v11 = off_1E6516848;
    }
    else
    {
      HgcYUV422BiPlanar_709ToRGB::HgcYUV422BiPlanar_709ToRGB((HgcYUV422BiPlanar_709ToRGB *)v19);
      v11 = off_1E6516AB0;
    }
  }
  else
  {
    v13 = (HGNode *)HGObject::operator new(0x1A0uLL);
    v10 = v13;
    *(_OWORD *)v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    *((_OWORD *)v13 + 2) = 0u;
    *((_OWORD *)v13 + 3) = 0u;
    *((_OWORD *)v13 + 4) = 0u;
    *((_OWORD *)v13 + 5) = 0u;
    *((_OWORD *)v13 + 6) = 0u;
    *((_OWORD *)v13 + 7) = 0u;
    *((_OWORD *)v13 + 8) = 0u;
    *((_OWORD *)v13 + 9) = 0u;
    *((_OWORD *)v13 + 10) = 0u;
    *((_OWORD *)v13 + 11) = 0u;
    *((_OWORD *)v13 + 12) = 0u;
    *((_OWORD *)v13 + 13) = 0u;
    *((_OWORD *)v13 + 14) = 0u;
    *((_OWORD *)v13 + 15) = 0u;
    *((_OWORD *)v13 + 16) = 0u;
    *((_OWORD *)v13 + 17) = 0u;
    *((_OWORD *)v13 + 18) = 0u;
    *((_OWORD *)v13 + 19) = 0u;
    *((_OWORD *)v13 + 20) = 0u;
    *((_OWORD *)v13 + 21) = 0u;
    *((_OWORD *)v13 + 22) = 0u;
    *((_OWORD *)v13 + 23) = 0u;
    *((_OWORD *)v13 + 24) = 0u;
    *((_OWORD *)v13 + 25) = 0u;
    if (v6)
    {
      HgcYUV422TriPlanar_601ToRGB::HgcYUV422TriPlanar_601ToRGB((HgcYUV422TriPlanar_601ToRGB *)v13);
      v11 = off_1E6515EA8;
    }
    else
    {
      HgcYUV422BiPlanar_601ToRGB::HgcYUV422BiPlanar_601ToRGB((HgcYUV422BiPlanar_601ToRGB *)v13);
      v11 = off_1E6516110;
    }
  }
LABEL_38:
  *(_QWORD *)v10 = v11;
  ((void (*)(HGNode *, unsigned int, HGNode *))v11[15])(v10, 0, Input);
  (*(void (**)(HGNode *, uint64_t, HGNode *))(*(_QWORD *)v10 + 120))(v10, 1, v5);
  if (v6)
    (*(void (**)(HGNode *, uint64_t, HGNode *))(*(_QWORD *)v10 + 120))(v10, 2, v6);
  if (Input)
  {
    if (v27)
    {
      BitmapFormat = HGBitmapLoader::GetBitmapFormat(v27);
      LODWORD(v27) = HGFormatUtils::bytesPerPixel(BitmapFormat);
    }
  }
  else
  {
    LODWORD(v27) = 0;
  }
  v29 = *((_DWORD *)this + 106);
  v30 = v29 - 3;
  v23.n128_u32[0] = 1.0;
  if (v29 == 1)
    v23.n128_f32[0] = 1.001;
  v31 = v29 - 4;
  v33 = (_DWORD)v27 == 2 || v31 < 3;
  v22.n128_u32[0] = 1066732165;
  if (v33)
    v22.n128_f32[0] = 1.1689;
  v24.n128_u32[0] = 1066514139;
  if (v33)
    v24.n128_f32[0] = 1.1428;
  v25.n128_u32[0] = -1089320667;
  v26.n128_u32[0] = -1114267611;
  if (v30 <= 3)
  {
    v34 = -0.073059;
  }
  else
  {
    v22.n128_f32[0] = v23.n128_f32[0];
    v34 = 0.0;
  }
  if (v30 > 3)
  {
    v35 = -0.5;
  }
  else
  {
    v23.n128_f32[0] = v24.n128_f32[0];
    v35 = -0.57143;
  }
  (*(void (**)(HGNode *, _QWORD, __n128, __n128, float, float, __n128, __n128, __n128))(*(_QWORD *)v10 + 96))(v10, 0, v22, v23, v23.n128_f32[0], 1.0, v24, v25, v26);
  (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(_QWORD *)v10 + 96))(v10, 1, v34, v35, v35, 0.0);
  return v10;
}

void sub_1B29D8E18(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8E2C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8E40(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8E54(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8E68(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8E7C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8E90(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8EA4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8EB8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8ECC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8EE0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8EF4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8F08(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8F1C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8F30(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8F44(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8F58(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29D8F6C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGYUVPlanarToRGBA::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGRenderer *v3;
  HGNode *OutputForPlanar;
  HGColorConform *OutputForXRsRGB;
  HGColorConform *v6;
  HGNode *v7;

  OutputForPlanar = HGYUVPlanarToRGBA::GetOutputForPlanar(this, a2);
  if (*((_BYTE *)this + 432))
  {
    OutputForXRsRGB = HGYUVPlanarToRGBA::GetOutputForXRsRGB((HGYUVPlanarToRGBA *)this, v3, OutputForPlanar);
    v6 = (HGColorConform *)*((_QWORD *)this + 51);
    if (v6 == OutputForXRsRGB)
    {
      if (OutputForXRsRGB)
        (*(void (**)(HGColorConform *))(*(_QWORD *)OutputForXRsRGB + 24))(OutputForXRsRGB);
    }
    else
    {
      if (v6)
        (*(void (**)(HGColorConform *))(*(_QWORD *)v6 + 24))(v6);
      *((_QWORD *)this + 51) = OutputForXRsRGB;
    }
    (*(void (**)(HGNode *))(*(_QWORD *)OutputForPlanar + 24))(OutputForPlanar);
    return *((_QWORD *)this + 51);
  }
  else
  {
    v7 = (HGNode *)*((_QWORD *)this + 51);
    if (v7 == OutputForPlanar)
    {
      if (OutputForPlanar)
        (*(void (**)(HGNode *))(*(_QWORD *)OutputForPlanar + 24))(OutputForPlanar);
    }
    else
    {
      if (v7)
        (*(void (**)(HGNode *))(*(_QWORD *)v7 + 24))(v7);
      *((_QWORD *)this + 51) = OutputForPlanar;
    }
    return *((_QWORD *)this + 51);
  }
}

void sub_1B29D9064(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HGYUVPlanarToRGBA::SetParameter(HGYUVPlanarToRGBA *this, int a2, float a3, float a4, float a5, float a6)
{
  int v7;
  unsigned int v8;
  unsigned int v9;

  if (a2 == 2)
  {
    v7 = a3 != 0.0;
    v8 = a4;
    v9 = a5;
    if (*((unsigned __int8 *)this + 432) == v7 && *((_DWORD *)this + 109) == v8 && *((_DWORD *)this + 107) == v9)
    {
      return 0;
    }
    else
    {
      *((_BYTE *)this + 432) = v7;
      *((_DWORD *)this + 109) = v8;
      *((_DWORD *)this + 107) = v9;
      return 1;
    }
  }
  else if (a2 == 1)
  {
    if (*((_DWORD *)this + 106) == a3)
    {
      return 0;
    }
    else
    {
      *((_DWORD *)this + 106) = a3;
      return 1;
    }
  }
  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }
  else if (*((_DWORD *)this + 105) == a3)
  {
    return 0;
  }
  else
  {
    *((_DWORD *)this + 105) = a3;
    return 1;
  }
}

void HGYUV444ToPlanarLuma::HGYUV444ToPlanarLuma(HGNode *a1, int a2)
{
  uint64_t v3;

  HGNode::HGNode(a1);
  *(_QWORD *)v3 = off_1E6514B50;
  *(_QWORD *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 416) = a2;
}

void HGYUV444ToPlanarLuma::~HGYUV444ToPlanarLuma(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6514B50;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6514B50;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGYUV444ToPlanarLuma::GetOutput(HGYUV444ToPlanarLuma *this, HGRenderer *a2)
{
  int v4;
  HgcYUV420BiPlanar_luma_pack2 *v5;
  HgcYUV420BiPlanar_luma_pack2 *v6;
  uint64_t v7;
  HGNode *Input;

  v4 = *((_DWORD *)this + 104);
  if (v4 == 1)
  {
    v5 = (HgcYUV420BiPlanar_luma_pack2 *)HGObject::operator new(0x1A0uLL);
    HgcYUV420BiPlanar_luma_pack2::HgcYUV420BiPlanar_luma_pack2(v5);
    v6 = (HgcYUV420BiPlanar_luma_pack2 *)*((_QWORD *)this + 51);
    if (v6 != v5)
    {
      if (v6)
        goto LABEL_11;
      goto LABEL_12;
    }
    if (!v5)
      goto LABEL_13;
    goto LABEL_19;
  }
  if (!v4)
  {
    v5 = (HgcYUV420BiPlanar_luma_pack2 *)HGObject::operator new(0x1A0uLL);
    HgcYUV420BiPlanar_luma_pack4::HgcYUV420BiPlanar_luma_pack4(v5);
    v6 = (HgcYUV420BiPlanar_luma_pack2 *)*((_QWORD *)this + 51);
    if (v6 != v5)
    {
      if (v6)
        goto LABEL_11;
      goto LABEL_12;
    }
    if (!v5)
      goto LABEL_13;
LABEL_19:
    (*(void (**)(HgcYUV420BiPlanar_luma_pack2 *))(*(_QWORD *)v5 + 24))(v5);
    goto LABEL_13;
  }
  v5 = (HgcYUV420BiPlanar_luma_pack2 *)HGObject::operator new(0x1A0uLL);
  HgcYUV420BiPlanar_luma::HgcYUV420BiPlanar_luma(v5);
  v6 = (HgcYUV420BiPlanar_luma_pack2 *)*((_QWORD *)this + 51);
  if (v6 == v5)
  {
    if (!v5)
      goto LABEL_13;
    goto LABEL_19;
  }
  if (v6)
LABEL_11:
    (*(void (**)(HgcYUV420BiPlanar_luma_pack2 *))(*(_QWORD *)v6 + 24))(v6);
LABEL_12:
  *((_QWORD *)this + 51) = v5;
LABEL_13:
  v7 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v7 + 120))(v7, 0, Input);
  return *((_QWORD *)this + 51);
}

void sub_1B29D9364(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void HGYUV444ToPlanarChroma::HGYUV444ToPlanarChroma(HGNode *a1, int a2, int a3)
{
  uint64_t v5;

  HGNode::HGNode(a1);
  *(_QWORD *)v5 = off_1E6514DA0;
  *(_QWORD *)(v5 + 408) = 0;
  *(_DWORD *)(v5 + 416) = a3;
  *(_DWORD *)(v5 + 420) = a2;
}

void HGYUV444ToPlanarChroma::~HGYUV444ToPlanarChroma(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6514DA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6514DA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGYUV444ToPlanarChroma::GetOutput(HGYUV444ToPlanarChroma *this, HGRenderer *a2)
{
  int v4;
  int v5;
  HgcYUV420BiPlanar_chroma *v6;
  HgcYUV444BiPlanar_chroma *v7;
  HgcYUV444BiPlanar_chroma *v8;
  int v9;
  HgcYUV422BiPlanar_chroma *v10;
  uint64_t v11;
  HGNode *Input;

  v4 = *((_DWORD *)this + 104);
  if (v4 == 1)
  {
    v9 = *((_DWORD *)this + 105);
    v10 = (HgcYUV422BiPlanar_chroma *)HGObject::operator new(0x1A0uLL);
    v7 = v10;
    if (v9)
    {
      HgcYUV422BiPlanar_chroma::HgcYUV422BiPlanar_chroma(v10);
      v8 = (HgcYUV444BiPlanar_chroma *)*((_QWORD *)this + 51);
      if (v8 != v7)
      {
        if (v8)
          goto LABEL_23;
        goto LABEL_24;
      }
      if (!v7)
        goto LABEL_25;
    }
    else
    {
      HgcYUV422BiPlanar_chroma_pack2::HgcYUV422BiPlanar_chroma_pack2(v10);
      v8 = (HgcYUV444BiPlanar_chroma *)*((_QWORD *)this + 51);
      if (v8 != v7)
      {
        if (v8)
          goto LABEL_23;
        goto LABEL_24;
      }
      if (!v7)
        goto LABEL_25;
    }
    goto LABEL_37;
  }
  if (!v4)
  {
    v5 = *((_DWORD *)this + 105);
    v6 = (HgcYUV420BiPlanar_chroma *)HGObject::operator new(0x1A0uLL);
    v7 = v6;
    if (v5)
    {
      HgcYUV420BiPlanar_chroma::HgcYUV420BiPlanar_chroma(v6);
      v8 = (HgcYUV444BiPlanar_chroma *)*((_QWORD *)this + 51);
      if (v8 != v7)
      {
        if (v8)
          goto LABEL_23;
        goto LABEL_24;
      }
      if (!v7)
        goto LABEL_25;
    }
    else
    {
      HgcYUV420BiPlanar_chroma_pack2::HgcYUV420BiPlanar_chroma_pack2(v6);
      v8 = (HgcYUV444BiPlanar_chroma *)*((_QWORD *)this + 51);
      if (v8 != v7)
      {
        if (v8)
          goto LABEL_23;
        goto LABEL_24;
      }
      if (!v7)
        goto LABEL_25;
    }
LABEL_37:
    (*(void (**)(HgcYUV444BiPlanar_chroma *))(*(_QWORD *)v7 + 24))(v7);
    goto LABEL_25;
  }
  if (*((_DWORD *)this + 105))
  {
    v7 = (HgcYUV444BiPlanar_chroma *)HGObject::operator new(0x200uLL);
    HgcYUV444BiPlanar_chroma::HgcYUV444BiPlanar_chroma(v7);
    v8 = (HgcYUV444BiPlanar_chroma *)*((_QWORD *)this + 51);
    if (v8 != v7)
    {
      if (v8)
        goto LABEL_23;
      goto LABEL_24;
    }
    if (!v7)
      goto LABEL_25;
    goto LABEL_37;
  }
  v7 = (HgcYUV444BiPlanar_chroma *)HGObject::operator new(0x1A0uLL);
  HgcYUV444BiPlanar_chroma_pack2::HgcYUV444BiPlanar_chroma_pack2(v7);
  v8 = (HgcYUV444BiPlanar_chroma *)*((_QWORD *)this + 51);
  if (v8 == v7)
  {
    if (!v7)
      goto LABEL_25;
    goto LABEL_37;
  }
  if (v8)
LABEL_23:
    (*(void (**)(HgcYUV444BiPlanar_chroma *))(*(_QWORD *)v8 + 24))(v8);
LABEL_24:
  *((_QWORD *)this + 51) = v7;
LABEL_25:
  v11 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v11 + 120))(v11, 0, Input);
  return *((_QWORD *)this + 51);
}

void sub_1B29D96E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void PlanarToRGB<HgcYUV444TriPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV444TriPlanar_601ToRGB::~HgcYUV444TriPlanar_601ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444TriPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444TriPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV444BiPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV444BiPlanar_601ToRGB::~HgcYUV444BiPlanar_601ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444BiPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444BiPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV444TriPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV444TriPlanar_2020ToRGB::~HgcYUV444TriPlanar_2020ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444TriPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444TriPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV444BiPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV444BiPlanar_2020ToRGB::~HgcYUV444BiPlanar_2020ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444BiPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444BiPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV444TriPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV444TriPlanar_709ToRGB::~HgcYUV444TriPlanar_709ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444TriPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444TriPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV444BiPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV444BiPlanar_709ToRGB::~HgcYUV444BiPlanar_709ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV444BiPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV444BiPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV422TriPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV422TriPlanar_601ToRGB::~HgcYUV422TriPlanar_601ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422TriPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422TriPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV422BiPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV422BiPlanar_601ToRGB::~HgcYUV422BiPlanar_601ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422BiPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422BiPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV422TriPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV422TriPlanar_2020ToRGB::~HgcYUV422TriPlanar_2020ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422TriPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422TriPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV422BiPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV422BiPlanar_2020ToRGB::~HgcYUV422BiPlanar_2020ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422BiPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422BiPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV422TriPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV422TriPlanar_709ToRGB::~HgcYUV422TriPlanar_709ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422TriPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422TriPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV422BiPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV422BiPlanar_709ToRGB::~HgcYUV422BiPlanar_709ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV422BiPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV422BiPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV420TriPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV420TriPlanar_601ToRGB::~HgcYUV420TriPlanar_601ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420TriPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420TriPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV420BiPlanar_601ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV420BiPlanar_601ToRGB::~HgcYUV420BiPlanar_601ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420BiPlanar_601ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420BiPlanar_601ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV420TriPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV420TriPlanar_2020ToRGB::~HgcYUV420TriPlanar_2020ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420TriPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420TriPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV420BiPlanar_2020ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV420BiPlanar_2020ToRGB::~HgcYUV420BiPlanar_2020ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420BiPlanar_2020ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420BiPlanar_2020ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV420TriPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV420TriPlanar_709ToRGB::~HgcYUV420TriPlanar_709ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420TriPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420TriPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void PlanarToRGB<HgcYUV420BiPlanar_709ToRGB>::~PlanarToRGB(HGNode *a1)
{
  void *v1;

  HgcYUV420BiPlanar_709ToRGB::~HgcYUV420BiPlanar_709ToRGB(a1);
  HGObject::operator delete(v1);
}

const char *PlanarToRGB<HgcYUV420BiPlanar_709ToRGB>::label_A()
{
  return "PlanarToRGB";
}

uint64_t PlanarToRGB<HgcYUV420BiPlanar_709ToRGB>::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

const char *HGFormat_repr(unsigned int a1)
{
  if (a1 > 0x29)
    return "unknown format";
  else
    return off_1E6517B78[a1];
}

HGObject *HGComicLookupFilterLUTBitmapResourceImplementation::HGComicLookupFilterLUTBitmapResourceImplementation(HGObject *a1, HGComicLookupFilterLUTBitmapResourceImplementation *a2)
{
  uint64_t v4;
  unsigned __int8 v5;
  HGComicLUT *Rect;
  uint64_t v7;
  uint64_t v8;
  int Format;
  void *Data;
  HGBitmap *v11;
  HGComicLUT *v12;
  HGComicLUT *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  HGBitmap *v18;
  HGBitmap *v20;
  _BYTE v21[8];
  void *v22;
  HGComicLUT *v23;

  HGObject::HGObject(a1);
  *(_QWORD *)v4 = off_1E6517CD8;
  *(_DWORD *)(v4 + 12) = (_DWORD)a2;
  if ((v5 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4AB8], &HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex, &dword_1B2737000);
  }
  std::mutex::lock(&HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex);
  HGComicLookupFilterLUTBitmapResourceImplementation::getCachedLUT(a2, &v23);
  if (v23)
  {
    (*(void (**)(HGComicLUT *))(*(_QWORD *)v23 + 24))(v23);
  }
  else
  {
    Rect = (HGComicLUT *)HGComicLUT::GetRect(0);
    v8 = v7;
    Format = HGComicLUT::GetFormat(Rect);
    Data = HGComicLUT::GetData((int)a2);
    v11 = (HGBitmap *)HGObject::operator new(0x80uLL);
    v12 = (HGComicLUT *)HGBitmap::HGBitmap((uint64_t)v11, (uint64_t)Rect, v8, Format, (uint64_t)Data);
    v13 = (HGComicLUT *)HGComicLUT::GetFormat(v12);
    if ((_DWORD)v13 == 17)
    {
      v14 = HGComicLUT::GetRect(v13);
      v16 = v15;
      v17 = HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(v17, v14, v16, 24);
      v22 = v17;
      HGComicLookupFilterLUTBitmapResourceImplementation::cacheLUT((int)a2, (uint64_t *)&v22);
      if (v17)
        (*(void (**)(void *))(*(_QWORD *)v17 + 24))(v17);
      HGRenderUtils::BufferReformatter::BufferReformatter((HGRenderUtils::BufferReformatter *)v21);
      HGComicLookupFilterLUTBitmapResourceImplementation::getCachedLUT(a2, &v20);
      v18 = v20;
      HGRenderUtils::BufferReformatter::execute((HGRenderUtils::BufferReformatter *)v21, v20, v11);
      if (v18)
        (*(void (**)(HGBitmap *))(*(_QWORD *)v18 + 24))(v18);
      HGRenderUtils::BufferReformatter::~BufferReformatter((HGRenderUtils::BufferReformatter *)v21);
    }
    if (v11)
      (*(void (**)(HGBitmap *))(*(_QWORD *)v11 + 24))(v11);
  }
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex);
  return a1;
}

void sub_1B29D9E4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  HGObject *v2;
  uint64_t v3;
  uint64_t v4;
  va_list va;

  va_start(va, a2);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  HGRenderUtils::BufferReformatter::~BufferReformatter((HGRenderUtils::BufferReformatter *)va);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getInstanceMutex(void)::instanceMutex);
  HGObject::~HGObject(v2);
  _Unwind_Resume(a1);
}

void sub_1B29D9F1C(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGComicLookupFilterLUTBitmapResourceImplementation::getCachedLUT(HGComicLookupFilterLUTBitmapResourceImplementation *this@<X0>, _QWORD *a2@<X8>)
{
  int v2;
  unsigned __int8 v4;
  unsigned __int8 v5;
  uint64_t v6;

  v2 = (int)this;
  if ((v4 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4AB8], &HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex, &dword_1B2737000);
  }
  std::mutex::lock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  if (v2 > 5)
  {
    *a2 = 0;
    std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  }
  else
  {
    if ((v5 & 1) == 0
    {
      off_1EEFEECB8 = 0u;
      *(_OWORD *)&off_1EEFEECC8 = 0u;
      HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data = 0u;
      __cxa_atexit((void (*)(void *))__cxx_global_array_dtor, 0, &dword_1B2737000);
    }
    v6 = *((_QWORD *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + v2);
    *a2 = v6;
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
    std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  }
}

void sub_1B29DA054(_Unwind_Exception *a1)
{
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  _Unwind_Resume(a1);
}

void HGComicLookupFilterLUTBitmapResourceImplementation::cacheLUT(int a1, uint64_t *a2)
{
  unsigned __int8 v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;

  if ((v4 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4AB8], &HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex, &dword_1B2737000);
  }
  std::mutex::lock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  if (a1 <= 5)
  {
    if ((v5 & 1) == 0
    {
      off_1EEFEECB8 = 0u;
      *(_OWORD *)&off_1EEFEECC8 = 0u;
      HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data = 0u;
      __cxa_atexit((void (*)(void *))__cxx_global_array_dtor, 0, &dword_1B2737000);
    }
    v6 = *((_QWORD *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + a1);
    v7 = *a2;
    if (v6 != *a2)
    {
      if (v6)
      {
        (*(void (**)(_QWORD))(*(_QWORD *)v6 + 24))(*((_QWORD *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data
                                                                + a1));
        v7 = *a2;
      }
      *((_QWORD *)&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + a1) = v7;
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
    }
  }
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
}

void sub_1B29DA198(_Unwind_Exception *a1)
{
  std::mutex::unlock(&HGComicLookupFilterLUTBitmapResourceImplementation::getCacheMutex(void)::cacheMutex);
  _Unwind_Resume(a1);
}

void HGComicLookupFilterLUTBitmapResourceImplementation::~HGComicLookupFilterLUTBitmapResourceImplementation(HGComicLookupFilterLUTBitmapResourceImplementation *this)
{
  void *v1;

  HGObject::~HGObject(this);
  HGObject::operator delete(v1);
}

uint64_t HGComicLookupFilterLUTBitmapResource::HGComicLookupFilterLUTBitmapResource(uint64_t a1, HGComicLookupFilterLUTBitmapResourceImplementation *a2)
{
  _QWORD *v4;
  HGObject *v5;

  HGNode::HGNode((HGNode *)a1);
  *v4 = off_1E6517D10;
  v4[51] = 0;
  v5 = (HGObject *)HGObject::operator new(0x10uLL);
  HGComicLookupFilterLUTBitmapResourceImplementation::HGComicLookupFilterLUTBitmapResourceImplementation(v5, a2);
  *(_QWORD *)(a1 + 416) = v5;
  return a1;
}

void sub_1B29DA220(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v4;

  HGObject::operator delete(v2);
  v4 = *(_QWORD *)(v1 + 408);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGComicLookupFilterLUTBitmapResource::~HGComicLookupFilterLUTBitmapResource(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E6517D10;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E6517D10;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 51);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

HGBitmapLoader *HGComicLookupFilterLUTBitmapResource::GetOutput(HGComicLookupFilterLUTBitmapResource *this, HGRenderer *a2)
{
  HGBitmap *v3;
  HGBitmapLoader *v4;
  HGBitmapLoader *v5;
  HGBitmap *v7;

  HGComicLookupFilterLUTBitmapResourceImplementation::getCachedLUT((HGComicLookupFilterLUTBitmapResourceImplementation *)*(unsigned int *)(*((_QWORD *)this + 52) + 12), &v7);
  v3 = v7;
  v4 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v4, v3);
  if (v3)
    (*(void (**)(HGBitmap *))(*(_QWORD *)v3 + 24))(v3);
  v5 = (HGBitmapLoader *)*((_QWORD *)this + 51);
  if (v5 == v4)
  {
    if (v4)
      goto LABEL_9;
  }
  else
  {
    if (v5)
      (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v5 + 24))(v5);
    *((_QWORD *)this + 51) = v4;
    if (v4)
    {
      (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v4 + 16))(v4);
LABEL_9:
      (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v4 + 24))(v4);
    }
  }
  return v4;
}

void sub_1B29DA3D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_array_dtor()
{
  uint64_t result;

  if (off_1EEFEECD0)
    (*(void (**)(void *))(*(_QWORD *)off_1EEFEECD0 + 24))(off_1EEFEECD0);
  if (off_1EEFEECC8)
    (*(void (**)(void *))(*(_QWORD *)off_1EEFEECC8 + 24))(off_1EEFEECC8);
  if (*(&off_1EEFEECB8 + 1))
    (*(void (**)(_QWORD))(**(&off_1EEFEECB8 + 1) + 24))(*(&off_1EEFEECB8 + 1));
  if (off_1EEFEECB8)
    (*(void (**)(_QWORD))(*off_1EEFEECB8 + 24))(off_1EEFEECB8);
  if (*(&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + 1))
    (*(void (**)(_QWORD))(**(&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data + 1)
                                   + 24))(*(&HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data
                                            + 1));
  result = HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data;
  if (HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data)
    return (*(uint64_t (**)(_QWORD))(*HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data
                                             + 24))(HGComicLookupFilterLUTBitmapResourceImplementation::getData(void)::data);
  return result;
}

void HGCache::HGCache(HGCache *this)
{
  *(_QWORD *)this = &off_1E6517F90;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 40), 0);
}

void HGCache::~HGCache(HGCache *this)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E6517F90;
  v1 = (_QWORD *)*((_QWORD *)this + 2);
  if (v1)
  {
    do
    {
      v3 = v1[5];
      if (v3)
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
      v2 = (_QWORD *)*v1;
      MEMORY[0x1B5E29170](v1, 0x1020C40063BF169);
      v1 = v2;
    }
    while (v2);
  }
}

{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E6517F90;
  v1 = (_QWORD *)*((_QWORD *)this + 2);
  if (v1)
  {
    do
    {
      v3 = v1[5];
      if (v3)
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
      v2 = (_QWORD *)*v1;
      MEMORY[0x1B5E29170](v1, 0x1020C40063BF169);
      v1 = v2;
    }
    while (v2);
  }
  JUMPOUT(0x1B5E29170);
}

void HGCinematic::HGCinematic(HGCinematic *this)
{
  uint64_t v2;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v2 = off_1E6517FC0;
  *(_DWORD *)(v2 + 420) = 0;
  *(_WORD *)(v2 + 424) = 256;
  *(_QWORD *)(v2 + 440) = 0;
  *(_QWORD *)(v2 + 448) = 0;
  *(_QWORD *)(v2 + 432) = 0;
  *(_QWORD *)(v2 + 464) = 0;
  *(_QWORD *)(v2 + 472) = 0;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(v2 + 16) & 0xFFFFF9FF | 0x400;
  atomic_store(0, (unsigned int *)(v2 + 456));
  HGNode::SetFlags((HGNode *)v2, 0, 2);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 2);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 0xFFFFFFFFLL, 2);
  (*(void (**)(HGCinematic *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 0x2000);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 0x2000);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 0xFFFFFFFFLL, 128);
  (*(void (**)(HGCinematic *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 0xFFFFFFFFLL, 4);
  *((_DWORD *)this + 104) = 100;
}

void sub_1B29DA930(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 455) < 0)
    operator delete(*v2);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGCinematic::~HGCinematic(id *this)
{
  *this = off_1E6517FC0;

  if (*((char *)this + 455) < 0)
    operator delete(this[54]);
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;

  *this = off_1E6517FC0;

  if (*((char *)this + 455) < 0)
    operator delete(this[54]);
  HGNode::~HGNode((HGNode *)this);
  HGObject::operator delete(v2);
}

uint64_t HGCinematic::GetDOD(HGCinematic *this, HGRenderer *a2, uint64_t a3, HGRect a4)
{
  HGNode *v5;

  v5 = (HGNode *)(*(uint64_t (**)(HGCinematic *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 128))(this, 0, a3, *(_QWORD *)&a4.var0, *(_QWORD *)&a4.var2);
  return HGRenderer::GetDOD(a2, v5);
}

uint64_t HGCinematic::GetROI(HGCinematic *this, HGRenderer *a2, uint64_t a3, HGRect a4)
{
  HGNode *v5;

  if (a3 > 1)
    return *(_QWORD *)&a4.var0;
  v5 = (HGNode *)(*(uint64_t (**)(HGCinematic *, uint64_t))(*(_QWORD *)this + 128))(this, a3);
  return HGRenderer::GetDOD(a2, v5);
}

uint64_t HGCinematic::RenderPageMetal(HGNode *this, HGPage *a2)
{
  const char *v4;
  uint64_t MetalContext;
  uint64_t v6;
  uint64_t v7;
  char *Buffer;
  uint64_t v9;
  uint64_t DOD;
  uint64_t v11;
  uint64_t v12;
  HGBitmap *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  HGNode *Input;
  HGNode *v19;
  HGBitmap *NodeMetalTexture;
  HGBitmap *v21;
  HGBitmap *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  HGBitmap **v27;
  char *v28;
  uint64_t v29;
  HGBitmap **v30;
  char *v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[5];
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  _QWORD *v40;
  HGBitmap *v41;
  HGBitmap *v42;
  _BYTE v43[16];
  HGPage *v44;
  char __str[256];
  uint64_t v46;
  HGRect v47;
  HGRect v48;
  HGRect v49;

  v46 = *MEMORY[0x1E0C80C00];
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v44, this, a2);
  v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(_QWORD *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPageMetal( [%d %d %d %d])", v4, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v43, "gpu", 1, __str);
  MetalContext = HGGPURenderer::GetMetalContext(*(HGGPURenderer **)a2);
  v6 = *(_QWORD *)(*(_QWORD *)(MetalContext + 16) + 16);
  v7 = *((_QWORD *)a2 + 1);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
    Buffer = (char *)*((_QWORD *)a2 + 1);
  }
  else
  {
    v9 = *(_QWORD *)a2;
    DOD = HGRenderer::GetDOD(*(HGRenderer **)a2, this);
    v12 = v11;
    *(_QWORD *)&v47.var0 = DOD;
    *(_QWORD *)&v47.var2 = v12;
    Buffer = HGGPURenderer::CreateBuffer(v9, v47, *((unsigned int *)a2 + 8), 1, 1, 0);
    *((_QWORD *)a2 + 1) = Buffer;
  }
  v13 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, (HGBitmap *)Buffer);
  v34 = *((_QWORD *)v13 + 18);
  v35 = v6;
  v14 = *(_QWORD *)((char *)a2 + 36);
  v15 = *(_QWORD *)((char *)a2 + 44);
  v16 = *(_QWORD *)((char *)a2 + 52);
  v17 = *(_QWORD *)((char *)a2 + 60);
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, this, 0);
  v19 = HGRenderer::GetInput(*(HGRenderer **)a2, this, 1u);
  *(_QWORD *)&v48.var0 = v14;
  *(_QWORD *)&v48.var2 = v15;
  NodeMetalTexture = HGGPURenderer::GetNodeMetalTexture(*(HGGPURenderer **)a2, Input, v48, 0, 0);
  v42 = NodeMetalTexture;
  *(_QWORD *)&v49.var0 = v16;
  *(_QWORD *)&v49.var2 = v17;
  v21 = HGGPURenderer::GetNodeMetalTexture(*(HGGPURenderer **)a2, v19, v49, 0, 0);
  v22 = v21;
  v41 = v21;
  if (NodeMetalTexture)
  {
    if (v21)
    {
      HGGPURenderer::FlushMetalCommandBuffer(*(HGGPURenderer **)a2);
      v23 = *((_QWORD *)NodeMetalTexture + 18);
      if (v23)
      {
        v24 = *((_QWORD *)v22 + 18);
        if (v24)
        {
          v37 = 0;
          v38 = &v37;
          v39 = 0x2020000000;
          v40 = 0;
          v25 = (_QWORD *)operator new();
          *v25 = 0;
          v25[1] = 0;
          v25[2] = 0;
          v40 = v25;
          v26 = v38[3];
          v27 = *(HGBitmap ***)(v26 + 8);
          if ((unint64_t)v27 >= *(_QWORD *)(v26 + 16))
          {
            v28 = std::vector<HGRef<HGMetalTexture>>::__push_back_slow_path<HGRef<HGMetalTexture> const&>((char **)v38[3], (uint64_t *)&v42);
          }
          else
          {
            *v27 = NodeMetalTexture;
            (*(void (**)(HGBitmap *))(*(_QWORD *)NodeMetalTexture + 16))(NodeMetalTexture);
            v28 = (char *)(v27 + 1);
            *(_QWORD *)(v26 + 8) = v27 + 1;
          }
          *(_QWORD *)(v26 + 8) = v28;
          v29 = v38[3];
          v30 = *(HGBitmap ***)(v29 + 8);
          if ((unint64_t)v30 >= *(_QWORD *)(v29 + 16))
          {
            v31 = std::vector<HGRef<HGMetalTexture>>::__push_back_slow_path<HGRef<HGMetalTexture> const&>((char **)v38[3], (uint64_t *)&v41);
          }
          else
          {
            *v30 = v22;
            (*(void (**)(HGBitmap *))(*(_QWORD *)v22 + 16))(v22);
            v31 = (char *)(v30 + 1);
            *(_QWORD *)(v29 + 8) = v30 + 1;
          }
          *(_QWORD *)(v29 + 8) = v31;
          v32 = *(_QWORD *)(MetalContext + 32);
          v36[0] = MEMORY[0x1E0C809B0];
          v36[1] = 3221225472;
          v36[2] = ___ZN11HGCinematic15RenderPageMetalEP6HGPage_block_invoke;
          v36[3] = &unk_1E6518210;
          v36[4] = &v37;
          (*(void (**)(HGNode *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)this
                                                                                                  + 576))(this, v35, v32, v23, v24, v34, v36);
          _Block_object_dispose(&v37, 8);
        }
      }
    }
  }
  (*(void (**)(HGBitmap *))(*(_QWORD *)v13 + 24))(v13);
  if (v41)
    (*(void (**)(HGBitmap *))(*(_QWORD *)v41 + 24))(v41);
  if (v42)
    (*(void (**)(HGBitmap *))(*(_QWORD *)v42 + 24))(v42);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v43);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v44);
  return *((_QWORD *)a2 + 1);
}

void sub_1B29DAE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,HGPage *a30)
{
  uint64_t v30;
  uint64_t v31;

  *(_QWORD *)(v31 + 8) = v30;
  _Block_object_dispose(&a22, 8);
  if (a26)
    (*(void (**)(uint64_t))(*(_QWORD *)a26 + 24))(a26);
  if (a27)
    (*(void (**)(uint64_t))(*(_QWORD *)a27 + 24))(a27);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a28);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&a30);
  _Unwind_Resume(a1);
}

void sub_1B29DAEE8(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t ___ZN11HGCinematic15RenderPageMetalEP6HGPage_block_invoke(uint64_t result)
{
  void **v1;
  char *v2;
  char *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(void ***)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24);
  if (v1)
  {
    v2 = (char *)*v1;
    if (*v1)
    {
      v3 = (char *)v1[1];
      v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          v6 = *((_QWORD *)v3 - 1);
          v3 -= 8;
          v5 = v6;
          if (v6)
            (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
        }
        while (v3 != v2);
        v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t HGCinematic::setAperture(uint64_t this, float a2)
{
  *(float *)(this + 408) = a2;
  return this;
}

uint64_t HGCinematic::setFocusDistance(uint64_t this, float a2)
{
  *(float *)(this + 412) = a2;
  return this;
}

uint64_t HGCinematic::setRenderDisparity(uint64_t this)
{
  *(_BYTE *)(this + 424) = 1;
  *(_DWORD *)(this + 420) = 2;
  return this;
}

double ___ZN11HGCinematic26prepCachePipelinesAndLocksEv_block_invoke()
{
  uint64_t v0;
  _OWORD *v1;
  double result;

  v0 = operator new();
  *(_QWORD *)v0 = 850045863;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_QWORD *)(v0 + 56) = 0;
  HGCinematic::_cachePipelinesLock = v0;
  v1 = (_OWORD *)operator new();
  result = 0.0;
  *v1 = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  HGCinematic::_cachePipelines = (uint64_t)v1;
  return result;
}

void HGCinematic::performPortraitWithDevice(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  std::mutex *v14;
  void **Pipeline;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  CGColorSpace *v23;
  CGColorSpace *v24;
  CGColorConversionInfoRef v25;
  void *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  _QWORD *v30;
  double v31;
  void *v32;
  double v33;
  int v34;
  void *context;
  _OWORD v36[2];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (HGCinematic::prepCachePipelinesAndLocks(void)::onceToken != -1)
    dispatch_once(&HGCinematic::prepCachePipelinesAndLocks(void)::onceToken, &__block_literal_global_60);
  v14 = (std::mutex *)HGCinematic::_cachePipelinesLock;
  std::mutex::lock((std::mutex *)HGCinematic::_cachePipelinesLock);
  Pipeline = HGCinematic::getPipeline(a1, a2, a4, a5);
  context = (void *)MEMORY[0x1B5E29C50]();
  v16 = (void *)objc_msgSend(a3, "commandBuffer");
  if (*(_BYTE *)(a1 + 424) && *(_BYTE *)(a1 + 425))
  {
    v17 = (void *)objc_msgSend(Pipeline[2], "upscaleDisparity:inRGBA:commandBuffer:", a5, a4, v16);
    v18 = v17;
    if (v17)
    {
      v19 = objc_msgSend(v17, "pixelFormat");
      v20 = objc_msgSend(a6, "pixelFormat");
      if (v19 != v20)
      {
        v21 = (void *)objc_msgSend(MEMORY[0x1E0CC6BB0], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v20, objc_msgSend(v18, "width"), objc_msgSend(v18, "height"), 0);
        objc_msgSend(v21, "setUsage:", 3);
        v22 = (void *)objc_msgSend(a2, "newTextureWithDescriptor:", v21);
        v23 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9F0]);
        v24 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9D0]);
        v25 = CGColorConversionInfoCreate(v23, v24);
        memset(v36, 0, sizeof(v36));
        v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6E18]), "initWithDevice:srcAlpha:destAlpha:backgroundColor:conversionInfo:", a2, 1, 1, v36, v25);
        objc_msgSend(v26, "encodeToCommandBuffer:sourceTexture:destinationTexture:", v16, v18, v22);

        CFRelease(v25);
        CGColorSpaceRelease(v23);
        CGColorSpaceRelease(v24);
        v27 = objc_msgSend(v18, "width");
        if (v27 == objc_msgSend(a6, "width"))
        {
          objc_msgSend(v18, "height");
          objc_msgSend(a6, "height");
        }
        v28 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6E08]), "initWithDevice:", a2);
        objc_msgSend(v28, "encodeToCommandBuffer:sourceTexture:destinationTexture:", v16, v22, a6);
        objc_msgSend(v16, "addCompletedHandler:", &__block_literal_global_22);
        objc_msgSend(v16, "commit");

      }
    }
    goto LABEL_26;
  }
  v29 = (void *)objc_opt_new();
  objc_msgSend(v29, "setRenderState:", Pipeline[3]);
  objc_msgSend(v29, "setSourceColor:", objc_msgSend(MEMORY[0x1E0D7F5B8], "createRGBA:", a4));
  objc_msgSend(v29, "setDestinationColor:", objc_msgSend(MEMORY[0x1E0D7F5B8], "createRGBA:", a6));
  v30 = (_QWORD *)(a1 + 432);
  if (*(char *)(a1 + 455) < 0)
  {
    if (!*(_QWORD *)(a1 + 440))
      goto LABEL_16;
    v30 = (_QWORD *)*v30;
    goto LABEL_15;
  }
  if (*(_BYTE *)(a1 + 455))
LABEL_15:
    objc_msgSend((id)objc_msgSend(v29, "sourceColor"), "setTransferFunction:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v30, objc_msgSend(MEMORY[0x1E0CB3940], "defaultCStringEncoding")));
LABEL_16:
  objc_msgSend(v29, "setSourceDisparity:", a5);
  objc_msgSend((id)objc_msgSend(v29, "destinationColor"), "setTransferFunction:", objc_msgSend((id)objc_msgSend(v29, "sourceColor"), "transferFunction"));
  if (*(_QWORD *)(a1 + 472) && (objc_opt_respondsToSelector() & 1) != 0)
    objc_msgSend(*(id *)(a1 + 472), "applyToRenderRequest:", v29);
  v32 = *(void **)(a1 + 464);
  if (v32)
    objc_msgSend(v32, "applyToRenderRequest:", v29);
  LODWORD(v31) = *(_DWORD *)(a1 + 408);
  objc_msgSend(v29, "setAperture:", v31);
  LODWORD(v33) = *(_DWORD *)(a1 + 412);
  objc_msgSend(v29, "setFocusDistance:", v33);
  v34 = objc_msgSend(Pipeline[1], "encodeRenderTo:withRenderRequest:", v16, v29);

  if (v34)
    NSLog(CFSTR("error:%@"), objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB2F90], v34, 0));
  if (a7)
    objc_msgSend(v16, "addCompletedHandler:", a7);
  objc_msgSend(v16, "commit");
  objc_msgSend(v16, "waitUntilScheduled");
LABEL_26:
  objc_autoreleasePoolPop(context);
  std::mutex::unlock(v14);
}

void sub_1B29DB46C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB480(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB494(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB4A8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB4BC(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB4D0(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB4E4(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB4F8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB50C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB520(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB534(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB548(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB55C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB570(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB584(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DB598(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void **HGCinematic::getPipeline(uint64_t a1, void *a2, void *a3, void *a4)
{
  double v8;
  double v9;
  double v10;
  double v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  void ***v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  double v20;
  double v21;
  double v23;
  double v24;
  void **result;
  void ***v27;
  unint64_t v28;
  uint64_t v29;
  id *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  id v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  id v39;
  void *v40;
  _QWORD *v41;
  unint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;

  v8 = (double)(unint64_t)objc_msgSend(a3, "width");
  v9 = (double)(unint64_t)objc_msgSend(a3, "height");
  v10 = (double)(unint64_t)objc_msgSend(a4, "width");
  v11 = (double)(unint64_t)objc_msgSend(a4, "height");
  v12 = (_QWORD *)HGCinematic::_cachePipelines;
  v13 = *(_QWORD *)(HGCinematic::_cachePipelines + 8);
  if (*(_QWORD *)(HGCinematic::_cachePipelines + 16) == v13
    || (v14 = *(_QWORD *)(HGCinematic::_cachePipelines + 32),
        v15 = (_QWORD *)(v13 + 8 * (v14 >> 9)),
        v16 = (void ***)(*v15 + 8 * (v14 & 0x1FF)),
        v17 = *(_QWORD *)(v13 + (((*(_QWORD *)(HGCinematic::_cachePipelines + 40) + v14) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*(_QWORD *)(HGCinematic::_cachePipelines + 40) + v14) & 0x1FF),
        v16 == (void ***)v17))
  {
    if (*(_QWORD *)(HGCinematic::_cachePipelines + 40) == 1)
    {
LABEL_22:
      v28 = v12[4];
      v29 = v12[1];
      v30 = *(id **)(*(_QWORD *)(v29 + ((v28 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v28 & 0x1FF));
      if (v30)
      {

        *(_OWORD *)v30 = 0u;
        *((_OWORD *)v30 + 1) = 0u;
        MEMORY[0x1B5E29170](v30, 0x1080C406D05D2F5);
        v12 = (_QWORD *)HGCinematic::_cachePipelines;
        v28 = *(_QWORD *)(HGCinematic::_cachePipelines + 32);
        v31 = *(_QWORD *)(HGCinematic::_cachePipelines + 40);
        v29 = *(_QWORD *)(HGCinematic::_cachePipelines + 8);
      }
      else
      {
        v31 = 1;
      }
      v32 = v12[2];
      if (v32 == v29)
        v33 = 0;
      else
        v33 = ((v32 - v29) << 6) - 1;
      v12[5] = v31 - 1;
      if (v33 - (v31 + v28) + 1 >= 0x400)
      {
        operator delete(*(void **)(v32 - 8));
        v12[2] -= 8;
      }
    }
LABEL_30:
    v34 = objc_alloc(MEMORY[0x1E0D7F588]);
    v35 = (void *)objc_msgSend(v34, "initWithDevice:version:colorSize:disparitySize:", a2, objc_msgSend(MEMORY[0x1E0D7F578], "latestVersion"), v8, v9, v10, v11);
    objc_msgSend(v35, "setDebugRendering:", *(int *)(a1 + 420));
    objc_msgSend(v35, "setUseRGBA:", 1);
    v36 = operator new();
    *(_OWORD *)(v36 + 8) = 0u;
    *(_OWORD *)(v36 + 24) = 0u;
    *(_QWORD *)v36 = v35;
    v37 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D7F578]), "initWithDescriptor:", v35);
    *(_QWORD *)(v36 + 8) = v37;
    *(_QWORD *)(v36 + 16) = -[HGDisparityUpscale initWithDevice:disparitySize:colorSize:portraitUtil:]([HGDisparityUpscale alloc], "initWithDevice:disparitySize:colorSize:portraitUtil:", a2, 0, v10, v11, v8, v9);
    v38 = (void *)objc_msgSend(v37, "createRenderStateWithQuality:", *(unsigned int *)(a1 + 416));
    *(_QWORD *)(v36 + 24) = v38;
    v39 = v38;
    *(_DWORD *)(v36 + 32) = *(_DWORD *)(a1 + 416);
    v40 = *(void **)(a1 + 464);
    if (v40)
      objc_msgSend(v40, "applyToRenderState:", v38);
    v41 = (_QWORD *)HGCinematic::_cachePipelines;
    v42 = *(_QWORD *)(HGCinematic::_cachePipelines + 32);
    if (!v42)
    {
      std::deque<Pipeline *>::__add_front_capacity(HGCinematic::_cachePipelines);
      v42 = v41[4];
    }
    v43 = v41[1];
    v44 = (_QWORD *)(v43 + 8 * (v42 >> 9));
    if (v41[2] == v43)
      v45 = 0;
    else
      v45 = *v44 + 8 * (v42 & 0x1FF);
    if (v45 == *v44)
      v45 = *(v44 - 1) + 4096;
    *(_QWORD *)(v45 - 8) = v36;
    v46 = v41[5] + 1;
    v41[4] = v42 - 1;
    v41[5] = v46;
    return *(void ***)(*(_QWORD *)(*(_QWORD *)(HGCinematic::_cachePipelines + 8)
                                 + ((*(_QWORD *)(HGCinematic::_cachePipelines + 32) >> 6) & 0x3FFFFFFFFFFFFF8))
                     + 8 * (*(_QWORD *)(HGCinematic::_cachePipelines + 32) & 0x1FFLL));
  }
  else
  {
    while (1)
    {
      v18 = **v16;
      v19 = objc_msgSend((id)objc_msgSend(v18, "device"), "registryID");
      if (v19 == objc_msgSend(a2, "registryID"))
      {
        objc_msgSend(v18, "colorInputSize");
        if (v21 == v8 && v20 == v9)
        {
          objc_msgSend(v18, "disparitySize");
          if (v24 == v10 && v23 == v11 && objc_msgSend(v18, "debugRendering") == *(_DWORD *)(a1 + 420))
          {
            result = *v16;
            if (*((_DWORD *)*v16 + 8) == *(_DWORD *)(a1 + 416))
              break;
          }
        }
      }
      if ((void ***)((char *)++v16 - *v15) == (void ***)4096)
      {
        v27 = (void ***)v15[1];
        ++v15;
        v16 = v27;
      }
      if (v16 == (void ***)v17)
      {
        v12 = (_QWORD *)HGCinematic::_cachePipelines;
        if (*(_QWORD *)(HGCinematic::_cachePipelines + 40) != 1)
          goto LABEL_30;
        goto LABEL_22;
      }
    }
  }
  return result;
}

uint64_t HGCinematic::setDisplayMode(uint64_t this, int a2)
{
  int v2;
  int v3;

  if (a2 != 4)
  {
    if (a2 == 1)
      v2 = 2;
    else
      v2 = 0;
    if (a2 == 3)
      v3 = 4;
    else
      v3 = v2;
    *(_DWORD *)(this + 420) = v3;
  }
  return this;
}

uint64_t HGCinematic::RenderTile(HGNode *this, HGTile *a2)
{
  unsigned int *v3;
  unsigned int v4;
  HGRenderer *v5;
  HGNode *Input;
  HGNode *v7;
  void *v8;
  unsigned int v9;
  int v10;
  unint64_t ROI;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  id v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  HGNode *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  void *v34;
  void *context;
  void *v36;
  id v38;
  _QWORD v39[6];
  _QWORD v40[6];
  uint64_t v41;
  int v42;

  v3 = (unsigned int *)((char *)this + 456);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  if (!v4)
  {
    context = (void *)MEMORY[0x1B5E29C50]();
    v36 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 2);
    v38 = MTLCreateSystemDefaultDevice();
    v33 = objc_msgSend(v38, "newCommandQueue");
    v5 = (HGRenderer *)HGTile::Renderer(a2);
    Input = HGRenderer::GetInput(v5, this, 0);
    if (Input)
    {
      v7 = Input;
      v8 = 0;
      v9 = 0;
      v10 = 1;
      do
      {
        ROI = HGRenderer::GetROI(v5, v7);
        v13 = v12;
        HGRenderer::RenderInput((uint64_t)v5, *((_QWORD *)a2 + 42), (uint64_t)this, v9, (uint64_t)&v41, ROI, v12, 0);
        if (v10)
          v14 = 28;
        else
          v14 = 7;
        v15 = 16 * v42;
        v16 = HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v16, ROI, v13, v14, v41, v15);
        v17 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
        v18 = v17;
        if (v10)
          v19 = 125;
        else
          v19 = 55;
        objc_msgSend(v17, "setPixelFormat:", v19, v33, context);
        objc_msgSend(v18, "setWidth:", (int)v13 - (int)ROI);
        objc_msgSend(v18, "setHeight:", (uint64_t)(v13 - (ROI & 0xFFFFFFFF00000000)) >> 32);
        v20 = (void *)objc_msgSend(v38, "newTextureWithDescriptor:", v18);
        v21 = objc_msgSend(v18, "width");
        v22 = objc_msgSend(v18, "height");
        memset(v40, 0, 24);
        v40[3] = v21;
        v40[4] = v22;
        v40[5] = 1;
        objc_msgSend(v20, "replaceRegion:mipmapLevel:withBytes:bytesPerRow:", v40, 0, v16[10], v16[8]);
        if (!v8)
        {
          objc_msgSend(v18, "setUsage:", 2);
          v8 = (void *)objc_msgSend(v38, "newTextureWithDescriptor:", v18);
        }

        objc_msgSend(v36, "addObject:", v20);
        (*(void (**)(_QWORD *))(*v16 + 24))(v16);
        v23 = HGRenderer::GetInput(v5, this, v9 + 1);
        if (v9 > 6)
          break;
        v7 = v23;
        --v10;
        ++v9;
      }
      while (v23);
    }
    else
    {
      v8 = 0;
    }
    v24 = objc_msgSend(v36, "objectAtIndex:", 0, v33);
    v25 = (*(uint64_t (**)(HGNode *, id, void *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)this + 576))(this, v38, v34, v24, objc_msgSend(v36, "objectAtIndex:", 1), v8, 0);
    v26 = (void *)MEMORY[0x1B5E29C50](v25);
    v27 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
    v28 = (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1));
    v29 = (void *)objc_msgSend(v34, "commandBuffer");
    objc_msgSend((id)objc_msgSend(v29, "blitCommandEncoder"), "endEncoding");
    objc_msgSend(v29, "commit");
    objc_msgSend(v29, "waitUntilCompleted");
    v30 = *((_QWORD *)a2 + 2);
    v31 = 16 * *((int *)a2 + 6);
    memset(v39, 0, 24);
    v39[3] = v27;
    v39[4] = v28;
    v39[5] = 1;
    objc_msgSend(v8, "getBytes:bytesPerRow:fromRegion:mipmapLevel:", v30, v31, v39, 0);
    objc_autoreleasePoolPop(v26);

    objc_autoreleasePoolPop(context);
  }
  return 0;
}

void sub_1B29DBCAC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DBCC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

PTGlobalRenderingMetadata *HGCinematic::SetGlobalRenderingMetadata(PTGlobalRenderingMetadata *this, PTGlobalRenderingMetadata *a2)
{
  PTGlobalRenderingMetadata *v2;
  PTGlobalRenderingMetadata *v4;

  v2 = (PTGlobalRenderingMetadata *)*((_QWORD *)this + 58);
  if (v2 != a2)
  {
    v4 = this;

    this = a2;
    *((_QWORD *)v4 + 58) = this;
  }
  return this;
}

_QWORD *HGCinematic::SetTimedRenderingMetadata(_QWORD *result, void *a2)
{
  void *v2;
  _QWORD *v4;

  v2 = (void *)result[59];
  if (v2 != a2)
  {
    v4 = result;

    result = a2;
    v4[59] = result;
  }
  return result;
}

void HGCinematic::ClearCachePipelines(HGCinematic *this)
{
  std::mutex *v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  char *v5;
  unint64_t v6;
  id *v7;
  char *v8;

  if (HGCinematic::prepCachePipelinesAndLocks(void)::onceToken != -1)
    dispatch_once(&HGCinematic::prepCachePipelinesAndLocks(void)::onceToken, &__block_literal_global_60);
  v1 = (std::mutex *)HGCinematic::_cachePipelinesLock;
  std::mutex::lock((std::mutex *)HGCinematic::_cachePipelinesLock);
  v2 = HGCinematic::_cachePipelines;
  v3 = *(_QWORD *)(HGCinematic::_cachePipelines + 8);
  v4 = (char *)(v3 + 8 * (*(_QWORD *)(HGCinematic::_cachePipelines + 32) >> 9));
  if (*(_QWORD *)(HGCinematic::_cachePipelines + 16) == v3)
  {
    v5 = 0;
    goto LABEL_8;
  }
  v5 = (char *)(*(_QWORD *)v4 + 8 * (*(_QWORD *)(HGCinematic::_cachePipelines + 32) & 0x1FFLL));
  while (1)
  {
    v6 = *(_QWORD *)(v2 + 40) + *(_QWORD *)(v2 + 32);
    if (v5 == (char *)(*(_QWORD *)(v3 + ((v6 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v6 & 0x1FF)))
      break;
    while (1)
    {
      v7 = *(id **)v5;

      *(_OWORD *)v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      v4 = (char *)std::deque<Pipeline *>::erase((int64x2_t *)HGCinematic::_cachePipelines, v4, v5);
      v5 = v8;
      v2 = HGCinematic::_cachePipelines;
      v3 = *(_QWORD *)(HGCinematic::_cachePipelines + 8);
      if (*(_QWORD *)(HGCinematic::_cachePipelines + 16) != v3)
        break;
LABEL_8:
      if (!v5)
        goto LABEL_11;
    }
  }
LABEL_11:
  std::mutex::unlock(v1);
}

void sub_1B29DBE94(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DBEA8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void **std::deque<Pipeline *>::erase(int64x2_t *a1, char *a2, char *a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void **v9;
  char *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  unint64_t v14;
  const void **v15;
  char v16;
  const void **v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  const void **v21;
  char *v22;
  unint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  const void **v29;
  _BYTE *v30;
  __int16 v31;
  const void **v32;
  _BYTE *v33;
  uint64_t v34;
  unint64_t v35;
  int64x2_t v36;
  unint64_t v37;
  void **v38;
  void **result;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  void **v43;
  uint64_t v44;
  uint64_t v45;
  const void **v46[4];

  v6 = a1[2].u64[0];
  v7 = a1->i64[1];
  v8 = a1[1].i64[0];
  v9 = (const void **)(v7 + 8 * (v6 >> 9));
  if (v8 != v7)
  {
    v10 = (char *)*v9 + 8 * (a1[2].i64[0] & 0x1FF);
    if (a3 != v10)
      goto LABEL_3;
LABEL_7:
    v14 = 0;
    v12 = *v9;
    goto LABEL_8;
  }
  v10 = 0;
  if (!a3)
    goto LABEL_7;
LABEL_3:
  v11 = ((uint64_t)&a3[-*(_QWORD *)a2] >> 3) + ((a2 - (char *)v9) << 6);
  v12 = *v9;
  v13 = v10 - (_BYTE *)*v9;
  v14 = v11 - (v13 >> 3);
  if (v11 != v13 >> 3)
  {
    if (v11 < 1)
    {
      v23 = 511 - v11;
      LOWORD(v11) = ~(511 - v11);
      v15 = &v9[-(v23 >> 9)];
    }
    else
    {
      v15 = &v9[(unint64_t)v11 >> 9];
    }
    v24 = *v15;
    v17 = (const void **)((char *)*v15 + 8 * (v11 & 0x1FF));
    v25 = a1[2].i64[1];
    if (v14 > (unint64_t)(v25 - 1) >> 1)
    {
      v26 = (char *)v17 - v24;
      v27 = ((char *)v17 - v24) >> 3;
      if (v26 < -7)
      {
        v42 = 510 - v27;
        v29 = &v15[-(v42 >> 9)];
        v30 = (char *)*v29 + 8 * (~(_WORD)v42 & 0x1FF);
        v31 = v25 + v6;
        v32 = (const void **)(v7 + 8 * ((v25 + v6) >> 9));
        if (v8 != v7)
          goto LABEL_14;
      }
      else
      {
        v28 = v27 + 1;
        v29 = &v15[v28 >> 9];
        v30 = (char *)*v29 + 8 * (v28 & 0x1FF);
        v31 = v25 + v6;
        v32 = (const void **)(v7 + 8 * ((v25 + v6) >> 9));
        if (v8 != v7)
        {
LABEL_14:
          v33 = (char *)*v32 + 8 * (v31 & 0x1FF);
LABEL_28:
          v46[0] = v15;
          v46[1] = v17;
          std::__for_each_segment[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>>>(v29, v30, v32, v33, (uint64_t)v46);
          v38 = (void **)a1->i64[1];
          v43 = (void **)a1[1].i64[0];
          v37 = a1[2].u64[0];
          v44 = a1[2].i64[1];
          a1[2].i64[1] = v44 - 1;
          v45 = (((char *)v43 - (char *)v38) << 6) - 1;
          if (v43 == v38)
            v45 = 0;
          if (v45 - (v44 + v37) + 1 >= 0x400)
          {
            operator delete(*(v43 - 1));
            v16 = 0;
            v38 = (void **)a1->i64[1];
            a1[1].i64[0] -= 8;
            v37 = a1[2].u64[0];
          }
          else
          {
            v16 = 0;
          }
          goto LABEL_19;
        }
      }
      v33 = 0;
      goto LABEL_28;
    }
    v16 = 0;
    v34 = (char *)v17 - v24;
    v19 = ((char *)v17 - v24) >> 3;
    if (v34 < -7)
      goto LABEL_16;
LABEL_9:
    v20 = v19 + 1;
    v21 = &v15[v20 >> 9];
    v22 = (char *)*v21 + 8 * (v20 & 0x1FF);
    goto LABEL_17;
  }
LABEL_8:
  v16 = 1;
  v15 = (const void **)(v7 + 8 * (v6 >> 9));
  v17 = (const void **)v10;
  v18 = v10 - v12;
  v19 = (v10 - v12) >> 3;
  if (v18 >= -7)
    goto LABEL_9;
LABEL_16:
  v35 = 510 - v19;
  v21 = &v15[-(v35 >> 9)];
  v22 = (char *)*v21 + 8 * (~(_WORD)v35 & 0x1FF);
LABEL_17:
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,0>(v9, v10, v15, (char *)v17, v21, v22, v46);
  v36 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B304F0B0);
  a1[2] = v36;
  v37 = v36.i64[0];
  v38 = (void **)a1->i64[1];
  if (v36.i64[0] >= 0x400uLL)
  {
    operator delete(*v38);
    v38 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v38;
    v37 = a1[2].i64[0] - 512;
    a1[2].i64[0] = v37;
  }
LABEL_19:
  result = &v38[v37 >> 9];
  if ((void **)a1[1].i64[0] == v38)
  {
    v40 = 0;
    if ((v16 & 1) != 0)
      return result;
  }
  else
  {
    v40 = (uint64_t)*result + 8 * (v37 & 0x1FF);
    if ((v16 & 1) != 0)
      return result;
  }
  v41 = v14 + ((v40 - (uint64_t)*result) >> 3);
  if (v41 < 1)
    result -= (unint64_t)(511 - v41) >> 9;
  else
    result += (unint64_t)v41 >> 9;
  return result;
}

uint64_t HGCinematic::SetRenderQuality(uint64_t this, int a2)
{
  *(_DWORD *)(this + 416) = a2;
  return this;
}

char *std::vector<HGRef<HGMetalTexture>>::__push_back_slow_path<HGRef<HGMetalTexture> const&>(char **a1, uint64_t *a2)
{
  char *v3;
  char *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v19;
  uint64_t v20;
  char *v21;

  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 3;
  v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v8 = a1[2] - v3;
  if (v8 >> 2 > v6)
    v6 = v8 >> 2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
    v9 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v9 = v6;
  if (v9)
  {
    if (v9 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v10 = (char *)operator new(8 * v9);
  }
  else
  {
    v10 = 0;
  }
  v11 = &v10[8 * v5];
  v12 = &v10[8 * v9];
  v13 = *a2;
  *(_QWORD *)v11 = *a2;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13);
    v3 = *a1;
    v4 = a1[1];
  }
  v14 = v11 + 8;
  v21 = v11 + 8;
  if (v4 == v3)
  {
    v17 = v3;
  }
  else
  {
    v15 = 0;
    do
    {
      v16 = *(_QWORD *)&v4[v15 - 8];
      *(_QWORD *)&v11[v15 - 8] = v16;
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
      v15 -= 8;
    }
    while (&v4[v15] != v3);
    v17 = *a1;
    v3 = a1[1];
    v11 += v15;
    v14 = v21;
  }
  *a1 = v11;
  a1[1] = v14;
  a1[2] = v12;
  if (v3 == v17)
  {
    if (v3)
LABEL_22:
      operator delete(v3);
  }
  else
  {
    do
    {
      v20 = *((_QWORD *)v3 - 1);
      v3 -= 8;
      v19 = v20;
      if (v20)
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
    }
    while (v3 != v17);
    v3 = v17;
    if (v17)
      goto LABEL_22;
  }
  return v14;
}

void sub_1B29DC374(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<HGRef<HGMetalTexture>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B29DC38C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  for (; v2; v2 += 8)
  {
    v5 = *(_QWORD *)(v3 + v2);
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  }
  std::__split_buffer<HGRef<HGMetalTexture>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<HGRef<HGMetalTexture>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v5 = *(_QWORD *)(v2 - 8);
    v2 -= 8;
    v4 = v5;
    *(_QWORD *)(a1 + 16) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::deque<Pipeline *>::__add_front_capacity(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  void *v12;
  void *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  void *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  unint64_t v34;
  int64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 *v43;
  char *v44;
  uint64_t v45;
  __int128 v46;
  void *v47;

  v3 = *(char **)(a1 + 8);
  v2 = *(char **)(a1 + 16);
  if (v2 == v3)
    v4 = 0;
  else
    v4 = ((v2 - v3) << 6) - 1;
  v5 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v4 - (*(_QWORD *)(a1 + 40) + v5)) >= 0x200)
  {
    *(_QWORD *)(a1 + 32) = v5 + 512;
    v47 = (void *)*((_QWORD *)v2 - 1);
    *(_QWORD *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  v6 = *(char **)(a1 + 24);
  v7 = *(char **)a1;
  v8 = (uint64_t)&v6[-*(_QWORD *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      v17 = *(_QWORD *)(a1 + 16);
      v47 = *(void **)(v17 - 8);
      *(_QWORD *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
        goto LABEL_9;
    }
    else
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
      {
LABEL_9:
        v9 = 256;
LABEL_19:
        *(_QWORD *)(a1 + 32) = v9;
        return;
      }
    }
    v9 = *(_QWORD *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7)
    v10 = 1;
  else
    v10 = v8 >> 2;
  if (v10 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v11 = (char *)operator new(8 * v10);
  v12 = operator new(0x1000uLL);
  v13 = v12;
  if (v10)
  {
    v14 = &v11[8 * v10];
    *(_QWORD *)v11 = v12;
    v15 = v11 + 8;
    v16 = v11;
    if (v3 != v2)
      goto LABEL_27;
    goto LABEL_21;
  }
  v18 = (char *)operator new(8uLL);
  v14 = v18 + 8;
  operator delete(v11);
  v3 = *(char **)(a1 + 8);
  v19 = *(char **)(a1 + 16);
  v11 = v18;
  *(_QWORD *)v18 = v13;
  v15 = v18 + 8;
  v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_27:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16)
            v31 = 1;
          else
            v31 = (v15 - v16) >> 2;
          if (v31 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v32 = (char *)operator new(8 * v31);
          v33 = v32;
          v34 = v31 >> 2;
          v20 = &v32[8 * (v31 >> 2)];
          v23 = v20;
          v35 = v15 - v11;
          if (v15 != v11)
          {
            v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            v36 = v35 - 8;
            if (v36 < 0x38 || (v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              v38 = &v32[8 * (v31 >> 2)];
              v39 = v11;
              goto LABEL_43;
            }
            v41 = (v36 >> 3) + 1;
            v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            v38 = &v20[v42];
            v39 = &v11[v42];
            v43 = (__int128 *)(v11 + 16);
            v44 = &v32[v37 + 16];
            v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_43:
                v40 = *(_QWORD *)v39;
                v39 += 8;
                *(_QWORD *)v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          v15 = &v32[8 * v31];
          if (v16)
            operator delete(v16);
          v16 = v33;
          goto LABEL_26;
        }
        v25 = (v11 - v16) >> 3;
        if (v25 >= -1)
          v26 = v25 + 1;
        else
          v26 = v25 + 2;
        v27 = v26 >> 1;
        v28 = &v11[-8 * (v26 >> 1)];
        v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          v29 = v11;
        }
        v30 = -v27;
        v23 = &v28[v15 - v11];
        v20 = &v29[8 * v30];
      }
      else
      {
        v20 = v11;
        v23 = v15;
        v15 = v14;
      }
LABEL_26:
      v14 = v15;
      v24 = *(_QWORD *)v3;
      v3 += 8;
      *(_QWORD *)v23 = v24;
      v21 = v23 + 8;
      v15 = v21;
      v11 = v20;
      if (v3 == *(char **)(a1 + 16))
        goto LABEL_22;
    }
  }
LABEL_21:
  v20 = v11;
  v21 = v15;
LABEL_22:
  v22 = *(void **)a1;
  *(_QWORD *)a1 = v16;
  *(_QWORD *)(a1 + 8) = v20;
  *(_QWORD *)(a1 + 16) = v21;
  *(_QWORD *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(_QWORD *)(a1 + 32) = 256;
    if (v22)
LABEL_24:
      operator delete(v22);
  }
  else
  {
    *(_QWORD *)(a1 + 32) += 512;
    if (v22)
      goto LABEL_24;
  }
}

void sub_1B29DC798(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  const void **v8;
  _BYTE *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  void *result;
  uint64_t v19;
  char *v20;
  const void **v21;
  char *v22;
  _BYTE *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;

  v8 = a5;
  if (a1 == a3)
  {
    if (a2 == a4)
      goto LABEL_42;
    v32 = (uint64_t)*a5;
    v33 = a4;
    while (1)
    {
      v34 = (uint64_t)&a6[-v32] >> 3;
      if ((v33 - a2) >> 3 < v34)
        v34 = (v33 - a2) >> 3;
      v33 -= 8 * v34;
      a6 -= 8 * v34;
      if (v34)
        result = memmove(a6, v33, 8 * v34);
      if (v33 == a2)
        break;
      v35 = (uint64_t)*--v8;
      v32 = v35;
      a6 = (char *)(v35 + 4096);
    }
    goto LABEL_40;
  }
  v14 = *a3;
  if (*a3 != a4)
  {
    v15 = (uint64_t)*a5;
    v16 = a4;
    while (1)
    {
      v17 = (uint64_t)&a6[-v15] >> 3;
      if ((v16 - v14) >> 3 < v17)
        v17 = (v16 - v14) >> 3;
      v16 -= 8 * v17;
      a6 -= 8 * v17;
      if (v17)
        result = memmove(a6, v16, 8 * v17);
      if (v16 == v14)
        break;
      v19 = (uint64_t)*--v8;
      v15 = v19;
      a6 = (char *)(v19 + 4096);
    }
    if ((char *)*v8 + 4096 == a6)
    {
      v20 = (char *)v8[1];
      ++v8;
      a6 = v20;
    }
  }
  v21 = a3 - 1;
  if (a3 - 1 != a1)
  {
    v22 = (char *)*v8;
    do
    {
      while (1)
      {
        v23 = *v21;
        v24 = (char *)*v21 + 4096;
        while (1)
        {
          v25 = (a6 - v22) >> 3;
          if ((v24 - v23) >> 3 < v25)
            v25 = (v24 - v23) >> 3;
          v24 -= 8 * v25;
          a6 -= 8 * v25;
          if (v25)
            result = memmove(a6, v24, 8 * v25);
          if (v24 == v23)
            break;
          v26 = (char *)*--v8;
          v22 = v26;
          a6 = v26 + 4096;
        }
        v22 = (char *)*v8;
        if ((char *)*v8 + 4096 == a6)
          break;
        if (--v21 == a1)
          goto LABEL_24;
      }
      v27 = (char *)v8[1];
      ++v8;
      v22 = v27;
      a6 = v27;
      --v21;
    }
    while (v21 != a1);
  }
LABEL_24:
  v28 = (char *)*a1 + 4096;
  if (v28 != a2)
  {
    v29 = (uint64_t)*v8;
    while (1)
    {
      v30 = (uint64_t)&a6[-v29] >> 3;
      if ((v28 - a2) >> 3 < v30)
        v30 = (v28 - a2) >> 3;
      v28 -= 8 * v30;
      a6 -= 8 * v30;
      if (v30)
        result = memmove(a6, v28, 8 * v30);
      if (v28 == a2)
        break;
      v31 = (uint64_t)*--v8;
      v29 = v31;
      a6 = (char *)(v31 + 4096);
    }
LABEL_40:
    if ((char *)*v8 + 4096 == a6)
    {
      v36 = (char *)v8[1];
      ++v8;
      a6 = v36;
    }
  }
LABEL_42:
  *a7 = a3;
  a7[1] = (const void **)a4;
  a7[2] = v8;
  a7[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>,std::__deque_iterator<Pipeline *,Pipeline **,Pipeline *&,Pipeline ***,long,512l>>>(const void **result, _BYTE *__src, const void **a3, _BYTE *a4, uint64_t a5)
{
  _BYTE *v7;
  char *v8;
  void **v9;
  const void **v11;
  _BYTE *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  const void **i;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  void **v26;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  void **v32;
  _BYTE *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;

  v7 = __src;
  v9 = *(void ***)a5;
  v8 = *(char **)(a5 + 8);
  if (result != a3)
  {
    v11 = result;
    v12 = (char *)*result + 4096;
    if (v12 != __src)
    {
      v14 = (char *)*v9++;
      v13 = v14;
      while (1)
      {
        v15 = (v13 - v8 + 4096) >> 3;
        if ((v12 - v7) >> 3 >= v15)
          v16 = v15;
        else
          v16 = (v12 - v7) >> 3;
        if (v16)
          result = (const void **)memmove(v8, v7, 8 * v16);
        v7 += 8 * v16;
        if (v7 == v12)
          break;
        v17 = (char *)*v9++;
        v13 = v17;
        v8 = v17;
      }
      v8 += 8 * v16;
      if ((char *)*(v9 - 1) + 4096 == v8)
      {
        v8 = (char *)*v9;
        *(_QWORD *)a5 = v9;
        *(_QWORD *)(a5 + 8) = v8;
        i = v11 + 1;
        if (v11 + 1 != a3)
          goto LABEL_16;
LABEL_39:
        v33 = *a3;
        if (v33 == a4)
          goto LABEL_50;
        v35 = (char *)*v9++;
        v34 = v35;
        while (1)
        {
          v36 = (v34 - v8 + 4096) >> 3;
          v37 = (a4 - v33) >> 3 >= v36 ? v36 : (a4 - v33) >> 3;
          if (v37)
            result = (const void **)memmove(v8, v33, 8 * v37);
          v33 += 8 * v37;
          if (v33 == a4)
            break;
          v38 = (char *)*v9++;
          v34 = v38;
          v8 = v38;
        }
        v8 += 8 * v37;
        v32 = v9 - 1;
        if ((char *)*(v9 - 1) + 4096 != v8)
        {
LABEL_49:
          v9 = v32;
          goto LABEL_50;
        }
        goto LABEL_37;
      }
      --v9;
    }
    *(_QWORD *)a5 = v9;
    *(_QWORD *)(a5 + 8) = v8;
    for (i = v11 + 1; i != a3; ++i)
    {
LABEL_16:
      while (1)
      {
        v19 = 0;
        v20 = (char *)*i;
        v22 = (char *)*v9++;
        v21 = v22;
        while (1)
        {
          v23 = (v21 - v8 + 4096) >> 3;
          if ((4096 - 8 * v19) >> 3 >= v23)
            v24 = v23;
          else
            v24 = (4096 - 8 * v19) >> 3;
          if (v24)
            result = (const void **)memmove(v8, &v20[8 * v19], 8 * v24);
          v19 += v24;
          if (v19 == 512)
            break;
          v25 = (char *)*v9++;
          v21 = v25;
          v8 = v25;
        }
        v8 += 8 * v24;
        v26 = v9 - 1;
        if ((char *)*(v9 - 1) + 4096 != v8)
          break;
        v8 = (char *)*v9;
        *(_QWORD *)a5 = v9;
        *(_QWORD *)(a5 + 8) = v8;
        if (++i == a3)
          goto LABEL_39;
      }
      --v9;
      *(_QWORD *)a5 = v26;
      *(_QWORD *)(a5 + 8) = v8;
    }
    goto LABEL_39;
  }
  if (__src != a4)
  {
    v28 = (char *)*v9++;
    v27 = v28;
    while (1)
    {
      v29 = (v27 - v8 + 4096) >> 3;
      if ((a4 - v7) >> 3 >= v29)
        v30 = v29;
      else
        v30 = (a4 - v7) >> 3;
      if (v30)
        result = (const void **)memmove(v8, v7, 8 * v30);
      v7 += 8 * v30;
      if (v7 == a4)
        break;
      v31 = (char *)*v9++;
      v27 = v31;
      v8 = v31;
    }
    v8 += 8 * v30;
    v32 = v9 - 1;
    if ((char *)*(v9 - 1) + 4096 != v8)
      goto LABEL_49;
LABEL_37:
    v8 = (char *)*v9;
  }
LABEL_50:
  *(_QWORD *)a5 = v9;
  *(_QWORD *)(a5 + 8) = v8;
  return result;
}

uint64_t HGCV::HGFormatForCVPixelFormat(HGCV *this, const char *a2, char *a3)
{
  uint64_t v3;
  uint64_t v4;

  if ((int)this <= 1278226533)
  {
    if ((int)this <= 843264103)
    {
      switch((_DWORD)this)
      {
        case 0x20:
          return 22;
        case 0x32433038:
          return 10;
        case 0x32433066:
          return 13;
      }
    }
    else if ((int)this > 1111970368)
    {
      if ((_DWORD)this == 1111970369)
        return 23;
      if ((_DWORD)this == 1278226488)
        return 1;
    }
    else
    {
      if ((_DWORD)this == 843264104)
        return 12;
      if ((_DWORD)this == 843264310)
        return 11;
    }
    goto LABEL_33;
  }
  if ((int)this <= 1380401728)
  {
    switch((_DWORD)this)
    {
      case 0x4C303066:
        return 7;
      case 0x4C303068:
        return 5;
      case 0x4C303136:
        return 3;
    }
  }
  else
  {
    if ((int)this <= 1380411456)
    {
      if ((_DWORD)this == 1380401729)
        return 24;
      if ((_DWORD)this == 1380410945)
        return 28;
      goto LABEL_33;
    }
    if ((_DWORD)this == 1380411457)
      return 27;
    if ((_DWORD)this == 1751411059)
      return 5;
  }
LABEL_33:
  HGLogger::warning((HGLogger *)"unsupported HGFormat for CoreVideo format %c%c%c%c\n", a2, a3, ((int)this >> 24), ((int)((_DWORD)this << 8) >> 24), ((__int16)this >> 8), (char)this, v3, v4);
  return 0;
}

uint64_t HGCV::CVPixelFormatForHGFormat(int a1)
{
  int v1;
  uint64_t v2;
  const char *v3;
  char *v4;

  v1 = a1 - 1;
  if ((a1 - 1) < 0x21 && ((0x1DFE0FE57uLL >> v1) & 1) != 0)
    return dword_1B309BF1C[v1];
  v2 = HGFormatUtils::toString(a1);
  HGLogger::warning((HGLogger *)"unsupported CoreVideo format for HGFormat %s\n", v3, v4, v2);
  return 1111970369;
}

BOOL HGCV::AllowPixelSizeCastingForHGFormat(int a1)
{
  unint64_t v2;
  char v6;
  char **v7;
  char *v8;

  v2 = atomic_load(&HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::envCheck);
  if (v2 != -1)
  {
    v8 = &v6;
    v7 = &v8;
    std::__call_once(&HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::envCheck, &v7, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::$_0 &&>>);
  }
  return a1 != 27 && (a1 - 25) < 0xFFFFFFFE
      || HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::forcePixelSizeCastingAllowed != 0;
}

const char *std::__call_once_proxy[abi:ne180100]<std::tuple<HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::$_0 &&>>()
{
  const char *result;

  result = getenv("HG_ENV_FORCE_IOSURFACE_PIXEL_SIZE_CASTING");
  if (result)
  {
    result = (const char *)atoi(result);
    HGCV::AllowPixelSizeCastingForHGFormat(HGFormat)::forcePixelSizeCastingAllowed = (_DWORD)result != 0;
  }
  return result;
}

void HGDither::HGDither(HGDither *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E65182B8;
  *(_QWORD *)(v1 + 408) = 0;
  *(_BYTE *)(v1 + 448) = 1;
}

void HGDither::~HGDither(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65182B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  *((_QWORD *)this + 51) = 0;
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65182B8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  *((_QWORD *)this + 51) = 0;
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGDither::SetParameter(HGDither *this, int a2, float a3, float a4, float a5, float a6)
{
  int v7;

  if (a2)
    return 0xFFFFFFFFLL;
  v7 = a3 != 0.0;
  if (*((unsigned __int8 *)this + 448) == v7)
    return 0;
  *((_BYTE *)this + 448) = v7;
  return 1;
}

uint64_t HGDither::GetOutput(HGNode *this, HGRenderer *a2)
{
  unsigned __int8 v4;
  _DWORD *v5;
  uint64_t LUTCache;
  HGBitmap *NewLUT;
  HGBitmapLoader *v8;
  HGNode *Input;
  HgcDither_CPU *v10;
  HgcDither_CPU *v11;
  HgcDither_GPU *v12;
  HgcDither_GPU *v13;
  HGTextureWrap *v14;
  char *v15;
  uint64_t v16;

  v5 = (_DWORD *)operator new();
  *(_QWORD *)v5 = &off_1E6518570;
  v5[2] = 3;
  LUTCache = HGLUTCacheManager::getLUTCache(*((_QWORD *)a2 + 69), (unint64_t)&HGDither::GetOutput(HGRenderer *)::lutFactory);
  NewLUT = (HGBitmap *)HGLUTCache::getNewLUT(LUTCache, (uint64_t)v5);
  (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 8))(v5);
  v8 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v8, NewLUT);
  Input = HGRenderer::GetInput(a2, this, 0);
  if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) != 0)
  {
    if (*((_BYTE *)this + 448))
    {
      v10 = (HgcDither_CPU *)HGObject::operator new(0x1A0uLL);
      HgcDither_CPU::HgcDither_CPU(v10);
      v11 = (HgcDither_CPU *)*((_QWORD *)this + 51);
      if (v11 != v10)
      {
        if (v11)
          goto LABEL_13;
        goto LABEL_14;
      }
      if (!v10)
        goto LABEL_15;
    }
    else
    {
      v10 = (HgcDither_CPU *)HGObject::operator new(0x1A0uLL);
      HgcDither_CPU_NoClamp::HgcDither_CPU_NoClamp(v10);
      v11 = (HgcDither_CPU *)*((_QWORD *)this + 51);
      if (v11 != v10)
      {
        if (v11)
LABEL_13:
          (*(void (**)(HgcDither_CPU *))(*(_QWORD *)v11 + 24))(v11);
LABEL_14:
        *((_QWORD *)this + 51) = v10;
LABEL_15:
        v14 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
        HGTextureWrap::HGTextureWrap(v14);
        HGTextureWrap::SetTextureWrapMode((uint64_t)v14, (const char *)3, v15);
        (*(void (**)(HGTextureWrap *, _QWORD, HGBitmapLoader *))(*(_QWORD *)v14 + 120))(v14, 0, v8);
        (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 0, Input);
        (*(void (**)(_QWORD, uint64_t, HGTextureWrap *))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 1, v14);
        (*(void (**)(HGTextureWrap *))(*(_QWORD *)v14 + 24))(v14);
        goto LABEL_21;
      }
      if (!v10)
        goto LABEL_15;
    }
    (*(void (**)(HgcDither_CPU *))(*(_QWORD *)v10 + 24))(v10);
    goto LABEL_15;
  }
  if (*((_BYTE *)this + 448))
  {
    v12 = (HgcDither_GPU *)HGObject::operator new(0x1A0uLL);
    HgcDither_GPU::HgcDither_GPU(v12);
    v13 = (HgcDither_GPU *)*((_QWORD *)this + 51);
    if (v13 != v12)
    {
      if (v13)
        goto LABEL_18;
      goto LABEL_19;
    }
    if (!v12)
      goto LABEL_20;
LABEL_29:
    (*(void (**)(HgcDither_GPU *))(*(_QWORD *)v12 + 24))(v12);
    goto LABEL_20;
  }
  v12 = (HgcDither_GPU *)HGObject::operator new(0x1A0uLL);
  HgcDither_GPU_NoClamp::HgcDither_GPU_NoClamp(v12);
  v13 = (HgcDither_GPU *)*((_QWORD *)this + 51);
  if (v13 == v12)
  {
    if (!v12)
      goto LABEL_20;
    goto LABEL_29;
  }
  if (v13)
LABEL_18:
    (*(void (**)(HgcDither_GPU *))(*(_QWORD *)v13 + 24))(v13);
LABEL_19:
  *((_QWORD *)this + 51) = v12;
LABEL_20:
  (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 0, Input);
  (*(void (**)(_QWORD, uint64_t, HGBitmapLoader *))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 1, v8);
LABEL_21:
  v16 = *((_QWORD *)this + 51);
  if (v8)
    (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v8 + 24))(v8);
  if (NewLUT)
    (*(void (**)(HGBitmap *))(*(_QWORD *)NewLUT + 24))(NewLUT);
  return v16;
}

void sub_1B29DD370(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void HGDitherLUTEntryFactory::~HGDitherLUTEntryFactory(HGDitherLUTEntryFactory *this)
{
  JUMPOUT(0x1B5E29170);
}

_QWORD *HGDitherLUTEntryFactory::createLUTEntry(uint64_t a1, const void *a2, uint64_t a3)
{
  _QWORD *v5;

  v5 = (_QWORD *)operator new();
  HGDitherLUTEntry::HGDitherLUTEntry(v5, a2, a3);
  return v5;
}

void sub_1B29DD518(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0xA1C40987D6AD5);
  _Unwind_Resume(a1);
}

void HGDitherLUTInfo::~HGDitherLUTInfo(HGDitherLUTInfo *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t HGDitherLUTInfo::duplicate(HGDitherLUTInfo *this)
{
  uint64_t result;
  int v3;

  result = operator new();
  v3 = *((_DWORD *)this + 2);
  *(_QWORD *)result = &off_1E6518570;
  *(_DWORD *)(result + 8) = v3;
  return result;
}

_DWORD *HGDitherLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  _DWORD *result;

  if (!lpsrc)
    return 0;
  if (result)
    return (_DWORD *)(*(_DWORD *)(a1 + 8) == result[2]);
  return result;
}

_QWORD *HGDitherLUTEntry::HGDitherLUTEntry(_QWORD *a1, const void *a2, uint64_t a3)
{
  _QWORD *v5;
  HGBitmap **v6;
  HGDitherNoise *v7;
  HGDitherNoise *NumRows;
  int v9;
  int v10;
  uint64_t v11;
  HGDitherNoise *v12;
  uint64_t v13;
  uint64_t v14;
  int Format;
  HGBitmap *v16;
  __n128 v17;
  HGBitmap *v18;
  char *Noise;
  HGBitmap *v20;
  dispatch_group_t *v22;

  v5 = HGLUTCache::LUTEntry::LUTEntry(a1, (uint64_t)a2, a3);
  *v5 = &off_1E65185C8;
  v5[3] = 0;
  v6 = (HGBitmap **)(v5 + 3);
  v5[4] = 0;
  if (a2)
  {
    if (v7)
    {
      NumRows = (HGDitherNoise *)HGDitherNoise::getNumRows(v7);
      v9 = (int)NumRows;
      v10 = HGDitherNoise::getNumRows(NumRows);
      v12 = (HGDitherNoise *)HGRectMake4f(v11, 0.0, 0.0, (float)v9, (float)v10);
      v14 = v13;
      Format = HGDitherNoise::getFormat(v12);
      v16 = (HGBitmap *)HGObject::operator new(0x80uLL);
      v17 = HGBitmap::HGBitmap(v16, v12, v14, 27);
      v18 = *v6;
      if (*v6 == v16)
      {
        if (v16)
          (*(void (**)(HGBitmap *, __n128))(*(_QWORD *)v16 + 24))(v16, v17);
      }
      else
      {
        if (v18)
          (*(void (**)(HGBitmap *, __n128))(*(_QWORD *)v18 + 24))(v18, v17);
        *v6 = v16;
      }
      Noise = HGDitherNoise::getNoise();
      v20 = (HGBitmap *)HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap((uint64_t)v20, (uint64_t)v12, v14, Format, (uint64_t)Noise);
      if (Format == *((_DWORD *)*v6 + 4))
      {
        HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)&v22);
        HGRenderUtils::BufferCopier::execute(&v22, *v6, v20);
        HGRenderUtils::BufferCopier::~BufferCopier((HGRenderUtils::BufferCopier *)&v22);
        if (!v20)
          return a1;
        goto LABEL_13;
      }
      HGRenderUtils::BufferReformatter::BufferReformatter((HGRenderUtils::BufferReformatter *)&v22);
      HGRenderUtils::BufferReformatter::execute((HGRenderUtils::BufferReformatter *)&v22, *v6, v20);
      HGRenderUtils::BufferReformatter::~BufferReformatter((HGRenderUtils::BufferReformatter *)&v22);
      if (v20)
LABEL_13:
        (*(void (**)(HGBitmap *))(*(_QWORD *)v20 + 24))(v20);
    }
  }
  return a1;
}

void sub_1B29DD79C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  HGLUTCache::LUTEntry *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v14;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  v14 = *((_QWORD *)v10 + 4);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  if (*v12)
    (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 24))(*v12);
  HGLUTCache::LUTEntry::~LUTEntry(v10);
  _Unwind_Resume(a1);
}

void HGDitherLUTEntry::~HGDitherLUTEntry(HGDitherLUTEntry *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E65185C8;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGLUTCache::LUTEntry::~LUTEntry(this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E65185C8;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGLUTCache::LUTEntry::~LUTEntry(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t HGDitherLUTEntry::GetBitmap(HGDitherLUTEntry *this)
{
  uint64_t v2;
  uint64_t v3;
  HGGPURenderer *v4;
  HGMetalTexture *v5;
  char *v6;
  uint64_t MetalContext;
  HGMetalTexture *v8;
  HGMetalTexture *v10;

  v2 = *((_QWORD *)this + 2);
  if (!v2
    || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 304))(v2) & 1) != 0
    || ((v3 = *((_QWORD *)this + 2)) == 0
      ? (v4 = 0)
  {
    v5 = (HGMetalTexture *)*((_QWORD *)this + 3);
    v6 = (char *)this + 24;
    if (!v5)
      return *(_QWORD *)v6;
    goto LABEL_14;
  }
  v6 = (char *)this + 32;
  v5 = (HGMetalTexture *)*((_QWORD *)this + 4);
  if (v5)
    goto LABEL_14;
  MetalContext = HGGPURenderer::GetMetalContext(v4);
  HGMetalTexture::createWithCopy(*(void **)(*(_QWORD *)(MetalContext + 16) + 16), 0, *((_QWORD *)this + 3), *(_QWORD *)(*((_QWORD *)this + 3) + 20), *(_QWORD *)(*((_QWORD *)this + 3) + 28), 0, 0, &v10);
  v8 = (HGMetalTexture *)*((_QWORD *)this + 4);
  v5 = v10;
  if (v8 == v10)
  {
    if (!v8)
      return *(_QWORD *)v6;
    (*(void (**)(_QWORD))(*(_QWORD *)v8 + 24))(*((_QWORD *)this + 4));
    v5 = *(HGMetalTexture **)v6;
    if (!*(_QWORD *)v6)
      return *(_QWORD *)v6;
LABEL_14:
    (*(void (**)(HGMetalTexture *))(*(_QWORD *)v5 + 16))(v5);
    return *(_QWORD *)v6;
  }
  if (v8)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v8 + 24))(*((_QWORD *)this + 4));
    v5 = v10;
  }
  *(_QWORD *)v6 = v5;
  if (v5)
    goto LABEL_14;
  return *(_QWORD *)v6;
}

void sub_1B29DDA78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

void HGCFDataRefHolder::HGCFDataRefHolder(HGCFDataRefHolder *this, const __CFData *a2)
{
  _QWORD *v3;

  HGObject::HGObject(this);
  *v3 = off_1E6518608;
  v3[2] = a2;
  CFRetain(a2);
}

void sub_1B29DDADC(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGCFDataRefHolder::~HGCFDataRefHolder(CFTypeRef *this)
{
  *this = off_1E6518608;
  CFRelease(this[2]);
  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;

  *this = off_1E6518608;
  CFRelease(this[2]);
  HGObject::~HGObject((HGObject *)this);
  HGObject::operator delete(v2);
}

double HGDigestInit(_OWORD *a1)
{
  double result;

  result = -3.59869635e230;
  *a1 = xmmword_1B30588E0;
  return result;
}

_DWORD *HGDigestAdd(_DWORD *result, int *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;

  v2 = result[1];
  v4 = result[2];
  v3 = result[3];
  v5 = *a2;
  v6 = a2[1];
  HIDWORD(v7) = *result + *a2 - 680876936 + (v4 & v2 | v3 & ~v2);
  LODWORD(v7) = HIDWORD(v7);
  v8 = (v7 >> 25) + v2;
  HIDWORD(v7) = v3 + v6 - 389564586 + (v2 & v8 | v4 & ~v8);
  LODWORD(v7) = HIDWORD(v7);
  v9 = (v7 >> 20) + v8;
  v10 = a2[2];
  v11 = a2[3];
  HIDWORD(v7) = v4 + v10 + 606105819 + (v8 & v9 | v2 & ~v9);
  LODWORD(v7) = HIDWORD(v7);
  v12 = (v7 >> 15) + v9;
  HIDWORD(v7) = v2 + v11 - 1044525330 + (v9 & v12 | v8 & ~v12);
  LODWORD(v7) = HIDWORD(v7);
  v13 = (v7 >> 10) + v12;
  v15 = a2[4];
  v14 = a2[5];
  HIDWORD(v7) = v15 + v8 - 176418897 + (v12 & v13 | v9 & ~v13);
  LODWORD(v7) = HIDWORD(v7);
  v16 = (v7 >> 25) + v13;
  HIDWORD(v7) = v14 + v9 + 1200080426 + (v13 & v16 | v12 & ~v16);
  LODWORD(v7) = HIDWORD(v7);
  v17 = (v7 >> 20) + v16;
  v18 = a2[6];
  v19 = a2[7];
  HIDWORD(v7) = v18 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17);
  LODWORD(v7) = HIDWORD(v7);
  v20 = (v7 >> 15) + v17;
  HIDWORD(v7) = v19 + v13 - 45705983 + (v17 & v20 | v16 & ~v20);
  LODWORD(v7) = HIDWORD(v7);
  v21 = (v7 >> 10) + v20;
  v22 = a2[8];
  v23 = a2[9];
  HIDWORD(v7) = v22 + v16 + 1770035416 + (v20 & v21 | v17 & ~v21);
  LODWORD(v7) = HIDWORD(v7);
  v24 = (v7 >> 25) + v21;
  HIDWORD(v7) = v23 + v17 - 1958414417 + (v21 & v24 | v20 & ~v24);
  LODWORD(v7) = HIDWORD(v7);
  v25 = (v7 >> 20) + v24;
  v27 = a2[10];
  v26 = a2[11];
  HIDWORD(v7) = v27 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
  LODWORD(v7) = HIDWORD(v7);
  v28 = (v7 >> 15) + v25;
  HIDWORD(v7) = v26 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
  LODWORD(v7) = HIDWORD(v7);
  v29 = (v7 >> 10) + v28;
  v31 = a2[12];
  v30 = a2[13];
  HIDWORD(v7) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
  LODWORD(v7) = HIDWORD(v7);
  v32 = (v7 >> 25) + v29;
  HIDWORD(v7) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
  LODWORD(v7) = HIDWORD(v7);
  v33 = (v7 >> 20) + v32;
  v35 = a2[14];
  v34 = a2[15];
  HIDWORD(v7) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  v36 = (v7 >> 15) + v33;
  HIDWORD(v7) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  v37 = (v7 >> 10) + v36;
  HIDWORD(v7) = v6 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  v38 = (v7 >> 27) + v37;
  HIDWORD(v7) = v18 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  v39 = (v7 >> 23) + v38;
  HIDWORD(v7) = v26 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
  LODWORD(v7) = HIDWORD(v7);
  v40 = (v7 >> 18) + v39;
  HIDWORD(v7) = v5 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
  LODWORD(v7) = HIDWORD(v7);
  v41 = (v7 >> 12) + v40;
  HIDWORD(v7) = v14 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
  LODWORD(v7) = HIDWORD(v7);
  v42 = (v7 >> 27) + v41;
  HIDWORD(v7) = v27 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
  LODWORD(v7) = HIDWORD(v7);
  v43 = (v7 >> 23) + v42;
  HIDWORD(v7) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
  LODWORD(v7) = HIDWORD(v7);
  v44 = (v7 >> 18) + v43;
  HIDWORD(v7) = v15 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
  LODWORD(v7) = HIDWORD(v7);
  v45 = (v7 >> 12) + v44;
  HIDWORD(v7) = v23 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
  LODWORD(v7) = HIDWORD(v7);
  v46 = (v7 >> 27) + v45;
  HIDWORD(v7) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
  LODWORD(v7) = HIDWORD(v7);
  v47 = (v7 >> 23) + v46;
  HIDWORD(v7) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
  LODWORD(v7) = HIDWORD(v7);
  v48 = (v7 >> 18) + v47;
  HIDWORD(v7) = v22 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
  LODWORD(v7) = HIDWORD(v7);
  v49 = (v7 >> 12) + v48;
  HIDWORD(v7) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
  LODWORD(v7) = HIDWORD(v7);
  v50 = (v7 >> 27) + v49;
  HIDWORD(v7) = v10 + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
  LODWORD(v7) = HIDWORD(v7);
  v51 = (v7 >> 23) + v50;
  HIDWORD(v7) = v19 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
  LODWORD(v7) = HIDWORD(v7);
  v52 = (v7 >> 18) + v51;
  HIDWORD(v7) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
  LODWORD(v7) = HIDWORD(v7);
  v53 = (v7 >> 12) + v52;
  HIDWORD(v7) = v14 + v50 - 378558 + (v52 ^ v51 ^ v53);
  LODWORD(v7) = HIDWORD(v7);
  v54 = (v7 >> 28) + v53;
  HIDWORD(v7) = v22 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
  LODWORD(v7) = HIDWORD(v7);
  v55 = (v7 >> 21) + v54;
  HIDWORD(v7) = v26 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
  LODWORD(v7) = HIDWORD(v7);
  v56 = (v7 >> 16) + v55;
  HIDWORD(v7) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
  LODWORD(v7) = HIDWORD(v7);
  v57 = (v7 >> 9) + v56;
  HIDWORD(v7) = v6 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
  LODWORD(v7) = HIDWORD(v7);
  v58 = (v7 >> 28) + v57;
  HIDWORD(v7) = v15 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
  LODWORD(v7) = HIDWORD(v7);
  v59 = (v7 >> 21) + v58;
  HIDWORD(v7) = v19 + v56 - 155497632 + (v58 ^ v57 ^ v59);
  LODWORD(v7) = HIDWORD(v7);
  v60 = (v7 >> 16) + v59;
  HIDWORD(v7) = v27 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
  LODWORD(v7) = HIDWORD(v7);
  v61 = (v7 >> 9) + v60;
  HIDWORD(v7) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
  LODWORD(v7) = HIDWORD(v7);
  v62 = (v7 >> 28) + v61;
  HIDWORD(v7) = v5 + v59 - 358537222 + (v61 ^ v60 ^ v62);
  LODWORD(v7) = HIDWORD(v7);
  v63 = (v7 >> 21) + v62;
  HIDWORD(v7) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
  LODWORD(v7) = HIDWORD(v7);
  v64 = (v7 >> 16) + v63;
  HIDWORD(v7) = v18 + v61 + 76029189 + (v63 ^ v62 ^ v64);
  LODWORD(v7) = HIDWORD(v7);
  v65 = (v7 >> 9) + v64;
  HIDWORD(v7) = v23 + v62 - 640364487 + (v64 ^ v63 ^ v65);
  LODWORD(v7) = HIDWORD(v7);
  v66 = (v7 >> 28) + v65;
  HIDWORD(v7) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
  LODWORD(v7) = HIDWORD(v7);
  v67 = (v7 >> 21) + v66;
  HIDWORD(v7) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
  LODWORD(v7) = HIDWORD(v7);
  v68 = (v7 >> 16) + v67;
  HIDWORD(v7) = v10 + v65 - 995338651 + (v67 ^ v66 ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  v69 = (v7 >> 9) + v68;
  HIDWORD(v7) = v5 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  v70 = (v7 >> 26) + v69;
  HIDWORD(v7) = v19 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
  LODWORD(v7) = HIDWORD(v7);
  v71 = (v7 >> 22) + v70;
  HIDWORD(v7) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
  LODWORD(v7) = HIDWORD(v7);
  v72 = (v7 >> 17) + v71;
  HIDWORD(v7) = v14 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
  LODWORD(v7) = HIDWORD(v7);
  v73 = (v7 >> 11) + v72;
  HIDWORD(v7) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
  LODWORD(v7) = HIDWORD(v7);
  v74 = (v7 >> 26) + v73;
  HIDWORD(v7) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
  LODWORD(v7) = HIDWORD(v7);
  v75 = (v7 >> 22) + v74;
  HIDWORD(v7) = v27 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
  LODWORD(v7) = HIDWORD(v7);
  v76 = (v7 >> 17) + v75;
  HIDWORD(v7) = v6 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
  LODWORD(v7) = HIDWORD(v7);
  v77 = (v7 >> 11) + v76;
  HIDWORD(v7) = v22 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
  LODWORD(v7) = HIDWORD(v7);
  v78 = (v7 >> 26) + v77;
  HIDWORD(v7) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
  LODWORD(v7) = HIDWORD(v7);
  v79 = (v7 >> 22) + v78;
  HIDWORD(v7) = v18 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
  LODWORD(v7) = HIDWORD(v7);
  v80 = (v7 >> 17) + v79;
  HIDWORD(v7) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
  LODWORD(v7) = HIDWORD(v7);
  v81 = (v7 >> 11) + v80;
  HIDWORD(v7) = v15 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
  LODWORD(v7) = HIDWORD(v7);
  v82 = (v7 >> 26) + v81;
  HIDWORD(v7) = v26 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
  LODWORD(v7) = HIDWORD(v7);
  v83 = (v7 >> 22) + v82;
  HIDWORD(v7) = v10 + v80 + 718787259 + ((v83 | ~v81) ^ v82);
  LODWORD(v7) = HIDWORD(v7);
  v84 = (v7 >> 17) + v83;
  HIDWORD(v7) = v23 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
  LODWORD(v7) = HIDWORD(v7);
  *result += v82;
  result[1] = v84 + v2 + (v7 >> 11);
  result[2] = v84 + v4;
  result[3] = v83 + v3;
  return result;
}

const char *HGGLGetErrorString(int a1)
{
  if ((a1 - 1280) > 6)
    return "unknown error";
  else
    return off_1E6518698[a1 - 1280];
}

const char *HGGLGetFramebufferStatusString(int a1)
{
  if ((a1 - 36054) > 7)
    return "unknown status";
  else
    return off_1E65186D0[a1 - 36054];
}

void HGGLContextPtr::HGGLContextPtr(HGGLContextPtr *this, void *a2)
{
  *(_QWORD *)this = a2;
}

void HGGLContext::~HGGLContext(HGGLContext *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6518658;
  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 2) = 0;
  }
  HGObject::~HGObject((HGObject *)this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6518658;
  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 2) = 0;
  }
  HGObject::~HGObject((HGObject *)this);
  HGObject::operator delete(v3);
}

uint64_t HGGLContext::context(HGGLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 40))(*((_QWORD *)this + 2));
}

uint64_t HGGLContext::ptr(HGGLContext *this)
{
  uint64_t v2;

  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 2) + 40))(&v2);
  return v2;
}

uint64_t HGGLContext::isAccelerated(HGGLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
}

uint64_t HGGLContext::isES2(HGGLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 64))(*((_QWORD *)this + 2));
}

uint64_t HGGLContext::setVirtualScreen(HGGLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 88))(*((_QWORD *)this + 2));
}

uint64_t HGGLContext::getVirtualScreen(HGGLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 96))(*((_QWORD *)this + 2));
}

uint64_t HGGLContext::setPriority(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 144))(*(_QWORD *)(a1 + 16));
}

uint64_t HGGLContext::getPriority(HGGLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 136))(*((_QWORD *)this + 2));
}

uint64_t HGGLContext::setCurrent(HGGLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 128))(*((_QWORD *)this + 2));
}

uint64_t HGGLContext::Create@<X0>(uint64_t *a1@<X0>, HGObject **a2@<X8>)
{
  HGObject *v4;
  HGGLContextEAGL *v5;
  uint64_t result;
  uint64_t v7;

  v4 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v4);
  *(_QWORD *)v4 = off_1E6518658;
  v5 = (HGGLContextEAGL *)operator new();
  HGGLContextEAGL::HGGLContextEAGL(v5);
  *((_QWORD *)v4 + 2) = v5;
  v7 = *a1;
  result = (*(uint64_t (**)(HGGLContextEAGL *, uint64_t *))(*(_QWORD *)v5 + 24))(v5, &v7);
  *a2 = v4;
  return result;
}

void sub_1B29DE778(_Unwind_Exception *a1)
{
  HGObject *v1;
  uint64_t v2;
  void *v4;

  MEMORY[0x1B5E29170](v2, 0x81C40803F642BLL);
  HGObject::~HGObject(v1);
  HGObject::operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1B29DE7B0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGLContext::Share@<X0>(uint64_t *a1@<X0>, HGObject **a2@<X8>)
{
  HGObject *v4;
  HGGLContextEAGL *v5;
  uint64_t result;
  uint64_t v7;

  v4 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v4);
  *(_QWORD *)v4 = off_1E6518658;
  v5 = (HGGLContextEAGL *)operator new();
  HGGLContextEAGL::HGGLContextEAGL(v5);
  *((_QWORD *)v4 + 2) = v5;
  v7 = *a1;
  result = (*(uint64_t (**)(HGGLContextEAGL *, uint64_t *))(*(_QWORD *)v5 + 32))(v5, &v7);
  *a2 = v4;
  return result;
}

void sub_1B29DE854(_Unwind_Exception *a1)
{
  HGObject *v1;
  uint64_t v2;
  void *v4;

  MEMORY[0x1B5E29170](v2, 0x81C40803F642BLL);
  HGObject::~HGObject(v1);
  HGObject::operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1B29DE88C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGGLSetCurrentContext(PC_Sp_counted_base **a1)
{
  PC_Sp_counted_base *v1;

  v1 = *a1;
  HGGLContextEAGL::setCurrent(&v1);
}

HGGLContextPtr *HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard(HGGLContextPtr *a1, PC_Sp_counted_base **a2)
{
  PC_Sp_counted_base *v5;

  HGGLContextEAGL::getCurrent(a1);
  *((_BYTE *)a1 + 8) = 0;
  if (*(PC_Sp_counted_base **)a1 != *a2)
  {
    v5 = *a2;
    HGGLContextEAGL::setCurrent(&v5);
    *((_BYTE *)a1 + 8) = 1;
  }
  return a1;
}

void sub_1B29DE928(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(a1);
}

void HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard(HGGLSetCurrentContextGuard *this)
{
  PC_Sp_counted_base *v2;

  if (*((_BYTE *)this + 8))
  {
    v2 = *(PC_Sp_counted_base **)this;
    HGGLContextEAGL::setCurrent(&v2);
  }
  *(_QWORD *)this = 0;
}

char *HGDitherNoise::getNoise()
{
  return kBlueNoise3RPDF;
}

uint64_t HGDitherNoise::getNumRows(HGDitherNoise *this)
{
  return 256;
}

uint64_t HGDitherNoise::getFormat(HGDitherNoise *this)
{
  return 27;
}

void HGGLContextEAGL::HGGLContextEAGL(HGGLContextEAGL *this)
{
  *(_QWORD *)this = &off_1E6518720;
  *((_QWORD *)this + 1) = 0;
}

void HGGLContextEAGL::~HGGLContextEAGL(id *this)
{
  *this = &off_1E6518720;

}

{
  *this = &off_1E6518720;

  JUMPOUT(0x1B5E29170);
}

uint64_t HGGLContextEAGL::create(HGGLContextEAGL *this)
{
  uint64_t result;

  result = objc_msgSend(objc_alloc(MEMORY[0x1E0CD0958]), "initWithAPI:", 2);
  *((_QWORD *)this + 1) = result;
  return result;
}

uint64_t HGGLContextEAGL::create(uint64_t a1, PC_Sp_counted_base **a2)
{
  void *CGColorSpace;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  PCSharedCount v7;

  v7.var0 = *a2;
  CGColorSpace = (void *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v7);
  PCSharedCount::PCSharedCount(&v7);
  v4 = objc_msgSend(CGColorSpace, "API");
  v5 = objc_msgSend(CGColorSpace, "sharegroup");
  result = objc_msgSend(objc_alloc(MEMORY[0x1E0CD0958]), "initWithAPI:sharegroup:", v4, v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

void sub_1B29DEAD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

uint64_t HGGLContextEAGL::share(_QWORD *a1, PC_Sp_counted_base **a2)
{
  PCSharedCount v4;

  v4.var0 = *a2;
  a1[1] = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v4);
  PCSharedCount::PCSharedCount(&v4);
  return (*(uint64_t (**)(_QWORD *))(*a1 + 112))(a1);
}

void sub_1B29DEB38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void HGGLContextEAGL::context(void **this@<X0>, HGGLContextPtr *a2@<X8>)
{
  HGGLContextPtr::HGGLContextPtr(a2, this[1]);
}

uint64_t HGGLContextEAGL::isAccelerated(HGGLContextEAGL *this)
{
  return 1;
}

uint64_t HGGLContextEAGL::isES2(HGGLContextEAGL *this)
{
  return 1;
}

uint64_t HGGLContextEAGL::isES3(HGGLContextEAGL *this)
{
  return 0;
}

uint64_t HGGLContextEAGL::getShareGroup(id *this)
{
  return objc_msgSend(this[1], "sharegroup");
}

uint64_t HGGLContextEAGL::getVirtualScreen(HGGLContextEAGL *this)
{
  return 0;
}

uint64_t HGGLContextEAGL::getRegistryID(HGGLContextEAGL *this)
{
  return 0;
}

id HGGLContextEAGL::retain(id *this)
{
  return this[1];
}

void HGGLContextEAGL::release(id *this)
{

}

uint64_t HGGLContextEAGL::setCurrent(HGGLContextEAGL *this)
{
  return objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", *((_QWORD *)this + 1));
}

void HGGLContextEAGL::setCurrent(PC_Sp_counted_base **a1)
{
  PCSharedCount v1;

  v1.var0 = *a1;
  objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v1));
  PCSharedCount::PCSharedCount(&v1);
}

void sub_1B29DEBFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void HGGLContextEAGL::getCurrent(HGGLContextPtr *a1@<X8>)
{
  HGGLContextPtr::HGGLContextPtr(a1, (void *)objc_msgSend(MEMORY[0x1E0CD0958], "currentContext"));
}

uint64_t HGGLContextEAGL::getPriority(HGGLContextEAGL *this)
{
  return 1;
}

BOOL HGGLContextEAGL::setPriority(uint64_t a1, int a2)
{
  int v2;
  int v4;

  v4 = 1;
  if (a2 == 2)
  {
    v2 = 4;
    goto LABEL_5;
  }
  if (!a2)
  {
    v2 = 2;
LABEL_5:
    v4 = v2;
  }
  return objc_msgSend(*(id *)(a1 + 8), "setParameter:to:", 608, &v4) == 0;
}

uint64_t HGGLContextEAGL::isES(HGGLContextEAGL *this)
{
  return 1;
}

HgcDemosaic_2 *HGDemosaicImplementation::GenerateGraph(HGDemosaicImplementation *this, HGRenderer *a2, HGNode *a3)
{
  HgcDemosaic_1 *v6;
  HgcDemosaic_2 *v7;
  HgcDemosaic_2 *v8;
  HgcDemosaic_2 *v9;

  if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0
    && (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 43)
    && (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 43) != 1)
  {
    return 0;
  }
  v6 = (HgcDemosaic_1 *)HGObject::operator new(0x1A0uLL);
  HgcDemosaic_1::HgcDemosaic_1(v6);
  *(_QWORD *)v6 = off_1E6518A40;
  v7 = (HgcDemosaic_2 *)HGObject::operator new(0x1A0uLL);
  HgcDemosaic_2::HgcDemosaic_2(v7);
  *(_QWORD *)v7 = off_1E6518CA8;
  (*(void (**)(HgcDemosaic_1 *, _QWORD, HGNode *))(*(_QWORD *)v6 + 120))(v6, 0, a3);
  (*(void (**)(HgcDemosaic_1 *, _QWORD, float, double, float, float))(*(_QWORD *)v6 + 96))(v6, 0, *((float *)this + 3), *((double *)this + 3), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 3))), *((float *)this + 4));
  (*(void (**)(HgcDemosaic_1 *, uint64_t, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 1, *((float *)this + 8), *((float *)this + 9), *((float *)this + 10), *((float *)this + 11));
  (*(void (**)(HgcDemosaic_1 *, uint64_t, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 2, 1.0 / COERCE_FLOAT(*((_QWORD *)this + 6)), 1.0 / COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 6))), *((float *)this + 5), 0.0);
  (*(void (**)(HgcDemosaic_2 *, _QWORD, HgcDemosaic_1 *))(*(_QWORD *)v7 + 120))(v7, 0, v6);
  (*(void (**)(HgcDemosaic_2 *, _QWORD, float, double, float, float))(*(_QWORD *)v7 + 96))(v7, 0, *((float *)this + 3), *((double *)this + 3), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 3))), 0.0);
  (*(void (**)(HgcDemosaic_2 *, uint64_t, float, float, float, float))(*(_QWORD *)v7 + 96))(v7, 1, *((float *)this + 8), *((float *)this + 9), *((float *)this + 10), *((float *)this + 11));
  (*(void (**)(HgcDemosaic_2 *, uint64_t, double, float, float, float))(*(_QWORD *)v7 + 96))(v7, 2, *((double *)this + 6), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 6))), 0.0, 0.0);
  v8 = (HgcDemosaic_2 *)*((_QWORD *)this + 7);
  v9 = v7;
  if (v8 != v7)
  {
    if (v8)
      (*(void (**)(HgcDemosaic_2 *))(*(_QWORD *)v8 + 24))(v8);
    *((_QWORD *)this + 7) = v7;
    (*(void (**)(HgcDemosaic_2 *))(*(_QWORD *)v7 + 16))(v7);
    v9 = (HgcDemosaic_2 *)*((_QWORD *)this + 7);
  }
  (*(void (**)(HgcDemosaic_2 *))(*(_QWORD *)v7 + 24))(v7);
  (*(void (**)(HgcDemosaic_1 *))(*(_QWORD *)v6 + 24))(v6);
  return v9;
}

void sub_1B29DEECC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HDemosaic_1::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

uint64_t HDemosaic_2::GetROI(HDemosaic_2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HDemosaic_2::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

void HGDemosaic::HGDemosaic(HGDemosaic *this)
{
  _QWORD *v2;
  char *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65187F0;
  v3 = (char *)HGObject::operator new(0x40uLL);
  HGObject::HGObject((HGObject *)v3);
  *(_QWORD *)v3 = off_1E6518F28;
  *(_OWORD *)(v3 + 12) = 0u;
  *(_OWORD *)(v3 + 28) = 0u;
  *(_OWORD *)(v3 + 44) = 0u;
  *((_DWORD *)v3 + 15) = 0;
  *((_QWORD *)this + 51) = v3;
}

void sub_1B29DF034(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DF050(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGDemosaic::~HGDemosaic(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65187F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E65187F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGDemosaic::SetParameter(HGDemosaic *this, int a2, double a3, float a4, float a5, float a6)
{
  uint64_t v6;
  uint64_t result;

  v6 = *((_QWORD *)this + 51);
  switch(a2)
  {
    case 0:
      if (*(float *)(v6 + 12) == *(float *)&a3)
        goto LABEL_27;
      *(_DWORD *)(v6 + 12) = LODWORD(a3);
      result = 1;
      break;
    case 1:
      if (*(float *)(v6 + 16) == *(float *)&a3)
        goto LABEL_27;
      *(_DWORD *)(v6 + 16) = LODWORD(a3);
      result = 1;
      break;
    case 2:
      if (*(float *)(v6 + 20) == *(float *)&a3)
        goto LABEL_27;
      *(_DWORD *)(v6 + 20) = LODWORD(a3);
      result = 1;
      break;
    case 3:
      if (COERCE_FLOAT(*(_QWORD *)(v6 + 24)) == *(float *)&a3 && COERCE_FLOAT(HIDWORD(*(_QWORD *)(v6 + 24))) == a4)
        goto LABEL_27;
      *((float *)&a3 + 1) = a4;
      *(double *)(v6 + 24) = a3;
      result = 1;
      break;
    case 4:
      if (*(float *)(v6 + 32) == *(float *)&a3)
        goto LABEL_27;
      *(_DWORD *)(v6 + 32) = LODWORD(a3);
      result = 1;
      break;
    case 5:
      if (*(float *)(v6 + 36) == *(float *)&a3)
        goto LABEL_27;
      *(_DWORD *)(v6 + 36) = LODWORD(a3);
      result = 1;
      break;
    case 6:
      if (*(float *)(v6 + 40) == *(float *)&a3)
        goto LABEL_27;
      *(_DWORD *)(v6 + 40) = LODWORD(a3);
      result = 1;
      break;
    case 7:
      if (*(float *)(v6 + 44) == *(float *)&a3)
        goto LABEL_27;
      *(_DWORD *)(v6 + 44) = LODWORD(a3);
      result = 1;
      break;
    case 8:
      if (COERCE_FLOAT(*(_QWORD *)(v6 + 48)) == *(float *)&a3 && COERCE_FLOAT(HIDWORD(*(_QWORD *)(v6 + 48))) == a4)
      {
LABEL_27:
        result = 0;
      }
      else
      {
        *((float *)&a3 + 1) = a4;
        *(double *)(v6 + 48) = a3;
        result = 1;
      }
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

HGNode *HGDemosaic::GetOutput(HGDemosaic *this, HGRenderer *a2)
{
  HGNode *result;

  result = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (result)
    return (HGNode *)HGDemosaicImplementation::GenerateGraph(*((HGDemosaicImplementation **)this + 51), a2, result);
  return result;
}

void HDemosaic_1::~HDemosaic_1(HGNode *this)
{
  void *v1;

  HgcDemosaic_1::~HgcDemosaic_1(this);
  HGObject::operator delete(v1);
}

void HDemosaic_2::~HDemosaic_2(HGNode *this)
{
  void *v1;

  HgcDemosaic_2::~HgcDemosaic_2(this);
  HGObject::operator delete(v1);
}

void HGDemosaicImplementation::~HGDemosaicImplementation(HGDemosaicImplementation *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6518F28;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6518F28;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGObject::~HGObject(this);
  HGObject::operator delete(v3);
}

void HGComicGaussianBlurAndGradientGeneration::HGComicGaussianBlurAndGradientGeneration(HGComicGaussianBlurAndGradientGeneration *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E6518F78;
  *(_OWORD *)(v1 + 408) = xmmword_1B30520F0;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGComicGaussianBlurAndGradientGeneration::~HGComicGaussianBlurAndGradientGeneration(HGNode *this)
{
  void *v1;

  HGNode::~HGNode(this);
  HGObject::operator delete(v1);
}

uint64_t HGComicGaussianBlurAndGradientGeneration::SetParameter(HGComicGaussianBlurAndGradientGeneration *this, int a2, float a3, float a4, float a5, float a6)
{
  float v7;
  float v8;
  float v9;

  if (a2 == 2)
  {
    if (a3 == 1.0)
      v7 = 1.0;
    else
      v7 = 0.0;
    if (*((float *)this + 105) != v7)
    {
      if (a3 == 1.0)
        v8 = 1.0;
      else
        v8 = 0.0;
      *((float *)this + 105) = v8;
      return 1;
    }
  }
  else
  {
    if (a2 != 1)
    {
      if (a2)
        return 0xFFFFFFFFLL;
      if (*((float *)this + 102) != a3)
      {
        *((float *)this + 102) = a3;
        return 1;
      }
      return 0;
    }
    if (*((float *)this + 103) != a3)
    {
      *((float *)this + 103) = a3;
      v9 = *((float *)this + 104);
      goto LABEL_19;
    }
    v9 = *((float *)this + 104);
    if (v9 != a4)
    {
LABEL_19:
      if (v9 != a4)
      {
        *((float *)this + 104) = a4;
        return 1;
      }
      return 1;
    }
  }
  return 0;
}

uint64_t HGComicGaussianBlurAndGradientGeneration::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
    return 0;
  else
    return a4;
}

uint64_t HGComicGaussianBlurAndGradientGeneration::GetROI(HGComicGaussianBlurAndGradientGeneration *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  HGRect v12;
  HGRect v13;
  HGRect v14;

  if (a3)
  {
    v13 = (HGRect)HGRectNull;
    return HGRectNull;
  }
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  a4.var2 = vcvtps_s32_f32(*((float *)this + 102) + *((float *)this + 102));
  if (*((float *)this + 103) == 1.0)
  {
    v7 = -a4.var2;
    v8 = 0;
    a4.var0 = a4.var2;
    a4.var2 = 0;
LABEL_7:
    HGRect::Init(&v12, v7, v8, a4.var0, a4.var2);
    goto LABEL_8;
  }
  if (*((float *)this + 104) == 1.0)
  {
    v8 = -a4.var2;
    v7 = 0;
    a4.var0 = 0;
    goto LABEL_7;
  }
LABEL_8:
  *(_QWORD *)&v13.var0 = v6;
  *(_QWORD *)&v13.var2 = v5;
  HGRect::Grow(&v13, v12);
  v9 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  v11 = v10;
  *(_QWORD *)&v14.var0 = v9;
  *(_QWORD *)&v14.var2 = v11;
  HGRect::Grow(&v13, v14);
  return *(_QWORD *)&v13.var0;
}

uint64_t HGComicGaussianBlurAndGradientGeneration::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicGaussianBlurAndGradientGeneration::RenderTile(HGComicGaussianBlurAndGradientGeneration *this, HGTile *a2)
{
  float v4;
  uint64_t v6;
  int v7;
  int32x2_t v8;
  uint64_t v9;
  int v10;
  int v11;
  float32x4_t v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  float v26;
  __float2 v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  int8x16_t v35;
  uint64_t v36;
  uint64_t v37;
  float32x4_t v38;
  int32x4_t v39;
  float32x2_t v40;
  float32x4_t *v41;
  float32x4_t v42;
  float32x4_t v43;
  float v44;
  float32x4_t v45;
  uint64_t v46;
  float v47;
  float v48;
  float32x4_t v49;
  unint64_t v50;
  int32x2_t v51;
  float32x4_t v52;
  int32x4_t v53;
  float32x4_t *v54;
  float32x4_t v55;
  int32x4_t v56;
  float32x4_t v57;
  float32x2_t v58;
  float32x4_t v59;
  float32x4_t *v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int32x4_t v64;
  float v65;
  float v66;
  unint64_t v67;
  int32x2_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int32x4_t v71;
  __int32 v72;
  __int32 v73;
  float32x4_t v74;
  int32x4_t v75;
  float32x4_t v76;
  int v77;
  float32x4_t v78;
  int v79;
  float32x4_t v80;
  int8x16_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;

  v4 = *((float *)this + 104);
  if (*((float *)this + 103) == 1.0)
  {
    if (v4 == 1.0)
      return 0xFFFFFFFFLL;
  }
  else if (v4 != 1.0)
  {
    return 0xFFFFFFFFLL;
  }
  v6 = HGTile::Renderer(a2);
  v7 = (*(uint64_t (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t))(*(_QWORD *)this + 312))(this, v6);
  v8 = *(int32x2_t *)a2;
  v77 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v77 >= 1)
  {
    v9 = (*((_DWORD *)a2 + 2) - v8.i32[0]);
    if ((int)v9 >= 1)
    {
      v10 = v7;
      v11 = 0;
      *(float32x2_t *)v12.f32 = vadd_f32(vcvt_f32_s32(v8), (float32x2_t)0x3F0000003F000000);
      v12.i64[1] = 0x3F80000000000000;
      v13 = *((float *)this + 102);
      v14 = v13 + v13;
      v15 = 1.0 / (float)(v13 * (float)(v13 + v13));
      v16 = *((_QWORD *)a2 + 2);
      v17.i32[0] = 1.0;
      __asm { FMOV            V0.4S, #1.0 }
      v80 = _Q0;
      v23 = v12;
      v82 = v12;
      do
      {
        v79 = v11;
        v24 = 0;
        v78 = v23;
        v25 = v23;
        do
        {
          v36 = *((_QWORD *)a2 + 10);
          v37 = *((int *)a2 + 22);
          v38 = vsubq_f32(v25, v12);
          v83 = v25;
          if (v10)
          {
            v39 = vaddq_s32(vcvtq_s32_f32(v38), vcltzq_f32(v38));
            v40 = (float32x2_t)vsubq_f32(v38, vcvtq_f32_s32(v39)).u64[0];
            v41 = (float32x4_t *)(v36 + 16 * (v39.i32[0] + v39.i32[1] * (int)v37));
            v42 = vaddq_f32(*v41, vmulq_n_f32(vsubq_f32(v41[1], *v41), v40.f32[0]));
            v43 = vaddq_f32(v42, vmulq_lane_f32(vsubq_f32(vaddq_f32(v41[v37], vmulq_n_f32(vsubq_f32(v41[(int)v37 + 1], v41[v37]), v40.f32[0])), v42), v40, 1));
            v44 = *((float *)this + 104);
            v45.i64[0] = 0x3F0000003F000000;
            v45.i64[1] = 0x3F0000003F000000;
            v81 = (int8x16_t)v43;
            if (v14 >= v17.f32[0])
            {
              v46 = (int)v37 + 1;
              v47 = *((float *)this + 103);
              v48 = 1.0;
              v49 = v43;
              do
              {
                v86 = v49;
                v89 = v45;
                *(float *)&v50 = v48 * v47;
                *((float *)&v50 + 1) = v48 * v44;
                v84 = (float32x4_t)v50;
                *(float *)v51.i32 = expf(v15 * (float)-(float)(v48 * v48));
                v25 = v83;
                v45 = vaddq_f32(v89, (float32x4_t)vdupq_lane_s32(v51, 0));
                v52 = vsubq_f32(vaddq_f32(v83, v84), v82);
                v53 = vaddq_s32(vcvtq_s32_f32(v52), vcltzq_f32(v52));
                v52.i64[0] = vsubq_f32(v52, vcvtq_f32_s32(v53)).u64[0];
                v54 = (float32x4_t *)(v36 + 16 * (v53.i32[0] + v53.i32[1] * (int)v37));
                v55 = vsubq_f32(vsubq_f32(v83, v84), v82);
                v56 = vaddq_s32(vcvtq_s32_f32(v55), vcltzq_f32(v55));
                v57 = vaddq_f32(*v54, vmulq_n_f32(vsubq_f32(v54[1], *v54), v52.f32[0]));
                v58 = (float32x2_t)vsubq_f32(v55, vcvtq_f32_s32(v56)).u64[0];
                v59 = vaddq_f32(v54[v37], vmulq_n_f32(vsubq_f32(v54[v46], v54[v37]), v52.f32[0]));
                v60 = (float32x4_t *)(v36 + 16 * (v56.i32[0] + v56.i32[1] * (int)v37));
                v17 = vaddq_f32(*v60, vmulq_n_f32(vsubq_f32(v60[1], *v60), v58.f32[0]));
                v61 = vaddq_f32(v57, vmulq_lane_f32(vsubq_f32(v59, v57), *(float32x2_t *)v52.f32, 1));
                v62 = vaddq_f32(v17, vmulq_lane_f32(vsubq_f32(vaddq_f32(v60[v37], vmulq_n_f32(vsubq_f32(v60[v46], v60[v37]), v58.f32[0])), v17), v58, 1));
                v17.i32[0] = 1.0;
                v48 = v48 + 1.0;
                v49 = vaddq_f32(v86, vmulq_n_f32(vaddq_f32(v61, v62), *(float *)v51.i32));
              }
              while (v48 <= v14);
              goto LABEL_21;
            }
          }
          else
          {
            v45.i64[0] = 0x3F0000003F000000;
            v45.i64[1] = 0x3F0000003F000000;
            v63 = vaddq_f32(v38, v45);
            v64 = vcvtq_s32_f32(v63);
            v63.i64[0] = vaddq_s32(v64, vcgtq_f32(vcvtq_f32_s32(v64), v63)).u64[0];
            v43 = *(float32x4_t *)(v36 + 16 * (v63.i32[0] + v63.i32[1] * (int)v37));
            v44 = *((float *)this + 104);
            v81 = (int8x16_t)v43;
            if (v14 >= v17.f32[0])
            {
              v65 = *((float *)this + 103);
              v66 = 1.0;
              v49 = v43;
              do
              {
                v87 = v49;
                v90 = v45;
                *(float *)&v67 = v66 * v65;
                *((float *)&v67 + 1) = v66 * v44;
                v85 = (float32x4_t)v67;
                *(float *)v68.i32 = expf(v15 * (float)-(float)(v66 * v66));
                v25 = v83;
                v17.i32[0] = 1.0;
                v69.i64[0] = 0x3F0000003F000000;
                v69.i64[1] = 0x3F0000003F000000;
                v70 = vaddq_f32(vsubq_f32(vaddq_f32(v83, v85), v82), v69);
                v71 = vcvtq_s32_f32(v70);
                v70.i64[0] = vaddq_s32(v71, vcgtq_f32(vcvtq_f32_s32(v71), v70)).u64[0];
                v72 = v70.i32[1];
                v73 = v70.i32[0];
                v74 = vaddq_f32(vsubq_f32(vsubq_f32(v83, v85), v82), v69);
                v75 = vcvtq_s32_f32(v74);
                v74.i64[0] = vaddq_s32(v75, vcgtq_f32(vcvtq_f32_s32(v75), v74)).u64[0];
                v45 = vaddq_f32(v90, (float32x4_t)vdupq_lane_s32(v68, 0));
                v66 = v66 + 1.0;
                v49 = vaddq_f32(v87, vmulq_n_f32(vaddq_f32(*(float32x4_t *)(v36 + 16 * (v73 + v72 * (int)v37)), *(float32x4_t *)(v36 + 16 * (v74.i32[0] + v74.i32[1] * (int)v37))), *(float *)v68.i32));
              }
              while (v66 <= v14);
              goto LABEL_21;
            }
          }
          v49 = v43;
LABEL_21:
          v76.i64[0] = 0x3F0000003F000000;
          v76.i64[1] = 0x3F0000003F000000;
          v29 = vdivq_f32(vmulq_f32(v49, v76), v45);
          if (v44 == v17.f32[0])
          {
            v88 = (int8x16_t)v29;
            v26 = atan2f((float)((float)(v29.f32[2] + v29.f32[2]) + -1.0) * -2.0, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1), v29).f32[0]);
            v27 = __sincosf_stret((float)(v26 * 0.5) + 3.1416);
            v25 = v83;
            v17.i32[0] = 1.0;
            v28.i32[0] = *((_DWORD *)this + 105);
            v29.i32[0] = 0;
            v29.f32[1] = (float)(v27.__cosval + 1.0) * 0.5;
            v29.f32[2] = (float)(v27.__sinval + 1.0) * 0.5;
            v29.i32[3] = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vceqq_f32(v28, v17), 0), v81, v88).i32[3];
          }
          else if (*((float *)this + 105) == v17.f32[0])
          {
            v29.i32[3] = v81.i32[3];
          }
          v12 = v82;
          v30 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(v29, v80), (float32x4_t)0);
          v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.i8, 1);
          v29.i32[0] = 0;
          v32 = v30;
          v32.i32[1] = 0;
          v33 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v29, v31), (int8x16_t)vcgeq_f32(v31, v29))), 0), v32, v30);
          v34 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2);
          v35 = v33;
          v35.i32[2] = 0;
          *(int8x16_t *)(v16 + 16 * v24) = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v29, v34), (int8x16_t)vcgeq_f32(v34, v29))), 0), v35, v33);
          v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B304F230);
          ++v24;
        }
        while (v24 != v9);
        v23 = vaddq_f32(v78, (float32x4_t)xmmword_1B304F240);
        v16 += 16 * *((int *)a2 + 6);
        v11 = v79 + 1;
      }
      while (v79 + 1 != v77);
    }
  }
  return 0;
}

HGComicGaussianBlurAndGradientGeneration *HGComicGaussianBlurAndGradientGeneration::GetOutput(HGComicGaussianBlurAndGradientGeneration *this, HGRenderer *a2, char *a3)
{
  char *v4;
  char *v5;

  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), 0.0, 0.0, 0.0, a3);
  HGNode::SetParameter((HGNode *)this, 1, *((float *)this + 103), *((float *)this + 104), 0.0, 0.0, v4);
  HGNode::SetParameter((HGNode *)this, 2, *((float *)this + 105), 0.0, 0.0, 0.0, v5);
  return this;
}

const char *HGComicGaussianBlurAndGradientGeneration::GetProgram(HGComicGaussianBlurAndGradientGeneration *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) < 0x60B10)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
    {
      if (*((float *)this + 103) == 1.0)
        return "//GLfs1.0      \n"
               "//LEN=0000000632\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#define precision\n"
               "#endif\n"
               "\n"
               "precision highp float;\n"
               "precision highp int;\n"
               "\n"
               "\n"
               "uniform lowp sampler2DRect inputTexture;\n"
               "uniform mediump vec4 hg_ProgramLocal0;
               "uniform mediump vec4 hg_ProgramLocal1;
               "uniform mediump vec4 hg_ProgramLocal2;
               "\n"
               "void main()\n"
               "{\n"
               "    mediump float sigma = hg_ProgramLocal0.x;\n"
               "    mediump float alphaPassthrough = hg_ProgramLocal2.x;\n"
               "    mediump float sigma22 = 1.0 / (2.0 * sigma * sigma);\n"
               "    mediump float sigmax2 = 2.0 * sigma;\n"
               "\n"
               "    highp vec4 texel = texture2DRect(inputTexture, gl_TexCoord[0].xy);\n"
               "    highp vec4 acc = texel;\n"
               "    float norm = 0.5;\n"
               "\n"
               "    for (float i = 1.0; i <=  sigmax2; i++)\n"
               "    {\n"
               "        float coeff = exp(-i*i * sigma22);\n"
               "        \n"
               "        float uPos = gl_TexCoord[0].x + i;\n"
               "        float uNeg = gl_TexCoord[0].x - i;\n"
               "        float v = gl_TexCoord[0].y;\n"
               "     \n"
               "        norm += coeff;\n"
               "        acc += coeff * \n"
               "            (texture2DRect(inputTexture, vec2(uPos, v)) +\n"
               "               texture2DRect(inputTexture, vec2(uNeg, v)));\n"
               "    }\n"
               "    \n"
               "    highp vec4 result = acc * 0.5 / norm;\n"
               "    result.a = (texel.a * alphaPassthrough + result.a * (1.0 - alphaPassthrough));\n"
               "    \n"
               "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
               "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
               "    gl_FragColor = clamp(result, 0.0, 1.0);\n"
               "}\n"
               "//MD5=603686a0:96250beb:b6f38426:b3689fdb\n"
               "//SIG=00000000:00000000:00000000:00000000:0012:0003:0000:0000:0000:0000:0000:0000:0001:00:0:1:0\n";
      else
        return "//GLfs1.0      \n"
               "//LEN=0000000743\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#define precision\n"
               "#endif\n"
               "#define defaultp highp\n"
               "\n"
               "precision highp float;\n"
               "precision highp int;\n"
               "\n"
               "#define M_PI        3.14159265358979323846264338327950288\n"
               "\n"
               "uniform sampler2DRect inputTexture;\n"
               "uniform mediump vec4 hg_ProgramLocal0;
               "uniform mediump vec4 hg_ProgramLocal1;
               "uniform mediump vec4 hg_ProgramLocal2;
               "\n"
               "void main()\n"
               "{\n"
               "    mediump float sigma = hg_ProgramLocal0.x;\n"
               "    mediump float alphaPassthrough = hg_ProgramLocal2.x;\n"
               "    mediump float sigma22 = 1.0 / (2.0 * sigma * sigma);\n"
               "    mediump float sigmax2 = 2.0 * sigma;\n"
               "\n"
               "    vec4 texel = texture2DRect(inputTexture, gl_TexCoord[0].xy);\n"
               "    vec4 acc = texel;\n"
               "    float norm = 0.5;\n"
               "\n"
               "    for (float i = 1.0; i <= sigmax2; i++)\n"
               "    {\n"
               "        float coeff = exp(-i*i * sigma22);\n"
               "        \n"
               "        float u = gl_TexCoord[0].x;\n"
               "        float vPos = gl_TexCoord[0].y + i;\n"
               "        float vNeg = gl_TexCoord[0].y - i;\n"
               "     \n"
               "        norm += coeff;\n"
               "        acc += coeff * \n"
               "            (texture2DRect(inputTexture, vec2(u, vPos)) +\n"
               "               texture2DRect(inputTexture, vec2(u, vNeg)));\n"
               "    }\n"
               "    acc = acc * 0.5 / norm;\n"
               "    \n"
               "    // Generate gradients \n"
               "    float alfa = M_PI + 0.5 * atan(-2.0 * (acc.z * 2.0 - 1.0),  acc.y - acc.x);\n"
               "    \n"
               "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
               "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
               "    gl_FragColor = clamp(vec4(0.0,\n"
               "                              (cos(alfa) + 1.0) * 0.5,\n"
               "                              (sin(alfa) + 1.0) * 0.5,\n"
               "                              (alphaPassthrough == 1.0) ? texel.a : acc.a), 0.0, 1.0);\n"
               "}\n"
               "//MD5=92f7df43:09b533ad:ad6d6e66:e2b97b70\n"
               "//SIG=00000000:00000000:00000000:00000000:0026:0003:0000:0000:0000:0000:0000:0000:0001:00:0:1:0\n";
    }
    else
    {
      return 0;
    }
  }
  else if (*((float *)this + 103) == 1.0)
  {
    return "//Metal1.0     \n"
           "//LEN=00000005fd\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const BOOL alphaPassthrough {static_cast<BOOL>(hg_Params[2].x)};\n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    half4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    half4 acc = texel;\n"
           "    half norm {0.5h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i++)\n"
           "    {\n"
           "        const half coeff {exp(-i * i * sigma22)};\n"
           "        \n"
           "        const float uPos {frag._texCoord0.x + i};\n"
           "        const float uNeg {frag._texCoord0.x - i};\n"
           "        const float v {frag._texCoord0.y};\n"
           "     \n"
           "        norm += coeff;\n"
           "        acc += coeff * \n"
           "            (hg_Texture0.sample(hg_Sampler0, float2(uPos, v)) +\n"
           "             hg_Texture0.sample(hg_Sampler0, float2(uNeg, v)));\n"
           "    }\n"
           " \n"
           "    half4 result = acc * 0.5h / norm;\n"
           "    result.a = (alphaPassthrough ? texel.a : result.a);\n"
           "\n"
           "    FragmentOut out {static_cast<float4>(result)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=85a34481:c1c78204:e169c439:c39a6324\n"
           "//SIG=00000000:00000000:00000000:00000001:0008:0003:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else
  {
    return "//Metal1.0     \n"
           "//LEN=00000006fe\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const BOOL alphaPassthrough {static_cast<BOOL>(hg_Params[2].x)};\n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    const half4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "\n"
           "    half4 acc = texel;\n"
           "    half norm {0.5h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i++)\n"
           "    {\n"
           "        const half coeff {exp(-i * i * sigma22)};\n"
           "        \n"
           "        const float u {frag._texCoord0.x};\n"
           "        const float vPos {frag._texCoord0.y + i};\n"
           "        const float vNeg {frag._texCoord0.y - i};\n"
           "\n"
           "        norm += coeff;\n"
           "        acc += coeff * \n"
           "            (hg_Texture0.sample(hg_Sampler0, float2(u, vPos)) +\n"
           "             hg_Texture0.sample(hg_Sampler0, float2(u, vNeg)));\n"
           "    }\n"
           "    acc = acc * 0.5h / norm;\n"
           "\n"
           "    // Generate gradients \n"
           "    const half alfa {M_PI_H + 0.5h * atan2(-2.0h * (acc.z * 2.0h - 1.0h),  acc.y - acc.x)};\n"
           "    \n"
           "    FragmentOut out {float4(0.0h,\n"
           "                     (cos(alfa) + 1.0h) * 0.5h,\n"
           "                     (sin(alfa) + 1.0h) * 0.5h,\n"
           "                     alphaPassthrough ? texel.a : acc.a)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=d4a9c30f:71e94a09:7c9108eb:21ca2c59\n"
           "//SIG=00000000:00000000:00000000:00000001:0011:0003:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
}

uint64_t HGComicGaussianBlurAndGradientGeneration::BindTexture(HGComicGaussianBlurAndGradientGeneration *this, HGHandler *a2, uint64_t a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t *HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(uint64_t *a1, uint64_t a2, PCColorSpaceHandle *a3)
{
  PCColorSpaceHandle *v5;
  uint64_t v6;
  PC_Sp_counted_base *var0;
  uint64_t CGColorSpace;
  uint64_t v9;
  PCSharedCount *v10;
  PC_Sp_counted_base *v12;
  PC_Sp_counted_base *v13;
  PCSharedCount v14;

  *a1 = a2;
  v5 = (PCColorSpaceHandle *)(a1 + 1);
  HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)(a1 + 1), 0);
  *((_BYTE *)a1 + 16) = 0;
  v6 = *a1;
  if (*a1)
  {
    if (*(_BYTE *)(v6 + 40))
    {
      var0 = *(PC_Sp_counted_base **)(v6 + 32);
      v14.var0 = var0;
    }
    else
    {
      HGGLGetCurrentContext();
      var0 = v14.var0;
    }
    *(_QWORD *)v5 = var0;
    PCSharedCount::PCSharedCount(&v14);
  }
  if (!PCColorSpaceHandle::getCGColorSpace(v5))
  {
    HGGLGetCurrentContext();
    *(PCSharedCount *)v5 = v14;
    PCSharedCount::PCSharedCount(&v14);
  }
  CGColorSpace = PCColorSpaceHandle::getCGColorSpace(v5);
  if (CGColorSpace != PCColorSpaceHandle::getCGColorSpace(a3))
  {
    v9 = *a1;
    if (*a1)
    {
      v13 = *(PC_Sp_counted_base **)a3;
      v10 = (PCSharedCount *)&v13;
      HGGLState::setCurrentContext(v9, &v13);
    }
    else
    {
      v12 = *(PC_Sp_counted_base **)a3;
      v10 = (PCSharedCount *)&v12;
      HGGLSetCurrentContext(&v12);
    }
    PCSharedCount::PCSharedCount(v10);
    *((_BYTE *)a1 + 16) = 1;
  }
  return a1;
}

void sub_1B29DFD28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount *v10;

  PCSharedCount::PCSharedCount(&a10);
  PCSharedCount::PCSharedCount(v10);
  _Unwind_Resume(a1);
}

void sub_1B29DFD44(_Unwind_Exception *a1)
{
  PCSharedCount *v1;

  PCSharedCount::PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DFD58(_Unwind_Exception *a1)
{
  PCSharedCount *v1;

  PCSharedCount::PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void sub_1B29DFD6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11)
{
  PCSharedCount *v11;

  PCSharedCount::PCSharedCount(&a11);
  PCSharedCount::PCSharedCount(v11);
  _Unwind_Resume(a1);
}

void sub_1B29DFD88(_Unwind_Exception *a1)
{
  PCSharedCount *v1;

  PCSharedCount::PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void HGGLState::setCurrentContext(uint64_t a1, PC_Sp_counted_base **a2)
{
  PC_Sp_counted_base **v3;
  uint64_t CGColorSpace;
  PCSharedCount v5;
  PCSharedCount v6;

  if (*(_BYTE *)(a1 + 40))
  {
    v3 = (PC_Sp_counted_base **)(a1 + 32);
    CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(a1 + 32));
    if (CGColorSpace != PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)a2))
    {
      v6.var0 = *a2;
      HGGLSetCurrentContext(&v6.var0);
      PCSharedCount::PCSharedCount(&v6);
      *v3 = *a2;
    }
  }
  else
  {
    v5.var0 = *a2;
    HGGLSetCurrentContext(&v5.var0);
    PCSharedCount::PCSharedCount(&v5);
  }
}

void sub_1B29DFE3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
  PCSharedCount::PCSharedCount(&a9);
  _Unwind_Resume(a1);
}

void sub_1B29DFE50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(PCSharedCount *this)
{
  uint64_t var0;
  PCSharedCount v3;

  if (LOBYTE(this[2].var0))
  {
    var0 = (uint64_t)this->var0;
    if (this->var0)
    {
      v3.var0 = this[1].var0;
      HGGLState::setCurrentContext(var0, &v3.var0);
    }
    else
    {
      v3.var0 = this[1].var0;
      HGGLSetCurrentContext(&v3.var0);
    }
    PCSharedCount::PCSharedCount(&v3);
  }
  PCSharedCount::PCSharedCount(this + 1);
}

void HGGLState::HGGLState(HGGLState *this)
{
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = (char *)this + 8;
  HGGLContextPtr::HGGLContextPtr((HGGLState *)((char *)this + 24), 0);
  HGGLContextPtr::HGGLContextPtr((HGGLState *)((char *)this + 32), 0);
  *((_BYTE *)this + 40) = 0;
  HGLogger::setLevel((HGLogger *)"glstate", (const char *)1);
}

void sub_1B29DFF44(_Unwind_Exception *a1)
{
  uint64_t v1;
  PCSharedCount *v2;
  PCSharedCount *v3;
  PCSharedCount *v4;

  v4 = v3;
  PCSharedCount::PCSharedCount(v4);
  PCSharedCount::PCSharedCount(v2);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1B29DFF78(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

void HGGLState::resetUniforms(HGGLState **this)
{
  HGGLState **v2;
  HGGLState *v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  HGGLState *v7;
  HGGLState **v8;
  BOOL v9;

  v2 = this + 1;
  v3 = *this;
  if (*this != (HGGLState *)(this + 1))
  {
    do
    {
      v4 = (_QWORD *)*((_QWORD *)v3 + 5);
      if (v4)
      {
        v5 = (void *)v4[4];
        if (v5)
        {
          v4[5] = v5;
          operator delete(v5);
        }
        v6 = (void *)v4[1];
        if (v6)
        {
          v4[2] = v6;
          operator delete(v6);
        }
        MEMORY[0x1B5E29170](v4, 0x1010C40738DD8B8);
      }
      v7 = (HGGLState *)*((_QWORD *)v3 + 1);
      if (v7)
      {
        do
        {
          v8 = (HGGLState **)v7;
          v7 = *(HGGLState **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (HGGLState **)*((_QWORD *)v3 + 2);
          v9 = *v8 == v3;
          v3 = (HGGLState *)v8;
        }
        while (!v9);
      }
      v3 = (HGGLState *)v8;
    }
    while (v8 != v2);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this, this[1]);
  this[1] = 0;
  this[2] = 0;
  *this = (HGGLState *)v2;
}

void HGGLState::~HGGLState(HGGLState *this)
{
  HGGLState::resetUniforms((HGGLState **)this);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 4);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this, *((_QWORD **)this + 1));
}

void HGGLState::startContextTracking(HGGLState *this)
{
  PCSharedCount v2;

  if (!*((_BYTE *)this + 40))
  {
    *((_BYTE *)this + 40) = 1;
    HGGLGetCurrentContext();
    *((PCSharedCount *)this + 4) = v2;
    PCSharedCount::PCSharedCount(&v2);
    *((_QWORD *)this + 3) = *((_QWORD *)this + 4);
  }
}

void HGGLState::stopContextTracking(PCSharedCount *this)
{
  PCSharedCount v2;
  PCSharedCount v3;

  if (LOBYTE(this[5].var0))
  {
    v3.var0 = this[3].var0;
    HGGLState::setCurrentContext((uint64_t)this, &v3.var0);
    PCSharedCount::PCSharedCount(&v3);
    LOBYTE(this[5].var0) = 0;
    HGGLContextPtr::HGGLContextPtr((HGGLContextPtr *)&v2, 0);
    this[4].var0 = v2.var0;
    PCSharedCount::PCSharedCount(&v2);
    this[3].var0 = this[4].var0;
  }
}

void sub_1B29E0164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

uint64_t HGGLState::getUniformLocation(uint64_t **a1, unint64_t a2, int a3, int a4)
{
  GLuint v4;
  uint64_t *UniformLocations;
  uint64_t result;

  v4 = a2;
  if (a3 == 2)
    return HGGLState::_getProgramLocalLocation(a1, a2, a4);
  if (a3 == 1)
    return HGGLState::_getTextureMatrixLocation(a1, a2, a4);
  if (a3)
    return 0xFFFFFFFFLL;
  UniformLocations = HGGLState::_getUniformLocations(a1, a2);
  result = *(unsigned int *)UniformLocations;
  if ((_DWORD)result == -2)
  {
    result = glGetUniformLocation(v4, "hg_ProjectionMatrix");
    *(_DWORD *)UniformLocations = result;
  }
  return result;
}

uint64_t HGGLState::_getTextureMatrixLocation(uint64_t **this, unint64_t a2, int a3)
{
  GLuint v4;
  uint64_t *UniformLocations;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t result;
  int v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  char *v25;
  int UniformLocation;
  uint64_t v27;
  __int128 v28;
  __int16 v29;
  char v30;
  char v31;
  uint64_t v32;

  v4 = a2;
  v32 = *MEMORY[0x1E0C80C00];
  UniformLocations = HGGLState::_getUniformLocations(this, a2);
  v6 = a3;
  v8 = UniformLocations + 1;
  v7 = UniformLocations[1];
  v9 = (UniformLocations[2] - v7) >> 2;
  if (v9 <= a3)
  {
    v10 = (a3 + 1);
    if (v10 <= v9)
    {
      if (v10 < v9)
        UniformLocations[2] = v7 + 4 * v10;
    }
    else
    {
      std::vector<int>::__append((std::vector<int> *)(UniformLocations + 1), v10 - v9, &UNKNOWN_LOC);
      v7 = *v8;
    }
  }
  result = *(unsigned int *)(v7 + 4 * a3);
  if ((_DWORD)result == -2)
  {
    v29 = 0;
    v28 = *(_OWORD *)"hg_TextureMatrix";
    v12 = a3 > 999;
    if (a3 > 9999)
      ++v12;
    if (a3 > 99)
      ++v12;
    if (a3 <= 9)
      v13 = 0;
    else
      v13 = -1;
    if (v12 == v13)
    {
      v14 = 16;
    }
    else
    {
      if (a3 <= 9999)
        v15 = a3 > 999;
      else
        v15 = (a3 > 999) + 1;
      if (a3 > 99)
        ++v15;
      if (a3 > 9)
        ++v15;
      v16 = format(char *,int,int)::div[v15];
      v17 = a3 / v16;
      a3 %= v16;
      LOBYTE(v29) = v17 + 48;
      v18 = v15 - 2;
      if (v15 < 2)
      {
        v14 = 17;
      }
      else
      {
        v19 = format(char *,int,int)::div[v15 - 1];
        v20 = a3 / v19;
        a3 %= v19;
        HIBYTE(v29) = v20 + 48;
        if (v15 - 1 < 2)
        {
          v14 = 18;
        }
        else
        {
          v21 = format(char *,int,int)::div[v18];
          v22 = a3 / v21;
          a3 %= v21;
          v30 = v22 + 48;
          if (v18 < 2)
          {
            v14 = 19;
          }
          else
          {
            v23 = format(char *,int,int)::div[v15 - 3];
            v24 = a3 / v23;
            a3 %= v23;
            v31 = v24 + 48;
            v14 = 20;
          }
        }
      }
    }
    v25 = (char *)&v28 + v14;
    *v25 = a3 + 48;
    v25[1] = 0;
    UniformLocation = glGetUniformLocation(v4, (const GLchar *)&v28);
    v27 = *v8;
    *(_DWORD *)(v27 + 4 * v6) = UniformLocation;
    return *(unsigned int *)(v27 + 4 * v6);
  }
  return result;
}

uint64_t HGGLState::_getProgramLocalLocation(uint64_t **this, unint64_t a2, int a3)
{
  GLuint v4;
  uint64_t *UniformLocations;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t result;
  int v12;
  int v13;
  int v14;
  unint64_t v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  _BYTE *v25;
  int UniformLocation;
  uint64_t v27;
  _BYTE v28[21];
  uint64_t v29;

  v4 = a2;
  v29 = *MEMORY[0x1E0C80C00];
  UniformLocations = HGGLState::_getUniformLocations(this, a2);
  v6 = a3;
  v8 = UniformLocations + 4;
  v7 = UniformLocations[4];
  v9 = (UniformLocations[5] - v7) >> 2;
  if (v9 <= a3)
  {
    v10 = (a3 + 1);
    if (v10 <= v9)
    {
      if (v10 < v9)
        UniformLocations[5] = v7 + 4 * v10;
    }
    else
    {
      std::vector<int>::__append((std::vector<int> *)(UniformLocations + 4), v10 - v9, &UNKNOWN_LOC);
      v7 = *v8;
    }
  }
  result = *(unsigned int *)(v7 + 4 * a3);
  if ((_DWORD)result == -2)
  {
    strcpy(v28, "hg_ProgramLocal");
    *(_QWORD *)&v28[13] = 27745;
    v12 = a3 > 999;
    if (a3 > 9999)
      ++v12;
    if (a3 > 99)
      ++v12;
    if (a3 <= 9)
      v13 = 0;
    else
      v13 = -1;
    if (v12 == v13)
    {
      v14 = 15;
    }
    else
    {
      if (a3 <= 9999)
        v15 = a3 > 999;
      else
        v15 = (a3 > 999) + 1;
      if (a3 > 99)
        ++v15;
      if (a3 > 9)
        ++v15;
      v16 = format(char *,int,int)::div[v15];
      v17 = a3 / v16;
      a3 %= v16;
      v28[15] = v17 + 48;
      v18 = v15 - 2;
      if (v15 < 2)
      {
        v14 = 16;
      }
      else
      {
        v19 = format(char *,int,int)::div[v15 - 1];
        v20 = a3 / v19;
        a3 %= v19;
        v28[16] = v20 + 48;
        if (v15 - 1 < 2)
        {
          v14 = 17;
        }
        else
        {
          v21 = format(char *,int,int)::div[v18];
          v22 = a3 / v21;
          a3 %= v21;
          v28[17] = v22 + 48;
          if (v18 < 2)
          {
            v14 = 18;
          }
          else
          {
            v23 = format(char *,int,int)::div[v15 - 3];
            v24 = a3 / v23;
            a3 %= v23;
            v28[18] = v24 + 48;
            v14 = 19;
          }
        }
      }
    }
    v25 = &v28[v14];
    *v25 = a3 + 48;
    v25[1] = 0;
    UniformLocation = glGetUniformLocation(v4, v28);
    v27 = *v8;
    *(_DWORD *)(v27 + 4 * v6) = UniformLocation;
    return *(unsigned int *)(v27 + 4 * v6);
  }
  return result;
}

uint64_t *HGGLState::_getUniformLocations(uint64_t **this, unint64_t a2)
{
  uint64_t *v4;
  uint64_t **v5;
  uint64_t **v6;
  uint64_t *v7;
  unint64_t v8;
  BOOL v9;
  uint64_t **v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t **v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t **v19;
  unint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t *v23;

  v5 = this + 1;
  v4 = this[1];
  if (!v4)
    goto LABEL_12;
  v6 = this + 1;
  v7 = this[1];
  do
  {
    v8 = v7[4];
    v9 = v8 >= a2;
    if (v8 >= a2)
      v10 = (uint64_t **)v7;
    else
      v10 = (uint64_t **)(v7 + 1);
    if (v9)
      v6 = (uint64_t **)v7;
    v7 = *v10;
  }
  while (*v10);
  if (v6 != v5 && (unint64_t)v6[4] <= a2)
  {
    while (1)
    {
LABEL_25:
      while (1)
      {
        v19 = (uint64_t **)v4;
        v20 = v4[4];
        if (v20 <= a2)
          break;
        v4 = *v19;
        v5 = v19;
        if (!*v19)
          goto LABEL_29;
      }
      if (v20 >= a2)
        break;
      v4 = v19[1];
      if (!v4)
      {
        v5 = v19 + 1;
        goto LABEL_29;
      }
    }
  }
  else
  {
LABEL_12:
    v11 = operator new();
    *(_DWORD *)v11 = -2;
    *(_OWORD *)(v11 + 8) = 0u;
    *(_OWORD *)(v11 + 24) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    v12 = *v5;
    v13 = v5;
    v14 = v5;
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          v14 = (uint64_t **)v12;
          v15 = v12[4];
          if (v15 <= a2)
            break;
          v12 = *v14;
          v13 = v14;
          if (!*v14)
            goto LABEL_19;
        }
        if (v15 >= a2)
          break;
        v12 = v14[1];
        if (!v12)
        {
          v13 = v14 + 1;
          goto LABEL_19;
        }
      }
    }
    else
    {
LABEL_19:
      v16 = (uint64_t *)v14;
      v14 = (uint64_t **)operator new(0x30uLL);
      v14[4] = (uint64_t *)a2;
      v14[5] = 0;
      *v14 = 0;
      v14[1] = 0;
      v14[2] = v16;
      *v13 = (uint64_t *)v14;
      v17 = (uint64_t *)**this;
      v18 = (uint64_t *)v14;
      if (v17)
      {
        *this = v17;
        v18 = *v13;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(this[1], v18);
      this[2] = (uint64_t *)((char *)this[2] + 1);
    }
    v14[5] = (uint64_t *)v11;
    v4 = *v5;
    v19 = v5;
    if (*v5)
      goto LABEL_25;
LABEL_29:
    v21 = (uint64_t *)v19;
    v19 = (uint64_t **)operator new(0x30uLL);
    v19[4] = (uint64_t *)a2;
    v19[5] = 0;
    *v19 = 0;
    v19[1] = 0;
    v19[2] = v21;
    *v5 = (uint64_t *)v19;
    v22 = (uint64_t *)**this;
    v23 = (uint64_t *)v19;
    if (v22)
    {
      *this = v22;
      v23 = *v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(this[1], v23);
    this[2] = (uint64_t *)((char *)this[2] + 1);
  }
  return v19[5];
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  int *value;
  std::vector<int>::pointer end;
  int *v8;
  std::vector<int>::pointer begin;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  std::vector<int>::size_type v16;
  std::vector<int>::size_type v17;
  float32x4_t v18;
  float32x4_t *v19;
  uint64_t v20;
  int *v21;
  int *v22;
  std::vector<int>::size_type v23;
  int *v24;
  std::vector<int>::size_type v25;
  float32x4_t v26;
  float32x4_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD *v32;
  __int128 *v33;
  uint64_t v34;
  __int128 v35;
  int v36;

  end = this->__end_;
  value = this->__end_cap_.__value_;
  v8 = end;
  if (__n <= value - end)
  {
    if (__n)
    {
      v16 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 < 0xF || end < __x + 1 && &end[__n] > __x)
        goto LABEL_43;
      v17 = v16 + 1;
      v8 = &end[v17 & 0x7FFFFFFFFFFFFFF8];
      v18 = vld1q_dup_f32((const float *)__x);
      v19 = (float32x4_t *)(end + 4);
      v20 = v17 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v19[-1] = v18;
        *v19 = v18;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_43:
        do
          *v8++ = *__x;
        while (v8 != &end[__n]);
      }
      v8 = &end[__n];
    }
    this->__end_ = v8;
  }
  else
  {
    begin = this->__begin_;
    v10 = (char *)end - (char *)this->__begin_;
    v11 = v10 >> 2;
    v12 = (v10 >> 2) + __n;
    if (v12 >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v13 = (char *)value - (char *)begin;
    if (v13 >> 1 > v12)
      v12 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    if (v14)
    {
      if (v14 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v15 = operator new(4 * v14);
    }
    else
    {
      v15 = 0;
    }
    v21 = (int *)&v15[4 * v11];
    v22 = &v21[__n];
    v23 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
    v24 = v21;
    if (v23 < 0x13)
      goto LABEL_44;
    if (v21 < __x + 1)
    {
      v24 = (int *)&v15[4 * v11];
      if (&v15[4 * __n + v10] > (_BYTE *)__x)
        goto LABEL_44;
    }
    v25 = v23 + 1;
    v24 = &v21[v25 & 0x7FFFFFFFFFFFFFF8];
    v26 = vld1q_dup_f32((const float *)__x);
    v27 = (float32x4_t *)&v15[4 * v11 + 16];
    v28 = v25 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v27[-1] = v26;
      *v27 = v26;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    if (v25 != (v25 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_44:
      do
        *v24++ = *__x;
      while (v24 != v22);
    }
    if (end != begin)
    {
      v29 = (char *)end - (char *)begin - 4;
      if (v29 < 0x2C)
        goto LABEL_45;
      if ((unint64_t)((char *)end - &v15[v10]) < 0x20)
        goto LABEL_45;
      v30 = (v29 >> 2) + 1;
      v31 = 4 * (v30 & 0x7FFFFFFFFFFFFFF8);
      v8 = &end[v31 / 0xFFFFFFFFFFFFFFFCLL];
      v21 = (int *)((char *)v21 - v31);
      v32 = &v15[4 * v11 - 16];
      v33 = (__int128 *)(end - 4);
      v34 = v30 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v35 = *v33;
        *(v32 - 1) = *(v33 - 1);
        *v32 = v35;
        v32 -= 2;
        v33 -= 2;
        v34 -= 8;
      }
      while (v34);
      if (v30 != (v30 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_45:
        do
        {
          v36 = *--v8;
          *--v21 = v36;
        }
        while (v8 != begin);
      }
    }
    this->__begin_ = v21;
    this->__end_ = v22;
    this->__end_cap_.__value_ = (int *)&v15[4 * v14];
    if (begin)
      operator delete(begin);
  }
}

FILE *HGIQA::IQAWriteFile(const char *a1, __int128 *a2, char *a3)
{
  FILE *result;
  __int128 v6;
  FILE *v7;
  int v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 __ptr;
  _BYTE v16[28];

  result = fopen(a1, "w");
  v6 = a2[1];
  __ptr = *a2;
  *(_OWORD *)v16 = v6;
  *(_OWORD *)&v16[12] = *(__int128 *)((char *)a2 + 28);
  if (result)
  {
    v7 = result;
    LOBYTE(__ptr) = __ptr | 0x80;
    if (fwrite(&__ptr, 1uLL, 1uLL, result) != 1
      || fwrite((char *)&__ptr + 4, 4uLL, 1uLL, v7) != 1
      || fwrite((char *)&__ptr + 8, 4uLL, 1uLL, v7) != 1)
    {
      goto LABEL_30;
    }
    if ((*(_DWORD *)&v16[8] - 31) > 1)
    {
      if ((*(_DWORD *)&v16[8] - 19) >= 2)
      {
        *(_DWORD *)&v16[20] = 0;
        *(_DWORD *)&v16[24] = 0;
      }
    }
    else
    {
      if (HIDWORD(__ptr) != 1)
      {
        *(_DWORD *)&v16[20] = HIDWORD(__ptr);
        HIDWORD(__ptr) = 1;
      }
      if (*(_DWORD *)v16 != 1)
      {
        *(_DWORD *)&v16[24] = *(_DWORD *)v16;
        *(_DWORD *)v16 = 1;
      }
    }
    if (fwrite((const void *)((unint64_t)&__ptr | 0xC), 4uLL, 1uLL, v7) != 1 || fwrite(v16, 4uLL, 1uLL, v7) != 1)
      goto LABEL_30;
    v13 = 0;
    v14 = 0;
    v8 = *(_DWORD *)&v16[8];
    HGIQA::GetPixelInfo(*(int *)&v16[8], &v14, &v13, 0, 0);
    v9 = *(int *)&v16[4];
    v10 = v8 == 24 ? vcvts_n_u32_f32(ceilf((float)SHIDWORD(__ptr) / 6.0), 4uLL) : v14 * SHIDWORD(__ptr) * v13;
    if (v10 < *(int *)&v16[4])
      *(_DWORD *)&v16[4] = v10;
    if (fwrite(&v16[4], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[8], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[12], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[16], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[20], 4uLL, 1uLL, v7) != 1
      || fwrite(&v16[24], 4uLL, 1uLL, v7) != 1)
    {
      goto LABEL_30;
    }
    if ((*(_DWORD *)&v16[8] - 31) > 1)
    {
      HGIQA::GetPixelInfo(*(int *)&v16[8], &v14, &v13, 0, 0);
      if (v10 != v9)
      {
        if (*(int *)v16 >= 1)
        {
          v12 = 0;
          while (fwrite(a3, v10, 1uLL, v7) == 1)
          {
            ++v12;
            a3 += v9;
            if (v12 >= *(int *)v16)
              goto LABEL_36;
          }
          goto LABEL_30;
        }
        goto LABEL_36;
      }
      v11 = *(int *)v16 * (uint64_t)*(int *)&v16[4];
    }
    else
    {
      v11 = ((uint64_t)*(int *)&v16[4] << (*(_DWORD *)&v16[12] != 0))
          + ((uint64_t)*(int *)&v16[4] << (*(_DWORD *)&v16[12] != 0)) * (SDWORD2(__ptr) - (uint64_t)SDWORD1(__ptr));
    }
    if (fwrite(a3, v11, 1uLL, v7) != 1)
    {
LABEL_30:
      fclose(v7);
      return 0;
    }
LABEL_36:
    fclose(v7);
    return (FILE *)1;
  }
  return result;
}

const char *HGIQA::GetPixelInfo(int a1, _QWORD *a2, _QWORD *a3, int *a4, int *a5)
{
  const char *result;
  int v6;
  int v7;

  switch(a1)
  {
    case 0:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 22;
      result = "r408";
      if (a5)
      {
        v6 = 4;
        goto LABEL_313;
      }
      return result;
    case 1:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 14;
      result = "2vuy_cby0cry1";
      if (a5)
        goto LABEL_233;
      return result;
    case 2:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 29;
      result = "r4fl";
      if (a5)
      {
        v6 = 7;
        goto LABEL_313;
      }
      return result;
    case 3:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 22;
      result = "ARGB 8 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 4:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 26;
      result = "ARGB 16 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 5:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 29;
      result = "ARGB 32 bit float";
      if (a5)
        goto LABEL_312;
      return result;
    case 6:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 0;
      result = "ABGR 8 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 7:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 0;
      result = "ABGR 16 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 8:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 0;
      result = "ABGR 32 bit float";
      if (a5)
        goto LABEL_312;
      return result;
    case 9:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 24;
      result = "RGBA 8 bit float";
      if (a5)
        goto LABEL_312;
      return result;
    case 10:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 27;
      result = "RGBA 16 bit float";
      if (a5)
        goto LABEL_312;
      return result;
    case 11:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 1;
      if (a4)
        *a4 = 1;
      result = "A 8 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 12:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 1;
      if (a4)
        *a4 = 3;
      result = "A 16 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 13:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 1;
      if (a4)
        *a4 = 7;
      result = "A 32 bit float";
      if (a5)
        goto LABEL_312;
      return result;
    case 14:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 10;
      result = "AL 8 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 15:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 11;
      result = "AL 16 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 16:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 13;
      result = "AL 32 bit float";
      if (a5)
        goto LABEL_312;
      return result;
    case 18:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 12;
      result = "AL half float";
      if (a5)
        goto LABEL_312;
      return result;
    case 19:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 13;
      result = "Optical Flow Progressive";
      if (a5)
        goto LABEL_312;
      return result;
    case 20:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 28;
      result = "Optical Flow Interlaced";
      if (a5)
        goto LABEL_312;
      return result;
    case 21:
      if (a2)
        *a2 = 8;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 0;
      result = "LABC";
      if (a5)
        goto LABEL_312;
      return result;
    case 22:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 22;
      result = "y408";
      if (a5)
      {
        v6 = 5;
        goto LABEL_313;
      }
      return result;
    case 23:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 26;
      result = "y416";
      if (a5)
      {
        v6 = 6;
        goto LABEL_313;
      }
      return result;
    case 24:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 31;
      result = "v210";
      if (a5)
      {
        v6 = 2;
        goto LABEL_313;
      }
      return result;
    case 25:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 16;
      result = "v216";
      if (a5)
      {
        v6 = 3;
        goto LABEL_313;
      }
      return result;
    case 26:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 32;
      result = "r10k";
      if (a5)
        goto LABEL_312;
      return result;
    case 27:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 33;
      result = "b64a";
      if (a5)
        goto LABEL_312;
      return result;
    case 28:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 2;
      if (a4)
        *a4 = 15;
      result = "2vuy_y0cby1cr";
      if (a5)
      {
LABEL_233:
        v6 = 1;
        goto LABEL_313;
      }
      return result;
    case 29:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 23;
      result = "BGRA 8 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 30:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 29;
      result = "AYCbCr float";
      if (a5)
        goto LABEL_312;
      return result;
    case 31:
      if (a2)
        *a2 = 8;
      if (a3)
        *a3 = 13;
      if (a4)
        *a4 = 0;
      result = "DominantMotionTracker Original Motion Data";
      if (a5)
        goto LABEL_312;
      return result;
    case 32:
      if (a2)
        *a2 = 8;
      if (a3)
        *a3 = 17;
      if (a4)
        *a4 = 0;
      result = "DominantMotionTracker Processed Motion Data";
      if (a5)
        goto LABEL_312;
      return result;
    case 33:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 0;
      result = "ARGB half float";
      if (a5)
        goto LABEL_312;
      return result;
    case 34:
      if (a2)
        *a2 = 4;
      if (a3)
        *a3 = 4;
      if (a4)
        *a4 = 28;
      result = "RGBA float";
      if (a5)
        goto LABEL_312;
      return result;
    case 35:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 3;
      if (a4)
        *a4 = 17;
      result = "RGB 8 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 36:
      if (a2)
        *a2 = 1;
      if (a3)
        *a3 = 3;
      if (a4)
        *a4 = 18;
      result = "BGR 8 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    case 37:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 3;
      if (!a4)
        goto LABEL_311;
      v7 = 19;
      goto LABEL_310;
    case 38:
      if (a2)
        *a2 = 2;
      if (a3)
        *a3 = 4;
      if (a4)
      {
        v7 = 25;
LABEL_310:
        *a4 = v7;
      }
LABEL_311:
      result = "RGB 16 bit unsigned int";
      if (a5)
        goto LABEL_312;
      return result;
    default:
      if (a2)
        *a2 = 0;
      if (a3)
        *a3 = 0;
      if (a4)
        *a4 = 0;
      result = "Unknown pixel type";
      if (!a5)
        return result;
LABEL_312:
      v6 = 0;
LABEL_313:
      *a5 = v6;
      return result;
  }
}

FILE *HGIQA::WriteBitmap(HGIQA *this, const char *a2, HGBitmap *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v6;
  int v7;
  int32x2_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *((unsigned int *)a2 + 4);
  if (!(_DWORD)a3)
  {
    if (((0x3BFCFFC8AuLL >> v3) & 1) != 0)
    {
      goto LABEL_9;
    }
    return 0;
  }
  if ((_DWORD)v3 == 13)
  {
    v4 = 19;
    goto LABEL_9;
  }
  if ((_DWORD)v3 != 28)
    return 0;
  v4 = 20;
LABEL_9:
  v6 = 0x100000000;
  v7 = 1;
  v8 = vsub_s32(*(int32x2_t *)(a2 + 28), *(int32x2_t *)(a2 + 20));
  v9 = *((_QWORD *)a2 + 8);
  v10 = v4;
  v12 = 0;
  v11 = 0;
  return HGIQA::IQAWriteFile((const char *)this, (__int128 *)&v6, *((char **)a2 + 10));
}

uint64_t HGLoggerUtils::bytesPrettyString(HGLoggerUtils *this)
{
  int v1;
  int v2;
  uint64_t v3;
  _QWORD *v4;
  const char *v5;
  size_t v6;
  uint64_t v7;
  _QWORD v9[2];
  _QWORD v10[11];
  char v11;
  uint64_t v12;

  if (this)
    v1 = (int)(log2((double)(unint64_t)this) / 10.0);
  else
    v1 = 0;
  if (v1 >= 4)
    v2 = 4;
  else
    v2 = v1;
  ldexp(1.0, 10 * v2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v9);
  v3 = v10[0];
  *(_DWORD *)((char *)&v10[1] + *(_QWORD *)(v10[0] - 24)) = *(_DWORD *)((_BYTE *)&v10[1] + *(_QWORD *)(v10[0] - 24)) & 0xFFFFFEFB | 4;
  *(_QWORD *)((char *)&v10[2] + *(_QWORD *)(v3 - 24)) = 1;
  v4 = (_QWORD *)std::ostream::operator<<();
  v5 = HGLoggerUtils::bytesPrettyString(unsigned long long)::units[v2];
  v6 = strlen(v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E0DE4F50];
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v9 + *(_QWORD *)(v9[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v10[0] = v7;
  v10[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v11 < 0)
    operator delete((void *)v10[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v12);
}

void sub_1B29E1778(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B29E178C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGLoggerUtils::timePrettyString(HGLoggerUtils *this)
{
  int v1;
  int v2;
  uint64_t v3;
  _QWORD *v4;
  const char *v5;
  size_t v6;
  uint64_t v7;
  _QWORD v9[2];
  _QWORD v10[11];
  char v11;
  uint64_t v12;

  if (this)
    v1 = (int)log10((double)(unint64_t)this) / 3;
  else
    v1 = 0;
  if (v1 >= 3)
    v2 = 3;
  else
    v2 = v1;
  __exp10((double)(3 * v2));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v9);
  v3 = v10[0];
  *(_DWORD *)((char *)&v10[1] + *(_QWORD *)(v10[0] - 24)) = *(_DWORD *)((_BYTE *)&v10[1] + *(_QWORD *)(v10[0] - 24)) & 0xFFFFFEFB | 4;
  *(_QWORD *)((char *)&v10[2] + *(_QWORD *)(v3 - 24)) = 1;
  v4 = (_QWORD *)std::ostream::operator<<();
  v5 = HGLoggerUtils::timePrettyString(unsigned long long)::units[v2];
  v6 = strlen(v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E0DE4F50];
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v9 + *(_QWORD *)(v9[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v10[0] = v7;
  v10[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v11 < 0)
    operator delete((void *)v10[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1B5E290BC](&v12);
}

void sub_1B29E190C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B29E1920(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t MatrixPrettyString<double>(uint64_t a1, int a2, int a3, const void **a4, const void **a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::ios_base *v12;
  int v13;
  size_t v14;
  unint64_t v15;
  int v16;
  __int128 *p_dst;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  __int128 *v26;
  uint64_t v27;
  int v28;
  size_t v29;
  unint64_t v30;
  __int128 *v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  const char *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v49;
  __int128 v51;
  unint64_t v52;
  __int128 __dst;
  int64_t v54;
  uint64_t v55;
  _QWORD v56[8];
  void *__p[2];
  __int128 v58;
  int v59;
  uint64_t v60[20];

  v8 = MEMORY[0x1E0DE4FE0];
  v9 = MEMORY[0x1E0DE4FE0] + 64;
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v60[0] = MEMORY[0x1E0DE4FE0] + 64;
  v55 = v10;
  *(_QWORD *)((char *)&v56[-1] + *(_QWORD *)(v10 - 24)) = v11;
  v12 = (std::ios_base *)((char *)&v56[-1] + *(_QWORD *)(v55 - 24));
  std::ios_base::init(v12, v56);
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  v55 = v8 + 24;
  v60[0] = v9;
  std::streambuf::basic_streambuf();
  v56[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v58 = 0u;
  v59 = 16;
  v13 = *((char *)a4 + 23);
  if (v13 >= 0)
    v14 = *((unsigned __int8 *)a4 + 23);
  else
    v14 = (size_t)a4[1];
  v15 = v14 + 8;
  if (v14 + 8 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v16 = a2;
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    p_dst = (__int128 *)operator new(v18 + 1);
    *((_QWORD *)&__dst + 1) = v14 + 8;
    v54 = v19 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_11;
  }
  v54 = 0;
  __dst = 0uLL;
  p_dst = &__dst;
  HIBYTE(v54) = v14 + 8;
  if (v14)
  {
LABEL_11:
    if (v13 >= 0)
      v20 = a4;
    else
      v20 = *a4;
    memmove(p_dst, v20, v14);
  }
  v21 = 0;
  v22 = v16;
  v46 = v16;
  v23 = 8 * v16;
  strcpy((char *)p_dst + v14, "    [ [ ");
  v47 = v22 & ~(v22 >> 31);
  while (v21 != v47)
  {
    if (v54 >= 0)
      v26 = &__dst;
    else
      v26 = (__int128 *)__dst;
    if (v54 >= 0)
      v27 = HIBYTE(v54);
    else
      v27 = *((_QWORD *)&__dst + 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)v26, v27);
    v49 = v21;
    v28 = *((char *)a5 + 23);
    if (v28 >= 0)
      v29 = *((unsigned __int8 *)a5 + 23);
    else
      v29 = (size_t)a5[1];
    v30 = v29 + 8;
    if (v29 + 8 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    if (v30 >= 0x17)
    {
      v45 = *((char *)a5 + 23);
      v32 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v30 | 7) != 0x17)
        v32 = v30 | 7;
      v44 = v32 + 1;
      v31 = (__int128 *)operator new(v32 + 1);
      *((_QWORD *)&v51 + 1) = v29 + 8;
      v52 = v44 | 0x8000000000000000;
      *(_QWORD *)&v51 = v31;
      v28 = v45;
    }
    else
    {
      v52 = 0;
      v51 = 0uLL;
      v31 = &v51;
      HIBYTE(v52) = v29 + 8;
      if (!v29)
        goto LABEL_44;
    }
    if (v28 >= 0)
      v33 = a5;
    else
      v33 = *a5;
    memmove(v31, v33, v29);
LABEL_44:
    strcpy((char *)v31 + v29, "      [ ");
    if (SHIBYTE(v54) < 0)
      operator delete((void *)__dst);
    __dst = v51;
    v54 = v52;
    v34 = a3 - 1;
    v35 = a3 & ~(a3 >> 31);
    v36 = a1;
    while (v35)
    {
      v37 = v55;
      *(_DWORD *)((char *)v56 + *(_QWORD *)(v55 - 24)) = *(_DWORD *)((_BYTE *)v56 + *(_QWORD *)(v55 - 24)) & 0xFFFFFEFB | 4;
      *(_QWORD *)((char *)&v56[1] + *(_QWORD *)(v37 - 24)) = 8;
      v38 = (_QWORD *)std::ostream::operator<<();
      if (v34)
        v39 = ", ";
      else
        v39 = " ";
      if (v34)
        v40 = 2;
      else
        v40 = 1;
      --v35;
      v36 += v23;
      --v34;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)v39, v40);
    }
    v21 = v49 + 1;
    if (v49 + 1 == v46)
      v24 = "] ]";
    else
      v24 = "]\n";
    if (v49 + 1 == v46)
      v25 = 3;
    else
      v25 = 2;
    a1 += 8;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)v24, v25);
  }
  std::stringbuf::str();
  v41 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v42 = MEMORY[0x1E0DE4FB8];
  if (SHIBYTE(v54) < 0)
    operator delete((void *)__dst);
  v55 = *v41;
  *(_QWORD *)((char *)&v56[-1] + *(_QWORD *)(v55 - 24)) = v41[3];
  v56[0] = v42 + 16;
  if (SBYTE7(v58) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1B5E290BC](v60);
}

void sub_1B29E1D60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  if (a28 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t MatrixPrettyString<float>(uint64_t a1, int a2, int a3, const void **a4, const void **a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::ios_base *v12;
  int v13;
  size_t v14;
  unint64_t v15;
  int v16;
  __int128 *p_dst;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  __int128 *v26;
  uint64_t v27;
  int v28;
  size_t v29;
  unint64_t v30;
  __int128 *v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  const char *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v49;
  __int128 v51;
  unint64_t v52;
  __int128 __dst;
  int64_t v54;
  uint64_t v55;
  _QWORD v56[8];
  void *__p[2];
  __int128 v58;
  int v59;
  uint64_t v60[20];

  v8 = MEMORY[0x1E0DE4FE0];
  v9 = MEMORY[0x1E0DE4FE0] + 64;
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v60[0] = MEMORY[0x1E0DE4FE0] + 64;
  v55 = v10;
  *(_QWORD *)((char *)&v56[-1] + *(_QWORD *)(v10 - 24)) = v11;
  v12 = (std::ios_base *)((char *)&v56[-1] + *(_QWORD *)(v55 - 24));
  std::ios_base::init(v12, v56);
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  v55 = v8 + 24;
  v60[0] = v9;
  std::streambuf::basic_streambuf();
  v56[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v58 = 0u;
  v59 = 16;
  v13 = *((char *)a4 + 23);
  if (v13 >= 0)
    v14 = *((unsigned __int8 *)a4 + 23);
  else
    v14 = (size_t)a4[1];
  v15 = v14 + 8;
  if (v14 + 8 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v16 = a2;
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    p_dst = (__int128 *)operator new(v18 + 1);
    *((_QWORD *)&__dst + 1) = v14 + 8;
    v54 = v19 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_11;
  }
  v54 = 0;
  __dst = 0uLL;
  p_dst = &__dst;
  HIBYTE(v54) = v14 + 8;
  if (v14)
  {
LABEL_11:
    if (v13 >= 0)
      v20 = a4;
    else
      v20 = *a4;
    memmove(p_dst, v20, v14);
  }
  v21 = 0;
  v22 = v16;
  v46 = v16;
  v23 = 4 * v16;
  strcpy((char *)p_dst + v14, "    [ [ ");
  v47 = v22 & ~(v22 >> 31);
  while (v21 != v47)
  {
    if (v54 >= 0)
      v26 = &__dst;
    else
      v26 = (__int128 *)__dst;
    if (v54 >= 0)
      v27 = HIBYTE(v54);
    else
      v27 = *((_QWORD *)&__dst + 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)v26, v27);
    v49 = v21;
    v28 = *((char *)a5 + 23);
    if (v28 >= 0)
      v29 = *((unsigned __int8 *)a5 + 23);
    else
      v29 = (size_t)a5[1];
    v30 = v29 + 8;
    if (v29 + 8 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    if (v30 >= 0x17)
    {
      v45 = *((char *)a5 + 23);
      v32 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v30 | 7) != 0x17)
        v32 = v30 | 7;
      v44 = v32 + 1;
      v31 = (__int128 *)operator new(v32 + 1);
      *((_QWORD *)&v51 + 1) = v29 + 8;
      v52 = v44 | 0x8000000000000000;
      *(_QWORD *)&v51 = v31;
      v28 = v45;
    }
    else
    {
      v52 = 0;
      v51 = 0uLL;
      v31 = &v51;
      HIBYTE(v52) = v29 + 8;
      if (!v29)
        goto LABEL_44;
    }
    if (v28 >= 0)
      v33 = a5;
    else
      v33 = *a5;
    memmove(v31, v33, v29);
LABEL_44:
    strcpy((char *)v31 + v29, "      [ ");
    if (SHIBYTE(v54) < 0)
      operator delete((void *)__dst);
    __dst = v51;
    v54 = v52;
    v34 = a3 - 1;
    v35 = a3 & ~(a3 >> 31);
    v36 = a1;
    while (v35)
    {
      v37 = v55;
      *(_DWORD *)((char *)v56 + *(_QWORD *)(v55 - 24)) = *(_DWORD *)((_BYTE *)v56 + *(_QWORD *)(v55 - 24)) & 0xFFFFFEFB | 4;
      *(_QWORD *)((char *)&v56[1] + *(_QWORD *)(v37 - 24)) = 8;
      v38 = (_QWORD *)std::ostream::operator<<();
      if (v34)
        v39 = ", ";
      else
        v39 = " ";
      if (v34)
        v40 = 2;
      else
        v40 = 1;
      --v35;
      v36 += v23;
      --v34;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)v39, v40);
    }
    v21 = v49 + 1;
    if (v49 + 1 == v46)
      v24 = "] ]";
    else
      v24 = "]\n";
    if (v49 + 1 == v46)
      v25 = 3;
    else
      v25 = 2;
    a1 += 4;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)v24, v25);
  }
  std::stringbuf::str();
  v41 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v42 = MEMORY[0x1E0DE4FB8];
  if (SHIBYTE(v54) < 0)
    operator delete((void *)__dst);
  v55 = *v41;
  *(_QWORD *)((char *)&v56[-1] + *(_QWORD *)(v55 - 24)) = v41[3];
  v56[0] = v42 + 16;
  if (SBYTE7(v58) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1B5E290BC](v60);
}

void sub_1B29E2210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  if (a28 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t HGLogger::indent(uint64_t this)
{
  unsigned int v1;

  do
    v1 = __ldaxr(&HGLogger::_indent);
  while (__stlxr(v1 + this, &HGLogger::_indent));
  return this;
}

uint64_t HGLogger::setLevel(HGLogger *this, const char *a2)
{
  int v2;
  uint64_t v3;
  const char *v5;
  const char **v6;

  v2 = (int)a2;
  v5 = (const char *)this;
  pthread_mutex_lock(&HGLC::_ctxsLock);
  v3 = HGLC::getContexts(void)::contexts;
  if (!HGLC::getContexts(void)::contexts)
  {
    v3 = operator new();
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 8) = 0;
    *(_QWORD *)v3 = v3 + 8;
    HGLC::getContexts(void)::contexts = v3;
  }
  v6 = &v5;
  *((_DWORD *)std::__tree<std::__value_type<char const*,int>,std::__map_value_compare<char const*,std::__value_type<char const*,int>,HGLC::ltstr,true>,std::allocator<std::__value_type<char const*,int>>>::__emplace_unique_key_args<char const*,std::piecewise_construct_t const&,std::tuple<char const* const&>,std::tuple<>>((uint64_t **)v3, &v5, (uint64_t)&std::piecewise_construct, &v6)+ 10) = v2;
  return pthread_mutex_unlock(&HGLC::_ctxsLock);
}

uint64_t HGLogger::getLevel(HGLogger *this, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  _QWORD *v9;

  pthread_mutex_lock(&HGLC::_ctxsLock);
  if (HGLC::getContexts(void)::contexts)
  {
    v3 = HGLC::getContexts(void)::contexts + 8;
    v4 = *(_QWORD *)(HGLC::getContexts(void)::contexts + 8);
    if (!v4)
      goto LABEL_10;
    v5 = HGLC::getContexts(void)::contexts + 8;
    do
    {
      v6 = strcmp(*(const char **)(v4 + 32), (const char *)this);
      v7 = (uint64_t *)(v4 + 8);
      if (v6 >= 0)
      {
        v7 = (uint64_t *)v4;
        v5 = v4;
      }
      v4 = *v7;
    }
    while (*v7);
    if (v5 == v3 || strcmp((const char *)this, *(const char **)(v5 + 32)) < 0)
LABEL_10:
      v8 = 0;
    else
      v8 = *(unsigned int *)(v5 + 40);
  }
  else
  {
    v9 = (_QWORD *)operator new();
    v8 = 0;
    v9[2] = 0;
    v9[1] = 0;
    *v9 = v9 + 1;
    HGLC::getContexts(void)::contexts = (uint64_t)v9;
  }
  pthread_mutex_unlock(&HGLC::_ctxsLock);
  return v8;
}

void HGLogger::log(HGLogger *this, const char *a2, HGLogger *a3, const char *a4, char *a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGLogger::vlog(this, a2, a3, va, a5);
}

void HGLogger::vlog(HGLogger *this, const char *a2, HGLogger *a3, const char *a4, char *a5)
{
  unsigned __int8 v5;
  const char *v7;
  void **v8;
  size_t v9;
  void *v10;
  void **v11;
  const char *v12;
  const char *v13;
  int v14;
  char *v15;
  char *v16;
  int v17;
  size_t v18;
  size_t v19;
  size_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  std::locale::id *v26;
  NSObject *v27;
  const std::locale::facet *v28;
  unsigned __int8 v29;
  _QWORD *v30;
  std::locale::__imp *v31;
  void *v32;
  size_t v33;
  int64_t v34;
  void *__p[2];
  uint64_t v36;
  void *v37;
  char v38;
  uint64_t v39;
  void *v40;
  char *v41;
  char *v42;
  va_list v43;
  void *__dst[2];
  int64_t v45;
  va_list v46;
  std::locale v47[4];

  v47[3] = *(std::locale *)MEMORY[0x1E0C80C00];
  v46 = (va_list)a4;
  v5 = atomic_load(HGLogger::_enabled);
  if ((int)a2 < 1 || (v5 & 1) == 0 || (int)HGLogger::getLevel(this, a2) < (int)a2)
    return;
  HGLogger::getFormatPreamble((uint64_t *)__p, a3, v7);
  if (v36 >= 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  v9 = strlen((const char *)v8);
  if (v9 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v10 = (void *)v9;
  if (v9 >= 0x17)
  {
    v22 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v22 = v9 | 7;
    v23 = v22 + 1;
    v11 = (void **)operator new(v22 + 1);
    __dst[1] = v10;
    v45 = v23 | 0x8000000000000000;
    __dst[0] = v11;
LABEL_24:
    memmove(v11, v8, (size_t)v10);
    *((_BYTE *)v10 + (_QWORD)v11) = 0;
    if ((SHIBYTE(v36) & 0x80000000) == 0)
      goto LABEL_11;
    goto LABEL_25;
  }
  HIBYTE(v45) = v9;
  v11 = __dst;
  if (v9)
    goto LABEL_24;
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v36) & 0x80000000) == 0)
    goto LABEL_11;
LABEL_25:
  operator delete(__p[0]);
LABEL_11:
  if (v45 >= 0)
    v12 = (const char *)__dst;
  else
    v12 = (const char *)__dst[0];
  v13 = fmtcheck(v12, (const char *)a3);
  v43 = v46;
  v14 = vsnprintf(0, 0, v13, v46);
  v15 = 0;
  v16 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v17 = v14 + 1;
  if (v14 != -1)
  {
    if (v14 <= -2)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v18 = v17;
    v16 = (char *)operator new(v17);
    v15 = &v16[v18];
    v40 = v16;
    v42 = &v16[v18];
    bzero(v16, v18);
    v41 = &v16[v18];
  }
  vsnprintf(v16, v15 - v16, v13, v43);
  v19 = strlen(v16);
  if (v19 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v20 = v19;
  if (v19 >= 0x17)
  {
    v24 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v24 = v19 | 7;
    v25 = v24 + 1;
    v21 = operator new(v24 + 1);
    v33 = v20;
    v34 = v25 | 0x8000000000000000;
    v32 = v21;
  }
  else
  {
    HIBYTE(v34) = v19;
    v21 = &v32;
    if (!v19)
      goto LABEL_30;
  }
  memcpy(v21, v16, v20);
LABEL_30:
  *((_BYTE *)v21 + v20) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)__p, (uint64_t)&v32, 8);
  if (SHIBYTE(v34) < 0)
    operator delete(v32);
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v26 = (std::locale::id *)MEMORY[0x1E0DE4A90];
  v27 = MEMORY[0x1E0C81028];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)__p + *((_QWORD *)__p[0] - 3)));
    v28 = std::locale::use_facet(v47, v26);
    v29 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v28->__vftable[2].~facet_0)(v28, 10);
    std::locale::~locale(v47);
    v30 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(__p, (uint64_t)&v32, v29);
    if ((*((_BYTE *)v30 + *(_QWORD *)(*v30 - 24) + 32) & 5) != 0)
      break;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      if (v34 >= 0)
        v31 = (std::locale::__imp *)&v32;
      else
        v31 = (std::locale::__imp *)v32;
      LODWORD(v47[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v47[0].__locale_ + 4) = v31;
      _os_log_impl(&dword_1B2737000, v27, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v47, 0xCu);
    }
  }
  if (SHIBYTE(v34) < 0)
    operator delete(v32);
  __p[0] = *(void **)MEMORY[0x1E0DE4F58];
  *(void **)((char *)__p + *((_QWORD *)__p[0] - 3)) = *(void **)(MEMORY[0x1E0DE4F58] + 24);
  v36 = MEMORY[0x1E0DE4FB8] + 16;
  if (v38 < 0)
    operator delete(v37);
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E290BC](&v39);
  if (v40)
    operator delete(v40);
  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
}

void sub_1B29E285C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;
  void *v25;

  if (a17 < 0)
    operator delete(__p);
  v25 = *(void **)(v23 - 176);
  if (v25)
    operator delete(v25);
  if (*(char *)(v23 - 121) < 0)
    operator delete(*(void **)(v23 - 144));
  _Unwind_Resume(exception_object);
}

uint64_t HGLogger::getFormatPreamble(HGLogger *this, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  int v10;
  size_t v11;
  uint64_t v13;
  uint64_t v14[8];
  void *__p[2];
  __int128 v16;
  int v17;
  uint64_t v18[19];

  v3 = MEMORY[0x1E0DE4FE0];
  v4 = MEMORY[0x1E0DE4FE0] + 64;
  v5 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v18[0] = MEMORY[0x1E0DE4FE0] + 64;
  v13 = v6;
  *(uint64_t *)((char *)&v14[-1] + *(_QWORD *)(v6 - 24)) = v7;
  v8 = (std::ios_base *)((char *)&v14[-1] + *(_QWORD *)(v13 - 24));
  std::ios_base::init(v8, v14);
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v13 = v3 + 24;
  v18[0] = v4;
  std::streambuf::basic_streambuf();
  v9 = MEMORY[0x1E0DE4FB8];
  v14[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v16 = 0u;
  v17 = 16;
  v10 = atomic_load(&HGLogger::_indent);
  if (v10 >= 1)
  {
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)"| ", 2);
      --v10;
    }
    while (v10);
  }
  v11 = strlen((const char *)this);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)this, v11);
  std::stringbuf::str();
  v13 = *v5;
  *(uint64_t *)((char *)&v14[-1] + *(_QWORD *)(v13 - 24)) = v5[3];
  v14[0] = v9 + 16;
  if (SBYTE7(v16) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1B5E290BC](v18);
}

void sub_1B29E2A80(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1B5E290BC](v1);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::basic_istringstream[abi:ne180100](uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  uint64_t v10;

  v5 = MEMORY[0x1E0DE4FD8];
  v6 = MEMORY[0x1E0DE4FD8] + 64;
  *(_QWORD *)(a1 + 120) = MEMORY[0x1E0DE4FD8] + 64;
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 8);
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 16);
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + *(_QWORD *)(v7 - 24)) = v8;
  *(_QWORD *)(a1 + 8) = 0;
  v9 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v9, (void *)(a1 + 16));
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v5 + 24;
  *(_QWORD *)(a1 + 120) = v6;
  std::streambuf::basic_streambuf();
  v10 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 16) = v10;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = a3 | 8;
  std::stringbuf::str();
  return a1;
}

void sub_1B29E2BC4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  if (*(char *)(v2 + 103) < 0)
    operator delete(*v3);
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E290BC](v1);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::~istringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F58];
  v3 = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 16) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E290BC](a1 + 120);
  return a1;
}

void HGLogger::print(HGLogger *this, const char *a2, char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGLogger::vprint(this, va, a3);
}

void HGLogger::vprint(HGLogger *this, const char *a2, char *a3)
{
  unsigned __int8 v3;
  void **v5;
  size_t v6;
  void *v7;
  void **v8;
  const char *v9;
  const char *v10;
  int v11;
  char *v12;
  char *v13;
  int v14;
  size_t v15;
  size_t v16;
  size_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  std::locale::id *v23;
  NSObject *v24;
  const std::locale::facet *v25;
  unsigned __int8 v26;
  _QWORD *v27;
  std::locale::__imp *v28;
  void *v29;
  size_t v30;
  int64_t v31;
  void *__p[2];
  uint64_t v33;
  void *v34;
  char v35;
  uint64_t v36;
  void *v37;
  char *v38;
  char *v39;
  va_list v40;
  void *__dst[2];
  int64_t v42;
  va_list v43;
  std::locale v44[4];

  v44[3] = *(std::locale *)MEMORY[0x1E0C80C00];
  v43 = (va_list)a2;
  v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) == 0)
    return;
  HGLogger::getFormatPreamble((uint64_t *)__p, this, a2);
  if (v33 >= 0)
    v5 = __p;
  else
    v5 = (void **)__p[0];
  v6 = strlen((const char *)v5);
  if (v6 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v7 = (void *)v6;
  if (v6 >= 0x17)
  {
    v19 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v19 = v6 | 7;
    v20 = v19 + 1;
    v8 = (void **)operator new(v19 + 1);
    __dst[1] = v7;
    v42 = v20 | 0x8000000000000000;
    __dst[0] = v8;
LABEL_22:
    memmove(v8, v5, (size_t)v7);
    *((_BYTE *)v7 + (_QWORD)v8) = 0;
    if ((SHIBYTE(v33) & 0x80000000) == 0)
      goto LABEL_9;
    goto LABEL_23;
  }
  HIBYTE(v42) = v6;
  v8 = __dst;
  if (v6)
    goto LABEL_22;
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v33) & 0x80000000) == 0)
    goto LABEL_9;
LABEL_23:
  operator delete(__p[0]);
LABEL_9:
  if (v42 >= 0)
    v9 = (const char *)__dst;
  else
    v9 = (const char *)__dst[0];
  v10 = fmtcheck(v9, (const char *)this);
  v40 = v43;
  v11 = vsnprintf(0, 0, v10, v43);
  v12 = 0;
  v13 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v14 = v11 + 1;
  if (v11 != -1)
  {
    if (v11 <= -2)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v15 = v14;
    v13 = (char *)operator new(v14);
    v12 = &v13[v15];
    v37 = v13;
    v39 = &v13[v15];
    bzero(v13, v15);
    v38 = &v13[v15];
  }
  vsnprintf(v13, v12 - v13, v10, v40);
  v16 = strlen(v13);
  if (v16 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v17 = v16;
  if (v16 >= 0x17)
  {
    v21 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v21 = v16 | 7;
    v22 = v21 + 1;
    v18 = operator new(v21 + 1);
    v30 = v17;
    v31 = v22 | 0x8000000000000000;
    v29 = v18;
  }
  else
  {
    HIBYTE(v31) = v16;
    v18 = &v29;
    if (!v16)
      goto LABEL_28;
  }
  memcpy(v18, v13, v17);
LABEL_28:
  *((_BYTE *)v18 + v17) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)__p, (uint64_t)&v29, 8);
  if (SHIBYTE(v31) < 0)
    operator delete(v29);
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v23 = (std::locale::id *)MEMORY[0x1E0DE4A90];
  v24 = MEMORY[0x1E0C81028];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)__p + *((_QWORD *)__p[0] - 3)));
    v25 = std::locale::use_facet(v44, v23);
    v26 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
    std::locale::~locale(v44);
    v27 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(__p, (uint64_t)&v29, v26);
    if ((*((_BYTE *)v27 + *(_QWORD *)(*v27 - 24) + 32) & 5) != 0)
      break;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      if (v31 >= 0)
        v28 = (std::locale::__imp *)&v29;
      else
        v28 = (std::locale::__imp *)v29;
      LODWORD(v44[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v44[0].__locale_ + 4) = v28;
      _os_log_impl(&dword_1B2737000, v24, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v44, 0xCu);
    }
  }
  if (SHIBYTE(v31) < 0)
    operator delete(v29);
  __p[0] = *(void **)MEMORY[0x1E0DE4F58];
  *(void **)((char *)__p + *((_QWORD *)__p[0] - 3)) = *(void **)(MEMORY[0x1E0DE4F58] + 24);
  v33 = MEMORY[0x1E0DE4FB8] + 16;
  if (v35 < 0)
    operator delete(v34);
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E290BC](&v36);
  if (v37)
    operator delete(v37);
  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
}

void sub_1B29E30BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;
  void *v25;

  if (a17 < 0)
    operator delete(__p);
  v25 = *(void **)(v23 - 176);
  if (v25)
    operator delete(v25);
  if (*(char *)(v23 - 121) < 0)
    operator delete(*(void **)(v23 - 144));
  _Unwind_Resume(exception_object);
}

const char *HGLogger::warning(HGLogger *this, const char *a2, char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return HGLogger::vwarning((const char *)this, va, a3);
}

const char *HGLogger::vwarning(const char *this, const char *a2, char *a3)
{
  unsigned __int8 v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  _QWORD *v10;
  size_t v11;
  uint8_t *v12;
  size_t v13;
  void *v14;
  void **v15;
  const char *v16;
  const char *v17;
  int v18;
  char *v19;
  char *v20;
  int v21;
  size_t v22;
  size_t v23;
  size_t v24;
  void *p_p;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  std::locale::id *v30;
  NSObject *v31;
  const std::locale::facet *v32;
  unsigned __int8 v33;
  _QWORD *v34;
  std::locale::__imp *v35;
  uint64_t v36;
  uint64_t *v37;
  void *__p;
  size_t v39;
  int64_t v40;
  uint8_t buf[8];
  uint64_t v42;
  void *v43;
  char v44;
  uint64_t v45;
  void *v46;
  char *v47;
  char *v48;
  va_list v49;
  void *__dst[2];
  int64_t v51;
  uint64_t v52;
  uint64_t v53[8];
  __int128 v54;
  __int128 v55;
  int v56;
  uint64_t v57[19];
  va_list v58;
  std::locale v59[6];

  v59[3] = *(std::locale *)MEMORY[0x1E0C80C00];
  v58 = (va_list)a2;
  v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) == 0)
    return this;
  v4 = this;
  v5 = MEMORY[0x1E0DE4FE0];
  v6 = MEMORY[0x1E0DE4FE0] + 64;
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v57[0] = MEMORY[0x1E0DE4FE0] + 64;
  v52 = v7;
  *(uint64_t *)((char *)&v53[-1] + *(_QWORD *)(v7 - 24)) = v8;
  v9 = (std::ios_base *)((char *)&v53[-1] + *(_QWORD *)(v52 - 24));
  std::ios_base::init(v9, v53);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  v52 = v5 + 24;
  v57[0] = v6;
  std::streambuf::basic_streambuf();
  v53[0] = MEMORY[0x1E0DE4FB8] + 16;
  v54 = 0u;
  v55 = 0u;
  v56 = 16;
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v52, (uint64_t)"  Helium WARNING -- ", 20);
  v11 = strlen(v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v4, v11);
  std::stringbuf::str();
  if (v42 >= 0)
    v12 = buf;
  else
    v12 = *(uint8_t **)buf;
  v13 = strlen((const char *)v12);
  if (v13 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v14 = (void *)v13;
  if (v13 >= 0x17)
  {
    v26 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v26 = v13 | 7;
    v27 = v26 + 1;
    v15 = (void **)operator new(v26 + 1);
    __dst[1] = v14;
    v51 = v27 | 0x8000000000000000;
    __dst[0] = v15;
LABEL_24:
    memmove(v15, v12, (size_t)v14);
    *((_BYTE *)v14 + (_QWORD)v15) = 0;
    if ((SHIBYTE(v42) & 0x80000000) == 0)
      goto LABEL_9;
    goto LABEL_25;
  }
  HIBYTE(v51) = v13;
  v15 = __dst;
  if (v13)
    goto LABEL_24;
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v42) & 0x80000000) == 0)
    goto LABEL_9;
LABEL_25:
  operator delete(*(void **)buf);
LABEL_9:
  if (v51 >= 0)
    v16 = (const char *)__dst;
  else
    v16 = (const char *)__dst[0];
  v17 = fmtcheck(v16, v4);
  v49 = v58;
  v18 = vsnprintf(0, 0, v17, v58);
  v19 = 0;
  v20 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v21 = v18 + 1;
  if (v18 != -1)
  {
    if (v18 <= -2)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v22 = v21;
    v20 = (char *)operator new(v21);
    v19 = &v20[v22];
    v46 = v20;
    v48 = &v20[v22];
    bzero(v20, v22);
    v47 = &v20[v22];
  }
  vsnprintf(v20, v19 - v20, v17, v49);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B2737000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", buf, 2u);
  }
  v23 = strlen(v20);
  if (v23 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v24 = v23;
  if (v23 >= 0x17)
  {
    v28 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17)
      v28 = v23 | 7;
    v29 = v28 + 1;
    p_p = operator new(v28 + 1);
    v39 = v24;
    v40 = v29 | 0x8000000000000000;
    __p = p_p;
    goto LABEL_29;
  }
  HIBYTE(v40) = v23;
  p_p = &__p;
  if (v23)
LABEL_29:
    memcpy(p_p, v20, v24);
  *((_BYTE *)p_p + v24) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)buf, (uint64_t)&__p, 8);
  if (SHIBYTE(v40) < 0)
    operator delete(__p);
  __p = 0;
  v39 = 0;
  v40 = 0;
  v30 = (std::locale::id *)MEMORY[0x1E0DE4A90];
  v31 = MEMORY[0x1E0C81028];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)]);
    v32 = std::locale::use_facet(v59, v30);
    v33 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v32->__vftable[2].~facet_0)(v32, 10);
    std::locale::~locale(v59);
    v34 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(buf, (uint64_t)&__p, v33);
    if ((*((_BYTE *)v34 + *(_QWORD *)(*v34 - 24) + 32) & 5) != 0)
      break;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      if (v40 >= 0)
        v35 = (std::locale::__imp *)&__p;
      else
        v35 = (std::locale::__imp *)__p;
      LODWORD(v59[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v59[0].__locale_ + 4) = v35;
      _os_log_impl(&dword_1B2737000, v31, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v59, 0xCu);
    }
  }
  if (SHIBYTE(v40) < 0)
  {
    operator delete(__p);
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_42;
    goto LABEL_41;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
LABEL_41:
    LOWORD(__p) = 0;
    _os_log_impl(&dword_1B2737000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", (uint8_t *)&__p, 2u);
  }
LABEL_42:
  *(_QWORD *)buf = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 24);
  v36 = MEMORY[0x1E0DE4FB8];
  v42 = MEMORY[0x1E0DE4FB8] + 16;
  v37 = (uint64_t *)MEMORY[0x1E0DE4F60];
  if (v44 < 0)
    operator delete(v43);
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E290BC](&v45);
  if (v46)
    operator delete(v46);
  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  v52 = *v37;
  *(uint64_t *)((char *)&v53[-1] + *(_QWORD *)(v52 - 24)) = v37[3];
  v53[0] = v36 + 16;
  if (SBYTE7(v55) < 0)
    operator delete((void *)v54);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return (const char *)MEMORY[0x1B5E290BC](v57);
}

void sub_1B29E3738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,char a63)
{
  if (a16 < 0)
    operator delete(__p);
  if (a53)
    operator delete(a53);
  if (a62 < 0)
    operator delete(a57);
  std::ostringstream::~ostringstream((uint64_t)&a63);
  _Unwind_Resume(a1);
}

const char *HGLogger::error(HGLogger *this, const char *a2, char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return HGLogger::verror((const char *)this, va, a3);
}

const char *HGLogger::verror(const char *this, const char *a2, char *a3)
{
  unsigned __int8 v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  _QWORD *v10;
  size_t v11;
  uint8_t *v12;
  size_t v13;
  void *v14;
  void **v15;
  const char *v16;
  const char *v17;
  int v18;
  char *v19;
  char *v20;
  int v21;
  size_t v22;
  size_t v23;
  size_t v24;
  void *p_p;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  std::locale::id *v30;
  NSObject *v31;
  const std::locale::facet *v32;
  unsigned __int8 v33;
  _QWORD *v34;
  std::locale::__imp *v35;
  uint64_t v36;
  uint64_t *v37;
  void *__p;
  size_t v39;
  int64_t v40;
  uint8_t buf[8];
  uint64_t v42;
  void *v43;
  char v44;
  uint64_t v45;
  void *v46;
  char *v47;
  char *v48;
  va_list v49;
  void *__dst[2];
  int64_t v51;
  uint64_t v52;
  uint64_t v53[8];
  __int128 v54;
  __int128 v55;
  int v56;
  uint64_t v57[19];
  va_list v58;
  std::locale v59[6];

  v59[3] = *(std::locale *)MEMORY[0x1E0C80C00];
  v58 = (va_list)a2;
  v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) == 0)
    return this;
  v4 = this;
  v5 = MEMORY[0x1E0DE4FE0];
  v6 = MEMORY[0x1E0DE4FE0] + 64;
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v57[0] = MEMORY[0x1E0DE4FE0] + 64;
  v52 = v7;
  *(uint64_t *)((char *)&v53[-1] + *(_QWORD *)(v7 - 24)) = v8;
  v9 = (std::ios_base *)((char *)&v53[-1] + *(_QWORD *)(v52 - 24));
  std::ios_base::init(v9, v53);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  v52 = v5 + 24;
  v57[0] = v6;
  std::streambuf::basic_streambuf();
  v53[0] = MEMORY[0x1E0DE4FB8] + 16;
  v54 = 0u;
  v55 = 0u;
  v56 = 16;
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v52, (uint64_t)"  Helium ERROR -- ", 18);
  v11 = strlen(v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v4, v11);
  std::stringbuf::str();
  if (v42 >= 0)
    v12 = buf;
  else
    v12 = *(uint8_t **)buf;
  v13 = strlen((const char *)v12);
  if (v13 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v14 = (void *)v13;
  if (v13 >= 0x17)
  {
    v26 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v26 = v13 | 7;
    v27 = v26 + 1;
    v15 = (void **)operator new(v26 + 1);
    __dst[1] = v14;
    v51 = v27 | 0x8000000000000000;
    __dst[0] = v15;
LABEL_24:
    memmove(v15, v12, (size_t)v14);
    *((_BYTE *)v14 + (_QWORD)v15) = 0;
    if ((SHIBYTE(v42) & 0x80000000) == 0)
      goto LABEL_9;
    goto LABEL_25;
  }
  HIBYTE(v51) = v13;
  v15 = __dst;
  if (v13)
    goto LABEL_24;
  LOBYTE(__dst[0]) = 0;
  if ((SHIBYTE(v42) & 0x80000000) == 0)
    goto LABEL_9;
LABEL_25:
  operator delete(*(void **)buf);
LABEL_9:
  if (v51 >= 0)
    v16 = (const char *)__dst;
  else
    v16 = (const char *)__dst[0];
  v17 = fmtcheck(v16, v4);
  v49 = v58;
  v18 = vsnprintf(0, 0, v17, v58);
  v19 = 0;
  v20 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v21 = v18 + 1;
  if (v18 != -1)
  {
    if (v18 <= -2)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v22 = v21;
    v20 = (char *)operator new(v21);
    v19 = &v20[v22];
    v46 = v20;
    v48 = &v20[v22];
    bzero(v20, v22);
    v47 = &v20[v22];
  }
  vsnprintf(v20, v19 - v20, v17, v49);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B2737000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", buf, 2u);
  }
  v23 = strlen(v20);
  if (v23 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v24 = v23;
  if (v23 >= 0x17)
  {
    v28 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17)
      v28 = v23 | 7;
    v29 = v28 + 1;
    p_p = operator new(v28 + 1);
    v39 = v24;
    v40 = v29 | 0x8000000000000000;
    __p = p_p;
    goto LABEL_29;
  }
  HIBYTE(v40) = v23;
  p_p = &__p;
  if (v23)
LABEL_29:
    memcpy(p_p, v20, v24);
  *((_BYTE *)p_p + v24) = 0;
  std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)buf, (uint64_t)&__p, 8);
  if (SHIBYTE(v40) < 0)
    operator delete(__p);
  __p = 0;
  v39 = 0;
  v40 = 0;
  v30 = (std::locale::id *)MEMORY[0x1E0DE4A90];
  v31 = MEMORY[0x1E0C81028];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)]);
    v32 = std::locale::use_facet(v59, v30);
    v33 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v32->__vftable[2].~facet_0)(v32, 10);
    std::locale::~locale(v59);
    v34 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(buf, (uint64_t)&__p, v33);
    if ((*((_BYTE *)v34 + *(_QWORD *)(*v34 - 24) + 32) & 5) != 0)
      break;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      if (v40 >= 0)
        v35 = (std::locale::__imp *)&__p;
      else
        v35 = (std::locale::__imp *)__p;
      LODWORD(v59[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v59[0].__locale_ + 4) = v35;
      _os_log_impl(&dword_1B2737000, v31, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)v59, 0xCu);
    }
  }
  if (SHIBYTE(v40) < 0)
  {
    operator delete(__p);
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_42;
    goto LABEL_41;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
LABEL_41:
    LOWORD(__p) = 0;
    _os_log_impl(&dword_1B2737000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "------------------------------------------------------------", (uint8_t *)&__p, 2u);
  }
LABEL_42:
  *(_QWORD *)buf = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 24);
  v36 = MEMORY[0x1E0DE4FB8];
  v42 = MEMORY[0x1E0DE4FB8] + 16;
  v37 = (uint64_t *)MEMORY[0x1E0DE4F60];
  if (v44 < 0)
    operator delete(v43);
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E290BC](&v45);
  if (v46)
    operator delete(v46);
  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  v52 = *v37;
  *(uint64_t *)((char *)&v53[-1] + *(_QWORD *)(v52 - 24)) = v37[3];
  v53[0] = v36 + 16;
  if (SBYTE7(v55) < 0)
    operator delete((void *)v54);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return (const char *)MEMORY[0x1B5E290BC](v57);
}

void sub_1B29E3E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,char a63)
{
  if (a16 < 0)
    operator delete(__p);
  if (a53)
    operator delete(a53);
  if (a62 < 0)
    operator delete(a57);
  std::ostringstream::~ostringstream((uint64_t)&a63);
  _Unwind_Resume(a1);
}

uint64_t HGLogger::getNewlinePreamble(HGLogger *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;
  uint64_t v7;
  int v8;
  uint64_t v10;
  uint64_t v11[8];
  void *__p[2];
  __int128 v13;
  int v14;
  uint64_t v15[19];

  v1 = MEMORY[0x1E0DE4FE0];
  v2 = MEMORY[0x1E0DE4FE0] + 64;
  v3 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v15[0] = MEMORY[0x1E0DE4FE0] + 64;
  v10 = v4;
  *(uint64_t *)((char *)&v11[-1] + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)((char *)&v11[-1] + *(_QWORD *)(v10 - 24));
  std::ios_base::init(v6, v11);
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  v10 = v1 + 24;
  v15[0] = v2;
  std::streambuf::basic_streambuf();
  v7 = MEMORY[0x1E0DE4FB8];
  v11[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v13 = 0u;
  v14 = 16;
  v8 = atomic_load(&HGLogger::_indent);
  if (v8 >= 1)
  {
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v10, (uint64_t)"| ", 2);
      --v8;
    }
    while (v8);
  }
  std::stringbuf::str();
  v10 = *v3;
  *(uint64_t *)((char *)&v11[-1] + *(_QWORD *)(v10 - 24)) = v3[3];
  v11[0] = v7 + 16;
  if (SBYTE7(v13) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1B5E290BC](v15);
}

void sub_1B29E4064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B29E4078(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1B5E290BC](v1);
  _Unwind_Resume(a1);
}

void HGTraceGuard::HGTraceGuard(HGTraceGuard *this, HGLogger *a2, int a3, const char *a4)
{
  unsigned __int8 v5;
  char *v7;
  const char *v8;
  char *v9;
  unsigned int v10;
  HGProfiler *v11;
  char __str[100];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  v5 = atomic_load(HGLogger::_enabled);
  if (a3 >= 1 && (v5 & 1) != 0 && (int)HGLogger::getLevel(a2, (const char *)a2) >= a3)
  {
    v7 = strdup(a4);
    *(_QWORD *)this = v7;
    snprintf(__str, 0x64uLL, "/-- %s\n", v7);
    HGLogger::print((HGLogger *)"%s", v8, v9, __str);
    do
      v10 = __ldaxr(&HGLogger::_indent);
    while (__stlxr(v10 + 1, &HGLogger::_indent));
    v11 = (HGProfiler *)operator new();
    HGProfiler::HGProfiler(v11);
    *((_QWORD *)this + 1) = v11;
    HGProfiler::start(v11);
  }
}

void sub_1B29E41CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1000C40451B5BE8);
  _Unwind_Resume(a1);
}

void HGTraceGuard::~HGTraceGuard(HGProfiler **this)
{
  HGProfiler *v2;
  double Time;
  const char *v4;
  char *v5;
  unsigned int v6;
  HGProfiler *v7;
  char __str[100];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*this)
  {
    HGProfiler::stop(this[1]);
    v2 = *this;
    Time = HGProfiler::getTime(this[1]);
    snprintf(__str, 0x64uLL, "\\-- %s : %f msec\n", (const char *)v2, Time);
    do
      v6 = __ldaxr(&HGLogger::_indent);
    while (__stlxr(v6 - 1, &HGLogger::_indent));
    HGLogger::print((HGLogger *)"%s", v4, v5, __str);
    free(*this);
  }
  v7 = this[1];
  if (v7)
    MEMORY[0x1B5E29170](v7, 0x1000C40451B5BE8);
}

void sub_1B29E42D0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t **std::__tree<std::__value_type<char const*,int>,std::__map_value_compare<char const*,std::__value_type<char const*,int>,HGLC::ltstr,true>,std::allocator<std::__value_type<char const*,int>>>::__emplace_unique_key_args<char const*,std::piecewise_construct_t const&,std::tuple<char const* const&>,std::tuple<>>(uint64_t **a1, const char **a2, uint64_t a3, _QWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  const char *v8;
  uint64_t **v9;
  const char *v10;
  uint64_t **v11;
  _QWORD *v12;
  uint64_t *v13;
  uint64_t *v14;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = (const char *)v6[4];
        if ((strcmp(v8, v10) & 0x80000000) == 0)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_9;
      }
      if ((strcmp(v10, v8) & 0x80000000) == 0)
        return v9;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_9:
    v11 = v9;
    v12 = operator new(0x30uLL);
    v12[4] = **a4;
    *((_DWORD *)v12 + 10) = 0;
    *v12 = 0;
    v12[1] = 0;
    v12[2] = v11;
    *v7 = v12;
    v13 = (uint64_t *)**a1;
    v14 = v12;
    if (v13)
    {
      *a1 = v13;
      v14 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return (uint64_t **)v12;
  }
}

_QWORD *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;
  int v9;
  char v11;

  MEMORY[0x1B5E28E10](&v11, a1, 1);
  if (!v11)
    return a1;
  if (*(char *)(a2 + 23) < 0)
  {
    **(_BYTE **)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 23) = 0;
  }
  v6 = 0;
  while (1)
  {
    v7 = *(_QWORD **)((char *)a1 + *(_QWORD *)(*a1 - 24) + 40);
    v8 = (_BYTE *)v7[3];
    if (v8 != (_BYTE *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(_QWORD *))(*v7 + 80))(v7);
    if ((_DWORD)v7 == -1)
      break;
LABEL_9:
    if (v7 == a3)
    {
      v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(_QWORD *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6)
    v9 = 2;
  else
    v9 = 6;
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1B29E4514(void *a1)
{
  _QWORD *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  v2 = *v1;
  *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 32) |= 1u;
  if ((*((_BYTE *)v1 + *(_QWORD *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1B29E44E0);
  }
  __cxa_rethrow();
}

void sub_1B29E4558(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

const char *HGLodBlend2::GetProgram(HGLodBlend2 *this, HGRenderer *a2)
{
  unsigned int Target;
  unsigned int v5;
  const char *v6;

  Target = HGRenderer::GetTarget(a2, 393216);
  if ((*(unsigned int (**)(HGLodBlend2 *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2))
    v5 = Target;
  else
    v5 = 394016;
  if (v5 <= 0x6030F)
    v6 = "!!ARBfp1.0     \n"
         "##LEN=00000004f2\n"
         "##                          \n"
         "##                            \n"
         "##                                \n"
         "##                                     \n"
         "##$\n"
         "OUTPUT $o0=result.color;\n"
         "ATTRIB $f0=fragment.texcoord[0];\n"
         "ATTRIB $f1=fragment.texcoord[1];\n"
         "PARAM $p2=program.local[2];\n"
         "PARAM $c0={0.5000000000,1.500000000,0.000000000,0.000000000};\n"
         "##%\n"
         "TEMP r0,r1,r2,r3,r4,r5;\n"
         "##@\n"
         "SUB r0.xy,$f0,$c0.x;\n"
         "FLR r1.xy,r0;\n"
         "FRC r0.xy,r0;\n"
         "ADD r2.xy,r1,$c0.x;\n"
         "##0\n"
         "TEX r2,r2,texture[0],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##0\n"
         "TEX r3,r3,texture[0],RECT;\n"
         "ADD r4.xy,r1,$c0;\n"
         "##0\n"
         "TEX r4,r4,texture[0],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##0\n"
         "TEX r1,r1,texture[0],RECT;\n"
         "SUB r3,r3,r2;\n"
         "MAD r3,r0.x,r3,r2;\n"
         "SUB r1,r1,r4;\n"
         "MAD r4,r0.x,r1,r4;\n"
         "SUB r4,r4,r3;\n"
         "MAD r0,r0.y,r4,r3;\n"
         "SUB r2.xy,$f1,$c0.x;\n"
         "FLR r1.xy,r2;\n"
         "FRC r2.xy,r2;\n"
         "ADD r4.xy,r1,$c0.x;\n"
         "##1\n"
         "TEX r4,r4,texture[1],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##1\n"
         "TEX r3,r3,texture[1],RECT;\n"
         "ADD r5.xy,r1,$c0;\n"
         "##1\n"
         "TEX r5,r5,texture[1],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##1\n"
         "TEX r1,r1,texture[1],RECT;\n"
         "SUB r3,r3,r4;\n"
         "MAD r3,r2.x,r3,r4;\n"
         "SUB r1,r1,r5;\n"
         "MAD r5,r2.x,r1,r5;\n"
         "SUB r5,r5,r3;\n"
         "MAD r2,r2.y,r5,r3;\n"
         "SUB r2,r2,r0;\n"
         "MAD $o0,$p2,r2,r0;\n"
         "END\n"
         "##MD5=5731f160:a6e64969:b14ecbbd:d9ff8c59\n"
         "##SIG=00000000:00000000:00000000:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  else
    v6 = "!!ARBfp1.0     \n"
         "##LEN=0000000490\n"
         "##                          \n"
         "##                            \n"
         "##                                \n"
         "##                                     \n"
         "##$\n"
         "OUTPUT $o0=result.color;\n"
         "ATTRIB $f0=fragment.texcoord[0];\n"
         "ATTRIB $f1=fragment.texcoord[1];\n"
         "PARAM $p2=program.local[2];\n"
         "PARAM $c0={0.5000000000,1.500000000,0.000000000,0.000000000};\n"
         "##%\n"
         "TEMP r0,r1,r2,r3,r4,r5;\n"
         "##@\n"
         "SUB r0.xy,$f0,$c0.x;\n"
         "FLR r1.xy,r0;\n"
         "FRC r0.xy,r0;\n"
         "ADD r2.xy,r1,$c0.x;\n"
         "##0\n"
         "TEX r2,r2,texture[0],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##0\n"
         "TEX r3,r3,texture[0],RECT;\n"
         "ADD r4.xy,r1,$c0;\n"
         "##0\n"
         "TEX r4,r4,texture[0],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##0\n"
         "TEX r1,r1,texture[0],RECT;\n"
         "LRP r3,r0.x,r3,r2;\n"
         "LRP r4,r0.x,r1,r4;\n"
         "LRP r0,r0.y,r4,r3;\n"
         "SUB r2.xy,$f1,$c0.x;\n"
         "FLR r1.xy,r2;\n"
         "FRC r2.xy,r2;\n"
         "ADD r4.xy,r1,$c0.x;\n"
         "##1\n"
         "TEX r4,r4,texture[1],RECT;\n"
         "ADD r3.xy,r1,$c0.yxzw;\n"
         "##1\n"
         "TEX r3,r3,texture[1],RECT;\n"
         "ADD r5.xy,r1,$c0;\n"
         "##1\n"
         "TEX r5,r5,texture[1],RECT;\n"
         "ADD r1.xy,r1,$c0.y;\n"
         "##1\n"
         "TEX r1,r1,texture[1],RECT;\n"
         "LRP r3,r2.x,r3,r4;\n"
         "LRP r5,r2.x,r1,r5;\n"
         "LRP r2,r2.y,r5,r3;\n"
         "LRP $o0,$p2,r2,r0;\n"
         "END\n"
         "##MD5=1af34882:dae2497c:35308843:34541126\n"
         "##SIG=00000000:00000000:00000000:00000000:0001:0003:0006:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  if (v5 - 394016 < 0xF0 || v5 > 0x6043F)
    return "!!ARBfp1.0     \n"
           "##LEN=0000000218\n"
           "##                          \n"
           "##                            \n"
           "##                                \n"
           "##                                     \n"
           "##$\n"
           "OUTPUT $o0=result.color;\n"
           "ATTRIB $f0=fragment.texcoord[0];\n"
           "ATTRIB $f1=fragment.texcoord[1];\n"
           "PARAM $p2=program.local[2];\n"
           "##%\n"
           "TEMP r0,r1;\n"
           "##@\n"
           "##0\n"
           "TEX r0,$f0,texture[0],RECT;\n"
           "##1\n"
           "TEX r1,$f1,texture[1],RECT;\n"
           "LRP $o0,$p2,r1,r0;\n"
           "END\n"
           "##MD5=b7dfa253:e221938a:d4b76add:5cea1bcb\n"
           "##SIG=00000000:00000003:00000000:00000000:0000:0003:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  else
    return v6;
}

uint64_t HGLodBlend2::BindTexture(HGLodBlend2 *this, HGRenderer **a2, int a3)
{
  unsigned int Target;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  Target = HGRenderer::GetTarget(a2[18], 393216);
  if (a3 == 1)
  {
    if (Target > 0x6043F || Target - 394016 <= 0xEF)
    {
      (*((void (**)(HGRenderer **, uint64_t, _QWORD))*a2 + 9))(a2, 1, 0);
      v9 = (*(uint64_t (**)(HGLodBlend2 *, _QWORD))(*(_QWORD *)this + 312))(this, 0);
      (*((void (**)(HGRenderer **, uint64_t, uint64_t))*a2 + 6))(a2, v9, v9);
    }
    HGHandler::TexCoord((HGHandler *)a2, 1, 0, 0, 0);
    v8 = *((_QWORD *)this + 51) + 112;
    goto LABEL_11;
  }
  if (!a3)
  {
    if (Target > 0x6043F || Target - 394016 <= 0xEF)
    {
      (*((void (**)(HGRenderer **, _QWORD, _QWORD))*a2 + 9))(a2, 0, 0);
      v7 = (*(uint64_t (**)(HGLodBlend2 *, _QWORD))(*(_QWORD *)this + 312))(this, 0);
      (*((void (**)(HGRenderer **, uint64_t, uint64_t))*a2 + 6))(a2, v7, v7);
    }
    HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, 0);
    v8 = *((_QWORD *)this + 51) + 48;
LABEL_11:
    (*((void (**)(HGRenderer **, uint64_t))*a2 + 15))(a2, v8);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGLodBlend2::Bind(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *(_QWORD *)(a1 + 408), 1);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *(_QWORD *)(a1 + 408) + 16, 1);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *(_QWORD *)(a1 + 408) + 32, 1);
  return 0;
}

uint64_t HGLodBlend2::RenderTile(float32x4_t **this, HGTile *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  float v9;
  float32x4_t *v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int v15;
  float32x4_t v16;
  float32x4_t *v17;
  float32x4_t *v18;
  uint64_t v19;
  float32x4_t v25;
  float32x4_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  int v29;
  float32x4_t v30;
  float32x4_t *v31;
  int32x4_t v32;
  float32x2_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  uint64_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int32x4_t v39;
  float32x4_t *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x4_t v44;
  float32x4_t *v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int32x4_t v49;
  float32x4_t *v50;
  float32x4_t v51;
  float32x4_t v52;
  uint64_t v53;
  uint64_t v54;
  float32x4_t v55;
  int32x4_t v56;
  float32x4_t *v57;
  float32x4_t v58;
  uint64_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int32x4_t v62;
  float32x4_t *v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int32x4_t v67;
  float32x4_t *v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int32x4_t v72;
  float32x4_t *v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t *v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  uint64_t v88;
  uint64_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int32x4_t v92;
  float32x4_t v93;
  int32x4_t v94;
  float32x4_t v95;
  int32x4_t v96;
  float32x4_t v97;
  int32x4_t v98;
  uint64_t v99;
  int v100;
  float32x4_t v101;
  int32x4_t v102;
  float32x4_t v103;
  int32x4_t v104;
  float32x4_t v105;
  int32x4_t v106;
  float32x4_t v107;
  int32x4_t v108;
  uint64_t v109;
  float32x4_t *v111;
  float32x4_t v112;
  float32x4_t v113;
  uint64_t v114;
  float32x4_t v115;
  int32x4_t v116;
  float32x4_t *v117;
  float32x4_t v118;
  float32x4_t v119;
  int32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  uint64_t v123;
  float32x4_t *v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t *v128;
  float32x4_t v129;
  int32x4_t v130;
  __int32 v131;
  __int32 v132;
  float32x4_t v133;
  int32x4_t v134;
  float32x4_t v135;

  v4 = HGTile::Renderer(a2);
  v5 = ((uint64_t (*)(float32x4_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  v6 = *((_DWORD *)a2 + 1);
  v7 = *((_DWORD *)a2 + 3) - v6;
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = (float)*(int *)a2 + 0.5;
    v10 = this[51];
    v12.f32[0] = v9;
    v12.f32[1] = (float)v6 + 0.5;
    v11 = vmulq_n_f32(v10[7], v9);
    v12.i32[2] = 0;
    v12.i32[3] = 1.0;
    v13 = 0uLL;
    v14 = vaddq_f32(v10[6], vaddq_f32(vaddq_f32(vmulq_n_f32(v10[3], v9), vmulq_n_f32(v10[4], v12.f32[1])), vmulq_f32(v10[5], (float32x4_t)0)));
    v15 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v16 = vaddq_f32(v10[10], vaddq_f32(vaddq_f32(v11, vmulq_n_f32(v10[8], v12.f32[1])), vmulq_f32(v10[9], (float32x4_t)0)));
    v17 = (float32x4_t *)*((_QWORD *)a2 + 2);
    v18 = v17 + 2;
    v19 = 16 * *((int *)a2 + 6);
    __asm { FMOV            V4.4S, #4.0 }
    v25.i64[0] = 0x3F0000003F000000;
    v25.i64[1] = 0x3F0000003F000000;
    while (1)
    {
      v26 = this[51];
      v27 = vaddq_f32(v14, vmulq_f32(v13, v26[4]));
      v28 = vaddq_f32(v16, vmulq_f32(v13, v26[8]));
      if (v15 >= 4)
        break;
      LODWORD(v109) = 0;
      v30 = 0uLL;
      __asm { FMOV            V17.4S, #1.0 }
      if (v15 > 0)
        goto LABEL_13;
LABEL_3:
      v13 = vaddq_f32(v13, _Q17);
      ++v8;
      v18 = (float32x4_t *)((char *)v18 + v19);
      v17 = (float32x4_t *)((char *)v17 + v19);
      if (v8 == v7)
        return 0;
    }
    v29 = 0;
    v30 = 0uLL;
    v31 = v18;
    do
    {
      v77 = this[51];
      v78 = v77[3];
      v79 = vaddq_f32(v27, vmulq_f32(v30, v78));
      v80 = v77[7];
      v81 = vaddq_f32(v28, vmulq_f32(v30, v80));
      v82 = vaddq_f32(v78, v79);
      v83 = vaddq_f32(v80, v81);
      v84 = vaddq_f32(v78, v82);
      v85 = vaddq_f32(v80, v83);
      v86 = vaddq_f32(v78, v84);
      v87 = vaddq_f32(v80, v85);
      v88 = *((_QWORD *)a2 + 10);
      v89 = *((int *)a2 + 22);
      v90 = vsubq_f32(v79, v12);
      if (v5)
      {
        v32 = vaddq_s32(vcvtq_s32_f32(v90), vcltzq_f32(v90));
        v33 = (float32x2_t)vsubq_f32(v90, vcvtq_f32_s32(v32)).u64[0];
        v34 = (float32x4_t *)(v88 + 16 * (v32.i32[0] + v32.i32[1] * (int)v89));
        v35 = vaddq_f32(*v34, vmulq_n_f32(vsubq_f32(v34[1], *v34), v33.f32[0]));
        v36 = (int)v89 + 1;
        v37 = vaddq_f32(v35, vmulq_lane_f32(vsubq_f32(vaddq_f32(v34[v89], vmulq_n_f32(vsubq_f32(v34[v36], v34[v89]), v33.f32[0])), v35), v33, 1));
        v38 = vsubq_f32(v82, v12);
        v39 = vaddq_s32(vcvtq_s32_f32(v38), vcltzq_f32(v38));
        v38.i64[0] = vsubq_f32(v38, vcvtq_f32_s32(v39)).u64[0];
        v40 = (float32x4_t *)(v88 + 16 * (v39.i32[0] + v39.i32[1] * (int)v89));
        v41 = vaddq_f32(*v40, vmulq_n_f32(vsubq_f32(v40[1], *v40), v38.f32[0]));
        v42 = vaddq_f32(v41, vmulq_lane_f32(vsubq_f32(vaddq_f32(v40[v89], vmulq_n_f32(vsubq_f32(v40[v36], v40[v89]), v38.f32[0])), v41), *(float32x2_t *)v38.f32, 1));
        v43 = vsubq_f32(v84, v12);
        v44 = vaddq_s32(vcvtq_s32_f32(v43), vcltzq_f32(v43));
        v43.i64[0] = vsubq_f32(v43, vcvtq_f32_s32(v44)).u64[0];
        v45 = (float32x4_t *)(v88 + 16 * (v44.i32[0] + v44.i32[1] * (int)v89));
        v46 = vaddq_f32(*v45, vmulq_n_f32(vsubq_f32(v45[1], *v45), v43.f32[0]));
        v47 = vaddq_f32(v46, vmulq_lane_f32(vsubq_f32(vaddq_f32(v45[v89], vmulq_n_f32(vsubq_f32(v45[v36], v45[v89]), v43.f32[0])), v46), *(float32x2_t *)v43.f32, 1));
        v48 = vsubq_f32(v86, v12);
        v49 = vaddq_s32(vcvtq_s32_f32(v48), vcltzq_f32(v48));
        v48.i64[0] = vsubq_f32(v48, vcvtq_f32_s32(v49)).u64[0];
        v50 = (float32x4_t *)(v88 + 16 * (v49.i32[0] + v49.i32[1] * (int)v89));
        v51 = vaddq_f32(*v50, vmulq_n_f32(vsubq_f32(v50[1], *v50), v48.f32[0]));
        v52 = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50[v89], vmulq_n_f32(vsubq_f32(v50[v36], v50[v89]), v48.f32[0])), v51), *(float32x2_t *)v48.f32, 1));
        v53 = *((_QWORD *)a2 + 12);
        v54 = *((int *)a2 + 26);
        v55 = vsubq_f32(v81, v12);
        v56 = vaddq_s32(vcvtq_s32_f32(v55), vcltzq_f32(v55));
        v55.i64[0] = vsubq_f32(v55, vcvtq_f32_s32(v56)).u64[0];
        v57 = (float32x4_t *)(v53 + 16 * (v56.i32[0] + v56.i32[1] * (int)v54));
        v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v55.f32[0]));
        v59 = (int)v54 + 1;
        v60 = vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v54], vmulq_n_f32(vsubq_f32(v57[v59], v57[v54]), v55.f32[0])), v58), *(float32x2_t *)v55.f32, 1));
        v61 = vsubq_f32(v83, v12);
        v62 = vaddq_s32(vcvtq_s32_f32(v61), vcltzq_f32(v61));
        v61.i64[0] = vsubq_f32(v61, vcvtq_f32_s32(v62)).u64[0];
        v63 = (float32x4_t *)(v53 + 16 * (v62.i32[0] + v62.i32[1] * (int)v54));
        v64 = vaddq_f32(*v63, vmulq_n_f32(vsubq_f32(v63[1], *v63), v61.f32[0]));
        v65 = vaddq_f32(v64, vmulq_lane_f32(vsubq_f32(vaddq_f32(v63[v54], vmulq_n_f32(vsubq_f32(v63[v59], v63[v54]), v61.f32[0])), v64), *(float32x2_t *)v61.f32, 1));
        v66 = vsubq_f32(v85, v12);
        v67 = vaddq_s32(vcvtq_s32_f32(v66), vcltzq_f32(v66));
        v66.i64[0] = vsubq_f32(v66, vcvtq_f32_s32(v67)).u64[0];
        v68 = (float32x4_t *)(v53 + 16 * (v67.i32[0] + v67.i32[1] * (int)v54));
        v69 = vaddq_f32(*v68, vmulq_n_f32(vsubq_f32(v68[1], *v68), v66.f32[0]));
        v70 = vaddq_f32(v69, vmulq_lane_f32(vsubq_f32(vaddq_f32(v68[v54], vmulq_n_f32(vsubq_f32(v68[v59], v68[v54]), v66.f32[0])), v69), *(float32x2_t *)v66.f32, 1));
        v71 = vsubq_f32(v87, v12);
        v72 = vaddq_s32(vcvtq_s32_f32(v71), vcltzq_f32(v71));
        v71.i64[0] = vsubq_f32(v71, vcvtq_f32_s32(v72)).u64[0];
        v73 = (float32x4_t *)(v53 + 16 * (v72.i32[0] + v72.i32[1] * (int)v54));
        v74 = vaddq_f32(*v73, vmulq_n_f32(vsubq_f32(v73[1], *v73), v71.f32[0]));
        v75 = vaddq_f32(v74, vmulq_lane_f32(vsubq_f32(vaddq_f32(v73[v54], vmulq_n_f32(vsubq_f32(v73[v59], v73[v54]), v71.f32[0])), v74), *(float32x2_t *)v71.f32, 1));
      }
      else
      {
        v91 = vaddq_f32(v90, v25);
        v92 = vcvtq_s32_f32(v91);
        v91.i64[0] = vaddq_s32(v92, vcgtq_f32(vcvtq_f32_s32(v92), v91)).u64[0];
        v37 = *(float32x4_t *)(v88 + 16 * (v91.i32[0] + v91.i32[1] * (int)v89));
        v93 = vaddq_f32(vsubq_f32(v82, v12), v25);
        v94 = vcvtq_s32_f32(v93);
        v93.i64[0] = vaddq_s32(v94, vcgtq_f32(vcvtq_f32_s32(v94), v93)).u64[0];
        v42 = *(float32x4_t *)(v88 + 16 * (v93.i32[0] + v93.i32[1] * (int)v89));
        v95 = vaddq_f32(vsubq_f32(v84, v12), v25);
        v96 = vcvtq_s32_f32(v95);
        v95.i64[0] = vaddq_s32(v96, vcgtq_f32(vcvtq_f32_s32(v96), v95)).u64[0];
        v47 = *(float32x4_t *)(v88 + 16 * (v95.i32[0] + v95.i32[1] * (int)v89));
        v97 = vaddq_f32(vsubq_f32(v86, v12), v25);
        v98 = vcvtq_s32_f32(v97);
        v97.i64[0] = vaddq_s32(v98, vcgtq_f32(vcvtq_f32_s32(v98), v97)).u64[0];
        v52 = *(float32x4_t *)(v88 + 16 * (v97.i32[0] + v97.i32[1] * (int)v89));
        v99 = *((_QWORD *)a2 + 12);
        v100 = *((_DWORD *)a2 + 26);
        v101 = vaddq_f32(vsubq_f32(v81, v12), v25);
        v102 = vcvtq_s32_f32(v101);
        v101.i64[0] = vaddq_s32(v102, vcgtq_f32(vcvtq_f32_s32(v102), v101)).u64[0];
        v60 = *(float32x4_t *)(v99 + 16 * (v101.i32[0] + v101.i32[1] * v100));
        v103 = vaddq_f32(vsubq_f32(v83, v12), v25);
        v104 = vcvtq_s32_f32(v103);
        v103.i64[0] = vaddq_s32(v104, vcgtq_f32(vcvtq_f32_s32(v104), v103)).u64[0];
        v65 = *(float32x4_t *)(v99 + 16 * (v103.i32[0] + v103.i32[1] * v100));
        v105 = vaddq_f32(vsubq_f32(v85, v12), v25);
        v106 = vcvtq_s32_f32(v105);
        v105.i64[0] = vaddq_s32(v106, vcgtq_f32(vcvtq_f32_s32(v106), v105)).u64[0];
        v70 = *(float32x4_t *)(v99 + 16 * (v105.i32[0] + v105.i32[1] * v100));
        v107 = vaddq_f32(vsubq_f32(v87, v12), v25);
        v108 = vcvtq_s32_f32(v107);
        v107.i64[0] = vaddq_s32(v108, vcgtq_f32(vcvtq_f32_s32(v108), v107)).u64[0];
        v75 = *(float32x4_t *)(v99 + 16 * (v107.i32[0] + v107.i32[1] * v100));
      }
      v30 = vaddq_f32(v30, _Q4);
      v76 = v77[2];
      v31[-2] = vaddq_f32(v37, vmulq_f32(vsubq_f32(v60, v37), v76));
      v31[-1] = vaddq_f32(v42, vmulq_f32(vsubq_f32(v65, v42), v76));
      *v31 = vaddq_f32(v47, vmulq_f32(vsubq_f32(v70, v47), v76));
      v31[1] = vaddq_f32(v52, vmulq_f32(v76, vsubq_f32(v75, v52)));
      v31 += 4;
      v29 -= 4;
    }
    while (v15 + v29 > 3);
    LODWORD(v109) = -v29;
    __asm { FMOV            V17.4S, #1.0 }
    if ((int)v109 >= v15)
      goto LABEL_3;
LABEL_13:
    v109 = v109;
    if (v5)
    {
      do
      {
        v111 = this[51];
        v112 = v111[2];
        v113 = vaddq_f32(v28, vmulq_f32(v30, v111[7]));
        v114 = *((int *)a2 + 22);
        v115 = vsubq_f32(vaddq_f32(v27, vmulq_f32(v30, v111[3])), v12);
        v116 = vaddq_s32(vcvtq_s32_f32(v115), vcltzq_f32(v115));
        v115.i64[0] = vsubq_f32(v115, vcvtq_f32_s32(v116)).u64[0];
        v117 = (float32x4_t *)(*((_QWORD *)a2 + 10) + 16 * (v116.i32[0] + v116.i32[1] * (int)v114));
        v118 = v117[v114];
        v119 = vsubq_f32(v113, v12);
        v120 = vaddq_s32(vcvtq_s32_f32(v119), vcltzq_f32(v119));
        v119.i64[0] = vsubq_f32(v119, vcvtq_f32_s32(v120)).u64[0];
        v121 = vaddq_f32(*v117, vmulq_n_f32(vsubq_f32(v117[1], *v117), v115.f32[0]));
        v122 = vmulq_n_f32(vsubq_f32(v117[(int)v114 + 1], v118), v115.f32[0]);
        v123 = *((int *)a2 + 26);
        v124 = (float32x4_t *)(*((_QWORD *)a2 + 12) + 16 * (v120.i32[0] + v120.i32[1] * (int)v123));
        v125 = vsubq_f32(vaddq_f32(v118, v122), v121);
        v126 = vaddq_f32(*v124, vmulq_n_f32(vsubq_f32(v124[1], *v124), v119.f32[0]));
        v127 = vaddq_f32(v121, vmulq_lane_f32(v125, *(float32x2_t *)v115.f32, 1));
        v17[v109] = vaddq_f32(v127, vmulq_f32(v112, vsubq_f32(vaddq_f32(v126, vmulq_lane_f32(vsubq_f32(vaddq_f32(v124[v123], vmulq_n_f32(vsubq_f32(v124[(int)v123 + 1], v124[v123]), v119.f32[0])), v126), *(float32x2_t *)v119.f32, 1)), v127)));
        v30 = vaddq_f32(v30, _Q17);
        ++v109;
      }
      while (v109 < v15);
    }
    else
    {
      do
      {
        v128 = this[51];
        v129 = vaddq_f32(vsubq_f32(vaddq_f32(v27, vmulq_f32(v30, v128[3])), v12), v25);
        v130 = vcvtq_s32_f32(v129);
        v129.i64[0] = vaddq_s32(v130, vcgtq_f32(vcvtq_f32_s32(v130), v129)).u64[0];
        v131 = v129.i32[1];
        v132 = v129.i32[0];
        v133 = vaddq_f32(vsubq_f32(vaddq_f32(v28, vmulq_f32(v30, v128[7])), v12), v25);
        v134 = vcvtq_s32_f32(v133);
        v133.i64[0] = vaddq_s32(v134, vcgtq_f32(vcvtq_f32_s32(v134), v133)).u64[0];
        v135 = *(float32x4_t *)(*((_QWORD *)a2 + 10) + 16 * (v132 + v131 * *((_DWORD *)a2 + 22)));
        v17[v109] = vaddq_f32(v135, vmulq_f32(v128[2], vsubq_f32(*(float32x4_t *)(*((_QWORD *)a2 + 12)+ 16 * (v133.i32[0] + v133.i32[1] * *((_DWORD *)a2 + 26))), v135)));
        v30 = vaddq_f32(v30, _Q17);
        ++v109;
      }
      while (v109 < v15);
    }
    goto LABEL_3;
  }
  return 0;
}

uint64_t HGLodBlend2::GetDOD(HGLodBlend2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  const HGTransform *v5;
  uint64_t v7;
  uint64_t v8;
  HGTransformUtils *v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  HGTransformUtils *v16;
  float v17;
  uint64_t DOD;
  uint64_t v19;
  uint64_t v20;
  float64x2_t v22[9];
  HGRect v23;
  HGRect v24;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(const HGTransform **)&a4.var0;
  if (a3 == 1)
  {
    if ((*(int (**)(HGLodBlend2 *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
    {
      v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      v5 = (const HGTransform *)HGRectGrow((uint64_t)v5, v4, v14);
      v4 = v15;
    }
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((_QWORD *)this + 51) + 112));
    HGTransform::Invert2D((HGTransform *)v22);
    v17 = HGTransformUtils::MinW(v16);
    *(_QWORD *)&v24.var0 = v4;
    DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v22, v5, v24, 0.5, v17);
    v13 = HGRectUnion(0, 0, DOD, v19);
  }
  else
  {
    if (a3)
      return 0;
    if ((*(int (**)(HGLodBlend2 *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
    {
      v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      v5 = (const HGTransform *)HGRectGrow((uint64_t)v5, v4, v7);
      v4 = v8;
    }
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((_QWORD *)this + 51) + 48));
    HGTransform::Invert2D((HGTransform *)v22);
    v10 = HGTransformUtils::MinW(v9);
    *(_QWORD *)&v23.var0 = v4;
    v11 = HGTransformUtils::GetDOD((HGTransformUtils *)v22, v5, v23, 0.5, v10);
    v13 = HGRectUnion(0, 0, v11, v12);
  }
  v20 = v13;
  HGTransform::~HGTransform((HGTransform *)v22);
  return v20;
}

void sub_1B29E5188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29E519C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29E51B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29E51C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGLodBlend2::GetROI(HGLodBlend2 *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  unint64_t v5;
  HGTransformUtils *v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  HGTransformUtils *v14;
  float v15;
  uint64_t ROI;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float64x2_t v22[9];
  HGRect v23;
  HGRect v24;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (a3 == 1)
  {
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((_QWORD *)this + 51) + 112));
    v15 = HGTransformUtils::MinW(v14);
    *(_QWORD *)&v24.var0 = v4;
    ROI = HGTransformUtils::GetROI((HGTransformUtils *)v22, v5, v24, 0.5, v15);
    v12 = HGRectUnion(0, 0, ROI, v17);
  }
  else
  {
    if (a3)
      return 0;
    HGTransform::HGTransform((HGTransform *)v22);
    HGTransform::LoadMatrixf(v22, (float32x2_t *)(*((_QWORD *)this + 51) + 48));
    v9 = HGTransformUtils::MinW(v8);
    *(_QWORD *)&v23.var0 = v4;
    v10 = HGTransformUtils::GetROI((HGTransformUtils *)v22, v5, v23, 0.5, v9);
    v12 = HGRectUnion(0, 0, v10, v11);
  }
  v18 = v12;
  v19 = v13;
  HGTransform::~HGTransform((HGTransform *)v22);
  if ((*(int (**)(HGLodBlend2 *, HGRenderer *))(*(_QWORD *)this + 312))(this, a2) >= 1)
  {
    v20 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v18, v19, v20);
  }
  return v18;
}

void sub_1B29E5334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29E5348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29E535C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29E5370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void HGLodBlend2::~HGLodBlend2(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E6519228;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40104B78CFLL);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E6519228;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40104B78CFLL);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGLodBlend2::SetParameter(HGLodBlend2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HGLodBlend2::GetParameter(HGLodBlend2 *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

int8x8_t HGLodBlend2::GetOutput(uint64_t a1)
{
  uint64_t v1;
  int8x16_t v2;
  __int128 v3;
  float32x2_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int8x16_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x8_t result;

  if (*(_DWORD *)(a1 + 416))
  {
    v1 = *(_QWORD *)(a1 + 408);
    v2 = *(int8x16_t *)v1;
    v3 = *(_OWORD *)(v1 + 192);
    v4 = (float32x2_t)vextq_s8(v2, v2, 8uLL).u64[0];
    *(float32x2_t *)&v5 = vmul_f32(*(float32x2_t *)v1, *(float32x2_t *)(v1 + 176));
    v6 = *(_OWORD *)(v1 + 224);
    *((int8x8_t *)&v5 + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v1 + 240), *(int8x16_t *)(v1 + 240), 8uLL), *(int8x8_t *)&v5);
    *(_OWORD *)(v1 + 48) = v5;
    *(float32x2_t *)&v5 = vmul_f32(*(float32x2_t *)v2.i8, *(float32x2_t *)&v3);
    v7 = *(_QWORD *)(a1 + 408);
    *((int8x8_t *)&v5 + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v7 + 240), *(int8x16_t *)(v7 + 240), 8uLL), *(int8x8_t *)&v5);
    *(_OWORD *)(v7 + 64) = v5;
    *(float32x2_t *)v2.i8 = vmul_f32(*(float32x2_t *)v2.i8, *(float32x2_t *)&v6);
    v8 = *(_QWORD *)(a1 + 408);
    *(float32x2_t *)&v3 = vadd_f32(v4, *(float32x2_t *)v2.i8);
    v2.u64[1] = (unint64_t)vbsl_s8(*(int8x8_t *)(v8 + 240), *(int8x8_t *)v2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v8 + 208), *(int8x16_t *)(v8 + 208), 8uLL));
    *(int8x16_t *)(v8 + 80) = v2;
    v9 = *(_QWORD *)(a1 + 408);
    *((int8x8_t *)&v3 + 1) = vbsl_s8(*(int8x8_t *)(v9 + 240), *(int8x8_t *)&v3, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v9 + 224), *(int8x16_t *)(v9 + 224), 8uLL));
    *(_OWORD *)(v9 + 96) = v3;
    v10 = *(_QWORD *)(a1 + 408);
    v11 = *(int8x16_t *)(v10 + 16);
    v12 = *(_OWORD *)(v10 + 192);
    *(float32x2_t *)&v5 = vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)(v10 + 176));
    v13 = *(_OWORD *)(v10 + 224);
    *((int8x8_t *)&v5 + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v10 + 240), *(int8x16_t *)(v10 + 240), 8uLL), *(int8x8_t *)&v5);
    *(_QWORD *)&v6 = vextq_s8(v11, v11, 8uLL).u64[0];
    *(_OWORD *)(v10 + 112) = v5;
    *(float32x2_t *)&v5 = vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)&v12);
    v14 = *(_QWORD *)(a1 + 408);
    *((int8x8_t *)&v5 + 1) = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v14 + 240), *(int8x16_t *)(v14 + 240), 8uLL), *(int8x8_t *)&v5);
    *(_OWORD *)(v14 + 128) = v5;
    *(float32x2_t *)v11.i8 = vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)&v13);
    v15 = *(_QWORD *)(a1 + 408);
    *(float32x2_t *)&v12 = vadd_f32(*(float32x2_t *)&v6, *(float32x2_t *)v11.i8);
    v11.u64[1] = (unint64_t)vbsl_s8(*(int8x8_t *)(v15 + 240), *(int8x8_t *)v11.i8, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v15 + 208), *(int8x16_t *)(v15 + 208), 8uLL));
    *(int8x16_t *)(v15 + 144) = v11;
    v16 = *(_QWORD *)(a1 + 408);
    result = vbsl_s8(*(int8x8_t *)(v16 + 240), *(int8x8_t *)&v12, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v16 + 224), *(int8x16_t *)(v16 + 224), 8uLL));
    *((int8x8_t *)&v12 + 1) = result;
    *(_OWORD *)(v16 + 160) = v12;
    *(_DWORD *)(a1 + 416) = 0;
  }
  return result;
}

void HGMipmapLevel::HGMipmapLevel(HGMipmapLevel *this)
{
  _QWORD *v1;

  HGNode::HGNode((HGNode *)this);
  *v1 = off_1E6519478;
}

void HGMipmap::HGMipmap(HGMipmap *this)
{
  _QWORD *v2;
  HGTransform *v3;
  HGNode *v4;
  _OWORD *v5;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65196D0;
  v3 = (HGTransform *)(v2 + 56);
  HGTransform::HGTransform((HGTransform *)(v2 + 56));
  HGTransform::HGTransform((HGMipmap *)((char *)this + 592));
  v4 = (HGNode *)HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v4);
  *(_QWORD *)v4 = off_1E6519228;
  *((_DWORD *)v4 + 104) = 1;
  v5 = (_OWORD *)operator new();
  *v5 = 0u;
  v5[1] = 0u;
  v5[2] = 0u;
  v5[3] = xmmword_1B304F230;
  v5[4] = xmmword_1B304F240;
  v5[5] = xmmword_1B304F250;
  v5[6] = xmmword_1B304EFF0;
  v5[7] = xmmword_1B304F230;
  v5[8] = xmmword_1B304F240;
  v5[9] = xmmword_1B304F250;
  v5[10] = xmmword_1B304EFF0;
  v5[11] = xmmword_1B304F230;
  v5[12] = xmmword_1B304F240;
  v5[13] = xmmword_1B304F250;
  v5[14] = xmmword_1B304EFF0;
  v5[15] = xmmword_1B3050F80;
  *((_QWORD *)v4 + 51) = v5;
  (*(void (**)(HGNode *, _QWORD, uint64_t))(*(_QWORD *)v4 + 136))(v4, 0, 1);
  (*(void (**)(HGNode *, uint64_t, uint64_t))(*(_QWORD *)v4 + 136))(v4, 1, 1);
  *((_DWORD *)v4 + 4) |= 1u;
  *((_QWORD *)this + 51) = v4;
  (*(void (**)(HGNode *, uint64_t))(*(_QWORD *)v4 + 160))(v4, 1);
  *((_QWORD *)this + 52) = 0;
  *((_QWORD *)this + 53) = 0;
  *((_DWORD *)this + 108) = 0;
  *((_DWORD *)this + 110) = 2;
  HGTransform::LoadIdentity((HGMipmap *)((char *)this + 592));
  HGTransform::LoadIdentity(v3);
  *(_OWORD *)((char *)this + 740) = HGRectInfinite;
}

void sub_1B29E57B0(_Unwind_Exception *a1)
{
  HGNode *v1;
  HGTransform *v2;
  HGTransform *v3;
  void *v4;

  HGObject::operator delete(v4);
  HGTransform::~HGTransform(v3);
  HGTransform::~HGTransform(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMipmap::~HGMipmap(HGMipmap *this)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E65196D0;
  if (*((_DWORD *)this + 107))
  {
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(*((_QWORD *)this + 52) + 8 * v2);
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v3 + 120))(v3, 0, 0);
      v4 = *(_QWORD *)(*((_QWORD *)this + 52) + 8 * v2);
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      ++v2;
    }
    while (v2 < *((unsigned int *)this + 107));
    free(*((void **)this + 52));
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 51) + 24))(*((_QWORD *)this + 51));
  HGTransform::~HGTransform((HGMipmap *)((char *)this + 592));
  HGTransform::~HGTransform((HGMipmap *)((char *)this + 448));
  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;

  HGMipmap::~HGMipmap(this);
  HGObject::operator delete(v1);
}

uint64_t HGMipmap::SetTransform(HGMipmap *this, HGTransform *a2, HGTransform *a3, float a4)
{
  HGTransform *v8;
  uint64_t v9;
  HGTransform *v10;

  v8 = (HGMipmap *)((char *)this + 448);
  if (!HGTransform::IsEqual((HGMipmap *)((char *)this + 448), a2))
  {
    HGTransform::LoadTransform(v8, a2);
    v9 = 1;
    v10 = (HGMipmap *)((char *)this + 592);
    if (a3)
      goto LABEL_3;
LABEL_5:
    HGTransform::LoadTransform(v10, v8);
    HGTransform::Invert2D(v10);
    goto LABEL_6;
  }
  v9 = 0;
  v10 = (HGMipmap *)((char *)this + 592);
  if (!a3)
    goto LABEL_5;
LABEL_3:
  HGTransform::LoadTransform(v10, a3);
LABEL_6:
  *((float *)this + 184) = a4;
  return v9;
}

uint64_t HGMipmap::SetParameter(HGMipmap *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  if (*((float *)this + 108) == a3)
    return 0;
  *((float *)this + 108) = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HGMipmap::SetInput(HGNode *this, int a2, HGNode *a3)
{
  uint64_t result;

  if (a2)
    return 0xFFFFFFFFLL;
  result = HGNode::SetInput(this, 0, a3);
  if ((_DWORD)result == 1)
    *((_DWORD *)this + 109) = 1;
  return result;
}

uint64_t HGMipmap::SetLodFilter(uint64_t a1, uint64_t a2, char *a3)
{
  if (*(_DWORD *)(a1 + 440) == (_DWORD)a2)
    return 0;
  *(_DWORD *)(a1 + 440) = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  return 1;
}

HGNode *HGMipmap::GetLevelOfDetail(HGMipmap *this, HGRenderer *a2, unsigned int a3)
{
  HGNode *result;
  HGNode *Input;
  uint64_t DOD;
  uint64_t v9;
  unsigned int Target;
  double *MatrixPtr;
  BOOL v12;
  HGNode *v13;
  HGNode *v14;
  int v15;
  int TextureWrapMode;
  uint64_t v17;
  HGLodFilter *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  void *v27;
  unsigned int v28;
  HGLodFilter *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  float32x4_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  result = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (!result)
    return result;
  Input = result;
  DOD = 0;
  v9 = 0;
  v39 = 0uLL;
  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target > 0x6043F
    || Target - 394016 < 0xF0
    || (MatrixPtr = (double *)HGTransform::GetMatrixPtr((HGMipmap *)((char *)this + 592)), *((float *)this + 184) <= 1.0)
    || MatrixPtr[3] == 0.0
    && MatrixPtr[7] == 0.0
    && (MatrixPtr[11] == 0.0
      ? (v12 = *MatrixPtr * *MatrixPtr + MatrixPtr[1] * MatrixPtr[1] == MatrixPtr[4] * MatrixPtr[4]
                                                                      + MatrixPtr[5] * MatrixPtr[5])
      : (v12 = 0),
        v12))
  {
    if (*((_DWORD *)Input + 3) == -1814136143)
    {
      TextureWrapMode = HGTextureWrap::GetTextureWrapMode((HGTextureWrap *)Input);
      HGTextureWrap::GetTextureBorderColor((HGTextureWrap *)Input, v39.f32);
      v14 = 0;
      v15 = 1;
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v39)))) & 1) == 0
        && !TextureWrapMode)
      {
        Input = HGRenderer::GetInput(a2, Input, 0);
        v14 = 0;
      }
      if (!*((_DWORD *)this + 109))
      {
LABEL_20:
        if (*((_DWORD *)this + 107) > a3)
          goto LABEL_22;
      }
    }
    else
    {
      v14 = 0;
      v15 = 1;
      if (!*((_DWORD *)this + 109))
        goto LABEL_20;
    }
  }
  else
  {
    v13 = (HGNode *)HGObject::operator new(0x1B0uLL);
    HGLodPreFilter::HGLodPreFilter(v13, (uint64_t)this, 0);
    (*(void (**)(HGNode *, _QWORD, HGNode *))(*(_QWORD *)v13 + 120))(v13, 0, Input);
    v14 = (HGNode *)HGObject::operator new(0x1B0uLL);
    HGLodPreFilter::HGLodPreFilter(v14, (uint64_t)this, 1);
    (*(void (**)(HGNode *, _QWORD, HGNode *))(*(_QWORD *)v14 + 120))(v14, 0, v13);
    (*(void (**)(HGNode *))(*(_QWORD *)v13 + 24))(v13);
    v15 = 0;
    if (!*((_DWORD *)this + 109))
      goto LABEL_20;
  }
  DOD = HGRenderer::GetDOD(a2, Input);
  v9 = v17;
  *(_QWORD *)((char *)this + 740) = DOD;
  *(_QWORD *)((char *)this + 748) = v17;
LABEL_22:
  if (!v15)
    Input = v14;
  if (*((_DWORD *)this + 106))
  {
    if (!*((_DWORD *)this + 109))
    {
      if ((v15 & 1) != 0)
        goto LABEL_34;
LABEL_33:
      (*(void (**)(HGNode *))(*(_QWORD *)v14 + 24))(v14);
      goto LABEL_34;
    }
  }
  else
  {
    *((_DWORD *)this + 106) = 8;
    *((_QWORD *)this + 52) = malloc_type_malloc(0x40uLL, 0x2004093837F09uLL);
    v18 = (HGLodFilter *)HGObject::operator new(0x250uLL);
    HGLodFilter::HGLodFilter(v18);
    **((_QWORD **)this + 52) = v18;
    *((_DWORD *)this + 107) = 1;
    *((_DWORD *)this + 109) = 1;
  }
  (*(void (**)(_QWORD, _QWORD, HGNode *))(***((_QWORD ***)this + 52) + 120))(**((_QWORD **)this + 52), 0, Input);
  HGLodFilter::SetLevel(**((_QWORD **)this + 52), DOD, v9, DOD, v9, 0, 0);
  if (*((_DWORD *)this + 107) >= 2u)
  {
    v19 = 0;
    do
    {
      v20 = *((_QWORD *)this + 52) + 8 * v19;
      v21 = *(_QWORD *)(v20 + 8);
      v22 = HGRenderer::GetDOD(a2, *(HGNode **)v20);
      HGLodFilter::SetLevel(v21, DOD, v9, v22, v23, v19 + 1, *((_DWORD *)this + 110));
      v24 = v19 + 2;
      ++v19;
    }
    while (v24 < *((unsigned int *)this + 107));
  }
  *((_DWORD *)this + 109) = 0;
  if ((v15 & 1) == 0)
    goto LABEL_33;
LABEL_34:
  v25 = *((_DWORD *)this + 107);
  if (v25 > a3)
    return *(HGNode **)(*((_QWORD *)this + 52) + 8 * a3);
  while (1)
  {
    v26 = *((_DWORD *)this + 106);
    if (v26 <= v25)
    {
      v27 = (void *)*((_QWORD *)this + 52);
      v28 = v26 + 8;
      *((_DWORD *)this + 106) = v28;
      *((_QWORD *)this + 52) = malloc_type_realloc(v27, 8 * v28, 0x2004093837F09uLL);
    }
    v29 = (HGLodFilter *)HGObject::operator new(0x250uLL);
    HGLodFilter::HGLodFilter(v29);
    v30 = 8 * v25;
    *(_QWORD *)(*((_QWORD *)this + 52) + v30) = v29;
    v31 = *((_QWORD *)this + 52);
    v32 = *(_QWORD *)(v31 + v30);
    v33 = v25 - 1;
    v34 = HGRenderer::GetDOD(a2, *(HGNode **)(v31 + 8 * v33));
    v36 = HGLodFilter::SetLevel(v32, DOD, v9, v34, v35, v25, *((_DWORD *)this + 110));
    v37 = *((_QWORD *)this + 52);
    v38 = *(_QWORD *)(v37 + 8 * v25);
    if (v36 == -1)
      break;
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v38 + 120))(v38, 0, *(_QWORD *)(v37 + 8 * v33));
    *((_DWORD *)this + 107) = ++v25;
    if (v25 > a3)
      return *(HGNode **)(*((_QWORD *)this + 52) + 8 * a3);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v38 + 24))(v38);
  return 0;
}

void sub_1B29E5EB4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29E5EC8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29E5EDC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29E5EF0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGMipmap::GetOutput(HGMipmap *this, HGRenderer *a2)
{
  uint64_t v2;
  float v5;
  uint64_t v6;
  uint64_t v7;
  double *MatrixPtr;
  float v9;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  double *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  _QWORD v21[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;

  if (*((float *)this + 108) >= 0.0)
    v5 = *((float *)this + 108);
  else
    v5 = 0.0;
  LODWORD(v2) = vcvtms_s32_f32(v5);
  v6 = (*(uint64_t (**)(HGMipmap *, HGRenderer *, uint64_t))(*(_QWORD *)this + 584))(this, a2, v2);
  if (!v6)
    return 0;
  v7 = v6;
  HGTransform::HGTransform((HGTransform *)v30);
  (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v7 + 576))(v21, v7, 0);
  v35 = v26;
  v36 = v27;
  v37 = v28;
  v38 = v29;
  v31 = v22;
  v32 = v23;
  v33 = v24;
  v34 = v25;
  HGTransform::~HGTransform((HGTransform *)v21);
  MatrixPtr = (double *)HGTransform::GetMatrixPtr((HGTransform *)v30);
  (*(void (**)(_QWORD, _QWORD, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 0, v7);
  v9 = *MatrixPtr;
  v10 = MatrixPtr[5];
  v11 = MatrixPtr[12];
  v12 = MatrixPtr[13];
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, v9, v10, v11, v12);
  v13 = (*(uint64_t (**)(HGMipmap *, HGRenderer *, _QWORD))(*(_QWORD *)this + 584))(this, a2, (v2 + 1));
  (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v13 + 576))(v21, v13, 0);
  v35 = v26;
  v36 = v27;
  v37 = v28;
  v38 = v29;
  v31 = v22;
  v32 = v23;
  v33 = v24;
  v34 = v25;
  HGTransform::~HGTransform((HGTransform *)v21);
  v14 = (double *)HGTransform::GetMatrixPtr((HGTransform *)v30);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 51) + 120))(*((_QWORD *)this + 51), 1, v13);
  v15 = *v14;
  v16 = v14[5];
  v17 = v14[12];
  v18 = v14[13];
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, v15, v16, v17, v18);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 2, v5 - (float)(int)v2, v5 - (float)(int)v2, v5 - (float)(int)v2, v5 - (float)(int)v2);
  v19 = *((_QWORD *)this + 51);
  HGTransform::~HGTransform((HGTransform *)v30);
  return v19;
}

void sub_1B29E610C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  HGTransform::~HGTransform((HGTransform *)&a27);
  _Unwind_Resume(a1);
}

void sub_1B29E6120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  HGTransform::~HGTransform((HGTransform *)&a27);
  _Unwind_Resume(a1);
}

void sub_1B29E6134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  HGTransform::~HGTransform((HGTransform *)&a27);
  _Unwind_Resume(a1);
}

void sub_1B29E6148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  HGTransform::~HGTransform((HGTransform *)&a27);
  _Unwind_Resume(a1);
}

uint64_t HGMipmap::GetRect(HGMipmap *this, unsigned int a2, HGRect a3, char a4, int a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  if (*((_DWORD *)this + 107) <= (signed int)a2)
    return 0;
  if ((a4 & 1) != 0)
  {
    if ((a2 & 0x80000000) == 0)
    {
      v7 = 0;
      v8 = 8 * (a2 + 1);
      do
      {
        *(_QWORD *)&a3.var0 = HGLodFilter::GetRect(*(HGLodFilter **)(*((_QWORD *)this + 52) + v7), a3, 1, a5);
        *(_QWORD *)&a3.var2 = v9;
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  else if ((a2 & 0x80000000) == 0)
  {
    v11 = 8 * a2;
    do
    {
      *(_QWORD *)&a3.var0 = HGLodFilter::GetRect(*(HGLodFilter **)(*((_QWORD *)this + 52) + v11), a3, 0, a5);
      *(_QWORD *)&a3.var2 = v12;
      v11 -= 8;
    }
    while (v11 != -8);
  }
  return *(_QWORD *)&a3.var0;
}

void HGMipmap::GetTransform(HGMipmap *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, HGTransform *a4@<X8>)
{
  uint64_t v4;

  if (*((_DWORD *)this + 107) <= a2)
  {
    HGTransform::HGTransform(a4);
  }
  else
  {
    v4 = *(_QWORD *)(*((_QWORD *)this + 52) + 8 * a2);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 576))(v4, a3);
  }
}

void soMaxFlow::soMaxFlow(soMaxFlow *this, int a2, unint64_t *a3)
{
  soMaxFlow::Impl *v6;

  *(_QWORD *)this = &off_1E6519988;
  v6 = (soMaxFlow::Impl *)operator new();
  soMaxFlow::Impl::Impl(v6, a2, a3);
  *((_QWORD *)this + 1) = v6;
}

void sub_1B29E62D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10B0C406F4980B6);
  _Unwind_Resume(a1);
}

void soMaxFlow::~soMaxFlow(soMaxFlow *this, void *a2)
{
  HGMemory **v2;

  *(_QWORD *)this = &off_1E6519988;
  v2 = (HGMemory **)*((_QWORD *)this + 1);
  if (v2)
  {
    soMaxFlow::Impl::~Impl(v2, a2);
    MEMORY[0x1B5E29170]();
  }
}

{
  HGMemory **v2;

  *(_QWORD *)this = &off_1E6519988;
  v2 = (HGMemory **)*((_QWORD *)this + 1);
  if (v2)
  {
    soMaxFlow::Impl::~Impl(v2, a2);
    MEMORY[0x1B5E29170]();
  }
  JUMPOUT(0x1B5E29170);
}

double soMaxFlow::Reset(soMaxFlow *this)
{
  uint64_t v1;
  size_t v2;
  double result;

  v1 = *((_QWORD *)this + 1);
  v2 = *(int *)(v1 + 68) * (uint64_t)*(int *)(v1 + 64);
  bzero(*(void **)v1, v2 << 6);
  bzero(*(void **)(v1 + 8), 8 * v2);
  memset(*(void **)(v1 + 16), 255, v2);
  bzero(*(void **)(v1 + 24), v2);
  memset(*(void **)(v1 + 32), 255, v2);
  v2 *= 4;
  memset(*(void **)(v1 + 40), 255, v2);
  bzero(*(void **)(v1 + 48), v2);
  *(_QWORD *)(v1 + 72) = 0;
  result = NAN;
  *(_QWORD *)(v1 + 80) = -1;
  *(_QWORD *)(v1 + 104) = *(_QWORD *)(v1 + 96);
  return result;
}

float soMaxFlow::Run(HGProfiler ***this)
{
  return soMaxFlow::Impl::solve(this[1]);
}

float soMaxFlow::Impl::solve(HGProfiler **this)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  HGProfiler *v8;
  HGProfiler *v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  HGProfiler *v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  HGProfiler::start(this[11]);
  this[10] = (HGProfiler *)-1;
  v2 = *((_DWORD *)this + 16);
  v3 = *((_DWORD *)this + 17);
  if (v3 * v2 >= 1)
  {
    v4 = 0;
    do
    {
      if (*((_BYTE *)this[3] + v4))
      {
        *((_BYTE *)this[2] + v4) = -2;
        *((_QWORD *)this[1] + v4) = 1;
        v5 = *((unsigned int *)this + 21);
        if ((v5 & 0x80000000) != 0)
          *((_DWORD *)this + 20) = v4;
        else
          *((_DWORD *)this[5] + v5) = v4;
        *((_DWORD *)this + 21) = v4;
        v2 = *((_DWORD *)this + 16);
        v3 = *((_DWORD *)this + 17);
      }
      ++v4;
    }
    while (v4 < v3 * v2);
  }
  while (1)
  {
    v20 = -1;
    soMaxFlow::Impl::GrowthStage((uint64_t)this, &v20);
    v6 = v20;
    if ((v20 & 0x80000000) != 0)
      break;
    v7 = HIDWORD(v20);
    if (v20 < 0)
      break;
    ++*((_DWORD *)this + 18);
    v8 = this[2];
    v9 = *this;
    if (*((char *)v8 + v6) < 0)
    {
      v11 = 3.4028e38;
      v12 = v6;
    }
    else
    {
      v10 = *((unsigned __int8 *)v8 + v6);
      v11 = 3.4028e38;
      v12 = v6;
      do
      {
        v12 = *((int *)v9 + 16 * v12 + v10 + 8);
        v11 = fminf(v11, *((float *)v9 + 16 * v12 + (((_BYTE)v10 + 4) & 7)));
        v10 = *((unsigned __int8 *)v8 + v12);
      }
      while ((*((char *)v8 + v12) & 0x80000000) == 0);
    }
    v13 = this[6];
    v14 = (uint64_t)v9 + 64 * v6 + 4 * v7;
    v15 = fminf(fminf(v11, fabsf(*((float *)v13 + v12))), *(float *)v14);
    v16 = *(int *)(v14 + 32);
    if ((*((char *)v8 + v16) & 0x80000000) == 0)
    {
      v17 = *((unsigned __int8 *)v8 + v16);
      do
      {
        v18 = (uint64_t)v9 + 64 * v16 + 4 * v17;
        v15 = fminf(v15, *(float *)v18);
        v16 = *(int *)(v18 + 32);
        v17 = *((unsigned __int8 *)v8 + v16);
      }
      while ((*((char *)v8 + v16) & 0x80000000) == 0);
    }
    soMaxFlow::Impl::UpdateFlow((uint64_t)this, (int *)&v20, fminf(v15, fabsf(*((float *)v13 + v16))));
    soMaxFlow::Impl::AdoptionStage((soMaxFlow::Impl *)this);
  }
  HGProfiler::stop(this[11]);
  return *((float *)this + 19);
}

uint64_t soMaxFlow::SetNodeWeights(soMaxFlow *this, int a2, int a3, float a4, float a5)
{
  uint64_t v5;
  signed int v6;
  char v7;

  v5 = *((_QWORD *)this + 1);
  v6 = (((_BYTE)a2 + (*(int *)(v5 + 56) >> 1)) & 7 | ((a2 + (*(int *)(v5 + 56) >> 1)) >> 3 << 6))
     + ((a3 + (*(int *)(v5 + 60) >> 1)) & 0xFFFFFFF8) * *(_DWORD *)(v5 + 64)
     + 8 * ((a3 + (*(int *)(v5 + 60) >> 1)) & 7);
  *(float *)(*(_QWORD *)(v5 + 48) + 4 * v6) = a4 - a5;
  if ((float)(a4 - a5) != 0.0)
  {
    if ((float)(a4 - a5) > 0.0)
      v7 = 1;
    else
      v7 = 2;
    *(_BYTE *)(*(_QWORD *)(v5 + 24) + v6) = v7;
  }
  if (a4 >= a5)
    a4 = a5;
  *(float *)(v5 + 76) = a4 + *(float *)(v5 + 76);
  return 1;
}

uint64_t soMaxFlow::SetEdgeCapacity(uint64_t a1, int a2, int a3, int a4, float a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;

  v5 = *(_QWORD *)(a1 + 8);
  v6 = (int)((((_BYTE)a3 + (*(int *)(v5 + 56) >> 1)) & 7 | ((a3 + (*(int *)(v5 + 56) >> 1)) >> 3 << 6))
           + ((a4 + (*(int *)(v5 + 60) >> 1)) & 0xFFFFFFF8) * *(_DWORD *)(v5 + 64)
           + 8 * ((a4 + (*(int *)(v5 + 60) >> 1)) & 7));
  v7 = v6 << 6;
  v8 = 4 * a2;
  *(float *)(*(_QWORD *)v5 + (v6 << 6) + v8) = a5;
  *(_BYTE *)(*(_QWORD *)(v5 + 32) + v6) = *(_BYTE *)(*(_QWORD *)(v5 + 32) + v6) & ~(1 << a2) | ((a5 == 0.0) << a2);
  v9 = *(_DWORD *)((char *)&Edge::OffsetX + v8) + a3 + (*(int *)(v5 + 56) >> 1);
  LODWORD(v6) = *(_DWORD *)((char *)&Edge::OffsetY + v8) + a4 + (*(int *)(v5 + 60) >> 1);
  *(_DWORD *)(*(_QWORD *)v5 + v8 + v7 + 32) = (v9 & 7 | (v9 >> 3 << 6))
                                            + (v6 & 0xFFFFFFF8) * *(_DWORD *)(v5 + 64)
                                            + 8 * (v6 & 7);
  return 1;
}

uint64_t soMaxFlow::StoreGraphCutToMask(uint64_t this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, unsigned __int8 a8, char a9)
{
  uint64_t v9;
  uint64_t i;
  uint64_t v12;
  unsigned int v13;
  unsigned __int8 v15;

  v9 = *(_QWORD *)(this + 8);
  if (*(int *)(v9 + 64) - (uint64_t)*(int *)(v9 + 56) == a3
    && a4
    && *(int *)(v9 + 68) - (uint64_t)*(int *)(v9 + 60) == a4
    && a3 != 0)
  {
    for (i = 0; i != a4; ++i)
    {
      v12 = 0;
      do
      {
        v13 = a2[v12];
        if (v13 >= a6 && v13 <= a7)
        {
          if (*(_BYTE *)(*(_QWORD *)(v9 + 24)
                        + (int)((((_BYTE)v12 + (*(int *)(v9 + 56) >> 1)) & 7 | ((v12 + (*(int *)(v9 + 56) >> 1)) >> 3 << 6))
                              + ((i + (*(int *)(v9 + 60) >> 1)) & 0xFFFFFFF8) * *(_DWORD *)(v9 + 64)
                              + 8 * ((i + (*(int *)(v9 + 60) >> 1)) & 7))) == 1)
            v15 = a9;
          else
            v15 = a8;
          a2[v12] = v15;
        }
        ++v12;
      }
      while (a3 != v12);
      a2 += a5;
    }
  }
  return this;
}

soMaxFlow::Impl *soMaxFlow::Impl::Impl(soMaxFlow::Impl *this, int a2, unint64_t *a3)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unint64_t *v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t *v12;
  HGMemory *v13;
  unint64_t *v14;
  unint64_t *v15;
  size_t v16;
  HGProfiler *v17;

  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 9) = 1;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  v4 = 8 - (a2 & 7);
  v5 = 8 - (a3 & 7);
  *((_DWORD *)this + 14) = v4;
  *((_DWORD *)this + 15) = v5;
  if ((a2 & 7) == 7)
  {
    v4 = 9;
    *((_DWORD *)this + 14) = 9;
  }
  if ((a3 & 7) == 7)
  {
    v5 = 9;
    *((_DWORD *)this + 15) = 9;
  }
  v6 = v4 + a2;
  v7 = v5 + (_DWORD)a3;
  *((_DWORD *)this + 16) = v6;
  *((_DWORD *)this + 17) = v7;
  v8 = v7 * v6;
  *(_QWORD *)this = HGMemory::allocate((HGMemory *)((uint64_t)(v7 * v6) << 6), 0, a3);
  *((_QWORD *)this + 1) = HGMemory::allocate((HGMemory *)(8 * v8), 0, v9);
  *((_QWORD *)this + 2) = HGMemory::allocate((HGMemory *)v8, 0, v10);
  *((_QWORD *)this + 3) = HGMemory::allocate((HGMemory *)v8, 0, v11);
  *((_QWORD *)this + 4) = HGMemory::allocate((HGMemory *)v8, 0, v12);
  v13 = (HGMemory *)(4 * v8);
  *((_QWORD *)this + 5) = HGMemory::allocate(v13, 0, v14);
  *((_QWORD *)this + 6) = HGMemory::allocate(v13, 0, v15);
  v16 = *((int *)this + 17) * (uint64_t)*((int *)this + 16);
  bzero(*(void **)this, v16 << 6);
  bzero(*((void **)this + 1), 8 * v16);
  memset(*((void **)this + 2), 255, v16);
  bzero(*((void **)this + 3), v16);
  memset(*((void **)this + 4), 255, v16);
  v16 *= 4;
  memset(*((void **)this + 5), 255, v16);
  bzero(*((void **)this + 6), v16);
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = -1;
  *((_QWORD *)this + 13) = *((_QWORD *)this + 12);
  v17 = (HGProfiler *)operator new();
  HGProfiler::HGProfiler(v17);
  *((_QWORD *)this + 11) = v17;
  return this;
}

void sub_1B29E6994(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  uint64_t v4;
  void *v6;

  v4 = v2;
  MEMORY[0x1B5E29170](v4, 0x1000C40451B5BE8);
  v6 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 104) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void soMaxFlow::Impl::~Impl(HGMemory **this, void *a2)
{
  HGMemory *v3;
  HGMemory *v4;
  HGMemory *v5;
  HGMemory *v6;
  HGMemory *v7;
  HGMemory *v8;
  HGMemory *v9;
  HGMemory *v10;
  HGMemory *v11;

  v3 = *this;
  if (v3)
    HGMemory::release(v3, a2);
  v4 = this[1];
  if (v4)
    HGMemory::release(v4, a2);
  v5 = this[2];
  if (v5)
    HGMemory::release(v5, a2);
  v6 = this[3];
  if (v6)
    HGMemory::release(v6, a2);
  v7 = this[4];
  if (v7)
    HGMemory::release(v7, a2);
  v8 = this[5];
  if (v8)
    HGMemory::release(v8, a2);
  v9 = this[6];
  if (v9)
    HGMemory::release(v9, a2);
  v10 = this[11];
  if (v10)
    MEMORY[0x1B5E29170](v10, 0x1000C40451B5BE8);
  v11 = this[12];
  if (v11)
  {
    this[13] = v11;
    operator delete(v11);
  }
}

uint64_t soMaxFlow::Impl::GrowthStage(uint64_t result, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  _DWORD *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _DWORD *v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _DWORD *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  _DWORD *v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD *v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  uint64_t v56;
  uint64_t v57;
  _DWORD *v58;
  uint64_t v59;
  uint64_t v60;
  _DWORD *v61;
  uint64_t v62;
  uint64_t v63;
  _DWORD *v64;
  int v65;

  v2 = *(unsigned int *)(result + 80);
  if ((v2 & 0x80000000) != 0)
  {
LABEL_101:
    *(_DWORD *)(result + 84) = v2;
    return result;
  }
  while (1)
  {
    v5 = *(_QWORD *)(result + 16);
    if (*(unsigned __int8 *)(v5 + v2) == 255)
      goto LABEL_4;
    v6 = (int *)(*(_QWORD *)(result + 8) + 8 * v2);
    v7 = *(_QWORD *)(result + 24);
    v8 = *(_QWORD *)(result + 32);
    v9 = *(_BYTE *)(v7 + v2);
    v10 = *v6;
    v11 = v6[1];
    v12 = v10 + 1;
    v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 32);
    if (v9 == 2)
    {
      if ((*(_BYTE *)(v8 + v13) & 0x10) == 0)
      {
        if (*(unsigned __int8 *)(v5 + v13) == 255)
        {
          *(_BYTE *)(v7 + v13) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 4;
          v14 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
          *v14 = v12;
          v14[1] = v11;
          v15 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v15 + 4 * v13) & 0x80000000) != 0)
          {
            *(_DWORD *)(v15 + 4 * *(int *)(result + 84)) = v13;
            *(_DWORD *)(result + 84) = v13;
          }
        }
        else if (*(_BYTE *)(v7 + v13) != 2)
        {
          *a2 = v13;
          a2[1] = 4;
          return result;
        }
      }
      v16 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 36);
      if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v16) & 0x20) == 0)
      {
        v17 = *(_QWORD *)(result + 24);
        if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v16) == 255)
        {
          *(_BYTE *)(v17 + v16) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v16) = 5;
          v21 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v16);
          *v21 = v12;
          v21[1] = v11;
          v22 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v22 + 4 * v16) & 0x80000000) != 0)
          {
            *(_DWORD *)(v22 + 4 * *(int *)(result + 84)) = v16;
            *(_DWORD *)(result + 84) = v16;
          }
        }
        else if (*(_BYTE *)(v17 + v16) != 2)
        {
          *a2 = v16;
          a2[1] = 5;
          return result;
        }
      }
      v23 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 40);
      if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v23) & 0x40) == 0)
      {
        v24 = *(_QWORD *)(result + 24);
        if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v23) == 255)
        {
          *(_BYTE *)(v24 + v23) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v23) = 6;
          v27 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v23);
          *v27 = v12;
          v27[1] = v11;
          v28 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v28 + 4 * v23) & 0x80000000) != 0)
          {
            *(_DWORD *)(v28 + 4 * *(int *)(result + 84)) = v23;
            *(_DWORD *)(result + 84) = v23;
          }
        }
        else if (*(_BYTE *)(v24 + v23) != 2)
        {
          *a2 = v23;
          a2[1] = 6;
          return result;
        }
      }
      v29 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 44);
      if ((*(char *)(*(_QWORD *)(result + 32) + v29) & 0x80000000) == 0)
      {
        v30 = *(_QWORD *)(result + 24);
        if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v29) == 255)
        {
          *(_BYTE *)(v30 + v29) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v29) = 7;
          v31 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v29);
          *v31 = v12;
          v31[1] = v11;
          v32 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v32 + 4 * v29) & 0x80000000) != 0)
          {
            *(_DWORD *)(v32 + 4 * *(int *)(result + 84)) = v29;
            *(_DWORD *)(result + 84) = v29;
          }
        }
        else if (*(_BYTE *)(v30 + v29) != 2)
        {
          *a2 = v29;
          a2[1] = 7;
          return result;
        }
      }
      v33 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 48);
      if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v33) & 1) == 0)
      {
        v34 = *(_QWORD *)(result + 24);
        if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v33) == 255)
        {
          *(_BYTE *)(v34 + v33) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v33) = 0;
          v35 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v33);
          *v35 = v12;
          v35[1] = v11;
          v36 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v36 + 4 * v33) & 0x80000000) != 0)
          {
            *(_DWORD *)(v36 + 4 * *(int *)(result + 84)) = v33;
            *(_DWORD *)(result + 84) = v33;
          }
        }
        else if (*(_BYTE *)(v34 + v33) != 2)
        {
          *a2 = v33;
          a2[1] = 0;
          return result;
        }
      }
      v37 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 52);
      if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v37) & 2) == 0)
      {
        v38 = *(_QWORD *)(result + 24);
        if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v37) == 255)
        {
          *(_BYTE *)(v38 + v37) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v37) = 1;
          v39 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v37);
          *v39 = v12;
          v39[1] = v11;
          v40 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v40 + 4 * v37) & 0x80000000) != 0)
          {
            *(_DWORD *)(v40 + 4 * *(int *)(result + 84)) = v37;
            *(_DWORD *)(result + 84) = v37;
          }
        }
        else if (*(_BYTE *)(v38 + v37) != 2)
        {
          *a2 = v37;
          a2[1] = 1;
          return result;
        }
      }
      v41 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 56);
      if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v41) & 4) == 0)
      {
        v42 = *(_QWORD *)(result + 24);
        if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v41) == 255)
        {
          *(_BYTE *)(v42 + v41) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v41) = 2;
          v43 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v41);
          *v43 = v12;
          v43[1] = v11;
          v44 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v44 + 4 * v41) & 0x80000000) != 0)
          {
            *(_DWORD *)(v44 + 4 * *(int *)(result + 84)) = v41;
            *(_DWORD *)(result + 84) = v41;
          }
        }
        else if (*(_BYTE *)(v42 + v41) != 2)
        {
          *a2 = v41;
          a2[1] = 2;
          return result;
        }
      }
      v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 60);
      if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v13) & 8) == 0)
      {
        v45 = *(_QWORD *)(result + 24);
        if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) == 255)
        {
          *(_BYTE *)(v45 + v13) = 2;
          *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 3;
          v46 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
          *v46 = v12;
          v46[1] = v11;
          v47 = *(_QWORD *)(result + 40);
          if ((*(_DWORD *)(v47 + 4 * v13) & 0x80000000) != 0)
            goto LABEL_100;
        }
        else if (*(_BYTE *)(v45 + v13) != 2)
        {
          *a2 = v13;
          a2[1] = 3;
          return result;
        }
      }
      goto LABEL_4;
    }
    if ((*(_BYTE *)(v8 + v2) & 1) == 0)
    {
      if (*(unsigned __int8 *)(v5 + v13) == 255)
      {
        *(_BYTE *)(v7 + v13) = v9;
        *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 4;
        v18 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
        *v18 = v12;
        v18[1] = v11;
        v19 = *(_QWORD *)(result + 40);
        if ((*(_DWORD *)(v19 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v19 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 84) = v13;
          if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 2) != 0)
            goto LABEL_67;
          goto LABEL_23;
        }
      }
      else if (*(unsigned __int8 *)(v7 + v13) != v9)
      {
        v65 = 0;
        if (*(_BYTE *)(v7 + v2) != 1)
          goto LABEL_115;
        goto LABEL_117;
      }
    }
    if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 2) != 0)
      goto LABEL_67;
LABEL_23:
    v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 36);
    v20 = *(_QWORD *)(result + 24);
    if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) == 255)
    {
      *(_BYTE *)(v20 + v13) = v9;
      *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 5;
      v25 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
      *v25 = v12;
      v25[1] = v11;
      v26 = *(_QWORD *)(result + 40);
      if ((*(_DWORD *)(v26 + 4 * v13) & 0x80000000) != 0)
      {
        *(_DWORD *)(v26 + 4 * *(int *)(result + 84)) = v13;
        *(_DWORD *)(result + 84) = v13;
      }
    }
    else if (*(unsigned __int8 *)(v20 + v13) != v9)
    {
      v65 = 1;
      if (v9 != 1)
        goto LABEL_115;
      goto LABEL_117;
    }
LABEL_67:
    if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 4) == 0)
    {
      v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 40);
      v48 = *(_QWORD *)(result + 24);
      if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) == 255)
      {
        *(_BYTE *)(v48 + v13) = v9;
        *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 6;
        v49 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
        *v49 = v12;
        v49[1] = v11;
        v50 = *(_QWORD *)(result + 40);
        if ((*(_DWORD *)(v50 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v50 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 84) = v13;
          if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 8) != 0)
            goto LABEL_79;
          goto LABEL_73;
        }
      }
      else if (*(unsigned __int8 *)(v48 + v13) != v9)
      {
        v65 = 2;
        if (v9 != 1)
          goto LABEL_115;
        goto LABEL_117;
      }
    }
    if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 8) != 0)
      goto LABEL_79;
LABEL_73:
    v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 44);
    v51 = *(_QWORD *)(result + 24);
    if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) == 255)
    {
      *(_BYTE *)(v51 + v13) = v9;
      *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 7;
      v52 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
      *v52 = v12;
      v52[1] = v11;
      v53 = *(_QWORD *)(result + 40);
      if ((*(_DWORD *)(v53 + 4 * v13) & 0x80000000) != 0)
      {
        *(_DWORD *)(v53 + 4 * *(int *)(result + 84)) = v13;
        *(_DWORD *)(result + 84) = v13;
      }
    }
    else if (*(unsigned __int8 *)(v51 + v13) != v9)
    {
      v65 = 3;
      if (v9 != 1)
        goto LABEL_115;
      goto LABEL_117;
    }
LABEL_79:
    if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 0x10) == 0)
    {
      v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 48);
      v54 = *(_QWORD *)(result + 24);
      if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) == 255)
      {
        *(_BYTE *)(v54 + v13) = v9;
        *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 0;
        v55 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
        *v55 = v12;
        v55[1] = v11;
        v56 = *(_QWORD *)(result + 40);
        if ((*(_DWORD *)(v56 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v56 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 84) = v13;
          if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 0x20) != 0)
            goto LABEL_91;
          goto LABEL_85;
        }
      }
      else if (*(unsigned __int8 *)(v54 + v13) != v9)
      {
        v65 = 4;
        if (v9 != 1)
          goto LABEL_115;
        goto LABEL_117;
      }
    }
    if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 0x20) != 0)
      goto LABEL_91;
LABEL_85:
    v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 52);
    v57 = *(_QWORD *)(result + 24);
    if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) == 255)
    {
      *(_BYTE *)(v57 + v13) = v9;
      *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 1;
      v58 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
      *v58 = v12;
      v58[1] = v11;
      v59 = *(_QWORD *)(result + 40);
      if ((*(_DWORD *)(v59 + 4 * v13) & 0x80000000) != 0)
      {
        *(_DWORD *)(v59 + 4 * *(int *)(result + 84)) = v13;
        *(_DWORD *)(result + 84) = v13;
      }
    }
    else if (*(unsigned __int8 *)(v57 + v13) != v9)
    {
      v65 = 5;
      if (v9 == 1)
        goto LABEL_117;
      goto LABEL_115;
    }
LABEL_91:
    if ((*(_BYTE *)(*(_QWORD *)(result + 32) + v2) & 0x40) == 0)
    {
      v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 56);
      v60 = *(_QWORD *)(result + 24);
      if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) == 255)
      {
        *(_BYTE *)(v60 + v13) = v9;
        *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 2;
        v61 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
        *v61 = v12;
        v61[1] = v11;
        v62 = *(_QWORD *)(result + 40);
        if ((*(_DWORD *)(v62 + 4 * v13) & 0x80000000) != 0)
        {
          *(_DWORD *)(v62 + 4 * *(int *)(result + 84)) = v13;
          *(_DWORD *)(result + 84) = v13;
        }
      }
      else if (*(unsigned __int8 *)(v60 + v13) != v9)
      {
        v65 = 6;
        if (v9 == 1)
          goto LABEL_117;
LABEL_115:
        *a2 = v13;
        a2[1] = ((_BYTE)v65 + 4) & 7;
        return result;
      }
    }
    if (*(char *)(*(_QWORD *)(result + 32) + v2) < 0)
      goto LABEL_4;
    v13 = *(_DWORD *)(*(_QWORD *)result + (v2 << 6) + 60);
    v63 = *(_QWORD *)(result + 24);
    if (*(unsigned __int8 *)(*(_QWORD *)(result + 16) + v13) != 255)
      break;
    *(_BYTE *)(v63 + v13) = v9;
    *(_BYTE *)(*(_QWORD *)(result + 16) + v13) = 3;
    v64 = (_DWORD *)(*(_QWORD *)(result + 8) + 8 * v13);
    *v64 = v12;
    v64[1] = v11;
    v47 = *(_QWORD *)(result + 40);
    if ((*(_DWORD *)(v47 + 4 * v13) & 0x80000000) != 0)
    {
LABEL_100:
      *(_DWORD *)(v47 + 4 * *(int *)(result + 84)) = v13;
      *(_DWORD *)(result + 84) = v13;
    }
LABEL_4:
    v3 = *(_QWORD *)(result + 40);
    v4 = 4 * v2;
    *(_DWORD *)(result + 80) = *(_DWORD *)(v3 + v4);
    *(_DWORD *)(v3 + v4) = -1;
    v2 = *(unsigned int *)(result + 80);
    if ((v2 & 0x80000000) != 0)
      goto LABEL_101;
  }
  if (*(unsigned __int8 *)(v63 + v13) == v9)
    goto LABEL_4;
  v65 = 7;
  if (v9 != 1)
    goto LABEL_115;
LABEL_117:
  *a2 = v2;
  a2[1] = v65;
  return result;
}

void soMaxFlow::Impl::AdoptionStage(soMaxFlow::Impl *this)
{
  uint64_t i;
  int v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  int v22;
  int v23;
  _DWORD *v24;
  uint64_t v25;
  int v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _BYTE *v42;
  _DWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  _OWORD *v48;
  char *v49;
  uint64_t v50;
  __int128 v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  void **v56;
  unint64_t v57;

  v56 = (void **)((char *)this + 96);
  for (i = *((_QWORD *)this + 13); *((_QWORD *)this + 12) != i; i = *((_QWORD *)this + 13))
  {
    v5 = *(int *)(i - 4);
    *((_QWORD *)this + 13) = i - 4;
    v6 = *((_QWORD *)this + 3);
    v7 = *(unsigned __int8 *)(v6 + v5);
    v8 = *(_QWORD *)this;
    v9 = -1;
    v10 = 0x7FFFFFFF;
    v11 = (char *)&Edge::All;
    do
    {
      v12 = *(int *)v11;
      LODWORD(v13) = *(_DWORD *)(v8 + (v5 << 6) + 4 * v12 + 32);
      v14 = (int)v13;
      if (!*(_BYTE *)(v6 + (int)v13))
        goto LABEL_7;
      if (*(_BYTE *)(v6 + (int)v13) == 1)
      {
        if (((*(unsigned __int8 *)(*((_QWORD *)this + 4) + (int)v13) >> ((v12 + 4) & 7)) & 1) != 0)
          goto LABEL_7;
      }
      else if (((*(char *)(*((_QWORD *)this + 4) + v5) >> v12) & 1) != 0)
      {
        goto LABEL_7;
      }
      if (v7 == *(unsigned __int8 *)(v6 + (int)v13))
      {
        v15 = *((_QWORD *)this + 2);
        v16 = *(unsigned __int8 *)(v15 + (int)v13);
        if (v16 != 255)
        {
          v17 = *((_QWORD *)this + 1);
          v18 = *((_DWORD *)this + 18);
          v19 = v17 + 8 * (int)v13;
          v21 = *(_DWORD *)(v19 + 4);
          v20 = (_DWORD *)(v19 + 4);
          if (v21 == v18)
          {
            v22 = 0;
            v13 = (int)v13;
LABEL_21:
            v22 += *(_DWORD *)(v17 + 8 * v13);
            v23 = 1;
            if (v16 == 254)
              goto LABEL_22;
          }
          else
          {
            v22 = 0;
            while (1)
            {
              v13 = (int)v13;
              if (*(char *)(v15 + (int)v13) < 0)
                break;
              LODWORD(v13) = *(_DWORD *)(v8 + ((uint64_t)(int)v13 << 6) + 4 * *(unsigned __int8 *)(v15 + (int)v13) + 32);
              ++v22;
              if (*(_DWORD *)(v17 + 8 * (int)v13 + 4) == v18)
              {
                v13 = (int)v13;
                v16 = *(unsigned __int8 *)(v15 + (int)v13);
                goto LABEL_21;
              }
            }
            v23 = 0;
            v16 = *(unsigned __int8 *)(v15 + (int)v13);
            if (v16 == 254)
            {
LABEL_22:
              v24 = (_DWORD *)(v17 + 8 * v13);
              *v24 = 1;
              v24[1] = v18;
              v16 = *(unsigned __int8 *)(v15 + v13);
            }
          }
          if (((v16 != 254) & ~v23) == 0)
          {
            if (v22 < v10)
            {
              v9 = v12;
              v10 = v22;
            }
            if (*v20 != v18)
            {
              do
              {
                *(_DWORD *)(v17 + 8 * v14) = v22;
                *v20 = v18;
                v14 = *(int *)(v8 + (v14 << 6) + 4 * *(char *)(v15 + v14) + 32);
                --v22;
                v25 = v17 + 8 * v14;
                v26 = *(_DWORD *)(v25 + 4);
                v20 = (_DWORD *)(v25 + 4);
              }
              while (v26 != v18);
            }
          }
        }
      }
LABEL_7:
      v11 += 4;
    }
    while (v11 != "9soMaxFlow");
    *(_BYTE *)(*((_QWORD *)this + 2) + v5) = v9;
    if (v9 < 0)
    {
      v27 = (char *)&Edge::All;
      v55 = v7;
      while (1)
      {
        v29 = *(int *)v27;
        v30 = *(_DWORD *)(*(_QWORD *)this + (v5 << 6) + 4 * v29 + 32);
        v31 = v30;
        if (v7 != *(unsigned __int8 *)(*((_QWORD *)this + 3) + v30))
          goto LABEL_34;
        v32 = *((_QWORD *)this + 2);
        if (*(unsigned __int8 *)(v32 + v30) == 255)
          goto LABEL_34;
        v33 = *((_QWORD *)this + 5);
        if ((*(_DWORD *)(v33 + 4 * v30) & 0x80000000) != 0)
        {
          if (v7 == 1)
          {
            if (((*(unsigned __int8 *)(*((_QWORD *)this + 4) + v30) >> ((v29 + 4) & 7)) & 1) != 0)
              goto LABEL_38;
          }
          else if (((*(char *)(*((_QWORD *)this + 4) + v5) >> v29) & 1) != 0)
          {
            goto LABEL_38;
          }
          v54 = *((unsigned int *)this + 21);
          if ((v54 & 0x80000000) != 0)
            *((_DWORD *)this + 20) = v30;
          else
            *(_DWORD *)(v33 + 4 * v54) = v30;
          *((_DWORD *)this + 21) = v30;
        }
LABEL_38:
        if ((((_BYTE)v29 + 4) & 7) != *(_BYTE *)(v32 + v30))
          goto LABEL_34;
        v35 = (char *)*((_QWORD *)this + 13);
        v34 = *((_QWORD *)this + 14);
        if ((unint64_t)v35 >= v34)
        {
          v36 = (char *)*v56;
          v37 = v35 - (_BYTE *)*v56;
          v38 = v37 >> 2;
          v39 = (v37 >> 2) + 1;
          if (v39 >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v40 = v34 - (_QWORD)v36;
          if (v40 >> 1 > v39)
            v39 = v40 >> 1;
          if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL)
            v39 = 0x3FFFFFFFFFFFFFFFLL;
          v57 = v39;
          if (v39)
          {
            if (v39 >> 62)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v41 = v35 - (_BYTE *)*v56;
            v42 = operator new(4 * v39);
            v37 = v41;
            v7 = v55;
            v43 = &v42[4 * v38];
            *v43 = v30;
            v28 = (uint64_t)(v43 + 1);
            if (v35 != v36)
              goto LABEL_48;
LABEL_64:
            *((_QWORD *)this + 12) = v43;
            *((_QWORD *)this + 13) = v28;
            *((_QWORD *)this + 14) = &v42[4 * v57];
            if (!v36)
              goto LABEL_33;
          }
          else
          {
            v42 = 0;
            v43 = (_DWORD *)(4 * v38);
            *(_DWORD *)(4 * v38) = v30;
            v28 = 4 * v38 + 4;
            if (v35 == v36)
              goto LABEL_64;
LABEL_48:
            v44 = v35 - 4 - v36;
            if (v44 < 0x2C)
              goto LABEL_73;
            if ((unint64_t)(v35 - &v42[v37]) < 0x20)
              goto LABEL_73;
            v45 = (v44 >> 2) + 1;
            v46 = 4 * (v45 & 0x7FFFFFFFFFFFFFF8);
            v47 = &v35[-v46];
            v43 = (_DWORD *)((char *)v43 - v46);
            v48 = &v42[4 * v38 - 16];
            v49 = v35 - 16;
            v50 = v45 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              v51 = *(_OWORD *)v49;
              *(v48 - 1) = *((_OWORD *)v49 - 1);
              *v48 = v51;
              v48 -= 2;
              v49 -= 32;
              v50 -= 8;
            }
            while (v50);
            v35 = v47;
            if (v45 != (v45 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_73:
              do
              {
                v52 = *((_DWORD *)v35 - 1);
                v35 -= 4;
                *--v43 = v52;
              }
              while (v35 != v36);
            }
            *((_QWORD *)this + 12) = v43;
            *((_QWORD *)this + 13) = v28;
            *((_QWORD *)this + 14) = &v42[4 * v57];
            if (!v36)
              goto LABEL_33;
          }
          v53 = v28;
          operator delete(v36);
          v28 = v53;
          v32 = *((_QWORD *)this + 2);
          goto LABEL_33;
        }
        *(_DWORD *)v35 = v30;
        v28 = (uint64_t)(v35 + 4);
LABEL_33:
        *((_QWORD *)this + 13) = v28;
        *(_BYTE *)(v32 + v31) = -4;
LABEL_34:
        v27 += 4;
        if (v27 == "9soMaxFlow")
          goto LABEL_5;
      }
    }
    v3 = *((_DWORD *)this + 18);
    v4 = (int *)(*((_QWORD *)this + 1) + 8 * v5);
    *v4 = v10;
    v4[1] = v3;
LABEL_5:
    ;
  }
}

void soMaxFlow::Impl::UpdateFlow(uint64_t a1, int *a2, float a3)
{
  int *v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  int v19;
  unint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _BYTE *v28;
  _DWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  _OWORD *v34;
  char *v35;
  uint64_t v36;
  __int128 v37;
  int v38;
  uint64_t v39;
  float v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  _BYTE *v49;
  _DWORD *v50;
  char *v51;
  int64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  _OWORD *v57;
  char *v58;
  uint64_t v59;
  __int128 v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  float v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  uint64_t v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  float v77;
  int v78;
  int v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  float v83;
  unint64_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  _BYTE *v92;
  _DWORD *v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  _OWORD *v98;
  char *v99;
  uint64_t v100;
  __int128 v101;
  int v102;
  uint64_t v103;
  float v104;
  unint64_t v105;
  char *v106;
  uint64_t v107;
  char *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  _BYTE *v113;
  _DWORD *v114;
  char *v115;
  int64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  _OWORD *v121;
  char *v122;
  uint64_t v123;
  __int128 v124;
  int v125;
  void **v127;
  void **v128;

  v4 = a2;
  *(float *)(a1 + 76) = *(float *)(a1 + 76) + a3;
  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 16);
  v8 = *a2;
  if ((*(char *)(v7 + v8) & 0x80000000) == 0)
  {
    v9 = *(unsigned __int8 *)(v7 + v8);
    v127 = (void **)(a1 + 96);
    while (1)
    {
      v11 = *(_QWORD *)a1 + (v8 << 6);
      v12 = 4 * v9;
      v13 = *(float *)(v11 + v12) + a3;
      *(float *)(v11 + v12) = v13;
      *(_BYTE *)(*(_QWORD *)(a1 + 32) + v8) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v8) & ~(1 << v9) | ((v13 == 0.0) << v9);
      v14 = *(_DWORD *)(*(_QWORD *)a1 + (v8 << 6) + v12 + 32);
      v15 = ((_BYTE)v9 + 4) & 7;
      v16 = *(_QWORD *)a1 + ((uint64_t)v14 << 6);
      v17 = 4 * v15;
      v18 = *(float *)(v16 + v17) - a3;
      *(float *)(v16 + v17) = v18;
      LODWORD(v16) = (v18 == 0.0) << v15;
      v19 = 1 << v15;
      *(_BYTE *)(*(_QWORD *)(a1 + 32) + v14) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v14) & ~(_BYTE)v19 | v16;
      if ((v19 & *(_BYTE *)(*(_QWORD *)(a1 + 32) + v14)) == 0)
        goto LABEL_5;
      *(_BYTE *)(*(_QWORD *)(a1 + 16) + v8) = -4;
      v21 = *(char **)(a1 + 104);
      v20 = *(_QWORD *)(a1 + 112);
      if ((unint64_t)v21 >= v20)
        break;
      *(_DWORD *)v21 = v6;
      v10 = (uint64_t)(v21 + 4);
LABEL_4:
      *(_QWORD *)(a1 + 104) = v10;
LABEL_5:
      v7 = *(_QWORD *)(a1 + 16);
      v9 = *(unsigned __int8 *)(v7 + v14);
      v8 = v14;
      v6 = v14;
      if (*(char *)(v7 + v14) < 0)
      {
        v8 = v14;
        v6 = v14;
        v4 = a2;
        goto LABEL_29;
      }
    }
    v22 = (char *)*v127;
    v23 = v21 - (_BYTE *)*v127;
    v24 = v23 >> 2;
    v25 = (v23 >> 2) + 1;
    if (v25 >> 62)
LABEL_104:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v26 = v20 - (_QWORD)v22;
    if (v26 >> 1 > v25)
      v25 = v26 >> 1;
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
      v27 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v27 = v25;
    if (v27)
    {
      if (v27 >> 62)
        goto LABEL_105;
      v28 = operator new(4 * v27);
      v29 = &v28[4 * v24];
      *v29 = v6;
      v10 = (uint64_t)(v29 + 1);
      if (v21 == v22)
        goto LABEL_25;
    }
    else
    {
      v28 = 0;
      v29 = (_DWORD *)(4 * v24);
      *(_DWORD *)(4 * v24) = v6;
      v10 = 4 * v24 + 4;
      if (v21 == v22)
      {
LABEL_25:
        *(_QWORD *)(a1 + 96) = v29;
        *(_QWORD *)(a1 + 104) = v10;
        *(_QWORD *)(a1 + 112) = &v28[4 * v27];
        if (v22)
          operator delete(v22);
        goto LABEL_4;
      }
    }
    v30 = v21 - 4 - v22;
    if (v30 < 0x2C)
      goto LABEL_109;
    if ((unint64_t)(v21 - &v28[v23]) < 0x20)
      goto LABEL_109;
    v31 = (v30 >> 2) + 1;
    v32 = 4 * (v31 & 0x7FFFFFFFFFFFFFF8);
    v33 = &v21[-v32];
    v29 = (_DWORD *)((char *)v29 - v32);
    v34 = &v28[4 * v24 - 16];
    v35 = v21 - 16;
    v36 = v31 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v37 = *(_OWORD *)v35;
      *(v34 - 1) = *((_OWORD *)v35 - 1);
      *v34 = v37;
      v34 -= 2;
      v35 -= 32;
      v36 -= 8;
    }
    while (v36);
    v21 = v33;
    if (v31 != (v31 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_109:
      do
      {
        v38 = *((_DWORD *)v21 - 1);
        v21 -= 4;
        *--v29 = v38;
      }
      while (v21 != v22);
    }
    goto LABEL_25;
  }
LABEL_29:
  v39 = *(_QWORD *)(a1 + 48);
  v40 = *(float *)(v39 + 4 * v8) - a3;
  *(float *)(v39 + 4 * v8) = v40;
  if (v40 != 0.0)
    goto LABEL_52;
  *(_BYTE *)(v7 + v8) = -4;
  v42 = *(char **)(a1 + 104);
  v41 = *(_QWORD *)(a1 + 112);
  if ((unint64_t)v42 >= v41)
  {
    v44 = *(char **)(a1 + 96);
    v45 = (v42 - v44) >> 2;
    v46 = v45 + 1;
    if ((unint64_t)(v45 + 1) >> 62)
      goto LABEL_106;
    v47 = v41 - (_QWORD)v44;
    if (v47 >> 1 > v46)
      v46 = v47 >> 1;
    if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
      v48 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v48 = v46;
    if (v48)
    {
      if (v48 >> 62)
        goto LABEL_105;
      v49 = operator new(4 * v48);
      v50 = &v49[4 * v45];
      v51 = &v49[4 * v48];
      *v50 = v6;
      v43 = (uint64_t)(v50 + 1);
      v52 = v42 - v44;
      if (v42 == v44)
        goto LABEL_49;
    }
    else
    {
      v49 = 0;
      v50 = (_DWORD *)(4 * v45);
      v51 = 0;
      *(_DWORD *)(4 * v45) = v6;
      v43 = 4 * v45 + 4;
      v52 = v42 - v44;
      if (v42 == v44)
      {
LABEL_49:
        *(_QWORD *)(a1 + 96) = v50;
        *(_QWORD *)(a1 + 104) = v43;
        *(_QWORD *)(a1 + 112) = v51;
        if (v44)
          operator delete(v44);
        goto LABEL_51;
      }
    }
    v53 = v52 - 4;
    if (v53 < 0x2C)
      goto LABEL_110;
    if ((unint64_t)(v44 - v49) < 0x20)
      goto LABEL_110;
    v54 = (v53 >> 2) + 1;
    v55 = 4 * (v54 & 0x7FFFFFFFFFFFFFF8);
    v56 = &v42[-v55];
    v50 = (_DWORD *)((char *)v50 - v55);
    v57 = &v49[4 * v45 - 16];
    v58 = v42 - 16;
    v59 = v54 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v60 = *(_OWORD *)v58;
      *(v57 - 1) = *((_OWORD *)v58 - 1);
      *v57 = v60;
      v57 -= 2;
      v58 -= 32;
      v59 -= 8;
    }
    while (v59);
    v42 = v56;
    if (v54 != (v54 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_110:
      do
      {
        v61 = *((_DWORD *)v42 - 1);
        v42 -= 4;
        *--v50 = v61;
      }
      while (v42 != v44);
    }
    goto LABEL_49;
  }
  *(_DWORD *)v42 = v6;
  v43 = (uint64_t)(v42 + 4);
LABEL_51:
  *(_QWORD *)(a1 + 104) = v43;
LABEL_52:
  v62 = v4[1];
  v63 = *v4;
  v64 = *(_QWORD *)a1 + (v63 << 6);
  v65 = 4 * v62;
  v66 = *(float *)(v64 + v65) - a3;
  *(float *)(v64 + v65) = v66;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + v63) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v63) & ~(1 << v62) | ((v66 == 0.0) << v62);
  v67 = *(_DWORD *)(*(_QWORD *)a1 + (v63 << 6) + v65 + 32);
  LODWORD(v64) = ((_BYTE)v62 + 4) & 7;
  v68 = v67;
  v69 = *(_QWORD *)a1 + ((uint64_t)v67 << 6);
  v70 = 4 * v64;
  v71 = *(float *)(v69 + v70) + a3;
  *(float *)(v69 + v70) = v71;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + v67) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v67) & ~(1 << v64) | ((v71 == 0.0) << v64);
  v72 = *(_QWORD *)(a1 + 16);
  if (*(char *)(v72 + v67) < 0)
    goto LABEL_80;
  v73 = *(unsigned __int8 *)(v72 + v67);
  v128 = (void **)(a1 + 96);
  do
  {
    v75 = *(_QWORD *)a1 + (v68 << 6);
    v76 = 4 * v73;
    v77 = *(float *)(v75 + v76) - a3;
    *(float *)(v75 + v76) = v77;
    v78 = 1 << v73;
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + v68) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v68) & ~(1 << v73) | ((v77 == 0.0) << v73);
    v79 = *(_DWORD *)(*(_QWORD *)a1 + (v68 << 6) + v76 + 32);
    v80 = ((_BYTE)v73 + 4) & 7;
    v81 = *(_QWORD *)a1 + ((uint64_t)v79 << 6);
    v82 = 4 * v80;
    v83 = *(float *)(v81 + v82) + a3;
    *(float *)(v81 + v82) = v83;
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + v79) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v79) & ~(1 << v80) | ((v83 == 0.0) << v80);
    if ((v78 & *(char *)(*(_QWORD *)(a1 + 32) + v68)) != 0)
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 16) + v68) = -4;
      v85 = *(char **)(a1 + 104);
      v84 = *(_QWORD *)(a1 + 112);
      if ((unint64_t)v85 < v84)
      {
        *(_DWORD *)v85 = v67;
        v74 = (uint64_t)(v85 + 4);
LABEL_55:
        *(_QWORD *)(a1 + 104) = v74;
        goto LABEL_56;
      }
      v86 = (char *)*v128;
      v87 = v85 - (_BYTE *)*v128;
      v88 = v87 >> 2;
      v89 = (v87 >> 2) + 1;
      if (v89 >> 62)
        goto LABEL_104;
      v90 = v84 - (_QWORD)v86;
      if (v90 >> 1 > v89)
        v89 = v90 >> 1;
      if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL)
        v91 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v91 = v89;
      if (v91)
      {
        if (v91 >> 62)
          goto LABEL_105;
        v92 = operator new(4 * v91);
        v93 = &v92[4 * v88];
        *v93 = v67;
        v74 = (uint64_t)(v93 + 1);
        if (v85 == v86)
          goto LABEL_76;
      }
      else
      {
        v92 = 0;
        v93 = (_DWORD *)(4 * v88);
        *(_DWORD *)(4 * v88) = v67;
        v74 = 4 * v88 + 4;
        if (v85 == v86)
        {
LABEL_76:
          *(_QWORD *)(a1 + 96) = v93;
          *(_QWORD *)(a1 + 104) = v74;
          *(_QWORD *)(a1 + 112) = &v92[4 * v91];
          if (v86)
            operator delete(v86);
          goto LABEL_55;
        }
      }
      v94 = v85 - 4 - v86;
      if (v94 < 0x2C)
        goto LABEL_111;
      if ((unint64_t)(v85 - &v92[v87]) < 0x20)
        goto LABEL_111;
      v95 = (v94 >> 2) + 1;
      v96 = 4 * (v95 & 0x7FFFFFFFFFFFFFF8);
      v97 = &v85[-v96];
      v93 = (_DWORD *)((char *)v93 - v96);
      v98 = &v92[4 * v88 - 16];
      v99 = v85 - 16;
      v100 = v95 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v101 = *(_OWORD *)v99;
        *(v98 - 1) = *((_OWORD *)v99 - 1);
        *v98 = v101;
        v98 -= 2;
        v99 -= 32;
        v100 -= 8;
      }
      while (v100);
      v85 = v97;
      if (v95 != (v95 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_111:
        do
        {
          v102 = *((_DWORD *)v85 - 1);
          v85 -= 4;
          *--v93 = v102;
        }
        while (v85 != v86);
      }
      goto LABEL_76;
    }
LABEL_56:
    v72 = *(_QWORD *)(a1 + 16);
    v73 = *(unsigned __int8 *)(v72 + v79);
    v68 = v79;
    v67 = v79;
  }
  while ((*(char *)(v72 + v79) & 0x80000000) == 0);
  v68 = v79;
  v67 = v79;
LABEL_80:
  v103 = *(_QWORD *)(a1 + 48);
  v104 = *(float *)(v103 + 4 * v68) + a3;
  *(float *)(v103 + 4 * v68) = v104;
  if (v104 != 0.0)
    return;
  *(_BYTE *)(v72 + v68) = -4;
  v106 = *(char **)(a1 + 104);
  v105 = *(_QWORD *)(a1 + 112);
  if ((unint64_t)v106 < v105)
  {
    *(_DWORD *)v106 = v67;
    v107 = (uint64_t)(v106 + 4);
    goto LABEL_102;
  }
  v108 = *(char **)(a1 + 96);
  v109 = (v106 - v108) >> 2;
  v110 = v109 + 1;
  if ((unint64_t)(v109 + 1) >> 62)
LABEL_106:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v111 = v105 - (_QWORD)v108;
  if (v111 >> 1 > v110)
    v110 = v111 >> 1;
  if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL)
    v112 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v112 = v110;
  if (!v112)
  {
    v113 = 0;
    v114 = (_DWORD *)(4 * v109);
    v115 = 0;
    *(_DWORD *)(4 * v109) = v67;
    v107 = 4 * v109 + 4;
    v116 = v106 - v108;
    if (v106 == v108)
      goto LABEL_100;
LABEL_94:
    v117 = v116 - 4;
    if (v117 < 0x2C)
      goto LABEL_112;
    if ((unint64_t)(v108 - v113) < 0x20)
      goto LABEL_112;
    v118 = (v117 >> 2) + 1;
    v119 = 4 * (v118 & 0x7FFFFFFFFFFFFFF8);
    v120 = &v106[-v119];
    v114 = (_DWORD *)((char *)v114 - v119);
    v121 = &v113[4 * v109 - 16];
    v122 = v106 - 16;
    v123 = v118 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v124 = *(_OWORD *)v122;
      *(v121 - 1) = *((_OWORD *)v122 - 1);
      *v121 = v124;
      v121 -= 2;
      v122 -= 32;
      v123 -= 8;
    }
    while (v123);
    v106 = v120;
    if (v118 != (v118 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_112:
      do
      {
        v125 = *((_DWORD *)v106 - 1);
        v106 -= 4;
        *--v114 = v125;
      }
      while (v106 != v108);
    }
    goto LABEL_100;
  }
  if (v112 >> 62)
LABEL_105:
    std::__throw_bad_array_new_length[abi:ne180100]();
  v113 = operator new(4 * v112);
  v114 = &v113[4 * v109];
  v115 = &v113[4 * v112];
  *v114 = v67;
  v107 = (uint64_t)(v114 + 1);
  v116 = v106 - v108;
  if (v106 != v108)
    goto LABEL_94;
LABEL_100:
  *(_QWORD *)(a1 + 96) = v114;
  *(_QWORD *)(a1 + 104) = v107;
  *(_QWORD *)(a1 + 112) = v115;
  if (v108)
    operator delete(v108);
LABEL_102:
  *(_QWORD *)(a1 + 104) = v107;
}

uint64_t HGMemory::allocate(HGMemory *this, unint64_t *a2, unint64_t *a3)
{
  unint64_t v5;
  char v7;
  char **v8;
  char *v9;

  v5 = atomic_load(&HGMemoryManager::INSTANCE(void)::flag);
  if (v5 != -1)
  {
    v9 = &v7;
    v8 = &v9;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v8, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  return HGMemoryManager::allocate((HGMemoryManager *)HGMemoryManager::INSTANCE(void)::mm, (unint64_t)this, a2);
}

uint64_t HGMemoryManager::allocate(HGMemoryManager *this, unint64_t a2, unint64_t *a3)
{
  pthread_mutex_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unsigned int v23;
  unint64_t v24;
  BOOL v26;
  unint64_t v27;
  BOOL v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v33;

  v6 = (pthread_mutex_t *)((char *)this + 64);
  pthread_mutex_lock((pthread_mutex_t *)this + 1);
  HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v33, *((uint64_t **)this + 4));
  if (!*(_QWORD *)(*((_QWORD *)this + 3) + 40))
    goto LABEL_36;
  v7 = (*(uint64_t (**)(_QWORD, unint64_t))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1), a2);
  if (v7 >= a2)
    v8 = v7;
  else
    v8 = 0;
  if (v7 >= a2)
    v9 = a2;
  else
    v9 = 0;
  v10 = (_QWORD *)*((_QWORD *)this + 3);
  v11 = v10[1];
  v12 = v10[4];
  v13 = v10[5];
  v14 = (char *)(v11 + 8 * (v12 >> 9));
  v15 = *(char **)v14;
  v16 = (char *)(*(_QWORD *)v14 + 8 * (v12 & 0x1FF));
  v17 = *(_QWORD *)(v11 + (((v13 + v12) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v13 + v12) & 0x1FF);
  if (v16 != (char *)v17)
  {
    v18 = v14;
    v19 = v16 + 8;
    if (v16 + 8 - v15 != 4096)
      goto LABEL_11;
LABEL_10:
    v20 = (char *)*((_QWORD *)v18 + 1);
    v18 += 8;
    v15 = v20;
    v19 = v20;
LABEL_11:
    while (v19 != (char *)v17)
    {
      v21 = *(_QWORD *)(*(_QWORD *)v16 + 16);
      if (v8 < v21 || v9 > v21)
        v23 = 0;
      else
        v23 = v8 - v21;
      v24 = *(_QWORD *)(*(_QWORD *)v19 + 16);
      v26 = v9 <= v24 && v8 >= v24;
      if (v26 && v23 < (int)v8 - (int)v24)
      {
        v14 = v18;
        v16 = v19;
      }
      v19 += 8;
      if (v19 - v15 == 4096)
        goto LABEL_10;
    }
  }
  v27 = *(_QWORD *)(*(_QWORD *)v16 + 16);
  v28 = v9 <= v27 && v8 >= v27;
  v29 = !v28 || (_DWORD)v8 - (_DWORD)v27 == 0;
  if (v29 || (v30 = HGMemoryManager::_reuse((uint64_t)this, v14, v16, a2)) == 0)
LABEL_36:
    v30 = HGMemoryManager::_allocate(this, a2);
  if (a3)
    *a3 = *(_QWORD *)(v30 + 16);
  v31 = *(_QWORD *)(v30 + 8);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v33);
  pthread_mutex_unlock(v6);
  return v31;
}

void sub_1B29E81A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  pthread_mutex_t *v2;
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((_QWORD **)va);
  pthread_mutex_unlock(v2);
  _Unwind_Resume(a1);
}

pthread_mutex_t *HGMemory::release(HGMemory *this, void *a2)
{
  unint64_t v3;
  char v5;
  char **v6;
  char *v7;

  v3 = atomic_load(&HGMemoryManager::INSTANCE(void)::flag);
  if (v3 != -1)
  {
    v7 = &v5;
    v6 = &v7;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v6, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  return HGMemoryManager::release((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm, this);
}

pthread_mutex_t *HGMemoryManager::release(pthread_mutex_t *this, void *a2)
{
  uint64_t v3;
  pthread_mutex_t *v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  _QWORD *v28;

  if (a2)
  {
    v3 = (uint64_t)this;
    v4 = this + 1;
    pthread_mutex_lock(this + 1);
    ++*(_QWORD *)(v3 + 56);
    HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v28, *(uint64_t **)(v3 + 32));
    v7 = *(_QWORD **)(v3 + 16);
    v8 = v7[1];
    if (v7[2] == v8)
      goto LABEL_12;
    v9 = v7[4];
    v5 = v8 + 8 * (v9 >> 9);
    v6 = (char *)(*(_QWORD *)v5 + 8 * (v9 & 0x1FF));
    v10 = v7[5] + v9;
    v11 = v10 >> 9;
    v12 = *(_QWORD *)(v8 + 8 * (v10 >> 9));
    v13 = v10 & 0x1FF;
    v14 = (char *)(v12 + 8 * v13);
    if (v6 != v14)
    {
      while (*(void **)(*(_QWORD *)v6 + 8) != a2)
      {
        v6 += 8;
        if (&v6[-*(_QWORD *)v5] == (char *)4096)
        {
          v15 = *(char **)(v5 + 8);
          v5 += 8;
          v6 = v15;
        }
        if (v6 == v14)
        {
          v6 = v14;
          break;
        }
      }
    }
    if (v6 == (char *)(*(_QWORD *)(v8 + 8 * v11) + 8 * v13))
    {
LABEL_12:
      v16 = *(_QWORD **)(v3 + 24);
      v17 = v16[1];
      if (v16[2] == v17)
        goto LABEL_22;
      v18 = v16[4];
      v19 = (_QWORD *)(v17 + 8 * (v18 >> 9));
      v20 = *v19 + 8 * (v18 & 0x1FF);
      v21 = v16[5] + v18;
      v22 = v21 >> 9;
      v23 = *(_QWORD *)(v17 + 8 * (v21 >> 9));
      v24 = v21 & 0x1FF;
      v25 = v23 + 8 * v24;
      if (v20 != v25)
      {
        while (*(void **)(*(_QWORD *)v20 + 8) != a2)
        {
          v20 += 8;
          if (v20 - *v19 == 4096)
          {
            v26 = v19[1];
            ++v19;
            v20 = v26;
          }
          if (v20 == v25)
          {
            v20 = v25;
            break;
          }
        }
      }
      if (v20 == *(_QWORD *)(v17 + 8 * v22) + 8 * v24)
LABEL_22:
        v27 = "HGMemoryManager::release() - Attempting to release an unmanaged buffer: <%p>";
      else
        v27 = "HGMemoryManager::release() - Attempting to double-release a free buffer: <%p>";
      HGLogger::warning((HGLogger *)v27, (const char *)v5, v6, a2);
    }
    else
    {
      HGMemoryManager::_recycle(v3, (char *)v5, v6);
    }
    HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v28);
    HGMemoryManager::cleanup((uint64_t **)v3);
    return (pthread_mutex_t *)pthread_mutex_unlock(v4);
  }
  return this;
}

void sub_1B29E8400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  pthread_mutex_t *v10;

  pthread_mutex_unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t HGMemory::renderEnd(HGMemory *this)
{
  unint64_t v1;
  uint64_t **v2;
  pthread_mutex_t *v3;
  char v5;
  char **v6;
  char *v7;

  v1 = atomic_load(&HGMemoryManager::INSTANCE(void)::flag);
  if (v1 != -1)
  {
    v7 = &v5;
    v6 = &v7;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v6, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  v2 = (uint64_t **)HGMemoryManager::INSTANCE(void)::mm;
  v3 = (pthread_mutex_t *)((char *)HGMemoryManager::INSTANCE(void)::mm + 64);
  pthread_mutex_lock((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm + 1);
  v2[7] = (uint64_t *)((char *)v2[7] + 1);
  HGMemoryManager::cleanup(v2);
  return pthread_mutex_unlock(v3);
}

uint64_t HGMemoryManager::cleanup(uint64_t **this)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  unint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t *v48;
  uint64_t j;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  const char *v62;
  _QWORD *v64;

  if (*((_BYTE *)this + 128))
  {
    HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v64, this[4]);
    v2 = (*(uint64_t (**)(uint64_t *))(*this[1] + 32))(this[1]);
    v3 = this[3];
    for (i = v3[5]; i > v2; i = v3[5])
    {
      v5 = v3[4] + i;
      v6 = v3[1];
      v7 = v3[2];
      v8 = (_QWORD *)(v6 + 8 * (v5 >> 9));
      v9 = *v8 + 8 * (v5 & 0x1FF);
      if (v7 == v6)
        v9 = 0;
      v10 = v9 - *v8;
      v11 = v10 >> 3;
      if (v10 < 9)
      {
        v16 = 512 - v11;
        v13 = (char *)&v8[-(v16 >> 9)];
        v14 = *(_QWORD *)v13;
        v15 = ~(_DWORD)v16 & 0x1FFLL;
      }
      else
      {
        v12 = v11 - 1;
        v13 = (char *)&v8[v12 >> 9];
        v14 = *(_QWORD *)v13;
        v15 = v12 & 0x1FF;
      }
      HGMemoryManager::_release((uint64_t)this, v13, (char *)(v14 + 8 * v15));
      v3 = this[3];
    }
    v17 = (*(uint64_t (**)(uint64_t *))(*this[1] + 40))(this[1]);
    v18 = this[3];
    v19 = v18[5];
    if (v19)
    {
      v20 = v17;
      do
      {
        v21 = v18[4] + v19;
        v22 = v18[1];
        v23 = v18[2];
        v24 = (_QWORD *)(v22 + 8 * (v21 >> 9));
        v25 = *v24 + 8 * (v21 & 0x1FF);
        if (v23 == v22)
          v25 = 0;
        v26 = v25 - *v24;
        v27 = v26 >> 3;
        if (v26 < 9)
        {
          v32 = 512 - v27;
          v29 = (char *)&v24[-(v32 >> 9)];
          v30 = *(_QWORD *)v29;
          v31 = ~(_DWORD)v32 & 0x1FFLL;
        }
        else
        {
          v28 = v27 - 1;
          v29 = (char *)&v24[v28 >> 9];
          v30 = *(_QWORD *)v29;
          v31 = v28 & 0x1FF;
        }
        v33 = (char *)(v30 + 8 * v31);
        if ((unint64_t)this[7] - *(_QWORD *)(*(_QWORD *)v33 + 48) <= v20)
          break;
        HGMemoryManager::_release((uint64_t)this, v29, v33);
        v18 = this[3];
        v19 = v18[5];
      }
      while (v19);
    }
    v34 = (*(uint64_t (**)(uint64_t *))(*this[1] + 48))(this[1]);
    while (this[6][10] > v34)
    {
      v35 = this[3];
      v36 = v35[4] + v35[5];
      v37 = v35[1];
      v38 = v35[2];
      v39 = (_QWORD *)(v37 + 8 * (v36 >> 9));
      v40 = *v39 + 8 * (v36 & 0x1FF);
      if (v38 == v37)
        v40 = 0;
      v41 = v40 - *v39;
      v42 = v41 >> 3;
      if (v41 < 9)
      {
        v47 = 512 - v42;
        v44 = (char *)&v39[-(v47 >> 9)];
        v45 = *(_QWORD *)v44;
        v46 = ~(_DWORD)v47 & 0x1FFLL;
      }
      else
      {
        v43 = v42 - 1;
        v44 = (char *)&v39[v43 >> 9];
        v45 = *(_QWORD *)v44;
        v46 = v43 & 0x1FF;
      }
      HGMemoryManager::_release((uint64_t)this, v44, (char *)(v45 + 8 * v46));
    }
  }
  else
  {
    HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v64, this[4]);
    v48 = this[3];
    for (j = v48[5]; j; j = v48[5])
    {
      v50 = v48[4] + j;
      v51 = v48[1];
      v52 = v48[2];
      v53 = (_QWORD *)(v51 + 8 * (v50 >> 9));
      v54 = *v53 + 8 * (v50 & 0x1FF);
      if (v52 == v51)
        v54 = 0;
      v55 = v54 - *v53;
      v56 = v55 >> 3;
      if (v55 < 9)
      {
        v61 = 512 - v56;
        v58 = (char *)&v53[-(v61 >> 9)];
        v59 = *(_QWORD *)v58;
        v60 = ~(_DWORD)v61 & 0x1FFLL;
      }
      else
      {
        v57 = v56 - 1;
        v58 = (char *)&v53[v57 >> 9];
        v59 = *(_QWORD *)v58;
        v60 = v57 & 0x1FF;
      }
      HGMemoryManager::_release((uint64_t)this, v58, (char *)(v59 + 8 * v60));
      v48 = this[3];
    }
  }
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v64);
  return HGMemoryManager::dump((HGMemoryManager::Stats **)this, v62);
}

void sub_1B29E87C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((_QWORD **)va);
  _Unwind_Resume(a1);
}

void sub_1B29E87D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((_QWORD **)va);
  _Unwind_Resume(a1);
}

void sub_1B29E87E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((_QWORD **)va);
  _Unwind_Resume(a1);
}

void sub_1B29E87FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((_QWORD **)va);
  _Unwind_Resume(a1);
}

void sub_1B29E8810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard((_QWORD **)va);
  _Unwind_Resume(a1);
}

HGMemory::StorageObject *HGMemory::StorageObject::StorageObject(HGMemory::StorageObject *this, unint64_t a2)
{
  _QWORD *v4;
  unint64_t *v5;
  unint64_t v6;
  char v8;
  char **v9;
  char *v10;

  HGObject::HGObject(this);
  *v4 = off_1E65199B8;
  v5 = v4 + 3;
  v6 = atomic_load(&HGMemoryManager::INSTANCE(void)::flag);
  if (v6 != -1)
  {
    v10 = &v8;
    v9 = &v10;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v9, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  *((_QWORD *)this + 2) = HGMemoryManager::allocate((HGMemoryManager *)HGMemoryManager::INSTANCE(void)::mm, a2, v5);
  return this;
}

void sub_1B29E88C0(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGMemory::StorageObject::~StorageObject(HGMemory::StorageObject *this)
{
  void *v2;
  unint64_t v3;
  char v4;
  char **v5;
  char *v6;

  *(_QWORD *)this = off_1E65199B8;
  v2 = (void *)*((_QWORD *)this + 2);
  v3 = atomic_load(&HGMemoryManager::INSTANCE(void)::flag);
  if (v3 != -1)
  {
    v6 = &v4;
    v5 = &v6;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  HGMemoryManager::release((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm, v2);
  HGObject::~HGObject(this);
}

{
  void *v2;
  unint64_t v3;
  void *v4;
  char v5;
  char **v6;
  char *v7;

  *(_QWORD *)this = off_1E65199B8;
  v2 = (void *)*((_QWORD *)this + 2);
  v3 = atomic_load(&HGMemoryManager::INSTANCE(void)::flag);
  if (v3 != -1)
  {
    v7 = &v5;
    v6 = &v7;
    std::__call_once(&HGMemoryManager::INSTANCE(void)::flag, &v6, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>);
  }
  HGMemoryManager::release((pthread_mutex_t *)HGMemoryManager::INSTANCE(void)::mm, v2);
  HGObject::~HGObject(this);
  HGObject::operator delete(v4);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<HGMemoryManager::INSTANCE(void)::{lambda(void)#1} &&>>()
{
  HGMemoryManager *v0;

  v0 = (HGMemoryManager *)operator new();
  HGMemoryManager::HGMemoryManager(v0);
  HGMemoryManager::INSTANCE(void)::mm = v0;
}

void sub_1B29E8A30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1020C40F2D2F845);
  _Unwind_Resume(a1);
}

void HGMemoryManager::HGMemoryManager(HGMemoryManager *this)
{
  _OWORD *v2;
  _OWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  const char *v7;
  char *v8;

  *(_QWORD *)this = operator new();
  v2 = (_OWORD *)operator new();
  *v2 = 0u;
  v2[1] = 0u;
  v2[2] = 0u;
  *((_QWORD *)this + 2) = v2;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = v3;
  v4 = operator new();
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_QWORD *)(v4 + 112) = 0;
  *((_QWORD *)this + 6) = v4;
  *((_QWORD *)this + 7) = 0;
  *((_BYTE *)this + 128) = 1;
  pthread_mutex_init((pthread_mutex_t *)this + 1, 0);
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E6519A08;
  *((_QWORD *)this + 1) = v5;
  v6 = getenv("HG_ENV_DISABLE_HGMEMORY_RECYCLING");
  if (v6)
  {
    if (atoi(v6))
    {
      HGLogger::warning((HGLogger *)"HGMemory recycling has been disabled!", v7, v8);
      *((_BYTE *)this + 128) = 0;
    }
  }
}

void HGMemoryManager::PageSizePolicy::~PageSizePolicy(HGMemoryManager::PageSizePolicy *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t HGMemoryManager::PageSizePolicy::padBlockSizeForAlloc(HGMemoryManager::PageSizePolicy *this, uint64_t a2)
{
  int v3;

  v3 = getpagesize();
  return (a2 + v3 - 1) & -(uint64_t)v3;
}

uint64_t HGMemoryManager::PageSizePolicy::maxBlockSizeForReUsage(HGMemoryManager::PageSizePolicy *this, uint64_t a2)
{
  return 2 * a2;
}

uint64_t HGMemoryManager::PageSizePolicy::maxFreeBlockNumber(HGMemoryManager::PageSizePolicy *this)
{
  return 10;
}

uint64_t HGMemoryManager::PageSizePolicy::maxFreeBlockAge(HGMemoryManager::PageSizePolicy *this)
{
  return 200;
}

uint64_t HGMemoryManager::PageSizePolicy::maxFreeBlockTotalUsage(HGMemoryManager::PageSizePolicy *this)
{
  return -1;
}

uint64_t HGMemoryManager::_reuse(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;

  v8 = *(_QWORD **)(a1 + 16);
  v9 = v8[2];
  v10 = v8[1];
  v11 = ((v9 - v10) << 6) - 1;
  v12 = v9 == v10;
  v13 = *(_QWORD *)a3;
  *(_QWORD *)(v13 + 48) = *(_QWORD *)(a1 + 56);
  v14 = *(_QWORD *)(v13 + 32) + a4;
  *(_QWORD *)(v13 + 24) = a4;
  *(_QWORD *)(v13 + 32) = v14;
  ++*(_DWORD *)(v13 + 40);
  if (v12)
    v15 = 0;
  else
    v15 = v11;
  v16 = v8[5];
  v17 = v16 + v8[4];
  if (v15 == v17)
  {
    std::deque<HGMemoryManager::Block *>::__add_back_capacity((uint64_t)v8);
    v10 = v8[1];
    v16 = v8[5];
    v17 = v8[4] + v16;
  }
  *(_QWORD *)(*(_QWORD *)(v10 + ((v17 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v17 & 0x1FF)) = v13;
  v8[5] = v16 + 1;
  std::deque<Pipeline *>::erase(*(int64x2_t **)(a1 + 24), a2, a3);
  v18 = *(_QWORD **)(a1 + 48);
  v19 = *(_QWORD *)(v13 + 16);
  ++v18[2];
  v18[6] += v19;
  v20 = v18[8];
  v21 = v20 + v19;
  v22 = v18[9] + a4;
  v18[8] = v20 + v19;
  v18[9] = v22;
  v23 = v18[10];
  v24 = v18[11];
  v25 = v23 - v19;
  v18[10] = v25;
  if (v24 < v21)
  {
    v18[11] = v21;
    if (v18[12] >= v25)
    {
LABEL_8:
      v26 = v21 - v22;
      if (v18[13] >= v26)
        goto LABEL_9;
LABEL_14:
      v18[13] = v26;
      v27 = v23 + v20;
      if (v18[14] >= v27)
        return v13;
      goto LABEL_10;
    }
  }
  else if (v18[12] >= v25)
  {
    goto LABEL_8;
  }
  v18[12] = v25;
  v26 = v21 - v22;
  if (v18[13] < v26)
    goto LABEL_14;
LABEL_9:
  v27 = v23 + v20;
  if (v18[14] < v27)
LABEL_10:
    v18[14] = v27;
  return v13;
}

uint64_t HGMemoryManager::_allocate(HGMemoryManager *this, uint64_t a2)
{
  size_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v23;
  uint64_t *v24;

  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  HGProfilerGuard<(HGProfilerGuardMode)1>::HGProfilerGuard(&v24, *((_QWORD **)this + 4));
  HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v23, *((uint64_t **)this + 5));
  v5 = operator new();
  *(_QWORD *)v5 = *(_QWORD *)this;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_DWORD *)(v5 + 40) = 0;
  *(_QWORD *)(v5 + 8) = malloc_type_valloc(v4, 0xC9FB827BuLL);
  *(_QWORD *)(v5 + 16) = v4;
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v23);
  HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard(&v24);
  v6 = (_QWORD *)*((_QWORD *)this + 2);
  v7 = v6[2];
  v8 = v6[1];
  v9 = ((v7 - v8) << 6) - 1;
  v10 = v7 == v8;
  *(_QWORD *)(v5 + 48) = *((_QWORD *)this + 7);
  v11 = *(_QWORD *)(v5 + 32) + a2;
  *(_QWORD *)(v5 + 24) = a2;
  *(_QWORD *)(v5 + 32) = v11;
  ++*(_DWORD *)(v5 + 40);
  if (v10)
    v12 = 0;
  else
    v12 = v9;
  v13 = v6[5];
  v14 = v13 + v6[4];
  if (v12 == v14)
  {
    std::deque<HGMemoryManager::Block *>::__add_back_capacity((uint64_t)v6);
    v8 = v6[1];
    v13 = v6[5];
    v14 = v6[4] + v13;
  }
  *(_QWORD *)(*(_QWORD *)(v8 + ((v14 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v14 & 0x1FF)) = v5;
  v6[5] = v13 + 1;
  v15 = (_QWORD *)*((_QWORD *)this + 6);
  v16 = *(_QWORD *)(v5 + 16);
  ++*v15;
  v15[4] += v16;
  v17 = v15[8] + v16;
  v18 = v15[9] + a2;
  v15[8] = v17;
  v15[9] = v18;
  if (v15[11] < v17)
  {
    v15[11] = v17;
    v19 = v15[10];
    if (v15[12] >= v19)
    {
LABEL_8:
      v20 = v17 - v18;
      if (v15[13] >= v20)
        goto LABEL_9;
LABEL_14:
      v15[13] = v20;
      v21 = v19 + v17;
      if (v15[14] >= v21)
        return v5;
      goto LABEL_10;
    }
  }
  else
  {
    v19 = v15[10];
    if (v15[12] >= v19)
      goto LABEL_8;
  }
  v15[12] = v19;
  v20 = v17 - v18;
  if (v15[13] < v20)
    goto LABEL_14;
LABEL_9:
  v21 = v19 + v17;
  if (v15[14] < v21)
LABEL_10:
    v15[14] = v21;
  return v5;
}

void sub_1B29E8F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _QWORD *a9, uint64_t *a10)
{
  uint64_t v10;

  MEMORY[0x1B5E29170](v10, 0x10E0C40D70D0186);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&a9);
  HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard(&a10);
  _Unwind_Resume(a1);
}

void sub_1B29E8FAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard((uint64_t **)va);
  _Unwind_Resume(a1);
}

void std::deque<HGMemoryManager::Block *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B29E951C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B29E9538(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29E954C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29E9564(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGMemoryManager::_recycle(uint64_t a1, char *a2, char *a3)
{
  int64x2_t *v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int64x2_t *v13;
  int64x2_t v14;
  int64x2_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;

  v6 = *(int64x2_t **)a3;
  *(_QWORD *)(*(_QWORD *)a3 + 48) = *(_QWORD *)(a1 + 56);
  v7 = *(_QWORD **)(a1 + 24);
  v8 = v7[4];
  if (!v8)
  {
    std::deque<HGMemoryManager::Block *>::__add_front_capacity(*(_QWORD *)(a1 + 24));
    v8 = v7[4];
  }
  v9 = v7[1];
  v10 = (_QWORD *)(v9 + 8 * (v8 >> 9));
  if (v7[2] == v9)
    v11 = 0;
  else
    v11 = *v10 + 8 * (v8 & 0x1FF);
  if (v11 == *v10)
    v11 = *(v10 - 1) + 4096;
  *(_QWORD *)(v11 - 8) = v6;
  v12 = v7[5] + 1;
  v7[4] = v8 - 1;
  v7[5] = v12;
  std::deque<Pipeline *>::erase(*(int64x2_t **)(a1 + 16), a2, a3);
  v13 = *(int64x2_t **)(a1 + 48);
  ++v13->i64[1];
  v14 = v13[4];
  v15 = vsubq_s64(v14, v6[1]);
  v16 = v6[1].i64[0];
  v13[2].i64[1] += v16;
  v13[4] = v15;
  v17 = v13[5].i64[0];
  v18 = v13[5].u64[1];
  v19 = v17 + v16;
  v13[5].i64[0] = v17 + v16;
  if (v18 < v15.i64[0])
  {
    v13[5].i64[1] = v15.i64[0];
    if (v13[6].i64[0] >= v19)
    {
LABEL_10:
      v20 = v15.i64[0] - v15.i64[1];
      if (v13[6].i64[1] >= (unint64_t)(v15.i64[0] - v15.i64[1]))
        goto LABEL_11;
LABEL_16:
      v13[6].i64[1] = v20;
      v21 = v17 + v14.i64[0];
      if (v13[7].i64[0] >= v21)
        return v6->i64[1];
      goto LABEL_12;
    }
  }
  else if (v13[6].i64[0] >= v19)
  {
    goto LABEL_10;
  }
  v13[6].i64[0] = v19;
  v20 = v15.i64[0] - v15.i64[1];
  if (v13[6].i64[1] < (unint64_t)(v15.i64[0] - v15.i64[1]))
    goto LABEL_16;
LABEL_11:
  v21 = v17 + v14.i64[0];
  if (v13[7].i64[0] < v21)
LABEL_12:
    v13[7].i64[0] = v21;
  return v6->i64[1];
}

void std::deque<HGMemoryManager::Block *>::__add_front_capacity(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  void *v12;
  void *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  void *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  unint64_t v34;
  int64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 *v43;
  char *v44;
  uint64_t v45;
  __int128 v46;
  void *v47;

  v3 = *(char **)(a1 + 8);
  v2 = *(char **)(a1 + 16);
  if (v2 == v3)
    v4 = 0;
  else
    v4 = ((v2 - v3) << 6) - 1;
  v5 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v4 - (*(_QWORD *)(a1 + 40) + v5)) >= 0x200)
  {
    *(_QWORD *)(a1 + 32) = v5 + 512;
    v47 = (void *)*((_QWORD *)v2 - 1);
    *(_QWORD *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  v6 = *(char **)(a1 + 24);
  v7 = *(char **)a1;
  v8 = (uint64_t)&v6[-*(_QWORD *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      v17 = *(_QWORD *)(a1 + 16);
      v47 = *(void **)(v17 - 8);
      *(_QWORD *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
        goto LABEL_9;
    }
    else
    {
      v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
      {
LABEL_9:
        v9 = 256;
LABEL_19:
        *(_QWORD *)(a1 + 32) = v9;
        return;
      }
    }
    v9 = *(_QWORD *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7)
    v10 = 1;
  else
    v10 = v8 >> 2;
  if (v10 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v11 = (char *)operator new(8 * v10);
  v12 = operator new(0x1000uLL);
  v13 = v12;
  if (v10)
  {
    v14 = &v11[8 * v10];
    *(_QWORD *)v11 = v12;
    v15 = v11 + 8;
    v16 = v11;
    if (v3 != v2)
      goto LABEL_27;
    goto LABEL_21;
  }
  v18 = (char *)operator new(8uLL);
  v14 = v18 + 8;
  operator delete(v11);
  v3 = *(char **)(a1 + 8);
  v19 = *(char **)(a1 + 16);
  v11 = v18;
  *(_QWORD *)v18 = v13;
  v15 = v18 + 8;
  v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_27:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16)
            v31 = 1;
          else
            v31 = (v15 - v16) >> 2;
          if (v31 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v32 = (char *)operator new(8 * v31);
          v33 = v32;
          v34 = v31 >> 2;
          v20 = &v32[8 * (v31 >> 2)];
          v23 = v20;
          v35 = v15 - v11;
          if (v15 != v11)
          {
            v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            v36 = v35 - 8;
            if (v36 < 0x38 || (v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              v38 = &v32[8 * (v31 >> 2)];
              v39 = v11;
              goto LABEL_43;
            }
            v41 = (v36 >> 3) + 1;
            v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            v38 = &v20[v42];
            v39 = &v11[v42];
            v43 = (__int128 *)(v11 + 16);
            v44 = &v32[v37 + 16];
            v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_43:
                v40 = *(_QWORD *)v39;
                v39 += 8;
                *(_QWORD *)v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          v15 = &v32[8 * v31];
          if (v16)
            operator delete(v16);
          v16 = v33;
          goto LABEL_26;
        }
        v25 = (v11 - v16) >> 3;
        if (v25 >= -1)
          v26 = v25 + 1;
        else
          v26 = v25 + 2;
        v27 = v26 >> 1;
        v28 = &v11[-8 * (v26 >> 1)];
        v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          v29 = v11;
        }
        v30 = -v27;
        v23 = &v28[v15 - v11];
        v20 = &v29[8 * v30];
      }
      else
      {
        v20 = v11;
        v23 = v15;
        v15 = v14;
      }
LABEL_26:
      v14 = v15;
      v24 = *(_QWORD *)v3;
      v3 += 8;
      *(_QWORD *)v23 = v24;
      v21 = v23 + 8;
      v15 = v21;
      v11 = v20;
      if (v3 == *(char **)(a1 + 16))
        goto LABEL_22;
    }
  }
LABEL_21:
  v20 = v11;
  v21 = v15;
LABEL_22:
  v22 = *(void **)a1;
  *(_QWORD *)a1 = v16;
  *(_QWORD *)(a1 + 8) = v20;
  *(_QWORD *)(a1 + 16) = v21;
  *(_QWORD *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(_QWORD *)(a1 + 32) = 256;
    if (v22)
LABEL_24:
      operator delete(v22);
  }
  else
  {
    *(_QWORD *)(a1 + 32) += 512;
    if (v22)
      goto LABEL_24;
  }
}

void sub_1B29E9A68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t HGMemoryManager::dump(HGMemoryManager::Stats **this, const char *a2)
{
  unsigned __int8 v3;
  double Time;
  const char *v5;
  char *v6;
  double v7;
  unint64_t v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  _BYTE v13[16];

  v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"alloc", a2) >= 1)
  {
    HGMemoryManager::Stats::dump(this[6], (const char *)1);
    HGMemoryManager::dumpToLogger((HGMemoryManager *)this, (char *)1);
  }
  if (this[4] && this[5])
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v13, "alloc", 1, "Time Profile");
    Time = HGProfiler::getTime(this[4]);
    v7 = HGProfiler::getTime(this[5]);
    v8 = *((_QWORD *)this[6] + 2) + *(_QWORD *)this[6];
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
      HGLogger::log((HGLogger *)"alloc", (const char *)1, (HGLogger *)"time doing manager stuff   : %f ms / %zu ops (avg : %f ms)\n", v5, v6, *(_QWORD *)&Time, v8, Time / (double)v8);
    v10 = atomic_load(HGLogger::_enabled);
    if ((v10 & 1) != 0)
      HGLogger::log((HGLogger *)"alloc", (const char *)1, (HGLogger *)"time doing real memory ops : %f ms / %zu ops (avg : %f ms)\n", v5, v6, *(_QWORD *)&v7, v8, v7 / (double)v8);
    v11 = atomic_load(HGLogger::_enabled);
    if ((v11 & 1) != 0)
      HGLogger::log((HGLogger *)"alloc", (const char *)1, (HGLogger *)"total time in mem manager  : %f ms / %zu ops (avg : %f ms)\n", v5, v6, Time + v7, v8, (Time + v7) / (double)v8);
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v13);
  }
  return 0;
}

void sub_1B29E9C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29E9C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29E9C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t **HGMemoryManager::_release(uint64_t a1, char *a2, char *a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v13;
  uint64_t *v14;

  v4 = *(_QWORD *)a3;
  std::deque<Pipeline *>::erase(*(int64x2_t **)(a1 + 24), a2, a3);
  v5 = *(_QWORD **)(a1 + 48);
  v6 = *(_QWORD *)(v4 + 16);
  ++v5[3];
  v7 = v5[8];
  v5[7] += v6;
  v8 = v5[11];
  v9 = v5[10] - v6;
  v5[10] = v9;
  if (v8 < v7)
  {
    v5[11] = v7;
    if (v5[12] >= v9)
    {
LABEL_3:
      v10 = v7 - v5[9];
      if (v5[13] >= v10)
        goto LABEL_4;
LABEL_9:
      v5[13] = v10;
      v11 = v7 + v9;
      if (v5[14] >= v11)
        goto LABEL_6;
      goto LABEL_5;
    }
  }
  else if (v5[12] >= v9)
  {
    goto LABEL_3;
  }
  v5[12] = v9;
  v10 = v7 - v5[9];
  if (v5[13] < v10)
    goto LABEL_9;
LABEL_4:
  v11 = v7 + v9;
  if (v5[14] < v11)
LABEL_5:
    v5[14] = v11;
LABEL_6:
  HGProfilerGuard<(HGProfilerGuardMode)1>::HGProfilerGuard(&v14, *(_QWORD **)(a1 + 32));
  HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(&v13, *(uint64_t **)(a1 + 40));
  free(*(void **)(v4 + 8));
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  MEMORY[0x1B5E29170](v4, 0x10E0C40D70D0186);
  HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(&v13);
  return HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard(&v14);
}

void sub_1B29E9DAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard((uint64_t **)va);
  _Unwind_Resume(a1);
}

void HGMemoryManager::Stats::dump(HGMemoryManager::Stats *this, const char *a2)
{
  const char *v4;
  char *v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  unsigned __int8 v26;
  _BYTE v27[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v27, "alloc", (int)a2, "Memory Manager Stats");
  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  v7 = atomic_load(HGLogger::_enabled);
  if ((v7 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numAllocs           : %zu \n", v4, v5, *(_QWORD *)this);
  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numFrees            : %zu \n", v4, v5, *((_QWORD *)this + 3));
  v9 = atomic_load(HGLogger::_enabled);
  if ((v9 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numReused           : %zu \n", v4, v5, *((_QWORD *)this + 2));
  v10 = atomic_load(HGLogger::_enabled);
  if ((v10 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  numRecycled         : %zu \n", v4, v5, *((_QWORD *)this + 1));
  v11 = atomic_load(HGLogger::_enabled);
  if ((v11 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  v12 = atomic_load(HGLogger::_enabled);
  if ((v12 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalAllocated      : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 4) * 0.00000095367));
  v13 = atomic_load(HGLogger::_enabled);
  if ((v13 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalReleased       : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 7) * 0.00000095367));
  v14 = atomic_load(HGLogger::_enabled);
  if ((v14 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalReused         : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 6) * 0.00000095367));
  v15 = atomic_load(HGLogger::_enabled);
  if ((v15 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalRecycled       : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 5) * 0.00000095367));
  v16 = atomic_load(HGLogger::_enabled);
  if ((v16 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  v17 = atomic_load(HGLogger::_enabled);
  if ((v17 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  allocMem            : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 8) * 0.00000095367));
  v18 = atomic_load(HGLogger::_enabled);
  if ((v18 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  usedMem             : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 9) * 0.00000095367));
  v19 = atomic_load(HGLogger::_enabled);
  if ((v19 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  freeMem             : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 10) * 0.00000095367));
  v20 = atomic_load(HGLogger::_enabled);
  if ((v20 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  totalMem            : %5.1f mb \n", v4, v5, (float)((float)(unint64_t)(*((_QWORD *)this + 10) + *((_QWORD *)this + 8)) * 0.00000095367));
  v21 = atomic_load(HGLogger::_enabled);
  if ((v21 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  v22 = atomic_load(HGLogger::_enabled);
  if ((v22 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakAllocMem        : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 11) * 0.00000095367));
  v23 = atomic_load(HGLogger::_enabled);
  if ((v23 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakFreeMem         : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 12) * 0.00000095367));
  v24 = atomic_load(HGLogger::_enabled);
  if ((v24 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakUnusedMem       : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 13) * 0.00000095367));
  v25 = atomic_load(HGLogger::_enabled);
  if ((v25 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"  peakTotalMem        : %5.1f mb \n", v4, v5, (float)((float)*((unint64_t *)this + 14) * 0.00000095367));
  v26 = atomic_load(HGLogger::_enabled);
  if ((v26 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v27);
}

void sub_1B29EA234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMemoryManager::dumpToLogger(HGMemoryManager *this, char *a2)
{
  const char *v4;
  char *v5;
  uint64_t v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  HGMemoryManager::Block **v13;
  uint64_t v14;
  HGMemoryManager::Block **v15;
  uint64_t v16;
  float v17;
  float v18;
  uint64_t v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  HGMemoryManager::Block **v28;
  uint64_t v29;
  HGMemoryManager::Block **v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  _BYTE v33[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v33, "alloc", (int)a2, "Dump Memory Blocks");
  v6 = *((_QWORD *)this + 7);
  v7 = atomic_load(HGLogger::_enabled);
  if ((v7 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  v8 = atomic_load(HGLogger::_enabled);
  if ((v8 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"used blocks:\n", v4, v5);
  v9 = (_QWORD *)*((_QWORD *)this + 2);
  v10 = v9[1];
  if (v9[2] != v10)
  {
    v11 = v9[4];
    v12 = (_QWORD *)(v10 + 8 * (v11 >> 9));
    v13 = (HGMemoryManager::Block **)(*v12 + 8 * (v11 & 0x1FF));
    v14 = *(_QWORD *)(v10 + (((v9[5] + v11) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v9[5] + v11) & 0x1FF);
    while (v13 != (HGMemoryManager::Block **)v14)
    {
      HGMemoryManager::Block::dump(*v13++, v6, a2, v4, v5);
      if ((HGMemoryManager::Block **)((char *)v13 - *v12) == (HGMemoryManager::Block **)4096)
      {
        v15 = (HGMemoryManager::Block **)v12[1];
        ++v12;
        v13 = v15;
      }
    }
  }
  v16 = *((_QWORD *)this + 6);
  v17 = (float)*(unint64_t *)(v16 + 64) * 0.00000095367;
  v18 = (float)*(unint64_t *)(v16 + 72) * 0.00000095367;
  if (v17 <= 0.0)
  {
    v19 = 0;
    v21 = atomic_load(HGLogger::_enabled);
    if ((v21 & 1) == 0)
      goto LABEL_15;
    goto LABEL_14;
  }
  v19 = (int)(float)((float)(v18 * 100.0) / v17);
  v20 = atomic_load(HGLogger::_enabled);
  if ((v20 & 1) != 0)
LABEL_14:
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)" total : %5.1f mb(using : %5.1f mb or %3d%%)\n", v4, v5, v17, v18, v19);
LABEL_15:
  v22 = atomic_load(HGLogger::_enabled);
  if ((v22 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  v23 = atomic_load(HGLogger::_enabled);
  if ((v23 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"free blocks:\n", v4, v5);
  v24 = (_QWORD *)*((_QWORD *)this + 3);
  v25 = v24[1];
  if (v24[2] != v25)
  {
    v26 = v24[4];
    v27 = (_QWORD *)(v25 + 8 * (v26 >> 9));
    v28 = (HGMemoryManager::Block **)(*v27 + 8 * (v26 & 0x1FF));
    v29 = *(_QWORD *)(v25 + (((v24[5] + v26) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v24[5] + v26) & 0x1FF);
    while (v28 != (HGMemoryManager::Block **)v29)
    {
      HGMemoryManager::Block::dump(*v28++, v6, a2, v4, v5);
      if ((HGMemoryManager::Block **)((char *)v28 - *v27) == (HGMemoryManager::Block **)4096)
      {
        v30 = (HGMemoryManager::Block **)v27[1];
        ++v27;
        v28 = v30;
      }
    }
  }
  v31 = atomic_load(HGLogger::_enabled);
  if ((v31 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)" total : %5.1f mb\n", v4, v5, (float)((float)*(unint64_t *)(*((_QWORD *)this + 6) + 80) * 0.00000095367));
  v32 = atomic_load(HGLogger::_enabled);
  if ((v32 & 1) != 0)
    HGLogger::log((HGLogger *)"alloc", a2, (HGLogger *)"\n", v4, v5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v33);
}

void sub_1B29EA4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EA510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EA524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EA538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EA54C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMemoryManager::Block::dump(HGMemoryManager::Block *this, uint64_t a2, char *a3, const char *a4, char *a5)
{
  unint64_t v5;
  unsigned __int8 v6;

  v5 = *((_QWORD *)this + 2);
  v6 = atomic_load(HGLogger::_enabled);
  if (v5 <= 0x100000)
  {
    if ((v6 & 1) != 0)
      HGLogger::log((HGLogger *)"alloc", a3, (HGLogger *)"  %p : %8lu bytes (%7.1f kb) (using %7.1f kb) (age : %4lu) (total usage : %4d for %7.1f kb, average : %7.1f kb)\n", a4, a5, *((_QWORD *)this + 1), *((_QWORD *)this + 2), (float)((float)*((unint64_t *)this + 2) * 0.00097656), (float)((float)*((unint64_t *)this + 3) * 0.00097656), a2 - *((_QWORD *)this + 6), *((unsigned int *)this + 10), (float)((float)*((unint64_t *)this + 4) * 0.00097656), (float)((float)((float)*((unint64_t *)this + 4) * 0.00097656) / (float)*((unsigned int *)this + 10)));
  }
  else if ((v6 & 1) != 0)
  {
    HGLogger::log((HGLogger *)"alloc", a3, (HGLogger *)"  %p : %8lu bytes (%7.1f mb) (using %7.1f mb) (age : %4lu) (total usage : %4d for %7.1f mb, average : %7.1f mb)\n", a4, a5, *((_QWORD *)this + 1), *((_QWORD *)this + 2), (float)((float)*((unint64_t *)this + 2) * 0.00000095367), (float)((float)*((unint64_t *)this + 3) * 0.00000095367), a2 - *((_QWORD *)this + 6), *((unsigned int *)this + 10), (float)((float)*((unint64_t *)this + 4) * 0.00000095367), (float)((float)((float)*((unint64_t *)this + 4) * 0.00000095367) / (float)*((unsigned int *)this + 10)));
  }
}

void HGMetalContext::HGMetalContext(HGMetalContext *this, const HGMetalDeviceInfo *a2)
{
  _QWORD *v4;
  const HGMetalDeviceInfo *v5;
  const HGMetalDeviceInfo *DeviceResources;
  unint64_t v7;

  HGObject::HGObject(this);
  *v4 = off_1E6519A78;
  v4[2] = a2;
  DeviceResources = HGGPUResources::getDeviceResources(a2, v5);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = DeviceResources;
  *((_BYTE *)this + 52) = 1;
  *((_DWORD *)this + 14) = 64;
  *((_DWORD *)this + 16) = 1;
  *((_QWORD *)this + 9) = -1;
  *((_QWORD *)this + 10) = 0x100000000;
  *((_QWORD *)this + 11) = -1;
  *((_QWORD *)this + 12) = 0x101010100000020;
  *((_QWORD *)this + 4) = objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 16), "newCommandQueue");
  *((_DWORD *)this + 12) = 29;
  v7 = (unint64_t)(float)((float)*(unint64_t *)(*((_QWORD *)this + 2) + 40) * 0.1);
  *((_QWORD *)this + 10) = 0x500000002;
  if (v7 >= 0x40000000)
    v7 = 0x40000000;
  *((_QWORD *)this + 11) = v7;
}

void sub_1B29EA74C(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B29EA760(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGMetalContext::~HGMetalContext(id *this)
{
  *this = off_1E6519A78;

  this[4] = 0;
  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;

  *this = off_1E6519A78;

  this[4] = 0;
  HGObject::~HGObject((HGObject *)this);
  HGObject::operator delete(v2);
}

void HGMetalContext::setLabel(HGMetalContext *this, const char *__s)
{
  size_t v4;
  void *v5;
  void **v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  std::string::size_type v10;
  std::string *p_p;
  uint64_t v12;
  uint64_t v13;
  std::string *v14;
  void *v15;
  int v16;
  void *v17;
  void **v18;
  std::string __p;
  void *__dst[2];
  int64_t v21;

  v4 = strlen(__s);
  if (v4 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    v21 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_8;
  }
  HIBYTE(v21) = v4;
  v6 = __dst;
  if (v4)
LABEL_8:
    memcpy(v6, __s, (size_t)v5);
  *((_BYTE *)v5 + (_QWORD)v6) = 0;
  v9 = strlen(__s);
  if (v9 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  v10 = v9;
  if (v9 >= 0x17)
  {
    v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v12 = v9 | 7;
    v13 = v12 + 1;
    p_p = (std::string *)operator new(v12 + 1);
    __p.__r_.__value_.__l.__size_ = v10;
    __p.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_16;
  }
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = v9;
  p_p = &__p;
  if (v9)
LABEL_16:
    memcpy(p_p, __s, v10);
  p_p->__r_.__value_.__s.__data_[v10] = 0;
  v14 = std::string::append(&__p, " Frame");
  v15 = (void *)v14->__r_.__value_.__r.__words[0];
  v16 = SHIBYTE(v14->__r_.__value_.__r.__words[2]);
  v14->__r_.__value_.__r.__words[0] = 0;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v17 = (void *)*((_QWORD *)this + 4);
  if (v21 >= 0)
    v18 = __dst;
  else
    v18 = (void **)__dst[0];
  objc_msgSend(v17, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v18, __p.__r_.__value_.__r.__words[0], __p.__r_.__value_.__l.__size_, __p.__r_.__value_.__r.__words[2]));
  if ((v16 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v21) & 0x80000000) == 0)
      return;
LABEL_26:
    operator delete(__dst[0]);
    return;
  }
  operator delete(v15);
  if (SHIBYTE(v21) < 0)
    goto LABEL_26;
}

void sub_1B29EA9C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void HGMetalContext::synchronizeCommandQueue(id *this)
{
  void *v2;
  _BYTE v3[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v3, "metal", 1, "HGMetalContext::synchronizeCommandQueue()");
  v2 = (void *)objc_msgSend(this[4], "commandBuffer");
  objc_msgSend(v2, "setLabel:", CFSTR("HG synchronizeCommandQueue"));
  objc_msgSend((id)objc_msgSend(v2, "blitCommandEncoder"), "endEncoding");
  objc_msgSend(v2, "commit");
  objc_msgSend(v2, "waitUntilCompleted");
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v3);
}

void sub_1B29EAA80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29EAA94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGMetalContext::bufferPool(HGMetalContext *this)
{
  if (*((_BYTE *)this + 100))
    return *(_QWORD *)(*((_QWORD *)this + 3) + 32);
  else
    return 0;
}

uint64_t HGMetalContext::texturePool(HGMetalContext *this)
{
  if (*((_BYTE *)this + 101))
    return *(_QWORD *)(*((_QWORD *)this + 3) + 40);
  else
    return 0;
}

uint64_t HGMetalContext::bufferInfiniPool(HGMetalContext *this)
{
  if (*((_BYTE *)this + 102))
    return *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  else
    return 0;
}

uint64_t HGMetalContext::getCVTextureCacheRetainedRef(HGGPUResources **this)
{
  return HGGPUResources::getCVTextureCacheRetainedRef(this[3]);
}

uint64_t HGMetalContext::setCommandBufferLimits(uint64_t this, int a2, uint64_t a3)
{
  *(_DWORD *)(this + 64) = a2;
  *(_QWORD *)(this + 72) = a3;
  return this;
}

uint64_t HGMetalContext::setCommandQueueLimits(uint64_t this, int a2, int a3, uint64_t a4)
{
  *(_DWORD *)(this + 80) = a2;
  *(_DWORD *)(this + 84) = a3;
  *(_QWORD *)(this + 88) = a4;
  return this;
}

void HGObject::~HGObject(HGObject *this)
{
  *(_QWORD *)this = off_1E6519AC8;
}

{
  *(_QWORD *)this = off_1E6519AC8;
}

void HGObject::~HGObject(void *this)
{
  *(_QWORD *)this = off_1E6519AC8;
  operator delete(this);
}

uint64_t HGObject::Retain(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this + 8);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

unsigned int *HGObject::Release(unsigned int *this)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;

  v1 = this + 2;
  do
  {
    v2 = __ldaxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    do
      v4 = __ldaxr(v1);
    while (__stlxr(v4 + 1, v1));
    if (this)
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)this + 8))(this);
  }
  return this;
}

void HGObject::debugDescription(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

unint64_t HGMalloc(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;

  v2 = (unint64_t)malloc_type_malloc(a1 + 144, 0x7092249BuLL);
  v3 = v2 & 0xFFFFFFFFFFFFFF80;
  *(_QWORD *)(v3 + 112) = a1;
  *(_QWORD *)(v3 + 120) = v2;
  return (v2 & 0xFFFFFFFFFFFFFF80) + 128;
}

void HGFree(uint64_t a1)
{
  free(*(void **)(a1 - 8));
}

const void *HGRealloc(const void *a1, unint64_t a2)
{
  const void *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = a1;
  if (!a1 || *((_QWORD *)a1 - 2) < a2)
  {
    v4 = (unint64_t)malloc_type_malloc(a2 + 144, 0xE5E6AEA1uLL);
    v5 = v4 & 0xFFFFFFFFFFFFFF80;
    v6 = (v4 & 0xFFFFFFFFFFFFFF80) + 128;
    *(_QWORD *)(v5 + 112) = a2;
    *(_QWORD *)(v5 + 120) = v4;
    if (v3)
    {
      memcpy((void *)((v4 & 0xFFFFFFFFFFFFFF80) + 128), v3, *((_QWORD *)v3 - 2));
      free(*((void **)v3 - 1));
    }
    return (const void *)v6;
  }
  return v3;
}

unint64_t HGGetTBCFrequency()
{
  unint64_t result;

  result = qword_1ED4D94E0;
  if (!qword_1ED4D94E0)
  {
    mach_timebase_info((mach_timebase_info_t)&_MergedGlobals_3);
    result = 1000000000 * (unint64_t)*(unsigned int *)algn_1ED4D94DC / _MergedGlobals_3;
    qword_1ED4D94E0 = result;
  }
  return result;
}

uint64_t HGGetActiveCPU()
{
  size_t v1;
  unsigned int v2;

  v2 = 0;
  v1 = 4;
  if (sysctlbyname("hw.physicalcpu", &v2, &v1, 0, 0) && sysctlbyname("hw.ncpu", &v2, &v1, 0, 0))
    return 1;
  return v2;
}

uint64_t GLPBO::GLPBO(uint64_t a1, PC_Sp_counted_base **a2)
{
  PC_Sp_counted_base *v3;
  GLuint *v4;
  PCSharedCount v6;
  _BYTE v7[16];

  *(_DWORD *)a1 = 0;
  v3 = *a2;
  *(_QWORD *)(a1 + 8) = *a2;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = (GLuint *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 29) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v6.var0 = v3;
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v7, &v6.var0);
  PCSharedCount::PCSharedCount(&v6);
  glGenFramebuffers(1, v4);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v7);
  return a1;
}

void sub_1B29EADB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  PCSharedCount *v3;
  va_list va;

  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  PCSharedCount::PCSharedCount(v3);
  _Unwind_Resume(a1);
}

void sub_1B29EADD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount *v10;

  PCSharedCount::PCSharedCount(&a10);
  PCSharedCount::PCSharedCount(v10);
  _Unwind_Resume(a1);
}

void GLPBO::_delete(GLPBO *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v6;
  PCSharedCount v7;
  _BYTE v8[16];

  if (*((_DWORD *)this + 7))
  {
    v6 = atomic_load(HGLogger::_enabled);
    if ((v6 & 1) != 0)
      HGLogger::log((HGLogger *)"pbo", (const char *)1, (HGLogger *)"GLPBO::_delete()\n", a4, a5);
    if (*((_QWORD *)this + 5))
    {
      GLPBO::_unmap(this);
      *((_QWORD *)this + 5) = 0;
    }
    v7.var0 = (PC_Sp_counted_base *)*((_QWORD *)this + 1);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v8, &v7.var0);
    PCSharedCount::PCSharedCount(&v7);
    glDeleteBuffers(1, (const GLuint *)this + 5);
    *((_DWORD *)this + 5) = 0;
    *((_DWORD *)this + 7) = 0;
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v8);
  }
}

void sub_1B29EAE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B29EAEAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t GLPBO::_setup(GLPBO *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  PCSharedCount v11;
  _BYTE v12[16];

  if ((_DWORD)a2 && *((_DWORD *)this + 7) == (_DWORD)a2)
    return 1;
  GLPBO::_delete(this, a2, a3, a4, a5);
  v10 = atomic_load(HGLogger::_enabled);
  if ((v10 & 1) != 0)
    HGLogger::log((HGLogger *)"pbo", (const char *)1, (HGLogger *)"GLPBO::_setup( size = %d)\n", v8, v9, a2);
  *((_DWORD *)this + 7) = a2;
  v11.var0 = (PC_Sp_counted_base *)*((_QWORD *)this + 1);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v12, &v11.var0);
  PCSharedCount::PCSharedCount(&v11);
  glGenBuffers(1, (GLuint *)this + 5);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v12);
  return 1;
}

void sub_1B29EAF88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

void sub_1B29EAF9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void GLPBO::_map(GLPBO *this)
{
  PCSharedCount v2;
  _BYTE v3[16];
  PCSharedCount v4;
  _BYTE v5[16];

  if (GLPBO::m_ForcePostReadPixelsFinish)
  {
    v4.var0 = (PC_Sp_counted_base *)*((_QWORD *)this + 1);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v5, &v4.var0);
    PCSharedCount::PCSharedCount(&v4);
    glFinish();
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v5);
  }
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v5, "pbo", 1, "GLPBO::_map()");
  v2.var0 = (PC_Sp_counted_base *)*((_QWORD *)this + 1);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v3, &v2.var0);
  PCSharedCount::PCSharedCount(&v2);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v5);
}

void sub_1B29EB058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EB06C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::PCSharedCount(&a12);
  _Unwind_Resume(a1);
}

void sub_1B29EB080(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B29EB09C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B29EB0B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t GLPBO::_unmap(GLPBO *this)
{
  PCSharedCount v3;
  _BYTE v4[16];
  _BYTE v5[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v5, "pbo", 1, "GLPBO::_unmap()");
  v3.var0 = (PC_Sp_counted_base *)*((_QWORD *)this + 1);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v4, &v3.var0);
  PCSharedCount::PCSharedCount(&v3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v4);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v5);
  return 0;
}

void sub_1B29EB144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B29EB160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, uint64_t a11, uint64_t a12, char a13)
{
  PCSharedCount::PCSharedCount(&a10);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B29EB17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void GLPBO::ReadPixels(PC_Sp_counted_base **this, int a2, uint64_t a3, const char *a4, char *a5, int a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  int v12;
  uint64_t v14;
  PCSharedCount v15;
  _BYTE v16[16];

  v12 = (int)a5;
  if (this[5])
  {
    GLPBO::_unmap((GLPBO *)this);
    this[5] = 0;
  }
  *((_DWORD *)this + 6) = a6;
  v14 = (a6 * v12);
  if (*(_DWORD *)this)
    v14 = (float)(ceilf((float)v14 / (float)*(unsigned int *)this)
                              * (float)*(unsigned int *)this);
  GLPBO::_setup((GLPBO *)this, v14, a3, a4, a5);
  v15.var0 = this[1];
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v16, &v15.var0);
  PCSharedCount::PCSharedCount(&v15);
  *((_BYTE *)this + 36) = 1;
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v16);
}

void sub_1B29EB23C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EB250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::PCSharedCount(&a10);
  _Unwind_Resume(a1);
}

uint64_t GLPBO::forcePostReadPixelsFinish(uint64_t this)
{
  GLPBO::m_ForcePostReadPixelsFinish = this;
  return this;
}

uint64_t GLPBO::forcePostReadPixelsFence(uint64_t this)
{
  GLPBO::m_ForcePostReadPixelsFence = this;
  return this;
}

HGObject *HGPixelBufferObj::HGPixelBufferObj(HGObject *a1, PC_Sp_counted_base **a2)
{
  uint64_t v4;
  uint64_t v5;
  PCSharedCount v7;

  HGObject::HGObject(a1);
  *(_QWORD *)v4 = off_1E6519B10;
  *(_QWORD *)(v4 + 48) = 0;
  *(_BYTE *)(v4 + 56) = 0;
  v5 = operator new();
  v7.var0 = *a2;
  GLPBO::GLPBO(v5, &v7.var0);
  *((_QWORD *)a1 + 2) = v5;
  PCSharedCount::PCSharedCount(&v7);
  return a1;
}

void sub_1B29EB300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  HGObject *v10;
  uint64_t v11;

  PCSharedCount::PCSharedCount(&a10);
  MEMORY[0x1B5E29170](v11, 0x1080C404AC29809);
  HGObject::~HGObject(v10);
  _Unwind_Resume(a1);
}

void sub_1B29EB334(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGPixelBufferObj::~HGPixelBufferObj(HGPixelBufferObj *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  HGRenderUtils::BufferCopier *v6;
  uint64_t v7;
  PCSharedCount v8;
  _BYTE v9[16];

  *(_QWORD *)this = off_1E6519B10;
  v6 = (HGRenderUtils::BufferCopier *)*((_QWORD *)this + 6);
  if (v6)
  {
    HGRenderUtils::BufferCopier::~BufferCopier(v6);
    MEMORY[0x1B5E29170]();
  }
  v7 = *((_QWORD *)this + 2);
  if (v7)
  {
    GLPBO::_delete(*((GLPBO **)this + 2), a2, a3, a4, a5);
    v8.var0 = *(PC_Sp_counted_base **)(v7 + 8);
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v9, &v8.var0);
    PCSharedCount::PCSharedCount(&v8);
    glDeleteFramebuffers(1, (const GLuint *)(v7 + 16));
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v9);
    PCSharedCount::PCSharedCount((PCSharedCount *)(v7 + 8));
    MEMORY[0x1B5E29170](v7, 0x1080C404AC29809);
  }
  HGObject::~HGObject(this);
}

{
  void *v5;

  HGPixelBufferObj::~HGPixelBufferObj(this, a2, a3, a4, a5);
  HGObject::operator delete(v5);
}

uint64_t HGPixelBufferObj::rect(HGPixelBufferObj *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t HGPixelBufferObj::format(HGPixelBufferObj *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t HGPixelBufferObj::rowBytes(HGPixelBufferObj *this)
{
  return *(unsigned int *)(*((_QWORD *)this + 2) + 24);
}

uint64_t HGPixelBufferObj::padding(uint64_t this, int a2)
{
  **(_DWORD **)(this + 16) = a2;
  return this;
}

void HGPixelBufferObj::ReadPixels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v12;
  int v13;
  uint64_t v14;
  const char *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  BOOL v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  _BYTE v27[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v27, "pbo", 1, "HGPixelBufferObj::ReadPixels()");
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 40) = a8;
  HGFormatUtils::toGLType(a8);
  HGFormatUtils::toGLFormat(*(_DWORD *)(a1 + 40));
  v12 = HGFormatUtils::bytesPerPixel(*(_DWORD *)(a1 + 40));
  v18 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24);
  v19 = *(_DWORD *)(a1 + 40);
  v20 = v19 - 14;
  v21 = (v18 + 1) >> 1;
  v22 = v19 == 31;
  v23 = ((2863311531u * (unint64_t)(v18 + 5)) >> 32) & 0xFFFFFFFC;
  if (!v22)
    v23 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24);
  if (v20 >= 3)
    v24 = v12;
  else
    v24 = 2 * v12;
  if (v20 < 3)
    v23 = v21;
  GLPBO::ReadPixels(*(PC_Sp_counted_base ***)(a1 + 16), v13, v14, v15, (char *)(*(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 28)), v23 * v24, v16, v17, v25, HIDWORD(v25), v26);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v27);
}

void sub_1B29EB53C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EB550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EB564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EB578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B29EB58C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGPixelBufferObj::GetDataPtr(HGPixelBufferObj *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = *((_QWORD *)this + 2);
  result = *(_QWORD *)(v1 + 40);
  if (!result)
  {
    GLPBO::_map((GLPBO *)v1);
    result = *(_QWORD *)(v1 + 40);
  }
  *(_BYTE *)(v1 + 36) = 0;
  return result;
}

uint64_t HGPixelBufferObj::ReleaseDataPtr(HGPixelBufferObj *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 2);
  if (*(_QWORD *)(v1 + 40))
  {
    GLPBO::_unmap(*((GLPBO **)this + 2));
    *(_QWORD *)(v1 + 40) = 0;
  }
  return 0;
}

void HGPixelBufferObj::StartCopyBitmap(HGPixelBufferObj *this, HGBitmap *a2)
{
  uint64_t v4;
  const char *v5;
  char *v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  HGRenderUtils::BufferCopier *v12;
  void *v13;
  _BYTE v14[128];

  v4 = HGRectIntersection(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28), *((_QWORD *)this + 3), *((_QWORD *)this + 4));
  v7 = (_DWORD)v5 == (_DWORD)v4 || HIDWORD(v5) == HIDWORD(v4);
  if (v7 || (v8 = *((unsigned int *)a2 + 4), (_DWORD)v8 != *((_DWORD *)this + 10)))
  {
    HGLogger::warning((HGLogger *)"incompatible formats", v5, v6);
  }
  else
  {
    v9 = *((_QWORD *)this + 2);
    v10 = *(_QWORD *)(v9 + 40);
    if (v10)
    {
      v11 = *((_QWORD *)this + 2);
    }
    else
    {
      GLPBO::_map(*((GLPBO **)this + 2));
      v10 = *(_QWORD *)(v9 + 40);
      v11 = *((_QWORD *)this + 2);
      v8 = *((unsigned int *)this + 10);
    }
    *(_BYTE *)(v9 + 36) = 0;
    HGBitmap::HGBitmap(v14, *((_QWORD *)this + 3), *((_QWORD *)this + 4), v8, v10, *(unsigned int *)(v11 + 24));
    v12 = (HGRenderUtils::BufferCopier *)*((_QWORD *)this + 6);
    if (!v12)
    {
      v12 = (HGRenderUtils::BufferCopier *)operator new();
      HGRenderUtils::BufferCopier::BufferCopier(v12);
      *((_QWORD *)this + 6) = v12;
    }
    HGRenderUtils::BufferCopier::start((dispatch_group_t **)v12, a2, (HGBitmap *)v14);
    *((_BYTE *)this + 56) = 1;
    HGBitmap::~HGBitmap((HGBitmap *)v14, v13);
  }
}

void sub_1B29EB71C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void *v11;

  MEMORY[0x1B5E29170](v9, 0x20C4093837F09);
  HGBitmap::~HGBitmap((HGBitmap *)&a9, v11);
  _Unwind_Resume(a1);
}

void sub_1B29EB748(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGBitmap::~HGBitmap((HGBitmap *)&a9, a2);
  _Unwind_Resume(a1);
}

intptr_t HGPixelBufferObj::FinishCopyBitmap(intptr_t this)
{
  intptr_t v1;

  v1 = this;
  if (*(_BYTE *)(this + 56))
  {
    this = HGRenderUtils::BufferCopier::finish(*(_QWORD *)(this + 48));
    *(_BYTE *)(v1 + 56) = 0;
  }
  return this;
}

void HGPixelBufferObj::CopyBitmap(intptr_t *this, HGBitmap *a2)
{
  _BYTE v4[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v4, "pbo", 1, "HGPixelBufferObj::CopyBitmap()");
  HGPixelBufferObj::StartCopyBitmap((HGPixelBufferObj *)this, a2);
  if (*((_BYTE *)this + 56))
  {
    HGRenderUtils::BufferCopier::finish(this[6]);
    *((_BYTE *)this + 56) = 0;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v4);
}

void sub_1B29EB810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

HGBitmap *HGPixelBufferObj::CreateBitmap(HGPixelBufferObj *this)
{
  HGBitmap *v2;
  _BYTE v4[16];

  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v4, "pbo", 1, "HGPixelBufferObj::CreateBitmap()");
  v2 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v2, *((_QWORD *)this + 3), *((_QWORD *)this + 4), *((unsigned int *)this + 10));
  HGPixelBufferObj::CopyBitmap((intptr_t *)this, v2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v4);
  return v2;
}

void sub_1B29EB89C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  HGObject::operator delete(v9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29EB8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29EB8CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGGPURenderContext::HGGPURenderContext(uint64_t a1, uint64_t *a2, PC_Sp_counted_base **a3)
{
  uint64_t v6;
  HGGPUComputeDevice **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  void *v20;
  HGGPURenderer *v21;
  HGObject *v22;
  HGObject *v23;
  PCSharedCount v25;
  HGObject *v26;
  PCSharedCount v27;
  PCSharedCount v28;
  HGGLContext *v29;

  HGRenderContext::HGRenderContext((HGRenderContext *)a1);
  *(_QWORD *)v6 = off_1E6519B60;
  *(_QWORD *)(v6 + 136) = 0;
  v7 = (HGGPUComputeDevice **)(v6 + 136);
  *(_QWORD *)(v6 + 144) = 0;
  *(_QWORD *)(v6 + 184) = 0;
  *(_DWORD *)(v6 + 36) = 1;
  v8 = *a2;
  v9 = a2[1];
  if (!v9)
  {
    *(_QWORD *)(a1 + 136) = v8;
    *(_QWORD *)(a1 + 144) = 0;
    v17 = *(std::__shared_weak_count **)(a1 + 24);
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)(a1 + 24) = 0;
    if (!v17)
      goto LABEL_19;
    goto LABEL_15;
  }
  v10 = (unint64_t *)(v9 + 8);
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  v12 = *(std::__shared_weak_count **)(a1 + 144);
  *(_QWORD *)(a1 + 136) = v8;
  *(_QWORD *)(a1 + 144) = v9;
  if (!v12)
    goto LABEL_10;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  v8 = *(_QWORD *)(a1 + 136);
  v9 = *(_QWORD *)(a1 + 144);
  if (v9)
  {
LABEL_10:
    v15 = (unint64_t *)(v9 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = *(std::__shared_weak_count **)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 24) = v9;
  if (v17)
  {
LABEL_15:
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
LABEL_19:
  HGGPUComputeDevice::GetGLVirtualScreen(*v7);
  v28.var0 = *a3;
  HGGLContext::Create((uint64_t *)&v28, (HGObject **)&v29);
  PCSharedCount::PCSharedCount(&v28);
  HGGLContext::setVirtualScreen(v29);
  v20 = HGObject::operator new(0x5C8uLL);
  HGGLContext::context((uint64_t *)&v27, v29);
  HGGPURenderer::HGGPURenderer(v20, &v27, 1);
  *(_QWORD *)(a1 + 152) = v20;
  PCSharedCount::PCSharedCount(&v27);
  v21 = *(HGGPURenderer **)(a1 + 152);
  *(_QWORD *)(a1 + 72) = v21;
  *(_DWORD *)(a1 + 160) = 0;
  HGGPURenderer::GetCurrentContext(v21, (uint64_t *)&v25);
  HGGLContext::Share((uint64_t *)&v25, &v26);
  v22 = *(HGObject **)(a1 + 184);
  v23 = v26;
  if (v22 == v26)
  {
    if (v22)
      (*(void (**)(HGObject *))(*(_QWORD *)v22 + 24))(v22);
  }
  else
  {
    if (v22)
    {
      (*(void (**)(HGObject *))(*(_QWORD *)v22 + 24))(v22);
      v23 = v26;
    }
    *(_QWORD *)(a1 + 184) = v23;
    v26 = 0;
  }
  PCSharedCount::PCSharedCount(&v25);
  *(_QWORD *)(a1 + 168) = (*(int (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 72) + 128))(*(_QWORD *)(a1 + 72), 18);
  *(_BYTE *)(a1 + 176) = (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 152) + 128))(*(_QWORD *)(a1 + 152), 22) != 0;
  *(_BYTE *)(a1 + 177) = (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 152) + 128))(*(_QWORD *)(a1 + 152), 40) != 0;
  if (v29)
    (*(void (**)(HGGLContext *))(*(_QWORD *)v29 + 24))(v29);
  return a1;
}

void sub_1B29EBB48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, uint64_t a11, PCSharedCount a12, PCSharedCount a13, uint64_t a14)
{
  HGRenderContext *v14;
  uint64_t v15;
  uint64_t v17;

  if (a11)
    (*(void (**)(uint64_t))(*(_QWORD *)a11 + 24))(a11);
  PCSharedCount::PCSharedCount(&a10);
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 24))(a14);
  v17 = *((_QWORD *)v14 + 23);
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v15);
  HGRenderContext::~HGRenderContext(v14);
  _Unwind_Resume(a1);
}

void HGGPURenderContext::~HGGPURenderContext(HGGPURenderContext *this)
{
  HGGPURenderer *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  *(_QWORD *)this = off_1E6519B60;
  v2 = (HGGPURenderer *)*((_QWORD *)this + 19);
  if (v2)
  {
    HGGPURenderer::FinishMetalCommandBuffer(v2);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 19) + 24))(*((_QWORD *)this + 19));
  }
  v3 = *((_QWORD *)this + 23);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 18);
  if (!v4)
    goto LABEL_9;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    HGRenderContext::~HGRenderContext(this);
  }
  else
  {
LABEL_9:
    HGRenderContext::~HGRenderContext(this);
  }
}

{
  void *v1;

  HGGPURenderContext::~HGGPURenderContext(this);
  HGObject::operator delete(v1);
}

uint64_t HGGPURenderContext::DumpContext(HGGPURenderContext *this)
{
  puts("-----------------------------------------");
  printf("Dumping HGGPURenderContext: %p\n", this);
  printf("    _state                    : %d\n", *((_DWORD *)this + 8));
  printf("    _type                     : %d\n", *((_DWORD *)this + 9));
  printf("    _renderer                 : %p\n", *((const void **)this + 9));
  printf("    _renderQueue              : %p\n", *((const void **)this + 6));
  printf("    _renderGraphDumpLevel     : %d\n", *((_DWORD *)this + 22));
  printf("    _intermediateBufferFormat : %d\n", *((_DWORD *)this + 20));
  printf("    _defaultFilteringMode     : %d\n", *((_DWORD *)this + 21));
  printf("    _concatenationFlag        : %d\n", *((unsigned __int8 *)this + 176));
  printf("    _renderStatsFlag          : %d\n", *((unsigned __int8 *)this + 92));
  printf("    _renderStatsWarmUp        : %lu\n", *((_QWORD *)this + 12));
  printf("    _renderStatsMaxVals       : %lu\n", *((_QWORD *)this + 13));
  return puts("-----------------------------------------");
}

uint64_t HGGPURenderContext::GetGPURenderer(HGGPURenderContext *this)
{
  return *((_QWORD *)this + 19);
}

void HGGPURenderContext::GetGLContext(HGGLContext **this@<X0>, HGGLContextPtr *a2@<X8>)
{
  void *v3;

  v3 = (void *)HGGLContext::ptr(this[23]);
  HGGLContextPtr::HGGLContextPtr(a2, v3);
}

uint64_t HGGPURenderContext::GetGLContextPriority(HGGLContext **this)
{
  return HGGLContext::getPriority(this[23]);
}

uint64_t HGGPURenderContext::SetGLContextPriority(_QWORD *a1)
{
  HGObject *v2;
  uint64_t v3;
  HGObject *v4;
  PCSharedCount v6;
  HGObject *v7;
  PCSharedCount v8;
  HGObject *v9[2];
  char v10;

  v2 = (HGObject *)a1[7];
  v9[1] = v2;
  v10 = 0;
  HGSynchronizable::Lock((HGSynchronizable *)v2);
  HGGPURenderer::GetContext(a1[9], 24, (uint64_t *)&v8);
  HGGLContext::Share((uint64_t *)&v8, v9);
  PCSharedCount::PCSharedCount(&v8);
  HGGPURenderer::GetContext(a1[9], 0, (uint64_t *)&v6);
  HGGLContext::Share((uint64_t *)&v6, &v7);
  PCSharedCount::PCSharedCount(&v6);
  if ((HGGLContext::setPriority((uint64_t)v9[0]) & 1) == 0 || !HGGLContext::setPriority((uint64_t)v7))
  {
    v3 = 0;
    v4 = v7;
    if (!v7)
      goto LABEL_7;
    goto LABEL_6;
  }
  v3 = HGGLContext::setPriority(a1[23]);
  v4 = v7;
  if (v7)
LABEL_6:
    (*(void (**)(HGObject *))(*(_QWORD *)v4 + 24))(v4);
LABEL_7:
  if (v9[0])
    (*(void (**)(HGObject *))(*(_QWORD *)v9[0] + 24))(v9[0]);
  HGSynchronizable::Unlock((HGSynchronizable *)v2);
  return v3;
}

void sub_1B29EBF70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, uint64_t a12, HGSynchronizable *a13)
{
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  if (a12)
    (*(void (**)(uint64_t))(*(_QWORD *)a12 + 24))(a12);
  HGSynchronizer::~HGSynchronizer(&a13);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGGPURenderContext::SetGLTexturePoolingPolicy(uint64_t a1, uint64_t *a2)
{
  HGSynchronizable *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[2];
  char v9;

  v4 = *(HGSynchronizable **)(a1 + 56);
  v8[1] = v4;
  v9 = 0;
  HGSynchronizable::Lock(v4);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 1472);
  if (v5)
  {
    v6 = *a2;
    v8[0] = v6;
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
    HGTextureManager::setTexturePoolingPolicy(v5, v8);
    if (v8[0])
      (*(void (**)(_QWORD))(*(_QWORD *)v8[0] + 24))(v8[0]);
  }
  return HGSynchronizable::Unlock(v4);
}

void sub_1B29EC090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B29EC0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  if (a3)
    (*(void (**)(uint64_t))(*(_QWORD *)a3 + 24))(a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGGPURenderContext::SetGLTexturePaddingPolicy(uint64_t a1, _QWORD **a2)
{
  HGSynchronizable *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v8[2];
  char v9;

  v4 = *(HGSynchronizable **)(a1 + 56);
  v8[1] = &v4->var0;
  v9 = 0;
  HGSynchronizable::Lock(v4);
  v5 = *(_QWORD **)(*(_QWORD *)(a1 + 152) + 1472);
  if (v5)
  {
    v6 = *a2;
    v8[0] = v6;
    if (v6)
      (*(void (**)(_QWORD *))(*v6 + 16))(v6);
    HGTextureManager::setTexturePaddingPolicy(v5, v8);
    if (v8[0])
      (*(void (**)(_QWORD *))(*v8[0] + 24))(v8[0]);
  }
  return HGSynchronizable::Unlock(v4);
}

void sub_1B29EC168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B29EC17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  if (a3)
    (*(void (**)(uint64_t))(*(_QWORD *)a3 + 24))(a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void HRasterizerTextureNoColor::HRasterizerTextureNoColor(HRasterizerTextureNoColor *this)
{
  uint64_t v1;
  char *v7;

  HgcRasterizerTextureNoColor::HgcRasterizerTextureNoColor(this);
  *(_QWORD *)v1 = off_1E6519BB8;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v1 + 420) = _Q0;
  HgcRasterizerTextureNoColor::SetParameter((HgcRasterizerTextureNoColor *)v1, 0, 1.0, 1.0, 1.0, 1.0, v7);
}

void sub_1B29EC200(_Unwind_Exception *a1)
{
  HgcRasterizerTextureNoColor *v1;

  HgcRasterizerTextureNoColor::~HgcRasterizerTextureNoColor(v1);
  _Unwind_Resume(a1);
}

void HRasterizerTextureNoColor::~HRasterizerTextureNoColor(HRasterizerTextureNoColor *this)
{
  void *v1;

  HgcRasterizerTextureNoColor::~HgcRasterizerTextureNoColor(this);
  HGObject::operator delete(v1);
}

HGRect *HGRect::Init(HGRect *this, int a2, int a3, int a4, int a5)
{
  int v5;
  int v6;
  int v7;
  int v8;

  if (a2 >= a4)
    v5 = a4;
  else
    v5 = a2;
  if (a2 <= a4)
    v6 = a4;
  else
    v6 = a2;
  if (a3 >= a5)
    v7 = a5;
  else
    v7 = a3;
  this->var0 = v5;
  this->var1 = v7;
  if (a3 <= a5)
    v8 = a5;
  else
    v8 = a3;
  this->var2 = v6;
  this->var3 = v8;
  return this;
}

float HGRectf::Init(HGRectf *this, float a2, float a3, float a4, float a5)
{
  float v5;
  float result;

  v5 = fminf(a2, a4);
  result = fmaxf(a2, a4);
  *(float *)this = v5;
  *((float *)this + 1) = fminf(a3, a5);
  *((float *)this + 2) = result;
  *((float *)this + 3) = fmaxf(a3, a5);
  return result;
}

int32x2_t HGRect::Init(_QWORD *a1, double a2, float a3, double a4, float a5)
{
  int32x2_t result;
  float32x2_t v7;
  int8x8_t v8;

  if (*(float *)&a4 < *(float *)&a2 || a5 < a3)
  {
    result = 0;
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    *((float *)&a2 + 1) = a3;
    result = vcvt_s32_f32(vrndm_f32(vmaxnm_f32(*(float32x2_t *)&a2, (float32x2_t)0xCF000000CF000000)));
    *((float *)&a4 + 1) = a5;
    v7 = vrndp_f32(vminnm_f32(*(float32x2_t *)&a4, (float32x2_t)0x4F0000004F000000));
    v8 = (int8x8_t)vcge_f32(v7, (float32x2_t)0x4F0000004F000000);
    *a1 = result;
    a1[1] = vorr_s8((int8x8_t)(*(_QWORD *)&v8 & 0x7FFFFFFF7FFFFFFFLL), vbic_s8((int8x8_t)vcvt_s32_f32(v7), v8));
  }
  return result;
}

HGRect *HGRect::Grow(HGRect *this, HGRect a2)
{
  int var1;
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  int v7;
  int var2;
  int var3;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;

  var1 = this->var1;
  if (this->var0 >= (a2.var0 ^ 0x7FFFFFFF))
    v3 = 0x7FFFFFFF;
  else
    v3 = this->var0 + a2.var0;
  if (this->var0 <= (signed int)(0x80000000 - a2.var0))
    v4 = 0x80000000;
  else
    v4 = this->var0 + a2.var0;
  if (a2.var0 > 0)
    v4 = v3;
  if (var1 >= (a2.var1 ^ 0x7FFFFFFF))
    v5 = 0x7FFFFFFF;
  else
    v5 = var1 + a2.var1;
  if (var1 <= (int)(0x80000000 - a2.var1))
    v6 = 0x80000000;
  else
    v6 = var1 + a2.var1;
  if (a2.var1 <= 0)
    v7 = v6;
  else
    v7 = v5;
  var2 = this->var2;
  var3 = this->var3;
  v10 = var2 + a2.var2;
  if (var2 >= (a2.var2 ^ 0x7FFFFFFF))
    v11 = 0x7FFFFFFF;
  else
    v11 = var2 + a2.var2;
  if (var2 <= (int)(0x80000000 - a2.var2))
    v10 = 0x80000000;
  if (a2.var2 > 0)
    v10 = v11;
  if (var3 >= (a2.var3 ^ 0x7FFFFFFF))
    v12 = 0x7FFFFFFF;
  else
    v12 = var3 + a2.var3;
  if (var3 <= (int)(0x80000000 - a2.var3))
    v13 = 0x80000000;
  else
    v13 = var3 + a2.var3;
  this->var0 = v4;
  this->var1 = v7;
  if (a2.var3 <= 0)
    v14 = v13;
  else
    v14 = v12;
  this->var2 = v10;
  this->var3 = v14;
  return this;
}

BOOL HGRect::IsEqual(HGRect *this, HGRect a2)
{
  return this->var0 == a2.var0 && this->var1 == a2.var1 && this->var2 == a2.var2 && this->var3 == a2.var3;
}

BOOL HGRect::IsInfinite(HGRect *this)
{
  if (this->var0 == 0x80000000)
    return 1;
  if (this->var1 == 0x80000000)
    return 1;
  if (this->var2 == 0x7FFFFFFF)
    return 1;
  return this->var3 == 0x7FFFFFFF;
}

BOOL HGRect::IsNull(HGRect *this)
{
  return this->var2 <= this->var0 || this->var3 <= this->var1;
}

BOOL HGRect::IsZero(HGRect *this)
{
  if (this->var0)
    return 0;
  if (this->var1)
    return 0;
  if (this->var2)
    return 0;
  return this->var3 == 0;
}

BOOL HGRect::ContainsRect(HGRect *this, HGRect a2)
{
  if (this->var0 > a2.var0)
    return 0;
  if (this->var1 > a2.var1)
    return 0;
  if (this->var2 >= a2.var2)
    return this->var3 >= a2.var3;
  return 0;
}

HGRect *HGRect::Intersection(HGRect *this, HGRect a2)
{
  int var2;
  int var0;
  int var1;
  int var3;
  int v6;
  int v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  BOOL v12;

  var2 = this->var2;
  var0 = this->var0;
  if (var2 <= this->var0)
    goto LABEL_21;
  var1 = a2.var1;
  var3 = a2.var3;
  v6 = this->var3;
  v7 = this->var1;
  v8 = v6 <= v7 || a2.var2 <= a2.var0;
  v9 = v8 || a2.var3 <= a2.var1;
  v10 = v9 || var2 <= a2.var0;
  v11 = v10 || v6 <= a2.var1;
  v12 = !v11 && var0 < a2.var2;
  if (v12 && v7 < a2.var3)
  {
    if (var0 <= a2.var0)
      var0 = a2.var0;
    if (v7 > a2.var1)
      var1 = this->var1;
    this->var0 = var0;
    this->var1 = var1;
    if (var2 >= a2.var2)
      var2 = a2.var2;
    if (v6 < a2.var3)
      var3 = v6;
    this->var2 = var2;
    this->var3 = var3;
  }
  else
  {
LABEL_21:
    *(_QWORD *)&this->var0 = 0;
    *(_QWORD *)&this->var2 = 0;
  }
  return this;
}

uint64_t HGRectMake4i(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;

  if ((int)a1 >= (int)a3)
    v4 = a3;
  else
    v4 = a1;
  if ((int)a2 >= (int)a4)
    v5 = a4;
  else
    v5 = a2;
  return v4 | (v5 << 32);
}

HGRect *HGRect::Union(HGRect *this, HGRect a2)
{
  int var1;
  int var3;
  int var0;
  int var2;

  if (a2.var2 > a2.var0)
  {
    var1 = a2.var1;
    var3 = a2.var3;
    if (a2.var3 > a2.var1)
    {
      var0 = this->var0;
      if (this->var0 >= a2.var0)
        var0 = a2.var0;
      if (this->var1 < a2.var1)
        var1 = this->var1;
      this->var0 = var0;
      this->var1 = var1;
      var2 = this->var2;
      if (var2 <= a2.var2)
        var2 = a2.var2;
      if (this->var3 > a2.var3)
        var3 = this->var3;
      this->var2 = var2;
      this->var3 = var3;
    }
  }
  return this;
}

float HGRectFloat(int a1)
{
  return (float)a1;
}

uint64_t HGRectGrow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  LODWORD(v3) = a3 + a1;
  if ((int)(a3 ^ 0x7FFFFFFF) <= (int)a1)
    v4 = 0x7FFFFFFF;
  else
    v4 = a3 + a1;
  if ((int)(0x80000000 - a3) >= (int)a1)
    LODWORD(v3) = 0x80000000;
  if ((int)a3 <= 0)
    v3 = v3;
  else
    v3 = v4;
  if ((HIDWORD(a3) ^ 0x7FFFFFFF) <= SHIDWORD(a1))
    v5 = 0x7FFFFFFF;
  else
    v5 = HIDWORD(a3) + HIDWORD(a1);
  if ((int)(0x80000000 - HIDWORD(a3)) >= SHIDWORD(a1))
    LODWORD(v6) = 0x80000000;
  else
    LODWORD(v6) = HIDWORD(a3) + HIDWORD(a1);
  if (SHIDWORD(a3) <= 0)
    v6 = v6;
  else
    v6 = v5;
  return v3 | (v6 << 32);
}

BOOL HGRectIsEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && (_DWORD)a2 == (_DWORD)a4 && HIDWORD(a2) == HIDWORD(a4);
}

BOOL HGRectIsEqualSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (_DWORD)a2 - (_DWORD)a1 == (_DWORD)a4 - (_DWORD)a3 && HIDWORD(a2) - HIDWORD(a1) == HIDWORD(a4) - HIDWORD(a3);
}

BOOL HGRectIsInfinite(unint64_t a1, unint64_t a2)
{
  return (_DWORD)a1 == 0x80000000 || HIDWORD(a1) == 0x80000000 || (_DWORD)a2 == 0x7FFFFFFF || HIDWORD(a2) == 0x7FFFFFFF;
}

BOOL HGRectIsNull(uint64_t a1, uint64_t a2)
{
  return (int)a2 <= (int)a1 || SHIDWORD(a2) <= SHIDWORD(a1);
}

BOOL HGRectContainsRect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (int)a1 <= (int)a3 && SHIDWORD(a1) <= SHIDWORD(a3) && (int)a2 >= (int)a4 && SHIDWORD(a2) >= SHIDWORD(a4);
}

BOOL HGRectExcludesRect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (int)a1 > (int)a4 || SHIDWORD(a1) > SHIDWORD(a4) || (int)a2 < (int)a3 || SHIDWORD(a2) < SHIDWORD(a3);
}

uint64_t HGRectIntegral@<X0>(uint64_t a1@<X8>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>)
{
  uint64_t v5;

  if (a4 < a2 || a5 < a3)
    return 0;
  LODWORD(a1) = vcvtms_s32_f32(fmaxf(a2, -2147500000.0));
  LODWORD(v5) = vcvtms_s32_f32(fmaxf(a3, -2147500000.0));
  return a1 | (v5 << 32);
}

uint64_t HGRectIntersection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((int)a2 <= (int)a1)
    return 0;
  v4 = 0;
  if (SHIDWORD(a2) <= SHIDWORD(a1)
    || (int)a4 <= (int)a3
    || SHIDWORD(a4) <= SHIDWORD(a3)
    || (int)a2 <= (int)a3
    || SHIDWORD(a2) <= SHIDWORD(a3)
    || (int)a1 >= (int)a4)
  {
    return 0;
  }
  v5 = 0;
  if (SHIDWORD(a1) < SHIDWORD(a4))
  {
    if ((int)a1 <= (int)a3)
      v4 = a3;
    else
      v4 = a1;
    if (SHIDWORD(a1) <= SHIDWORD(a3))
      v6 = HIDWORD(a3);
    else
      v6 = HIDWORD(a1);
    v5 = v6 << 32;
  }
  return v5 | v4;
}

uint64_t HGRectMake4f@<X0>(uint64_t a1@<X8>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>)
{
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;

  v6 = fminf(a2, a4);
  v7 = fmaxf(a2, a4);
  v8 = fminf(a3, a5);
  v9 = fmaxf(a3, a5);
  if (v7 < v6 || v9 < v8)
    return 0;
  LODWORD(a1) = vcvtms_s32_f32(fmaxf(v6, -2147500000.0));
  LODWORD(v5) = vcvtms_s32_f32(fmaxf(v8, -2147500000.0));
  return a1 | (v5 << 32);
}

float HGRectfMake4f(float a1, double a2, float a3)
{
  return fminf(a1, a3);
}

float HGRectTranslate(float a1, double a2, float a3, double a4, float a5)
{
  return fminf(a1 + a5, a3 + a5);
}

float HGRectScale(float a1, double a2, float a3, double a4, float a5)
{
  float v5;
  float v6;
  float v7;
  float v8;

  v5 = a1 * a5;
  v6 = a3 * a5;
  v7 = fminf(v5, v6);
  v8 = fminf(v6, v5);
  if (a5 < 0.0)
    return v8;
  else
    return v7;
}

uint64_t HGRectUnion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((int)a2 > (int)a1 && SHIDWORD(a2) > SHIDWORD(a1))
  {
    if ((int)a1 >= (int)a3)
      v4 = a3;
    else
      v4 = a1;
    if (SHIDWORD(a1) >= SHIDWORD(a3))
      v5 = HIDWORD(a3);
    else
      v5 = HIDWORD(a1);
    v6 = v4 | (v5 << 32);
    if (SHIDWORD(a4) <= SHIDWORD(a3))
      v6 = a1;
    if ((int)a4 > (int)a3)
      return v6;
    else
      return a1;
  }
  return a3;
}

void HGRenderUtils::BufferCopierImpl::~BufferCopierImpl(dispatch_group_t *this)
{
  if (*((_BYTE *)this + 72))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 72) = 0;
  }
  dispatch_release(*this);
}

{
  if (*((_BYTE *)this + 72))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 72) = 0;
  }
  dispatch_release(*this);
}

intptr_t HGRenderUtils::BufferCopierImpl::finish_dispatch(intptr_t this)
{
  intptr_t v1;

  if (*(_BYTE *)(this + 72))
  {
    v1 = this;
    this = dispatch_group_wait(*(dispatch_group_t *)this, 0xFFFFFFFFFFFFFFFFLL);
    *(_BYTE *)(v1 + 72) = 0;
  }
  return this;
}

uint64_t HGRenderUtils::BufferCopierImpl::_build_context@<X0>(HGRenderUtils::BufferCopierImpl *this@<X0>, HGBitmap *a2@<X1>, HGBitmap *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v7;
  int v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64x2_t v11;
  uint64x2_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  float64x2_t v17;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t result;
  uint64_t v28;
  uint64_t v29;

  v7 = HGRectIntersection(*(_QWORD *)((char *)a3 + 20), *(_QWORD *)((char *)a3 + 28), *(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28));
  v9.i32[0] = *((_DWORD *)a3 + 5);
  v9.i32[1] = *((_DWORD *)a2 + 5);
  v10 = vsub_s32(vdup_n_s32(v7), v9);
  v11.i64[0] = v10.i32[0];
  v11.i64[1] = v10.i32[1];
  v12 = v11;
  v14 = (v13 - v7);
  v15 = *((_QWORD *)a3 + 7);
  if (*((_DWORD *)a3 + 4) == 31)
  {
    v16 = 4 * v15 * ((v14 + 5) / 6uLL);
    v17 = vcvtq_f64_u64(v12);
    __asm { FMOV            V1.2D, #3.0 }
    v12 = vcvtq_u64_f64(vdivq_f64(vaddq_f64(v17, v17), _Q1));
  }
  else
  {
    v16 = v15 * v14;
  }
  v23 = *((_QWORD *)a3 + 8);
  v25 = *((_QWORD *)a2 + 7);
  v24 = *((_QWORD *)a2 + 8);
  v26 = (v8 - HIDWORD(v7));
  result = v7 >> 32;
  v28 = *((_QWORD *)a2 + 10) + v24 * (result - *((int *)a2 + 6));
  *a4 = *((_QWORD *)a3 + 10) + v23 * (result - *((int *)a3 + 6)) + v12.i64[0] * v15;
  a4[1] = v28 + v25 * v12.i64[1];
  v29 = 4;
  if (v23 != v16 || v24 != v16)
    v29 = v26 >> 2;
  a4[2] = v23;
  a4[3] = v24;
  if (v26 < 0x40)
    v29 = v26;
  a4[4] = v16;
  a4[5] = v26;
  a4[6] = v29;
  a4[7] = 0;
  *((_BYTE *)a4 + 56) = v23 == v16 && v24 == v16;
  return result;
}

void *HGRenderUtils::BufferCopierImpl::plain_copy(HGRenderUtils::BufferCopierImpl *this, HGBitmap *a2, HGBitmap *a3)
{
  void *result;
  __int128 v5;
  __int128 v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  unsigned int v11;
  char *v12;
  char *v13;
  char *v14;
  _OWORD v16[4];

  result = (void *)HGRenderUtils::BufferCopierImpl::_build_context(this, a2, a3, v16);
  v5 = v16[1];
  *(_OWORD *)((char *)this + 8) = v16[0];
  *(_OWORD *)((char *)this + 24) = v5;
  v6 = v16[3];
  *(_OWORD *)((char *)this + 40) = v16[2];
  *(_OWORD *)((char *)this + 56) = v6;
  if (*((_BYTE *)this + 64))
    return memcpy(*((void **)this + 2), *((const void **)this + 1), *((_QWORD *)this + 6) * *((_QWORD *)this + 5));
  v7 = *((_QWORD *)this + 6);
  if (v7)
  {
    v8 = *((_QWORD *)this + 3);
    v9 = *((_QWORD *)this + 4);
    v10 = *((_QWORD *)this + 5);
    v11 = 1;
    v14 = (char *)this + 8;
    v12 = (char *)*((_QWORD *)this + 1);
    v13 = (char *)*((_QWORD *)v14 + 1);
    do
    {
      result = memcpy(v13, v12, v10);
      v12 += v8;
      v13 += v9;
    }
    while (v7 > v11++);
  }
  return result;
}

void HGRenderUtils::BufferCopierImpl::start_dispatch(dispatch_group_t *this, HGBitmap *a2, HGBitmap *a3)
{
  dispatch_group_t *v5;
  __int128 v6;
  __int128 v7;
  int v8;
  NSObject *v9;
  NSObject *global_queue;
  void (__cdecl *v11)(void *);
  _OWORD v12[4];

  v5 = this;
  if (*((_BYTE *)this + 72))
  {
    this = (dispatch_group_t *)dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)v5 + 72) = 0;
  }
  HGRenderUtils::BufferCopierImpl::_build_context((HGRenderUtils::BufferCopierImpl *)this, a2, a3, v12);
  v6 = v12[1];
  *(_OWORD *)(v5 + 1) = v12[0];
  *(_OWORD *)(v5 + 3) = v6;
  v7 = v12[3];
  *(_OWORD *)(v5 + 5) = v12[2];
  *(_OWORD *)(v5 + 7) = v7;
  v8 = *((unsigned __int8 *)v5 + 64);
  v9 = *v5;
  global_queue = dispatch_get_global_queue(0, 0);
  if (v8)
  else
  dispatch_group_async_f(v9, global_queue, v5 + 1, v11);
  *((_BYTE *)v5 + 72) = 1;
}

void `anonymous namespace'::block_single_copy_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3;
  NSObject *global_queue;

  v3 = *((_QWORD *)this + 6);
  global_queue = dispatch_get_global_queue(0, 0);
}

void `anonymous namespace'::block_copy_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3;
  NSObject *global_queue;

  v3 = *((_QWORD *)this + 6);
  global_queue = dispatch_get_global_queue(0, 0);
}

void HGRenderUtils::BufferReformatterImpl::~BufferReformatterImpl(dispatch_group_t *this)
{
  if (*((_BYTE *)this + 32))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 32) = 0;
  }
  dispatch_release(*this);
}

{
  if (*((_BYTE *)this + 32))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 32) = 0;
  }
  dispatch_release(*this);
}

intptr_t HGRenderUtils::BufferReformatterImpl::finish_dispatch(intptr_t this)
{
  intptr_t v1;

  if (*(_BYTE *)(this + 32))
  {
    v1 = this;
    this = dispatch_group_wait(*(dispatch_group_t *)this, 0xFFFFFFFFFFFFFFFFLL);
    *(_BYTE *)(v1 + 32) = 0;
  }
  return this;
}

pthread_mutex_t *HGRenderUtils::BufferReformatterImpl::plain_reformat(HGRenderUtils::BufferReformatterImpl *this, HGBitmap *a2, HGBitmap *a3)
{
  uint64_t v5;
  uint64_t v6;
  HGMemory *v7;
  void *v8;

  v5 = *(_QWORD *)((char *)a2 + 20);
  v6 = *(_QWORD *)((char *)a2 + 28);
  v7 = (HGMemory *)HGMemory::allocate((HGMemory *)(16 * (v6 - v5) * (HIDWORD(v6) - HIDWORD(v5))), 0, (unint64_t *)a3);
  (*(void (**)(HGBitmap *, HGMemory *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 72))(a3, v7, v5, v6, 0);
  (*(void (**)(HGBitmap *, HGMemory *, uint64_t, uint64_t))(*(_QWORD *)a2 + 80))(a2, v7, v5, v6);
  return HGMemory::release(v7, v8);
}

void HGRenderUtils::BufferReformatterImpl::start_dispatch(dispatch_group_t *this, HGBitmap *a2, NSObject *a3)
{
  unint64_t v6;
  NSObject *v7;
  NSObject *global_queue;

  if (*((_BYTE *)this + 32))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 32) = 0;
  }
  v6 = (*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
  if (v6 >= 0x40)
    v6 >>= 2;
  this[1] = a3;
  this[2] = (dispatch_group_t)a2;
  this[3] = (dispatch_group_t)v6;
  v7 = *this;
  global_queue = dispatch_get_global_queue(0, 0);
  *((_BYTE *)this + 32) = 1;
}

void `anonymous namespace'::block_reformat_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3;
  NSObject *global_queue;

  v3 = *((_QWORD *)this + 2);
  global_queue = dispatch_get_global_queue(0, 0);
}

void HGRenderUtils::BufferFillerImpl::~BufferFillerImpl(dispatch_group_t *this)
{
  dispatch_group_t v2;

  if (*((_BYTE *)this + 240))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 240) = 0;
  }
  dispatch_release(*this);
  v2 = this[29];
  if (v2)
    MEMORY[0x1B5E2914C](v2, 0x1000C8077774924);
}

{
  dispatch_group_t v2;

  if (*((_BYTE *)this + 240))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 240) = 0;
  }
  dispatch_release(*this);
  v2 = this[29];
  if (v2)
    MEMORY[0x1B5E2914C](v2, 0x1000C8077774924);
}

intptr_t HGRenderUtils::BufferFillerImpl::finish_dispatch(intptr_t this)
{
  intptr_t v1;

  if (*(_BYTE *)(this + 240))
  {
    v1 = this;
    this = dispatch_group_wait(*(dispatch_group_t *)this, 0xFFFFFFFFFFFFFFFFLL);
    *(_BYTE *)(v1 + 240) = 0;
  }
  return this;
}

void HGRenderUtils::BufferFillerImpl::plain_fill(HGRenderUtils::BufferFillerImpl *this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4, size_t a5)
{
  uint64_t v7;
  uint64_t v8;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const void *v39;
  char *v40;
  size_t v41;
  _QWORD *v42;
  unsigned int v43;
  unsigned int v44;
  void *__p;
  _BYTE *v46;
  char *v47;

  v7 = *(_QWORD *)&a3.var2;
  v8 = *(_QWORD *)&a3.var0;
  v11 = (_OWORD *)((char *)a2 + 20);
  v12 = HGRectIntersection(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28), *(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2);
  v14 = v13;
  __p = 0;
  v46 = 0;
  v47 = 0;
  if (HGRectIsNull(v8, v7))
  {
    v15 = 0;
    v16 = 0;
  }
  else
  {
    if (!HGRectIsNull(v12, v14))
    {
      goto LABEL_16;
    }
    v15 = v46;
    v16 = v47;
  }
  v17 = (v15 - (_BYTE *)__p) >> 4;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v19 = v16 - (_BYTE *)__p;
  if (v19 >> 3 > v18)
    v18 = v19 >> 3;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0)
    v20 = 0xFFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v21 = (char *)operator new(16 * v20);
  }
  else
  {
    v21 = 0;
  }
  v22 = &v21[16 * v17];
  *(_OWORD *)v22 = *v11;
  __p = v22;
  v47 = &v21[16 * v20];
  v46 = v22 + 16;
LABEL_16:
  v23 = *((_DWORD *)a2 + 7);
  v24 = *((_DWORD *)a2 + 5);
  v25 = v23 - v24;
  v26 = *((_QWORD *)this + 29);
  if (v26)
    MEMORY[0x1B5E2914C](v26, 0x1000C8077774924);
  v27 = (char *)operator new[]();
  *((_QWORD *)this + 29) = v27;
  if (v23 != v24)
  {
    do
    {
      memcpy(v27, a4, a5);
      v27 += a5;
      --v25;
    }
    while (v25);
  }
  if (v46 - (_BYTE *)__p >= 1)
  {
    v28 = (unint64_t)(v46 - (_BYTE *)__p) >> 4;
    do
    {
      v30 = (char *)__p + 16 * v28 - 16;
      v31 = *(_QWORD *)v30;
      v32 = *((_DWORD *)v30 + 3);
      v33 = HIDWORD(*(_QWORD *)v30);
      v34 = *((_DWORD *)v30 + 2) - *(_QWORD *)v30;
      v35 = (v32 - HIDWORD(v31));
      v36 = v35 >> 2;
      if (v35 < 0x40)
        v36 = (v32 - HIDWORD(v31));
      v37 = *((_QWORD *)a2 + 7);
      v38 = *((_QWORD *)a2 + 8);
      v39 = (const void *)*((_QWORD *)this + 29);
      v40 = (char *)(*((_QWORD *)a2 + 10)
                   + v38 * ((v31 >> 32) - *((int *)a2 + 6))
                   + v37 * ((int)v31 - (uint64_t)*((int *)a2 + 5)));
      v41 = v37 * v34;
      v42 = (_QWORD *)((char *)this + 56 * v28 - 56);
      v42[1] = v40;
      v42[2] = v38;
      v42[3] = v39;
      v42[4] = v37 * v34;
      v42[5] = v34;
      v42[6] = v35;
      v42[7] = v36;
      v43 = v32 - v33;
      if (v32 != (_DWORD)v33)
      {
        v44 = 0;
        do
        {
          memcpy(v40, v39, v41);
          v40 += v38;
          ++v44;
        }
        while (v43 > v44);
      }
    }
    while (v28-- > 1);
  }
  if (__p)
  {
    v46 = __p;
    operator delete(__p);
  }
}

void sub_1B29ED454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::subdivideRect(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t **a5)
{
  signed int v7;
  unint64_t v8;
  signed int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t *v24;
  uint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  uint64_t *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t *v47;
  uint64_t *v48;
  int v49;
  uint64_t *v50;
  unint64_t v51;
  int v52;
  uint64_t v53;
  char *v54;
  uint64_t *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t *v70;
  uint64_t *v71;
  int v72;
  unint64_t v73;
  int v74;
  unint64_t v75;

  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = HIDWORD(a3);
  v75 = HIDWORD(a3);
  if (SHIDWORD(a3) > SHIDWORD(a1))
  {
    v11 = HGRectMake4i(a1, HIDWORD(a1), a2, HIDWORD(a3));
    v13 = v11;
    v14 = v12;
    v16 = a5[1];
    v15 = (unint64_t)a5[2];
    if ((unint64_t)v16 < v15)
    {
      *v16 = v11;
      v16[1] = v12;
      v17 = (uint64_t)(v16 + 2);
LABEL_17:
      a5[1] = (uint64_t *)v17;
      goto LABEL_18;
    }
    v73 = a4;
    v18 = *a5;
    v19 = ((char *)v16 - (char *)*a5) >> 4;
    v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 60)
      goto LABEL_80;
    v21 = v15 - (_QWORD)v18;
    if (v21 >> 3 > v20)
      v20 = v21 >> 3;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
      v22 = 0xFFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22)
    {
      if (v22 >> 60)
        goto LABEL_81;
      v23 = (char *)operator new(16 * v22);
      v24 = (uint64_t *)&v23[16 * v19];
      v25 = (uint64_t *)&v23[16 * v22];
      *v24 = v13;
      v24[1] = v14;
      v17 = (uint64_t)(v24 + 2);
      if (v16 != v18)
      {
LABEL_13:
        a4 = v73;
        do
        {
          *((_OWORD *)v24 - 1) = *((_OWORD *)v16 - 1);
          v24 -= 2;
          v16 -= 2;
        }
        while (v16 != v18);
        v16 = *a5;
        *a5 = v24;
        a5[1] = (uint64_t *)v17;
        a5[2] = v25;
        LODWORD(v10) = v75;
        if (!v16)
          goto LABEL_17;
LABEL_16:
        operator delete(v16);
        goto LABEL_17;
      }
    }
    else
    {
      v24 = (uint64_t *)(16 * v19);
      v25 = 0;
      *v24 = v11;
      v24[1] = v12;
      v17 = 16 * v19 + 16;
      if (v16 != v18)
        goto LABEL_13;
    }
    a4 = v73;
    LODWORD(v10) = v75;
    *a5 = v24;
    a5[1] = (uint64_t *)v17;
    a5[2] = v25;
    if (!v16)
      goto LABEL_17;
    goto LABEL_16;
  }
LABEL_18:
  v26 = HIDWORD(a4);
  if (SHIDWORD(a4) >= SHIDWORD(v8))
    goto LABEL_35;
  v27 = HGRectMake4i(v9, HIDWORD(a4), v8, HIDWORD(v8));
  v29 = v27;
  v30 = v28;
  v32 = a5[1];
  v31 = (unint64_t)a5[2];
  if ((unint64_t)v32 >= v31)
  {
    v72 = v8;
    v74 = a4;
    v34 = *a5;
    v35 = ((char *)v32 - (char *)*a5) >> 4;
    v36 = v35 + 1;
    if ((unint64_t)(v35 + 1) >> 60)
      goto LABEL_80;
    v37 = v31 - (_QWORD)v34;
    if (v37 >> 3 > v36)
      v36 = v37 >> 3;
    if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF0)
      v38 = 0xFFFFFFFFFFFFFFFLL;
    else
      v38 = v36;
    if (v38)
    {
      if (v38 >> 60)
        goto LABEL_81;
      v39 = (char *)operator new(16 * v38);
      v40 = (uint64_t *)&v39[16 * v35];
      v41 = (uint64_t *)&v39[16 * v38];
      *v40 = v29;
      v40[1] = v30;
      v33 = (uint64_t)(v40 + 2);
      if (v32 != v34)
      {
LABEL_30:
        LODWORD(v8) = v72;
        LODWORD(a4) = v74;
        LODWORD(v10) = v75;
        do
        {
          *((_OWORD *)v40 - 1) = *((_OWORD *)v32 - 1);
          v40 -= 2;
          v32 -= 2;
        }
        while (v32 != v34);
        v32 = *a5;
        *a5 = v40;
        a5[1] = (uint64_t *)v33;
        a5[2] = v41;
        if (!v32)
          goto LABEL_34;
LABEL_33:
        operator delete(v32);
        goto LABEL_34;
      }
    }
    else
    {
      v40 = (uint64_t *)(16 * v35);
      v41 = 0;
      *v40 = v27;
      v40[1] = v28;
      v33 = 16 * v35 + 16;
      if (v32 != v34)
        goto LABEL_30;
    }
    LODWORD(v8) = v72;
    LODWORD(a4) = v74;
    LODWORD(v10) = v75;
    *a5 = v40;
    a5[1] = (uint64_t *)v33;
    a5[2] = v41;
    if (!v32)
      goto LABEL_34;
    goto LABEL_33;
  }
  *v32 = v27;
  v32[1] = v28;
  v33 = (uint64_t)(v32 + 2);
  LODWORD(v10) = v75;
LABEL_34:
  a5[1] = (uint64_t *)v33;
LABEL_35:
  if (v7 > v9)
  {
    v42 = HGRectMake4i(v9, v10, v7, v26);
    v44 = v42;
    v45 = v43;
    v47 = a5[1];
    v46 = (unint64_t)a5[2];
    if ((unint64_t)v47 >= v46)
    {
      v49 = a4;
      v50 = *a5;
      a4 = ((char *)v47 - (char *)*a5) >> 4;
      v51 = a4 + 1;
      if ((a4 + 1) >> 60)
        goto LABEL_80;
      v52 = v8;
      v53 = v46 - (_QWORD)v50;
      if (v53 >> 3 > v51)
        v51 = v53 >> 3;
      if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF0)
        v8 = 0xFFFFFFFFFFFFFFFLL;
      else
        v8 = v51;
      if (v8)
      {
        if (v8 >> 60)
          goto LABEL_81;
        v54 = (char *)operator new(16 * v8);
      }
      else
      {
        v54 = 0;
      }
      v55 = (uint64_t *)&v54[16 * a4];
      v56 = (uint64_t *)&v54[16 * v8];
      *v55 = v44;
      v55[1] = v45;
      v48 = v55 + 2;
      LODWORD(v8) = v52;
      LODWORD(a4) = v49;
      if (v47 != v50)
      {
        do
        {
          *((_OWORD *)v55 - 1) = *((_OWORD *)v47 - 1);
          v55 -= 2;
          v47 -= 2;
        }
        while (v47 != v50);
        v47 = *a5;
      }
      LODWORD(v10) = v75;
      *a5 = v55;
      a5[1] = v48;
      a5[2] = v56;
      if (v47)
        operator delete(v47);
    }
    else
    {
      *v47 = v42;
      v47[1] = v43;
      v48 = v47 + 2;
    }
    a5[1] = v48;
  }
  if ((int)a4 >= (int)v8)
    return;
  v57 = HGRectMake4i(a4, v10, v8, v26);
  v59 = v57;
  v60 = v58;
  v62 = a5[1];
  v61 = (unint64_t)a5[2];
  if ((unint64_t)v62 >= v61)
  {
    v64 = *a5;
    v65 = ((char *)v62 - (char *)*a5) >> 4;
    v66 = v65 + 1;
    if (!((unint64_t)(v65 + 1) >> 60))
    {
      v67 = v61 - (_QWORD)v64;
      if (v67 >> 3 > v66)
        v66 = v67 >> 3;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF0)
        v68 = 0xFFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      if (!v68)
      {
        v70 = (uint64_t *)(16 * v65);
        v71 = 0;
        *v70 = v57;
        v70[1] = v58;
        v63 = 16 * v65 + 16;
        if (v62 == v64)
          goto LABEL_76;
        goto LABEL_74;
      }
      if (!(v68 >> 60))
      {
        v69 = (char *)operator new(16 * v68);
        v70 = (uint64_t *)&v69[16 * v65];
        v71 = (uint64_t *)&v69[16 * v68];
        *v70 = v59;
        v70[1] = v60;
        v63 = (uint64_t)(v70 + 2);
        if (v62 == v64)
        {
LABEL_76:
          *a5 = v70;
          a5[1] = (uint64_t *)v63;
          a5[2] = v71;
          if (v62)
            operator delete(v62);
          goto LABEL_78;
        }
        do
        {
LABEL_74:
          *((_OWORD *)v70 - 1) = *((_OWORD *)v62 - 1);
          v70 -= 2;
          v62 -= 2;
        }
        while (v62 != v64);
        v62 = *a5;
        goto LABEL_76;
      }
LABEL_81:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_80:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  *v62 = v57;
  v62[1] = v58;
  v63 = (uint64_t)(v62 + 2);
LABEL_78:
  a5[1] = (uint64_t *)v63;
}

void HGRenderUtils::BufferFillerImpl::start_dispatch(dispatch_group_t *this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4, size_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  int v20;
  int v21;
  int v22;
  dispatch_group_t v23;
  NSObject *v24;
  char *v25;
  unint64_t v26;
  NSObject *global_queue;
  unint64_t v28;
  uint64_t v29;
  dispatch_group_t *v30;
  uint64_t v31;
  dispatch_group_t v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  void *__p;
  char *v39;
  char *v40;

  v7 = *(_QWORD *)&a3.var2;
  v8 = *(_QWORD *)&a3.var0;
  if (*((_BYTE *)this + 240))
  {
    dispatch_group_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)this + 240) = 0;
  }
  v11 = HGRectIntersection(*(_QWORD *)((char *)a2 + 20), *(_QWORD *)((char *)a2 + 28), v8, v7);
  v13 = v12;
  __p = 0;
  v39 = 0;
  v40 = 0;
  if (HGRectIsNull(v8, v7) || HGRectIsNull(v11, v13))
  {
    v14 = (v39 - (_BYTE *)__p) >> 4;
    v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v16 = v40 - (_BYTE *)__p;
    if ((v40 - (_BYTE *)__p) >> 3 > v15)
      v15 = v16 >> 3;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
      v17 = 0xFFFFFFFFFFFFFFFLL;
    else
      v17 = v15;
    if (v17)
    {
      if (v17 >> 60)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v18 = (char *)operator new(16 * v17);
    }
    else
    {
      v18 = 0;
    }
    v19 = &v18[16 * v14];
    *(_OWORD *)v19 = *(_OWORD *)((char *)a2 + 20);
    __p = v19;
    v40 = &v18[16 * v17];
    v39 = v19 + 16;
  }
  else
  {
  }
  v20 = *((_DWORD *)a2 + 7);
  v21 = *((_DWORD *)a2 + 5);
  v22 = v20 - v21;
  v23 = this[29];
  if (v23)
    MEMORY[0x1B5E2914C](v23, 0x1000C8077774924);
  v24 = operator new[]();
  this[29] = v24;
  if (v20 != v21)
  {
    do
    {
      memcpy(v24, a4, a5);
      v24 = ((char *)v24 + a5);
      --v22;
    }
    while (v22);
  }
  v25 = (char *)__p;
  if (v39 - (_BYTE *)__p >= 1)
  {
    v26 = (unint64_t)(v39 - (_BYTE *)__p) >> 4;
    global_queue = dispatch_get_global_queue(0, 0);
    v28 = v26 + 1;
    v29 = 16 * v26 - 8;
    v30 = &this[7 * v26 - 6];
    do
    {
      v31 = *(_QWORD *)((char *)__p + v29 - 8);
      v32 = this[29];
      v34 = *((_QWORD *)a2 + 7);
      v33 = *((_QWORD *)a2 + 8);
      v35 = (*(_DWORD *)((char *)__p + v29) - v31);
      v36 = (*(_DWORD *)((char *)__p + v29 + 4) - HIDWORD(v31));
      v37 = ((unint64_t)v36 >> 2);
      if (v36 < 0x40)
        v37 = (*(_DWORD *)((char *)__p + v29 + 4) - HIDWORD(v31));
      *v30 = (dispatch_group_t)(*((_QWORD *)a2 + 10)
                              + (_QWORD)v33 * ((v31 >> 32) - *((int *)a2 + 6))
                              + v34 * ((int)v31 - (uint64_t)*((int *)a2 + 5)));
      v30[1] = v33;
      v30[2] = v32;
      v30[3] = (dispatch_group_t)(v34 * (_QWORD)v35);
      v30[4] = v35;
      v30[5] = v36;
      v30[6] = v37;
      --v28;
      v29 -= 16;
      v30 -= 7;
    }
    while (v28 > 1);
    v25 = (char *)__p;
  }
  *((_BYTE *)this + 240) = 1;
  if (v25)
  {
    v39 = v25;
    operator delete(v25);
  }
}

void sub_1B29EDC08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::block_fill_dispatch(_anonymous_namespace_ *this, void *a2)
{
  size_t v3;
  NSObject *global_queue;

  v3 = *((_QWORD *)this + 6);
  global_queue = dispatch_get_global_queue(0, 0);
}

HGRenderUtils::BufferCopier *HGRenderUtils::BufferCopier::BufferCopier(HGRenderUtils::BufferCopier *this)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 72) = 0;
  *(_QWORD *)v2 = dispatch_group_create();
  *(_QWORD *)this = v2;
  return this;
}

void HGRenderUtils::BufferCopier::~BufferCopier(HGRenderUtils::BufferCopier *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    if (*(_BYTE *)(v1 + 72))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(_BYTE *)(v1 + 72) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1B5E29170](v1, 0x1030C400C955606);
  }
}

{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    if (*(_BYTE *)(v1 + 72))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(_BYTE *)(v1 + 72) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1B5E29170](v1, 0x1030C400C955606);
  }
}

void HGRenderUtils::BufferCopier::execute(dispatch_group_t **this, HGBitmap *a2, HGBitmap *a3)
{
  dispatch_group_t *v4;

  if (*((_DWORD *)a2 + 4) == *((_DWORD *)a3 + 4))
    HGRenderUtils::BufferCopierImpl::start_dispatch(*this, a2, a3);
  v4 = *this;
  if (*((_BYTE *)v4 + 72))
  {
    dispatch_group_wait(*v4, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)v4 + 72) = 0;
  }
}

void HGRenderUtils::BufferCopier::start(dispatch_group_t **this, HGBitmap *a2, HGBitmap *a3)
{
  if (*((_DWORD *)a2 + 4) == *((_DWORD *)a3 + 4))
    HGRenderUtils::BufferCopierImpl::start_dispatch(*this, a2, a3);
}

intptr_t HGRenderUtils::BufferCopier::finish(intptr_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 72))
  {
    this = dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
    *(_BYTE *)(v1 + 72) = 0;
  }
  return this;
}

HGRenderUtils::BufferReformatter *HGRenderUtils::BufferReformatter::BufferReformatter(HGRenderUtils::BufferReformatter *this)
{
  uint64_t v2;

  v2 = operator new();
  *(_BYTE *)(v2 + 32) = 0;
  *(_QWORD *)v2 = dispatch_group_create();
  *(_QWORD *)this = v2;
  return this;
}

void HGRenderUtils::BufferReformatter::~BufferReformatter(HGRenderUtils::BufferReformatter *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    if (*(_BYTE *)(v1 + 32))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(_BYTE *)(v1 + 32) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1B5E29170](v1, 0x1020C409C40F318);
  }
}

{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    if (*(_BYTE *)(v1 + 32))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(_BYTE *)(v1 + 32) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    MEMORY[0x1B5E29170](v1, 0x1020C409C40F318);
  }
}

void HGRenderUtils::BufferReformatter::execute(HGRenderUtils::BufferReformatter *this, HGBitmap *a2, HGBitmap *a3)
{
  uint64_t v4;

  HGRenderUtils::BufferReformatter::start(this, a2, a3);
  v4 = *(_QWORD *)this;
  if (*(_BYTE *)(v4 + 32))
  {
    dispatch_group_wait(*(dispatch_group_t *)v4, 0xFFFFFFFFFFFFFFFFLL);
    *(_BYTE *)(v4 + 32) = 0;
  }
}

void HGRenderUtils::BufferReformatter::start(HGRenderUtils::BufferReformatter *this, HGBitmap *a2, HGBitmap *a3)
{
  uint64_t v5;
  unint64_t v6;
  NSObject *v7;
  NSObject *global_queue;

  if (*((_DWORD *)a2 + 4) != *((_DWORD *)a3 + 4))
  {
    v5 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 32))
    {
      dispatch_group_wait(*(dispatch_group_t *)v5, 0xFFFFFFFFFFFFFFFFLL);
      *(_BYTE *)(v5 + 32) = 0;
    }
    v6 = (*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
    if (v6 >= 0x40)
      v6 >>= 2;
    *(_QWORD *)(v5 + 8) = a3;
    *(_QWORD *)(v5 + 16) = a2;
    *(_QWORD *)(v5 + 24) = v6;
    v7 = *(NSObject **)v5;
    global_queue = dispatch_get_global_queue(0, 0);
    *(_BYTE *)(v5 + 32) = 1;
  }
}

intptr_t HGRenderUtils::BufferReformatter::finish(intptr_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 32))
  {
    this = dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
    *(_BYTE *)(v1 + 32) = 0;
  }
  return this;
}

HGRenderUtils::BufferFiller *HGRenderUtils::BufferFiller::BufferFiller(HGRenderUtils::BufferFiller *this)
{
  uint64_t v2;

  v2 = operator new();
  *(_QWORD *)(v2 + 232) = 0;
  *(_BYTE *)(v2 + 240) = 0;
  *(_QWORD *)v2 = dispatch_group_create();
  *(_QWORD *)this = v2;
  return this;
}

void HGRenderUtils::BufferFiller::~BufferFiller(HGRenderUtils::BufferFiller *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    if (*(_BYTE *)(v1 + 240))
    {
      dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
      *(_BYTE *)(v1 + 240) = 0;
    }
    dispatch_release(*(dispatch_object_t *)v1);
    v2 = *(_QWORD *)(v1 + 232);
    if (v2)
      MEMORY[0x1B5E2914C](v2, 0x1000C8077774924);
    MEMORY[0x1B5E29170](v1, 0x1030C40855A15F8);
  }
}

void HGRenderUtils::BufferFiller::execute(dispatch_group_t **this, HGBitmap *a2, unsigned __int8 *a3, size_t a4)
{
  dispatch_group_t *v7;
  HGRect v8;

  if (*((_QWORD *)a2 + 7) == a4)
  {
    *(_QWORD *)&v8.var0 = 0;
    *(_QWORD *)&v8.var2 = 0;
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, v8, a3, a4);
  }
  v7 = *this;
  if (*((_BYTE *)v7 + 240))
  {
    dispatch_group_wait(*v7, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)v7 + 240) = 0;
  }
}

void HGRenderUtils::BufferFiller::execute(dispatch_group_t **this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4, size_t a5)
{
  dispatch_group_t *v6;

  if (*((_QWORD *)a2 + 7) == a5)
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, a3, a4, a5);
  v6 = *this;
  if (*((_BYTE *)v6 + 240))
  {
    dispatch_group_wait(*v6, 0xFFFFFFFFFFFFFFFFLL);
    *((_BYTE *)v6 + 240) = 0;
  }
}

void HGRenderUtils::BufferFiller::start(dispatch_group_t **this, HGBitmap *a2, HGRect a3, unsigned __int8 *a4, size_t a5)
{
  if (*((_QWORD *)a2 + 7) == a5)
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, a3, a4, a5);
}

intptr_t HGRenderUtils::BufferFiller::finish(intptr_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 240))
  {
    this = dispatch_group_wait(*(dispatch_group_t *)v1, 0xFFFFFFFFFFFFFFFFLL);
    *(_BYTE *)(v1 + 240) = 0;
  }
  return this;
}

void HGRenderUtils::BufferFiller::start(dispatch_group_t **this, HGBitmap *a2, unsigned __int8 *a3, size_t a4)
{
  HGRect v6;

  if (*((_QWORD *)a2 + 7) == a4)
  {
    *(_QWORD *)&v6.var0 = 0;
    *(_QWORD *)&v6.var2 = 0;
    HGRenderUtils::BufferFillerImpl::start_dispatch(*this, a2, v6, a3, a4);
  }
}

void *`anonymous namespace'::block_single_copy(_anonymous_namespace_ *this, void *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = *((_QWORD *)this + 5);
  v2 = *((_QWORD *)this + 6);
  v4 = v3 / v2;
  v5 = v3 % v2;
  if ((void *)(v2 - 1) == a2)
    v6 = v5;
  else
    v6 = 0;
  return memcpy((void *)(*((_QWORD *)this + 1) + *((_QWORD *)this + 3) * v4 * (_QWORD)a2), (const void *)(*(_QWORD *)this + *((_QWORD *)this + 2) * v4 * (_QWORD)a2), *((_QWORD *)this + 4) * (v6 + v4));
}

_QWORD *`anonymous namespace'::block_copy(_QWORD *this, void *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  unsigned int v13;

  v2 = this[5];
  v3 = this[6];
  v4 = v2 / v3;
  v5 = v2 % v3;
  if ((void *)(v3 - 1) != a2)
    v5 = 0;
  v6 = v5 + v4;
  if (v5 + v4)
  {
    v7 = this[2];
    v8 = this[3];
    v9 = this[4];
    v10 = v4 * (_QWORD)a2;
    v11 = (char *)(this[1] + v8 * v10);
    v12 = (char *)(*this + v7 * v10);
    v13 = 1;
    do
    {
      this = memcpy(v11, v12, v9);
      v12 += v7;
      v11 += v8;
    }
    while (v6 > v13++);
  }
  return this;
}

pthread_mutex_t *`anonymous namespace'::block_reformat(_anonymous_namespace_ *this, void *a2)
{
  _DWORD *v3;
  unint64_t v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _anonymous_namespace_ *v16;
  unint64_t *v17;
  HGMemory *v18;
  void *v19;

  v3 = (_DWORD *)*((_QWORD *)this + 1);
  v4 = *((_QWORD *)this + 2);
  v5 = v3[5];
  v6 = v3[6];
  v7 = v3[7];
  v8 = (v3[8] - v6);
  v9 = v8 / v4;
  v10 = v8 % v4;
  if ((void *)(v4 - 1) != a2)
    v10 = 0;
  v11 = HGRectMake4i(v5, v6 + (int)v9 * (int)a2, v7, v6 + (int)v9 * (int)a2 + (int)v9 + v10);
  v13 = v12;
  v16 = this;
  v14 = *(_QWORD *)this;
  v15 = *((_QWORD *)v16 + 1);
  v18 = (HGMemory *)HGMemory::allocate((HGMemory *)(16 * (v12 - v11) * (HIDWORD(v12) - HIDWORD(v11))), 0, v17);
  (*(void (**)(uint64_t, HGMemory *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v14 + 72))(v14, v18, v11, v13, 0);
  (*(void (**)(uint64_t, HGMemory *, uint64_t, uint64_t))(*(_QWORD *)v15 + 80))(v15, v18, v11, v13);
  return HGMemory::release(v18, v19);
}

_QWORD *`anonymous namespace'::block_fill(_QWORD *this, void *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  const void *v7;
  size_t v8;
  uint64_t v9;
  char *v10;
  unsigned int v11;

  v2 = this[5];
  v3 = this[6];
  v4 = v2 / v3;
  v5 = v2 % v3;
  if ((void *)(v3 - 1) != a2)
    v5 = 0;
  v6 = v5 + v4;
  if (v5 + v4)
  {
    v7 = (const void *)this[2];
    v8 = this[3];
    v9 = this[1];
    v10 = (char *)(*this + v4 * (_QWORD)a2 * v9);
    v11 = 1;
    do
    {
      this = memcpy(v10, v7, v8);
      v10 += v9;
    }
    while (v6 > v11++);
  }
  return this;
}

HGPool **HGMetalBufferPool::HGMetalBufferPool(HGPool **a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  HGPool::BasePool *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = (std::__shared_weak_count *)operator new(0x28uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6519E30;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6519E80;
  v6 = v4 + 1;
  v4[1].__shared_owners_ = a2;
  v7 = operator new();
  v8 = v7;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  HGPool::BasePool::BasePool(v7);
  *(_QWORD *)v8 = &off_1E6519ED8;
  *(_QWORD *)(v8 + 16) = v6;
  *(_QWORD *)(v8 + 24) = v4;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = v6;
  *(_QWORD *)(v8 + 56) = v4;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_QWORD *)(v8 + 152) = v6;
  *(_QWORD *)(v8 + 160) = v4;
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 232) = 0u;
  *(_OWORD *)(v8 + 216) = 0u;
  *(_OWORD *)(v8 + 200) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_OWORD *)(v8 + 264) = 0u;
  *(_OWORD *)(v8 + 280) = 0u;
  *(_OWORD *)(v8 + 296) = 0u;
  *(_BYTE *)(v8 + 343) = 14;
  *(_QWORD *)(v8 + 312) = 0;
  strcpy((char *)(v8 + 320), "(unnamed) pool");
  *(_BYTE *)(v8 + 367) = 6;
  strcpy((char *)(v8 + 344), "hgpool");
  *(_DWORD *)(v8 + 368) = 0;
  *(_WORD *)(v8 + 372) = 257;
  *(_BYTE *)(v8 + 374) = 1;
  *(_WORD *)(v8 + 8) = 33;
  v14 = *(unsigned __int16 *)(v8 + 10) | 0x210000;
  *(_QWORD *)(v8 + 144) = v14;
  *(_QWORD *)(v8 + 248) = v14;
  *(_QWORD *)(v8 + 256) = 850045863;
  *a1 = (HGPool *)v8;
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  HGPool::registerPool(*a1, v10);
  if (v4)
  {
    v16 = (unint64_t *)&v4->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1B29EE6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  MEMORY[0x1B5E29170](v11, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1B29EE6E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

std::string *HGMetalBufferPool::setLabel(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(*(_QWORD *)a1 + 320), a2);
}

void HGMetalBufferPool::setServicingPolicy(std::mutex **a1, uint64_t *a2)
{
  std::mutex *v3;
  std::mutex *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;

  v3 = *a1;
  v4 = *a1 + 4;
  std::mutex::lock(v4);
  v6 = *a2;
  v5 = a2[1];
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = *(std::__shared_weak_count **)&v3[2].__m_.__opaque[40];
  *(_QWORD *)&v3[2].__m_.__opaque[32] = v6;
  *(_QWORD *)&v3[2].__m_.__opaque[40] = v5;
  if (!v9)
    goto LABEL_8;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    std::mutex::unlock(v4);
  }
  else
  {
LABEL_8:
    std::mutex::unlock(v4);
  }
}

void HGMetalBufferPool::setAllocationPolicy(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v2 = *a1;
  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = *(std::__shared_weak_count **)(v2 + 40);
  *(_QWORD *)(v2 + 32) = v4;
  *(_QWORD *)(v2 + 40) = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

uint64_t HGMetalBufferPool::newBuffer(uint64_t *a1, uint64_t *a2)
{
  return HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObjectWithRecovery(*a1, a2, 0);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObjectWithRecovery(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t result;
  unint64_t *v7;
  unint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  void **v15;
  int64x2_t v16;
  const char *v17;
  char *v18;
  unsigned __int8 v19;
  HGLogger *v20;

  result = HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObject(a1, a2, a3);
  if (!result)
  {
    v7 = (unint64_t *)(a1 + 232);
    v8 = (unint64_t *)(a1 + 240);
    while (1)
    {
      std::mutex::lock((std::mutex *)(a1 + 256));
      if (!*(_QWORD *)(a1 + 224))
        break;
      v9 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 8 * (*(_QWORD *)(a1 + 216) / 0x55uLL))
                     + 48 * (*(_QWORD *)(a1 + 216) % 0x55uLL));
      v11 = *v9;
      v10 = v9[1];
      v12 = v9[2];
      do
        v13 = __ldaxr(v7);
      while (__stlxr(v13 - 1, v7));
      do
        v14 = __ldaxr(v8);
      while (__stlxr(v14 - v12, v8));
      v15 = *(void ***)(a1 + 192);
      v16 = vaddq_s64(*(int64x2_t *)(a1 + 216), (int64x2_t)xmmword_1B304F0B0);
      *(int64x2_t *)(a1 + 216) = v16;
      if (v16.i64[0] >= 0xAAuLL)
      {
        operator delete(*v15);
        *(_QWORD *)(a1 + 192) += 8;
        *(_QWORD *)(a1 + 216) -= 85;
      }
      kdebug_trace();
      kdebug_trace();
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 152) + 24))(*(_QWORD *)(a1 + 152), v11);
      if (v10)
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 152) + 24))(*(_QWORD *)(a1 + 152), v10);
      kdebug_trace();
      std::mutex::unlock((std::mutex *)(a1 + 256));
      result = HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObject(a1, a2, a3);
      if (result)
        return result;
    }
    std::mutex::unlock((std::mutex *)(a1 + 256));
    v19 = atomic_load(HGLogger::_enabled);
    if ((v19 & 1) != 0)
    {
      v20 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0)
        v20 = *(HGLogger **)v20;
      HGLogger::log(v20, (const char *)1, (HGLogger *)"HGPool::newObjectWithRecovery() - Failed to recycle or allocate object! Oops.", v17, v18, 1, -1);
    }
    return 0;
  }
  return result;
}

void sub_1B29EEA38(_Unwind_Exception *a1)
{
  kdebug_trace();
  _Unwind_Resume(a1);
}

void HGMetalBufferPool::releaseBuffer(uint64_t *a1, uint64_t a2)
{
  HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::releaseObject(*a1, a2);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  std::mutex *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _OWORD *v8;
  __int128 v9;
  __int128 v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  const char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _OWORD *v23;
  __int128 v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  char *v31;
  __int128 v32;
  _OWORD v33[2];
  __int128 v34;
  _BYTE v35[32];
  uint64_t v36;

  v36 = a2;
  v3 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), &v36, (uint64_t)&v34);
  if ((_QWORD)v34)
  {
    v35[24] = 0;
    *(std::chrono::steady_clock::time_point *)&v35[8] = std::chrono::steady_clock::now();
    kdebug_trace();
    v4 = *(_QWORD *)(a1 + 200);
    v5 = *(_QWORD *)(a1 + 192);
    v6 = 85 * ((v4 - v5) >> 3) - 1;
    if (v4 == v5)
      v6 = 0;
    v7 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    if (v6 == v7)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(a1 + 184);
      v5 = *(_QWORD *)(a1 + 192);
      v7 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    }
    v8 = (_OWORD *)(*(_QWORD *)(v5 + 8 * (v7 / 0x55)) + 48 * (v7 % 0x55));
    v9 = v34;
    v10 = *(_OWORD *)&v35[16];
    v8[1] = *(_OWORD *)v35;
    v8[2] = v10;
    *v8 = v9;
    ++*(_QWORD *)(a1 + 224);
    v11 = (unint64_t *)(a1 + 232);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
    v13 = *(_QWORD *)v35;
    v14 = (unint64_t *)(a1 + 240);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 + v13, v14));
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v36, (uint64_t)&v32);
    v34 = v32;
    *(_OWORD *)v35 = v33[0];
    *(_OWORD *)&v35[9] = *(_OWORD *)((char *)v33 + 9);
    v18 = v32;
    if ((_QWORD)v32)
    {
      v19 = *(_QWORD *)(a1 + 200);
      v20 = *(_QWORD *)(a1 + 192);
      v21 = 85 * ((v19 - v20) >> 3) - 1;
      if (v19 == v20)
        v21 = 0;
      v22 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      if (v21 == v22)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(a1 + 184);
        v20 = *(_QWORD *)(a1 + 192);
        v22 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      }
      v23 = (_OWORD *)(*(_QWORD *)(v20 + 8 * (v22 / 0x55)) + 48 * (v22 % 0x55));
      v24 = v34;
      v25 = *(_OWORD *)&v35[16];
      v23[1] = *(_OWORD *)v35;
      v23[2] = v25;
      *v23 = v24;
      ++*(_QWORD *)(a1 + 224);
      v26 = (unint64_t *)(a1 + 232);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 + 1, v26));
      v28 = *(_QWORD *)v35;
      v29 = (unint64_t *)(a1 + 240);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 + v28, v29));
      v31 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      v18 = v34;
    }
    else
    {
      v31 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v31, v16, v17, v18);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v3);
}

void sub_1B29EED48(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29EED5C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGMetalBufferPool::clear(HGMetalBufferPool *this)
{
  HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::clear(*(_QWORD *)this);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::clear(uint64_t a1)
{
  std::mutex *v2;
  uint64_t v3;

  v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(_QWORD *)(a1 + 224))
  {
    v3 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      --v3;
    }
    while (*(_QWORD *)(a1 + 224));
    if (v3)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
      kdebug_trace();
    }
  }
  std::mutex::unlock(v2);
}

void sub_1B29EEE4C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29EEE60(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

HGPool **HGMetalBufferWrapperInfinipool::HGMetalBufferWrapperInfinipool(HGPool **a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  HGMetalDeviceInfo *DeviceInfo;
  int v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  HGPool::BasePool *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v32;

  v4 = (std::__shared_weak_count *)operator new(0x28uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A0F0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A140;
  v6 = v4 + 1;
  v4[1].__shared_owners_ = a2;
  v32 = v4;
  v7 = operator new();
  v8 = v7;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  HGPool::BasePool::BasePool(v7);
  *(_QWORD *)v8 = &off_1E651A198;
  *(_QWORD *)(v8 + 16) = v6;
  *(_QWORD *)(v8 + 24) = v4;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = v6;
  *(_QWORD *)(v8 + 56) = v4;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_QWORD *)(v8 + 152) = v6;
  *(_QWORD *)(v8 + 160) = v4;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  *(_OWORD *)(v8 + 232) = 0u;
  *(_OWORD *)(v8 + 216) = 0u;
  *(_OWORD *)(v8 + 200) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_OWORD *)(v8 + 264) = 0u;
  *(_OWORD *)(v8 + 280) = 0u;
  *(_OWORD *)(v8 + 296) = 0u;
  *(_BYTE *)(v8 + 343) = 14;
  *(_QWORD *)(v8 + 312) = 0;
  strcpy((char *)(v8 + 320), "(unnamed) pool");
  *(_BYTE *)(v8 + 367) = 6;
  strcpy((char *)(v8 + 344), "hgpool");
  *(_DWORD *)(v8 + 368) = 0;
  *(_WORD *)(v8 + 372) = 257;
  *(_BYTE *)(v8 + 374) = 1;
  *(_WORD *)(v8 + 8) = 49;
  v13 = *(unsigned __int16 *)(v8 + 10) | 0x310000;
  *(_QWORD *)(v8 + 144) = v13;
  *(_QWORD *)(v8 + 248) = v13;
  *(_QWORD *)(v8 + 256) = 850045863;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  *a1 = (HGPool *)v8;
  DeviceInfo = (HGMetalDeviceInfo *)HGMetalDeviceInfo::getDeviceInfo(a2);
  if (DeviceInfo)
  {
    if (HGMetalDeviceInfo::isIntel(DeviceInfo))
      v16 = 2;
    else
      v16 = 1;
  }
  else
  {
    v16 = 1;
  }
  *(_DWORD *)(v8 + 368) = v16;
  v17 = (std::__shared_weak_count *)operator new(0x20uLL);
  v17->__shared_owners_ = 0;
  v18 = (unint64_t *)&v17->__shared_owners_;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A220;
  v17[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A270;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  std::mutex::lock((std::mutex *)(v8 + 256));
  do
    v20 = __ldxr(v18);
  while (__stxr(v20 + 1, v18));
  v21 = *(std::__shared_weak_count **)(v8 + 176);
  *(_QWORD *)(v8 + 168) = v17 + 1;
  *(_QWORD *)(v8 + 176) = v17;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  std::mutex::unlock((std::mutex *)(v8 + 256));
  if (v17)
  {
    v25 = (unint64_t *)&v17->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  HGPool::registerPool(*a1, v24);
  if (v17)
  {
    v27 = (unint64_t *)&v17->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (v32)
  {
    v29 = (unint64_t *)&v32->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  return a1;
}

void sub_1B29EF1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B29EF1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B29EF218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B29EF22C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B29EF240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  MEMORY[0x1B5E29170](v3, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B29EF274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGMetalBufferWrapperInfinipool::newBuffer(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  id v5;

  v2 = *a1;
  v3 = (void *)HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::newObject(*a1, a2, 0);
  v4 = (uint64_t)v3;
  if (v3)
  {
    v5 = v3;
    HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::releaseObject(v2, v4);
  }
  return v4;
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::newObject(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4;
  std::chrono::steady_clock::time_point v5;
  std::chrono::steady_clock::time_point v6;
  unsigned __int8 v7;
  void **v8;
  const char *v9;
  char *v10;
  int v11;
  __int128 v12;
  uint64_t v13;
  const char *v14;
  char *v15;
  uint64_t v16;
  unsigned __int8 v17;
  void **v18;
  uint64_t v19;
  uint64_t v20;
  std::chrono::steady_clock::time_point v21;
  std::chrono::steady_clock::time_point v22;
  unsigned __int8 v23;
  void **v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  char *v28;
  uint64_t v29;
  unsigned __int8 v30;
  void **v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  _OWORD *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unsigned __int8 v46;
  HGLogger *v47;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  unint64_t v54;
  void *v55[2];
  char v56;

  if ((a3 & 1) != 0 || (v4 = *(_QWORD *)(a1 + 32)) == 0)
  {
    v53 = *(_OWORD *)a2;
    v54 = *(_QWORD *)(a2 + 16);
  }
  else
  {
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v4 + 16))(&v53);
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v53, (uint64_t)&v49);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((_QWORD)v49)
  {
    BYTE8(v52) = 1;
    *((std::chrono::steady_clock::time_point *)&v51 + 1) = std::chrono::steady_clock::now();
    *(_QWORD *)&v52 = v52 + 1;
    v56 = 0;
    LOBYTE(v55[0]) = 0;
    v7 = atomic_load(HGLogger::_enabled);
    if ((v7 & 1) != 0)
    {
      v8 = v55;
      if (v56 < 0)
        v8 = (void **)v55[0];
      HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry reused : %p (%s)\n", (const char *)v5.__d_.__rep_, (char *)v6.__d_.__rep_, (_QWORD)v49, v8);
    }
    if (v56 < 0)
      operator delete(v55[0]);
    kdebug_trace();
    v11 = *(_DWORD *)(a1 + 368);
    if (v11 == 1)
    {
      kdebug_trace();
      v25 = v49;
      v29 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v53);
      v56 = 0;
      LOBYTE(v55[0]) = 0;
      v30 = atomic_load(HGLogger::_enabled);
      if ((v30 & 1) != 0)
      {
        v31 = v55;
        if (v56 < 0)
          v31 = (void **)v55[0];
        HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", v27, v28, (_QWORD)v49, v31);
      }
      v32 = *((_QWORD *)&v50 + 1);
      if (v56 < 0)
        operator delete(v55[0]);
      *(_QWORD *)&v49 = v29;
      v50 = v53;
      *(_QWORD *)&v51 = v54;
      HGPool::EntryEventHandler<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::allocated(&v49, v32, v26, v27, v28);
      kdebug_trace();
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), v25);
      kdebug_trace();
    }
    else if (v11 == 2)
    {
      kdebug_trace();
      v12 = v49;
      v16 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v53);
      v56 = 0;
      LOBYTE(v55[0]) = 0;
      v17 = atomic_load(HGLogger::_enabled);
      if ((v17 & 1) != 0)
      {
        v18 = v55;
        if (v56 < 0)
          v18 = (void **)v55[0];
        HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", v14, v15, (_QWORD)v49, v18);
      }
      v19 = *((_QWORD *)&v50 + 1);
      if (v56 < 0)
        operator delete(v55[0]);
      *(_QWORD *)&v49 = v16;
      *((_QWORD *)&v49 + 1) = v12;
      v50 = v53;
      *(_QWORD *)&v51 = v54;
      HGPool::EntryEventHandler<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::allocated(&v49, v19, v13, v14, v15);
      kdebug_trace();
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), *((_QWORD *)&v12 + 1));
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    v20 = (*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v53);
    v50 = v53;
    *(_QWORD *)&v52 = 0;
    v51 = v54;
    v49 = (unint64_t)v20;
    BYTE8(v52) = 1;
    *((std::chrono::steady_clock::time_point *)&v51 + 1) = std::chrono::steady_clock::now();
    *(_QWORD *)&v52 = v52 + 1;
    v56 = 0;
    LOBYTE(v55[0]) = 0;
    v23 = atomic_load(HGLogger::_enabled);
    if ((v23 & 1) != 0)
    {
      v24 = v55;
      if (v56 < 0)
        v24 = (void **)v55[0];
      HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry allocated : %p (%s)\n", (const char *)v21.__d_.__rep_, (char *)v22.__d_.__rep_, (_QWORD)v49, v24);
    }
    if (v56 < 0)
      operator delete(v55[0]);
    kdebug_trace();
    kdebug_trace();
  }
  if ((_QWORD)v49)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    v33 = *(_QWORD *)(a1 + 96);
    v34 = *(_QWORD *)(a1 + 88);
    v35 = 8 * (v33 - v34) - 1;
    if (v33 == v34)
      v35 = 0;
    v36 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    if (v35 == v36)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 80);
      v34 = *(_QWORD *)(a1 + 88);
      v36 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    }
    v37 = (_OWORD *)(*(_QWORD *)(v34 + ((v36 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v36 & 0x3F) << 6));
    v38 = v49;
    v39 = v50;
    v40 = v52;
    v37[2] = v51;
    v37[3] = v40;
    *v37 = v38;
    v37[1] = v39;
    ++*(_QWORD *)(a1 + 120);
    v41 = (unint64_t *)(a1 + 128);
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 + 1, v41));
    v43 = *((_QWORD *)&v50 + 1);
    v44 = (unint64_t *)(a1 + 136);
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 + v43, v44));
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    v46 = atomic_load(HGLogger::_enabled);
    if ((v46 & 1) != 0)
    {
      v47 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0)
        v47 = *(HGLogger **)v47;
      HGLogger::log(v47, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v9, v10);
    }
  }
  return v49;
}

void sub_1B29EF954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  uint64_t v13;

  if (*(char *)(v13 - 65) < 0)
  {
    operator delete(*(void **)(v13 - 88));
    HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
    _Unwind_Resume(a1);
  }
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B29EF9A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 65) < 0)
    operator delete(*(void **)(v1 - 88));
  _Unwind_Resume(exception_object);
}

void sub_1B29EF9C0(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  std::mutex *v3;
  std::chrono::steady_clock::time_point v4;
  std::chrono::steady_clock::time_point v5;
  unsigned __int8 v6;
  void **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _OWORD *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  const char *v21;
  char *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _OWORD *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  char *v37;
  void *__p[2];
  __int128 v39;
  _OWORD v40[2];
  __int128 v41;
  __int128 v42;
  _BYTE v43[32];
  uint64_t v44;

  v44 = a2;
  v3 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), &v44, (uint64_t)&v41);
  if ((_QWORD)v41)
  {
    v43[24] = 0;
    *(std::chrono::steady_clock::time_point *)&v43[8] = std::chrono::steady_clock::now();
    BYTE7(v39) = 0;
    LOBYTE(__p[0]) = 0;
    v6 = atomic_load(HGLogger::_enabled);
    if ((v6 & 1) != 0)
    {
      v7 = __p;
      if (SBYTE7(v39) < 0)
        v7 = (void **)__p[0];
      HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry recycled : %p (%s)\n", (const char *)v4.__d_.__rep_, (char *)v5.__d_.__rep_, (_QWORD)v41, v7);
    }
    if (SBYTE7(v39) < 0)
      operator delete(__p[0]);
    kdebug_trace();
    v8 = *(_QWORD *)(a1 + 200);
    v9 = *(_QWORD *)(a1 + 192);
    v10 = 8 * (v8 - v9) - 1;
    if (v8 == v9)
      v10 = 0;
    v11 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    if (v10 == v11)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
      v9 = *(_QWORD *)(a1 + 192);
      v11 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
    }
    v12 = (_OWORD *)(*(_QWORD *)(v9 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v11 & 0x3F) << 6));
    v13 = v41;
    v14 = v42;
    v15 = *(_OWORD *)&v43[16];
    v12[2] = *(_OWORD *)v43;
    v12[3] = v15;
    *v12 = v13;
    v12[1] = v14;
    ++*(_QWORD *)(a1 + 224);
    v16 = (unint64_t *)(a1 + 232);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 + 1, v16));
    v18 = *((_QWORD *)&v42 + 1);
    v19 = (unint64_t *)(a1 + 240);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + v18, v19));
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::service(a1 + 152, a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v44, (uint64_t)__p);
    v41 = *(_OWORD *)__p;
    v42 = v39;
    *(_OWORD *)v43 = v40[0];
    *(_OWORD *)&v43[9] = *(_OWORD *)((char *)v40 + 9);
    v23 = __p[0];
    if (__p[0])
    {
      v24 = *(_QWORD *)(a1 + 200);
      v25 = *(_QWORD *)(a1 + 192);
      v26 = 8 * (v24 - v25) - 1;
      if (v24 == v25)
        v26 = 0;
      v27 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      if (v26 == v27)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
        v25 = *(_QWORD *)(a1 + 192);
        v27 = *(_QWORD *)(a1 + 224) + *(_QWORD *)(a1 + 216);
      }
      v28 = (_OWORD *)(*(_QWORD *)(v25 + ((v27 >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((v27 & 0x3F) << 6));
      v29 = v41;
      v30 = v42;
      v31 = *(_OWORD *)&v43[16];
      v28[2] = *(_OWORD *)v43;
      v28[3] = v31;
      *v28 = v29;
      v28[1] = v30;
      ++*(_QWORD *)(a1 + 224);
      v32 = (unint64_t *)(a1 + 232);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 + 1, v32));
      v34 = *((_QWORD *)&v42 + 1);
      v35 = (unint64_t *)(a1 + 240);
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 + v34, v35));
      v37 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      v23 = (void *)v41;
    }
    else
    {
      v37 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v37, v21, v22, v23);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v3);
}

void sub_1B29EFCE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  std::mutex *v16;

  std::mutex::unlock(v16);
  _Unwind_Resume(a1);
}

void HGMetalBufferWrapperInfinipool::clear(HGMetalBufferWrapperInfinipool *this)
{
  HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::clear(*(_QWORD *)this);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::clear(uint64_t a1)
{
  std::mutex *v2;
  uint64_t v3;
  const char *v4;
  char *v5;
  uint64_t v6;

  v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(_QWORD *)(a1 + 224))
  {
    v6 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152), 1, v3, v4, v5);
      --v6;
    }
    while (*(_QWORD *)(a1 + 224));
    if (v6)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
      kdebug_trace();
    }
  }
  std::mutex::unlock(v2);
}

void sub_1B29EFE00(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29EFE14(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<`anonymous namespace'::BufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6519E30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<`anonymous namespace'::BufferAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6519E30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<`anonymous namespace'::BufferAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void `anonymous namespace'::BufferAllocator::~BufferAllocator(_anonymous_namespace_::BufferAllocator *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t `anonymous namespace'::BufferAllocator::allocate(uint64_t a1, _QWORD *a2)
{
  return objc_msgSend(*(id *)(a1 + 8), "newBufferWithLength:options:", *a2, 0);
}

void `anonymous namespace'::BufferAllocator::release(uint64_t a1, void *a2)
{

}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::~Pool(a1, a2);
  JUMPOUT(0x1B5E29170);
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::service(uint64_t a1)
{
  std::mutex *v2;

  v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    kdebug_trace();
  }
  std::mutex::unlock(v2);
}

void sub_1B29F0014(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::trace(std::mutex *a1)
{
  std::mutex *v2;
  std::mutex *sig;

  v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0)
    sig = (std::mutex *)sig->__m_.__sig;
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B29F0228(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F023C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F0250(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F0264(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log(uint64_t a1, const char *a2)
{
  HGLogger *v3;
  const char *v4;
  char *v5;
  unsigned __int8 v6;
  _QWORD *v7;
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  const char *v11;
  char *v12;
  unsigned __int8 v13;

  v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2)
      return;
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    v7 = (_QWORD *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0)
      v7 = (_QWORD *)*v7;
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  v10 = atomic_load(HGLogger::_enabled);
  if ((v10 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::log((_QWORD *)(a1 + 48), v3);
  v13 = atomic_load(HGLogger::_enabled);
  if ((v13 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::log((_QWORD *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);
  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B29F0390(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::~List(int64x2_t *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front(a1);
  std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  v2 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = (std::__shared_weak_count *)a1->i64[1];
  if (!v5)
    return a1;
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (v7)
    return a1;
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front(int64x2_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  void **v10;
  int64x2_t v11;

  v2 = (uint64_t *)(*(_QWORD *)(a1[2].i64[1] + 8 * (a1[4].i64[0] / 0x55uLL)) + 48 * (a1[4].i64[0] % 0x55uLL));
  v4 = *v2;
  v3 = v2[1];
  v5 = v2[2];
  v6 = (unint64_t *)&a1[5];
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  v8 = &a1[5].u64[1];
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - v5, v8));
  v10 = (void **)a1[2].i64[1];
  v11 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B304F0B0);
  a1[4] = v11;
  if (v11.i64[0] >= 0xAAuLL)
  {
    operator delete(*v10);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 85;
  }
  kdebug_trace();
  kdebug_trace();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0], v4);
  if (v3)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0], v3);
  return kdebug_trace();
}

void sub_1B29F05FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::~deque[abi:ne180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 42;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 85;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;

  *(_QWORD *)a1 = &off_1E6519ED8;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_24:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0)
    goto LABEL_24;
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::~List((int64x2_t *)(a1 + 152));
  std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6)
  {
    v7 = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = *(std::__shared_weak_count **)(a1 + 40);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v12)
    return a1;
  v13 = (unint64_t *)&v12->__shared_owners_;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (v14)
    return a1;
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::service(int64x2_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  if (!a1[1].i64[0] || !a1[4].i64[1])
    return 0;
  v4 = 0;
  do
  {
    v5 = atomic_load((unint64_t *)&a1[5]);
    if (v5 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 16))(a1[1].i64[0], a2))
    {
      v6 = atomic_load(&a1[5].u64[1]);
      if (v6 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 24))(a1[1].i64[0], a2))
      {
        v7 = a1[4].u64[0];
        v8 = *(_QWORD *)(a1[2].i64[1] + 8 * (v7 / 0x55));
        v9 = std::chrono::steady_clock::now().__d_.__rep_ - *(_QWORD *)(v8 + 48 * (v7 % 0x55) + 24);
        if (v9 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1[1].i64[0] + 32))(a1[1].i64[0], a2))
          break;
      }
    }
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_pop_front(a1);
    ++v4;
  }
  while (a1[4].i64[1]);
  return v4;
}

void HGPool::EntryTrace<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::trace(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40))
    std::chrono::steady_clock::now();
}

void sub_1B29F09E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  __int128 *v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 *v11;
  HGLoggerUtils *v12;
  const char *v13;
  char *v14;
  unsigned __int8 v15;
  void **v16;
  unint64_t v17;
  void *__p[2];
  __int128 v19;
  __int128 v20;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 / 0x55));
      v7 = (__int128 *)(*v6 + 48 * (v5 % 0x55));
      v8 = *(_QWORD *)(v4 + 8 * ((a1[9] + v5) / 0x55)) + 48 * ((a1[9] + v5) % 0x55);
      while (v7 != (__int128 *)v8)
      {
        v9 = *v7;
        v10 = v7[2];
        v19 = v7[1];
        v20 = v10;
        *(_OWORD *)__p = v9;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 3;
        if ((__int128 *)((char *)v7 - *v6) == (__int128 *)4080)
        {
          v11 = (__int128 *)v6[1];
          ++v6;
          v7 = v11;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v12 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v12);
    v15 = atomic_load(HGLogger::_enabled);
    if ((v15 & 1) != 0)
    {
      if ((SBYTE7(v19) & 0x80u) == 0)
        v16 = __p;
      else
        v16 = (void **)__p[0];
      v17 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v13, v14, v16, v17);
    }
    if (SBYTE7(v19) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B29F0B64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  __int128 *v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 *v11;
  HGLoggerUtils *v12;
  const char *v13;
  char *v14;
  unsigned __int8 v15;
  void **v16;
  unint64_t v17;
  void *__p[2];
  __int128 v19;
  __int128 v20;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 / 0x55));
      v7 = (__int128 *)(*v6 + 48 * (v5 % 0x55));
      v8 = *(_QWORD *)(v4 + 8 * ((a1[9] + v5) / 0x55)) + 48 * ((a1[9] + v5) % 0x55);
      while (v7 != (__int128 *)v8)
      {
        v9 = *v7;
        v10 = v7[2];
        v19 = v7[1];
        v20 = v10;
        *(_OWORD *)__p = v9;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 3;
        if ((__int128 *)((char *)v7 - *v6) == (__int128 *)4080)
        {
          v11 = (__int128 *)v6[1];
          ++v6;
          v7 = v11;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v12 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v12);
    v15 = atomic_load(HGLogger::_enabled);
    if ((v15 & 1) != 0)
    {
      if ((SBYTE7(v19) & 0x80u) == 0)
        v16 = __p;
      else
        v16 = (void **)__p[0];
      v17 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v13, v14, v16, v17);
    }
    if (SBYTE7(v19) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B29F0CE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6;
  const char *v7;
  char *v8;
  unsigned __int8 v9;
  void **v10;
  void **v11;
  std::chrono::steady_clock::time_point v12;
  const char *v13;
  char *v14;
  unsigned __int8 v15;
  void **v16;
  void *p_p;
  void **v18;
  void *__p;
  char v20;
  void *v21[2];
  char v22;
  void *v23[2];
  char v24;

  v6 = *a1;
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)a1[2]);
  v22 = 0;
  LOBYTE(v21[0]) = 0;
  if (*((_BYTE *)a1 + 40))
  {
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
    {
      v10 = v23;
      if (v24 < 0)
        v10 = (void **)v23[0];
      v11 = v21;
      if (v22 < 0)
        v11 = (void **)v21[0];
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v7, v8, v6, v10, a1[4], v11);
    }
    goto LABEL_17;
  }
  v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v12.__d_.__rep_ - a1[3]));
  v15 = atomic_load(HGLogger::_enabled);
  if ((v15 & 1) != 0)
  {
    v16 = v23;
    if (v24 < 0)
      v16 = (void **)v23[0];
    p_p = &__p;
    if (v20 < 0)
      p_p = __p;
    v18 = v21;
    if (v22 < 0)
      v18 = (void **)v21[0];
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v13, v14, v6, v16, a1[4], p_p, v18);
  }
  if ((v20 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v22 & 0x80000000) == 0)
      goto LABEL_18;
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v22 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v24 & 0x80000000) == 0)
      return;
LABEL_22:
    operator delete(v23[0]);
    return;
  }
LABEL_21:
  operator delete(v21[0]);
  if (v24 < 0)
    goto LABEL_22;
}

void sub_1B29F0E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 33) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 33) & 0x80000000) == 0)
LABEL_4:
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>::newObject(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  char *v7;
  int v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _OWORD *v16;
  __int128 v17;
  __int128 v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unsigned __int8 v24;
  HGLogger *v25;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  unint64_t v30;

  if ((a3 & 1) != 0 || (v4 = *(_QWORD *)(a1 + 32)) == 0)
    v5 = *a2;
  else
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  v30 = v5;
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), (uint64_t *)&v30, (uint64_t)&v27);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((_QWORD)v27)
  {
    BYTE8(v29) = 1;
    *((std::chrono::steady_clock::time_point *)&v28 + 1) = std::chrono::steady_clock::now();
    *(_QWORD *)&v29 = v29 + 1;
    kdebug_trace();
    v8 = *(_DWORD *)(a1 + 368);
    if (v8 == 1)
    {
      kdebug_trace();
      v11 = v27;
      *(_QWORD *)&v27 = (*(uint64_t (**)(_QWORD, unint64_t *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v30);
      *(_QWORD *)&v28 = v30;
      kdebug_trace();
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), v11);
      kdebug_trace();
    }
    else if (v8 == 2)
    {
      kdebug_trace();
      v9 = v27;
      *(_QWORD *)&v27 = (*(uint64_t (**)(_QWORD, unint64_t *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v30);
      *((_QWORD *)&v27 + 1) = v9;
      *(_QWORD *)&v28 = v30;
      kdebug_trace();
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), *((_QWORD *)&v9 + 1));
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    v10 = (*(uint64_t (**)(_QWORD, unint64_t *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), &v30);
    *(_QWORD *)&v29 = 0;
    v27 = (unint64_t)v10;
    v28 = v30;
    BYTE8(v29) = 1;
    *((std::chrono::steady_clock::time_point *)&v28 + 1) = std::chrono::steady_clock::now();
    *(_QWORD *)&v29 = v29 + 1;
    kdebug_trace();
    kdebug_trace();
  }
  if ((_QWORD)v27)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    v12 = *(_QWORD *)(a1 + 96);
    v13 = *(_QWORD *)(a1 + 88);
    v14 = 85 * ((v12 - v13) >> 3) - 1;
    if (v12 == v13)
      v14 = 0;
    v15 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    if (v14 == v15)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(a1 + 80);
      v13 = *(_QWORD *)(a1 + 88);
      v15 = *(_QWORD *)(a1 + 120) + *(_QWORD *)(a1 + 112);
    }
    v16 = (_OWORD *)(*(_QWORD *)(v13 + 8 * (v15 / 0x55)) + 48 * (v15 % 0x55));
    v17 = v27;
    v18 = v29;
    v16[1] = v28;
    v16[2] = v18;
    *v16 = v17;
    ++*(_QWORD *)(a1 + 120);
    v19 = (unint64_t *)(a1 + 128);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + 1, v19));
    v21 = v28;
    v22 = (unint64_t *)(a1 + 136);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 + v21, v22));
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    v24 = atomic_load(HGLogger::_enabled);
    if ((v24 & 1) != 0)
    {
      v25 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0)
        v25 = *(HGLogger **)v25;
      HGLogger::log(v25, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v6, v7);
    }
  }
  return v27;
}

void sub_1B29F13D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a10);
  _Unwind_Resume(a1);
}

void sub_1B29F13EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a10);
  _Unwind_Resume(a1);
}

void sub_1B29F1400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a10);
  _Unwind_Resume(a1);
}

void sub_1B29F1414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a10);
  _Unwind_Resume(a1);
}

void sub_1B29F1428(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

_QWORD *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v19 = 0;
  v20 = v5;
  v14 = 0;
  v15 = v5;
  v6 = operator new(0x30uLL);
  *v6 = &off_1E6519F60;
  v6[4] = 0;
  v6[5] = v5;
  v17 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_retrieve(a1, v16, a3);
  v7 = v17;
  if (v17 == v16)
  {
    v8 = 4;
    v7 = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v12 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v19 = 0;
  v20 = v5;
  v14 = 0;
  v15 = v5;
  v6 = operator new(0x30uLL);
  *v6 = &off_1E651A068;
  v6[4] = 0;
  v6[5] = v5;
  v17 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_retrieve(a1, v16, a3);
  v7 = v17;
  if (v17 == v16)
  {
    v8 = 4;
    v7 = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v12 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void sub_1B29F1564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  char *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v24 = a18;
  if (a18 == v22)
  {
    v25 = 4;
    v24 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  v28 = a22;
  if (a22 == &a19)
  {
    v29 = 4;
    v28 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_16;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void **result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  _BYTE v31[24];
  void **v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_BYTE *)(a3 + 40) = 1;
  v5 = a1[4].u64[0];
  v6 = v5 + a1[4].i64[1];
  v7 = v6 / 0x55;
  v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    v9 = *(_QWORD *)(v8 + 8 * v7) + 48 * (v6 % 0x55);
    v10 = *(_QWORD *)(v8 + 8 * (v5 / 0x55)) + 48 * (v5 % 0x55);
    v11 = (_QWORD *)a2[3];
    if (v11)
      goto LABEL_3;
LABEL_6:
    v32 = 0;
    goto LABEL_8;
  }
  v9 = 0;
  v10 = 0;
  v11 = (_QWORD *)a2[3];
  if (!v11)
    goto LABEL_6;
LABEL_3:
  if (v11 == a2)
  {
    v32 = (void **)v31;
    (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v31);
  }
  else
  {
    v32 = (void **)(*(uint64_t (**)(_QWORD *))(*v11 + 16))(v11);
  }
LABEL_8:
  v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    v13 = *v12;
    while (1)
    {
      v14 = v9;
      if (v9 == v13)
        v14 = *(v12 - 1) + 4080;
      if (!v32)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*((uint64_t (**)(void **, uint64_t))*v32 + 6))(v32, v14 - 48) & 1) != 0)
        break;
      v13 = *v12;
      if (v9 == *v12)
      {
        v15 = *--v12;
        v13 = v15;
        v9 = v15 + 4080;
      }
      v9 -= 48;
      if (v9 == v10)
      {
        v9 = v10;
        break;
      }
    }
  }
  result = v32;
  if (v32 == (void **)v31)
  {
    v17 = 4;
    result = (void **)v31;
  }
  else
  {
    if (!v32)
      goto LABEL_23;
    v17 = 5;
  }
  result = (void **)(*((uint64_t (**)(void))*result + v17))();
LABEL_23:
  v18 = a1[2].i64[1];
  if (a1[3].i64[0] == v18)
  {
    if (!v9)
      return result;
  }
  else if (v9 == *(_QWORD *)(v18 + 8 * (a1[4].i64[0] / 0x55uLL)) + 48 * (a1[4].i64[0] % 0x55uLL))
  {
    return result;
  }
  v19 = v9 - *v12;
  v20 = 0xAAAAAAAAAAAAAAABLL * (v19 >> 4);
  if (v19 < 49)
  {
    v24 = 85 - v20;
    v22 = &v12[-(v24 / 0x55)];
    v23 = *v22 + 48 * (85 * (v24 / 0x55) - v24) + 4032;
  }
  else
  {
    v21 = v20 - 1;
    v22 = &v12[v21 / 0x55];
    v23 = *v22 + 48 * (v21 % 0x55);
  }
  v25 = *(_OWORD *)(v23 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v23;
  *(_OWORD *)(a3 + 16) = v25;
  *(_OWORD *)(a3 + 25) = *(_OWORD *)(v23 + 25);
  v26 = (unint64_t *)&a1[5];
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  v28 = *(_QWORD *)(a3 + 16);
  v29 = &a1[5].u64[1];
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - v28, v29));
  return std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::erase(a1 + 2, v22, (char *)v23);
}

void sub_1B29F18E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(void))(a10 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (!a13)
    _Unwind_Resume(exception_object);
  (*(void (**)(void))(*a13 + 40))();
  _Unwind_Resume(exception_object);
}

void **std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::erase(int64x2_t *a1, _QWORD *a2, char *a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void **v9;
  char *v10;
  uint64_t v11;
  _BYTE *v12;
  unint64_t v13;
  const void **v14;
  const void **v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  const void **v20;
  _BYTE *v21;
  char v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  const void **v26;
  char *v27;
  unint64_t v28;
  int64x2_t v29;
  unint64_t v30;
  void **v31;
  void **result;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  const void **v38;
  _BYTE *v39;
  void **v40;
  uint64_t v41;
  uint64_t v42;
  const void **v43[4];

  v6 = a1[2].u64[0];
  v7 = a1->i64[1];
  v8 = a1[1].i64[0];
  v9 = (const void **)(v7 + 8 * (v6 / 0x55));
  if (v8 != v7)
  {
    v10 = (char *)*v9 + 48 * (v6 % 0x55);
    if (a3 != v10)
      goto LABEL_3;
LABEL_9:
    v13 = 0;
    v12 = *v9;
    goto LABEL_10;
  }
  v10 = 0;
  if (!a3)
    goto LABEL_9;
LABEL_3:
  v11 = 85 * ((const void **)a2 - v9) - 0x5555555555555555 * ((uint64_t)&a3[-*a2] >> 4);
  v12 = *v9;
  v13 = v11 + 0x5555555555555555 * ((v10 - (_BYTE *)*v9) >> 4);
  if (!v13)
  {
LABEL_10:
    v22 = 1;
    v14 = (const void **)(v7 + 8 * (v6 / 0x55));
    v15 = (const void **)v10;
    goto LABEL_13;
  }
  if (v11 < 1)
  {
    v14 = &v9[-((84 - v11) / 0x55uLL)];
    v12 = *v14;
    v15 = (const void **)((char *)*v14 + 48 * (85 * ((84 - v11) / 0x55uLL) - (84 - v11)) + 4032);
    v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
      goto LABEL_6;
  }
  else
  {
    v14 = &v9[v11 / 0x55uLL];
    v12 = *v14;
    v15 = (const void **)((char *)*v14 + 48 * (v11 % 0x55uLL));
    v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
    {
LABEL_6:
      v17 = (char *)v15 - v12;
      v18 = 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - v12) >> 4);
      if (v17 < -47)
      {
        v35 = 83 - v18;
        v20 = &v14[-(v35 / 0x55)];
        v21 = (char *)*v20 + 48 * (85 * (v35 / 0x55) - v35) + 4032;
      }
      else
      {
        v19 = v18 + 1;
        v20 = &v14[v19 / 0x55];
        v21 = (char *)*v20 + 48 * (v19 % 0x55);
      }
      v36 = v16 + v6;
      v37 = (v16 + v6) / 0x55;
      v38 = (const void **)(v7 + 8 * v37);
      if (v8 == v7)
        v39 = 0;
      else
        v39 = (char *)*v38 + 48 * (v36 - 85 * v37);
      v43[0] = v14;
      v43[1] = v15;
      std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*>>(v20, v21, v38, v39, (uint64_t)v43);
      v31 = (void **)a1->i64[1];
      v40 = (void **)a1[1].i64[0];
      v41 = 85 * (v40 - v31) - 1;
      v30 = a1[2].u64[0];
      v42 = a1[2].i64[1];
      a1[2].i64[1] = v42 - 1;
      if (v40 == v31)
        v41 = 0;
      if (v41 - (v42 + v30) + 1 >= 0xAA)
      {
        operator delete(*(v40 - 1));
        v22 = 0;
        v31 = (void **)a1->i64[1];
        a1[1].i64[0] -= 8;
        v30 = a1[2].u64[0];
      }
      else
      {
        v22 = 0;
      }
      goto LABEL_18;
    }
  }
  v22 = 0;
LABEL_13:
  v23 = (char *)v15 - v12;
  v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - v12) >> 4);
  if (v23 < -47)
  {
    v28 = 83 - v24;
    v26 = &v14[-(v28 / 0x55)];
    v27 = (char *)*v26 + 48 * (85 * (v28 / 0x55) - v28) + 4032;
  }
  else
  {
    v25 = v24 + 1;
    v26 = &v14[v25 / 0x55];
    v27 = (char *)*v26 + 48 * (v25 % 0x55);
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,0>(v9, v10, v14, (char *)v15, v26, v27, v43);
  v29 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B304F0B0);
  a1[2] = v29;
  v30 = v29.i64[0];
  v31 = (void **)a1->i64[1];
  if (v29.i64[0] >= 0xAAuLL)
  {
    operator delete(*v31);
    v31 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v31;
    v30 = a1[2].i64[0] - 85;
    a1[2].i64[0] = v30;
  }
LABEL_18:
  result = &v31[v30 / 0x55];
  if ((void **)a1[1].i64[0] == v31)
  {
    v33 = 0;
    if ((v22 & 1) != 0)
      return result;
  }
  else
  {
    v33 = (unint64_t)*result + 48 * (v30 % 0x55);
    if ((v22 & 1) != 0)
      return result;
  }
  v34 = v13 - 0x5555555555555555 * ((uint64_t)(v33 - (_QWORD)*result) >> 4);
  if (v34 < 1)
    result -= (84 - v34) / 0x55uLL;
  else
    result += v34 / 0x55uLL;
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  const void **v8;
  const void **v9;
  const void **v10;
  const void ***v12;
  _BYTE *v14;
  uint64_t v15;
  char *v16;
  int64_t v17;
  void *result;
  uint64_t v19;
  char *v20;
  const void **v21;
  char *v22;
  _BYTE *v23;
  char *v24;
  int64_t v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  int64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v34;
  char *v35;
  int64_t v36;
  uint64_t v37;
  char *v38;

  v8 = a5;
  v9 = (const void **)a4;
  v10 = a3;
  v12 = a7;
  if (a1 == a3)
  {
    if (a2 != a4)
    {
      v34 = (uint64_t)*a5;
      v35 = a4;
      while (1)
      {
        v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v34] >> 4);
        if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v35 - a2) >> 4)) < v36)
          v36 = 0xAAAAAAAAAAAAAAABLL * ((v35 - a2) >> 4);
        v35 -= 48 * v36;
        a6 -= 48 * v36;
        if (v36)
          result = memmove(a6, v35, 48 * v36 - 7);
        if (v35 == a2)
          break;
        v37 = (uint64_t)*--v8;
        v34 = v37;
        a6 = (char *)(v37 + 4080);
      }
      if ((char *)*v8 + 4080 == a6)
      {
        v38 = (char *)v8[1];
        ++v8;
        a6 = v38;
      }
      v10 = a3;
    }
  }
  else
  {
    v14 = *a3;
    if (*a3 != a4)
    {
      v15 = (uint64_t)*a5;
      v16 = a4;
      while (1)
      {
        v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v15] >> 4);
        if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v16 - v14) >> 4)) < v17)
          v17 = 0xAAAAAAAAAAAAAAABLL * ((v16 - v14) >> 4);
        v16 -= 48 * v17;
        a6 -= 48 * v17;
        if (v17)
          result = memmove(a6, v16, 48 * v17 - 7);
        if (v16 == v14)
          break;
        v19 = (uint64_t)*--v8;
        v15 = v19;
        a6 = (char *)(v19 + 4080);
      }
      if ((char *)*v8 + 4080 == a6)
      {
        v20 = (char *)v8[1];
        ++v8;
        a6 = v20;
      }
      v10 = a3;
    }
    v21 = v10 - 1;
    if (v10 - 1 != a1)
    {
      v22 = (char *)*v8;
      do
      {
        while (1)
        {
          v23 = *v21;
          v24 = (char *)*v21 + 4080;
          while (1)
          {
            v25 = 0xAAAAAAAAAAAAAAABLL * ((a6 - v22) >> 4);
            if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 4)) < v25)
              v25 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 4);
            v24 -= 48 * v25;
            a6 -= 48 * v25;
            if (v25)
              result = memmove(a6, v24, 48 * v25 - 7);
            if (v24 == v23)
              break;
            v26 = (char *)*--v8;
            v22 = v26;
            a6 = v26 + 4080;
          }
          v22 = (char *)*v8;
          if ((char *)*v8 + 4080 == a6)
            break;
          if (--v21 == a1)
            goto LABEL_25;
        }
        v27 = (char *)v8[1];
        ++v8;
        v22 = v27;
        a6 = v27;
        --v21;
      }
      while (v21 != a1);
LABEL_25:
      v10 = a3;
    }
    v28 = (char *)*a1 + 4080;
    v9 = (const void **)a4;
    if (v28 != a2)
    {
      v29 = (uint64_t)*v8;
      while (1)
      {
        v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v29] >> 4);
        if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v28 - a2) >> 4)) < v30)
          v30 = 0xAAAAAAAAAAAAAAABLL * ((v28 - a2) >> 4);
        v28 -= 48 * v30;
        a6 -= 48 * v30;
        if (v30)
          result = memmove(a6, v28, 48 * v30 - 7);
        if (v28 == a2)
          break;
        v31 = (uint64_t)*--v8;
        v29 = v31;
        a6 = (char *)(v31 + 4080);
      }
      if ((char *)*v8 + 4080 == a6)
      {
        v32 = (char *)v8[1];
        ++v8;
        a6 = v32;
      }
    }
    v12 = a7;
  }
  *v12 = v10;
  v12[1] = v9;
  v12[2] = v8;
  v12[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,HGMetalBufferPool::Descriptor*,HGMetalBufferPool::Descriptor&,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,long,85l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*,HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>*>>(const void **result, _BYTE *__src, const void **a3, _BYTE *a4, uint64_t a5)
{
  _BYTE *v6;
  char *v7;
  void **v8;
  const void **v9;
  _BYTE *v10;
  char *v11;
  char *v12;
  int64_t v13;
  unint64_t v14;
  char *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  int64_t v21;
  unint64_t v22;
  char *v23;
  _BYTE *v24;
  char *v25;
  char *v26;
  int64_t v27;
  unint64_t v28;
  char *v29;
  void **v30;
  char *v31;
  char *v32;
  int64_t v33;
  unint64_t v34;
  char *v35;
  _QWORD *v38;

  v6 = __src;
  v8 = *(void ***)a5;
  v7 = *(char **)(a5 + 8);
  if (result == a3)
  {
    if (__src == a4)
      goto LABEL_48;
    v32 = (char *)*v8++;
    v31 = v32;
    while (1)
    {
      v33 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v7 + 4080) >> 4);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((a4 - v6) >> 4)) >= v33)
        v34 = v33;
      else
        v34 = 0xAAAAAAAAAAAAAAABLL * ((a4 - v6) >> 4);
      if (v34)
        result = (const void **)memmove(v7, v6, 48 * v34 - 7);
      v6 += 48 * v34;
      if (v6 == a4)
        break;
      v35 = (char *)*v8++;
      v31 = v35;
      v7 = v35;
    }
    v7 += 48 * v34;
    v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4080 != v7)
      goto LABEL_36;
    goto LABEL_47;
  }
  v9 = result;
  v10 = (char *)*result + 4080;
  if (v10 != __src)
  {
    v12 = (char *)*v8++;
    v11 = v12;
    while (1)
    {
      v13 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v7 + 4080) >> 4);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v10 - v6) >> 4)) >= v13)
        v14 = v13;
      else
        v14 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v6) >> 4);
      if (v14)
        result = (const void **)memmove(v7, v6, 48 * v14 - 7);
      v6 += 48 * v14;
      if (v6 == v10)
        break;
      v15 = (char *)*v8++;
      v11 = v15;
      v7 = v15;
    }
    v7 += 48 * v14;
    if ((char *)*(v8 - 1) + 4080 == v7)
    {
      v7 = (char *)*v8;
      *(_QWORD *)a5 = v8;
      *(_QWORD *)(a5 + 8) = v7;
      v16 = v9 + 1;
      if (v9 + 1 != a3)
        goto LABEL_16;
      goto LABEL_26;
    }
    --v8;
  }
  *(_QWORD *)a5 = v8;
  *(_QWORD *)(a5 + 8) = v7;
  v16 = v9 + 1;
  if (v9 + 1 != a3)
  {
    do
    {
LABEL_16:
      while (1)
      {
        v17 = 0;
        v38 = v16;
        v18 = *v16;
        v20 = (char *)*v8++;
        v19 = v20;
        while (1)
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * ((v19 - v7 + 4080) >> 4);
          if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((4080 - 48 * v17) >> 4)) >= v21)
            v22 = v21;
          else
            v22 = 0xAAAAAAAAAAAAAAABLL * ((4080 - 48 * v17) >> 4);
          if (v22)
            result = (const void **)memmove(v7, (const void *)(v18 + 48 * v17), 48 * v22 - 7);
          v17 += v22;
          if (v17 == 85)
            break;
          v23 = (char *)*v8++;
          v19 = v23;
          v7 = v23;
        }
        v7 += 48 * v22;
        if ((char *)*(v8 - 1) + 4080 != v7)
          break;
        v7 = (char *)*v8;
        *(_QWORD *)a5 = v8;
        *(_QWORD *)(a5 + 8) = v7;
        v16 = v38 + 1;
        if (v38 + 1 == a3)
          goto LABEL_26;
      }
      *(_QWORD *)a5 = --v8;
      *(_QWORD *)(a5 + 8) = v7;
      v16 = v38 + 1;
    }
    while (v38 + 1 != a3);
  }
LABEL_26:
  v24 = *a3;
  if (*a3 != a4)
  {
    v26 = (char *)*v8++;
    v25 = v26;
    while (1)
    {
      v27 = 0xAAAAAAAAAAAAAAABLL * ((v25 - v7 + 4080) >> 4);
      v28 = (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((a4 - v24) >> 4)) >= v27 ? v27 : 0xAAAAAAAAAAAAAAABLL * ((a4 - v24) >> 4);
      if (v28)
        result = (const void **)memmove(v7, v24, 48 * v28 - 7);
      v24 += 48 * v28;
      if (v24 == a4)
        break;
      v29 = (char *)*v8++;
      v25 = v29;
      v7 = v29;
    }
    v7 += 48 * v28;
    v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4080 != v7)
    {
LABEL_36:
      v8 = v30;
      goto LABEL_48;
    }
LABEL_47:
    v7 = (char *)*v8;
  }
LABEL_48:
  *(_QWORD *)a5 = v8;
  *(_QWORD *)(a5 + 8) = v7;
  return result;
}

_QWORD *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E6519F60;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E6519F60;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1B5E29170);
}

_QWORD *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = operator new(0x30uLL);
  *v2 = &off_1E6519F60;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
    goto LABEL_4;
  if (v4 != a1 + 8)
  {
    v4 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
LABEL_4:
    v5 = *(_QWORD *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v2[5] = *(_QWORD *)(a1 + 40);
  return v2;
}

void sub_1B29F2518(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t result;

  *a2 = &off_1E6519F60;
  v4 = a2 + 1;
  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 8;
  result = *(_QWORD *)(a1 + 32);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 16);
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE")
    return a1 + 8;
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target_type()
{
}

void std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x55;
  v4 = v2 - 85;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0xFF0uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0xFF0uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0xFF0uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B29F2C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B29F2C54(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F2C68(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F2C80(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v19 = 0;
  v20 = v5;
  v14 = 0;
  v15 = v5;
  v6 = operator new(0x30uLL);
  *v6 = &off_1E651A068;
  v6[4] = 0;
  v6[5] = v5;
  v17 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::_retrieve(a1, v16, a3);
  v7 = v17;
  if (v17 == v16)
  {
    v8 = 4;
    v7 = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v12 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void sub_1B29F2DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  char *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v24 = a18;
  if (a18 == v22)
  {
    v25 = 4;
    v24 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  v28 = a22;
  if (a22 == &a19)
  {
    v29 = 4;
    v28 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_16;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void sub_1B29F2F88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  char *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v24 = a18;
  if (a18 == v22)
  {
    v25 = 4;
    v24 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  v28 = a22;
  if (a22 == &a19)
  {
    v29 = 4;
    v28 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_16;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void **result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  _BYTE v31[24];
  void **v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_BYTE *)(a3 + 40) = 1;
  v5 = a1[4].u64[0];
  v6 = v5 + a1[4].i64[1];
  v7 = v6 / 0x55;
  v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    v9 = *(_QWORD *)(v8 + 8 * v7) + 48 * (v6 % 0x55);
    v10 = *(_QWORD *)(v8 + 8 * (v5 / 0x55)) + 48 * (v5 % 0x55);
    v11 = (_QWORD *)a2[3];
    if (v11)
      goto LABEL_3;
LABEL_6:
    v32 = 0;
    goto LABEL_8;
  }
  v9 = 0;
  v10 = 0;
  v11 = (_QWORD *)a2[3];
  if (!v11)
    goto LABEL_6;
LABEL_3:
  if (v11 == a2)
  {
    v32 = (void **)v31;
    (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v31);
  }
  else
  {
    v32 = (void **)(*(uint64_t (**)(_QWORD *))(*v11 + 16))(v11);
  }
LABEL_8:
  v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    v13 = *v12;
    while (1)
    {
      v14 = v9;
      if (v9 == v13)
        v14 = *(v12 - 1) + 4080;
      if (!v32)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*((uint64_t (**)(void **, uint64_t))*v32 + 6))(v32, v14 - 48) & 1) != 0)
        break;
      v13 = *v12;
      if (v9 == *v12)
      {
        v15 = *--v12;
        v13 = v15;
        v9 = v15 + 4080;
      }
      v9 -= 48;
      if (v9 == v10)
      {
        v9 = v10;
        break;
      }
    }
  }
  result = v32;
  if (v32 == (void **)v31)
  {
    v17 = 4;
    result = (void **)v31;
  }
  else
  {
    if (!v32)
      goto LABEL_23;
    v17 = 5;
  }
  result = (void **)(*((uint64_t (**)(void))*result + v17))();
LABEL_23:
  v18 = a1[2].i64[1];
  if (a1[3].i64[0] == v18)
  {
    if (!v9)
      return result;
  }
  else if (v9 == *(_QWORD *)(v18 + 8 * (a1[4].i64[0] / 0x55uLL)) + 48 * (a1[4].i64[0] % 0x55uLL))
  {
    return result;
  }
  v19 = v9 - *v12;
  v20 = 0xAAAAAAAAAAAAAAABLL * (v19 >> 4);
  if (v19 < 49)
  {
    v24 = 85 - v20;
    v22 = &v12[-(v24 / 0x55)];
    v23 = *v22 + 48 * (85 * (v24 / 0x55) - v24) + 4032;
  }
  else
  {
    v21 = v20 - 1;
    v22 = &v12[v21 / 0x55];
    v23 = *v22 + 48 * (v21 % 0x55);
  }
  v25 = *(_OWORD *)(v23 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v23;
  *(_OWORD *)(a3 + 16) = v25;
  *(_OWORD *)(a3 + 25) = *(_OWORD *)(v23 + 25);
  v26 = (unint64_t *)&a1[5];
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  v28 = *(_QWORD *)(a3 + 16);
  v29 = &a1[5].u64[1];
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - v28, v29));
  return std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>>::erase(a1 + 2, v22, (char *)v23);
}

void sub_1B29F3304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(void))(a10 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (!a13)
    _Unwind_Resume(exception_object);
  (*(void (**)(void))(*a13 + 40))();
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E651A068;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E651A068;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1B5E29170);
}

_QWORD *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = operator new(0x30uLL);
  *v2 = &off_1E651A068;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
    goto LABEL_4;
  if (v4 != a1 + 8)
  {
    v4 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
LABEL_4:
    v5 = *(_QWORD *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v2[5] = *(_QWORD *)(a1 + 40);
  return v2;
}

void sub_1B29F34B0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t result;

  *a2 = &off_1E651A068;
  v4 = a2 + 1;
  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 8;
  result = *(_QWORD *)(a1 + 32);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  return *a2 == *(_QWORD *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE")
    return a1 + 8;
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN17HGMetalBufferPool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferPool::Descriptor>,std::allocator<HGMetalBufferPool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferPool> const&)>::target_type()
{
}

void std::__shared_ptr_emplace<`anonymous namespace'::BufferWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A0F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<`anonymous namespace'::BufferWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A0F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<`anonymous namespace'::BufferWrapperAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void `anonymous namespace'::BufferWrapperAllocator::~BufferWrapperAllocator(_anonymous_namespace_::BufferWrapperAllocator *this)
{
  JUMPOUT(0x1B5E29170);
}

uint64_t `anonymous namespace'::BufferWrapperAllocator::allocate(uint64_t a1, _QWORD *a2)
{
  return objc_msgSend(*(id *)(a1 + 8), "newBufferWithBytesNoCopy:length:options:deallocator:", *a2, a2[1], a2[2], 0);
}

void `anonymous namespace'::BufferWrapperAllocator::release(uint64_t a1, void *a2)
{

}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::~Pool(a1, a2);
  JUMPOUT(0x1B5E29170);
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::service(std::mutex *a1)
{
  std::mutex *v2;

  v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  if (HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::service((uint64_t)&a1[2].__m_.__opaque[16], (uint64_t)a1))
  {
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 24))(a1);
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
    kdebug_trace();
  }
  std::mutex::unlock(v2);
}

void sub_1B29F3864(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::trace(std::mutex *a1)
{
  std::mutex *v2;
  std::mutex *sig;

  v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0)
    sig = (std::mutex *)sig->__m_.__sig;
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B29F3A50(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F3A64(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F3A78(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F3A8C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log(uint64_t a1, const char *a2)
{
  HGLogger *v3;
  const char *v4;
  char *v5;
  unsigned __int8 v6;
  _QWORD *v7;
  const char *v8;
  char *v9;
  unsigned __int8 v10;
  const char *v11;
  char *v12;
  unsigned __int8 v13;

  v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2)
      return;
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  v6 = atomic_load(HGLogger::_enabled);
  if ((v6 & 1) != 0)
  {
    v7 = (_QWORD *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0)
      v7 = (_QWORD *)*v7;
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  v10 = atomic_load(HGLogger::_enabled);
  if ((v10 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::log((_QWORD *)(a1 + 48), v3);
  v13 = atomic_load(HGLogger::_enabled);
  if ((v13 & 1) != 0)
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::log((_QWORD *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);
  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B29F3BB8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::~List(int64x2_t *a1, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;

  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front(a1, 1, a3, a4, a5);
  std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  v6 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = (std::__shared_weak_count *)a1->i64[1];
  if (!v9)
    return a1;
  v10 = (unint64_t *)&v9->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (v11)
    return a1;
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front(int64x2_t *a1, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  void **v14;
  int64x2_t v15;
  unsigned __int8 v16;
  void *p_p;
  void *__p;
  char v20;

  v6 = (uint64_t *)(*(_QWORD *)(a1[2].i64[1] + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
                 + ((a1[4].i64[0] & 0x3F) << 6));
  v8 = *v6;
  v7 = v6[1];
  v9 = v6[3];
  v10 = (unint64_t *)&a1[5];
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  v12 = &a1[5].u64[1];
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - v9, v12));
  v14 = (void **)a1[2].i64[1];
  v15 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B304F0B0);
  a1[4] = v15;
  if (v15.i64[0] >= 0x80uLL)
  {
    operator delete(*v14);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 64;
  }
  v20 = 0;
  LOBYTE(__p) = 0;
  v16 = atomic_load(HGLogger::_enabled);
  if ((v16 & 1) != 0)
  {
    p_p = &__p;
    if (v20 < 0)
      p_p = __p;
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", a4, a5, v8, p_p);
  }
  if (v20 < 0)
    operator delete(__p);
  kdebug_trace();
  LODWORD(__p) = 4164;
  kdebug_trace();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0], v8);
  if (v7)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1->i64[0] + 24))(a1->i64[0], v7);
  return kdebug_trace();
}

void sub_1B29F3E6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1B29F3E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  char *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;

  *(_QWORD *)a1 = &off_1E651A198;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_24:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0)
    goto LABEL_24;
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::~List((int64x2_t *)(a1 + 152), v3, v4, v5, v6);
  std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = *(std::__shared_weak_count **)(a1 + 56);
  if (v10)
  {
    v11 = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = *(std::__shared_weak_count **)(a1 + 40);
  if (v13)
  {
    v14 = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v16)
    return a1;
  v17 = (unint64_t *)&v16->__shared_owners_;
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 - 1, v17));
  if (v18)
    return a1;
  ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
  std::__shared_weak_count::__release_weak(v16);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::service(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  if (*(_QWORD *)(a1 + 16))
  {
    if (*(_QWORD *)(a1 + 72))
    {
      v4 = 0;
      while (1)
      {
        v6 = atomic_load((unint64_t *)(a1 + 80));
        if (v6 > (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), a2))
        {
          v5 = 4;
        }
        else
        {
          v10 = atomic_load((unint64_t *)(a1 + 88));
          if (v10 <= (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), a2))
          {
            v11 = *(_QWORD *)(a1 + 64);
            v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8));
            v13 = std::chrono::steady_clock::now().__d_.__rep_ - *(_QWORD *)(v12 + ((v11 & 0x3F) << 6) + 40);
            if (v13 <= (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16), a2))return v4;
            v5 = 6;
          }
          else
          {
            v5 = 5;
          }
        }
        HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_pop_front((int64x2_t *)a1, v5, v7, v8, v9);
        ++v4;
        if (!*(_QWORD *)(a1 + 72))
          return v4;
      }
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

void HGPool::EntryTrace<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::trace(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 56))
    std::chrono::steady_clock::now();
}

void sub_1B29F41B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 *v12;
  HGLoggerUtils *v13;
  const char *v14;
  char *v15;
  unsigned __int8 v16;
  void **v17;
  unint64_t v18;
  void *__p[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 >> 6));
      v7 = (__int128 *)(*v6 + ((v5 & 0x3F) << 6));
      v8 = *(_QWORD *)(v4 + (((a1[9] + v5) >> 3) & 0x1FFFFFFFFFFFFFF8)) + (((a1[9] + v5) & 0x3F) << 6);
      while (v7 != (__int128 *)v8)
      {
        v9 = *v7;
        v10 = v7[1];
        v11 = v7[3];
        v21 = v7[2];
        v22 = v11;
        *(_OWORD *)__p = v9;
        v20 = v10;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 4;
        if ((__int128 *)((char *)v7 - *v6) == (__int128 *)4096)
        {
          v12 = (__int128 *)v6[1];
          ++v6;
          v7 = v12;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v13 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v13);
    v16 = atomic_load(HGLogger::_enabled);
    if ((v16 & 1) != 0)
    {
      if ((SBYTE7(v20) & 0x80u) == 0)
        v17 = __p;
      else
        v17 = (void **)__p[0];
      v18 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v14, v15, v17, v18);
    }
    if (SBYTE7(v20) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B29F431C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::log(_QWORD *a1, HGLogger *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 *v12;
  HGLoggerUtils *v13;
  const char *v14;
  char *v15;
  unsigned __int8 v16;
  void **v17;
  unint64_t v18;
  void *__p[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;

  if (a1[9])
  {
    HGLogger::indent(1);
    v4 = a1[5];
    if (a1[6] != v4)
    {
      v5 = a1[8];
      v6 = (_QWORD *)(v4 + 8 * (v5 >> 6));
      v7 = (__int128 *)(*v6 + ((v5 & 0x3F) << 6));
      v8 = *(_QWORD *)(v4 + (((a1[9] + v5) >> 3) & 0x1FFFFFFFFFFFFFF8)) + (((a1[9] + v5) & 0x3F) << 6);
      while (v7 != (__int128 *)v8)
      {
        v9 = *v7;
        v10 = v7[1];
        v11 = v7[3];
        v21 = v7[2];
        v22 = v11;
        *(_OWORD *)__p = v9;
        v20 = v10;
        HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 4;
        if ((__int128 *)((char *)v7 - *v6) == (__int128 *)4096)
        {
          v12 = (__int128 *)v6[1];
          ++v6;
          v7 = v12;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    v13 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v13);
    v16 = atomic_load(HGLogger::_enabled);
    if ((v16 & 1) != 0)
    {
      if ((SBYTE7(v20) & 0x80u) == 0)
        v17 = __p;
      else
        v17 = (void **)__p[0];
      v18 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v14, v15, v17, v18);
    }
    if (SBYTE7(v20) < 0)
      operator delete(__p[0]);
  }
}

void sub_1B29F4484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6;
  const char *v7;
  char *v8;
  unsigned __int8 v9;
  void **v10;
  void **v11;
  std::chrono::steady_clock::time_point v12;
  const char *v13;
  char *v14;
  unsigned __int8 v15;
  void **v16;
  void *p_p;
  void **v18;
  void *__p;
  char v20;
  void *v21[2];
  char v22;
  void *v23[2];
  char v24;

  v6 = *a1;
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)a1[3]);
  v22 = 0;
  LOBYTE(v21[0]) = 0;
  if (*((_BYTE *)a1 + 56))
  {
    v9 = atomic_load(HGLogger::_enabled);
    if ((v9 & 1) != 0)
    {
      v10 = v23;
      if (v24 < 0)
        v10 = (void **)v23[0];
      v11 = v21;
      if (v22 < 0)
        v11 = (void **)v21[0];
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v7, v8, v6, v10, a1[6], v11);
    }
    goto LABEL_17;
  }
  v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v12.__d_.__rep_ - a1[5]));
  v15 = atomic_load(HGLogger::_enabled);
  if ((v15 & 1) != 0)
  {
    v16 = v23;
    if (v24 < 0)
      v16 = (void **)v23[0];
    p_p = &__p;
    if (v20 < 0)
      p_p = __p;
    v18 = v21;
    if (v22 < 0)
      v18 = (void **)v21[0];
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v13, v14, v6, v16, a1[6], p_p, v18);
  }
  if ((v20 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v22 & 0x80000000) == 0)
      goto LABEL_18;
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v22 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v24 & 0x80000000) == 0)
      return;
LABEL_22:
    operator delete(v23[0]);
    return;
  }
LABEL_21:
  operator delete(v21[0]);
  if (v24 < 0)
    goto LABEL_22;
}

void sub_1B29F4628(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 33) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 33) & 0x80000000) == 0)
LABEL_4:
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 56));
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<`anonymous namespace'::InfinipoolServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A220;
  std::__shared_weak_count::~__shared_weak_count(this);
}

{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E65266C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<`anonymous namespace'::InfinipoolServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651A220;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E65266C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<`anonymous namespace'::InfinipoolServicingPolicy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void `anonymous namespace'::InfinipoolServicingPolicy::~InfinipoolServicingPolicy(_anonymous_namespace_::InfinipoolServicingPolicy *this)
{
  JUMPOUT(0x1B5E29170);
}

{
  JUMPOUT(0x1B5E29170);
}

uint64_t HGPool::ServicingPolicy::maxObjectsCount(HGPool::ServicingPolicy *this, const BasePool *a2)
{
  return -1;
}

uint64_t `anonymous namespace'::InfinipoolServicingPolicy::maxObjectAgeNS(_anonymous_namespace_::InfinipoolServicingPolicy *this, const BasePool *a2)
{
  return 2000000000;
}

{
  return 2000000000;
}

_QWORD *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  __int128 v15;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD *v18;
  _BYTE v19[24];
  _BYTE *v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21 = *a2;
  v22 = *((_QWORD *)a2 + 2);
  v14 = 0;
  v15 = v21;
  v16 = v22;
  v18 = 0;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)v6 = &off_1E651A2C0;
  *((_QWORD *)v6 + 4) = 0;
  *(_OWORD *)(v6 + 40) = *a2;
  *((_QWORD *)v6 + 7) = *((_QWORD *)a2 + 2);
  v18 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_retrieve(a1, v17, a3);
  v7 = v18;
  if (v18 == v17)
  {
    v8 = 4;
    v7 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v20;
  if (v20 == v19)
  {
    v12 = 4;
    result = v19;
  }
  else
  {
    if (!v20)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void sub_1B29F485C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char *a20,char a21,uint64_t a22,uint64_t a23,char *a24)
{
  char *v24;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;

  v26 = a20;
  if (a20 == v24)
  {
    v27 = 4;
    v26 = &a17;
  }
  else
  {
    if (!a20)
      goto LABEL_6;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_6:
  v28 = a13;
  if (a13 == &a10)
  {
    v29 = 4;
    v28 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_11:
  v30 = a24;
  if (a24 == &a21)
  {
    v31 = 4;
    v30 = &a21;
  }
  else
  {
    if (!a24)
      goto LABEL_16;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void **result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  __int128 v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  _BYTE v29[24];
  void **v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_BYTE *)(a3 + 56) = 1;
  v5 = a1[4].i64[0] + a1[4].i64[1];
  v6 = a1[2].i64[1];
  v7 = (uint64_t *)(v6 + 8 * (v5 >> 6));
  if (a1[3].i64[0] != v6)
  {
    v8 = *v7 + ((v5 & 0x3F) << 6);
    v9 = *(_QWORD *)(v6 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((a1[4].i64[0] & 0x3F) << 6);
    v10 = (_QWORD *)a2[3];
    if (v10)
      goto LABEL_3;
LABEL_6:
    v30 = 0;
    goto LABEL_8;
  }
  v8 = 0;
  v9 = 0;
  v10 = (_QWORD *)a2[3];
  if (!v10)
    goto LABEL_6;
LABEL_3:
  if (v10 == a2)
  {
    v30 = (void **)v29;
    (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v29);
  }
  else
  {
    v30 = (void **)(*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
  }
LABEL_8:
  if (v8 != v9)
  {
    v11 = *v7;
    while (1)
    {
      v12 = v8;
      if (v8 == v11)
        v12 = *(v7 - 1) + 4096;
      if (!v30)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*((uint64_t (**)(void **, uint64_t))*v30 + 6))(v30, v12 - 64) & 1) != 0)
        break;
      v11 = *v7;
      if (v8 == *v7)
      {
        v13 = *--v7;
        v11 = v13;
        v8 = v13 + 4096;
      }
      v8 -= 64;
      if (v8 == v9)
      {
        v8 = v9;
        break;
      }
    }
  }
  result = v30;
  if (v30 == (void **)v29)
  {
    v15 = 4;
    result = (void **)v29;
  }
  else
  {
    if (!v30)
      goto LABEL_23;
    v15 = 5;
  }
  result = (void **)(*((uint64_t (**)(void))*result + v15))();
LABEL_23:
  v16 = a1[2].i64[1];
  if (a1[3].i64[0] == v16)
  {
    if (!v8)
      return result;
  }
  else if (v8 == *(_QWORD *)(v16 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
                + ((a1[4].i64[0] & 0x3F) << 6))
  {
    return result;
  }
  v17 = v8 - *v7;
  v18 = v17 >> 6;
  if (v17 < 65)
  {
    v22 = 64 - v18;
    v20 = (char *)&v7[-(v22 >> 6)];
    v21 = *(_QWORD *)v20 + ((unint64_t)(~(_BYTE)v22 & 0x3F) << 6);
  }
  else
  {
    v19 = v18 - 1;
    v20 = (char *)&v7[v19 >> 6];
    v21 = *(_QWORD *)v20 + ((v19 & 0x3F) << 6);
  }
  v23 = *(_OWORD *)(v21 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v21;
  *(_OWORD *)(a3 + 16) = v23;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v21 + 32);
  *(_OWORD *)(a3 + 41) = *(_OWORD *)(v21 + 41);
  v24 = (unint64_t *)&a1[5];
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  v26 = *(_QWORD *)(a3 + 24);
  v27 = &a1[5].u64[1];
  do
    v28 = __ldaxr(v27);
  while (__stlxr(v28 - v26, v27));
  return std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::erase(a1 + 2, v20, (char *)v21);
}

void sub_1B29F4B8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(void))(a10 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (!a13)
    _Unwind_Resume(exception_object);
  (*(void (**)(void))(*a13 + 40))();
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E651A2C0;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E651A2C0;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1B5E29170);
}

char *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = (char *)operator new(0x40uLL);
  *(_QWORD *)v2 = &off_1E651A2C0;
  v3 = v2 + 8;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      *((_QWORD *)v2 + 4) = v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      goto LABEL_6;
    }
    v4 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v4 + 16))(v4, v3);
  }
  *((_QWORD *)v2 + 4) = v4;
LABEL_6:
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *((_QWORD *)v2 + 7) = *(_QWORD *)(a1 + 56);
  return v2;
}

void sub_1B29F4D30(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __n128 result;

  *(_QWORD *)a2 = &off_1E651A2C0;
  v4 = a2 + 8;
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    if (v5 == a1 + 8)
    {
      *(_QWORD *)(a2 + 32) = v4;
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
    }
    else
    {
      *(_QWORD *)(a2 + 32) = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 16))(v5, v4);
    }
  }
  else
  {
    *(_QWORD *)(a2 + 32) = 0;
  }
  result = *(__n128 *)(a1 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 8;
  result = *(_QWORD *)(a1 + 32);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  return a1[5] == a2[2] && a1[6] == a2[3] && a1[7] == a2[4];
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE")
    return a1 + 8;
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperIn"
                                "finipool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target_type()
{
}

void HGPool::EntryEventHandler<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>::allocated(_QWORD *a1, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  unsigned __int8 v5;
  void *p_p;
  void *__p;
  char v8;

  v8 = 0;
  LOBYTE(__p) = 0;
  v5 = atomic_load(HGLogger::_enabled);
  if ((v5 & 1) != 0)
  {
    p_p = &__p;
    if (v8 < 0)
      p_p = __p;
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry allocated : %p (%s)\n", a4, a5, *a1, p_p);
  }
  if (v8 < 0)
    operator delete(__p);
}

void sub_1B29F4FA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::deque<HGPool::Entry<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  BOOL v37;
  int64_t v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  size_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  void *v90;
  void *v91;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x40;
  v4 = v2 - 64;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v31 = (v5 - v9) >> 2;
      if (v5 == v9)
        v31 = 1;
      if (!(v31 >> 61))
      {
        v32 = v31 >> 2;
        v33 = 8 * v31;
        v34 = (char *)operator new(8 * v31);
        v35 = &v34[8 * v32];
        v36 = &v34[v33];
        v38 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            v74 = &v34[8 * v32];
            v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              v75 = (v39 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v40 = &v35[v76];
              v7 += v76;
              v77 = (__int128 *)(v6 + 3);
              v78 = v74 + 16;
              v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v40 = &v34[8 * v32];
          }
          do
          {
            v81 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_76;
      }
LABEL_87:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 8);
  v20 = v18 - v19;
  v21 = (v18 - v19) >> 3;
  v22 = v17 - *(_QWORD *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    v41 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    v8 = *v41;
    *(_QWORD *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_78;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v42 = (v5 - v9) >> 2;
      if (v5 == v9)
        v42 = 1;
      if (!(v42 >> 61))
      {
        v43 = v42 >> 2;
        v44 = 8 * v42;
        v34 = (char *)operator new(8 * v42);
        v35 = &v34[8 * v43];
        v36 = &v34[v44];
        v45 = v5 - v7;
        v37 = v5 == v7;
        v5 = v35;
        if (!v37)
        {
          v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            v82 = &v34[8 * v43];
            v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              v83 = (v46 >> 3) + 1;
              v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              v47 = &v35[v84];
              v7 += v84;
              v85 = (__int128 *)(v41 + 3);
              v86 = v82 + 16;
              v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
            }
          }
          else
          {
            v47 = &v34[8 * v43];
          }
          do
          {
            v89 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_76:
        *(_QWORD *)a1 = v34;
        *(_QWORD *)(a1 + 8) = v35;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_87;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v17 == *(_QWORD *)a1)
    v24 = 1;
  else
    v24 = v23;
  if (v24 >> 61)
    goto LABEL_87;
  v25 = (char *)operator new(8 * v24);
  v26 = operator new(0x1000uLL);
  v27 = &v25[8 * v21];
  v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19)
        v48 = 1;
      else
        v48 = v20 >> 2;
      if (v48 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v49 = (char *)operator new(8 * v48);
      v27 = &v49[8 * (v48 >> 2)];
      v28 = &v49[8 * v48];
      operator delete(v25);
      v50 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 16);
      v25 = v49;
      *(_QWORD *)v27 = v90;
      v29 = v27 + 8;
      if (v18 == v50)
        goto LABEL_45;
    }
    else
    {
      v30 = v21 + 2;
      if (v21 >= -1)
        v30 = v21 + 1;
      v27 -= 8 * (v30 >> 1);
      *(_QWORD *)v27 = v26;
      v29 = v27 + 8;
      if (v18 == v19)
        goto LABEL_45;
    }
    do
    {
LABEL_50:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27)
            v59 = 1;
          else
            v59 = (v28 - v27) >> 2;
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v60 = (char *)operator new(8 * v59);
          v25 = v60;
          v61 = (v59 + 3) >> 2;
          v53 = &v60[8 * v61];
          v62 = v29 - v27;
          v37 = v29 == v27;
          v29 = v53;
          if (!v37)
          {
            v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = v62 - 8;
            v64 = &v60[8 * v61];
            v65 = v27;
            if (v63 < 0x38)
              goto LABEL_91;
            v66 = 8 * v61;
            v64 = &v60[8 * v61];
            v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20)
              goto LABEL_91;
            v67 = (v63 >> 3) + 1;
            v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            v64 = &v53[v68];
            v65 = &v27[v68];
            v69 = (__int128 *)(v27 + 16);
            v70 = &v60[v66 + 16];
            v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_91:
              do
              {
                v73 = *(_QWORD *)v65;
                v65 += 8;
                *(_QWORD *)v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          v55 = (v28 - v29) >> 3;
          if (v55 >= -1)
            v56 = v55 + 1;
          else
            v56 = v55 + 2;
          v57 = &v29[8 * (v56 >> 1)];
          v53 = &v57[-(v29 - v27)];
          v58 = v29 - v27;
          v37 = v29 == v27;
          v29 = v57;
          if (!v37)
            memmove(v53, v27, v58);
          v25 = v27;
        }
      }
      else
      {
        v53 = v27;
      }
      v54 = *(_QWORD *)(v18 - 8);
      v18 -= 8;
      *((_QWORD *)v53 - 1) = v54;
      v51 = v53 - 8;
      v27 = v51;
    }
    while (v18 != *(_QWORD *)(a1 + 8));
    goto LABEL_46;
  }
  *(_QWORD *)v27 = v26;
  v29 = v27 + 8;
  if (v18 != v19)
    goto LABEL_50;
LABEL_45:
  v51 = v27;
LABEL_46:
  v52 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v51;
  *(_QWORD *)(a1 + 16) = v29;
  *(_QWORD *)(a1 + 24) = v28;
  if (v52)
    operator delete(v52);
}

void sub_1B29F5518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  void *v9;

  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B29F5534(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F5548(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F5560(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v19 = 0;
  v20 = v5;
  v14 = 0;
  v15 = v5;
  v6 = operator new(0x30uLL);
  *v6 = &off_1E651A3C8;
  v6[4] = 0;
  v6[5] = v5;
  v17 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::_retrieve(a1, v16, a3);
  v7 = v17;
  if (v17 == v16)
  {
    v8 = 4;
    v7 = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v12 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void sub_1B29F56A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  char *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v24 = a18;
  if (a18 == v22)
  {
    v25 = 4;
    v24 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  v28 = a22;
  if (a22 == &a19)
  {
    v29 = 4;
    v28 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_16;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

_QWORD *HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v19 = 0;
  v20 = v5;
  v14 = 0;
  v15 = v5;
  v6 = operator new(0x30uLL);
  *v6 = &off_1E651A3C8;
  v6[4] = 0;
  v6[5] = v5;
  v17 = v6;
  HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,false>::_retrieve(a1, v16, a3);
  v7 = v17;
  if (v17 == v16)
  {
    v8 = 4;
    v7 = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_11;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_11:
  result = v19;
  if (v19 == v18)
  {
    v12 = 4;
    result = v18;
  }
  else
  {
    if (!v19)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void sub_1B29F5868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  char *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v24 = a18;
  if (a18 == v22)
  {
    v25 = 4;
    v24 = &a15;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  v28 = a22;
  if (a22 == &a19)
  {
    v29 = 4;
    v28 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_16;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

void **HGPool::List<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void **result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  __int128 v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  _BYTE v29[24];
  void **v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_BYTE *)(a3 + 56) = 1;
  v5 = a1[4].i64[0] + a1[4].i64[1];
  v6 = a1[2].i64[1];
  v7 = (uint64_t *)(v6 + 8 * (v5 >> 6));
  if (a1[3].i64[0] != v6)
  {
    v8 = *v7 + ((v5 & 0x3F) << 6);
    v9 = *(_QWORD *)(v6 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8)) + ((a1[4].i64[0] & 0x3F) << 6);
    v10 = (_QWORD *)a2[3];
    if (v10)
      goto LABEL_3;
LABEL_6:
    v30 = 0;
    goto LABEL_8;
  }
  v8 = 0;
  v9 = 0;
  v10 = (_QWORD *)a2[3];
  if (!v10)
    goto LABEL_6;
LABEL_3:
  if (v10 == a2)
  {
    v30 = (void **)v29;
    (*(void (**)(_QWORD *, _BYTE *))(*a2 + 24))(a2, v29);
  }
  else
  {
    v30 = (void **)(*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
  }
LABEL_8:
  if (v8 != v9)
  {
    v11 = *v7;
    while (1)
    {
      v12 = v8;
      if (v8 == v11)
        v12 = *(v7 - 1) + 4096;
      if (!v30)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*((uint64_t (**)(void **, uint64_t))*v30 + 6))(v30, v12 - 64) & 1) != 0)
        break;
      v11 = *v7;
      if (v8 == *v7)
      {
        v13 = *--v7;
        v11 = v13;
        v8 = v13 + 4096;
      }
      v8 -= 64;
      if (v8 == v9)
      {
        v8 = v9;
        break;
      }
    }
  }
  result = v30;
  if (v30 == (void **)v29)
  {
    v15 = 4;
    result = (void **)v29;
  }
  else
  {
    if (!v30)
      goto LABEL_23;
    v15 = 5;
  }
  result = (void **)(*((uint64_t (**)(void))*result + v15))();
LABEL_23:
  v16 = a1[2].i64[1];
  if (a1[3].i64[0] == v16)
  {
    if (!v8)
      return result;
  }
  else if (v8 == *(_QWORD *)(v16 + (((unint64_t)a1[4].i64[0] >> 3) & 0x1FFFFFFFFFFFFFF8))
                + ((a1[4].i64[0] & 0x3F) << 6))
  {
    return result;
  }
  v17 = v8 - *v7;
  v18 = v17 >> 6;
  if (v17 < 65)
  {
    v22 = 64 - v18;
    v20 = (char *)&v7[-(v22 >> 6)];
    v21 = *(_QWORD *)v20 + ((unint64_t)(~(_BYTE)v22 & 0x3F) << 6);
  }
  else
  {
    v19 = v18 - 1;
    v20 = (char *)&v7[v19 >> 6];
    v21 = *(_QWORD *)v20 + ((v19 & 0x3F) << 6);
  }
  v23 = *(_OWORD *)(v21 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v21;
  *(_OWORD *)(a3 + 16) = v23;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v21 + 32);
  *(_OWORD *)(a3 + 41) = *(_OWORD *)(v21 + 41);
  v24 = (unint64_t *)&a1[5];
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  v26 = *(_QWORD *)(a3 + 24);
  v27 = &a1[5].u64[1];
  do
    v28 = __ldaxr(v27);
  while (__stlxr(v28 - v26, v27));
  return std::deque<HGPool::Entry<__CVBuffer *,HGCVPixelBufferPool::Descriptor>>::erase(a1 + 2, v20, (char *)v21);
}

void sub_1B29F5B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(void))(a10 + 32))();
    _Unwind_Resume(exception_object);
  }
  if (!a13)
    _Unwind_Resume(exception_object);
  (*(void (**)(void))(*a13 + 40))();
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E651A3C8;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E651A3C8;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1B5E29170);
}

_QWORD *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = operator new(0x30uLL);
  *v2 = &off_1E651A3C8;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
    goto LABEL_4;
  if (v4 != a1 + 8)
  {
    v4 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
LABEL_4:
    v5 = *(_QWORD *)(a1 + 40);
    v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  v2[4] = v3;
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v2[5] = *(_QWORD *)(a1 + 40);
  return v2;
}

void sub_1B29F5D44(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t result;

  *a2 = &off_1E651A3C8;
  v4 = a2 + 1;
  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(_QWORD *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 8;
  result = *(_QWORD *)(a1 + 32);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  return *a2 == *(_QWORD *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE")
    return a1 + 8;
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinip"
                                "ool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIPU19objcproto9MTLBuffer11objc_objectN30HGMetalBufferWrapperInfinipool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto9MTLBuffer}*,HGMetalBufferWrapperInfinipool::Descriptor>,std::allocator<HGMetalBufferWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto9MTLBuffer},HGMetalBufferWrapperInfinipool> const&)>::target_type()
{
}

HGNode *HGPQ::EOTF::EOTF(HGNode *this, double a2)
{
  _QWORD *v4;
  HgcST2084_EOTF *v5;
  float v6;

  HGNode::HGNode(this);
  *v4 = off_1E651A450;
  v5 = (HgcST2084_EOTF *)HGObject::operator new(0x1A0uLL);
  HgcST2084_EOTF::HgcST2084_EOTF(v5);
  *((_QWORD *)this + 51) = v5;
  v6 = 10000.0 / a2;
  *((float *)this + 104) = v6;
  return this;
}

void sub_1B29F5F78(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F5F94(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::EOTF::~EOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651A450;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651A450;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGPQ::EOTF::GetOutput(HGPQ::EOTF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, 6.2774, 0.012683, 0.0, 0.0);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, 0.83594, 18.852, -18.688, *((float *)this + 104));
  return *((_QWORD *)this + 51);
}

HGNode *HGPQ::InverseEOTF::InverseEOTF(HGNode *this, double a2)
{
  _QWORD *v4;
  HgcST2084_InverseEOTF *v5;

  HGNode::HGNode(this);
  *v4 = off_1E651A6A0;
  v5 = (HgcST2084_InverseEOTF *)HGObject::operator new(0x1A0uLL);
  HgcST2084_InverseEOTF::HgcST2084_InverseEOTF(v5);
  *((_QWORD *)this + 51) = v5;
  *((float32x2_t *)this + 52) = vcvt_f32_f64(vmulq_n_f64((float64x2_t)xmmword_1B309D0C0, pow(a2 / 10000.0, 0.159301758)));
  return this;
}

void sub_1B29F6178(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F6194(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::InverseEOTF::~InverseEOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651A6A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651A6A0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGPQ::InverseEOTF::GetOutput(HGPQ::InverseEOTF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, 0.1593, 78.844, 0.0, 0.0);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, 0.83594, *((float *)this + 104), *((float *)this + 105), 0.0);
  return *((_QWORD *)this + 51);
}

HGNode *HGPQ::OOTF::OOTF(HGNode *this, int a2, double a3, double a4)
{
  _QWORD *v8;
  HgcBT2100_PQ_OOTF_qtApprox *v9;
  long double v10;
  double v11;

  HGNode::HGNode(this);
  *v8 = off_1E651A8F0;
  if (a2)
  {
    v9 = (HgcBT2100_PQ_OOTF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OOTF_qtApprox::HgcBT2100_PQ_OOTF_qtApprox(v9);
  }
  else
  {
    v9 = (HgcBT2100_PQ_OOTF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OOTF::HgcBT2100_PQ_OOTF(v9);
  }
  *((_QWORD *)this + 51) = v9;
  v10 = a4 / a3;
  v11 = pow(v10, 0.416666667);
  *((float32x2_t *)this + 52) = vcvt_f32_f64(vmulq_n_f64((float64x2_t)xmmword_1B309D0D0, v11));
  *(float *)&v11 = v11 * 4.5;
  *((_DWORD *)this + 106) = LODWORD(v11);
  *(float *)&v11 = v10;
  *((_DWORD *)this + 107) = LODWORD(v11);
  return this;
}

void sub_1B29F6394(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F63B4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::OOTF::~OOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651A8F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651A8F0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGPQ::OOTF::GetOutput(HGPQ::OOTF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  const void *v5;
  void *v6;
  void *v7;
  void *v9;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  v5 = (const void *)*((_QWORD *)this + 51);
  if (v6)
  {
    v7 = v6;
    (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 0, *((float *)this + 104), *((float *)this + 105), *((float *)this + 106), 0.018);
    (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v7 + 96))(v7, 1, 0.45, 2.4, 0.0, 0.0);
  }
  else
  {
    (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, 1.0, 1.227, *((float *)this + 107), 0.0);
  }
  return *((_QWORD *)this + 51);
}

HGNode *HGPQ::InverseOOTF::InverseOOTF(HGNode *this, int a2, double a3, double a4)
{
  _QWORD *v8;
  HgcBT2100_PQ_OOTF_qtApprox *v9;
  long double v10;
  long double v11;

  HGNode::HGNode(this);
  *v8 = off_1E651AB40;
  if (a2)
  {
    v9 = (HgcBT2100_PQ_OOTF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OOTF_qtApprox::HgcBT2100_PQ_OOTF_qtApprox(v9);
  }
  else
  {
    v9 = (HgcBT2100_PQ_OOTF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_InverseOOTF::HgcBT2100_PQ_InverseOOTF(v9);
  }
  *((_QWORD *)this + 51) = v9;
  v10 = a3 / a4;
  v11 = pow(v10, 0.416666667);
  *((float32x2_t *)this + 52) = vcvt_f32_f64(vdivq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v11, 0), (float64x2_t)xmmword_1B309D0E0));
  *(float *)&v11 = 0.081 / v11;
  *((_DWORD *)this + 106) = LODWORD(v11);
  *(float *)&v11 = v10;
  *((_DWORD *)this + 107) = LODWORD(v11);
  return this;
}

void sub_1B29F6648(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F6668(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::InverseOOTF::~InverseOOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651AB40;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651AB40;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGPQ::InverseOOTF::GetOutput(HGPQ::InverseOOTF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  const void *v5;
  void *v6;
  void *v7;
  void *v9;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  v5 = (const void *)*((_QWORD *)this + 51);
  if (v6)
  {
    v7 = v6;
    (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 0, *((float *)this + 104), 0.090082, *((float *)this + 105), *((float *)this + 106));
    (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v7 + 96))(v7, 1, 0.41667, 2.2222, 0.0, 0.0);
  }
  else
  {
    (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, *((float *)this + 107), 0.815, 1.0, 0.0);
  }
  return *((_QWORD *)this + 51);
}

HGNode *HGPQ::OETF::OETF(HGNode *this, int a2, double a3)
{
  _QWORD *v6;
  HgcBT2100_PQ_OETF_qtApprox *v7;

  HGNode::HGNode(this);
  *v6 = off_1E651AD90;
  *((float32x2_t *)this + 52) = vcvt_f32_f64(vmulq_n_f64((float64x2_t)xmmword_1B309D0C0, pow(a3 / 10000.0, 0.159301758)));
  if (a2)
  {
    v7 = (HgcBT2100_PQ_OETF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OETF_qtApprox::HgcBT2100_PQ_OETF_qtApprox(v7);
  }
  else
  {
    v7 = (HgcBT2100_PQ_OETF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_OETF::HgcBT2100_PQ_OETF(v7);
  }
  *((_QWORD *)this + 51) = v7;
  return this;
}

void sub_1B29F68E4(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F6904(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::OETF::~OETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651AD90;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651AD90;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGPQ::OETF::GetOutput(HGPQ::OETF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  const void *v5;
  void *v6;
  void *v7;
  void *v9;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  v5 = (const void *)*((_QWORD *)this + 51);
  if (v5)
  {
    if (v6)
    {
      v7 = v6;
      (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 0, 1.099, -0.099, 4.5, 0.018);
      (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v7 + 96))(v7, 1, 0.45, 0.38232, 78.844, 0.0);
      (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v7 + 96))(v7, 2, 0.83594, *((float *)this + 104), *((float *)this + 105), 0.0);
      return *((_QWORD *)this + 51);
    }
  }
  else
  {
    v9 = 0;
  }
  (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, 0.19546, 78.844, 0.0, 0.0);
  (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 1, 0.83594, *((float *)this + 104), *((float *)this + 105), 0.0);
  return *((_QWORD *)this + 51);
}

HGNode *HGPQ::InverseOETF::InverseOETF(HGNode *this, int a2, double a3)
{
  _QWORD *v6;
  HgcBT2100_PQ_InverseOETF_qtApprox *v7;
  long double v8;
  long double v9;
  float v10;

  HGNode::HGNode(this);
  *v6 = off_1E651AFE0;
  if (a2)
  {
    v7 = (HgcBT2100_PQ_InverseOETF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_InverseOETF_qtApprox::HgcBT2100_PQ_InverseOETF_qtApprox(v7);
  }
  else
  {
    v7 = (HgcBT2100_PQ_InverseOETF_qtApprox *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_PQ_InverseOETF::HgcBT2100_PQ_InverseOETF(v7);
  }
  *((_QWORD *)this + 51) = v7;
  v8 = 10000.0 / a3;
  v9 = pow(v8, 0.416666667);
  *((float32x2_t *)this + 52) = vcvt_f32_f64(vdivq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v9, 0), (float64x2_t)xmmword_1B309D0E0));
  *(float *)&v9 = 0.081 / v9;
  *((_DWORD *)this + 106) = LODWORD(v9);
  v10 = pow(v8, 0.815);
  *((float *)this + 107) = v10;
  return this;
}

void sub_1B29F6C34(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F6C54(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPQ::InverseOETF::~InverseOETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651AFE0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651AFE0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGPQ::InverseOETF::GetOutput(HGPQ::InverseOETF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  const void *v5;
  void *v6;
  void *v7;
  void *v9;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  v5 = (const void *)*((_QWORD *)this + 51);
  if (v5)
  {
    if (v6)
    {
      v7 = v6;
      (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 0, 0.83594, 18.852, -18.688, 0.0);
      (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v7 + 96))(v7, 1, 2.6156, 0.012683, 2.2222, 0.0);
      (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v7 + 96))(v7, 2, *((float *)this + 104), 0.090082, *((float *)this + 105), *((float *)this + 106));
      return *((_QWORD *)this + 51);
    }
  }
  else
  {
    v9 = 0;
  }
  (*(void (**)(void *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, 0.83594, 18.852, -18.688, 0.0);
  (*(void (**)(void *, uint64_t, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 1, 5.1161, 0.012683, *((float *)this + 107), 0.0);
  return *((_QWORD *)this + 51);
}

HGNode *HGHLG::OETF::OETF(HGNode *this)
{
  _QWORD *v2;
  HgcBT2100_HLG_OETF *v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  int v9;

  HGNode::HGNode(this);
  *v2 = off_1E651B230;
  v3 = (HgcBT2100_HLG_OETF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_OETF::HgcBT2100_HLG_OETF(v3);
  *((_QWORD *)this + 51) = v3;
  v4 = atomic_load((unsigned __int8 *)&qword_1ED4D9540);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9540))
  {
    qword_1ED4D9538 = 0x3FE1EAC9E70D7420;
    __cxa_guard_release(&qword_1ED4D9540);
  }
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4D9548);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9548))
  {
    LODWORD(_MergedGlobals_4) = 1056964608;
    __cxa_guard_release(&qword_1ED4D9548);
  }
  v6 = atomic_load((unsigned __int8 *)&qword_1ED4D9550);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9550))
  {
    HIDWORD(_MergedGlobals_4) = 1040047461;
    __cxa_guard_release(&qword_1ED4D9550);
  }
  v7 = atomic_load((unsigned __int8 *)qword_1ED4D9558);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(qword_1ED4D9558))
  {
    *(float *)&v9 = *(double *)&qword_1ED4D9538 + 0.0;
    dword_1ED4D94F0 = v9;
    __cxa_guard_release(qword_1ED4D9558);
  }
  *((_QWORD *)this + 52) = _MergedGlobals_4;
  *((_DWORD *)this + 106) = dword_1ED4D94F0;
  return this;
}

void sub_1B29F701C(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F7038(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::OETF::~OETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651B230;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651B230;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGHLG::OETF::GetOutput(HGHLG::OETF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, 1.0, 0.0, 0.0, 0.0);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 104), *((float *)this + 105), 0.28467, *((float *)this + 106));
  return *((_QWORD *)this + 51);
}

HGNode *HGHLG::InverseOETF::InverseOETF(HGNode *this)
{
  _QWORD *v2;
  HgcBT2100_HLG_InverseOETF *v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  int v7;
  int v9;

  HGNode::HGNode(this);
  *v2 = off_1E651B480;
  v3 = (HgcBT2100_HLG_InverseOETF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_InverseOETF::HgcBT2100_HLG_InverseOETF(v3);
  *((_QWORD *)this + 51) = v3;
  v4 = atomic_load((unsigned __int8 *)&qword_1ED4D9578);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9578))
  {
    qword_1ED4D9570 = 0x3FE1EAC9E70D7420;
    __cxa_guard_release(&qword_1ED4D9578);
  }
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4D9580);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9580))
  {
    dword_1ED4D94F4 = 1090589594;
    __cxa_guard_release(&qword_1ED4D9580);
  }
  v6 = atomic_load((unsigned __int8 *)&qword_1ED4D9588);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9588))
  {
    *(float *)&v9 = *(double *)&qword_1ED4D9570 / -0.123957432;
    dword_1ED4D94F8 = v9;
    __cxa_guard_release(&qword_1ED4D9588);
  }
  v7 = dword_1ED4D94F8;
  *((_DWORD *)this + 104) = dword_1ED4D94F4;
  *((_DWORD *)this + 105) = v7;
  return this;
}

void sub_1B29F72A0(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F72BC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::InverseOETF::~InverseOETF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651B480;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651B480;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGHLG::InverseOETF::GetOutput(HGHLG::InverseOETF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, 0.5, 4.0, 0.0, 0.0);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 104), *((float *)this + 105), 1.0, 0.28467);
  return *((_QWORD *)this + 51);
}

float HGHLG::OOTF::setPeakDisplayLuminance(HGHLG::OOTF *this, double a2)
{
  double v4;
  long double v5;
  long double v6;
  float v7;
  float result;

  v4 = a2 / 1000.0;
  if (a2 < 400.0 || a2 > 2000.0)
  {
    v6 = log2(v4);
    v5 = pow(1.111, v6) * 1.2;
  }
  else
  {
    v5 = log10(v4) * 0.42 + 1.2;
  }
  v7 = v5 + -1.0;
  *((float *)this + 108) = v7;
  result = pow(0.0833333333, v5) * a2 / *((double *)this + 53);
  *((float *)this + 109) = result;
  return result;
}

uint64_t HGHLG::OOTF::OOTF(uint64_t a1, unsigned int a2, double a3)
{
  _QWORD *v6;
  HgcBT2100_HLG_OOTF_InverseOOTF *v7;
  float v8;

  HGNode::HGNode((HGNode *)a1);
  *v6 = off_1E651B6D0;
  v7 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v7);
  *(_QWORD *)(a1 + 408) = v7;
  *(_QWORD *)(a1 + 416) = (char *)&HGHLG::OOTF::luminanceCoeffs + 12 * a2;
  *(double *)(a1 + 424) = a3;
  *(_DWORD *)(a1 + 432) = 1045220557;
  v8 = 50.6970285 / a3;
  *(float *)(a1 + 436) = v8;
  return a1;
}

void sub_1B29F7564(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F7580(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::OOTF::~OOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651B6D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651B6D0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGHLG::OOTF::GetOutput(HGHLG::OOTF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, **((float **)this + 52), *(float *)(*((_QWORD *)this + 52) + 4), *(float *)(*((_QWORD *)this + 52) + 8), 0.0);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 108), *((float *)this + 109), 0.0, 0.0);
  return *((_QWORD *)this + 51);
}

float HGHLG::InverseOOTF::setPeakDisplayLuminance(HGHLG::InverseOOTF *this, double a2)
{
  double v4;
  double v5;
  long double v6;
  long double v7;
  float v8;
  float result;

  v4 = a2 / 1000.0;
  if (a2 < 400.0 || a2 > 2000.0)
  {
    v6 = log2(v4);
    v5 = pow(1.111, v6) * 1.2;
  }
  else
  {
    v5 = log10(v4) * 0.42 + 1.2;
  }
  v7 = 1.0 / v5;
  v8 = 1.0 / v5 + -1.0;
  *((float *)this + 108) = v8;
  result = pow(*((double *)this + 53) / a2, v7) * 12.0;
  *((float *)this + 109) = result;
  return result;
}

uint64_t HGHLG::InverseOOTF::InverseOOTF(uint64_t a1, unsigned int a2, double a3)
{
  _QWORD *v6;
  HgcBT2100_HLG_OOTF_InverseOOTF *v7;
  float v8;

  HGNode::HGNode((HGNode *)a1);
  *v6 = off_1E651B920;
  v7 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
  HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v7);
  *(_QWORD *)(a1 + 408) = v7;
  *(_QWORD *)(a1 + 416) = (char *)&HGHLG::OOTF::luminanceCoeffs + 12 * a2;
  *(double *)(a1 + 424) = a3;
  *(_DWORD *)(a1 + 432) = -1104500053;
  v8 = pow(a3 / 1000.0, 0.833333333) * 12.0;
  *(float *)(a1 + 436) = v8;
  return a1;
}

void sub_1B29F7830(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F784C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::InverseOOTF::~InverseOOTF(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651B920;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651B920;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGHLG::InverseOOTF::GetOutput(HGHLG::InverseOOTF *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, **((float **)this + 52), *(float *)(*((_QWORD *)this + 52) + 4), *(float *)(*((_QWORD *)this + 52) + 8), 0.0);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 108), *((float *)this + 109), 0.0, 0.0);
  return *((_QWORD *)this + 51);
}

uint64_t HGHLG::HLGToSDR::HLGToSDR(uint64_t a1, int a2)
{
  uint64_t v4;

  HGNode::HGNode((HGNode *)a1);
  *(_QWORD *)v4 = off_1E651BB70;
  *(_QWORD *)(v4 + 408) = 0;
  *(_WORD *)(v4 + 416) = 0;
  *(_DWORD *)(v4 + 420) = a2;
  *(_DWORD *)(a1 + 424) = TXParagraphStyleFolder_Factory::version((TXParagraphStyleFolder_Factory *)v4);
  return a1;
}

void sub_1B29F79C4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::HLGToSDR::~HLGToSDR(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651BB70;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651BB70;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGHLG::HLGToSDR::SetOutputIsRec709Gamma(uint64_t this, char a2)
{
  *(_BYTE *)(this + 416) = a2;
  return this;
}

uint64_t HGHLG::HLGToSDR::SetToneQualityMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 424) = a2;
  return result;
}

uint64_t HGHLG::HLGToSDR::SetMinimumInputValueZero(uint64_t this, char a2)
{
  *(_BYTE *)(this + 417) = a2;
  return this;
}

uint64_t HGHLG::HLGToSDR::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  unsigned int v4;
  HGNode *v5;
  HgcBT2100_HLG_OOTF_InverseOOTF *v6;
  float v7;
  HGColorMatrix *v8;
  HGColorGamma *v9;
  char *v10;
  char *v11;
  HGNode *v12;
  HgcBT2100_HLG_OOTF_InverseOOTF *v13;
  float v14;
  HgcBT2446_Method_A_TMO_Input_Clamped *v15;
  HGColorGamma *v16;
  char *v17;
  char *v18;
  int v19;
  int v20;
  HGColorConform *v21;
  char *v22;

  Input = HGRenderer::GetInput(a2, this, 0);
  v4 = *((_DWORD *)this + 105);
  if (v4 >= 2)
  {
    if (v4 == 2)
    {
      v12 = (HGNode *)HGObject::operator new(0x1C0uLL);
      HGNode::HGNode(v12);
      *(_QWORD *)v12 = off_1E651B6D0;
      v13 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
      HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v13);
      *((_QWORD *)v12 + 51) = v13;
      *((_QWORD *)v12 + 52) = &unk_1B309D14C;
      *((_QWORD *)v12 + 53) = 0x408F400000000000;
      *((_QWORD *)v12 + 54) = 0x3D4FA7B03E4CCCCDLL;
      (*(void (**)(HGNode *, _QWORD, HGNode *))(*(_QWORD *)v12 + 120))(v12, 0, Input);
      *((_DWORD *)v12 + 108) = 1045220557;
      v14 = 50.6970285 / *((double *)v12 + 53);
      *((float *)v12 + 109) = v14;
      if (*((_BYTE *)this + 417))
      {
        v15 = (HgcBT2446_Method_A_TMO_Input_Clamped *)HGObject::operator new(0x1A0uLL);
        HgcBT2446_Method_A_TMO_Input_Clamped::HgcBT2446_Method_A_TMO_Input_Clamped(v15);
      }
      else
      {
        v15 = (HgcBT2446_Method_A_TMO_Input_Clamped *)HGObject::operator new(0x1A0uLL);
        HgcBT2446_Method_A_TMO::HgcBT2446_Method_A_TMO(v15);
      }
      (*(void (**)(HgcBT2446_Method_A_TMO_Input_Clamped *, _QWORD, HGNode *))(*(_QWORD *)v15 + 120))(v15, 0, v12);
      if (*((_BYTE *)this + 416))
        v19 = 0;
      else
        v19 = 3;
      if (*((_BYTE *)this + 416))
        v20 = 1;
      else
        v20 = 8;
      v21 = (HGColorConform *)HGObject::operator new(0x320uLL);
      HGColorConform::HGColorConform(v21);
      (*(void (**)(HGColorConform *, _QWORD, HgcBT2446_Method_A_TMO_Input_Clamped *))(*(_QWORD *)v21 + 120))(v21, 0, v15);
      HGColorConform::SetToneQualityMode((HGNode *)v21, *((unsigned int *)this + 106), v22);
      HGColorConform::SetConversion((uint64_t)v21, 3, 1, 3, v19, v20, 0);
      HGColorConform::SetPremultiplyState((HGNode *)v21, 0, 0);
      (*(void (**)(HGColorConform *))(*(_QWORD *)v21 + 16))(v21);
      *((_QWORD *)this + 51) = v21;
      (*(void (**)(HGColorConform *))(*(_QWORD *)v21 + 24))(v21);
      (*(void (**)(HgcBT2446_Method_A_TMO_Input_Clamped *))(*(_QWORD *)v15 + 24))(v15);
      (*(void (**)(HGNode *))(*(_QWORD *)v12 + 24))(v12);
    }
  }
  else
  {
    v5 = (HGNode *)HGObject::operator new(0x1C0uLL);
    HGNode::HGNode(v5);
    *(_QWORD *)v5 = off_1E651B6D0;
    v6 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v6);
    *((_QWORD *)v5 + 51) = v6;
    *((_QWORD *)v5 + 52) = &unk_1B309D14C;
    *((_QWORD *)v5 + 53) = 0x4059000000000000;
    *((_QWORD *)v5 + 54) = 0x3F01C8CE3E4CCCCDLL;
    (*(void (**)(HGNode *, _QWORD, HGNode *))(*(_QWORD *)v5 + 120))(v5, 0, Input);
    *((_DWORD *)v5 + 108) = -1105343833;
    v7 = 12.2211881 / *((double *)v5 + 53);
    *((float *)v5 + 109) = v7;
    v8 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v8);
    (*(void (**)(HGColorMatrix *, _QWORD, HGNode *))(*(_QWORD *)v8 + 120))(v8, 0, v5);
    HGColorMatrix::LoadMatrix(v8, HGColorGamma::rec2020RGBToRec709RGB, 1);
    if (*((_DWORD *)this + 105))
    {
      v9 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
      HGColorGamma::HGColorGamma(v9);
      (*(void (**)(HGColorGamma *, _QWORD, HGColorMatrix *))(*(_QWORD *)v9 + 120))(v9, 0, v8);
      HGColorGamma::SetToneQualityMode((uint64_t)v9, *((unsigned int *)this + 106), v10);
      HGColorGamma::SetConversion((uint64_t)v9, 0, (char *)8, 0, 0, 13, 0);
      HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v9, 1);
      HGColorGamma::SetToneQualityMode((uint64_t)v9, 2, v11);
      HGColorGamma::SetPremultiplyState(v9, 0, 0);
    }
    else
    {
      v9 = (HGColorGamma *)HGObject::operator new(0x1B0uLL);
      HGGamma::HGGamma(v9);
      (*(void (**)(HGColorGamma *, _QWORD, HGColorMatrix *))(*(_QWORD *)v9 + 120))(v9, 0, v8);
      (*(void (**)(HGColorGamma *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, 0.45455, 0.0, 0.0, 0.0);
    }
    (*(void (**)(HGColorGamma *))(*(_QWORD *)v9 + 16))(v9);
    (*(void (**)(HGColorGamma *))(*(_QWORD *)v9 + 24))(v9);
    if (*((_BYTE *)this + 416))
    {
      (*(void (**)(HGColorGamma *))(*(_QWORD *)v9 + 16))(v9);
      *((_QWORD *)this + 51) = v9;
    }
    else
    {
      v16 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
      HGColorGamma::HGColorGamma(v16);
      (*(void (**)(HGColorGamma *, _QWORD, HGColorGamma *))(*(_QWORD *)v16 + 120))(v16, 0, v9);
      HGColorGamma::SetToneQualityMode((uint64_t)v16, *((unsigned int *)this + 106), v17);
      HGColorGamma::SetConversion((uint64_t)v16, 0, (char *)1, 0, 3u, 8, 0);
      HGColorGamma::SetToneQualityMode((uint64_t)v16, 2, v18);
      HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v16, 1);
      HGColorGamma::SetPremultiplyState(v16, 0, 0);
      (*(void (**)(HGColorGamma *))(*(_QWORD *)v16 + 16))(v16);
      *((_QWORD *)this + 51) = v16;
      (*(void (**)(HGColorGamma *))(*(_QWORD *)v16 + 24))(v16);
    }
    (*(void (**)(HGColorGamma *))(*(_QWORD *)v9 + 24))(v9);
    (*(void (**)(HGColorMatrix *))(*(_QWORD *)v8 + 24))(v8);
    (*(void (**)(HGNode *))(*(_QWORD *)v5 + 24))(v5);
  }
  return *((_QWORD *)this + 51);
}

void sub_1B29F7F48(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHLG::SDRToHLG::SDRToHLG(uint64_t a1, int a2, int a3)
{
  uint64_t v6;

  HGNode::HGNode((HGNode *)a1);
  *(_QWORD *)v6 = off_1E651BDC0;
  *(_QWORD *)(v6 + 408) = 0;
  *(_DWORD *)(v6 + 416) = a2;
  *(_DWORD *)(v6 + 420) = a3;
  *(_DWORD *)(a1 + 424) = TXParagraphStyleFolder_Factory::version((TXParagraphStyleFolder_Factory *)v6);
  return a1;
}

void sub_1B29F81B8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGHLG::SDRToHLG::~SDRToHLG(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651BDC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651BDC0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGHLG::SDRToHLG::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  int v4;
  HGGamma *v5;
  int v6;
  HGGamma *v7;
  HGColorGamma *v8;
  HGColorConform *v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  HgcBT2446_Method_A_ITMO *v14;
  HGNode *v15;
  HgcBT2100_HLG_OOTF_InverseOOTF *v16;
  float v17;
  HGColorConform *v18;
  char *v19;
  char *v20;
  int v21;
  int v22;
  int v23;
  char *v24;
  HGNode *v25;
  HgcBT2100_HLG_OOTF_InverseOOTF *v26;
  float v27;
  char *v29;
  uint64_t v30;

  Input = HGRenderer::GetInput(a2, this, 0);
  v4 = *((_DWORD *)this + 105);
  if (v4 == 2)
  {
    v18 = (HGColorConform *)HGObject::operator new(0x320uLL);
    HGColorConform::HGColorConform(v18);
    (*(void (**)(HGColorConform *, _QWORD, HGNode *))(*(_QWORD *)v18 + 120))(v18, 0, Input);
    HGColorConform::SetToneQualityMode((HGNode *)v18, *((unsigned int *)this + 106), v19);
    HGColorConform::SetAntiSymmetricToneCurves((HGNode *)v18, 1, v20);
    v21 = *((_DWORD *)this + 104);
    if (v21 == 1)
      v22 = 5;
    else
      v22 = 3;
    if (v21)
      v23 = v22;
    else
      v23 = 0;
    HGColorConform::SetConversion((uint64_t)v18, v23, 13, 0, 3, 8, 0);
    HGColorConform::SetToneQualityMode((HGNode *)v18, 2, v24);
    HGColorConform::SetPremultiplyState((HGNode *)v18, 0, 0);
    v25 = (HGNode *)HGObject::operator new(0x1C0uLL);
    HGNode::HGNode(v25);
    *(_QWORD *)v25 = off_1E651B920;
    v26 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v26);
    *((_QWORD *)v25 + 51) = v26;
    *((_QWORD *)v25 + 52) = &unk_1B309D14C;
    *((_QWORD *)v25 + 53) = 0x4059000000000000;
    *((_QWORD *)v25 + 54) = 0x3FE17437BE2AAAABLL;
    (*(void (**)(HGNode *, _QWORD, HGColorConform *))(*(_QWORD *)v25 + 120))(v25, 0, v18);
    *((_DWORD *)v25 + 108) = 1044023574;
    v27 = pow(*((double *)v25 + 53) / 100.0, 1.18216357) * 12.0;
    *((float *)v25 + 109) = v27;
    (*(void (**)(HGNode *))(*(_QWORD *)v25 + 16))(v25);
    *((_QWORD *)this + 51) = v25;
    (*(void (**)(HGNode *))(*(_QWORD *)v25 + 24))(v25);
    (*(void (**)(HGColorConform *))(*(_QWORD *)v18 + 24))(v18);
    return *((_QWORD *)this + 51);
  }
  if (v4 == 1)
  {
    v9 = (HGColorConform *)HGObject::operator new(0x320uLL);
    HGColorConform::HGColorConform(v9);
    (*(void (**)(HGColorConform *, _QWORD, HGNode *))(*(_QWORD *)v9 + 120))(v9, 0, Input);
    HGColorConform::SetToneQualityMode((HGNode *)v9, *((unsigned int *)this + 106), v10);
    v11 = *((_DWORD *)this + 104);
    if (v11 == 1)
      v12 = 5;
    else
      v12 = 3;
    if (v11)
      v13 = v12;
    else
      v13 = 0;
    HGColorConform::SetConversion((uint64_t)v9, v13, 1, 0, 3, 1, 3);
    HGColorConform::SetPremultiplyState((HGNode *)v9, 0, 0);
    v14 = (HgcBT2446_Method_A_ITMO *)HGObject::operator new(0x1A0uLL);
    HgcBT2446_Method_A_ITMO::HgcBT2446_Method_A_ITMO(v14);
    (*(void (**)(HgcBT2446_Method_A_ITMO *, _QWORD, HGColorConform *))(*(_QWORD *)v14 + 120))(v14, 0, v9);
    v15 = (HGNode *)HGObject::operator new(0x1C0uLL);
    HGNode::HGNode(v15);
    *(_QWORD *)v15 = off_1E651B920;
    v16 = (HgcBT2100_HLG_OOTF_InverseOOTF *)HGObject::operator new(0x1A0uLL);
    HgcBT2100_HLG_OOTF_InverseOOTF::HgcBT2100_HLG_OOTF_InverseOOTF(v16);
    *((_QWORD *)v15 + 51) = v16;
    *((_QWORD *)v15 + 52) = &unk_1B309D14C;
    *((_QWORD *)v15 + 53) = 0x408F400000000000;
    *((_QWORD *)v15 + 54) = 0x41400000BE2AAAABLL;
    (*(void (**)(HGNode *, _QWORD, HgcBT2446_Method_A_ITMO *))(*(_QWORD *)v15 + 120))(v15, 0, v14);
    *((_DWORD *)v15 + 108) = -1104500053;
    v17 = pow(*((double *)v15 + 53) / 1000.0, 0.833333333) * 12.0;
    *((float *)v15 + 109) = v17;
    (*(void (**)(HGNode *))(*(_QWORD *)v15 + 16))(v15);
    *((_QWORD *)this + 51) = v15;
    (*(void (**)(HGNode *))(*(_QWORD *)v15 + 24))(v15);
    (*(void (**)(HGColorConform *))(*(_QWORD *)v9 + 24))(v9);
    goto LABEL_28;
  }
  if (v4)
    return *((_QWORD *)this + 51);
  v5 = (HGGamma *)HGObject::operator new(0x1B0uLL);
  HGGamma::HGGamma(v5);
  (*(void (**)(HGGamma *, _QWORD, HGNode *))(*(_QWORD *)v5 + 120))(v5, 0, Input);
  (*(void (**)(HGGamma *, _QWORD, float, float, float, float))(*(_QWORD *)v5 + 96))(v5, 0, 2.0, 2.0, 2.0, 1.0);
  HGGamma::SetPremultiplyState((uint64_t)v5, 0);
  (*(void (**)(HGGamma *))(*(_QWORD *)v5 + 16))(v5);
  v6 = *((_DWORD *)this + 104);
  if (v6 == 1)
  {
    v8 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
    HGColorGamma::HGColorGamma(v8);
    (*(void (**)(HGColorGamma *, _QWORD, HGGamma *))(*(_QWORD *)v8 + 120))(v8, 0, v5);
    HGColorGamma::SetToneQualityMode((uint64_t)v8, *((unsigned int *)this + 106), v29);
    HGColorGamma::SetConversion((uint64_t)v8, 5, (char *)8, 0, 3u, 8, 0);
    HGColorGamma::SetPremultiplyState(v8, 0, 0);
    v7 = v5;
    if (v5 != v8)
    {
      (*(void (**)(HGGamma *))(*(_QWORD *)v5 + 24))(v5);
      v7 = v8;
      (*(void (**)(HGColorGamma *))(*(_QWORD *)v8 + 16))(v8);
    }
    goto LABEL_26;
  }
  v7 = v5;
  if (!v6)
  {
    v8 = (HGColorGamma *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v8);
    (*(void (**)(HGColorGamma *, _QWORD, HGGamma *))(*(_QWORD *)v8 + 120))(v8, 0, v5);
    HGColorMatrix::LoadMatrix(v8, HGColorGamma::rec709RGBToRec2020RGB, 1);
    v7 = v5;
    if (v5 != v8)
    {
      (*(void (**)(HGGamma *))(*(_QWORD *)v5 + 24))(v5);
      v7 = v8;
      (*(void (**)(HGColorGamma *))(*(_QWORD *)v8 + 16))(v8);
    }
LABEL_26:
    (*(void (**)(HGColorGamma *))(*(_QWORD *)v8 + 24))(v8);
  }
  v14 = (HgcBT2446_Method_A_ITMO *)HGObject::operator new(0x1A0uLL);
  HgcBT2390_Gain_Sat_ToneAdj::HgcBT2390_Gain_Sat_ToneAdj(v14);
  (*(void (**)(HgcBT2446_Method_A_ITMO *, _QWORD, HGGamma *))(*(_QWORD *)v14 + 120))(v14, 0, v7);
  (*(void (**)(HgcBT2446_Method_A_ITMO *))(*(_QWORD *)v14 + 16))(v14);
  *((_QWORD *)this + 51) = v14;
  (*(void (**)(HGGamma *))(*(_QWORD *)v7 + 24))(v7);
  (*(void (**)(HGGamma *))(*(_QWORD *)v5 + 24))(v5);
LABEL_28:
  v30 = *((_QWORD *)this + 51);
  (*(void (**)(HgcBT2446_Method_A_ITMO *))(*(_QWORD *)v14 + 24))(v14);
  return v30;
}

void sub_1B29F87E0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

HGNode *HGACEScct::Encode::Encode(HGNode *this)
{
  _QWORD *v2;
  HgcLogVideo_encode *v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  float v8;
  int v9;
  int v11;

  HGNode::HGNode(this);
  *v2 = off_1E651C010;
  v3 = (HgcLogVideo_encode *)HGObject::operator new(0x1A0uLL);
  HgcLogVideo_encode::HgcLogVideo_encode(v3);
  *((_QWORD *)this + 51) = v3;
  v4 = atomic_load((unsigned __int8 *)&qword_1ED4D9598);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9598))
  {
    qword_1ED4D9590 = 0x4025149A0A90F133;
    __cxa_guard_release(&qword_1ED4D9598);
  }
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4D95A8);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95A8))
  {
    *(double *)&qword_1ED4D95A0 = *(double *)&qword_1ED4D9590 * -0.0078125 + 0.155251142;
    __cxa_guard_release(&qword_1ED4D95A8);
  }
  v6 = atomic_load((unsigned __int8 *)&qword_1ED4D95B0);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95B0))
  {
    dword_1ED4D94FC = 1057738349;
    __cxa_guard_release(&qword_1ED4D95B0);
  }
  v7 = atomic_load((unsigned __int8 *)&qword_1ED4D95B8);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95B8))
  {
    *(float *)&v11 = *(double *)&qword_1ED4D9590 * 0.9;
    dword_1ED4D9500 = v11;
    __cxa_guard_release(&qword_1ED4D95B8);
  }
  v8 = *(double *)&qword_1ED4D95A0;
  *((float *)this + 104) = v8;
  v9 = dword_1ED4D9500;
  *((_DWORD *)this + 105) = dword_1ED4D94FC;
  *((_DWORD *)this + 106) = v9;
  return this;
}

void sub_1B29F8BBC(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F8BD8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGACEScct::Encode::~Encode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651C010;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651C010;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGACEScct::Encode::GetOutput(HGACEScct::Encode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, 1.0, 0.0, 0.057078, *((float *)this + 105));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 106), *((float *)this + 104), 0.0086806, 0.0);
  return *((_QWORD *)this + 51);
}

HGNode *HGACEScct::Decode::Decode(HGNode *this)
{
  _QWORD *v2;
  HgcLogVideo_decode *v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  float v10;
  int v11;

  HGNode::HGNode(this);
  *v2 = off_1E651C260;
  v3 = (HgcLogVideo_decode *)HGObject::operator new(0x1A0uLL);
  HgcLogVideo_decode::HgcLogVideo_decode(v3);
  *((_QWORD *)this + 51) = v3;
  v4 = atomic_load((unsigned __int8 *)&qword_1ED4D95C8);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95C8))
  {
    qword_1ED4D95C0 = 0x4025149A0A90F133;
    __cxa_guard_release(&qword_1ED4D95C8);
  }
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4D95D8);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95D8))
  {
    *(double *)&qword_1ED4D95D0 = *(double *)&qword_1ED4D95C0 * -0.0078125 + 0.155251142;
    __cxa_guard_release(&qword_1ED4D95D8);
  }
  v6 = atomic_load((unsigned __int8 *)&qword_1ED4D95E0);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95E0))
  {
    LODWORD(qword_1ED4D9504) = -1055320444;
    __cxa_guard_release(&qword_1ED4D95E0);
  }
  v7 = atomic_load((unsigned __int8 *)&qword_1ED4D95E8);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95E8))
  {
    v10 = 1.0 / (*(double *)&qword_1ED4D95C0 * 0.9);
    *((float *)&qword_1ED4D9504 + 1) = v10;
    __cxa_guard_release(&qword_1ED4D95E8);
  }
  v8 = atomic_load((unsigned __int8 *)&qword_1ED4D95F0);
  if ((v8 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95F0))
  {
    *(float *)&v11 = *(double *)&qword_1ED4D95D0 / (*(double *)&qword_1ED4D95C0 * -0.9);
    dword_1ED4D950C = v11;
    __cxa_guard_release(&qword_1ED4D95F0);
  }
  *((_QWORD *)this + 52) = qword_1ED4D9504;
  *((_DWORD *)this + 106) = dword_1ED4D950C;
  return this;
}

void sub_1B29F8EFC(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F8F18(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGACEScct::Decode::~Decode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651C260;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651C260;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGACEScct::Decode::GetOutput(HGACEScct::Decode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, 1.0, 0.0, 17.52, *((float *)this + 104));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, *((float *)this + 105), *((float *)this + 106), 0.15525, 0.0);
  return *((_QWORD *)this + 51);
}

uint64_t HGCanonLog2CinemaGamut::Encode::Encode(uint64_t a1, unsigned int a2, int a3)
{
  _QWORD *v6;
  HGColorMatrix *v7;
  HgcCanonLog_encode *v8;

  HGNode::HGNode((HGNode *)a1);
  *v6 = off_1E651C4B0;
  v7 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v7);
  *(_QWORD *)(a1 + 408) = v7;
  v8 = (HgcCanonLog_encode *)HGObject::operator new(0x1A0uLL);
  HgcCanonLog_encode::HgcCanonLog_encode(v8);
  *(_QWORD *)(a1 + 416) = v8;
  *(_QWORD *)(a1 + 424) = (char *)&HGCanonLog2CinemaGamut::Encode::sourceToCinemaGamut + 64 * (unint64_t)a2;
  *(_DWORD *)(a1 + 432) = a3;
  return a1;
}

void sub_1B29F90DC(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F90FC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGCanonLog2CinemaGamut::Encode::~Encode(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E651C4B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E651C4B0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGCanonLog2CinemaGamut::Encode::GetOutput(HGCanonLog2CinemaGamut::Encode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  float v5;
  float v6;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  if (*((_DWORD *)this + 108))
    v5 = 0.072657;
  else
    v5 = 0.084849;
  if (*((_DWORD *)this + 108))
    v6 = 0.092864;
  else
    v6 = 0.035388;
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, *((_QWORD *)this + 51));
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, v5, v6, 87.099, 0.0);
  return *((_QWORD *)this + 52);
}

uint64_t HGDJIDLog::Encode::Encode(uint64_t a1, unsigned int a2)
{
  _QWORD *v4;
  HGColorMatrix *v5;
  HgcLogVideo_encode *v6;

  HGNode::HGNode((HGNode *)a1);
  *v4 = off_1E651C700;
  v5 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v5);
  *(_QWORD *)(a1 + 408) = v5;
  v6 = (HgcLogVideo_encode *)HGObject::operator new(0x1A0uLL);
  HgcLogVideo_encode::HgcLogVideo_encode(v6);
  *(_QWORD *)(a1 + 416) = v6;
  *(_QWORD *)(a1 + 424) = (char *)&HGDJIDLog::Encode::sourceToDGamut + 64 * (unint64_t)a2;
  return a1;
}

void sub_1B29F931C(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F933C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGDJIDLog::Encode::~Encode(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E651C700;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E651C700;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGDJIDLog::Encode::GetOutput(HGDJIDLog::Encode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  unsigned __int8 v5;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4D95F8);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D95F8))
  {
    dword_1ED4D9510 = 1033780275;
    __cxa_guard_release(&qword_1ED4D95F8);
  }
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, *((_QWORD *)this + 51));
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, 0.89028, 0.0108, *(float *)&dword_1ED4D9510, 0.58455);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 1, 5.4225, 0.0929, 0.0086667, 0.0);
  return *((_QWORD *)this + 52);
}

void HGFujifilmFLog2::Encode::~Encode(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E651C950;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E651C950;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGFujifilmFLog2::Encode::GetOutput(HGFujifilmFLog2::Encode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  unsigned __int8 v5;
  HGNode *v7;
  int v8;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (v3)
  {
    (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
    HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
    Input = (HGNode *)*((_QWORD *)this + 51);
  }
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4D9600);
  if ((v5 & 1) == 0)
  {
    v7 = Input;
    v8 = __cxa_guard_acquire(&qword_1ED4D9600);
    Input = v7;
    if (v8)
    {
      dword_1ED4D9514 = 1033320402;
      __cxa_guard_release(&qword_1ED4D9600);
      Input = v7;
    }
  }
  (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, 5.0, 0.064829, *(float *)&dword_1ED4D9514, 0.38432);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 1, 7.9195, 0.092864, 0.00098778, 0.0);
  return *((_QWORD *)this + 52);
}

uint64_t HGNikonNLog::Encode::Encode(uint64_t a1, int a2)
{
  _QWORD *v4;
  HgcNikonLog_encode *v5;
  HGColorMatrix *v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  int v9;

  HGNode::HGNode((HGNode *)a1);
  *v4 = off_1E651CBA0;
  v4[51] = 0;
  v5 = (HgcNikonLog_encode *)HGObject::operator new(0x1A0uLL);
  HgcNikonLog_encode::HgcNikonLog_encode(v5);
  *(_QWORD *)(a1 + 416) = v5;
  *(_QWORD *)(a1 + 424) = 0;
  if (!a2)
  {
    v6 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v6);
    *(_QWORD *)(a1 + 408) = v6;
    *(_QWORD *)(a1 + 424) = HGColorGamma::rec709RGBToRec2020RGB;
  }
  v7 = atomic_load((unsigned __int8 *)&qword_1ED4D9608);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9608))
  {
    dword_1ED4D9518 = 1037051326;
    __cxa_guard_release(&qword_1ED4D9608);
  }
  v8 = atomic_load((unsigned __int8 *)&qword_1ED4D9610);
  if ((v8 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9610))
  {
    dword_1ED4D951C = 1058468423;
    __cxa_guard_release(&qword_1ED4D9610);
  }
  v9 = dword_1ED4D951C;
  *(_DWORD *)(a1 + 432) = dword_1ED4D9518;
  *(_DWORD *)(a1 + 436) = v9;
  return a1;
}

void sub_1B29F981C(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F983C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGNikonNLog::Encode::~Encode(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E651CBA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E651CBA0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGNikonNLog::Encode::GetOutput(HGNikonNLog::Encode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (v3)
  {
    (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
    HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
    Input = (HGNode *)*((_QWORD *)this + 51);
  }
  (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, 0.23086, 0.0019239, 0.33333, 0.36444);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 1, *((float *)this + 108), *((float *)this + 109), 0.0, 0.0);
  return *((_QWORD *)this + 52);
}

uint64_t HGPanasonicVLog::Encode::Encode(uint64_t a1, unsigned int a2)
{
  _QWORD *v4;
  HGColorMatrix *v5;
  HgcLogVideo_encode *v6;

  HGNode::HGNode((HGNode *)a1);
  *v4 = off_1E651CDF0;
  v5 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v5);
  *(_QWORD *)(a1 + 408) = v5;
  v6 = (HgcLogVideo_encode *)HGObject::operator new(0x1A0uLL);
  HgcLogVideo_encode::HgcLogVideo_encode(v6);
  *(_QWORD *)(a1 + 416) = v6;
  *(_QWORD *)(a1 + 424) = (char *)&HGPanasonicVLog::Encode::sourceToVGamut + 64 * (unint64_t)a2;
  return a1;
}

void sub_1B29F9A58(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F9A78(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPanasonicVLog::Encode::~Encode(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E651CDF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E651CDF0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGPanasonicVLog::Encode::GetOutput(HGPanasonicVLog::Encode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;
  unsigned __int8 v5;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  v5 = atomic_load((unsigned __int8 *)qword_1ED4D9618);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(qword_1ED4D9618))
  {
    dword_1ED4D9520 = 1033168202;
    __cxa_guard_release(qword_1ED4D9618);
  }
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, *((_QWORD *)this + 51));
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, 0.9, 0.00873, *(float *)&dword_1ED4D9520, 0.59821);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 1, 5.04, 0.125, 0.011111, 0.0);
  return *((_QWORD *)this + 52);
}

uint64_t HGSonySLog3::Encode::Encode(uint64_t a1, unsigned int a2, int a3, __int32 a4)
{
  _QWORD *v8;
  HGColorMatrix *v9;
  HgcLogVideo_encode *v10;
  int32x4_t v11;
  int32x4_t v12;
  unint64_t v13;
  char *v14;
  char *v15;

  HGNode::HGNode((HGNode *)a1);
  *v8 = off_1E651D040;
  v9 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v9);
  *(_QWORD *)(a1 + 408) = v9;
  v10 = (HgcLogVideo_encode *)HGObject::operator new(0x1A0uLL);
  HgcLogVideo_encode::HgcLogVideo_encode(v10);
  v13 = (unint64_t)a2 << 6;
  v14 = (char *)&HGSonySLog3::Encode::sourceToSGamut3 + v13;
  v15 = (char *)&HGSonySLog3::Encode::sourceToSGamut3Cine + v13;
  if (!a3)
    v15 = v14;
  *(_QWORD *)(a1 + 416) = v10;
  *(_QWORD *)(a1 + 424) = v15;
  v11.i64[0] = 0x3D57943600000001;
  *(_QWORD *)(a1 + 432) = 0x3D57943640979436;
  v12.i32[0] = a4;
  *(int8x16_t *)(a1 + 440) = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v12, v11), 0), (int8x16_t)xmmword_1B309D100, (int8x16_t)xmmword_1B309D0F0);
  return a1;
}

void sub_1B29F9D34(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F9D54(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSonySLog3::Encode::~Encode(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E651D040;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_1E651D040;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 52);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode(this);
  HGObject::operator delete(v4);
}

uint64_t HGSonySLog3::Encode::GetOutput(HGSonySLog3::Encode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  HGColorMatrix::LoadMatrix(*((_OWORD **)this + 51), *((_OWORD **)this + 53), 1);
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, *((_QWORD *)this + 51));
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, *((float *)this + 108), *((float *)this + 109), *((float *)this + 110), *((float *)this + 111));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 1, *((float *)this + 112), *((float *)this + 113), 0.0125, 0.0);
  return *((_QWORD *)this + 52);
}

void HGSony709_800_MLUT::HGSony709_800_MLUT(HGSony709_800_MLUT *this)
{
  _QWORD *v2;
  HgcSony709_800_MLUT *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E651D290;
  v3 = (HgcSony709_800_MLUT *)HGObject::operator new(0x1A0uLL);
  HgcSony709_800_MLUT::HgcSony709_800_MLUT(v3);
  *((_QWORD *)this + 51) = v3;
}

void sub_1B29F9F28(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B29F9F44(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSony709_800_MLUT::~HGSony709_800_MLUT(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651D290;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651D290;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGSony709_800_MLUT::GetOutput(HGSony709_800_MLUT *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 0, 0.0066667, 0.018, 0.379, 0.0);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 1, 4.5, 1.099, -0.099, 0.45);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), 2, 0.125, 1.09, 28.966, 0.0);
  return *((_QWORD *)this + 51);
}

void HGCameraLogEncode::HGCameraLogEncode(HGNode *a1, int a2)
{
  uint64_t v3;

  HGNode::HGNode(a1);
  *(_QWORD *)v3 = off_1E651D4E0;
  *(_QWORD *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 416) = a2;
}

void HGCameraLogEncode::~HGCameraLogEncode(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651D4E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651D4E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

HGNode *HGCameraLogEncode::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HGNode *v4;
  HgcLogVideo_encode *v5;

  Input = HGRenderer::GetInput(a2, this, 0);
  *((_QWORD *)this + 51) = Input;
  switch(*((_DWORD *)this + 104))
  {
    case 1:
      v4 = (HGNode *)HGObject::operator new(0x1C0uLL);
      HGCanonLog2CinemaGamut::Encode::Encode((uint64_t)v4, 1u, 0);
      goto LABEL_12;
    case 2:
      v4 = (HGNode *)HGObject::operator new(0x1C0uLL);
      HGCanonLog2CinemaGamut::Encode::Encode((uint64_t)v4, 1u, 1);
      goto LABEL_12;
    case 3:
      v4 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGDJIDLog::Encode::Encode((uint64_t)v4, 1u);
      goto LABEL_12;
    case 4:
      v4 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGNode::HGNode(v4);
      *(_QWORD *)v4 = off_1E651C950;
      *((_QWORD *)v4 + 51) = 0;
      v5 = (HgcLogVideo_encode *)HGObject::operator new(0x1A0uLL);
      HgcLogVideo_encode::HgcLogVideo_encode(v5);
      *((_QWORD *)v4 + 52) = v5;
      *((_QWORD *)v4 + 53) = 0;
      goto LABEL_13;
    case 5:
      v4 = (HGNode *)HGObject::operator new(0x1C0uLL);
      HGNikonNLog::Encode::Encode((uint64_t)v4, 1);
      goto LABEL_12;
    case 6:
      v4 = (HGNode *)HGObject::operator new(0x1B0uLL);
      HGPanasonicVLog::Encode::Encode((uint64_t)v4, 1u);
      goto LABEL_12;
    case 7:
      v4 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode((uint64_t)v4, 1u, 0, 1);
      goto LABEL_12;
    case 8:
      v4 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode((uint64_t)v4, 1u, 0, 0);
      goto LABEL_12;
    case 9:
      v4 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode((uint64_t)v4, 1u, 1, 1);
      goto LABEL_12;
    case 0xA:
      v4 = (HGNode *)HGObject::operator new(0x1D0uLL);
      HGSonySLog3::Encode::Encode((uint64_t)v4, 1u, 1, 0);
LABEL_12:
      if (v4)
      {
LABEL_13:
        (*(void (**)(HGNode *, _QWORD, _QWORD))(*(_QWORD *)v4 + 120))(v4, 0, *((_QWORD *)this + 51));
        *((_QWORD *)this + 51) = v4;
        return v4;
      }
      else
      {
        Input = (HGNode *)*((_QWORD *)this + 51);
LABEL_15:
        (*(void (**)(HGNode *))(*(_QWORD *)Input + 16))(Input);
        return (HGNode *)*((_QWORD *)this + 51);
      }
    default:
      goto LABEL_15;
  }
}

void sub_1B29FA37C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA390(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA3A4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA3B8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA3CC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA3E0(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA3F4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA408(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;
  void *v4;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  HGObject::operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1B29FA430(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA444(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FA458(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGComicBilateralFilter::HGComicBilateralFilter(HGComicBilateralFilter *this)
{
  uint64_t v1;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v1 = off_1E651D940;
  *(_OWORD *)(v1 + 408) = xmmword_1B3051560;
  *(_DWORD *)(v1 + 424) = 1065353216;
  *(_DWORD *)(v1 + 16) |= 0x620u;
}

void HGComicBilateralFilter::~HGComicBilateralFilter(HGNode *this)
{
  void *v1;

  HGNode::~HGNode(this);
  HGObject::operator delete(v1);
}

uint64_t HGComicBilateralFilter::SetParameter(HGComicBilateralFilter *this, int a2, float a3, float a4, float a5, float a6)
{
  float v6;
  float v8;

  if (a2 == 2)
  {
    if (*((float *)this + 106) != a3)
    {
      *((float *)this + 106) = a3;
      return 1;
    }
    return 0;
  }
  if (a2 != 1)
  {
    if (a2)
      return 0xFFFFFFFFLL;
    if (*((float *)this + 102) != a3)
    {
      *((float *)this + 102) = a3;
      v6 = *((float *)this + 103);
      goto LABEL_13;
    }
    v6 = *((float *)this + 103);
    if (v6 != a4)
    {
LABEL_13:
      if (v6 != a4)
      {
        *((float *)this + 103) = a4;
        return 1;
      }
      return 1;
    }
    return 0;
  }
  if (*((float *)this + 104) == a3)
  {
    v8 = *((float *)this + 105);
    if (v8 != a4)
      goto LABEL_16;
    return 0;
  }
  *((float *)this + 104) = a3;
  v8 = *((float *)this + 105);
LABEL_16:
  if (v8 == a4)
    return 1;
  *((float *)this + 105) = a4;
  return 1;
}

uint64_t HGComicBilateralFilter::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicBilateralFilter::GetDOD(HGComicBilateralFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t DOD;
  double v6;
  const HGTransform *v7;
  uint64_t v8;
  HGTransformUtils *v9;
  float v10;
  _BYTE v12[144];
  HGRect v13;
  HGRect v14;

  v13 = a4;
  if (a3)
    return 0;
  if (HGRect::IsInfinite(&v13))
    return *(_QWORD *)&v13.var0;
  v6 = *((float *)this + 106);
  HGTransform::HGTransform((HGTransform *)v12);
  HGTransform::Scale((HGTransform *)v12, v6, v6, 1.0);
  v7 = *(const HGTransform **)&v13.var0;
  v8 = *(_QWORD *)&v13.var2;
  v10 = HGTransformUtils::MinW(v9);
  *(_QWORD *)&v14.var0 = v8;
  DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v12, v7, v14, 0.5, v10);
  HGTransform::~HGTransform((HGTransform *)v12);
  return DOD;
}

void sub_1B29FA634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29FA648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGComicBilateralFilter::GetROI(HGComicBilateralFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  unint64_t v5;
  double v7;
  HGTransformUtils *v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v18[144];
  HGRect v19;
  HGRect v20;
  HGRect v21;
  HGRect v22;
  HGRect v23;

  v4 = *(_QWORD *)&a4.var2;
  v5 = *(_QWORD *)&a4.var0;
  if (a3 == 1)
  {
    v19 = a4;
    v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v16 = v15;
    *(_QWORD *)&v22.var0 = v14;
    *(_QWORD *)&v22.var2 = v16;
    HGRect::Grow(&v19, v22);
  }
  else if (a3)
  {
    v19 = (HGRect)HGRectNull;
  }
  else
  {
    v7 = 1.0 / *((float *)this + 106);
    HGTransform::HGTransform((HGTransform *)v18);
    HGTransform::Scale((HGTransform *)v18, v7, v7, 1.0);
    *(_QWORD *)&v19.var0 = 0;
    *(_QWORD *)&v19.var2 = 0;
    v9 = HGTransformUtils::MinW(v8);
    *(_QWORD *)&v23.var0 = v4;
    *(_QWORD *)&v19.var0 = HGTransformUtils::GetROI((HGTransformUtils *)v18, v5, v23, 0.5, v9);
    *(_QWORD *)&v19.var2 = *(_QWORD *)&v20.var0;
    LODWORD(v10) = vcvtps_s32_f32(*((float *)this + 102) + *((float *)this + 102));
    *(_QWORD *)&v20.var2 = v10 | (v10 << 32);
    v20.var0 = -(int)v10;
    v20.var1 = -(int)v10;
    HGRect::Grow(&v19, v20);
    v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    v13 = v12;
    *(_QWORD *)&v21.var0 = v11;
    *(_QWORD *)&v21.var2 = v13;
    HGRect::Grow(&v19, v21);
    HGTransform::~HGTransform((HGTransform *)v18);
  }
  return *(_QWORD *)&v19.var0;
}

void sub_1B29FA790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29FA7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void sub_1B29FA7B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGComicBilateralFilter::RenderTile(HGComicBilateralFilter *this, HGTile *a2)
{
  float v4;
  float v6;
  uint64_t v7;
  int v8;
  float32x4_t v9;
  __int128 v10;
  int32x2_t v11;
  uint64_t v12;
  int v13;
  int v14;
  float32x4_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;
  float32x4_t v26;
  uint64_t v27;
  float32x4_t v28;
  float32x4_t v29;
  uint64_t v30;
  uint64_t v31;
  float32x4_t v32;
  int32x4_t v33;
  float32x2_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int32x4_t v40;
  float32x4_t v41;
  uint64_t v42;
  uint64_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x2_t v46;
  float32x4_t *v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  int8x16_t v57;
  float32x4_t v58;
  int8x16_t v59;
  float32x4_t v60;
  float v61;
  uint64_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  float32x4_t v66;
  int32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int8x16_t v71;
  int8x16_t v72;
  float v73;
  int32x2_t v74;
  int32x2_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int32x4_t v78;
  float32x2_t v79;
  float32x4_t *v80;
  float32x4_t v81;
  float32x4_t v82;
  int32x4_t v83;
  float32x4_t *v84;
  float32x4_t v85;
  int v86;
  float32x4_t v87;
  float v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float v96;
  float v97;
  __int128 v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;

  v4 = *((float *)this + 105);
  if (*((float *)this + 104) == 1.0)
  {
    if (v4 == 1.0)
      return 0xFFFFFFFFLL;
  }
  else if (v4 != 1.0)
  {
    return 0xFFFFFFFFLL;
  }
  v6 = *((float *)this + 106);
  v7 = HGTile::Renderer(a2);
  v8 = (*(uint64_t (**)(HGComicBilateralFilter *, uint64_t))(*(_QWORD *)this + 312))(this, v7);
  v11 = *(int32x2_t *)a2;
  v86 = *((_DWORD *)a2 + 3) - HIDWORD(*(_QWORD *)a2);
  if (v86 >= 1)
  {
    v12 = (*((_DWORD *)a2 + 2) - v11.i32[0]);
    if ((int)v12 >= 1)
    {
      v13 = v8;
      v14 = 0;
      *(float32x2_t *)v15.f32 = vadd_f32(vcvt_f32_s32(v11), (float32x2_t)0x3F0000003F000000);
      v15.i64[1] = 0x3F80000000000000;
      v16 = *((float *)this + 102);
      v17 = v16 + v16;
      v18 = 1.0 / (float)(v16 * (float)(v16 + v16));
      v19 = 1.0 / (float)(*((float *)this + 103) * (float)(*((float *)this + 103) + *((float *)this + 103)));
      v20 = *((_QWORD *)a2 + 2);
      __asm { FMOV            V0.4S, #1.0 }
      v89 = _Q0;
      v88 = 1.0 / v6;
      v26 = v15;
      v91 = v15;
      do
      {
        v27 = 0;
        v87 = v26;
        v28 = v26;
        do
        {
          v30 = *((_QWORD *)a2 + 12);
          v31 = *((int *)a2 + 26);
          v32 = vsubq_f32(v28, v15);
          v90 = v28;
          if (v13)
          {
            v33 = vaddq_s32(vcvtq_s32_f32(v32), vcltzq_f32(v32));
            v34 = (float32x2_t)vsubq_f32(v32, vcvtq_f32_s32(v33)).u64[0];
            v35 = (float32x4_t *)(v30 + 16 * (v33.i32[0] + v33.i32[1] * (int)v31));
            v36 = vaddq_f32(*v35, vmulq_n_f32(vsubq_f32(v35[1], *v35), v34.f32[0]));
            v37 = (int8x16_t)vaddq_f32(v36, vmulq_lane_f32(vsubq_f32(vaddq_f32(v35[v31], vmulq_n_f32(vsubq_f32(v35[(int)v31 + 1], v35[v31]), v34.f32[0])), v36), v34, 1));
          }
          else
          {
            v38.i64[0] = 0x3F0000003F000000;
            v38.i64[1] = 0x3F0000003F000000;
            v39 = vaddq_f32(v32, v38);
            v40 = vcvtq_s32_f32(v39);
            v39.i64[0] = vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)).u64[0];
            v37 = *(int8x16_t *)(v30 + 16 * (v39.i32[0] + v39.i32[1] * (int)v31));
          }
          v41 = vmulq_n_f32(v90, v88);
          v42 = *((_QWORD *)a2 + 10);
          v43 = *((int *)a2 + 22);
          v44 = vsubq_f32(v41, v15);
          if (v13)
          {
            v45 = vaddq_s32(vcvtq_s32_f32(v44), vcltzq_f32(v44));
            v46 = (float32x2_t)vsubq_f32(v44, vcvtq_f32_s32(v45)).u64[0];
            v47 = (float32x4_t *)(v42 + 16 * (v45.i32[0] + v45.i32[1] * (int)v43));
            v48 = vaddq_f32(*v47, vmulq_n_f32(vsubq_f32(v47[1], *v47), v46.f32[0]));
            v49 = v47[v43];
            v9 = vmulq_n_f32(vsubq_f32(v47[(int)v43 + 1], v49), v46.f32[0]);
            v94 = vaddq_f32(v48, vmulq_lane_f32(vsubq_f32(vaddq_f32(v49, v9), v48), v46, 1));
            v50 = v94;
            v51 = v89;
            if (v17 < 1.0)
              goto LABEL_10;
          }
          else
          {
            v52.i64[0] = 0x3F0000003F000000;
            v52.i64[1] = 0x3F0000003F000000;
            v53 = vaddq_f32(v44, v52);
            v54 = vcvtq_s32_f32(v53);
            v53.i64[0] = vaddq_s32(v54, vcgtq_f32(vcvtq_f32_s32(v54), v53)).u64[0];
            v94 = *(float32x4_t *)(v42 + 16 * (v53.i32[0] + v53.i32[1] * (int)v43));
            v50 = v94;
            v51 = v89;
            if (v17 < 1.0)
              goto LABEL_10;
          }
          v55 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 1);
          v51.i32[0] = 0;
          v56 = v37;
          v56.i32[1] = 0;
          v57 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v51, v55), (int8x16_t)vcgeq_f32(v55, v51))), 0), v56, v37);
          v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 2);
          v59 = v57;
          v59.i32[2] = 0;
          v60 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v51, v58), (int8x16_t)vcgeq_f32(v58, v51))), 0), v59, v57);
          v58.i32[0] = *((_DWORD *)this + 104);
          *(float *)v59.i32 = vmuls_lane_f32(v58.f32[0], v60, 2);
          v61 = *((float *)this + 105);
          v9.f32[0] = vmuls_lane_f32(v61, *(float32x2_t *)v60.f32, 1);
          v9.f32[0] = (float)((float)(*(float *)v59.i32 + v9.f32[0]) + (float)(*(float *)v59.i32 + v9.f32[0])) + -1.0;
          *(float *)v59.i32 = vmuls_lane_f32(v58.f32[0], *(float32x2_t *)v60.f32, 1);
          v60.f32[0] = vmuls_lane_f32(v61, v60, 2);
          v9.f32[1] = (float)(v61 - v58.f32[0])
                    * (float)((float)((float)(*(float *)v59.i32 + v60.f32[0]) + (float)(*(float *)v59.i32 + v60.f32[0]))
                            + -1.0);
          v92 = v9;
          v93 = v41;
          v62 = (int)v43 + 1;
          LODWORD(v10) = 1.0;
          v51 = v89;
          v50 = v94;
          do
          {
            v76 = (float32x4_t)vmulq_n_f32(v92, *(float *)&v10).u64[0];
            v77 = vsubq_f32(vaddq_f32(v41, (float32x4_t)v76.u64[0]), v15);
            v99 = v51;
            v100 = v50;
            if (v13)
            {
              v78 = vaddq_s32(vcvtq_s32_f32(v77), vcltzq_f32(v77));
              v79 = (float32x2_t)vsubq_f32(v77, vcvtq_f32_s32(v78)).u64[0];
              v80 = (float32x4_t *)(v42 + 16 * (v78.i32[0] + v78.i32[1] * (int)v43));
              v81 = vaddq_f32(*v80, vmulq_n_f32(vsubq_f32(v80[1], *v80), v79.f32[0]));
              v102 = vaddq_f32(v81, vmulq_lane_f32(vsubq_f32(vaddq_f32(v80[v43], vmulq_n_f32(vsubq_f32(v80[v62], v80[v43]), v79.f32[0])), v81), v79, 1));
              v82 = vsubq_f32(vsubq_f32(v41, v76), v15);
              v83 = vaddq_s32(vcvtq_s32_f32(v82), vcltzq_f32(v82));
              v82.i64[0] = vsubq_f32(v82, vcvtq_f32_s32(v83)).u64[0];
              v84 = (float32x4_t *)(v42 + 16 * (v83.i32[0] + v83.i32[1] * (int)v43));
              v85 = vaddq_f32(*v84, vmulq_n_f32(vsubq_f32(v84[1], *v84), v82.f32[0]));
              v68 = vaddq_f32(v85, vmulq_lane_f32(vsubq_f32(vaddq_f32(v84[v43], vmulq_n_f32(vsubq_f32(v84[v62], v84[v43]), v82.f32[0])), v85), *(float32x2_t *)v82.f32, 1));
            }
            else
            {
              v63.i64[0] = 0x3F0000003F000000;
              v63.i64[1] = 0x3F0000003F000000;
              v64 = vaddq_f32(v77, v63);
              v65 = vcvtq_s32_f32(v64);
              v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
              v102 = *(float32x4_t *)(v42 + 16 * (v64.i32[0] + v64.i32[1] * (int)v43));
              v66 = vaddq_f32(vsubq_f32(vsubq_f32(v41, v76), v15), v63);
              v67 = vcvtq_s32_f32(v66);
              v66.i64[0] = vaddq_s32(v67, vcgtq_f32(vcvtq_f32_s32(v67), v66)).u64[0];
              v68 = *(float32x4_t *)(v42 + 16 * (v66.i32[0] + v66.i32[1] * (int)v43));
            }
            v101 = v68;
            v98 = v10;
            v97 = expf(v18 * (float)-(float)(*(float *)&v10 * *(float *)&v10));
            v69 = vsubq_f32(v102, v94);
            v70 = vsubq_f32(v101, v94);
            v71 = (int8x16_t)vmulq_f32(v69, v69);
            v72 = (int8x16_t)vmulq_f32(v70, v70);
            v73 = vaddv_f32(vadd_f32(*(float32x2_t *)v72.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL)));
            *(float *)v74.i32 = expf(-(float)(vaddv_f32(vadd_f32(*(float32x2_t *)v71.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL)))* v19));
            v96 = *(float *)v74.i32;
            v95 = (float32x4_t)vdupq_lane_s32(v74, 0);
            *(float *)v75.i32 = expf(-(float)(v73 * v19));
            v10 = v98;
            v51 = vaddq_f32(v99, vmulq_n_f32(vaddq_f32(v95, (float32x4_t)vdupq_lane_s32(v75, 0)), v97));
            v9.i64[1] = v101.i64[1];
            v50 = vaddq_f32(v100, vmulq_n_f32(vaddq_f32(vmulq_n_f32(v102, v96), vmulq_n_f32(v101, *(float *)v75.i32)), v97));
            *(float *)&v10 = *(float *)&v98 + 1.0;
            v15 = v91;
            v41 = v93;
          }
          while ((float)(*(float *)&v98 + 1.0) <= v17);
LABEL_10:
          v29 = vdivq_f32(v50, v51);
          v29.i32[3] = v94.i32[3];
          *(float32x4_t *)(v20 + 16 * v27) = vmaxnmq_f32(vminnmq_f32(v29, v89), (float32x4_t)0);
          v28 = vaddq_f32(v90, (float32x4_t)xmmword_1B304F230);
          ++v27;
        }
        while (v27 != v12);
        v26 = vaddq_f32(v87, (float32x4_t)xmmword_1B304F240);
        v20 += 16 * *((int *)a2 + 6);
        ++v14;
      }
      while (v14 != v86);
    }
  }
  return 0;
}

HGComicBilateralFilter *HGComicBilateralFilter::GetOutput(HGComicBilateralFilter *this, HGRenderer *a2, char *a3)
{
  char *v4;

  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), *((float *)this + 103), 0.0, 0.0, a3);
  HGNode::SetParameter((HGNode *)this, 1, *((float *)this + 104), *((float *)this + 105), 0.0, 0.0, v4);
  return this;
}

const char *HGComicBilateralFilter::GetProgram(HGComicBilateralFilter *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F)
    return "//Metal1.0     \n"
           "//LEN=00000009bb\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >     hg_Texture0 [[ texture(0) ]],\n"
           "                                  texture2d< half >     hg_Texture1 [[ texture(1) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const half sigmacolor {static_cast<half>(hg_Params[0].y)};\n"
           "    const half xAxis {static_cast<half>(hg_Params[1].x)};\n"
           "    const half yAxis {static_cast<half>(hg_Params[1].y)};\n"
           "    \n"
           "    const half sigma22 {1.0h / (2.0h * sigma * sigma)};\n"
           "    const half sigmacolor22 {1.0h / (2.0h * sigmacolor * sigmacolor)};\n"
           "    const half sigmax2 {2.0h * sigma};\n"
           "\n"
           "    half2 gradient = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).yz;\n"
           "    gradient = \n"
           "        half2( (gradient.y * xAxis + gradient.x * yAxis) * 2.0h - 1.0h,\n"
           "             ((gradient.x * xAxis + gradient.y * yAxis) * 2.0h - 1.0h) *\n"
           "               (-1.0h * xAxis + 1.0h * yAxis));\n"
           "    \n"
           "    const half alpha = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).a;\n"
           "    const half3 current = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).rgb;\n"
           "    half3 acc = current;\n"
           "    half norm {1.0h};\n"
           "\n"
           "    for (half i {1.0h}; i <= sigmax2; i += 1.0h)\n"
           "    {\n"
           "        const float2 uPos = frag._texCoord0.xy + float2(i * gradient);\n"
           "        const float2 uNeg = frag._texCoord0.xy - float2(i * gradient);\n"
           "        \n"
           "        const half3 right = hg_Texture0.sample(hg_Sampler0, uPos).rgb;\n"
           "        const half3 left = hg_Texture0.sample(hg_Sampler0, uNeg).rgb;\n"
           "\n"
           "        const half coeff = exp(-i * i * sigma22);\n"
           "        const half coeffr = exp(-dot((right - current), (right - current)) * sigmacolor22);\n"
           "        const half coeffl = exp(-dot((left - current), (left - current)) * sigmacolor22);\n"
           "\n"
           "        norm += coeff * (coeffr + coeffl);\n"
           "        acc += coeff * (coeffr * right+coeffl * left);\n"
           "    }\n"
           "    \n"
           "    acc = acc / norm;\n"
           "    \n"
           "    FragmentOut out {float4(float3(acc), alpha)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "    \n"
           "    return out;\n"
           " }\n"
           "//MD5=63de27e4:0c23b7b0:cc01e232:e534b9f2\n"
           "//SIG=00000000:00000000:00000000:00000003:0010:0002:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
    return "//GLfs1.0      \n"
           "//LEN=0000000898\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           "\n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           "uniform defaultp sampler2DRect hg_Texture0;\n"
           "uniform defaultp sampler2DRect hg_Texture1;\n"
           "\n"
           "uniform highp vec4 hg_ProgramLocal0;
           "uniform highp vec4 hg_ProgramLocal1;
           "\n"
           "void main (void) \n"
           "{\n"
           "    float sigma = hg_ProgramLocal0.x;\n"
           "    float sigmacolor = hg_ProgramLocal0.y;\n"
           "    float xAxis = hg_ProgramLocal1.x;\n"
           "    float yAxis = hg_ProgramLocal1.y;\n"
           "    \n"
           "    float sigma22 = 1.0 / (2.0 * sigma  * sigma);\n"
           "    float sigmacolor22 = 1.0 / (2.0 * sigmacolor * sigmacolor);\n"
           "    float sigmax2 = 2.0 * sigma;\n"
           "    \n"
           "    float alpha = texture2DRect(hg_Texture0, gl_TexCoord[0].xy).a;\n"
           "    vec3 current = texture2DRect(hg_Texture0, gl_TexCoord[0].xy).rgb;\n"
           "    vec3 acc = current;\n"
           "    float norm = 1.0;\n"
           "    \n"
           "    vec2 gradient = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).yz;\n"
           "    gradient = \n"
           "        vec2( (gradient.y * xAxis + gradient.x * yAxis)*2.0 - 1.0,\n"
           "             ((gradient.x * xAxis + gradient.y * yAxis)*2.0 - 1.0) * \n"
           "             (-1.0 * xAxis + 1.0 * yAxis));\n"
           "\n"
           "    for (float i = 1.0; i <= sigmax2; i += 1.0) \n"
           "    {\n"
           "        vec2 uPos = gl_TexCoord[0].xy + i * gradient;\n"
           "        vec2 uNeg = gl_TexCoord[0].xy - i * gradient;\n"
           "        \n"
           "        vec3 right = texture2DRect(hg_Texture0, uPos).rgb;\n"
           "        vec3 left = texture2DRect(hg_Texture0, uNeg).rgb;\n"
           "\n"
           "        float coeff = exp( -i * i * sigma22);\n"
           "        float coeffr = exp( -dot((right - current), (right - current)) * sigmacolor22); //(ri-cun).r*(rig-cu)"
           ".r + (ri-cu).g*(ri-cur).g ... = dist*dist\n"
           "        float coeffl = exp( -dot((left - current), (left - current)) * sigmacolor22);\n"
           "\n"
           "        norm += coeff * (coeffr + coeffl);\n"
           "        acc += coeff * (coeffr * right+coeffl * left);\n"
           "    }\n"
           "    \n"
           "    acc = acc / norm;\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4(acc, alpha), 0.0, 1.0);\n"
           " }\n"
           "//MD5=26dc515d:0940174b:2c779b1c:584e541e\n"
           "//SIG=00000000:00000000:00000000:00000000:0020:0002:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicBilateralFilter::BindTexture(HGComicBilateralFilter *this, HGHandler *a2, uint64_t a3)
{
  float v5;

  if ((_DWORD)a3 == 1)
  {
    HGHandler::TexCoord(a2, 1, 0, 0, 0);
  }
  else if (!(_DWORD)a3)
  {
    v5 = 1.0 / *((float *)this + 106);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(_QWORD *)a2 + 104))(a2, v5, v5, 1.0);
  }
  (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, 1, 1);
  return 0;
}

void HRasterizerGenerator::HRasterizerGenerator(HRasterizerGenerator *this)
{
  HgcRasterizerGenerator *v1;
  char *v7;

  HgcRasterizerGenerator::HgcRasterizerGenerator(this);
  *(_QWORD *)v1 = off_1E651DBA8;
  __asm { FMOV            V0.4S, #1.0 }
  *((_OWORD *)v1 + 26) = _Q0;
  HgcRasterizerGenerator::SetParameter(v1, 0, 1.0, 1.0, 1.0, 1.0, v7);
}

void sub_1B29FAF7C(_Unwind_Exception *a1)
{
  HgcRasterizerGenerator *v1;

  HgcRasterizerGenerator::~HgcRasterizerGenerator(v1);
  _Unwind_Resume(a1);
}

void HRasterizerGenerator::~HRasterizerGenerator(HRasterizerGenerator *this)
{
  void *v1;

  HgcRasterizerGenerator::~HgcRasterizerGenerator(this);
  HGObject::operator delete(v1);
}

const HGMetalDeviceInfo *HGGPUResources::getDeviceResources(HGGPUResources *this, const HGMetalDeviceInfo *a2)
{
  const HGMetalDeviceInfo *v2;
  unsigned __int8 v3;
  std::mutex *v4;
  unsigned __int8 v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  _QWORD *v10;
  unsigned __int8 v11;
  HGGPUResources *v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t **v16;
  uint64_t **v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t **v25;
  uint64_t **v26;
  unint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;

  v2 = this;
  if (this)
  {
    v3 = atomic_load((unsigned __int8 *)&qword_1ED4D9668);
    if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9668))
    {
      v32 = operator new();
      *(_QWORD *)v32 = 850045863;
      *(_OWORD *)(v32 + 8) = 0u;
      *(_OWORD *)(v32 + 24) = 0u;
      *(_OWORD *)(v32 + 40) = 0u;
      *(_QWORD *)(v32 + 56) = 0;
      _MergedGlobals_5 = v32;
      __cxa_guard_release(&qword_1ED4D9668);
    }
    v4 = (std::mutex *)_MergedGlobals_5;
    std::mutex::lock((std::mutex *)_MergedGlobals_5);
    v5 = atomic_load((unsigned __int8 *)&qword_1ED4D9678);
    if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9678))
    {
      v33 = (_QWORD *)operator new();
      v33[1] = 0;
      v33[2] = 0;
      *v33 = v33 + 1;
      qword_1ED4D9670 = (uint64_t)v33;
      __cxa_guard_release(&qword_1ED4D9678);
    }
    v6 = *(_QWORD **)(qword_1ED4D9670 + 8);
    if (!v6)
      goto LABEL_15;
    v7 = qword_1ED4D9670 + 8;
    do
    {
      v8 = v6[4];
      v9 = v8 >= (unint64_t)v2;
      if (v8 >= (unint64_t)v2)
        v10 = v6;
      else
        v10 = v6 + 1;
      if (v9)
        v7 = (uint64_t)v6;
      v6 = (_QWORD *)*v10;
    }
    while (*v10);
    if (v7 == qword_1ED4D9670 + 8 || *(_QWORD *)(v7 + 32) > (unint64_t)v2)
LABEL_15:
      v7 = qword_1ED4D9670 + 8;
    v11 = atomic_load((unsigned __int8 *)&qword_1ED4D9678);
    if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9678))
    {
      v34 = (_QWORD *)operator new();
      v34[1] = 0;
      v34[2] = 0;
      *v34 = v34 + 1;
      qword_1ED4D9670 = (uint64_t)v34;
      __cxa_guard_release(&qword_1ED4D9678);
    }
    if (v7 == qword_1ED4D9670 + 8)
    {
      v12 = (HGGPUResources *)HGObject::operator new(0xB0uLL);
      HGGPUResources::HGGPUResources(v12, v2);
      v13 = atomic_load((unsigned __int8 *)&qword_1ED4D9678);
      if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9678))
      {
        v36 = (_QWORD *)operator new();
        v36[1] = 0;
        v36[2] = 0;
        *v36 = v36 + 1;
        qword_1ED4D9670 = (uint64_t)v36;
        __cxa_guard_release(&qword_1ED4D9678);
      }
      v14 = qword_1ED4D9670;
      v16 = (uint64_t **)(qword_1ED4D9670 + 8);
      v15 = *(uint64_t **)(qword_1ED4D9670 + 8);
      if (v15)
      {
        while (1)
        {
          while (1)
          {
            v17 = (uint64_t **)v15;
            v18 = v15[4];
            if (v18 <= (unint64_t)v2)
              break;
            v15 = *v17;
            v16 = v17;
            if (!*v17)
              goto LABEL_26;
          }
          if (v18 >= (unint64_t)v2)
            break;
          v15 = v17[1];
          if (!v15)
          {
            v16 = v17 + 1;
            goto LABEL_26;
          }
        }
        v19 = (uint64_t *)v17;
      }
      else
      {
        v17 = (uint64_t **)(qword_1ED4D9670 + 8);
LABEL_26:
        v19 = (uint64_t *)operator new(0x30uLL);
        v19[4] = (uint64_t)v2;
        v19[5] = 0;
        *v19 = 0;
        v19[1] = 0;
        v19[2] = (uint64_t)v17;
        *v16 = v19;
        v20 = **(_QWORD **)v14;
        v21 = v19;
        if (v20)
        {
          *(_QWORD *)v14 = v20;
          v21 = *v16;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v14 + 8), v21);
        ++*(_QWORD *)(v14 + 16);
      }
      v19[5] = (uint64_t)v12;
    }
    v22 = atomic_load((unsigned __int8 *)&qword_1ED4D9678);
    if ((v22 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9678))
    {
      v35 = (_QWORD *)operator new();
      v35[1] = 0;
      v35[2] = 0;
      *v35 = v35 + 1;
      qword_1ED4D9670 = (uint64_t)v35;
      __cxa_guard_release(&qword_1ED4D9678);
    }
    v23 = qword_1ED4D9670;
    v25 = (uint64_t **)(qword_1ED4D9670 + 8);
    v24 = *(uint64_t **)(qword_1ED4D9670 + 8);
    if (v24)
    {
      while (1)
      {
        while (1)
        {
          v26 = (uint64_t **)v24;
          v27 = v24[4];
          if (v27 <= (unint64_t)v2)
            break;
          v24 = *v26;
          v25 = v26;
          if (!*v26)
            goto LABEL_39;
        }
        if (v27 >= (unint64_t)v2)
          break;
        v24 = v26[1];
        if (!v24)
        {
          v25 = v26 + 1;
          goto LABEL_39;
        }
      }
      v28 = (uint64_t *)v26;
    }
    else
    {
      v26 = (uint64_t **)(qword_1ED4D9670 + 8);
LABEL_39:
      v28 = (uint64_t *)operator new(0x30uLL);
      v28[4] = (uint64_t)v2;
      v28[5] = 0;
      *v28 = 0;
      v28[1] = 0;
      v28[2] = (uint64_t)v26;
      *v25 = v28;
      v29 = **(_QWORD **)v23;
      v30 = v28;
      if (v29)
      {
        *(_QWORD *)v23 = v29;
        v30 = *v25;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v23 + 8), v30);
      ++*(_QWORD *)(v23 + 16);
    }
    v2 = (const HGMetalDeviceInfo *)v28[5];
    std::mutex::unlock(v4);
  }
  return v2;
}

void sub_1B29FB378(_Unwind_Exception *a1)
{
  std::mutex *v1;

  __cxa_guard_abort(&qword_1ED4D9678);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FB3A4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4D9668);
  _Unwind_Resume(a1);
}

void sub_1B29FB3BC(_Unwind_Exception *a1)
{
  std::mutex *v1;
  void *v2;

  HGObject::operator delete(v2);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FB3D8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGGPUResources::HGGPUResources(HGGPUResources *this, const HGMetalDeviceInfo *a2)
{
  uint64_t v4;
  HGCVPixelBufferPool **v5;
  uint64_t *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  HGCVPixelBufferPool *v10;
  std::string *v11;
  __int128 v12;
  uint64_t v13;
  std::string *v14;
  __int128 v15;
  uint64_t v16;
  std::string *v17;
  __int128 v18;
  uint64_t v19;
  std::string *v20;
  __int128 v21;
  uint64_t v22;
  std::string *v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  _QWORD *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *size;
  unint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  _QWORD *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  __int128 v45;
  unint64_t v46;
  uint64_t v47;
  std::string v48;
  _QWORD v49[2];
  _QWORD v50[11];
  char v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _BYTE v57[32];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  unint64_t v61;

  HGObject::HGObject(this);
  *(_QWORD *)v4 = off_1E651DE20;
  *(_OWORD *)(v4 + 24) = 0u;
  v5 = (HGCVPixelBufferPool **)(v4 + 24);
  *(_QWORD *)(v4 + 16) = a2;
  *(_QWORD *)(v4 + 64) = 850045863;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_QWORD *)(v4 + 56) = 0;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_DWORD *)(v4 + 136) = 1065353216;
  *(_OWORD *)(v4 + 144) = 0u;
  v6 = (uint64_t *)(v4 + 144);
  *(_OWORD *)(v4 + 160) = 0u;
  v7 = *((_QWORD *)a2 + 2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v49);
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)"(device:0x", 10);
  *(_DWORD *)((char *)v8 + *(_QWORD *)(*v8 - 24) + 8) = *(_DWORD *)((_BYTE *)v8 + *(_QWORD *)(*v8 - 24) + 8) & 0xFFFFFFB5 | 8;
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)")", 1);
  v10 = (HGCVPixelBufferPool *)HGObject::operator new(0x18uLL);
  HGCVPixelBufferPool::HGCVPixelBufferPool(v10);
  *v5 = v10;
  std::stringbuf::str();
  v11 = std::string::insert(&v48, 0, "HGCV pool ");
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  *(_QWORD *)&v54 = *((_QWORD *)&v11->__r_.__value_.__l + 2);
  v53 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  HGCVPixelBufferPool::setLabel((uint64_t)v10, (const std::string *)&v53);
  if (SBYTE7(v54) < 0)
  {
    operator delete((void *)v53);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v48.__r_.__value_.__l.__data_);
LABEL_3:
  v13 = operator new();
  HGMetalBufferPool::HGMetalBufferPool(v13, v7);
  *((_QWORD *)this + 4) = v13;
  std::stringbuf::str();
  v14 = std::string::insert(&v48, 0, "MTLBuffers pool ");
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  *(_QWORD *)&v54 = *((_QWORD *)&v14->__r_.__value_.__l + 2);
  v53 = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  HGMetalBufferPool::setLabel(v13, (const std::string *)&v53);
  if (SBYTE7(v54) < 0)
  {
    operator delete((void *)v53);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_5;
  }
  else if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(v48.__r_.__value_.__l.__data_);
LABEL_5:
  v16 = operator new();
  HGMetalTexturePool::HGMetalTexturePool(v16, v7);
  *((_QWORD *)this + 5) = v16;
  std::stringbuf::str();
  v17 = std::string::insert(&v48, 0, "MTLTextures pool ");
  v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  *(_QWORD *)&v54 = *((_QWORD *)&v17->__r_.__value_.__l + 2);
  v53 = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  HGMetalBufferPool::setLabel(v16, (const std::string *)&v53);
  if (SBYTE7(v54) < 0)
  {
    operator delete((void *)v53);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_7;
  }
  else if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(v48.__r_.__value_.__l.__data_);
LABEL_7:
  v19 = operator new();
  HGMetalBufferWrapperInfinipool::HGMetalBufferWrapperInfinipool(v19, v7);
  *((_QWORD *)this + 6) = v19;
  std::stringbuf::str();
  v20 = std::string::insert(&v48, 0, "MTLBuffers infinipool ");
  v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  *(_QWORD *)&v54 = *((_QWORD *)&v20->__r_.__value_.__l + 2);
  v53 = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  HGMetalBufferPool::setLabel(v19, (const std::string *)&v53);
  if (SBYTE7(v54) < 0)
  {
    operator delete((void *)v53);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_9;
  }
  else if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v48.__r_.__value_.__l.__data_);
LABEL_9:
  v22 = operator new();
  HGMetalTextureWrapperInfinipool::HGMetalTextureWrapperInfinipool(v22, v7);
  *((_QWORD *)this + 7) = v22;
  std::stringbuf::str();
  v23 = std::string::insert(&v48, 0, "MTLTextures infinipool ");
  v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  *(_QWORD *)&v54 = *((_QWORD *)&v23->__r_.__value_.__l + 2);
  v53 = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  HGMetalBufferPool::setLabel(v22, (const std::string *)&v53);
  if (SBYTE7(v54) < 0)
  {
    operator delete((void *)v53);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_11;
LABEL_43:
    operator delete(v48.__r_.__value_.__l.__data_);
    goto LABEL_11;
  }
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_43;
LABEL_11:
  *((_DWORD *)this + 34) = 1053609165;
  HGGPUResources::forceResetCVTextureCache((std::mutex *)this);
  v25 = operator new();
  HGMetalRenderPipelineStateCache::HGMetalRenderPipelineStateCache(v25, v7);
  *v6 = v25;
  v26 = operator new();
  HGMetalSamplerStateCache::HGMetalSamplerStateCache(v26, v7);
  *((_QWORD *)this + 19) = v26;
  v27 = operator new();
  HGMetalDepthStencilStateCache::HGMetalDepthStencilStateCache(v27, v7);
  *((_QWORD *)this + 20) = v27;
  v28 = operator new();
  HGMetalFunctionCache::HGMetalFunctionCache(v28, v7);
  *((_QWORD *)this + 21) = v28;
  v29 = (uint64_t *)*((_QWORD *)this + 4);
  v30 = operator new(0x20uLL);
  v30[1] = 0;
  v30[2] = 0;
  *v30 = &off_1E651DE70;
  v30[3] = &off_1E651DEC0;
  *(_QWORD *)&v53 = v30 + 3;
  *((_QWORD *)&v53 + 1) = v30;
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = 0uLL;
  HGMetalBufferPool::setAllocationPolicy(v29, (uint64_t *)&v53);
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v53 + 1);
  if (*((_QWORD *)&v53 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v53 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  size = (std::__shared_weak_count *)v48.__r_.__value_.__l.__size_;
  if (v48.__r_.__value_.__l.__size_)
  {
    v35 = (unint64_t *)(v48.__r_.__value_.__l.__size_ + 8);
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  v37 = (uint64_t *)*((_QWORD *)this + 5);
  v38 = operator new(0x20uLL);
  v38[1] = 0;
  v38[2] = 0;
  *v38 = &off_1E651DF10;
  v38[3] = &off_1E651DF60;
  *(_QWORD *)&v53 = v38 + 3;
  *((_QWORD *)&v53 + 1) = v38;
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = 0uLL;
  HGMetalBufferPool::setAllocationPolicy(v37, (uint64_t *)&v53);
  v39 = (std::__shared_weak_count *)*((_QWORD *)&v53 + 1);
  if (*((_QWORD *)&v53 + 1))
  {
    v40 = (unint64_t *)(*((_QWORD *)&v53 + 1) + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v42 = (std::__shared_weak_count *)v48.__r_.__value_.__l.__size_;
  if (v48.__r_.__value_.__l.__size_)
  {
    v43 = (unint64_t *)(v48.__r_.__value_.__l.__size_ + 8);
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  *(_QWORD *)&v45 = -1;
  *((_QWORD *)&v45 + 1) = -1;
  v59 = v45;
  v60 = v45;
  *(_OWORD *)&v57[16] = v45;
  v58 = v45;
  v56 = v45;
  *(_OWORD *)v57 = v45;
  v46 = *(_QWORD *)(*((_QWORD *)this + 2) + 40);
  v54 = v45;
  v55 = xmmword_1B309D5F0;
  *(_OWORD *)&v57[8] = xmmword_1B309D5F0;
  *(_QWORD *)&v53 = 64;
  *((_QWORD *)&v53 + 1) = (unint64_t)(float)((float)v46 * 0.2);
  *(_QWORD *)&v59 = 1000000000;
  *(_QWORD *)&v57[24] = *((_QWORD *)&v53 + 1);
  *(_QWORD *)&v60 = (unint64_t)(float)((float)v46 * 0.25);
  v61 = (unint64_t)(float)((float)v46 * 0.4);
  HGGPUResources::setupGroupTotalUsagePolicies((uint64_t)this, (uint64_t)&v53);
  v49[0] = *MEMORY[0x1E0DE4F50];
  v47 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v49 + *(_QWORD *)(v49[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v50[0] = v47;
  v50[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v51 < 0)
    operator delete((void *)v50[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1B5E290BC](&v52);
}

void sub_1B29FBAD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  HGObject *v15;
  std::mutex *v16;
  uint64_t v17;

  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v17 - 224);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  std::mutex::~mutex(v16);
  HGObject::~HGObject(v15);
  _Unwind_Resume(a1);
}

void HGGPUResources::forceResetCVTextureCache(std::mutex *this)
{
  void *v2;
  CFNumberRef v3;
  void *v4;
  const __CFDictionary *v5;
  uint64_t v6;
  const char *v7;
  char *v8;
  CVMetalTextureCacheRef v9;
  const void *sig;
  CVMetalTextureCacheRef cacheOut;
  int valuePtr;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v2 = *(void **)(*(_QWORD *)&this->__m_.__opaque[8] + 16);
  valuePtr = *(_DWORD *)this[2].__m_.__opaque;
  v3 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  v4 = (void *)*MEMORY[0x1E0CA8F48];
  values = v3;
  keys[0] = v4;
  v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  cacheOut = 0;
  v6 = CVMetalTextureCacheCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, v2, 0, &cacheOut);
  CFRelease(v3);
  CFRelease(v5);
  if ((_DWORD)v6)
    HGLogger::warning((HGLogger *)"could not create CVMetalTextureCache! (%d)\n", v7, v8, v6);
  v9 = cacheOut;
  std::mutex::lock(this + 1);
  sig = (const void *)this[2].__m_.__sig;
  if (sig)
    CFRelease(sig);
  this[2].__m_.__sig = (uint64_t)v9;
  std::mutex::unlock(this + 1);
}

void sub_1B29FBD58(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGGPUResources::~HGGPUResources(std::mutex *this)
{
  this->__m_.__sig = (uint64_t)off_1E651DE20;
  std::mutex::~mutex(this + 1);
  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;

  this->__m_.__sig = (uint64_t)off_1E651DE20;
  std::mutex::~mutex(this + 1);
  HGObject::~HGObject((HGObject *)this);
  HGObject::operator delete(v2);
}

uint64_t HGGPUResources::getCVTextureCacheRetainedRef(HGGPUResources *this)
{
  std::mutex *v2;
  uint64_t v3;

  v2 = (std::mutex *)((char *)this + 64);
  std::mutex::lock((std::mutex *)this + 1);
  CFRetain(*((CFTypeRef *)this + 16));
  v3 = *((_QWORD *)this + 16);
  std::mutex::unlock(v2);
  return v3;
}

void sub_1B29FBE14(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGPUResources::setCVTextureCacheMaximumTextureAge(uint64_t this, float a2)
{
  *(float *)(this + 136) = a2;
  return this;
}

void HGGPUResources::flushFreeObjects(HGGPUResources *this)
{
  HGMetalBufferPool *v2;
  HGMetalTexturePool *v3;
  __CVMetalTextureCache *v4;

  v2 = (HGMetalBufferPool *)*((_QWORD *)this + 4);
  if (v2)
    HGMetalBufferPool::clear(v2);
  v3 = (HGMetalTexturePool *)*((_QWORD *)this + 5);
  if (v3)
    HGMetalTexturePool::clear(v3);
  v4 = (__CVMetalTextureCache *)*((_QWORD *)this + 16);
  if (v4)
    CVMetalTextureCacheFlush(v4, 0);
}

void HGGPUResources::releaseFreeObjects(HGGPUResources *this)
{
  HGCVPixelBufferPool *v2;
  HGMetalBufferPool *v3;
  HGMetalTexturePool *v4;
  HGMetalBufferWrapperInfinipool *v5;
  HGMetalTextureWrapperInfinipool *v6;
  __CVMetalTextureCache *v7;

  v2 = (HGCVPixelBufferPool *)*((_QWORD *)this + 3);
  if (v2)
    HGCVPixelBufferPool::clear(v2);
  v3 = (HGMetalBufferPool *)*((_QWORD *)this + 4);
  if (v3)
    HGMetalBufferPool::clear(v3);
  v4 = (HGMetalTexturePool *)*((_QWORD *)this + 5);
  if (v4)
    HGMetalTexturePool::clear(v4);
  v5 = (HGMetalBufferWrapperInfinipool *)*((_QWORD *)this + 6);
  if (v5)
    HGMetalBufferWrapperInfinipool::clear(v5);
  v6 = (HGMetalTextureWrapperInfinipool *)*((_QWORD *)this + 7);
  if (v6)
    HGMetalTextureWrapperInfinipool::clear(v6);
  v7 = (__CVMetalTextureCache *)*((_QWORD *)this + 16);
  if (v7)
    CVMetalTextureCacheFlush(v7, 0);
}

void HGGPUResources::forceResetAllCVTextureCaches(HGGPUResources *this)
{
  unsigned __int8 v1;
  std::mutex *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  unsigned __int8 v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v1 = atomic_load((unsigned __int8 *)&qword_1ED4D9668);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9668))
  {
    v10 = operator new();
    *(_QWORD *)v10 = 850045863;
    *(_OWORD *)(v10 + 8) = 0u;
    *(_OWORD *)(v10 + 24) = 0u;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_QWORD *)(v10 + 56) = 0;
    _MergedGlobals_5 = v10;
    __cxa_guard_release(&qword_1ED4D9668);
  }
  v2 = (std::mutex *)_MergedGlobals_5;
  std::mutex::lock((std::mutex *)_MergedGlobals_5);
  v3 = atomic_load((unsigned __int8 *)&qword_1ED4D9678);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9678))
  {
    v11 = (_QWORD *)operator new();
    v11[2] = 0;
    v11[1] = 0;
    *v11 = v11 + 1;
    qword_1ED4D9670 = (uint64_t)v11;
    __cxa_guard_release(&qword_1ED4D9678);
  }
  v4 = *(_QWORD **)qword_1ED4D9670;
  v5 = atomic_load((unsigned __int8 *)&qword_1ED4D9678);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9678))
  {
    v12 = (_QWORD *)operator new();
    v12[2] = 0;
    v12[1] = 0;
    *v12 = v12 + 1;
    qword_1ED4D9670 = (uint64_t)v12;
    __cxa_guard_release(&qword_1ED4D9678);
  }
  v6 = qword_1ED4D9670 + 8;
  if (v4 != (_QWORD *)(qword_1ED4D9670 + 8))
  {
    do
    {
      HGGPUResources::forceResetCVTextureCache((std::mutex *)v4[5]);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != (_QWORD *)v6);
  }
  std::mutex::unlock(v2);
}

void sub_1B29FC0A0(_Unwind_Exception *a1)
{
  std::mutex *v1;

  __cxa_guard_abort(&qword_1ED4D9678);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FC0C4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ED4D9668);
  _Unwind_Resume(a1);
}

void sub_1B29FC0DC(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGGPUResources::setupGroupTotalUsagePolicies(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  unint64_t *v5;
  uint64_t v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD *v11;
  uint64_t v12;
  __int128 v13;
  char *v14;
  uint64_t v15;
  uint64_t *LUTEnd;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::mutex **v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::mutex **v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t *v65;
  std::__shared_weak_count *v66;
  uint64_t *v67;
  std::__shared_weak_count *v68;
  uint64_t *v69;
  std::__shared_weak_count *v70;
  uint64_t *v71;
  std::__shared_weak_count *v72;
  char *v73;
  std::__shared_weak_count *v74;

  v4 = operator new(0x48uLL);
  v4[1] = 0;
  v5 = v4 + 1;
  v4[2] = 0;
  *v4 = &unk_1E651DFA0;
  v4[3] = &unk_1E651DFF0;
  v6 = *(_QWORD *)(a2 + 32);
  v7 = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v4 + 2) = *(_OWORD *)a2;
  *((_OWORD *)v4 + 3) = v7;
  v4[8] = v6;
  v73 = (char *)(v4 + 3);
  v74 = (std::__shared_weak_count *)v4;
  v8 = operator new(0x48uLL);
  v8[1] = 0;
  v8[2] = 0;
  *v8 = &unk_1E651DFA0;
  v9 = *(_QWORD *)(a2 + 72);
  v8[3] = &unk_1E651DFF0;
  v10 = *(_OWORD *)(a2 + 56);
  *((_OWORD *)v8 + 2) = *(_OWORD *)(a2 + 40);
  *((_OWORD *)v8 + 3) = v10;
  v8[8] = v9;
  v71 = v8 + 3;
  v72 = (std::__shared_weak_count *)v8;
  v11 = operator new(0x48uLL);
  v11[1] = 0;
  v11[2] = 0;
  *v11 = &unk_1E651DFA0;
  v12 = *(_QWORD *)(a2 + 112);
  v11[3] = &unk_1E651DFF0;
  v13 = *(_OWORD *)(a2 + 96);
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 80);
  *((_OWORD *)v11 + 3) = v13;
  v11[8] = v12;
  v69 = v11 + 3;
  v70 = (std::__shared_weak_count *)v11;
  v14 = (char *)operator new(0x58uLL);
  *((_QWORD *)v14 + 2) = 0;
  *(_QWORD *)v14 = &unk_1E651E060;
  *((_QWORD *)v14 + 1) = 0;
  *((_QWORD *)v14 + 3) = &unk_1E651E0B0;
  v15 = (uint64_t)(v14 + 24);
  *((_QWORD *)v14 + 6) = 0;
  *((_QWORD *)v14 + 5) = 0;
  *((_QWORD *)v14 + 4) = v14 + 40;
  *(_OWORD *)(v14 + 56) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(v14 + 72) = *(_OWORD *)(a2 + 136);
  v67 = (uint64_t *)(v14 + 24);
  v68 = (std::__shared_weak_count *)v14;
  LUTEnd = (uint64_t *)PCICCTransferFunctionLUT::getLUTEnd(*(PCICCTransferFunctionLUT **)(a1 + 24));
  v65 = v4 + 3;
  v66 = (std::__shared_weak_count *)v4;
  do
    v17 = __ldxr(v5);
  while (__stxr(v17 + 1, v5));
  HGPool::GroupServicingPolicy::addPool(v15, LUTEnd, &v65);
  v18 = v66;
  if (v66)
  {
    p_shared_owners = (unint64_t *)&v66->__shared_owners_;
    do
      v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = (uint64_t)v67;
  v22 = **(uint64_t ***)(a1 + 32);
  v65 = v71;
  v66 = v72;
  if (v72)
  {
    v23 = (unint64_t *)&v72->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  HGPool::GroupServicingPolicy::addPool(v21, v22, &v65);
  v25 = v66;
  if (v66)
  {
    v26 = (unint64_t *)&v66->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = (uint64_t)v67;
  v29 = **(uint64_t ***)(a1 + 40);
  v65 = v69;
  v66 = v70;
  if (v70)
  {
    v30 = (unint64_t *)&v70->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  HGPool::GroupServicingPolicy::addPool(v28, v29, &v65);
  v32 = v66;
  if (v66)
  {
    v33 = (unint64_t *)&v66->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = *(_QWORD *)(a1 + 24);
  v65 = v67;
  v66 = v68;
  if (v68)
  {
    v36 = (unint64_t *)&v68->__shared_owners_;
    do
      v37 = __ldxr(v36);
    while (__stxr(v37 + 1, v36));
  }
  HGCVPixelBufferPool::setServicingPolicy(v35, (uint64_t *)&v65);
  v38 = v66;
  if (v66)
  {
    v39 = (unint64_t *)&v66->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v41 = *(std::mutex ***)(a1 + 32);
  v65 = v67;
  v66 = v68;
  if (v68)
  {
    v42 = (unint64_t *)&v68->__shared_owners_;
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
  }
  HGMetalBufferPool::setServicingPolicy(v41, (uint64_t *)&v65);
  v44 = v66;
  if (v66)
  {
    v45 = (unint64_t *)&v66->__shared_owners_;
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  v47 = *(std::mutex ***)(a1 + 40);
  v65 = v67;
  v66 = v68;
  if (v68)
  {
    v48 = (unint64_t *)&v68->__shared_owners_;
    do
      v49 = __ldxr(v48);
    while (__stxr(v49 + 1, v48));
  }
  HGMetalBufferPool::setServicingPolicy(v47, (uint64_t *)&v65);
  v50 = v66;
  if (v66)
  {
    v51 = (unint64_t *)&v66->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  v53 = v68;
  if (v68)
  {
    v54 = (unint64_t *)&v68->__shared_owners_;
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  v56 = v70;
  if (v70)
  {
    v57 = (unint64_t *)&v70->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
  v59 = v72;
  if (v72)
  {
    v60 = (unint64_t *)&v72->__shared_owners_;
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v62 = v74;
  if (v74)
  {
    v63 = (unint64_t *)&v74->__shared_owners_;
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
  }
}

void sub_1B29FC588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void sub_1B29FC5D0()
{
  JUMPOUT(0x1B29FC5A8);
}

void sub_1B29FC5D8()
{
  JUMPOUT(0x1B29FC5B0);
}

void sub_1B29FC5E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B29FC5FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<`anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651DE70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<`anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651DE70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<`anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void `anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>::~BufferPoolFixedAllocationPolicy()
{
  JUMPOUT(0x1B5E29170);
}

unint64_t `anonymous namespace'::BufferPoolFixedAllocationPolicy<0,1024>::pad(uint64_t a1, _QWORD *a2)
{
  return ((*a2 - 1) & 0xFFFFFFFFFFFFFC00) + 1024;
}

void std::__shared_ptr_emplace<`anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651DF10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<`anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E651DF10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<`anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void `anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>::~TexturePoolFixedAllocationPolicy()
{
  JUMPOUT(0x1B5E29170);
}

__n128 `anonymous namespace'::TexturePoolFixedAllocationPolicy<16,64>::pad@<Q0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  __int128 v2;
  __n128 result;
  int64x2_t v4;
  int8x16_t v5;

  v2 = *(_OWORD *)(a1 + 32);
  result = *(__n128 *)(a1 + 16);
  v4.i64[0] = -1;
  v4.i64[1] = -1;
  v5 = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)a1, (uint64x2_t)vdupq_n_s64(0x10uLL)), (int8x16_t)vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(*(int64x2_t *)a1, v4), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFC0)), vdupq_n_s64(0x40uLL)), *(int8x16_t *)a1);
  *(__n128 *)(a2 + 16) = result;
  *(_OWORD *)(a2 + 32) = v2;
  *(int8x16_t *)a2 = v5;
  return result;
}

void std::__shared_ptr_emplace<HGPool::FixedTotalUsageServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E651DFA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGPool::FixedTotalUsageServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E651DFA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<HGPool::FixedTotalUsageServicingPolicy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t HGPool::FixedTotalUsageServicingPolicy::maxObjectAgeNS(HGPool::FixedTotalUsageServicingPolicy *this, const BasePool *a2)
{
  return *((_QWORD *)this + 5);
}

void std::__shared_ptr_emplace<HGPool::FixedGroupServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E651E060;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HGPool::FixedGroupServicingPolicy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E651E060;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E29170);
}

uint64_t std::__shared_ptr_emplace<HGPool::FixedGroupServicingPolicy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HGPool::FixedGroupServicingPolicy::~FixedGroupServicingPolicy(HGPool::FixedGroupServicingPolicy *this)
{
  *(_QWORD *)this = &off_1E652E808;
  std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
}

{
  *(_QWORD *)this = &off_1E652E808;
  std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
  JUMPOUT(0x1B5E29170);
}

uint64_t HGPool::FixedGroupServicingPolicy::maxTotalGroupBytesUsage(HGPool::FixedGroupServicingPolicy *this, const BasePool *a2)
{
  return *((_QWORD *)this + 7);
}

void std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  if (a2)
  {
    std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy(a1, a2[1]);
    v4 = (std::__shared_weak_count *)a2[6];
    if (!v4)
      goto LABEL_6;
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      operator delete(a2);
    }
    else
    {
LABEL_6:
      operator delete(a2);
    }
  }
}

void HGHWBlendFlipped::HGHWBlendFlipped(HGHWBlendFlipped *this)
{
  uint64_t v2;
  double v8;
  char *v9;

  HGLegacyBlend::HGLegacyBlend(this);
  *(_QWORD *)v2 = off_1E651E120;
  *(_QWORD *)(v2 + 456) = 0;
  *(_QWORD *)(v2 + 464) = 0;
  *(_QWORD *)(v2 + 448) = 0;
  *(_QWORD *)(v2 + 472) = 1;
  *(_WORD *)(v2 + 480) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v2 + 496) = _Q0;
  *(_QWORD *)(v2 + 512) = v2;
  *(_BYTE *)(v2 + 520) = 0;
  *(_DWORD *)(v2 + 524) = 9;
  *(_QWORD *)(v2 + 528) = 0x3F80000000000000;
  *(_DWORD *)(v2 + 540) = 1065353216;
  LODWORD(v8) = 0;
  HGLegacyBlend::SetParameter((HGLegacyBlend *)v2, 2, COERCE_DOUBLE(COERCE_UNSIGNED_INT(1.0) | 0x3F80000000000000), v8, 0.0, 0.0, v9);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(_QWORD *)this + 96))(this, 5, 1.0, 0.0, 0.0, 0.0);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B29FC9C8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 456) = v5;
    operator delete(v5);
  }
  HGLegacyBlend::~HGLegacyBlend((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGHWBlendFlipped::~HGHWBlendFlipped(HGHWBlendFlipped *this)
{
  HGHWBlendFlipped *v2;
  void *v3;

  *(_QWORD *)this = off_1E651E120;
  v2 = (HGHWBlendFlipped *)*((_QWORD *)this + 64);
  if (v2 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 64) = this;
  }
  HGHWBlendFlipped::DeleteStates((uint64_t)this);
  v3 = (void *)*((_QWORD *)this + 56);
  if (v3)
  {
    *((_QWORD *)this + 57) = v3;
    operator delete(v3);
  }
  HGLegacyBlend::~HGLegacyBlend((HGNode *)this);
}

{
  HGHWBlendFlipped *v2;
  void *v3;

  *(_QWORD *)this = off_1E651E120;
  v2 = (HGHWBlendFlipped *)*((_QWORD *)this + 64);
  if (v2 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 64) = this;
  }
  HGHWBlendFlipped::DeleteStates((uint64_t)this);
  v3 = (void *)*((_QWORD *)this + 56);
  if (v3)
  {
    *((_QWORD *)this + 57) = v3;
    operator delete(v3);
  }
  HGLegacyBlend::~HGLegacyBlend((HGNode *)this);
}

{
  HGHWBlendFlipped *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_1E651E120;
  v2 = (HGHWBlendFlipped *)*((_QWORD *)this + 64);
  if (v2 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 64) = this;
  }
  HGHWBlendFlipped::DeleteStates((uint64_t)this);
  v3 = (void *)*((_QWORD *)this + 56);
  if (v3)
  {
    *((_QWORD *)this + 57) = v3;
    operator delete(v3);
  }
  HGLegacyBlend::~HGLegacyBlend((HGNode *)this);
  HGObject::operator delete(v4);
}

const char *HGHWBlendFlipped::label_B(HGHWBlendFlipped *this)
{
  uint64_t v1;

  v1 = *((unsigned int *)this + 106);
  if (v1 > 0x29)
    return "(invalid)";
  else
    return s_label_table[v1];
}

const char *HGHWBlendFlipped::GetBlendModeLabel(HGHWBlendFlipped *this)
{
  if (this > 0x29)
    return "(invalid)";
  else
    return s_label_table[this];
}

uint64_t HGHWBlendFlipped::SetParameter(__n128 *this, uint64_t a2, __n128 a3, double a4, float a5, float a6, char *a7)
{
  unsigned int v7;
  uint64_t result;
  unsigned int v9;
  unsigned int v10;
  unsigned __int32 v11;
  unsigned __int32 v12;
  unsigned int v13;

  switch((int)a2)
  {
    case 0:
      v7 = vcvtms_s32_f32(a3.n128_f32[0]);
      if (v7 - 9 > 0x20)
      {
        a2 = 0;
        goto LABEL_24;
      }
      if (this[26].n128_u32[2] == v7)
        goto LABEL_22;
      this[26].n128_u32[2] = v7;
      result = 1;
      break;
    case 3:
      v9 = vcvtms_u32_f32(a3.n128_f32[0]);
      if (v9 > 2)
      {
        result = 0xFFFFFFFFLL;
      }
      else
      {
        this[29].n128_u32[2] = v9;
        result = 0;
      }
      break;
    case 4:
      v10 = vcvtms_s32_f32(a3.n128_f32[0]);
      v11 = v10 != 0;
      if (this[29].n128_u32[3] == v11)
        goto LABEL_22;
      this[29].n128_u32[3] = v11;
      v12 = this[1].n128_u32[0];
      if (v10)
        v13 = v12 | 0x20;
      else
        v13 = v12 & 0xFFFFFFDF;
      this[1].n128_u32[0] = v13;
      result = 1;
      break;
    case 6:
      if (this[31].n128_f32[0] == a3.n128_f32[0]
        && this[31].n128_f32[1] == *(float *)&a4
        && this[31].n128_f32[2] == a5
        && this[31].n128_f32[3] == a6)
      {
LABEL_22:
        result = 0;
      }
      else
      {
        a3.n128_u32[1] = LODWORD(a4);
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        this[31] = a3;
        result = 1;
      }
      break;
    default:
LABEL_24:
      result = HGLegacyBlend::SetParameter((HGLegacyBlend *)this, a2, a3.n128_f64[0], a4, a5, a6, a7);
      break;
  }
  return result;
}

uint64_t HGHWBlendFlipped::SetState(HGHWBlendFlipped *this, HGRenderer *a2, int a3)
{
  if (a3 == 1)
    HGHWBlendFlipped::AllocateStates(this, a2);
  return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
}

HGHWBlendFlipped *HGHWBlendFlipped::Clone(HGHWBlendFlipped *this)
{
  HGHWBlendFlipped *v2;

  v2 = (HGHWBlendFlipped *)HGObject::operator new(0x220uLL);
  HGHWBlendFlipped::HGHWBlendFlipped(v2);
  (*(void (**)(HGHWBlendFlipped *, _QWORD, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 0, (float)*((int *)this + 106), 0.0, 0.0, 0.0);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 1, *((float *)this + 104), 0.0, 0.0, 0.0);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 2, (float)*((int *)this + 107), 0.0, 0.0, 0.0);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 3, (float)*((unsigned int *)this + 118), 0.0, 0.0, 0.0);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 4, (float)*((int *)this + 119), 0.0, 0.0, 0.0);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 5, *((float *)this + 105), 0.0, 0.0, 0.0);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(_QWORD *)v2 + 96))(v2, 6, *((float *)this + 124), *((float *)this + 125), *((float *)this + 126), *((float *)this + 127));
  return v2;
}

void sub_1B29FCDF4(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHWBlendFlipped::UpdateHWBlendStatus(HGHWBlendFlipped *this, HGRenderer *a2)
{
  uint64_t result;
  int v5;

  result = (*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2);
  if ((result & 1) == 0)
  {
    v5 = *((_DWORD *)this + 118);
    switch(v5)
    {
      case 2:
        *((_BYTE *)this + 480) = 1;
        break;
      case 1:
        result = (uint64_t)HGRenderer::GetInput(a2, (HGNode *)this, *((_DWORD *)this + 108));
        if (result)
          result = HGNode::DoInplaceHardwareBlending((HGNode *)result, a2, (HGNode *)this, *((float *)this + 104));
        *((_BYTE *)this + 480) = result;
        break;
      case 0:
        *((_BYTE *)this + 480) = 0;
        break;
    }
  }
  return result;
}

HGNode *HGHWBlendFlipped::GetOutput(HGHWBlendFlipped *this, HGRenderer *a2)
{
  HGHWBlendFlipped *v4;
  HGOverwrite *v5;
  HGNode *Input;
  HGNode *v7;
  HGLightWrapBlend *v9;
  HGNode *v10;
  HGNode *v11;
  HGBlendingInfo *v12;
  _QWORD *v13;

  if (*((int *)this + 106) >= 38)
    *((_DWORD *)this + 104) = 1065353216;
  (*(void (**)(HGHWBlendFlipped *, HGRenderer *))(*(_QWORD *)this + 592))(this, a2);
  v4 = (HGHWBlendFlipped *)*((_QWORD *)this + 64);
  if (v4 != this)
  {
    (*(void (**)(HGHWBlendFlipped *))(*(_QWORD *)v4 + 24))(v4);
    *((_QWORD *)this + 64) = this;
  }
  if ((*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2)
    && (*((_DWORD *)this + 119) || *((_DWORD *)this + 106) == 41))
  {
    v5 = (HGOverwrite *)HGObject::operator new(0x1A0uLL);
    HGOverwrite::HGOverwrite(v5);
    Input = HGRenderer::GetInput(a2, (HGNode *)this, *((_DWORD *)this + 107));
    (*(void (**)(HGOverwrite *, _QWORD, HGNode *))(*(_QWORD *)v5 + 120))(v5, 0, Input);
    v7 = HGRenderer::GetInput(a2, (HGNode *)this, *((_DWORD *)this + 108));
    (*(void (**)(HGOverwrite *, uint64_t, HGNode *))(*(_QWORD *)v5 + 120))(v5, 1, v7);
    *((_QWORD *)this + 64) = v5;
    return (HGNode *)v5;
  }
  else if (*((_BYTE *)this + 520))
  {
    v9 = (HGLightWrapBlend *)HGObject::operator new(0x1D0uLL);
    HGLightWrapBlend::HGLightWrapBlend(v9);
    v10 = HGRenderer::GetInput(a2, (HGNode *)this, 0);
    (*(void (**)(HGLightWrapBlend *, _QWORD, HGNode *))(*(_QWORD *)v9 + 120))(v9, 0, v10);
    v11 = HGRenderer::GetInput(a2, (HGNode *)this, 1u);
    (*(void (**)(HGLightWrapBlend *, uint64_t, HGNode *))(*(_QWORD *)v9 + 120))(v9, 1, v11);
    (*(void (**)(HGLightWrapBlend *, _QWORD, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 0, (float)*((int *)this + 106), 0.0, 0.0, 0.0);
    (*(void (**)(HGLightWrapBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v9 + 96))(v9, 1, *((float *)this + 104), 0.0, 0.0, 0.0);
    HGLightWrapBlend::SetLightWrapParams((uint64_t)v9, *((_DWORD *)this + 131), *((float *)this + 132), *((float *)this + 133), *((float *)this + 134), *((float *)this + 135));
    *((_QWORD *)this + 64) = v9;
    return (HGNode *)v9;
  }
  else if ((*((_DWORD *)this + 106) - 9) <= 0x20
         && (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) == 0
          && (*((_DWORD *)this + 119)
           || (v12 = (HGBlendingInfo *)*((unsigned int *)this + 106), (_DWORD)v12 == 41)
           || (v12 > 0x29 || *((float *)this + 105) == 1.0 || !s_gamma_support_blend_table[(_QWORD)v12])
           && (v13 = (_QWORD *)HGBlendingInfo::Get(v12), *((_BYTE *)this + 480))
           && (*v13 & 1) != 0)
          || *((int *)this + 106) >= 38))
  {
    (*(void (**)(HGHWBlendFlipped *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 0xFFFFFFFFLL, 32);
    (*(void (**)(HGHWBlendFlipped *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 32);
    (*(void (**)(HGHWBlendFlipped *, uint64_t, uint64_t))(*(_QWORD *)this + 136))(this, 1, 32);
    return HGLegacyBlend::GetOutput((HGNode *)this, a2);
  }
  else
  {
    return HGLegacyBlend::GetOutput((HGNode *)this, a2);
  }
}

void sub_1B29FD188(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B29FD19C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHWBlendFlipped::IsHardwareBlendSupported(HGHWBlendFlipped *this, HGRenderer *a2)
{
  HGBlendingInfo *v4;

  if (((*(uint64_t (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2) & 1) != 0)
    return 0;
  if (*((_DWORD *)this + 119))
    return 1;
  v4 = (HGBlendingInfo *)*((unsigned int *)this + 106);
  if ((_DWORD)v4 == 41)
    return 1;
  if (v4 <= 0x29 && *((float *)this + 105) != 1.0 && s_gamma_support_blend_table[(_QWORD)v4] != 0)
    return 0;
  return (*((_BYTE *)this + 480) != 0) & *(_BYTE *)HGBlendingInfo::Get(v4);
}

uint64_t HGHWBlendFlipped::BindTexture(HGHWBlendFlipped *this, HGHandler *a2, int a3)
{
  HGHandler::TexCoord(a2, a3, 0, 0, 0);
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
  return 0;
}

uint64_t HGHWBlendFlipped::GetGammaBlendMode(HGHWBlendFlipped *this, unsigned int a2, float a3)
{
  unsigned int v5;
  BOOL v6;

  if (a2 > 0x29)
    return 0;
  if (a3 > 1.9756 || a3 < 1.9364)
    v5 = 1;
  else
    v5 = 2;
  if (s_gamma_support_blend_table[a2])
    v6 = a3 == 1.0;
  else
    v6 = 1;
  if (v6)
    return 0;
  else
    return v5;
}

uint64_t HGHWBlendFlipped::GetDOD(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  uint64_t result;
  HGNode *Input;
  uint64_t DOD;
  uint64_t v9;
  uint64_t v10;
  HGNode *v11;
  uint64_t v12;
  uint64_t v13;

  switch(s_dod_policy_table[*((int *)this + 106)])
  {
    case 0:
      if (a3 >= 2)
        goto LABEL_10;
      goto LABEL_3;
    case 1:
      if (a3 > 1)
        goto LABEL_10;
      Input = HGRenderer::GetInput(a2, this, 0);
      DOD = HGRenderer::GetDOD(a2, Input);
      v10 = v9;
      v11 = HGRenderer::GetInput(a2, this, 1u);
      v12 = HGRenderer::GetDOD(a2, v11);
      result = HGRectIntersection(DOD, v10, v12, v13);
      break;
    case 2:
      if (!a3)
        goto LABEL_3;
      goto LABEL_10;
    case 3:
      if (a3 != 1)
        goto LABEL_10;
LABEL_3:
      result = *(_QWORD *)&a4.var0;
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

HGBitmap *HGHWBlendFlipped::RenderPageDispatcher<(HGGPURenderAPI)0>(uint64_t a1, HGPage *a2)
{
  uint64_t v4;
  HGBitmap *v5;
  const char *v6;
  uint64_t v7;
  HGBlendingInfo *v8;
  _QWORD *v9;
  char v11[16];
  char __str[256];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 616))(a1, 0);
  v4 = *(_QWORD *)a2;
  v5 = HGHWBlendFlipped::RenderSingleInput((HGHWBlendFlipped *)a1, a2);
  if (!v5)
  {
    v6 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    snprintf(__str, 0x100uLL, "%s::%s( [%d %d %d %d])", v6, "RenderPage", *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v11, "gpu", 1, __str);
    if ((*(_DWORD *)(a1 + 424) - 9) >= 0x21)
    {
      v7 = HGLegacyBlend::RenderPage((HGLegacyBlend *)a1, a2);
    }
    else if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 304))(v4) & 1) == 0
           && (*(_DWORD *)(a1 + 476)
            || (v8 = (HGBlendingInfo *)*(unsigned int *)(a1 + 424), (_DWORD)v8 == 41)
            || (v8 > 0x29 || *(float *)(a1 + 420) == 1.0 || !s_gamma_support_blend_table[(_QWORD)v8])
            && (v9 = (_QWORD *)HGBlendingInfo::Get(v8), *(_BYTE *)(a1 + 480))
            && (*v9 & 1) != 0))
    {
      v7 = (uint64_t)HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)0>(a1, a2);
    }
    else
    {
      v7 = HGNode::RenderPage((HGNode *)a1, (HGRect *)a2);
    }
    v5 = (HGBitmap *)v7;
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v11);
  }
  return v5;
}

void sub_1B29FD5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

HGBitmap *HGHWBlendFlipped::RenderPageDispatcher<(HGGPURenderAPI)1>(uint64_t a1, HGPage *a2)
{
  uint64_t v4;
  HGBitmap *v5;
  const char *v6;
  char *v7;
  HGBlendingInfo *v8;
  _QWORD *v9;
  char v11[16];
  char __str[256];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 616))(a1, 0);
  v4 = *(_QWORD *)a2;
  v5 = HGHWBlendFlipped::RenderSingleInput((HGHWBlendFlipped *)a1, a2);
  if (!v5)
  {
    v6 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    snprintf(__str, 0x100uLL, "%s::%s( [%d %d %d %d])", v6, "RenderPageMetal", *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v11, "gpu", 1, __str);
    if ((*(_DWORD *)(a1 + 424) - 9) >= 0x21)
    {
      v7 = (char *)HGLegacyBlend::RenderPageMetal((HGLegacyBlend *)a1, a2);
    }
    else if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 304))(v4) & 1) == 0
           && (*(_DWORD *)(a1 + 476)
            || (v8 = (HGBlendingInfo *)*(unsigned int *)(a1 + 424), (_DWORD)v8 == 41)
            || (v8 > 0x29 || *(float *)(a1 + 420) == 1.0 || !s_gamma_support_blend_table[(_QWORD)v8])
            && (v9 = (_QWORD *)HGBlendingInfo::Get(v8), *(_BYTE *)(a1 + 480))
            && (*v9 & 1) != 0))
    {
      v7 = HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)1>(a1, a2);
    }
    else
    {
      v7 = (char *)HGNode::RenderPageMetal((HGNode *)a1, a2);
    }
    v5 = (HGBitmap *)v7;
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v11);
  }
  return v5;
}

void sub_1B29FD780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

HGBitmap *HGHWBlendFlipped::RenderSingleInput(HGHWBlendFlipped *this, HGPage *a2)
{
  HGRenderer *v4;
  HGNode *Input;
  HGNode *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t DOD;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  HGRect v15;
  HGRect v16;

  v4 = *(HGRenderer **)a2;
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, (HGNode *)this, *((_DWORD *)this + 107));
  v6 = HGRenderer::GetInput(v4, (HGNode *)this, *((_DWORD *)this + 108));
  *(_QWORD *)&v16.var0 = (*(uint64_t (**)(HGHWBlendFlipped *, HGRenderer *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 400))(this, v4, *((unsigned int *)this + 107), *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3));
  *(_QWORD *)&v16.var2 = v7;
  *(_QWORD *)&v15.var0 = (*(uint64_t (**)(HGHWBlendFlipped *, HGRenderer *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 400))(this, v4, *((unsigned int *)this + 108), *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3));
  *(_QWORD *)&v15.var2 = v8;
  DOD = HGRenderer::GetDOD(v4, v6);
  v11 = v10;
  if (HGRect::IsNull(&v15))
  {
    v6 = Input;
  }
  else if ((HGNode::DoInplaceHardwareBlending(v6, v4, (HGNode *)this, *((float *)this + 104)) & 1) != 0
         || *((float *)this + 104) != 1.0
         || !HGRect::IsNull(&v16))
  {
    if (!*((_DWORD *)this + 119) && *((_DWORD *)this + 106) != 41)
      return 0;
    v12 = HGRectIntersection(DOD, v11, *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3));
    if (!HGRectIsEqual(v12, v13, *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3)))
      return 0;
  }
  return HGGPURenderer::GetNodeBitmap(v4, v6, *((HGRect *)a2 + 1), *((HGBuffer **)a2 + 1), 1u);
}

void HGHWBlendFlipped::ComputeSubPageRects(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  HGNode *Input;
  HGNode *v7;
  uint64_t DOD;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int var3;
  int var0;
  int v20;
  unsigned int v21;
  unsigned int var2;
  unsigned int var1;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t *v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t *v62;
  uint64_t *v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  uint64_t *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t *v79;
  uint64_t *v80;
  unsigned int v81;
  uint64_t *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  uint64_t *v88;
  unsigned int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t *v95;
  uint64_t *v96;
  uint64_t *v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  char *v102;
  uint64_t *v103;
  unsigned int v104;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  HGRect v112;
  HGRect v113;

  Input = HGRenderer::GetInput(*(HGRenderer **)a2, (HGNode *)a1, *(_DWORD *)(a1 + 432));
  v7 = HGRenderer::GetInput(*(HGRenderer **)a2, (HGNode *)a1, *(_DWORD *)(a1 + 428));
  DOD = HGRenderer::GetDOD(*(HGRenderer **)a2, v7);
  v10 = v9;
  v11 = HGRenderer::GetDOD(*(HGRenderer **)a2, Input);
  v13 = v12;
  *(_QWORD *)&v113.var0 = HGRectIntersection(DOD, v10, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  *(_QWORD *)&v113.var2 = v14;
  *(_QWORD *)&v112.var0 = HGRectIntersection(v11, v13, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  *(_QWORD *)&v112.var2 = v15;
  if (!HGRect::IsNull(&v113)
    && !HGRect::IsNull(&v112)
    && !HGRectIsEqual(*(uint64_t *)&v113.var0, *(uint64_t *)&v113.var2, *(uint64_t *)&v112.var0, *(uint64_t *)&v112.var2))
  {
    v16 = *(_DWORD *)(a2 + 16);
    v17 = *(_DWORD *)(a2 + 24);
    v111 = *(_DWORD *)(a2 + 28);
    if (v112.var3 >= v113.var3)
      var3 = v113.var3;
    else
      var3 = v112.var3;
    var0 = v113.var0;
    v20 = v112.var0;
    if (v113.var0 <= v112.var0)
      v21 = v112.var0;
    else
      v21 = v113.var0;
    if (v112.var2 >= v113.var2)
      var2 = v113.var2;
    else
      var2 = v112.var2;
    if (v113.var1 <= v112.var1)
      var1 = v112.var1;
    else
      var1 = v113.var1;
    if (v113.var1 != v112.var1)
    {
      v24 = *(_DWORD *)(a2 + 16);
      v25 = HGRectMake4i(v16, *(_DWORD *)(a2 + 20), v17, var1);
      v27 = v25;
      v28 = v26;
      v30 = a3[1];
      v29 = (unint64_t)a3[2];
      if ((unint64_t)v30 >= v29)
      {
        v104 = v21;
        v106 = var2;
        v108 = v17;
        v32 = *a3;
        v33 = ((char *)v30 - (char *)*a3) >> 4;
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 60)
          goto LABEL_123;
        v35 = v29 - (_QWORD)v32;
        if (v35 >> 3 > v34)
          v34 = v35 >> 3;
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0)
          v36 = 0xFFFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        if (v36)
        {
          if (v36 >> 60)
            goto LABEL_124;
          v37 = (char *)operator new(16 * v36);
        }
        else
        {
          v37 = 0;
        }
        v38 = (uint64_t *)&v37[16 * v33];
        v39 = (uint64_t *)&v37[16 * v36];
        *v38 = v27;
        v38[1] = v28;
        v31 = v38 + 2;
        v16 = v24;
        if (v30 == v32)
        {
          var2 = v106;
          v17 = v108;
        }
        else
        {
          var2 = v106;
          v17 = v108;
          do
          {
            *((_OWORD *)v38 - 1) = *((_OWORD *)v30 - 1);
            v38 -= 2;
            v30 -= 2;
          }
          while (v30 != v32);
          v30 = *a3;
        }
        *a3 = v38;
        a3[1] = v31;
        a3[2] = v39;
        v21 = v104;
        if (v30)
          operator delete(v30);
      }
      else
      {
        *v30 = v25;
        v30[1] = v26;
        v31 = v30 + 2;
        v16 = v24;
      }
      a3[1] = v31;
      var0 = v113.var0;
      v20 = v112.var0;
    }
    if (var0 != v20)
    {
      if (var0 <= v20)
        v40 = v20;
      else
        v40 = var0;
      v41 = v16;
      v42 = HGRectMake4i(v16, var1, v40, var3);
      v44 = v42;
      v45 = v43;
      v47 = a3[1];
      v46 = (unint64_t)a3[2];
      if ((unint64_t)v47 >= v46)
      {
        v105 = v21;
        v107 = var2;
        v109 = v17;
        v49 = *a3;
        v50 = ((char *)v47 - (char *)*a3) >> 4;
        v51 = v50 + 1;
        if ((unint64_t)(v50 + 1) >> 60)
          goto LABEL_123;
        v52 = v46 - (_QWORD)v49;
        if (v52 >> 3 > v51)
          v51 = v52 >> 3;
        if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF0)
          v53 = 0xFFFFFFFFFFFFFFFLL;
        else
          v53 = v51;
        if (v53)
        {
          if (v53 >> 60)
            goto LABEL_124;
          v54 = (char *)operator new(16 * v53);
        }
        else
        {
          v54 = 0;
        }
        v55 = (uint64_t *)&v54[16 * v50];
        v56 = (uint64_t *)&v54[16 * v53];
        *v55 = v44;
        v55[1] = v45;
        v48 = v55 + 2;
        v16 = v41;
        if (v47 == v49)
        {
          var2 = v107;
          v17 = v109;
        }
        else
        {
          var2 = v107;
          v17 = v109;
          do
          {
            *((_OWORD *)v55 - 1) = *((_OWORD *)v47 - 1);
            v55 -= 2;
            v47 -= 2;
          }
          while (v47 != v49);
          v47 = *a3;
        }
        *a3 = v55;
        a3[1] = v48;
        a3[2] = v56;
        v21 = v105;
        if (v47)
          operator delete(v47);
      }
      else
      {
        *v47 = v42;
        v47[1] = v43;
        v48 = v47 + 2;
        v16 = v41;
      }
      a3[1] = v48;
    }
    v57 = HGRectMake4i(v21, var1, var2, var3);
    v59 = v57;
    v60 = v58;
    v62 = a3[1];
    v61 = (unint64_t)a3[2];
    if ((unint64_t)v62 >= v61)
    {
      v110 = var1;
      v64 = var3;
      v65 = v17;
      v66 = *a3;
      v67 = ((char *)v62 - (char *)*a3) >> 4;
      v68 = v67 + 1;
      if ((unint64_t)(v67 + 1) >> 60)
        goto LABEL_123;
      v69 = v61 - (_QWORD)v66;
      if (v69 >> 3 > v68)
        v68 = v69 >> 3;
      if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0)
        v70 = 0xFFFFFFFFFFFFFFFLL;
      else
        v70 = v68;
      if (v70)
      {
        if (v70 >> 60)
          goto LABEL_124;
        v71 = (char *)operator new(16 * v70);
      }
      else
      {
        v71 = 0;
      }
      v72 = (uint64_t *)&v71[16 * v67];
      *v72 = v59;
      v72[1] = v60;
      v63 = v72 + 2;
      v17 = v65;
      if (v62 != v66)
      {
        do
        {
          *((_OWORD *)v72 - 1) = *((_OWORD *)v62 - 1);
          v72 -= 2;
          v62 -= 2;
        }
        while (v62 != v66);
        v62 = *a3;
      }
      var3 = v64;
      *a3 = v72;
      a3[1] = v63;
      a3[2] = (uint64_t *)&v71[16 * v70];
      var1 = v110;
      if (v62)
        operator delete(v62);
    }
    else
    {
      *v62 = v57;
      v62[1] = v58;
      v63 = v62 + 2;
    }
    a3[1] = v63;
    if (v113.var2 != v112.var2)
    {
      if (v112.var2 >= v113.var2)
        v73 = v113.var2;
      else
        v73 = v112.var2;
      v74 = HGRectMake4i(v73, var1, v17, var3);
      v76 = v74;
      v77 = v75;
      v79 = a3[1];
      v78 = (unint64_t)a3[2];
      if ((unint64_t)v79 >= v78)
      {
        v81 = v17;
        v82 = *a3;
        v83 = ((char *)v79 - (char *)*a3) >> 4;
        v84 = v83 + 1;
        if ((unint64_t)(v83 + 1) >> 60)
          goto LABEL_123;
        v85 = v78 - (_QWORD)v82;
        if (v85 >> 3 > v84)
          v84 = v85 >> 3;
        if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF0)
          v86 = 0xFFFFFFFFFFFFFFFLL;
        else
          v86 = v84;
        if (v86)
        {
          if (v86 >> 60)
            goto LABEL_124;
          v87 = (char *)operator new(16 * v86);
        }
        else
        {
          v87 = 0;
        }
        v88 = (uint64_t *)&v87[16 * v83];
        *v88 = v76;
        v88[1] = v77;
        v80 = v88 + 2;
        v17 = v81;
        if (v79 != v82)
        {
          do
          {
            *((_OWORD *)v88 - 1) = *((_OWORD *)v79 - 1);
            v88 -= 2;
            v79 -= 2;
          }
          while (v79 != v82);
          v79 = *a3;
        }
        *a3 = v88;
        a3[1] = v80;
        a3[2] = (uint64_t *)&v87[16 * v86];
        if (v79)
          operator delete(v79);
      }
      else
      {
        *v79 = v74;
        v79[1] = v75;
        v80 = v79 + 2;
      }
      a3[1] = v80;
    }
    if (v113.var3 == v112.var3)
      return;
    if (v112.var3 >= v113.var3)
      v89 = v113.var3;
    else
      v89 = v112.var3;
    v90 = HGRectMake4i(v16, v89, v17, v111);
    v92 = v90;
    v93 = v91;
    v95 = a3[1];
    v94 = (unint64_t)a3[2];
    if ((unint64_t)v95 < v94)
    {
      *v95 = v90;
      v95[1] = v91;
      v96 = v95 + 2;
LABEL_121:
      a3[1] = v96;
      return;
    }
    v97 = *a3;
    v98 = ((char *)v95 - (char *)*a3) >> 4;
    v99 = v98 + 1;
    if (!((unint64_t)(v98 + 1) >> 60))
    {
      v100 = v94 - (_QWORD)v97;
      if (v100 >> 3 > v99)
        v99 = v100 >> 3;
      if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0)
        v101 = 0xFFFFFFFFFFFFFFFLL;
      else
        v101 = v99;
      if (!v101)
      {
        v102 = 0;
        goto LABEL_116;
      }
      if (!(v101 >> 60))
      {
        v102 = (char *)operator new(16 * v101);
LABEL_116:
        v103 = (uint64_t *)&v102[16 * v98];
        *v103 = v92;
        v103[1] = v93;
        v96 = v103 + 2;
        if (v95 != v97)
        {
          do
          {
            *((_OWORD *)v103 - 1) = *((_OWORD *)v95 - 1);
            v103 -= 2;
            v95 -= 2;
          }
          while (v95 != v97);
          v95 = *a3;
        }
        *a3 = v103;
        a3[1] = v96;
        a3[2] = (uint64_t *)&v102[16 * v101];
        if (v95)
          operator delete(v95);
        goto LABEL_121;
      }
LABEL_124:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_123:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
}

BOOL HGHWBlendFlipped::RenderSubPages(HGHWBlendFlipped *this, HGPage *a2)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t *v14;
  _OWORD v15[2];
  int v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  char v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;

  v31 = 0;
  v32 = 0;
  v33 = 0;
  HGHWBlendFlipped::ComputeSubPageRects((uint64_t)this, (uint64_t)a2, &v31);
  v4 = v31;
  v14 = v32;
  if (v31 == v32)
  {
    v7 = v31;
    if (!v31)
      return v4 != v14;
    goto LABEL_5;
  }
  v5 = 0;
  v6 = 0;
  v7 = v31;
  do
  {
    v30 = 1;
    v8 = *(_OWORD *)((char *)a2 + 116);
    v21 = *(_OWORD *)((char *)a2 + 100);
    v22 = v8;
    v9 = *(_OWORD *)((char *)a2 + 148);
    v23 = *(_OWORD *)((char *)a2 + 132);
    v24 = v9;
    v10 = *(_OWORD *)((char *)a2 + 52);
    v17 = *(_OWORD *)((char *)a2 + 36);
    v18 = v10;
    v11 = *(_OWORD *)((char *)a2 + 84);
    v19 = *(_OWORD *)((char *)a2 + 68);
    v20 = v11;
    v25 = *(_OWORD *)((char *)a2 + 168);
    v26 = *(_OWORD *)((char *)a2 + 184);
    v27 = *(_OWORD *)((char *)a2 + 200);
    v28 = *(_OWORD *)((char *)a2 + 216);
    v15[0] = *(_OWORD *)a2;
    v16 = *((_DWORD *)a2 + 8);
    v29 = *(_OWORD *)((char *)a2 + 232);
    v15[1] = *(_OWORD *)&v7[v5];
    v12 = (*(uint64_t (**)(HGHWBlendFlipped *, _OWORD *))(*(_QWORD *)this + 456))(this, v15);
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    ++v6;
    v7 = v31;
    v5 += 2;
  }
  while (v6 < ((char *)v32 - (char *)v31) >> 4);
  if (v31)
  {
LABEL_5:
    v32 = v7;
    operator delete(v7);
  }
  return v4 != v14;
}

void sub_1B29FE044(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 120);
  if (v3)
  {
    *(_QWORD *)(v1 - 112) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGHWBlendFlipped::SetLightWrapParams(uint64_t result, int a2, float a3, float a4, float a5, float a6)
{
  *(_BYTE *)(result + 520) = 1;
  *(float *)(result + 528) = a3;
  *(float *)(result + 532) = a4;
  *(float *)(result + 536) = a5;
  *(_DWORD *)(result + 524) = a2;
  *(float *)(result + 540) = a6;
  return result;
}

char *HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)0>(uint64_t a1, _QWORD *a2)
{
  HGRenderer *v4;
  char *Buffer;
  unsigned int *v6;
  uint64_t v7;
  HGNode *Input;
  HGNode *v9;
  HGBitmap *NodeBitmap;
  HGBitmap *v11;
  uint64_t v12;
  char *v13;
  const char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t DOD;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  _BOOL4 v25;
  HGBitmap *v26;
  uint64_t v27;
  uint64_t v28;
  HGHandler *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  HGRect v35;
  HGRect v36;

  v4 = (HGRenderer *)*a2;
  Buffer = (char *)a2[1];
  v6 = (unsigned int *)(Buffer + 16);
  if (!Buffer)
    v6 = (unsigned int *)(a2 + 4);
  v7 = *v6;
  Input = HGRenderer::GetInput((HGRenderer *)*a2, (HGNode *)a1, *(_DWORD *)(a1 + 432));
  v9 = HGRenderer::GetInput(v4, (HGNode *)a1, *(_DWORD *)(a1 + 428));
  if (Buffer)
  {
    (*(void (**)(char *))(*(_QWORD *)Buffer + 16))(Buffer);
    if (*(_DWORD *)(a1 + 476))
      goto LABEL_8;
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, *((HGRect *)a2 + 1), v7, 0, (*(_DWORD *)(a1 + 16) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    if (*(_DWORD *)(a1 + 476))
      goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 424) != 41)
  {
LABEL_9:
    NodeBitmap = HGGPURenderer::GetNodeBitmap(v4, v9, *((HGRect *)a2 + 1), (HGBuffer *)Buffer, 1u);
    v11 = NodeBitmap;
    if (NodeBitmap && NodeBitmap == (HGBitmap *)Buffer)
      HGRenderer::DotLogInplaceRendering(v4, v9);
    if (!v11 || v11 == (HGBitmap *)Buffer)
    {
      if (!v11)
      {
        (*(void (**)(_QWORD, char *))(*(_QWORD *)*a2 + 144))(*a2, Buffer);
        HGGPURenderer::Clear(v4, *((HGRect *)a2 + 1), v14, v15);
LABEL_18:
        v16 = a2[2];
        v17 = a2[3];
        DOD = HGRenderer::GetDOD(v4, Input);
        v20 = HGRectIntersection(v16, v17, DOD, v19);
        v22 = v21;
        v23 = *(float *)(a1 + 416);
        if (HGNode::DoInplaceHardwareBlending(Input, v4, (HGNode *)a1, v23))
        {
          if (*(_DWORD *)(a1 + 476))
            v24 = 41;
          else
            v24 = *(unsigned int *)(a1 + 424);
          v27 = HGBlendingInfo::Get((HGBlendingInfo *)v24);
          (*(void (**)(HGNode *))(*(_QWORD *)Input + 240))(Input);
          (*(void (**)(HGNode *, uint64_t))(*(_QWORD *)Input + 248))(Input, v27);
          (*(void (**)(HGNode *, float))(*(_QWORD *)Input + 280))(Input, *(float *)(a1 + 416));
          (*(void (**)(HGNode *, uint64_t))(*(_QWORD *)Input + 264))(Input, a1 + 496);
          *(_QWORD *)&v36.var0 = v20;
          *(_QWORD *)&v36.var2 = v22;
          v26 = HGGPURenderer::GetNodeBitmap(v4, Input, v36, (HGBuffer *)Buffer, 1u);
          HGNode::DisableInplaceHardwareBlending(Input);
          HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 1);
          v25 = 0;
          if (!v26)
            goto LABEL_30;
        }
        else
        {
          v25 = v23 != 1.0;
          *(_QWORD *)&v35.var0 = v20;
          *(_QWORD *)&v35.var2 = v22;
          v26 = HGGPURenderer::GetNodeBitmap(v4, Input, v35, 0, 1u);
          if (!v26)
            goto LABEL_30;
        }
        if (v26 != (HGBitmap *)Buffer)
        {
          v28 = HGGPURenderer::ConvertToGLTexture(v4, *((HGRect *)a2 + 1), v26);
          (*(void (**)(HGRenderer *, char *))(*(_QWORD *)v4 + 144))(v4, Buffer);
          (*(void (**)(HGRenderer *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v4 + 152))(v4, 0, v28, 0, 0);
          v29 = 0;
          if (v25)
          {
            v30 = (*(uint64_t (**)(uint64_t, HGRenderer *))(*(_QWORD *)a1 + 600))(a1, v4);
            v29 = (HGHandler *)(*(uint64_t (**)(HGRenderer *, uint64_t, uint64_t))(*(_QWORD *)v4 + 376))(v4, v30, a1);
            *(_BYTE *)(a1 + 481) = 1;
            a2[21] = v28;
            (*(void (**)(uint64_t, _QWORD *, _QWORD, HGHandler *))(*(_QWORD *)a1 + 488))(a1, a2, 0, v29);
            *(_BYTE *)(a1 + 481) = 0;
          }
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 240))(a1);
          if (*(_DWORD *)(a1 + 476))
            v31 = 41;
          else
            v31 = *(unsigned int *)(a1 + 424);
          v32 = HGBlendingInfo::Get((HGBlendingInfo *)v31);
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 248))(a1, v32);
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 264))(a1, a1 + 496);
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 344))(a1);
          if (v29)
            HGGPURenderer::Rect(v4, v29, *((HGRect *)a2 + 1), 1);
          else
            HGGPURenderer::Copy(v4, *((HGRect *)a2 + 1), 0, v33);
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 352))(a1);
          HGNode::DisableInplaceHardwareBlending((HGNode *)a1);
          if (v29)
            (*(void (**)(uint64_t, _QWORD *, _QWORD, HGHandler *))(*(_QWORD *)a1 + 496))(a1, a2, 0, v29);
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
          HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 0);
LABEL_39:
          (*(void (**)(HGBitmap *))(*(_QWORD *)v26 + 24))(v26);
          return Buffer;
        }
LABEL_30:
        if (!v26)
          return Buffer;
        goto LABEL_39;
      }
    }
    else
    {
      v12 = HGGPURenderer::ConvertToGLTexture(v4, *((HGRect *)a2 + 1), v11);
      (*(void (**)(HGRenderer *, char *))(*(_QWORD *)v4 + 144))(v4, Buffer);
      (*(void (**)(HGRenderer *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v4 + 152))(v4, 0, v12, 0, 0);
      HGGPURenderer::Copy(v4, *((HGRect *)a2 + 1), 0, v13);
      (*(void (**)(HGRenderer *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v4 + 152))(v4, 0, 0, 0, 0);
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    }
    (*(void (**)(HGBitmap *))(*(_QWORD *)v11 + 24))(v11);
    goto LABEL_18;
  }
LABEL_8:
  if (!HGHWBlendFlipped::RenderSubPages((HGHWBlendFlipped *)a1, (HGPage *)a2))
    goto LABEL_9;
  return Buffer;
}

char *HGHWBlendFlipped::RenderPageHWBlending<(HGGPURenderAPI)1>(uint64_t a1, _QWORD *a2)
{
  HGRenderer *v4;
  char *Buffer;
  unsigned int *v6;
  uint64_t v7;
  HGNode *Input;
  HGNode *v9;
  HGBitmap *NodeBitmap;
  char *v11;
  HGBitmap *v12;
  BOOL v14;
  HGBitmap *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t DOD;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  HGBitmap *v25;
  _BOOL4 v26;
  char *v27;
  uint64_t v28;
  const void *v29;
  std::string *v30;
  int v31;
  const HGBlendingInfo *v32;
  size_t v34;
  std::string::size_type v35;
  std::string *p_dst;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  const HGBlendingInfo *v40;
  uint64_t v41;
  const char *__src;
  uint64_t v43;
  int v44;
  HGBitmap *v45;
  std::string __dst;
  HGRect v47;
  HGRect v48;
  HGRect v49;
  HGRect v50;

  v4 = (HGRenderer *)*a2;
  Buffer = (char *)a2[1];
  v6 = (unsigned int *)(Buffer + 16);
  if (!Buffer)
    v6 = (unsigned int *)(a2 + 4);
  v7 = *v6;
  Input = HGRenderer::GetInput((HGRenderer *)*a2, (HGNode *)a1, *(_DWORD *)(a1 + 432));
  v9 = HGRenderer::GetInput(v4, (HGNode *)a1, *(_DWORD *)(a1 + 428));
  if (Buffer)
    (*(void (**)(char *))(*(_QWORD *)Buffer + 16))(Buffer);
  else
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, *((HGRect *)a2 + 1), v7, 1, (*(_DWORD *)(a1 + 16) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
  NodeBitmap = HGGPURenderer::GetNodeBitmap(v4, v9, *((HGRect *)a2 + 1), (HGBuffer *)Buffer, 1u);
  v12 = NodeBitmap;
  if (NodeBitmap == (HGBitmap *)Buffer && NodeBitmap != 0)
    HGRenderer::DotLogInplaceRendering(v4, v9);
  if (v12)
    v14 = v12 == (HGBitmap *)Buffer;
  else
    v14 = 1;
  if (v14)
  {
    if (!v12)
    {
      HGGPURenderer::ClearMetal(v4, (HGBitmap *)Buffer, *((HGRect *)a2 + 1), v11);
      goto LABEL_19;
    }
  }
  else
  {
    v15 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v4, *((HGRect *)a2 + 1), v12);
    HGGPURenderer::CopyMetal(v4, (HGBitmap *)Buffer, *((HGRect *)a2 + 1), v15);
    (*(void (**)(HGBitmap *))(*(_QWORD *)v15 + 24))(v15);
  }
  (*(void (**)(HGBitmap *))(*(_QWORD *)v12 + 24))(v12);
LABEL_19:
  v16 = a2[2];
  v17 = a2[3];
  DOD = HGRenderer::GetDOD(v4, Input);
  v20 = HGRectIntersection(v16, v17, DOD, v19);
  v22 = v21;
  v23 = *(float *)(a1 + 416);
  if (HGNode::DoInplaceHardwareBlending(Input, v4, (HGNode *)a1, v23))
  {
    v24 = HGBlendingInfo::Get((HGBlendingInfo *)*(unsigned int *)(a1 + 424));
    (*(void (**)(HGNode *))(*(_QWORD *)Input + 240))(Input);
    (*(void (**)(HGNode *, uint64_t))(*(_QWORD *)Input + 248))(Input, v24);
    (*(void (**)(HGNode *, float))(*(_QWORD *)Input + 280))(Input, *(float *)(a1 + 416));
    (*(void (**)(HGNode *, uint64_t))(*(_QWORD *)Input + 264))(Input, a1 + 496);
    *(_QWORD *)&v48.var0 = v20;
    *(_QWORD *)&v48.var2 = v22;
    v25 = HGGPURenderer::GetNodeBitmap(v4, Input, v48, (HGBuffer *)Buffer, 1u);
    HGNode::DisableInplaceHardwareBlending(Input);
    HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 1);
    v26 = 0;
    if (!v25)
    {
LABEL_29:
      if (!v25)
        return Buffer;
      goto LABEL_34;
    }
  }
  else
  {
    v26 = v23 != 1.0;
    *(_QWORD *)&v49.var0 = v20;
    *(_QWORD *)&v49.var2 = v22;
    v25 = HGGPURenderer::GetNodeBitmap(v4, Input, v49, 0, 1u);
    if (!v25)
      goto LABEL_29;
  }
  if (v25 == (HGBitmap *)Buffer)
    goto LABEL_29;
  (*(void (**)(HGRenderer *, _QWORD))(*(_QWORD *)v4 + 144))(v4, 0);
  v27 = (char *)HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v4, *((HGRect *)a2 + 1), v25);
  if (v26)
  {
    v28 = (*(uint64_t (**)(uint64_t, HGRenderer *))(*(_QWORD *)a1 + 608))(a1, v4);
    v45 = (HGBitmap *)v27;
    if (!v28
      || (v29 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)*a2 + 376))(*a2, v28, a1)) == 0)
    {
      v30 = 0;
      (*(void (**)(HGRenderer *, uint64_t))(*(_QWORD *)v4 + 128))(v4, 46);
      goto LABEL_50;
    }
    v31 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)v4 + 128))(v4, 46);
    if (!v30)
    {
LABEL_50:
      (*(void (**)(uint64_t, _QWORD *, _QWORD, std::string *))(*(_QWORD *)a1 + 496))(a1, a2, 0, v30);
      v27 = (char *)v45;
      if (!v45)
        goto LABEL_33;
      goto LABEL_32;
    }
    v44 = v31;
    __src = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    v34 = strlen(__src);
    if (v34 >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v35 = v34;
    v43 = v20;
    if (v34 >= 0x17)
    {
      v37 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v34 | 7) != 0x17)
        v37 = v34 | 7;
      v41 = v22;
      v38 = v37 + 1;
      p_dst = (std::string *)operator new(v37 + 1);
      v39 = v38 | 0x8000000000000000;
      v22 = v41;
      __dst.__r_.__value_.__l.__size_ = v35;
      __dst.__r_.__value_.__r.__words[2] = v39;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v34;
      p_dst = &__dst;
      if (!v34)
        goto LABEL_45;
    }
    memmove(p_dst, __src, v35);
LABEL_45:
    p_dst->__r_.__value_.__s.__data_[v35] = 0;
    HGMetalHandler::SetDebugLabel(v30, &__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
    HGMetalHandler::EnableBlending((uint64_t)v30);
    v40 = (const HGBlendingInfo *)HGBlendingInfo::Get((HGBlendingInfo *)*(unsigned int *)(a1 + 424));
    HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v30, v40);
    HGMetalHandler::SetBlendingColor((__n128 *)v30, (__n128 *)(a1 + 496));
    (*(void (**)(std::string *, _QWORD, float, float, float, float))(v30->__r_.__value_.__r.__words[0] + 136))(v30, 0, *(float *)(a1 + 416), *(float *)(a1 + 416), *(float *)(a1 + 416), *(float *)(a1 + 416));
    HGMetalHandler::BindBuffer((HGMetalHandler *)v30, (HGBitmap *)Buffer);
    HGMetalHandler::BindTexture((HGMetalTexture ***)v30, 0, v45);
    *(_QWORD *)&v47.var0 = v43;
    *(_QWORD *)&v47.var2 = v22;
    HGMetalHandler::InitTextureUnit((HGMetalHandler *)v30, v47, 0);
    HGHandler::TexCoord((HGHandler *)v30, 0, 0, 0, 0);
    (*(void (**)(std::string *, _QWORD, _QWORD))(v30->__r_.__value_.__r.__words[0] + 72))(v30, 0, 0);
    (*(void (**)(std::string *, _QWORD, _QWORD))(v30->__r_.__value_.__r.__words[0] + 48))(v30, 0, 0);
    if (!v44)
      (*(void (**)(std::string *))(v30->__r_.__value_.__r.__words[0] + 168))(v30);
    (*(void (**)(std::string *))(v30->__r_.__value_.__r.__words[0] + 40))(v30);
    (*(void (**)(std::string *, uint64_t, uint64_t, uint64_t))(v30->__r_.__value_.__r.__words[0] + 192))(v30, v43, v22, 1);
    goto LABEL_50;
  }
  v32 = (const HGBlendingInfo *)HGBlendingInfo::Get((HGBlendingInfo *)*(unsigned int *)(a1 + 424));
  *(_QWORD *)&v50.var0 = v20;
  *(_QWORD *)&v50.var2 = v22;
  HGGPURenderer::CopyMetal(v4, (HGBitmap *)Buffer, v50, v27, v32, (__n128 *)(a1 + 496), 1);
  if (v27)
LABEL_32:
    (*(void (**)(char *))(*(_QWORD *)v27 + 24))(v27);
LABEL_33:
  HGRenderer::DotLogHWBlending(v4, Input, (HGNode *)a1, 0);
LABEL_34:
  (*(void (**)(HGBitmap *))(*(_QWORD *)v25 + 24))(v25);
  return Buffer;
}

void sub_1B29FEAF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double HGShaderBinding::reset(HGShaderBinding *this)
{
  double result;

  *((_DWORD *)this + 8) = 0;
  result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

BOOL HGLimits::isfragment(HGLimits *this)
{
  return (*(_DWORD *)this & 0xF0000) == 393216;
}

uint64_t HGLimits::isarb(HGLimits *this)
{
  if ((*(_DWORD *)this & 0xFF00u) - 768 >= 0x101)
    return 0;
  else
    return *(_DWORD *)this & 0xF0000;
}

uint64_t HGLimits::isarbfp(HGLimits *this)
{
  unsigned int v1;

  v1 = *(_DWORD *)this & 0xFFFFF;
  if (v1 - 394000 >= 0x131)
    return 0;
  else
    return v1;
}

uint64_t HGLimits::isglfs(HGLimits *this)
{
  unsigned int v1;

  v1 = *(_DWORD *)this & 0xFFFFF;
  if (v1 - 394768 >= 0x11)
    return 0;
  else
    return v1;
}

uint64_t HGLimits::ismetal(HGLimits *this)
{
  if ((*(_DWORD *)this & 0xFFFFF) == 0x60B10)
    return 396048;
  else
    return 0;
}

BOOL HGLimits::issafe(HGLimits *this)
{
  return (*((_BYTE *)this + 7) & 1) == 0;
}

uint64_t HGLimits::isenv(HGLimits *this)
{
  return (*((_DWORD *)this + 1) >> 27) & 1;
}

uint64_t HGLimits::setnormalized(uint64_t this, int a2)
{
  int v2;

  if (a2)
    v2 = 0x800000;
  else
    v2 = 0;
  *(_DWORD *)(this + 4) = *(_DWORD *)(this + 4) & 0xFF7FFFFF | v2;
  return this;
}

BOOL HGLimits::texturerect(HGLimits *this)
{
  return ((*((_DWORD *)this + 1) >> 23) & 1) == 0;
}

unsigned __int8 *HGString::target(HGString *this, const char *a2)
{
  int v2;
  unsigned __int8 *result;
  const char *v5;
  unsigned int v7;

  v2 = (int)a2;
  v7 = 0;
  result = header((const char *)this, &v7);
  if (result)
  {
    if (v2)
    {
      v5 = (char *)this + 33;
      if (!strncmp(v5, "OPTION NV_fragment_program; \n", 0x1DuLL))
        return (unsigned __int8 *)394256;
      if (!strncmp(v5, "OPTION NV_fragment_program2;\n", 0x1DuLL))
        return (unsigned __int8 *)394272;
      if (!strncmp(v5, "OPTION NV_vertex_program2;  \n", 0x1DuLL))
        return (unsigned __int8 *)328736;
      if (!strncmp(v5, "OPTION NV_vertex_program3;  \n", 0x1DuLL))
        return (unsigned __int8 *)328752;
    }
    return (unsigned __int8 *)v7;
  }
  return result;
}

unsigned __int8 *header(const char *__s1, unsigned int *a2)
{
  int v2;
  const char *v4;
  unsigned __int8 *v5;
  unsigned int v6;
  char v7;
  int v8;
  const char *v9;
  int v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  unsigned __int8 *result;
  unsigned __int8 *v25;
  int v26;
  int v27;
  unsigned __int8 *v28;
  int v29;
  int v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  int v34;
  int v35;

  v2 = *(unsigned __int8 *)__s1;
  if (!*__s1)
    return 0;
  v4 = __s1;
  if (v2 != 33 && v2 != 47)
  {
    while (1)
    {
      if ((v2 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          v8 = *(unsigned __int8 *)++v4;
          v2 = v8;
        }
        while ((v8 - 33) > 0xFFFFFFDF);
      }
      if (v2 != 35)
        break;
      v9 = v4;
      do
      {
        v10 = *(unsigned __int8 *)++v9;
        v2 = v10;
        if (!v10)
          return 0;
        v11 = *(unsigned __int8 *)v4;
        v4 = v9;
      }
      while (v11 != 10);
      v4 = v9;
    }
    if (!v2)
      return 0;
  }
  if (v2 == 47)
  {
    v5 = (unsigned __int8 *)(v4 + 6);
    if (!strncmp(v4, "//GLfs", 6uLL))
    {
      v7 = 0;
      v6 = 394752;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//GLvs", 6uLL))
    {
      v7 = 0;
      v6 = 329216;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//GLps", 6uLL))
    {
      v7 = 0;
      v6 = 132608;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//GLus", 6uLL))
    {
      v7 = 0;
      v6 = 460288;
      goto LABEL_49;
    }
    if (!strncmp(v4, "//CGfs", 6uLL))
    {
      v7 = 0;
      v6 = 395008;
    }
    else
    {
      if (strncmp(v4, "//CGvs", 6uLL))
      {
        if (!strncmp(v4, "//Metal", 7uLL))
        {
          v7 = 0;
          v5 = (unsigned __int8 *)(v4 + 7);
          v6 = 396032;
          goto LABEL_49;
        }
        return 0;
      }
      v7 = 0;
      v6 = 329472;
    }
  }
  else
  {
    if (v2 != 33)
      return 0;
    v5 = (unsigned __int8 *)(v4 + 7);
    if (!strncmp(v4, "!!ARBfp", 7uLL))
    {
      v7 = 0;
      v6 = 393984;
      goto LABEL_49;
    }
    if (!strncmp(v4, "!!NVfp", 6uLL))
    {
      v7 = 0;
      v6 = 394240;
      goto LABEL_48;
    }
    v6 = 328704;
    if (!strncmp(v4, "!!ARBvp", 7uLL))
    {
      v7 = 0;
      v6 = 328448;
      goto LABEL_49;
    }
    if (!strncmp(v4, "!!NVvp", 6uLL))
    {
      v7 = 0;
      goto LABEL_48;
    }
    if (!strncmp(v4, "!!NVgp", 6uLL))
    {
      v7 = 0;
      v6 = 197632;
      goto LABEL_48;
    }
    if (!strncmp(v4, "!!VP", 4uLL))
    {
      v7 = 0;
      v5 = (unsigned __int8 *)(v4 + 4);
    }
    else if (!strncmp(v4, "!!FP", 4uLL))
    {
      v6 = 0;
      v7 = 1;
      v5 = (unsigned __int8 *)(v4 + 4);
    }
    else if (!strncmp(v4, "!!VSP", 5uLL))
    {
      v7 = 0;
      v5 = (unsigned __int8 *)(v4 + 5);
      v6 = 263168;
    }
    else
    {
      if (!strncmp(v4, "!!HGfp", 6uLL))
      {
        v7 = 0;
        v6 = 394496;
        goto LABEL_48;
      }
      if (!strncmp(v4, "!!HGvp", 6uLL))
      {
        v7 = 0;
        v6 = 328960;
        goto LABEL_48;
      }
      if (!strncmp(v4, "!!CIfp", 6uLL))
      {
        v7 = 0;
        v6 = 393728;
        goto LABEL_48;
      }
      if (strncmp(v4, "!!SSEfp", 7uLL))
      {
        if (!strncmp(v4, "!!CIsw", 6uLL))
        {
          v7 = 0;
          v6 = 17170944;
          goto LABEL_48;
        }
        if (!strncmp(v4, "!!CIvp", 6uLL))
        {
          v7 = 0;
          v6 = 328192;
          goto LABEL_48;
        }
        if (!strncmp(v4, "!!CIpp", 6uLL))
        {
          v7 = 0;
          v6 = 66048;
LABEL_48:
          v5 = (unsigned __int8 *)(v4 + 6);
          goto LABEL_49;
        }
        return 0;
      }
      v7 = 0;
      v6 = 69599744;
    }
  }
LABEL_49:
  *a2 = v6;
  v12 = *v5;
  if ((v12 - 58) < 0xFFFFFFF6)
  {
    v13 = 0;
    goto LABEL_66;
  }
  v14 = 0;
  v13 = v5 + 1;
  do
  {
    v14 = v12 + 10 * v14 - 48;
    v15 = *v13++;
    v12 = v15;
  }
  while ((v15 - 58) > 0xFFFFFFF5);
  if ((v7 & 1) != 0)
  {
    v6 = 0;
    if (v12 != 46)
      goto LABEL_55;
LABEL_58:
    v16 = *v13;
    if ((v16 - 58) >= 0xFFFFFFF6)
    {
      v17 = 0;
      do
      {
        v17 = v16 + 10 * v17 - 48;
        v18 = *++v13;
        v16 = v18;
      }
      while ((v18 - 58) > 0xFFFFFFF5);
      if (!v6)
        goto LABEL_65;
      v6 += v17;
      *a2 = v6;
      if (v6 <= 0xFF)
        goto LABEL_65;
    }
    else
    {
      v13 = 0;
      if (v6 <= 0xFF)
        goto LABEL_65;
    }
    goto LABEL_66;
  }
  v6 += 16 * v14;
  *a2 = v6;
  if (*(v13 - 1) == 46)
    goto LABEL_58;
LABEL_55:
  --v13;
  if (v6 <= 0xFF)
  {
LABEL_65:
    *a2 = 394240;
    goto LABEL_78;
  }
LABEL_66:
  if ((v6 & 0x600) != 0)
  {
    while (1)
    {
      do
      {
LABEL_78:
        result = v13;
        v25 = v13 + 1;
        v26 = *v13++;
      }
      while ((v26 - 33) >= 0xFFFFFFE0);
      if (v26 != 47)
        goto LABEL_109;
      v27 = *v25;
      if (v27 == 42)
      {
        v13 = result + 2;
        if (result[2])
        {
          do
          {
            if (*(v25 - 1) == 42 && *v25 == 47)
              break;
            v30 = v25[2];
            ++v25;
          }
          while (v30);
          v13 = v25 + 1;
        }
      }
      else
      {
        if (v27 != 47)
          return result;
        v28 = result + 2;
        while (*v28)
        {
          v29 = *(v28 - 1);
          v13 = v28++;
          if (v29 == 10)
            goto LABEL_78;
        }
        v13 = v28;
      }
    }
  }
  if ((v6 & 0xB00) != 0)
  {
    while (1)
    {
      do
      {
LABEL_95:
        result = v13;
        v31 = v13 + 1;
        v26 = *v13++;
      }
      while ((v26 - 33) >= 0xFFFFFFE0);
      if (v26 != 47)
        break;
      v32 = *v31;
      if (v32 == 42)
      {
        v13 = result + 2;
        if (result[2])
        {
          do
          {
            if (*(v31 - 1) == 42 && *v31 == 47)
              break;
            v35 = v31[2];
            ++v31;
          }
          while (v35);
          v13 = v31 + 1;
        }
      }
      else
      {
        if (v32 != 47)
          return result;
        v33 = result + 2;
        while (*v33)
        {
          v34 = *(v33 - 1);
          v13 = v33++;
          if (v34 == 10)
            goto LABEL_95;
        }
        v13 = v33;
      }
    }
LABEL_109:
    if (!v26)
      return 0;
    return result;
  }
  v19 = *v13;
  if (!*v13)
    return 0;
  if ((v19 - 33) >= 0xE0u)
  {
    do
    {
LABEL_70:
      v20 = *++v13;
      v19 = v20;
    }
    while ((v20 - 33) > 0xDFu);
  }
LABEL_71:
  if (v19 == 35)
  {
    v21 = v13;
    while (1)
    {
      v22 = *++v21;
      v19 = v22;
      if (!v22)
        return 0;
      v23 = *v13;
      v13 = v21;
      if (v23 == 10)
      {
        v13 = v21;
        if ((v19 - 33) >= 0xE0u)
          goto LABEL_70;
        goto LABEL_71;
      }
    }
  }
  if (v19)
    return v13;
  else
    return 0;
}

uint64_t HGString::isdistilled(HGString *this, const char *a2)
{
  int v3;
  const char *v4;
  char *v5;
  uint8x8_t v6;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int8x8_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  int v28;
  unsigned __int8 v29;
  int v30;

  v3 = *(unsigned __int8 *)this;
  if (v3 != 47 && v3 != 33)
    return 0;
  if (!*((_BYTE *)this + 1))
    return 0;
  if (!*((_BYTE *)this + 2))
    return 0;
  if (!*((_BYTE *)this + 3))
    return 0;
  if (!*((_BYTE *)this + 4))
    return 0;
  if (!*((_BYTE *)this + 5))
    return 0;
  if (!*((_BYTE *)this + 6))
    return 0;
  if (!*((_BYTE *)this + 7))
    return 0;
  if (!*((_BYTE *)this + 8))
    return 0;
  if (!*((_BYTE *)this + 9))
    return 0;
  if (!*((_BYTE *)this + 10))
    return 0;
  if (!*((_BYTE *)this + 11))
    return 0;
  if (!*((_BYTE *)this + 12))
    return 0;
  if (!*((_BYTE *)this + 13))
    return 0;
  if (!*((_BYTE *)this + 14))
    return 0;
  if (!*((_BYTE *)this + 15))
    return 0;
  if (!*((_BYTE *)this + 16))
    return 0;
  if (!*((_BYTE *)this + 17))
    return 0;
  v30 = *((unsigned __int8 *)this + 16);
  if (strncmp((const char *)this + 18, "LEN=", 4uLL))
    return 0;
  v8 = *((char *)this + 24);
  if (v8 <= 96)
    v9 = 0;
  else
    v9 = 9;
  v10 = v9 + v8;
  v6.i32[0] = *(_DWORD *)((char *)this + 25);
  v11 = (int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v6));
  v12 = vshrq_n_s32(vshlq_n_s32(v11, 0x18uLL), 0x18uLL);
  v13.i64[0] = 0x6000000060;
  v13.i64[1] = 0x6000000060;
  v14 = (int8x16_t)vcgtq_s32(v12, v13);
  v12.i32[0] = v11.i32[0];
  v15 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vaddq_s32(v12, (int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B309D9B0)), (uint32x4_t)xmmword_1B309D9C0), (int32x4_t)xmmword_1B309D9D0);
  v16 = *((char *)this + 29);
  if (v16 <= 96)
    v17 = 0;
  else
    v17 = -39;
  v18 = ((v16 + v17) << 8) - 12288;
  v19 = *((char *)this + 30);
  if (v19 <= 96)
    v20 = 0;
  else
    v20 = -39;
  v21 = 16 * (v19 + v20) - 768;
  v22 = *((char *)this + 31);
  if (v22 <= 96)
    v23 = 0;
  else
    v23 = -39;
  v24 = vorr_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
  v25 = v24.i32[0] | v24.i32[1] | (v10 << 28) | v18 | v21 | (v22 + v23 - 48);
  if (!(_DWORD)v25
    || !*((_BYTE *)this + v25) && *((unsigned __int8 *)this + v25 - 138) != v30
    || (v26 = (char *)this + v25 - 136, v27 = v25, v28 = strncmp(v26, "MD5=", 4uLL), result = v27, v28))
  {
    v29 = atomic_load(HGLogger::_enabled);
    if ((v29 & 1) != 0)
      HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"Helium WARNING -- Shader string has incorrect LEN or missing MD5.\n", v4, v5);
    return 0;
  }
  return result;
}

uint64_t HGString::_distill(HGString *this, char *__s1, unsigned int a3)
{
  char *v3;
  int v5;
  int v7;
  const char *v8;
  int v9;
  const char *v10;
  int v11;
  int v12;
  const char *v13;
  int v14;
  const char *v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  unsigned int v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  unsigned __int8 *v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  int v28;
  char *v29;
  int v30;
  int v31;
  unsigned __int8 *v32;
  const char *v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  int v36;
  int v37;
  unsigned __int8 *v38;
  int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  int v43;
  unsigned __int8 *v44;
  int v45;
  const char *v46;
  const char *v47;
  int v48;
  unsigned __int8 *v49;
  int v50;
  const char *v51;
  int v52;
  const char *v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  const char *v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  int v70;
  unsigned int v71;
  const char *v72;
  const char *v73;
  const char *j;
  const char *v75;
  char *v76;
  int v77;
  const char *v78;
  int v79;
  const char *v80;
  int v81;
  uint64_t v83;
  const char *v84;
  const char *v85;
  const char *v86;
  unsigned int v87;
  unsigned __int8 *v88;
  unsigned __int8 *v89;
  const char *v90;
  int v91;
  _BYTE *v92;
  uint64_t v93;
  unsigned int v94;
  int v95;
  int v96;
  unsigned __int8 *v97;
  int v98;
  unsigned __int8 *v99;
  int v100;
  int v101;
  unsigned __int8 *v102;
  unsigned int v103;
  unsigned int v104;
  unint64_t v105;
  __int128 *p_dst;
  int v107;
  __int16 v108;
  unsigned int *v109;
  int v110;
  unsigned int v111;
  unsigned int v112;
  int v113;
  int v114;
  unsigned __int8 *v115;
  int v116;
  __int16 v117;
  int v118;
  uint64_t v119;
  int v120;
  unsigned __int8 *v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  char v125;
  uint64_t v126;
  int v127;
  int v128;
  unsigned __int8 *v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  const char *v135;
  int v136;
  __int16 v137;
  int v138;
  char v139;
  const char *v140;
  unsigned __int8 *v141;
  int v142;
  unsigned __int8 *v143;
  int v144;
  int v145;
  unsigned __int8 *v146;
  int v147;
  char v148;
  int v149;
  int v150;
  int v151;
  int v152;
  unsigned int v153;
  BOOL v154;
  uint64_t v155;
  uint64_t v156;
  unint64_t v157;
  void *v158;
  unint64_t *v159;
  uint64_t v160;
  _DWORD *v161;
  uint64_t v162;
  uint64_t v163;
  unint64_t v164;
  void *v165;
  unint64_t *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  void *v171;
  _QWORD *v172;
  uint64_t v173;
  signed int v174;
  uint64_t v175;
  uint64_t v176;
  unint64_t v177;
  void *v178;
  unint64_t *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  void *v183;
  _QWORD *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t v188;
  void *v189;
  _QWORD *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  unint64_t v194;
  void *v195;
  unint64_t *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unint64_t v201;
  size_t v202;
  void *v203;
  size_t *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  unint64_t v208;
  void *v209;
  _QWORD *v210;
  uint64_t v211;
  size_t v212;
  int *v213;
  double v214;
  double v215;
  uint32x4_t v216;
  size_t v217;
  uint64_t v218;
  unsigned __int8 *v219;
  unsigned __int8 *v220;
  int v221;
  int v222;
  unsigned __int8 *v223;
  int v224;
  int v225;
  unsigned __int8 *v226;
  int v227;
  char *v228;
  int v229;
  int v230;
  unsigned int v231;
  unsigned __int8 *v232;
  unsigned __int8 *v233;
  unsigned __int8 *v234;
  int v235;
  unsigned __int8 *v236;
  int v237;
  unsigned __int8 *v238;
  int v239;
  int v240;
  uint64_t v241;
  unsigned __int8 *v242;
  unsigned int v243;
  unsigned int *v244;
  unsigned int *v245;
  unsigned int *v246;
  unsigned int *v247;
  unsigned int v248;
  int v249;
  unsigned __int8 *v250;
  unsigned __int8 *v251;
  int v252;
  unsigned __int8 *v253;
  int v254;
  int v255;
  int v256;
  int v257;
  unsigned __int8 *v258;
  unsigned int v259;
  unsigned __int8 *v260;
  int v261;
  unsigned __int8 *v262;
  int v263;
  int v264;
  unsigned __int8 *v265;
  unsigned int v266;
  unsigned __int8 *v267;
  unsigned __int16 v268;
  int v269;
  int v270;
  unsigned __int8 *v271;
  int v272;
  int v273;
  unsigned __int8 *v274;
  unsigned __int8 *v275;
  unsigned __int16 v276;
  int v277;
  unsigned __int8 v278;
  int v279;
  unsigned __int8 *v280;
  int v281;
  int v282;
  unsigned __int8 *v283;
  int v284;
  unsigned __int8 *v285;
  unsigned __int16 v286;
  int v287;
  unsigned __int16 v288;
  int v289;
  int v290;
  unsigned __int8 *v291;
  unsigned int v292;
  int v293;
  int v294;
  unsigned __int8 *v295;
  int v296;
  int v297;
  uint64_t v298;
  uint64_t v299;
  unint64_t v300;
  void *v301;
  unint64_t *v302;
  void *v303;
  unint64_t *v304;
  uint64_t v305;
  uint64_t v306;
  __int16 v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  unint64_t v311;
  void *v312;
  unint64_t *v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  unint64_t v317;
  void *v318;
  _QWORD *v319;
  uint64_t v320;
  signed int v321;
  uint64_t v322;
  uint64_t v323;
  unint64_t v324;
  void *v325;
  unint64_t *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  void *v330;
  _QWORD *v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  unint64_t v335;
  void *v336;
  _QWORD *v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  unint64_t v341;
  void *v342;
  unint64_t *v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  unint64_t v348;
  size_t v349;
  void *v350;
  size_t *v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  unint64_t v355;
  void *v356;
  _QWORD *v357;
  uint64_t v358;
  size_t v359;
  int *v360;
  double v361;
  double v362;
  uint32x4_t v363;
  size_t v364;
  unsigned __int8 *v366;
  unint64_t *v367;
  char *v368;
  unsigned int v369;
  unsigned int v370;
  unsigned int v371;
  void *v372;
  int v373;
  int v374;
  int v375;
  const char *i;
  int v377;
  int v378;
  const char *v379;
  int v380;
  int v381;
  uint64_t v382;
  int v383;
  char v384;
  int v385;
  char v386;
  int v387;
  int v388;
  char v389;
  int v390;
  int v391;
  char v392;
  int v393;
  int v394;
  char v395;
  int v396;
  int v397;
  char v398;
  int v399;
  int v400;
  char v401;
  int v402;
  int v403;
  void *v404;
  arb *v405;
  char v406;
  int v407;
  void *v408;
  arb *v409;
  int v410;
  char v411;
  int v412;
  int v413;
  int v414;
  int v415;
  int v416;
  void *v417;
  unsigned __int8 *v418;
  int v419;
  int v420;
  int v421;
  unsigned __int8 *v422;
  int v423;
  arb *v424;
  int v425;
  const char *v426;
  const char *v427;
  size_t v428;
  int v429;
  unint64_t *v430;
  arb *v431;
  unsigned __int8 *v432;
  int v433;
  int v434;
  uint64_t v435;
  int v436;
  int v437;
  int v438;
  int v439;
  unsigned __int8 *v440;
  int v441;
  int v442;
  int v443;
  _BYTE *v444;
  int v445;
  int v446;
  unsigned __int8 *v447;
  unsigned __int8 *v448;
  int v449;
  int v450;
  int v451;
  unsigned __int8 *v452;
  int v453;
  int v454;
  unsigned __int8 *v455;
  int v456;
  int v457;
  int v458;
  int v459;
  unsigned __int8 *v460;
  int v461;
  char *v462;
  const char **v463;
  int v464;
  int v465;
  int v466;
  unsigned __int8 *v467;
  char *v468;
  char *v469;
  _BYTE *v470;
  unsigned __int8 *v475;
  char *v476;
  int v477;
  int v478;
  unsigned __int8 *v479;
  int v480;
  int v481;
  int v482;
  arb *v483;
  int v484;
  int v485;
  int v486;
  int v487;
  int v488;
  int v489;
  int v491;
  _BYTE *v492;
  int v493;
  int v494;
  int v495;
  int v496;
  int v497;
  int v498;
  _BYTE *v499;
  int v500;
  int v501;
  BOOL v502;
  int v503;
  unsigned __int8 *v504;
  char *v505;
  const char *v506;
  int v507;
  int v508;
  unsigned __int8 *v509;
  unsigned __int8 *v510;
  int v511;
  int v512;
  unsigned __int8 *v513;
  unsigned __int8 *v514;
  const char *v515;
  int v516;
  int v517;
  const char *v518;
  int v519;
  int v520;
  const char **v521;
  int v522;
  unsigned __int8 *v523;
  int v524;
  unsigned __int8 *v525;
  int v526;
  int v527;
  int v528;
  unsigned __int8 *v529;
  int v530;
  char v531;
  unsigned __int8 *v532;
  int v533;
  int v534;
  int v535;
  char v536;
  unsigned __int8 *v537;
  int v538;
  int v539;
  _BOOL4 v543;
  uint64_t v544;
  uint64_t v545;
  int v546;
  char *v547;
  unsigned __int8 *v548;
  int v549;
  int v550;
  char *v551;
  int v552;
  unsigned __int8 *v553;
  int v554;
  int v555;
  int v556;
  int v557;
  int v558;
  int v559;
  char v560;
  unsigned __int8 *v561;
  int v562;
  int v563;
  int v564;
  char *v565;
  char *v566;
  unint64_t v567;
  unint64_t v568;
  uint64_t v569;
  unint64_t v570;
  int v571;
  unsigned __int8 *v572;
  int v573;
  int v574;
  int v575;
  int v576;
  int v577;
  _BYTE *v578;
  int v579;
  unsigned int v580;
  int v581;
  int v582;
  int v583;
  int v584;
  _BYTE *v585;
  int v586;
  int v587;
  int v588;
  int v589;
  const char *v590;
  int v591;
  int v592;
  int v593;
  arb *v594;
  _BYTE *v595;
  const char *v596;
  const char *v597;
  const char *v598;
  const char *v599;
  _BYTE *v600;
  int v601;
  const char *v602;
  arb *v603;
  unint64_t *v604;
  char *v605;
  char *v606;
  const char *v607;
  const char *v608;
  uint64_t v609;
  int v610;
  char *v611;
  unsigned int v612;
  size_t v613;
  int *v614;
  double v615;
  double v616;
  uint32x4_t v617;
  size_t v618;
  char *ptr;
  unint64_t v620;
  unint64_t v621;
  char *v622;
  unint64_t v623;
  char *v624;
  unint64_t v625;
  unint64_t v626;
  unsigned int v627;
  char *v628;
  char *v629;
  unsigned int v630;
  uint64_t v631;
  unsigned int v632;
  unsigned int v633;
  int v634;
  int v635;
  __int16 v636;
  arb *v637;
  arb *v638;
  arb *v639;
  arb *v640;
  char __n;
  unsigned __int16 __na;
  void *__nb;
  size_t __nc;
  char *__nd;
  char *__ne;
  unsigned int v647[4];
  __int128 v648;
  __int128 v649;
  void *v650[2];
  __int128 v651;
  __int128 v652;
  __int128 v653;
  int v654;
  char *v655;
  char *v656;
  __int128 __dst;
  unint64_t v658;
  __int128 __s1a;
  unint64_t v660;
  uint64_t v661;

  v3 = __s1;
  v661 = *MEMORY[0x1E0C80C00];
  v652 = 0u;
  v653 = 0u;
  *(_OWORD *)v650 = 0u;
  v651 = 0u;
  v648 = 0u;
  v649 = 0u;
  *(_OWORD *)v647 = 0u;
  v5 = *__s1;
  if (*__s1)
  {
    v7 = *__s1;
    v8 = __s1;
    if ((v5 - 33) < 0xFFFFFFE0)
      goto LABEL_4;
    do
    {
LABEL_3:
      v9 = *(unsigned __int8 *)++v8;
      v7 = v9;
    }
    while ((v9 - 33) > 0xFFFFFFDF);
LABEL_4:
    while (v7 == 35)
    {
      v10 = v8;
      do
      {
        v11 = *(unsigned __int8 *)++v10;
        v7 = v11;
        if (!v11)
          goto LABEL_19;
        v12 = *(unsigned __int8 *)v8;
        v8 = v10;
      }
      while (v12 != 10);
      v8 = v10;
      if ((v7 - 33) >= 0xFFFFFFE0)
        goto LABEL_3;
    }
    if (v7 == 33)
    {
      v654 = 0;
      *(_QWORD *)&v653 = 0;
      DWORD2(v653) = 0;
      v13 = __s1;
      *((_QWORD *)&v651 + 1) = 0;
      *(_QWORD *)&v652 = 0;
      if ((v5 - 33) < 0xFFFFFFE0)
        goto LABEL_13;
      do
      {
LABEL_12:
        v14 = *(unsigned __int8 *)++v13;
        v5 = v14;
      }
      while ((v14 - 33) > 0xFFFFFFDF);
LABEL_13:
      while (v5 == 35)
      {
        v15 = v13;
        do
        {
          v16 = *(unsigned __int8 *)++v15;
          v5 = v16;
          if (!v16)
            goto LABEL_831;
          v17 = *(unsigned __int8 *)v13;
          v13 = v15;
        }
        while (v17 != 10);
        v13 = v15;
        if ((v5 - 33) >= 0xFFFFFFE0)
          goto LABEL_12;
      }
      if (!v5 || (v366 = header(v13, v647)) == 0)
      {
LABEL_831:
        v218 = 4294967238;
        *((_QWORD *)this + 1) = 0;
        *((_QWORD *)this + 2) = 0;
        *(_QWORD *)this = v3;
        v372 = v650[0];
        if (!v650[0])
          return v218;
        goto LABEL_832;
      }
      v368 = (char *)v366;
      if ((v647[0] & 0xF0000) == 0x50000)
      {
        v369 = 0;
        v371 = 0;
        v647[1] = -1073741824;
        v370 = -939524096;
      }
      else if ((v647[0] & 0xF0000) == 0x60000)
      {
        v647[1] = 0;
        v369 = a3;
        v370 = 0x8000000;
        v371 = 255;
      }
      else
      {
        v369 = 0;
        v371 = 0;
        v647[1] = 0;
        v370 = 0x8000000;
      }
      v647[2] = v371;
      v647[3] = v369;
      if (a3 >= 0x100)
        v647[1] = v370;
      v373 = *v366;
      if (v373 == 35)
      {
        while (v373 == 35)
        {
          ++v368;
          do
          {
            v373 = *v368;
            if (!*v368)
              goto LABEL_846;
            v375 = *(v368++ - 1);
          }
          while (v375 != 10);
          --v368;
          if ((v373 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              v374 = *++v368;
              v373 = v374;
            }
            while ((v374 - 33) > 0xFFFFFFDF);
          }
        }
      }
LABEL_846:
      v634 = 0;
      for (i = v368; ; ++i)
      {
LABEL_849:
        while (1)
        {
          v377 = *(unsigned __int8 *)i;
          if (v377 != 35)
            break;
          while (1)
          {
            if ((v377 - 33) >= 0xFFFFFFE0)
            {
              do
              {
                v378 = *(unsigned __int8 *)++i;
                v377 = v378;
              }
              while ((v378 - 33) > 0xFFFFFFDF);
            }
            if (v377 != 35)
              break;
            v379 = i;
            do
            {
              v380 = *(unsigned __int8 *)++v379;
              v377 = v380;
              if (!v380)
                goto LABEL_861;
              v381 = *(unsigned __int8 *)i;
              i = v379;
            }
            while (v381 != 10);
            i = v379;
          }
          if (!v377)
          {
LABEL_861:
            i = 0;
            goto LABEL_862;
          }
        }
        if ((v377 - 58) < 2)
          break;
        if (!*i)
          goto LABEL_861;
      }
      v414 = *(unsigned __int8 *)++i;
      v413 = v414;
      if (v414)
      {
        if ((v413 - 33) < 0xFFFFFFE0)
          goto LABEL_966;
        do
        {
LABEL_965:
          v415 = *(unsigned __int8 *)++i;
          v413 = v415;
        }
        while ((v415 - 33) > 0xFFFFFFDF);
LABEL_966:
        while (v413 == 35)
        {
          ++i;
          do
          {
            v413 = *(unsigned __int8 *)i;
            if (!*i)
              goto LABEL_862;
            v416 = *((unsigned __int8 *)i++ - 1);
          }
          while (v416 != 10);
          --i;
          if ((v413 - 33) >= 0xFFFFFFE0)
            goto LABEL_965;
        }
      }
LABEL_862:
      if (v368 == i)
      {
        i = v368;
        goto LABEL_848;
      }
      v382 = 0;
      LOBYTE(v383) = *v368;
      v637 = (arb *)((char *)&v648 + 10);
      __nb = &unk_1B309DC66;
      while (2)
      {
        v384 = 0;
        switch((char)v383)
        {
          case 'A':
            if (strncmp(v368, "ATTRIB", 6uLL))
            {
              v417 = arb::obj_alias((uint64_t)v650, v368, (uint64_t)v647);
              goto LABEL_993;
            }
            if ((v647[0] & 0xF0000) == 0x60000)
              v444 = &fragmentKind;
            else
              v444 = &vertexKind;
            if (arb::obj_decl((uint64_t)v650, v444, (arb *)(v368 + 6), v382, (uint64_t)v647))
              goto LABEL_848;
            v218 = 4294967243;
            *((_QWORD *)this + 1) = 0;
            *((_QWORD *)this + 2) = 0;
            *(_QWORD *)this = v3;
            v372 = v650[0];
            if (v650[0])
              goto LABEL_832;
            return v218;
          case 'B':
            if (strncmp(v368, "BUFFER", 6uLL))
              goto LABEL_1076;
            v423 = v368[6];
            v422 = (unsigned __int8 *)(v368 + 6);
            if (v423 == 52)
              v424 = (arb *)(v422 + 1);
            else
              v424 = (arb *)v422;
            if (arb::obj_decl((uint64_t)v650, &bufferKind, v424, v382, (uint64_t)v647))
              goto LABEL_848;
            v218 = 4294967246;
            *((_QWORD *)this + 1) = 0;
            *((_QWORD *)this + 2) = 0;
            *(_QWORD *)this = v3;
            v372 = v650[0];
            if (v650[0])
              goto LABEL_832;
            return v218;
          case 'C':
            if (strncmp(v368, "CENTROID", 8uLL))
              goto LABEL_1076;
            v385 = v368[8];
            v368 += 8;
            LOBYTE(v383) = v385;
            if (!v385)
              goto LABEL_865;
            if ((v383 - 33) >= 0xE0u)
              goto LABEL_870;
            while (1)
            {
              do
              {
                if (v383 != 35)
                  goto LABEL_865;
                ++v368;
                do
                {
                  LOBYTE(v383) = *v368;
                  if (!*v368)
                    goto LABEL_865;
                  v387 = *(v368++ - 1);
                }
                while (v387 != 10);
                --v368;
              }
              while ((v383 - 33) < 0xE0u);
              do
              {
LABEL_870:
                v386 = *++v368;
                LOBYTE(v383) = v386;
              }
              while ((v386 - 33) > 0xDFu);
            }
          case 'D':
            goto LABEL_1072;
          case 'E':
            if (!strncmp(v368, "ENDLOOP", 7uLL) || !strncmp(v368, "ENDREP", 6uLL))
            {
              --v634;
              goto LABEL_848;
            }
            if (strncmp(v368, "END", 3uLL))
              goto LABEL_1076;
            if ((ctype[2 * v368[3]] & 0x40) != 0)
              goto LABEL_848;
            goto LABEL_1410;
          case 'F':
            if (!strncmp(v368, "FLAT", 4uLL))
            {
              v410 = v368[4];
              v368 += 4;
              LOBYTE(v383) = v410;
              if (v410)
              {
                if ((v383 - 33) < 0xE0u)
                  goto LABEL_957;
                do
                {
LABEL_956:
                  v411 = *++v368;
                  LOBYTE(v383) = v411;
                }
                while ((v411 - 33) > 0xDFu);
LABEL_957:
                while (v383 == 35)
                {
                  ++v368;
                  do
                  {
                    LOBYTE(v383) = *v368;
                    if (!*v368)
                      goto LABEL_865;
                    v412 = *(v368++ - 1);
                  }
                  while (v412 != 10);
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                    goto LABEL_956;
                }
              }
            }
            else
            {
              if (strncmp(v368, "FLOAT", 5uLL))
                goto LABEL_1076;
              v400 = v368[5];
              v368 += 5;
              LOBYTE(v383) = v400;
              if (v400)
              {
                if ((v383 - 33) < 0xE0u)
                  goto LABEL_925;
                do
                {
LABEL_924:
                  v401 = *++v368;
                  LOBYTE(v383) = v401;
                }
                while ((v401 - 33) > 0xDFu);
LABEL_925:
                while (v383 == 35)
                {
                  ++v368;
                  do
                  {
                    LOBYTE(v383) = *v368;
                    if (!*v368)
                      goto LABEL_865;
                    v402 = *(v368++ - 1);
                  }
                  while (v402 != 10);
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                    goto LABEL_924;
                }
              }
            }
            goto LABEL_865;
          case 'I':
            if (!strncmp(v368, "INTERPOLATE", 0xBuLL))
              goto LABEL_848;
            if (strncmp(v368, "INT", 3uLL))
            {
              v426 = v368;
              v427 = "IF";
              v428 = 2;
LABEL_1037:
              if (!strncmp(v426, v427, v428))
                goto LABEL_848;
LABEL_1076:
              v384 = 0;
LABEL_1077:
              v425 = *v368;
              if ((ctype[2 * *v368] & 0x40) == 0)
              {
LABEL_1078:
                __nc = 0;
LABEL_1079:
                v448 = (unsigned __int8 *)(v368 - 1);
                do
                {
                  v450 = *++v448;
                  v449 = v450;
                }
                while ((ctype[2 * v450] & 0x40) != 0);
                *(_QWORD *)&__s1a = 0;
                *(_QWORD *)&__dst = 0;
                if (v449)
                {
                  if ((v449 - 33) < 0xFFFFFFE0)
                    goto LABEL_1084;
                  do
                  {
LABEL_1083:
                    v451 = *++v448;
                    v449 = v451;
                  }
                  while ((v451 - 33) > 0xFFFFFFDF);
LABEL_1084:
                  while (v449 == 35)
                  {
                    v452 = v448;
                    do
                    {
                      v453 = *++v452;
                      v449 = v453;
                      if (!v453)
                        goto LABEL_1092;
                      v454 = *v448;
                      v448 = v452;
                    }
                    while (v454 != 10);
                    v448 = v452;
                    if ((v449 - 33) >= 0xFFFFFFE0)
                      goto LABEL_1083;
                  }
                  if (v449 == 58)
                    goto LABEL_1091;
                }
LABEL_1092:
                if ((v384 & 1) != 0)
                {
                  v455 = 0;
                  v456 = *v368;
                  if (v456 == 59)
                  {
                    while (1)
                    {
LABEL_1101:
                      if ((v456 - 33) >= 0xFFFFFFE0)
                      {
                        do
                        {
                          v458 = *++v368;
                          v456 = v458;
                        }
                        while ((v458 - 33) > 0xFFFFFFDF);
                      }
                      if (v456 != 35)
                        break;
                      ++v368;
                      do
                      {
                        v456 = *v368;
                        if (!*v368)
                          goto LABEL_1108;
                        v459 = *(v368++ - 1);
                      }
                      while (v459 != 10);
                      --v368;
                    }
LABEL_1108:
                    if ((v384 & 1) != 0
                      || (v460 = arb::asymbol((arb *)v368, (char *)&__s1a, (const char **)&__dst, v367)) == 0)
                    {
                      v462 = 0;
                      v463 = 0;
                    }
                    else
                    {
                      v461 = *v460;
                      if (*v460 && v461 != 44)
                      {
                        do
                        {
                          if (v461 == 35)
                          {
                            while (v461 == 35)
                            {
                              ++v460;
                              do
                              {
                                v461 = *v460;
                                if (!*v460)
                                  goto LABEL_1112;
                                v488 = *(v460++ - 1);
                              }
                              while (v488 != 10);
                              --v460;
                              if ((v461 - 33) >= 0xFFFFFFE0)
                              {
                                do
                                {
                                  v487 = *++v460;
                                  v461 = v487;
                                }
                                while ((v487 - 33) > 0xFFFFFFDF);
                              }
                            }
                          }
                          else
                          {
                            v489 = *++v460;
                            v461 = v489;
                          }
                        }
                        while (v461 != 44 && v461 != 0);
                      }
LABEL_1112:
                      v462 = (char *)__s1a;
                      v463 = (const char **)__dst;
                      v464 = v460[1];
                      v368 = (char *)(v460 + 1);
                      if (v460[1])
                      {
                        if ((v464 - 33) < 0xFFFFFFE0)
                          goto LABEL_1115;
                        do
                        {
LABEL_1114:
                          v465 = *++v368;
                          v464 = v465;
                        }
                        while ((v465 - 33) > 0xFFFFFFDF);
LABEL_1115:
                        while (v464 == 35)
                        {
                          ++v368;
                          do
                          {
                            v464 = *v368;
                            if (!*v368)
                              goto LABEL_1122;
                            v466 = *(v368++ - 1);
                          }
                          while (v466 != 10);
                          --v368;
                          if ((v464 - 33) >= 0xFFFFFFE0)
                            goto LABEL_1114;
                        }
                      }
                    }
LABEL_1122:
                    v467 = arb::asymbol((arb *)v368, (char *)&__s1a, (const char **)&__dst, v367);
                    if (v467)
                    {
                      if (v455)
                      {
                        v468 = arb::obj_add((uint64_t)v650, (char *)__s1a, (const char **)__dst, (uint64_t)v647, 1);
                        if (v468 && *((_QWORD *)v468 + 5) == (_QWORD)v653 && *((_DWORD *)v468 + 14) == DWORD2(v653))
                          *(_QWORD *)&v653 = 0;
                      }
                      else
                      {
                        v475 = v467;
                        while (1)
                        {
                          v476 = arb::obj_add((uint64_t)v650, (char *)__s1a, (const char **)__dst, (uint64_t)v647, 1);
                          if (v476 && *((_QWORD *)v476 + 5) == (_QWORD)v653 && *((_DWORD *)v476 + 14) == DWORD2(v653))
                            *(_QWORD *)&v653 = 0;
                          v477 = *v475;
                          if (!*v475)
                            goto LABEL_1128;
LABEL_1154:
                          if ((v477 - 33) >= 0xFFFFFFE0)
                          {
                            do
                            {
                              v478 = *++v475;
                              v477 = v478;
                            }
                            while ((v478 - 33) > 0xFFFFFFDF);
                          }
                          if (v477 == 35)
                            break;
                          if (v477 == 44)
                          {
                            v484 = v475[1];
                            v483 = (arb *)(v475 + 1);
                            v482 = v484;
                            if (v484)
                            {
                              if ((v482 - 33) < 0xFFFFFFE0)
                                goto LABEL_1165;
                              do
                              {
LABEL_1164:
                                v485 = *((unsigned __int8 *)v483 + 1);
                                v483 = (arb *)((char *)v483 + 1);
                                v482 = v485;
                              }
                              while ((v485 - 33) > 0xFFFFFFDF);
LABEL_1165:
                              while (v482 == 35)
                              {
                                v483 = (arb *)((char *)v483 + 1);
                                do
                                {
                                  v482 = *(unsigned __int8 *)v483;
                                  if (!*(_BYTE *)v483)
                                    goto LABEL_1171;
                                  v486 = *((unsigned __int8 *)v483 - 1);
                                  v483 = (arb *)((char *)v483 + 1);
                                }
                                while (v486 != 10);
                                v483 = (arb *)((char *)v483 - 1);
                                if ((v482 - 33) >= 0xFFFFFFE0)
                                  goto LABEL_1164;
                              }
                            }
LABEL_1171:
                            v475 = arb::asymbol(v483, (char *)&__s1a, (const char **)&__dst, v367);
                            if (v475)
                              continue;
                          }
                          goto LABEL_1128;
                        }
                        v479 = v475;
                        while (1)
                        {
                          v480 = *++v475;
                          v477 = v480;
                          if (!v480)
                            break;
                          v481 = *v479;
                          v479 = v475;
                          if (v481 == 10)
                            goto LABEL_1154;
                        }
                      }
                    }
LABEL_1128:
                    if (v462)
                    {
                      v469 = arb::obj_add((uint64_t)v650, v462, v463, (uint64_t)v647, 1);
                      if (v469)
                      {
                        v470 = (_BYTE *)*((_QWORD *)v469 + 5);
                        if (v470 == (_BYTE *)v653 && *((_DWORD *)v469 + 14) == DWORD2(v653))
                          *(_QWORD *)&v653 = 0;
                        if (v470 != (_BYTE *)&longKind
                          && v470 != (_BYTE *)&unk_1B309DC66
                          && v470 != (_BYTE *)&shortKind
                          && v470 == outputKind
                          && __nc != 0)
                        {
                          HIDWORD(v653) = 1;
                        }
                      }
                    }
                    goto LABEL_848;
                  }
                }
                else
                {
                  if (!strncmp(v368, "SWZ", 3uLL))
                    v455 = (unsigned __int8 *)(v368 + 3);
                  else
                    v455 = 0;
                  v456 = *v368;
                  if (v456 == 59)
                    goto LABEL_1101;
                }
                do
                {
                  if ((v456 - 33) > 0xFFFFFFDF)
                    break;
                  v457 = *++v368;
                  v456 = v457;
                }
                while (v457 != 59);
                goto LABEL_1101;
              }
LABEL_1213:
              v506 = v368 - 1;
              while (1)
              {
                v507 = v425;
                v425 = *((unsigned __int8 *)v506 + 2);
                if (v507 == 95 && v425 == 83)
                {
                  if (v506[3] == 83)
                  {
                    v509 = (unsigned __int8 *)(v506 + 1);
                    v508 = *(unsigned __int8 *)v506;
                    if ((v508 - 48) >= 2)
                    {
                      __nc = (size_t)(v506 + 1);
                      if (v508 == 67
                        && (strncmp(v506 - 2, "FRC", 3uLL) || (ctype[2 * *((unsigned __int8 *)v506 - 3)] & 0x40) != 0))
                      {
                        v512 = strncmp(v506 - 4, "TRUNC", 5uLL);
                        v513 = (unsigned __int8 *)(v506 + 1);
                        if (v512)
                          v513 = (unsigned __int8 *)v506;
                        __nc = (size_t)v513;
                      }
                    }
                    else
                    {
                      v511 = *((unsigned __int8 *)v506 - 1);
                      v510 = (unsigned __int8 *)(v506 - 1);
                      if (v511 == 67)
                        v509 = v510;
                      __nc = (size_t)v509;
                    }
                    goto LABEL_1079;
                  }
                  v425 = 83;
                }
                ++v506;
                if ((ctype[2 * v425] & 0x40) == 0)
                  goto LABEL_1078;
              }
            }
            v391 = v368[3];
            v368 += 3;
            LOBYTE(v383) = v391;
            if (v391)
            {
              if ((v383 - 33) < 0xE0u)
                goto LABEL_892;
              do
              {
LABEL_891:
                v392 = *++v368;
                LOBYTE(v383) = v392;
              }
              while ((v392 - 33) > 0xDFu);
LABEL_892:
              while (v383 == 35)
              {
                ++v368;
                do
                {
                  LOBYTE(v383) = *v368;
                  if (!*v368)
                    goto LABEL_945;
                  v393 = *(v368++ - 1);
                }
                while (v393 != 10);
                --v368;
                if ((v383 - 33) >= 0xE0u)
                  goto LABEL_891;
              }
            }
LABEL_945:
            v637 = (arb *)((char *)&v648 + 12);
            __nb = &intKind;
            v382 = 3;
            goto LABEL_865;
          case 'K':
            if (strncmp(v368, "KIL", 3uLL))
              goto LABEL_1076;
            v647[1] |= 0x1000000u;
            v384 = 1;
            v425 = *v368;
            if ((ctype[2 * *v368] & 0x40) != 0)
              goto LABEL_1213;
            goto LABEL_1078;
          case 'L':
            if (!strncmp(v368, "LOOP", 4uLL))
              goto LABEL_1027;
            if (strncmp(v368, "LONG", 4uLL))
              goto LABEL_1076;
            v397 = v368[4];
            v368 += 4;
            LOBYTE(v383) = v397;
            if (!v397)
              goto LABEL_946;
            if ((v383 - 33) >= 0xE0u)
              goto LABEL_913;
LABEL_914:
            if (v383 == 35)
            {
              ++v368;
              while (1)
              {
                LOBYTE(v383) = *v368;
                if (!*v368)
                  break;
                v399 = *(v368++ - 1);
                if (v399 == 10)
                {
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                  {
                    do
                    {
LABEL_913:
                      v398 = *++v368;
                      LOBYTE(v383) = v398;
                    }
                    while ((v398 - 33) > 0xDFu);
                  }
                  goto LABEL_914;
                }
              }
            }
LABEL_946:
            if ((v382 & 7u) >= 3uLL)
              v408 = __nb;
            else
              v408 = &longKind;
            v409 = v637;
            if ((v382 & 7u) < 3uLL)
              v409 = (arb *)((char *)&v648 + 11);
            v637 = v409;
            __nb = v408;
            if ((v382 & 7u) < 3uLL)
              v382 = 2;
            goto LABEL_865;
          case 'M':
            v656 = 0;
            *(_QWORD *)&__dst = 0;
            v655 = 0;
            v429 = strncmp(v368, "MULA", 4uLL);
            v431 = (arb *)(v368 + 4);
            if (v429)
              v432 = 0;
            else
              v432 = (unsigned __int8 *)(v368 + 4);
            *(_QWORD *)&__s1a = v432;
            if (v429 || (v433 = *(unsigned __int8 *)v431, (v433 - 33) < 0xFFFFFFE0))
            {
              if (strncmp(i, "MOV", 3uLL) || *((unsigned __int8 *)i + 3) - 33 < 0xFFFFFFE0)
                goto LABEL_1072;
              v434 = strncmp(v368, "MUL", 3uLL);
              v435 = v434 ? 0 : (uint64_t)(v368 + 3);
              *(_QWORD *)&__s1a = v435;
              if (v434 || v368[3] - 33 < 0xFFFFFFE0)
                goto LABEL_1072;
              v436 = *(unsigned __int8 *)v431;
              if (*(_BYTE *)v431)
              {
                if ((v436 - 33) < 0xFFFFFFE0)
                  goto LABEL_1017;
                do
                {
LABEL_1016:
                  v437 = *((unsigned __int8 *)v431 + 1);
                  v431 = (arb *)((char *)v431 + 1);
                  v436 = v437;
                }
                while ((v437 - 33) > 0xFFFFFFDF);
LABEL_1017:
                while (v436 == 35)
                {
                  v431 = (arb *)((char *)v431 + 1);
                  do
                  {
                    v436 = *(unsigned __int8 *)v431;
                    if (!*(_BYTE *)v431)
                      goto LABEL_1231;
                    v438 = *((unsigned __int8 *)v431 - 1);
                    v431 = (arb *)((char *)v431 + 1);
                  }
                  while (v438 != 10);
                  v431 = (arb *)((char *)v431 - 1);
                  if ((v436 - 33) >= 0xFFFFFFE0)
                    goto LABEL_1016;
                }
              }
LABEL_1231:
              v514 = arb::asymbol(v431, (char *)&__dst, (const char **)&v656, v367);
              if (v431 != (arb *)__dst)
                goto LABEL_1072;
              v515 = (const char *)v514;
              __ne = v656;
              if ((unsigned __int8 *)&v656[(_QWORD)v431] != v514)
              {
                v639 = (arb *)(v514 - 4);
                if (strncmp((const char *)v514 - 4, "xyzw", 4uLL))
                {
                  if (strncmp((const char *)v639, "rgba", 4uLL)
                    && strncmp(v515 - 3, "xyzw", 3uLL)
                    && strncmp(v515 - 3, "rgba", 3uLL))
                  {
                    goto LABEL_1072;
                  }
                }
              }
              *(_QWORD *)&__s1a = v515;
              if (!v515)
                goto LABEL_1072;
              v516 = *(unsigned __int8 *)v515;
              if (!*v515)
                goto LABEL_1072;
              if ((v516 - 33) < 0xFFFFFFE0)
                goto LABEL_1241;
              do
              {
LABEL_1240:
                v517 = *(unsigned __int8 *)++v515;
                v516 = v517;
              }
              while ((v517 - 33) > 0xFFFFFFDF);
LABEL_1241:
              while (v516 == 35)
              {
                v518 = v515;
                do
                {
                  v519 = *(unsigned __int8 *)++v518;
                  v516 = v519;
                  if (!v519)
                    goto LABEL_1072;
                  v520 = *(unsigned __int8 *)v515;
                  v515 = v518;
                }
                while (v520 != 10);
                v515 = v518;
                if ((v516 - 33) >= 0xFFFFFFE0)
                  goto LABEL_1240;
              }
              if (v516 != 44)
                goto LABEL_1072;
              v591 = *((unsigned __int8 *)v515 + 1);
              v590 = v515 + 1;
              v589 = v591;
              if (v591)
              {
                if ((v589 - 33) < 0xFFFFFFE0)
                  goto LABEL_1386;
                do
                {
LABEL_1385:
                  v592 = *(unsigned __int8 *)++v590;
                  v589 = v592;
                }
                while ((v592 - 33) > 0xFFFFFFDF);
LABEL_1386:
                while (v589 == 35)
                {
                  ++v590;
                  do
                  {
                    v589 = *(unsigned __int8 *)v590;
                    if (!*v590)
                      goto LABEL_1392;
                    v593 = *((unsigned __int8 *)v590++ - 1);
                  }
                  while (v593 != 10);
                  --v590;
                  if ((v589 - 33) >= 0xFFFFFFE0)
                    goto LABEL_1385;
                }
              }
LABEL_1392:
              if (strncmp(v590, (const char *)v431, (size_t)__ne))
                goto LABEL_1072;
              v594 = (arb *)&__ne[(_QWORD)v590];
              v595 = arb::achr(v594, (const char *)0x2E);
              if (v595)
              {
                v597 = arb::atok(v595, v596);
                if (strncmp(v597, "xyzw", 4uLL) && strncmp(v597, "rgba", 4uLL))
                {
LABEL_1072:
                  if (!(_QWORD)v653 || !arb::isunpremult((uint64_t)v650, v368, (uint64_t)i))
                    goto LABEL_1076;
LABEL_1074:
                  v384 = 0;
                  v647[1] |= 0x10000000u;
                  *(_QWORD *)&v653 = 0;
                  v425 = *v368;
                  if ((ctype[2 * *v368] & 0x40) != 0)
                    goto LABEL_1213;
                  goto LABEL_1078;
                }
                v594 = (arb *)(v597 + 4);
              }
              v598 = arb::achr(v594, (const char *)0x2C);
              if (!v598)
                goto LABEL_1072;
              v599 = v598;
              if (strncmp(v598, (const char *)v431, (size_t)__ne))
                goto LABEL_1072;
              v600 = arb::achr((arb *)&__ne[(_QWORD)v599], (const char *)0x2E);
              *(_QWORD *)&__s1a = v600;
              if (!v600)
                goto LABEL_1072;
              v601 = *v600;
              if (v601 != 119 && v601 != 97)
                goto LABEL_1072;
              if (!arb::achr((arb *)(v600 + 1), (const char *)0x3B))
                goto LABEL_1072;
              v603 = (arb *)arb::atok((_BYTE *)i + 4, v602);
              arb::asymbol(v603, (char *)&__s1a, (const char **)&v655, v604);
              v605 = v655;
              v640 = (arb *)__s1a;
              v606 = arb::obj_add((uint64_t)v650, (char *)__s1a, (const char **)v655, (uint64_t)v647, 1);
              if (!v606)
                goto LABEL_1072;
              if (*((_BYTE **)v606 + 5) != outputKind)
                goto LABEL_1072;
              if (*((_DWORD *)v606 + 14))
                goto LABEL_1072;
              v607 = arb::achr((arb *)&v605[(_QWORD)v640], (const char *)0x2C);
              if (!v607)
                goto LABEL_1072;
              v608 = v607;
              if (strncmp(v607, (const char *)v431, (size_t)__ne)
                || !arb::achr((arb *)&__ne[(_QWORD)v608], (const char *)0x3B))
              {
                goto LABEL_1072;
              }
            }
            else
            {
              while (1)
              {
                if ((v433 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v445 = *((unsigned __int8 *)v431 + 1);
                    v431 = (arb *)((char *)v431 + 1);
                    v433 = v445;
                  }
                  while ((v445 - 33) > 0xFFFFFFDF);
                }
                if (v433 != 35)
                  break;
                v431 = (arb *)((char *)v431 + 1);
                do
                {
                  v433 = *(unsigned __int8 *)v431;
                  if (!*(_BYTE *)v431)
                    goto LABEL_1071;
                  v446 = *((unsigned __int8 *)v431 - 1);
                  v431 = (arb *)((char *)v431 + 1);
                }
                while (v446 != 10);
                v431 = (arb *)((char *)v431 - 1);
              }
LABEL_1071:
              v447 = arb::asymbol(v431, (char *)&__dst, (const char **)&v656, v430);
              if (v431 != (arb *)__dst)
                goto LABEL_1072;
              v504 = v447;
              __nd = v656;
              if ((unsigned __int8 *)&v656[(_QWORD)v431] != v447)
              {
                v638 = (arb *)(v447 - 4);
                if (strncmp((const char *)v447 - 4, "xyzw", 4uLL))
                {
                  if (strncmp((const char *)v638, "rgba", 4uLL))
                    goto LABEL_1072;
                }
              }
              if (!v504)
                goto LABEL_1072;
              v505 = arb::obj_add((uint64_t)v650, (char *)v431, (const char **)__nd, (uint64_t)v647, 1);
              if (!v505 || *((_BYTE **)v505 + 5) != outputKind || *((_DWORD *)v505 + 14))
                goto LABEL_1072;
            }
            v384 = 0;
            *((_QWORD *)&v651 + 1) = v368;
            v647[1] |= 0x20000000u;
            v425 = *v368;
            if ((ctype[2 * *v368] & 0x40) == 0)
              goto LABEL_1078;
            goto LABEL_1213;
          case 'O':
            v418 = (unsigned __int8 *)(v368 + 6);
            if (!strncmp(v368, "OUTPUT", 6uLL))
            {
              if (arb::obj_decl((uint64_t)v650, outputKind, (arb *)(v368 + 6), v382, (uint64_t)v647))
                goto LABEL_848;
              v218 = 4294967245;
              *((_QWORD *)this + 1) = 0;
              *((_QWORD *)this + 2) = 0;
              *(_QWORD *)this = v3;
              v372 = v650[0];
              if (!v650[0])
                return v218;
LABEL_832:
              free(v372);
              return v218;
            }
            if (strncmp(v368, "OPTION", 6uLL))
              goto LABEL_1076;
            v419 = *v418;
            if (*v418)
            {
              if ((v419 - 33) < 0xFFFFFFE0)
                goto LABEL_979;
              do
              {
LABEL_978:
                v420 = *++v418;
                v419 = v420;
              }
              while ((v420 - 33) > 0xFFFFFFDF);
LABEL_979:
              while (v419 == 35)
              {
                ++v418;
                do
                {
                  v419 = *v418;
                  if (!*v418)
                    goto LABEL_1063;
                  v421 = *(v418++ - 1);
                }
                while (v421 != 10);
                --v418;
                if ((v419 - 33) >= 0xFFFFFFE0)
                  goto LABEL_978;
              }
            }
LABEL_1063:
            if (!strncmp((const char *)v418, "NV_fragment_program", 0x13uLL))
            {
              v493 = v418[19];
              v492 = v418 + 19;
              v491 = v493;
              v494 = v493 - 58;
              if ((v493 - 58) >= 0xFFFFFFF6)
              {
                v495 = 0;
                do
                {
                  v495 = v491 + 10 * v495 - 48;
                  v496 = *++v492;
                  v491 = v496;
                }
                while ((v496 - 58) > 0xFFFFFFF5);
                v654 = v495;
                v497 = *v492;
                if (*v492)
                {
                  if ((v497 - 33) < 0xFFFFFFE0)
                    goto LABEL_1195;
                  do
                  {
LABEL_1194:
                    v498 = *++v492;
                    v497 = v498;
                  }
                  while ((v498 - 33) > 0xFFFFFFDF);
LABEL_1195:
                  while (v497 == 35)
                  {
                    v499 = v492;
                    do
                    {
                      v500 = *++v499;
                      v497 = v500;
                      if (!v500)
                        goto LABEL_1201;
                      v501 = *v492;
                      v492 = v499;
                    }
                    while (v501 != 10);
                    v492 = v499;
                    if ((v497 - 33) >= 0xFFFFFFE0)
                      goto LABEL_1194;
                  }
                }
              }
LABEL_1201:
              v502 = __CFADD__(v494, 10);
              v503 = 394256;
              if (v502)
                v503 = 16 * v654 + 394240;
              v647[0] = v503;
              goto LABEL_848;
            }
            if (!strncmp((const char *)v418, "ARB_precision_hint_fastest", 0x1AuLL))
            {
              v647[1] = v647[1] & 0x3FFFFFFF | 0x40000000;
              goto LABEL_848;
            }
            if (!strncmp((const char *)v418, "ARB_precision_hint_nicest", 0x19uLL))
            {
              v647[1] |= 0x80000000;
              goto LABEL_848;
            }
            if (strncmp((const char *)v418, "ARB_draw_buffers", 0x10uLL)
              && strncmp((const char *)v418, "ATI_draw_buffers", 0x10uLL))
            {
              if (!strncmp((const char *)v418, "NV_vertex_program", 0x11uLL))
              {
                v579 = v418[17];
                v578 = v418 + 17;
                v577 = v579;
                v580 = v579 - 58;
                if ((v579 - 58) >= 0xFFFFFFF6)
                {
                  v581 = 0;
                  do
                  {
                    v581 = v577 + 10 * v581 - 48;
                    v582 = *++v578;
                    v577 = v582;
                  }
                  while ((v582 - 58) > 0xFFFFFFF5);
                  v654 = v581;
                  v583 = *v578;
                  if (*v578)
                  {
                    if ((v583 - 33) < 0xFFFFFFE0)
                      goto LABEL_1372;
                    do
                    {
LABEL_1371:
                      v584 = *++v578;
                      v583 = v584;
                    }
                    while ((v584 - 33) > 0xFFFFFFDF);
LABEL_1372:
                    while (v583 == 35)
                    {
                      v585 = v578;
                      do
                      {
                        v586 = *++v585;
                        v583 = v586;
                        if (!v586)
                          goto LABEL_1378;
                        v587 = *v578;
                        v578 = v585;
                      }
                      while (v587 != 10);
                      v578 = v585;
                      if ((v583 - 33) >= 0xFFFFFFE0)
                        goto LABEL_1371;
                    }
                  }
                }
LABEL_1378:
                if (v580 >= 0xFFFFFFF6)
                  v588 = 16 * v654 + 328704;
                else
                  v588 = 328720;
                v647[0] = v588;
                goto LABEL_848;
              }
              if (!strncmp((const char *)v418, "ARB_position_invariant", 0x16uLL))
              {
                v647[1] |= 0xC0000000;
                goto LABEL_848;
              }
LABEL_1091:
              v647[3] = 0;
            }
LABEL_848:
            v368 = (char *)i;
            if (!i)
            {
LABEL_1410:
              if (HIDWORD(v653))
              {
                HIDWORD(v653) = WORD4(v648);
                v609 = arb::obj_key((char **)v650, "", 0);
                v610 = WORD4(v648);
                ++WORD4(v648);
                v611 = (char *)v650[0] + 88 * v609;
                *((_QWORD *)v611 + 5) = &unk_1B309DC66;
                *((_QWORD *)v611 + 6) = 1;
                *((_DWORD *)v611 + 14) = v610;
                *((_QWORD *)v611 + 9) = 0;
                *((_QWORD *)v611 + 10) = 0;
                *((_QWORD *)v611 + 8) = 0;
              }
              v612 = v647[1];
              v647[2] = (v647[2] & LOBYTE(v647[1]));
              v647[3] = (v647[3] & LOBYTE(v647[1]));
              v647[1] &= 0xFFFFFF00;
              if ((v647[3] & 1) == 0)
              {
                v647[1] = v612 & 0xEFFFFF00;
                *(_QWORD *)&v652 = 0;
              }
              arb::obj_write((uint64_t *)v650, (uint64_t)this, (uint64_t)v647, v3);
              v614 = *(int **)this;
              v613 = *((_QWORD *)this + 1);
              v615 = HGDigestInit(&__dst);
              if (v613 >= 0x40)
              {
                v618 = v613 >> 6;
                do
                {
                  HGDigestAdd(&__dst, v614);
                  v614 += 16;
                  --v618;
                }
                while (v618);
                v613 &= 0x3Fu;
              }
              if (v613)
              {
                memcpy(&__s1a, v614, v613);
                bzero((char *)&__s1a + v613, 64 - v613);
                HGDigestAdd(&__dst, (int *)&__s1a);
              }
              arb::end((string_t *)this, (uint64_t)v647, (unsigned int *)&__dst, v615, v616, v617);
              v218 = 0;
              v372 = v650[0];
              if (!v650[0])
                return v218;
              goto LABEL_832;
            }
            goto LABEL_849;
          case 'P':
            if (!strncmp(v368, "PARAM", 5uLL))
            {
              if (arb::obj_decl((uint64_t)v650, paramKind, (arb *)(v368 + 5), v382, (uint64_t)v647))
                goto LABEL_848;
              v218 = 4294967244;
              *((_QWORD *)this + 1) = 0;
              *((_QWORD *)this + 2) = 0;
              *(_QWORD *)this = v3;
              v372 = v650[0];
              if (!v650[0])
                return v218;
              goto LABEL_832;
            }
            if (strncmp(v368, "NOPERSPECTIVE", 0xDuLL))
            {
              if (strncmp(v368, "PRIMITIVE_IN", 0xCuLL))
              {
                v426 = v368;
                v427 = "PRIMITIVE_OUT";
                v428 = 13;
                goto LABEL_1037;
              }
              goto LABEL_848;
            }
            v394 = v368[13];
            v368 += 13;
            LOBYTE(v383) = v394;
            if (v394)
            {
              if ((v383 - 33) < 0xE0u)
                goto LABEL_903;
              do
              {
LABEL_902:
                v395 = *++v368;
                LOBYTE(v383) = v395;
              }
              while ((v395 - 33) > 0xDFu);
LABEL_903:
              while (v383 == 35)
              {
                ++v368;
                do
                {
                  LOBYTE(v383) = *v368;
                  if (!*v368)
                    goto LABEL_865;
                  v396 = *(v368++ - 1);
                }
                while (v396 != 10);
                --v368;
                if ((v383 - 33) >= 0xE0u)
                  goto LABEL_902;
              }
            }
LABEL_865:
            if (v368 == i)
              goto LABEL_848;
            continue;
          case 'R':
            if ((_QWORD)v653 && arb::isunpremult((uint64_t)v650, v368, (uint64_t)i))
              goto LABEL_1074;
            if (strncmp(v368, "REP", 3uLL))
            {
              v426 = v368;
              v427 = "RET";
              v428 = 3;
              goto LABEL_1037;
            }
LABEL_1027:
            ++v634;
            v384 = 1;
            v425 = *v368;
            if ((ctype[2 * *v368] & 0x40) != 0)
              goto LABEL_1213;
            goto LABEL_1078;
          case 'S':
            if (strncmp(v368, "SHORT", 5uLL))
              goto LABEL_1076;
            v403 = v368[5];
            v368 += 5;
            v383 = v403;
            v404 = __nb;
            if ((v382 & 7u) < 3uLL)
              v404 = &shortKind;
            v405 = v637;
            if ((v382 & 7u) < 3uLL)
              v405 = (arb *)((char *)&v648 + 10);
            v637 = v405;
            __nb = v404;
            v382 |= (v382 & 7u) < 3uLL;
            if (!v383)
              goto LABEL_865;
            if ((v383 - 33) >= 0xE0u)
              goto LABEL_938;
LABEL_939:
            if (v383 == 35)
            {
              ++v368;
              while (1)
              {
                LOBYTE(v383) = *v368;
                if (!*v368)
                  break;
                v407 = *(v368++ - 1);
                if (v407 == 10)
                {
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                  {
                    do
                    {
LABEL_938:
                      v406 = *++v368;
                      LOBYTE(v383) = v406;
                    }
                    while ((v406 - 33) > 0xDFu);
                  }
                  goto LABEL_939;
                }
              }
            }
            goto LABEL_865;
          case 'T':
            if (strncmp(v368, "TEMP", 4uLL))
            {
              v417 = arb::obj_texop((uint64_t)v650, (char *)&v654, (arb *)v368, v634 == 0, (int8x8_t *)v647);
LABEL_993:
              if (v417)
                goto LABEL_848;
              v384 = 0;
              v425 = *v368;
              if ((ctype[2 * *v368] & 0x40) == 0)
                goto LABEL_1078;
              goto LABEL_1213;
            }
            v441 = v368[4];
            v440 = (unsigned __int8 *)(v368 + 4);
            v439 = v441;
            if (!v441)
              goto LABEL_1247;
            if ((v439 - 33) >= 0xFFFFFFE0)
              goto LABEL_1042;
            break;
          case 'U':
            if (strncmp(v368, "UINT", 4uLL))
              goto LABEL_1076;
            v388 = v368[4];
            v368 += 4;
            LOBYTE(v383) = v388;
            if (!v388)
              goto LABEL_864;
            if ((v383 - 33) >= 0xE0u)
              goto LABEL_880;
LABEL_881:
            if (v383 == 35)
            {
              ++v368;
              while (1)
              {
                LOBYTE(v383) = *v368;
                if (!*v368)
                  break;
                v390 = *(v368++ - 1);
                if (v390 == 10)
                {
                  --v368;
                  if ((v383 - 33) >= 0xE0u)
                  {
                    do
                    {
LABEL_880:
                      v389 = *++v368;
                      LOBYTE(v383) = v389;
                    }
                    while ((v389 - 33) > 0xDFu);
                  }
                  goto LABEL_881;
                }
              }
            }
LABEL_864:
            v637 = (arb *)((char *)&v648 + 13);
            __nb = &uintKind;
            v382 = 4;
            goto LABEL_865;
          case 'V':
            v426 = v368;
            v427 = "VERTICES_OUT";
            v428 = 12;
            goto LABEL_1037;
          default:
            goto LABEL_1077;
        }
        break;
      }
      while (1)
      {
        if (v439 != 35)
          goto LABEL_1247;
        ++v440;
        do
        {
          v439 = *v440;
          if (!*v440)
          {
            while (1)
            {
LABEL_1247:
              v521 = 0;
              do
              {
                v522 = *((unsigned __int8 *)v521 + (_QWORD)v440 + 1);
                v521 = (const char **)((char *)v521 + 1);
              }
              while ((ctype[2 * v522] & 0x40) != 0);
              if (!v522)
                goto LABEL_1281;
              v523 = (unsigned __int8 *)v521 + (_QWORD)v440;
              if ((v522 - 33) < 0xFFFFFFE0)
                goto LABEL_1252;
              do
              {
LABEL_1251:
                v524 = *++v523;
                v522 = v524;
              }
              while ((v524 - 33) > 0xFFFFFFDF);
LABEL_1252:
              while (v522 == 35)
              {
                v525 = v523;
                do
                {
                  v526 = *++v525;
                  v522 = v526;
                  if (!v526)
                    goto LABEL_1281;
                  v527 = *v523;
                  v523 = v525;
                }
                while (v527 != 10);
                v523 = v525;
                if ((v522 - 33) >= 0xFFFFFFE0)
                  goto LABEL_1251;
              }
              if (v522 != 91)
                goto LABEL_1281;
              v530 = v523[1];
              v529 = v523 + 1;
              LOBYTE(v528) = v530;
              if (!v530)
                goto LABEL_1281;
              if ((v528 - 33) < 0xE0u)
                goto LABEL_1262;
              do
              {
LABEL_1261:
                v531 = *++v529;
                LOBYTE(v528) = v531;
              }
              while ((v531 - 33) > 0xDFu);
LABEL_1262:
              while (v528 == 35)
              {
                v532 = v529;
                do
                {
                  v533 = *++v532;
                  LOBYTE(v528) = v533;
                  if (!v533)
                    goto LABEL_1281;
                  v534 = *v529;
                  v529 = v532;
                }
                while (v534 != 10);
                v529 = v532;
                if ((v528 - 33) >= 0xE0u)
                  goto LABEL_1261;
              }
              if ((v528 - 58) < 0xF6u)
                goto LABEL_1281;
              LODWORD(v631) = 0;
              do
              {
                v631 = 10 * (_DWORD)v631 + v528 - 48;
                v535 = *++v529;
                v528 = v535;
              }
              while ((v535 - 58) > 0xF5u);
              if (!v528)
                goto LABEL_1281;
              if ((v528 - 33) < 0xE0u)
                goto LABEL_1274;
              do
              {
LABEL_1273:
                v536 = *++v529;
                LOBYTE(v528) = v536;
              }
              while ((v536 - 33) > 0xDFu);
LABEL_1274:
              while (v528 == 35)
              {
                v537 = v529;
                do
                {
                  v538 = *++v537;
                  LOBYTE(v528) = v538;
                  if (!v538)
                    goto LABEL_1281;
                  v539 = *v529;
                  v529 = v537;
                }
                while (v539 != 10);
                v529 = v537;
                if ((v528 - 33) >= 0xE0u)
                  goto LABEL_1273;
              }
              if (!(_BYTE)v528)
                goto LABEL_1281;
              while (1)
              {
                if ((v528 - 33) >= 0xE0u)
                {
                  do
                  {
                    v560 = *++v529;
                    LOBYTE(v528) = v560;
                  }
                  while ((v560 - 33) > 0xDFu);
                }
                if (v528 != 35)
                  break;
                v561 = v529;
                do
                {
                  v562 = *++v561;
                  LOBYTE(v528) = v562;
                  if (!v562)
                    goto LABEL_1281;
                  v563 = *v529;
                  v529 = v561;
                }
                while (v563 != 10);
                v529 = v561;
              }
              if (v528 == 93)
              {
                ptr = (char *)v650[0];
                v620 = (unint64_t)v650[1];
                v622 = (char *)v650[0] + 88 * (uint64_t)v650[1];
                if (!v650[1])
                  goto LABEL_1339;
                v623 = (unint64_t)v650[1];
                v628 = (char *)v650[0];
                while (1)
                {
                  *(_QWORD *)&__s1a = v440;
                  v621 = v623 >> 1;
                  v624 = &v628[88 * (v623 >> 1)];
                  v564 = arb::ascan((unsigned __int8 **)&__s1a, v521, (unsigned __int8 *)v624, (const char *)1);
                  if (!v564)
                    break;
                  v565 = v622;
                  v566 = (char *)(v623 - (v621 + 1));
                  if (v564 <= 0)
                    v565 = &v628[88 * (v623 >> 1)];
                  v622 = v565;
                  if (v564 > 0)
                    v567 = v621 + 1;
                  else
                    v567 = 0;
                  v628 += 88 * v567;
                  if (v564 <= 0)
                    v566 = (char *)(v623 >> 1);
                  v623 = (unint64_t)v566;
                  if (!v566)
                    goto LABEL_1339;
                }
                if (!v628)
                {
LABEL_1339:
                  if (v620 + 1 <= (unint64_t)v651
                    || (v625 = (v620 & 0xFFFFFFFFFFFFFFF0) + 16, (_QWORD)v651 == v625))
                  {
                    v629 = ptr;
                  }
                  else
                  {
                    *(_QWORD *)&v651 = (v620 & 0xFFFFFFFFFFFFFFF0) + 16;
                    v629 = (char *)malloc_type_realloc(ptr, 88 * v625, 0x10500400A17BEF8uLL);
                    v650[0] = v629;
                    v568 = v620;
                    if (v620 >= v625)
                      v568 = (v620 & 0xFFFFFFFFFFFFFFF0) + 16;
                    v620 = v568;
                  }
                  v626 = 0x2E8BA2E8BA2E8BA3 * ((v622 - ptr) >> 3);
                  if (v620 > v626)
                    memmove(&v629[8 * ((v622 - ptr) >> 3) + 88], &v629[8 * ((v622 - ptr) >> 3)], 88 * (v620 - v626));
                  v650[1] = (void *)(v620 + 1);
                  v624 = &v629[8 * ((v622 - ptr) >> 3)];
                  v569 = 0;
                  if (v521)
                  {
                    v570 = 0;
                    do
                    {
                      v571 = v440[v570];
                      if ((v571 - 33) > 0xFFFFFFDF)
                      {
                        v572 = &v440[++v570];
                        if (v440[v570] == 35)
                        {
LABEL_1355:
                          v573 = 35;
                          while (v573 == 35)
                          {
                            ++v572;
                            do
                            {
                              v573 = *v572;
                              if (!*v572)
                                goto LABEL_1349;
                              v575 = *(v572++ - 1);
                            }
                            while (v575 != 10);
                            --v572;
                            if ((v573 - 33) >= 0xFFFFFFE0)
                            {
                              do
                              {
                                v574 = *++v572;
                                v573 = v574;
                              }
                              while ((v574 - 33) > 0xFFFFFFDF);
                            }
                          }
LABEL_1349:
                          v570 = v572 - v440;
                        }
                      }
                      else
                      {
                        v624[v569++] = v571;
                        v572 = &v440[++v570];
                        if (v440[v570] == 35)
                          goto LABEL_1355;
                      }
                    }
                    while (v570 < (unint64_t)v521);
                  }
                  v624[v569] = 0;
                }
                v576 = WORD1(v649);
                *((_QWORD *)v624 + 5) = &arrayKind;
                *((_QWORD *)v624 + 6) = 2;
                *((_DWORD *)v624 + 14) = v576;
                *((_QWORD *)v624 + 8) = 0;
                *((_QWORD *)v624 + 9) = v631;
                *((_QWORD *)v624 + 10) = v382;
                WORD1(v649) = v576 + v631;
                v548 = (unsigned __int8 *)v521 + (_QWORD)(v529 + 1);
                v549 = *v548;
                if (!*v548)
                  goto LABEL_848;
              }
              else
              {
LABEL_1281:
                v543 = __nb == &shortKind || __nb == &longKind || __nb == &intKind || __nb == &uintKind;
                v544 = arb::obj_key((char **)v650, v440, v521);
                if (v543)
                {
                  v545 = 1;
                  if (*((_BYTE *)__nb + 1))
                    v545 = 2;
                  v546 = *(unsigned __int8 *)v637;
                  *(_BYTE *)v637 = v546 + 1;
                  v547 = (char *)v650[0] + 88 * v544;
                  *((_QWORD *)v547 + 5) = __nb;
                  *((_QWORD *)v547 + 6) = v545;
                  *((_DWORD *)v547 + 14) = v546;
                  *((_QWORD *)v547 + 8) = 0;
                  *((_QWORD *)v547 + 9) = 0;
                  *((_QWORD *)v547 + 10) = v382;
                  v548 = (unsigned __int8 *)v521 + (_QWORD)v440;
                  v549 = *v548;
                  if (!*v548)
                    goto LABEL_848;
                }
                else
                {
                  v550 = WORD4(v648);
                  ++WORD4(v648);
                  v551 = (char *)v650[0] + 88 * v544;
                  *((_QWORD *)v551 + 5) = &unk_1B309DC66;
                  *((_QWORD *)v551 + 6) = 1;
                  *((_DWORD *)v551 + 14) = v550;
                  *((_QWORD *)v551 + 8) = 0;
                  *((_QWORD *)v551 + 9) = 0;
                  *((_QWORD *)v551 + 10) = v382;
                  __nb = &unk_1B309DC66;
                  v548 = (unsigned __int8 *)v521 + (_QWORD)v440;
                  v549 = *v548;
                  if (!*v548)
                    goto LABEL_848;
                }
              }
              if ((v549 - 33) < 0xFFFFFFE0)
                goto LABEL_1301;
              do
              {
LABEL_1300:
                v552 = *++v548;
                v549 = v552;
              }
              while ((v552 - 33) > 0xFFFFFFDF);
LABEL_1301:
              while (v549 == 35)
              {
                v553 = v548;
                do
                {
                  v554 = *++v553;
                  v549 = v554;
                  if (!v554)
                    goto LABEL_848;
                  v555 = *v548;
                  v548 = v553;
                }
                while (v555 != 10);
                v548 = v553;
                if ((v549 - 33) >= 0xFFFFFFE0)
                  goto LABEL_1300;
              }
              if (v549 != 44)
                goto LABEL_848;
              v557 = v548[1];
              v440 = v548 + 1;
              v556 = v557;
              if (v557)
              {
                if ((v556 - 33) < 0xFFFFFFE0)
                  goto LABEL_1311;
                do
                {
LABEL_1310:
                  v558 = *++v440;
                  v556 = v558;
                }
                while ((v558 - 33) > 0xFFFFFFDF);
LABEL_1311:
                while (v556 == 35)
                {
                  ++v440;
                  do
                  {
                    v556 = *v440;
                    if (!*v440)
                      goto LABEL_1247;
                    v559 = *(v440++ - 1);
                  }
                  while (v559 != 10);
                  --v440;
                  if ((v556 - 33) >= 0xFFFFFFE0)
                    goto LABEL_1310;
                }
              }
            }
          }
          v443 = *(v440++ - 1);
        }
        while (v443 != 10);
        --v440;
        if ((v439 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_1042:
            v442 = *++v440;
            v439 = v442;
          }
          while ((v442 - 33) > 0xFFFFFFDF);
          continue;
        }
      }
    }
  }
LABEL_19:
  v18 = header(__s1, v647);
  v19 = v647[0];
  if (v647[0])
  {
    if ((v647[0] & 0xFF00) == 0xB00)
      goto LABEL_21;
LABEL_491:
    if (!v18)
      goto LABEL_521;
    while (1)
    {
      do
      {
LABEL_506:
        v219 = v18;
        v220 = v18 + 1;
        v221 = *v18++;
      }
      while ((v221 - 33) >= 0xFFFFFFE0);
      if (v221 != 47)
        break;
      v222 = *v220;
      if (v222 == 42)
      {
        v18 = v219 + 2;
        if (v219[2])
        {
          do
          {
            if (*(v220 - 1) == 42 && *v220 == 47)
              break;
            v225 = v220[2];
            ++v220;
          }
          while (v225);
          v18 = v220 + 1;
        }
      }
      else
      {
        if (v222 != 47)
          goto LABEL_537;
        v223 = v219 + 2;
        while (*v223)
        {
          v224 = *(v223 - 1);
          v18 = v223++;
          if (v224 == 10)
            goto LABEL_506;
        }
        v18 = v223;
      }
    }
LABEL_535:
    if (!v221)
      v219 = 0;
LABEL_537:
    v231 = 0;
    v636 = 0;
    v627 = BYTE10(v649);
    v632 = v647[1];
    v633 = WORD2(v649);
    __na = WORD3(v648);
    v630 = BYTE8(v649);
    v635 = WORD2(v648);
    v232 = v219;
    while (1)
    {
      v233 = v232;
      while (1)
      {
        do
        {
LABEL_540:
          v234 = v233;
          v236 = v233 + 1;
          v235 = *v233++;
        }
        while ((v235 - 33) >= 0xFFFFFFE0);
        if (v235 != 47)
          break;
        v237 = *v236;
        if (v237 == 42)
        {
          v233 = v234 + 2;
          if (v234[2])
          {
            do
            {
              if (*(v236 - 1) == 42 && *v236 == 47)
                break;
              v240 = v236[2];
              ++v236;
            }
            while (v240);
            v233 = v236 + 1;
          }
        }
        else
        {
          if (v237 != 47)
            goto LABEL_555;
          v238 = v234 + 2;
          while (*v238)
          {
            v239 = *(v238 - 1);
            v233 = v238++;
            if (v239 == 10)
              goto LABEL_540;
          }
          v233 = v238;
        }
      }
      if (!v235)
      {
        WORD3(v648) = __na + 4 * (v636 + v231);
        HIDWORD(v649) = 16 * WORD3(v648);
        v296 = v19 | 0x60600;
        if (v19 >= 0x100 && (v296 = v19, (_BYTE)v19))
        {
          LOBYTE(v297) = v647[0];
          v299 = *((_QWORD *)this + 1);
          v298 = *((_QWORD *)this + 2);
          v300 = v299 + 6;
          if ((v647[0] & 0xFFFFFF00) != 0x50600)
            goto LABEL_769;
LABEL_776:
          if (v298)
          {
            if (v300 >= *(_QWORD *)v298)
            {
              v303 = malloc_type_realloc(*(void **)(v298 + 16), (v299 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v304 = (unint64_t *)*((_QWORD *)this + 2);
              v304[2] = (unint64_t)v303;
              *v304 = (v299 + 261) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v303;
            }
          }
          else
          {
            str_alloc((string_t *)this, v300);
          }
          v308 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 6;
          v306 = v308 + v299;
          v307 = 29558;
        }
        else
        {
          if ((_BYTE)v296)
            v297 = v296;
          else
            v297 = v296 | 0x10;
          v647[0] = v297;
          v299 = *((_QWORD *)this + 1);
          v298 = *((_QWORD *)this + 2);
          v300 = v299 + 6;
          if ((v297 & 0xFFFFFF00) == 0x50600)
            goto LABEL_776;
LABEL_769:
          if (v298)
          {
            if (v300 >= *(_QWORD *)v298)
            {
              v301 = malloc_type_realloc(*(void **)(v298 + 16), (v299 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v302 = (unint64_t *)*((_QWORD *)this + 2);
              v302[2] = (unint64_t)v301;
              *v302 = (v299 + 261) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v301;
            }
          }
          else
          {
            str_alloc((string_t *)this, v300);
          }
          v305 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 6;
          v306 = v305 + v299;
          v307 = 29542;
        }
        *(_WORD *)(v306 + 4) = v307;
        *(_DWORD *)v306 = 1279733551;
        v310 = *((_QWORD *)this + 1);
        v309 = *((_QWORD *)this + 2);
        v311 = v310 + 20;
        if (v309)
        {
          if (v311 >= *(_QWORD *)v309)
          {
            v312 = malloc_type_realloc(*(void **)(v309 + 16), (v310 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v313 = (unint64_t *)*((_QWORD *)this + 2);
            v313[2] = (unint64_t)v312;
            *v313 = (v310 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v312;
          }
        }
        else
        {
          str_alloc((string_t *)this, v311);
        }
        v314 = itoa((char *)(*(_QWORD *)this + v310), v297 >> 4);
        v315 = *((_QWORD *)this + 2);
        v316 = *((_QWORD *)this + 1) + v314;
        *((_QWORD *)this + 1) = v316;
        v317 = v316 + 1;
        if (v315)
        {
          if (v317 >= *(_QWORD *)v315)
          {
            v318 = malloc_type_realloc(*(void **)(v315 + 16), (v316 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v319 = (_QWORD *)*((_QWORD *)this + 2);
            v319[2] = v318;
            *v319 = (v316 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)this = v318;
          }
        }
        else
        {
          str_alloc((string_t *)this, v317);
        }
        v320 = *(_QWORD *)this;
        ++*((_QWORD *)this + 1);
        *(_BYTE *)(v320 + v316) = 46;
        v321 = v647[0] & 0xF;
        v323 = *((_QWORD *)this + 1);
        v322 = *((_QWORD *)this + 2);
        v324 = v323 + 20;
        if (v322)
        {
          if (v324 >= *(_QWORD *)v322)
          {
            v325 = malloc_type_realloc(*(void **)(v322 + 16), (v323 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v326 = (unint64_t *)*((_QWORD *)this + 2);
            v326[2] = (unint64_t)v325;
            *v326 = (v323 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v325;
          }
        }
        else
        {
          str_alloc((string_t *)this, v324);
        }
        v327 = itoa((char *)(*(_QWORD *)this + v323), v321);
        v328 = *((_QWORD *)this + 2);
        v329 = *((_QWORD *)this + 1) + v327;
        *((_QWORD *)this + 1) = v329;
        if (v328)
        {
          if (*(_QWORD *)v328 <= 0xFuLL)
          {
            v330 = malloc_type_realloc(*(void **)(v328 + 16), 0x100uLL, 0xCCCD1039uLL);
            v331 = (_QWORD *)*((_QWORD *)this + 2);
            v331[2] = v330;
            *v331 = 256;
            *(_QWORD *)this = v330;
          }
        }
        else
        {
          str_alloc((string_t *)this, 15);
        }
        v332 = *(_QWORD *)this;
        *((_QWORD *)this + 1) += 15 - v329;
        memcpy((void *)(v332 + v329), "               ", 15 - v329);
        v334 = *((_QWORD *)this + 1);
        v333 = *((_QWORD *)this + 2);
        v335 = v334 + 1;
        if (v333)
        {
          if (v335 >= *(_QWORD *)v333)
          {
            v336 = malloc_type_realloc(*(void **)(v333 + 16), (v334 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v337 = (_QWORD *)*((_QWORD *)this + 2);
            v337[2] = v336;
            *v337 = (v334 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)this = v336;
          }
        }
        else
        {
          str_alloc((string_t *)this, v335);
        }
        v338 = *(_QWORD *)this;
        ++*((_QWORD *)this + 1);
        *(_BYTE *)(v338 + v334) = 10;
        v340 = *((_QWORD *)this + 1);
        v339 = *((_QWORD *)this + 2);
        v341 = v340 + 17;
        if (v339)
        {
          if (v341 >= *(_QWORD *)v339)
          {
            v342 = malloc_type_realloc(*(void **)(v339 + 16), (v340 + 272) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v343 = (unint64_t *)*((_QWORD *)this + 2);
            v343[2] = (unint64_t)v342;
            *v343 = (v340 + 272) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v342;
          }
        }
        else
        {
          str_alloc((string_t *)this, v341);
        }
        v344 = *(_QWORD *)this;
        *((_QWORD *)this + 1) += 17;
        v345 = v344 + v340;
        *(_OWORD *)v345 = *(_OWORD *)"//LEN=0000000000\n";
        *(_BYTE *)(v345 + 16) = 10;
        v347 = *((_QWORD *)this + 1);
        v346 = *((_QWORD *)this + 2);
        v348 = v347 + v232 - v219;
        if (v346)
        {
          if (v348 >= *(_QWORD *)v346)
          {
            v349 = (v348 + 255) & 0xFFFFFFFFFFFFFF00;
            v350 = malloc_type_realloc(*(void **)(v346 + 16), v349, 0xCCCD1039uLL);
            v351 = (size_t *)*((_QWORD *)this + 2);
            v351[2] = (size_t)v350;
            *v351 = v349;
            *(_QWORD *)this = v350;
          }
        }
        else
        {
          str_alloc((string_t *)this, v348);
        }
        v352 = *(_QWORD *)this;
        *((_QWORD *)this + 1) += v232 - v219;
        memcpy((void *)(v352 + v347), v219, v232 - v219);
        if (*(v232 - 1) != 10)
        {
          v354 = *((_QWORD *)this + 1);
          v353 = *((_QWORD *)this + 2);
          v355 = v354 + 1;
          if (v353)
          {
            if (v355 >= *(_QWORD *)v353)
            {
              v356 = malloc_type_realloc(*(void **)(v353 + 16), (v354 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v357 = (_QWORD *)*((_QWORD *)this + 2);
              v357[2] = v356;
              *v357 = (v354 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)this = v356;
            }
          }
          else
          {
            str_alloc((string_t *)this, v355);
          }
          v358 = *(_QWORD *)this;
          ++*((_QWORD *)this + 1);
          *(_BYTE *)(v358 + v354) = 10;
        }
        v360 = *(int **)this;
        v359 = *((_QWORD *)this + 1);
        v361 = HGDigestInit(&__dst);
        if (v359 >= 0x40)
        {
          v364 = v359 >> 6;
          do
          {
            HGDigestAdd(&__dst, v360);
            v360 += 16;
            --v364;
          }
          while (v364);
          v359 &= 0x3Fu;
        }
        if (v359)
        {
          memcpy(&__s1a, v360, v359);
          bzero((char *)&__s1a + v359, 64 - v359);
          HGDigestAdd(&__dst, (int *)&__s1a);
        }
        glsl::end((string_t *)this, (uint64_t)v647, (unsigned int *)&__dst, 0, v361, v362, v363);
        return 0;
      }
LABEL_555:
      LODWORD(__s1a) = 0;
      v241 = *v234;
      if ((_DWORD)v241 == 103)
      {
        if (*v236 != 108 || v234[2] != 95)
          goto LABEL_594;
        if (!strncmp((const char *)v234 + 3, "TextureMatrix", 0xDuLL))
        {
          v259 = v19 & 0xFFFFFF00;
          v19 = v19 & 0xFFFFFF00 | 0x10;
          v647[0] = v259 | 0x10;
          LODWORD(__s1a) = 0;
          v260 = glsl::glindex((glsl *)(v234 + 16), (char *)&__s1a, v244);
          if (v260)
            v236 = v260;
          else
            v236 = v234 + 16;
          if ((int)__s1a + 1 > v231)
            v231 = __s1a + 1;
          v632 |= 0x8000000u;
          v647[1] = v632;
          goto LABEL_674;
        }
        v236 = v234 + 11;
        if (!strncmp((const char *)v234 + 3, "TexCoord", 8uLL))
        {
          v266 = v19 & 0xFFFFFF00;
          v19 = v19 & 0xFFFFFF00 | 0x10;
          v647[0] = v266 | 0x10;
          LODWORD(__s1a) = 0;
          v267 = glsl::glindex((glsl *)(v234 + 11), (char *)&__s1a, v245);
          if (v267)
            v236 = v267;
          if ((int)__s1a + 1 > v633)
            v268 = __s1a + 1;
          else
            v268 = v633;
          v633 = v268;
          WORD2(v649) = v268;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "MultiTexCoord", 0xDuLL))
        {
          v647[0] = 329232;
          LODWORD(__s1a) = 0;
          v275 = glsl::glindex((glsl *)(v234 + 16), (char *)&__s1a, v246);
          if (v275)
            v236 = v275;
          else
            v236 = v234 + 16;
          if ((int)__s1a + 1 > v633)
            v276 = __s1a + 1;
          else
            v276 = v633;
          v633 = v276;
          WORD2(v649) = v276;
          v19 = 329232;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "ModelViewProjectionMatrix", 0x19uLL))
        {
          v236 = v234 + 28;
          v19 = v19 & 0xFFFFFF00 | 0x10;
          v647[0] = v19;
          v647[1] = v632 | 0x8000000;
          v632 |= 0x8000000u;
LABEL_713:
          v636 = 1;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "Position", 8uLL))
        {
          v647[0] = 329232;
          v19 = 329232;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "Vertex", 6uLL) || !strncmp((const char *)v234 + 3, "Normal", 6uLL))
        {
          v647[0] = 329232;
          v19 = 329232;
          v236 = v234 + 9;
          goto LABEL_674;
        }
        if (!strncmp((const char *)v234 + 3, "FrontFacing", 0xBuLL))
        {
          v236 = v234 + 14;
          v19 = v19 | 0x60600;
          v647[0] = v19;
          goto LABEL_674;
        }
        v232 = v234 + 12;
        if (!strncmp((const char *)v234 + 3, "FragDepth", 9uLL) || !strncmp((const char *)v234 + 3, "FragCoord", 9uLL))
        {
          v19 = v19 | 0x60600;
          v647[0] = v19;
          v236 = v234 + 12;
          goto LABEL_674;
        }
        if (strncmp((const char *)v234 + 3, "FragColor", 9uLL))
        {
          if (!strncmp((const char *)v234 + 3, "FragData", 8uLL))
          {
            v294 = v19;
            v19 = v19 | 0x60600;
            v647[0] = v294 | 0x60600;
            LODWORD(__s1a) = 0;
            v295 = glsl::glindex((glsl *)(v234 + 11), (char *)&__s1a, v247);
            if (v295)
            {
              if ((int)__s1a + 1 > v627)
              {
                v627 = (__s1a + 1);
                BYTE10(v649) = __s1a + 1;
              }
              v236 = v295;
            }
          }
          else
          {
            v236 = v234 + 2;
            do
              v248 = *++v236;
            while (v248 > 0x20);
          }
          goto LABEL_674;
        }
        v19 = v19 | 0x60600;
        v647[0] = v19;
        if (!v627)
        {
          v627 = 1;
          BYTE10(v649) = 1;
        }
      }
      else if ((_DWORD)v241 == 104)
      {
        if (*v236 == 103 && v234[2] == 95)
        {
          v236 = v234 + 3;
          v242 = v234 + 16;
          if (!strncmp((const char *)v234 + 3, "TextureMatrix", 0xDuLL))
          {
            v19 = 329248;
            v647[0] = 329248;
            LODWORD(__s1a) = 0;
            v256 = *v242;
            if ((v256 - 58) >= 0xFFFFFFF6)
            {
              v257 = 0;
              v258 = v234 + 16;
              do
              {
                v257 = v256 + 10 * v257 - 48;
                v269 = *++v258;
                v256 = v269;
              }
              while ((v269 - 58) > 0xFFFFFFF5);
              LODWORD(__s1a) = v257;
            }
            else
            {
              v257 = 0;
              v258 = 0;
            }
            if (v258)
              v232 = v258;
            else
              v232 = v234 + 16;
            if (v257 + 1 > v231)
              v231 = v257 + 1;
          }
          else if (!strncmp((const char *)v234 + 3, "Texture", 7uLL))
          {
            v263 = v234[10];
            v262 = v234 + 10;
            v261 = v263;
            v19 = v19 | 0x60600;
            v647[0] = v19;
            LODWORD(__s1a) = 0;
            if ((v263 - 58) >= 0xFFFFFFF6)
            {
              v264 = 0;
              v265 = v262;
              do
              {
                v264 = v261 + 10 * v264 - 48;
                v277 = *++v265;
                v261 = v277;
              }
              while ((v277 - 58) > 0xFFFFFFF5);
              LODWORD(__s1a) = v264;
            }
            else
            {
              v264 = 0;
              v265 = 0;
            }
            if (v265)
              v232 = v265;
            else
              v232 = v262;
            if (v264 + 1 > v630)
              v278 = v264 + 1;
            else
              v278 = v630;
            v630 = v278;
            BYTE8(v649) = v278;
          }
          else
          {
            if (!strncmp((const char *)v234 + 3, "TexCoord", 8uLL))
            {
              v272 = v234[11];
              v271 = v234 + 11;
              v270 = v272;
              v19 = v19 & 0xFFFFFF00 | 0x20;
              v647[0] = v19;
              LODWORD(__s1a) = 0;
              if ((v272 - 58) >= 0xFFFFFFF6)
              {
                v273 = 0;
                v274 = v271;
                do
                {
                  v273 = v270 + 10 * v273 - 48;
                  v284 = *++v274;
                  v270 = v284;
                }
                while ((v284 - 58) > 0xFFFFFFF5);
                LODWORD(__s1a) = v273;
              }
              else
              {
                v273 = 0;
                v274 = 0;
              }
              if (v274)
                v285 = v274;
              else
                v285 = v271;
              if (v273 + 1 > v633)
                v286 = v273 + 1;
              else
                v286 = v633;
              goto LABEL_723;
            }
            if (!strncmp((const char *)v234 + 3, "ProgramLocal", 0xCuLL))
            {
              v281 = v234[15];
              v280 = v234 + 15;
              v279 = v281;
              if ((v281 - 58) >= 0xFFFFFFF6)
              {
                v282 = 0;
                v283 = v280;
                do
                {
                  v282 = v279 + 10 * v282 - 48;
                  v287 = *++v283;
                  v279 = v287;
                }
                while ((v287 - 58) > 0xFFFFFFF5);
                LODWORD(__s1a) = v282;
              }
              else
              {
                v282 = 0;
                v283 = 0;
              }
              if (v283)
                v232 = v283;
              else
                v232 = v280;
              if (v282 + 1 > __na)
                v288 = v282 + 1;
              else
                v288 = __na;
              __na = v288;
              WORD3(v648) = v288;
            }
            else
            {
              if (!strncmp((const char *)v234 + 3, "Position", 8uLL))
              {
                v19 = 329248;
                v647[0] = 329248;
                goto LABEL_674;
              }
              if (strncmp((const char *)v234 + 3, "MultiTexCoord", 0xDuLL))
              {
                if (!strncmp((const char *)v234 + 3, "ProjectionMatrix", 0x10uLL))
                {
                  v236 = v234 + 19;
                  v19 = 329248;
                  v647[0] = 329248;
                  goto LABEL_713;
                }
                v236 = v234 + 2;
                do
                  v243 = *++v236;
                while (v243 > 0x20);
                goto LABEL_674;
              }
              v19 = 329248;
              v647[0] = 329248;
              LODWORD(__s1a) = 0;
              v289 = *v242;
              if ((v289 - 58) >= 0xFFFFFFF6)
              {
                v290 = 0;
                v291 = v234 + 16;
                v292 = v633;
                do
                {
                  v290 = v289 + 10 * v290 - 48;
                  v293 = *++v291;
                  v289 = v293;
                }
                while ((v293 - 58) > 0xFFFFFFF5);
                LODWORD(__s1a) = v290;
              }
              else
              {
                v290 = 0;
                v291 = 0;
                v292 = v633;
              }
              if (v291)
                v285 = v291;
              else
                v285 = v234 + 16;
              if (v290 + 1 > v292)
                v286 = v290 + 1;
              else
                v286 = v292;
LABEL_723:
              v633 = v286;
              WORD2(v649) = v286;
              v232 = v285;
            }
          }
        }
        else
        {
LABEL_594:
          if (!strncmp((const char *)v234, "texture2DRectLodOffset", 0x16uLL))
          {
            v236 = v234 + 22;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2DRectOffset", 0x13uLL))
          {
            v236 = v234 + 19;
            goto LABEL_674;
          }
          v250 = v234 + 16;
          if (!strncmp((const char *)v234, "texture2DRectLod", 0x10uLL))
          {
            v236 = v234 + 16;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2DRect", 0xDuLL))
          {
LABEL_662:
            v236 = v234 + 13;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture1DLodOffset", 0x12uLL))
          {
LABEL_663:
            v236 = v234 + 18;
            goto LABEL_674;
          }
          v251 = v234 + 15;
          if (!strncmp((const char *)v234, "texture1DOffset", 0xFuLL))
          {
LABEL_672:
            v236 = v251;
            goto LABEL_674;
          }
          v252 = strncmp((const char *)v234, "texture1DLod", 0xCuLL);
          v253 = v234 + 12;
          if (!v252 || (v254 = strncmp((const char *)v234, "texture1D", 9uLL), v253 = v234 + 9, !v254))
          {
            v236 = v253;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2DLodOffset", 0x12uLL))
            goto LABEL_663;
          if (!strncmp((const char *)v234, "texture2DOffset", 0xFuLL))
            goto LABEL_672;
          if (!strncmp((const char *)v234, "texture2DLod", 0xCuLL))
          {
LABEL_739:
            v236 = v234 + 12;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "texture2D", 9uLL))
            goto LABEL_750;
          if (!strncmp((const char *)v234, "texture3DLodOffset", 0x12uLL))
            goto LABEL_663;
          if (!strncmp((const char *)v234, "texture3DOffset", 0xFuLL))
            goto LABEL_672;
          if (!strncmp((const char *)v234, "texture3DLod", 0xCuLL))
            goto LABEL_739;
          if (!strncmp((const char *)v234, "texture3D", 9uLL))
          {
LABEL_750:
            v236 = v234 + 9;
            goto LABEL_674;
          }
          if (!strncmp((const char *)v234, "textureCubeLodOffset", 0x14uLL))
          {
            v236 = v234 + 20;
          }
          else if (!strncmp((const char *)v234, "textureCubeOffset", 0x11uLL))
          {
            v236 = v234 + 17;
          }
          else if (!strncmp((const char *)v234, "textureCubeLod", 0xEuLL))
          {
            v236 = v234 + 14;
          }
          else
          {
            v251 = v234 + 11;
            if (!strncmp((const char *)v234, "textureCube", 0xBuLL))
              goto LABEL_672;
            if (!strncmp((const char *)v234, "greaterThanEqual", 0x10uLL))
              goto LABEL_764;
            if (!strncmp((const char *)v234, "lessThanEqual", 0xDuLL))
              goto LABEL_662;
            if (!strncmp((const char *)v234, "greaterThan", 0xBuLL)
              || !strncmp((const char *)v234, "inversesqrt", 0xBuLL))
            {
              goto LABEL_672;
            }
            if (!strncmp((const char *)v234, "normalize", 9uLL))
              goto LABEL_750;
            v250 = v234 + 8;
            if (!strncmp((const char *)v234, "lessThan", 8uLL)
              || !strncmp((const char *)v234, "notEqual", 8uLL)
              || (v250 = v234 + 7, !strncmp((const char *)v234, "reflect", 7uLL))
              || !strncmp((const char *)v234, "discard", 7uLL)
              || (v250 = v234 + 6, !strncmp((const char *)v234, "noise1", 6uLL))
              || !strncmp((const char *)v234, "noise2", 6uLL)
              || !strncmp((const char *)v234, "noise3", 6uLL)
              || !strncmp((const char *)v234, "noise4", 6uLL)
              || (v250 = v234 + 5, !strncmp((const char *)v234, "cross", 5uLL))
              || !strncmp((const char *)v234, "clamp", 5uLL)
              || !strncmp((const char *)v234, "fract", 5uLL)
              || !strncmp((const char *)v234, "equal", 5uLL)
              || !strncmp((const char *)v234, "floor", 5uLL)
              || !strncmp((const char *)v234, "while", 5uLL)
              || (v250 = v234 + 4, !strncmp((const char *)v234, "ceil", 4uLL))
              || !strncmp((const char *)v234, "log2", 4uLL)
              || !strncmp((const char *)v234, "exp2", 4uLL)
              || !strncmp((const char *)v234, "dFdx", 4uLL)
              || !strncmp((const char *)v234, "dFdy", 4uLL)
              || !strncmp((const char *)v234, "sqrt", 4uLL)
              || !strncmp((const char *)v234, "acos", 4uLL)
              || !strncmp((const char *)v234, "asin", 4uLL)
              || !strncmp((const char *)v234, "atan", 4uLL)
              || (v250 = v234 + 3, !strncmp((const char *)v234, "abs", 3uLL))
              || !strncmp((const char *)v234, "min", 3uLL)
              || !strncmp((const char *)v234, "max", 3uLL)
              || !strncmp((const char *)v234, "dot", 3uLL)
              || !strncmp((const char *)v234, "pow", 3uLL)
              || !strncmp((const char *)v234, "cos", 3uLL)
              || !strncmp((const char *)v234, "sin", 3uLL)
              || !strncmp((const char *)v234, "tan", 3uLL)
              || !strncmp((const char *)v234, "mod", 3uLL)
              || !strncmp((const char *)v234, "mix", 3uLL)
              || !strncmp((const char *)v234, "for", 3uLL))
            {
LABEL_764:
              v236 = v250;
            }
            else if (!strncmp((const char *)v234, "if", 2uLL))
            {
              v236 = v234 + 2;
            }
            else if ((ctype[2 * v241] & 0x40) != 0)
            {
              if ((_DWORD)v241)
              {
                do
                {
                  if ((ctype[2 * v241] & 0x40) == 0)
                    break;
                  v255 = *++v234;
                  LODWORD(v241) = v255;
                }
                while (v255);
              }
              v236 = v234;
            }
          }
LABEL_674:
          v232 = v236;
        }
      }
      else
      {
        if ((v241 - 48) > 9)
        {
          if (v241 <= 0x3E
            && (((1 << v241) & 0xAC0000000000) != 0
             || ((1 << v241) & 0x7000000200000000) != 0 && ((_DWORD)v241 == 61 || *v236 == 61)))
          {
            goto LABEL_674;
          }
          goto LABEL_594;
        }
        do
          v249 = *++v234;
        while ((v249 - 48) < 0xA);
        WORD2(v648) = ++v635;
        v232 = v234;
      }
    }
  }
  v46 = v3;
  do
  {
    while (1)
    {
      while (1)
      {
        do
        {
LABEL_103:
          v47 = v46;
          v49 = (unsigned __int8 *)(v46 + 1);
          v48 = *(unsigned __int8 *)v46++;
        }
        while ((v48 - 33) >= 0xFFFFFFE0);
        if (v48 != 47)
          break;
        v50 = *v49;
        if (v50 == 42)
        {
          v46 = v47 + 2;
          if (v47[2])
          {
            do
            {
              if (*(v49 - 1) == 42 && *v49 == 47)
                break;
              v60 = v49[2];
              ++v49;
            }
            while (v60);
            v46 = (const char *)(v49 + 1);
          }
        }
        else
        {
          if (v50 != 47)
            goto LABEL_113;
          v51 = v47 + 2;
          while (*v51)
          {
            v52 = *((unsigned __int8 *)v51 - 1);
            v46 = v51++;
            if (v52 == 10)
              goto LABEL_103;
          }
          v46 = v51;
        }
      }
      if (!v48)
      {
        v19 = 0;
        if (v18)
          goto LABEL_506;
        while (1)
        {
          do
          {
LABEL_521:
            v219 = (unsigned __int8 *)v3;
            v226 = (unsigned __int8 *)(v3 + 1);
            v221 = *v3++;
          }
          while ((v221 - 33) >= 0xFFFFFFE0);
          if (v221 != 47)
            goto LABEL_535;
          v227 = *v226;
          if (v227 == 42)
          {
            v3 = (char *)(v219 + 2);
            if (v219[2])
            {
              do
              {
                if (*(v226 - 1) == 42 && *v226 == 47)
                  break;
                v230 = v226[2];
                ++v226;
              }
              while (v230);
              v3 = (char *)(v226 + 1);
            }
          }
          else
          {
            if (v227 != 47)
              goto LABEL_537;
            v228 = (char *)(v219 + 2);
            while (*v228)
            {
              v229 = *(v228 - 1);
              v3 = v228++;
              if (v229 == 10)
                goto LABEL_521;
            }
            v3 = v228;
          }
        }
      }
LABEL_113:
      if (!strncmp(v47, "vertex ", 7uLL))
        break;
      if (!strncmp(v47, "fragment ", 9uLL))
      {
        v61 = v47 + 8;
        do
        {
          v63 = *(unsigned __int8 *)++v61;
          v62 = v63;
        }
        while (v63 - 33 > 0xFFFFFFDF);
        if (v62 >= 0x21)
        {
          do
            v64 = *(unsigned __int8 *)++v61;
          while (v64 > 0x20);
        }
        v46 = v61 - 1;
        do
        {
          v66 = *(unsigned __int8 *)++v46;
          v65 = v66;
        }
        while (v66 - 33 > 0xFFFFFFDF);
        if (v65 >= 0x21)
        {
          while (v65 != 40)
          {
            v67 = *(unsigned __int8 *)++v46;
            v65 = v67;
            if (v67 <= 0x20)
              goto LABEL_103;
          }
          v647[0] = 396032;
          goto LABEL_21;
        }
      }
      else if (!strncmp(v47, "kernel ", 7uLL))
      {
        v46 = v47 + 6;
        do
          v68 = *(unsigned __int8 *)++v46;
        while ((v68 - 33) > 0xFFFFFFDF);
        if (!strncmp(v46, "void", 4uLL))
        {
LABEL_181:
          v19 = 2816;
          goto LABEL_182;
        }
      }
      else if (!strncmp(v47, "#include", 8uLL))
      {
        v46 = v47 + 7;
        do
          v70 = *(unsigned __int8 *)++v46;
        while ((v70 - 33) > 0xFFFFFFDF);
        if (!strncmp(v46, "<metal_common>", 0xEuLL)
          || !strncmp(v46, "<metal_graphics>", 0x10uLL)
          || !strncmp(v46, "<metal_matrix>", 0xEuLL)
          || !strncmp(v46, "<metal_geometric>", 0x11uLL)
          || !strncmp(v46, "<metal_math>", 0xCuLL)
          || !strncmp(v46, "<metal_texture>", 0xFuLL)
          || !strncmp(v46, "<metal_stdlib>", 0xEuLL)
          || !strncmp(v46, "<metal_integer>", 0xFuLL)
          || !strncmp(v46, "<metal_relational>", 0x12uLL)
          || !strncmp(v46, "<metal_compute>", 0xFuLL)
          || !strncmp(v46, "<metal_pack>", 0xCuLL)
          || !strncmp(v46, "<metal_atomic>", 0xEuLL))
        {
          goto LABEL_181;
        }
      }
      else if (v48 == 103 && *v49 == 108 && v47[2] == 95)
      {
        v46 = v47 + 3;
        if (!strncmp(v47 + 3, "TextureMatrix", 0xDuLL)
          || !strncmp(v47 + 3, "TexCoord", 8uLL)
          || !strncmp(v47 + 3, "MultiTexCoord", 0xDuLL)
          || !strncmp(v47 + 3, "ModelViewProjectionMatrix", 0x19uLL)
          || !strncmp(v47 + 3, "Position", 8uLL)
          || !strncmp(v47 + 3, "Vertex", 6uLL)
          || !strncmp(v47 + 3, "Normal", 6uLL)
          || !strncmp(v47 + 3, "FrontFacing", 0xBuLL)
          || !strncmp(v47 + 3, "FragDepth", 9uLL)
          || !strncmp(v47 + 3, "FragCoord", 9uLL)
          || !strncmp(v47 + 3, "FragColor", 9uLL)
          || !strncmp(v47 + 3, "FragData", 8uLL))
        {
          v19 = 394752;
LABEL_182:
          v647[0] = v19;
          if ((v19 & 0xFF00) == 0xB00)
            goto LABEL_21;
          goto LABEL_491;
        }
      }
      else
      {
        v46 = v47 - 1;
        do
          v69 = *(unsigned __int8 *)++v46;
        while (v69 > 0x20);
      }
    }
    v53 = v47 + 6;
    do
    {
      v55 = *(unsigned __int8 *)++v53;
      v54 = v55;
    }
    while (v55 - 33 > 0xFFFFFFDF);
    if (v54 >= 0x21)
    {
      do
        v56 = *(unsigned __int8 *)++v53;
      while (v56 > 0x20);
    }
    v46 = v53 - 1;
    do
    {
      v58 = *(unsigned __int8 *)++v46;
      v57 = v58;
    }
    while (v58 - 33 > 0xFFFFFFDF);
  }
  while (v57 < 0x21);
  while (v57 != 40)
  {
    v59 = *(unsigned __int8 *)++v46;
    v57 = v59;
    if (v59 <= 0x20)
      goto LABEL_103;
  }
  v647[0] = 330512;
LABEL_21:
  if (v18)
  {
    while (1)
    {
      do
      {
LABEL_24:
        v20 = v18;
        v21 = v18 + 1;
        v22 = *v18++;
      }
      while ((v22 - 33) >= 0xFFFFFFE0);
      if (v22 != 47)
        break;
      v23 = *v21;
      if (v23 == 42)
      {
        v18 = v20 + 2;
        if (v20[2])
        {
          do
          {
            if (*(v21 - 1) == 42 && *v21 == 47)
              break;
            v26 = v21[2];
            ++v21;
          }
          while (v26);
          v18 = v21 + 1;
        }
      }
      else
      {
        if (v23 != 47)
          goto LABEL_55;
        v24 = v20 + 2;
        while (*v24)
        {
          v25 = *(v24 - 1);
          v18 = v24++;
          if (v25 == 10)
            goto LABEL_24;
        }
        v18 = v24;
      }
    }
  }
  else
  {
    while (1)
    {
      do
      {
LABEL_39:
        v20 = (unsigned __int8 *)v3;
        v27 = (unsigned __int8 *)(v3 + 1);
        v22 = *v3++;
      }
      while ((v22 - 33) >= 0xFFFFFFE0);
      if (v22 != 47)
        break;
      v28 = *v27;
      if (v28 == 42)
      {
        v3 = (char *)(v20 + 2);
        if (v20[2])
        {
          do
          {
            if (*(v27 - 1) == 42 && *v27 == 47)
              break;
            v31 = v27[2];
            ++v27;
          }
          while (v31);
          v3 = (char *)(v27 + 1);
        }
      }
      else
      {
        if (v28 != 47)
          goto LABEL_55;
        v29 = (char *)(v20 + 2);
        while (*v29)
        {
          v30 = *(v29 - 1);
          v3 = v29++;
          if (v30 == 10)
            goto LABEL_39;
        }
        v3 = v29;
      }
    }
  }
  if (!v22)
    v20 = 0;
LABEL_55:
  __s1a = 0uLL;
  v660 = 0;
  v32 = v20;
  while (1)
  {
    do
    {
LABEL_58:
      v34 = v32;
      v35 = v32 + 1;
      v36 = *v32++;
    }
    while ((v36 - 33) >= 0xFFFFFFE0);
    if (v36 == 47)
    {
      v37 = *v35;
      if (v37 == 42)
      {
        v32 = v34 + 2;
        if (v34[2])
        {
          do
          {
            if (*(v35 - 1) == 42 && *v35 == 47)
              break;
            v41 = v35[2];
            ++v35;
          }
          while (v41);
          v32 = v35 + 1;
        }
        goto LABEL_58;
      }
      if (v37 == 47)
      {
        v38 = v34 + 2;
        while (*v38)
        {
          v39 = *(v38 - 1);
          v32 = v38++;
          if (v39 == 10)
            goto LABEL_58;
        }
        v32 = v38;
        goto LABEL_58;
      }
    }
    else if (!v36)
    {
      goto LABEL_187;
    }
    if (!strncmp((const char *)v34, "vertex ", 7uLL))
    {
      v71 = 330512;
      goto LABEL_186;
    }
    if (!strncmp((const char *)v34, "fragment ", 9uLL))
      break;
    if (!strncmp((const char *)v34, "kernel ", 7uLL))
    {
      v33 = (const char *)(v34 + 7);
LABEL_57:
      v647[0] = 2816;
      v32 = (unsigned __int8 *)v33;
      goto LABEL_58;
    }
    if (strncmp((const char *)v34, "#include", 8uLL))
    {
      v32 = v34 - 1;
      do
        v40 = *++v32;
      while (v40 > 0x20);
      goto LABEL_58;
    }
    v33 = (const char *)(v34 + 25);
    do
      v42 = *((unsigned __int8 *)v33++ - 17) - 33;
    while (v42 > 0xFFFFFFDF);
    v32 = (unsigned __int8 *)(v33 - 18);
    if (!strncmp(v33 - 18, "<metal_common>", 0xEuLL))
    {
LABEL_95:
      v33 -= 4;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_graphics>", 0x10uLL))
    {
      v33 -= 2;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_matrix>", 0xEuLL))
      goto LABEL_95;
    if (!strncmp(v33 - 18, "<metal_geometric>", 0x11uLL))
    {
      --v33;
      goto LABEL_57;
    }
    v43 = strncmp(v33 - 18, "<metal_math>", 0xCuLL);
    v44 = (unsigned __int8 *)(v33 - 6);
    if (!v43 || (v45 = strncmp(v33 - 18, "<metal_texture>", 0xFuLL), v44 = (unsigned __int8 *)(v33 - 3), !v45))
    {
      v33 = (const char *)v44;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_stdlib>", 0xEuLL))
      goto LABEL_95;
    if (!strncmp(v33 - 18, "<metal_integer>", 0xFuLL))
      goto LABEL_100;
    if (!strncmp(v33 - 18, "<metal_relational>", 0x12uLL))
      goto LABEL_57;
    if (!strncmp(v33 - 18, "<metal_compute>", 0xFuLL))
    {
LABEL_100:
      v33 -= 3;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_pack>", 0xCuLL))
    {
      v33 -= 6;
      goto LABEL_57;
    }
    if (!strncmp(v33 - 18, "<metal_atomic>", 0xEuLL))
      goto LABEL_95;
  }
  v71 = 396048;
LABEL_186:
  v647[0] = v71;
LABEL_187:
  __n = 0;
  v72 = "texCoord";
  v73 = "hg_Params[";
  j = (const char *)v20;
LABEL_188:
  v75 = j;
  while (1)
  {
    do
    {
LABEL_190:
      v76 = (char *)v75;
      v78 = v75 + 1;
      v77 = *(unsigned __int8 *)v75++;
    }
    while ((v77 - 33) >= 0xFFFFFFE0);
    if (v77 != 47)
      break;
    v79 = *(unsigned __int8 *)v78;
    if (v79 == 42)
    {
      v75 = v76 + 2;
      if (v76[2])
      {
        do
        {
          if (*(v78 - 1) == 42 && *v78 == 47)
            break;
        }
        while (*((unsigned __int8 *)v78++ + 2));
        v75 = v78 + 1;
      }
    }
    else
    {
      if (v79 != 47)
      {
LABEL_205:
        LODWORD(v656) = 0;
        v83 = *v76;
        if ((_DWORD)v83 == 95)
        {
          if (!strncmp(v78, v72, 8uLL))
          {
            v100 = v76[9];
            v99 = (unsigned __int8 *)(v76 + 9);
            v98 = v100;
            if ((v100 - 58) >= 0xFFFFFFF6)
            {
              v101 = 0;
              v102 = v99;
              do
              {
                v101 = v98 + 10 * v101 - 48;
                v116 = *++v102;
                v98 = v116;
              }
              while ((v116 - 58) > 0xFFFFFFF5);
              LODWORD(v656) = v101;
            }
            else
            {
              v101 = 0;
              v102 = 0;
            }
            if (v102)
              j = (const char *)v102;
            else
              j = (const char *)v99;
            if (v101 + 1 > WORD2(v649))
              v117 = v101 + 1;
            else
              v117 = WORD2(v649);
            WORD2(v649) = v117;
          }
          else
          {
            do
              v94 = *++v76;
            while (v94 > 0x20);
            j = v76;
          }
          goto LABEL_188;
        }
        if ((_DWORD)v83 == 91 && *v78 == 91)
        {
          v84 = v73;
          v85 = v72;
          v86 = v76 + 14;
          do
            v87 = *((unsigned __int8 *)v86++ - 12) - 33;
          while (v87 >= 0xFFFFFFE0);
          v88 = (unsigned __int8 *)(v86 - 13);
          v89 = (unsigned __int8 *)(v86 - 5);
          if (!strncmp(v86 - 13, "texture(", 8uLL))
          {
            v113 = *((unsigned __int8 *)v86 - 5);
            if ((v113 - 58) >= 0xFFFFFFF6)
            {
              v114 = 0;
              v115 = (unsigned __int8 *)(v86 - 5);
              v72 = v85;
              do
              {
                v114 = v113 + 10 * v114 - 48;
                v124 = *++v115;
                v113 = v124;
              }
              while ((v124 - 58) > 0xFFFFFFF5);
              LODWORD(v656) = v114;
            }
            else
            {
              v114 = 0;
              v115 = 0;
              v72 = v85;
            }
            v73 = v84;
            if (v115)
              v88 = v115;
            else
              v88 = v89;
            if (v114 + 1 > BYTE8(v649))
              v125 = v114 + 1;
            else
              v125 = BYTE8(v649);
            BYTE8(v649) = v125;
            if ((__n & 1) != 0)
            {
              __n = 0;
              LODWORD(v648) = v648 | (1 << v114);
            }
            else
            {
              __n = 0;
            }
          }
          else if (!strncmp(v86 - 13, "sampler(", 8uLL))
          {
            v120 = *((unsigned __int8 *)v86 - 5);
            if ((v120 - 58) >= 0xFFFFFFF6)
            {
              v130 = 0;
              v121 = (unsigned __int8 *)(v86 - 5);
              v72 = v85;
              do
              {
                v130 = v120 + 10 * v130 - 48;
                v131 = *++v121;
                v120 = v131;
              }
              while ((v131 - 58) > 0xFFFFFFF5);
              LODWORD(v656) = v130;
            }
            else
            {
              v121 = 0;
              v72 = v85;
            }
            v73 = v84;
            if (v121)
              v88 = v121;
            else
              v88 = v89;
          }
          else
          {
            if (!strncmp(v86 - 13, "user(texcoord", 0xDuLL))
            {
              v127 = *(unsigned __int8 *)v86;
              if ((v127 - 58) >= 0xFFFFFFF6)
              {
                v128 = 0;
                v129 = (unsigned __int8 *)v86;
                do
                {
                  v128 = v127 + 10 * v128 - 48;
                  v136 = *++v129;
                  v127 = v136;
                }
                while ((v136 - 58) > 0xFFFFFFF5);
                LODWORD(v656) = v128;
              }
              else
              {
                v128 = 0;
                v129 = 0;
              }
              if (v129)
                v88 = v129;
              else
                v88 = (unsigned __int8 *)v86;
              if (v128 + 1 > WORD2(v649))
                v137 = v128 + 1;
              else
                v137 = WORD2(v649);
              WORD2(v649) = v137;
            }
            else if (!strncmp(v86 - 13, "stage_in", 8uLL))
            {
              v647[0] = 396048;
              v88 = (unsigned __int8 *)(v86 - 5);
            }
            else if (!strncmp(v86 - 13, "vertex_id", 9uLL))
            {
              v88 = (unsigned __int8 *)(v86 - 4);
              v647[0] = 330512;
            }
            else if (!strncmp(v86 - 13, "position", 8uLL))
            {
              v88 = (unsigned __int8 *)(v86 - 5);
            }
            else if (!strncmp(v86 - 13, "color(", 6uLL))
            {
              v144 = *((unsigned __int8 *)v86 - 7);
              v143 = (unsigned __int8 *)(v86 - 7);
              v142 = v144;
              if ((v144 - 58) >= 0xFFFFFFF6)
              {
                v145 = 0;
                v146 = v143;
                do
                {
                  v145 = v142 + 10 * v145 - 48;
                  v147 = *++v146;
                  v142 = v147;
                }
                while ((v147 - 58) > 0xFFFFFFF5);
                LODWORD(v656) = v145;
              }
              else
              {
                v145 = 0;
                v146 = 0;
              }
              if (v146)
                v88 = v146;
              else
                v88 = v143;
              if (v145 + 1 > BYTE10(v649))
                v148 = v145 + 1;
              else
                v148 = BYTE10(v649);
              BYTE10(v649) = v148;
            }
            else if (!strncmp(v86 - 13, "depth(any)", 0xAuLL))
            {
              v88 = (unsigned __int8 *)(v86 - 3);
              BYTE9(v649) = 1;
            }
            v72 = v85;
            v73 = v84;
          }
          for (j = (const char *)(v88 + 2); *(j - 2) != 93 || *(j - 1) != 93; ++j)
            ;
          goto LABEL_188;
        }
        if (!strncmp(v76, v73, 0xAuLL))
        {
          v95 = v76[10];
          if ((v95 - 58) >= 0xFFFFFFF6)
          {
            v96 = 0;
            v97 = (unsigned __int8 *)(v76 + 10);
            do
            {
              v96 = v95 + 10 * v96 - 48;
              v107 = *++v97;
              v95 = v107;
            }
            while ((v107 - 58) > 0xFFFFFFF5);
            LODWORD(v656) = v96;
          }
          else
          {
            v96 = 0;
            v97 = 0;
          }
          if (!v97)
            v97 = (unsigned __int8 *)(v76 + 10);
          if (v96 + 1 > WORD3(v648))
            v108 = v96 + 1;
          else
            v108 = WORD3(v648);
          WORD3(v648) = v108;
          j = (const char *)(v97 + 1);
        }
        else
        {
          v90 = v72;
          v91 = strncmp(v76, "FragmentOut ", 0xCuLL);
          j = v76 + 12;
          if (v91)
            v92 = 0;
          else
            v92 = v76 + 12;
          if (!v91 && strncmp(v76 + 12, "fragmentFunc", 0xCuLL))
          {
            v103 = *(unsigned __int8 *)j;
            if (*j)
            {
              do
              {
                if (v103 < 0x21)
                  break;
                if ((ctype[2 * v103] & 0x40) == 0)
                  break;
                v104 = *(unsigned __int8 *)++j;
                v103 = v104;
              }
              while (v104);
            }
            v105 = j - v92;
            if ((unint64_t)(j - v92) >= 0x7FFFFFFFFFFFFFF8)
              std::string::__throw_length_error[abi:ne180100]();
            if (v105 >= 0x17)
            {
              v122 = (v105 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v105 | 7) != 0x17)
                v122 = v105 | 7;
              v123 = v122 + 1;
              p_dst = (__int128 *)operator new(v122 + 1);
              *((_QWORD *)&__dst + 1) = j - v92;
              v658 = v123 | 0x8000000000000000;
              *(_QWORD *)&__dst = p_dst;
            }
            else
            {
              HIBYTE(v658) = (_BYTE)j - (_BYTE)v92;
              p_dst = &__dst;
              if (j == v92)
                goto LABEL_293;
            }
            memmove(p_dst, v92, j - v92);
LABEL_293:
            v72 = v90;
            *((_BYTE *)p_dst + v105) = 0;
            v73 = "hg_Params[";
            if (SHIBYTE(v660) < 0)
              operator delete((void *)__s1a);
            __s1a = __dst;
            v660 = v658;
            goto LABEL_188;
          }
          v93 = HIBYTE(v660);
          if (SHIBYTE(v660) < 0)
          {
            if (*((_QWORD *)&__s1a + 1))
            {
              if (*((_QWORD *)&__s1a + 1) == -1)
                std::string::__throw_out_of_range[abi:ne180100]();
              if (!memcmp((const void *)__s1a, v76, *((size_t *)&__s1a + 1)))
                goto LABEL_282;
            }
          }
          else if (HIBYTE(v660) && !memcmp(&__s1a, v76, HIBYTE(v660)))
          {
LABEL_282:
            if ((v93 & 0x80u) == 0)
              v119 = v93;
            else
              v119 = *((_QWORD *)&__s1a + 1);
            j = &v76[v119];
            if (!strncmp(&v76[v119], ".color", 6uLL))
            {
              v133 = *((unsigned __int8 *)j + 6);
              j += 6;
              v132 = v133;
              v72 = v90;
              v134 = 0;
              if ((v133 - 58) >= 0xFFFFFFF6)
              {
                v135 = j;
                v73 = "hg_Params[";
                do
                {
                  v134 = v132 + 10 * v134 - 48;
                  v138 = *(unsigned __int8 *)++v135;
                  v132 = v138;
                }
                while ((v138 - 58) > 0xFFFFFFF5);
                LODWORD(v656) = v134;
              }
              else
              {
                v135 = 0;
                v73 = "hg_Params[";
              }
              if (v135)
                j = v135;
              if (v134 + 1 > BYTE10(v649))
                v139 = v134 + 1;
              else
                v139 = BYTE10(v649);
              BYTE10(v649) = v139;
            }
            else
            {
              v72 = v90;
              v73 = "hg_Params[";
            }
            if (!strncmp(j, ".depth", 6uLL))
              v647[1] |= 0x2000000u;
            goto LABEL_188;
          }
          j = v76 + 9;
          v72 = v90;
          if (!strncmp(v76, "texture2d", 9uLL))
          {
            v111 = *(unsigned __int8 *)j;
            if (*j)
            {
              v73 = "hg_Params[";
              do
              {
                if (v111 >= 0x21 && v111 != 60)
                  break;
                v112 = *(unsigned __int8 *)++j;
                v111 = v112;
              }
              while (v112);
            }
            else
            {
              v73 = "hg_Params[";
            }
            if (!strncmp(j, "half", 4uLL))
            {
              v647[1] |= 0x400000u;
              __n = 1;
            }
            else
            {
              __n &= strncmp(j, "float", 5uLL) != 0;
            }
          }
          else if ((_DWORD)v83 == 46)
          {
            do
              v110 = *++v76;
            while ((v110 - 48) < 0xA);
            j = v76;
            v73 = "hg_Params[";
          }
          else if ((v83 - 48) > 9)
          {
            v126 = (v83 - 33);
            if (v126 > 0x3A)
              goto LABEL_356;
            if (((1 << (v83 - 33)) & 0x5E00) != 0)
              goto LABEL_314;
            if (((1 << (v83 - 33)) & 0x38000001) != 0)
            {
              if (*v78 == 61 || (_DWORD)v83 == 44 || (_DWORD)v83 == 61)
              {
LABEL_314:
                j = v78;
                v73 = "hg_Params[";
                goto LABEL_188;
              }
LABEL_356:
              if (!strncmp(v76, "get_num_mip_levels", 0x12uLL))
              {
                j = v76 + 18;
                v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_num_samples", 0xFuLL))
              {
                j = v76 + 15;
                v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_array_size", 0xEuLL))
              {
                j = v76 + 14;
                v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_height", 0xAuLL))
              {
                j = v76 + 10;
                v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_width", 9uLL))
              {
                v73 = "hg_Params[";
                goto LABEL_188;
              }
              if (!strncmp(v76, "get_depth", 9uLL))
              {
                v73 = "hg_Params[";
                goto LABEL_188;
              }
              v141 = (unsigned __int8 *)(v76 + 6);
              if (!strncmp(v76, "sample", 6uLL) || !strncmp(v76, "gather", 6uLL))
                goto LABEL_432;
              if (strncmp(v76, "write", 5uLL))
              {
                v141 = (unsigned __int8 *)(v76 + 4);
                if (!strncmp(v76, "read", 4uLL))
                  goto LABEL_432;
                if (!strncmp(v76, "discard_fragment", 0x10uLL))
                {
                  j = v76 + 16;
                  goto LABEL_437;
                }
                if (!strncmp(v76, "normalize", 9uLL))
                {
LABEL_437:
                  v72 = v90;
                  v73 = "hg_Params[";
                  goto LABEL_188;
                }
                if (!strncmp(v76, "reflect", 7uLL))
                {
                  j = v76 + 7;
                  goto LABEL_437;
                }
                if (strncmp(v76, "rsqrt", 5uLL)
                  && strncmp(v76, "cross", 5uLL)
                  && strncmp(v76, "clamp", 5uLL)
                  && strncmp(v76, "fract", 5uLL)
                  && strncmp(v76, "floor", 5uLL)
                  && strncmp(v76, "while", 5uLL)
                  && strncmp(v76, "ilogb", 5uLL)
                  && strncmp(v76, "ldexp", 5uLL)
                  && strncmp(v76, "round", 5uLL)
                  && strncmp(v76, "atan2", 5uLL)
                  && strncmp(v76, "trunc", 5uLL))
                {
                  if (strncmp(v76, "ceil", 4uLL)
                    && strncmp(v76, "log2", 4uLL)
                    && strncmp(v76, "exp2", 4uLL)
                    && strncmp(v76, "dfdx", 4uLL)
                    && strncmp(v76, "dfdy", 4uLL)
                    && strncmp(v76, "sqrt", 4uLL)
                    && strncmp(v76, "acos", 4uLL)
                    && strncmp(v76, "asin", 4uLL)
                    && strncmp(v76, "atan", 4uLL)
                    && strncmp(v76, "fmax", 4uLL)
                    && strncmp(v76, "fmin", 4uLL))
                  {
                    j = v76 + 3;
                    if (strncmp(v76, "abs", 3uLL)
                      && strncmp(v76, "min", 3uLL)
                      && strncmp(v76, "max", 3uLL)
                      && strncmp(v76, "dot", 3uLL)
                      && strncmp(v76, "pow", 3uLL)
                      && strncmp(v76, "cos", 3uLL)
                      && strncmp(v76, "sin", 3uLL)
                      && strncmp(v76, "tan", 3uLL)
                      && strncmp(v76, "mod", 3uLL)
                      && strncmp(v76, "mix", 3uLL)
                      && strncmp(v76, "for", 3uLL))
                    {
                      if (!strncmp(v76, "if", 2uLL))
                      {
                        j = v76 + 2;
                      }
                      else if ((ctype[2 * v83] & 0x40) != 0)
                      {
                        if ((_DWORD)v83)
                        {
                          do
                          {
                            if ((ctype[2 * v83] & 0x40) == 0)
                              break;
                            v151 = *++v76;
                            LODWORD(v83) = v151;
                          }
                          while (v151);
                        }
                        j = v76;
                      }
                      else
                      {
                        j = v78;
                      }
                    }
                    goto LABEL_437;
                  }
LABEL_432:
                  j = (const char *)v141;
                  goto LABEL_437;
                }
              }
              j = v76 + 5;
              goto LABEL_437;
            }
            if (v126 != 58)
              goto LABEL_356;
            v140 = glsl::glindex((glsl *)v76, (char *)&v656, v109);
            if (v140)
            {
              j = v140;
              v73 = "hg_Params[";
            }
            else
            {
              j = v76;
              v73 = "hg_Params[";
              do
              {
                v150 = *(unsigned __int8 *)++j;
                v149 = v150;
              }
              while (v150 && v149 != 93);
            }
          }
          else
          {
            v73 = "hg_Params[";
            do
              v118 = *++v76;
            while ((v118 - 48) < 0xA);
            ++WORD2(v648);
            j = v76;
          }
        }
        goto LABEL_188;
      }
      v80 = v76 + 2;
      while (*v80)
      {
        v81 = *((unsigned __int8 *)v80 - 1);
        v75 = v80++;
        if (v81 == 10)
          goto LABEL_190;
      }
      v75 = v80;
    }
  }
  if (v77)
    goto LABEL_205;
  HIDWORD(v649) = 16 * WORD3(v648);
  LOBYTE(v152) = v647[0];
  v153 = v647[0] | 0x60B00;
  if (v647[0] < 0x100)
  {
    v154 = 1;
  }
  else
  {
    v153 = v647[0];
    v154 = LOBYTE(v647[0]) == 0;
  }
  if (v154)
  {
    if ((_BYTE)v153)
      v152 = v153;
    else
      v152 = v153 | 0x10;
    v647[0] = v152;
    if (SHIBYTE(v660) < 0)
      goto LABEL_452;
LABEL_455:
    v156 = *((_QWORD *)this + 1);
    v155 = *((_QWORD *)this + 2);
    v157 = v156 + 7;
    if (v155)
      goto LABEL_456;
LABEL_453:
    str_alloc((string_t *)this, v157);
  }
  else
  {
    if ((SHIBYTE(v660) & 0x80000000) == 0)
      goto LABEL_455;
LABEL_452:
    operator delete((void *)__s1a);
    v156 = *((_QWORD *)this + 1);
    v155 = *((_QWORD *)this + 2);
    v157 = v156 + 7;
    if (!v155)
      goto LABEL_453;
LABEL_456:
    if (v157 >= *(_QWORD *)v155)
    {
      v158 = malloc_type_realloc(*(void **)(v155 + 16), (v156 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v159 = (unint64_t *)*((_QWORD *)this + 2);
      v159[2] = (unint64_t)v158;
      *v159 = (v156 + 262) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)this = v158;
    }
  }
  v160 = *(_QWORD *)this;
  *((_QWORD *)this + 1) += 7;
  v161 = (_DWORD *)(v160 + v156);
  *(_DWORD *)((char *)v161 + 3) = 1818326117;
  *v161 = 1699557167;
  v163 = *((_QWORD *)this + 1);
  v162 = *((_QWORD *)this + 2);
  v164 = v163 + 20;
  if (v162)
  {
    if (v164 >= *(_QWORD *)v162)
    {
      v165 = malloc_type_realloc(*(void **)(v162 + 16), (v163 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v166 = (unint64_t *)*((_QWORD *)this + 2);
      v166[2] = (unint64_t)v165;
      *v166 = (v163 + 275) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)this = v165;
    }
  }
  else
  {
    str_alloc((string_t *)this, v164);
  }
  v167 = itoa((char *)(*(_QWORD *)this + v163), v152 >> 4);
  v168 = *((_QWORD *)this + 2);
  v169 = *((_QWORD *)this + 1) + v167;
  *((_QWORD *)this + 1) = v169;
  v170 = v169 + 1;
  if (v168)
  {
    if (v170 >= *(_QWORD *)v168)
    {
      v171 = malloc_type_realloc(*(void **)(v168 + 16), (v169 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v172 = (_QWORD *)*((_QWORD *)this + 2);
      v172[2] = v171;
      *v172 = (v169 & 0xFFFFFFFFFFFFFF00) + 256;
      *(_QWORD *)this = v171;
    }
  }
  else
  {
    str_alloc((string_t *)this, v170);
  }
  v173 = *(_QWORD *)this;
  ++*((_QWORD *)this + 1);
  *(_BYTE *)(v173 + v169) = 46;
  v174 = v647[0] & 0xF;
  v176 = *((_QWORD *)this + 1);
  v175 = *((_QWORD *)this + 2);
  v177 = v176 + 20;
  if (v175)
  {
    if (v177 >= *(_QWORD *)v175)
    {
      v178 = malloc_type_realloc(*(void **)(v175 + 16), (v176 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v179 = (unint64_t *)*((_QWORD *)this + 2);
      v179[2] = (unint64_t)v178;
      *v179 = (v176 + 275) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)this = v178;
    }
  }
  else
  {
    str_alloc((string_t *)this, v177);
  }
  v180 = itoa((char *)(*(_QWORD *)this + v176), v174);
  v181 = *((_QWORD *)this + 2);
  v182 = *((_QWORD *)this + 1) + v180;
  *((_QWORD *)this + 1) = v182;
  if (v181)
  {
    if (*(_QWORD *)v181 <= 0xFuLL)
    {
      v183 = malloc_type_realloc(*(void **)(v181 + 16), 0x100uLL, 0xCCCD1039uLL);
      v184 = (_QWORD *)*((_QWORD *)this + 2);
      v184[2] = v183;
      *v184 = 256;
      *(_QWORD *)this = v183;
    }
  }
  else
  {
    str_alloc((string_t *)this, 15);
  }
  v185 = *(_QWORD *)this;
  *((_QWORD *)this + 1) += 15 - v182;
  memcpy((void *)(v185 + v182), "               ", 15 - v182);
  v187 = *((_QWORD *)this + 1);
  v186 = *((_QWORD *)this + 2);
  v188 = v187 + 1;
  if (v186)
  {
    if (v188 >= *(_QWORD *)v186)
    {
      v189 = malloc_type_realloc(*(void **)(v186 + 16), (v187 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v190 = (_QWORD *)*((_QWORD *)this + 2);
      v190[2] = v189;
      *v190 = (v187 & 0xFFFFFFFFFFFFFF00) + 256;
      *(_QWORD *)this = v189;
    }
  }
  else
  {
    str_alloc((string_t *)this, v188);
  }
  v191 = *(_QWORD *)this;
  ++*((_QWORD *)this + 1);
  *(_BYTE *)(v191 + v187) = 10;
  v193 = *((_QWORD *)this + 1);
  v192 = *((_QWORD *)this + 2);
  v194 = v193 + 17;
  if (v192)
  {
    if (v194 >= *(_QWORD *)v192)
    {
      v195 = malloc_type_realloc(*(void **)(v192 + 16), (v193 + 272) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v196 = (unint64_t *)*((_QWORD *)this + 2);
      v196[2] = (unint64_t)v195;
      *v196 = (v193 + 272) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)this = v195;
    }
  }
  else
  {
    str_alloc((string_t *)this, v194);
  }
  v197 = *(_QWORD *)this;
  *((_QWORD *)this + 1) += 17;
  v198 = v197 + v193;
  *(_OWORD *)v198 = *(_OWORD *)"//LEN=0000000000\n";
  *(_BYTE *)(v198 + 16) = 10;
  v200 = *((_QWORD *)this + 1);
  v199 = *((_QWORD *)this + 2);
  v201 = v200 + j - (const char *)v20;
  if (v199)
  {
    if (v201 >= *(_QWORD *)v199)
    {
      v202 = (v201 + 255) & 0xFFFFFFFFFFFFFF00;
      v203 = malloc_type_realloc(*(void **)(v199 + 16), v202, 0xCCCD1039uLL);
      v204 = (size_t *)*((_QWORD *)this + 2);
      v204[2] = (size_t)v203;
      *v204 = v202;
      *(_QWORD *)this = v203;
    }
  }
  else
  {
    str_alloc((string_t *)this, v201);
  }
  v205 = *(_QWORD *)this;
  *((_QWORD *)this + 1) += j - (const char *)v20;
  memcpy((void *)(v205 + v200), v20, j - (const char *)v20);
  if (*(j - 1) != 10)
  {
    v207 = *((_QWORD *)this + 1);
    v206 = *((_QWORD *)this + 2);
    v208 = v207 + 1;
    if (v206)
    {
      if (v208 >= *(_QWORD *)v206)
      {
        v209 = malloc_type_realloc(*(void **)(v206 + 16), (v207 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
        v210 = (_QWORD *)*((_QWORD *)this + 2);
        v210[2] = v209;
        *v210 = (v207 & 0xFFFFFFFFFFFFFF00) + 256;
        *(_QWORD *)this = v209;
      }
    }
    else
    {
      str_alloc((string_t *)this, v208);
    }
    v211 = *(_QWORD *)this;
    ++*((_QWORD *)this + 1);
    *(_BYTE *)(v211 + v207) = 10;
  }
  v213 = *(int **)this;
  v212 = *((_QWORD *)this + 1);
  v214 = HGDigestInit(&__dst);
  if (v212 >= 0x40)
  {
    v217 = v212 >> 6;
    do
    {
      HGDigestAdd(&__dst, v213);
      v213 += 16;
      --v217;
    }
    while (v217);
    v212 &= 0x3Fu;
  }
  if (v212)
  {
    memcpy(&__s1a, v213, v212);
    bzero((char *)&__s1a + v212, 64 - v212);
    HGDigestAdd(&__dst, (int *)&__s1a);
  }
  glsl::end((string_t *)this, (uint64_t)v647, (unsigned int *)&__dst, 0, v214, v215, v216);
  return 4294967264;
}

void sub_1B2A048C0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 137) < 0)
  {
    operator delete(*(void **)(v1 - 160));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *arb::atok(_BYTE *this, const char *a2)
{
  int v2;
  int v3;
  int v4;

  v2 = *this;
  if (*this)
  {
    if ((v2 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_3:
        v3 = *++this;
        v2 = v3;
      }
      while ((v3 - 33) > 0xFFFFFFDF);
    }
LABEL_4:
    if (v2 == 35)
    {
      ++this;
      while (1)
      {
        v2 = *this;
        if (!*this)
          break;
        v4 = *(this++ - 1);
        if (v4 == 10)
        {
          --this;
          if ((v2 - 33) >= 0xFFFFFFE0)
            goto LABEL_3;
          goto LABEL_4;
        }
      }
    }
  }
  return this;
}

void arb::obj_write(uint64_t *a1, uint64_t a2, uint64_t a3, char *__s1)
{
  int v6;
  int v7;
  int v8;
  const HGLimits *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t *v14;
  string_t v15;
  uint64_t v16;
  unint64_t v17;
  string_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  unint64_t *v24;
  string_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  void *v36;
  unint64_t *v37;
  unint64_t v38;
  void *v39;
  unint64_t *v40;
  string_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  void *v45;
  unint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  void *v51;
  unint64_t *v52;
  string_t v53;
  uint64_t *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  _QWORD *v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  char *v81;
  string_t v82;
  uint64_t v83;
  const void *v84;
  size_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  size_t v89;
  void *v90;
  size_t *v91;
  string_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  void *v96;
  unint64_t *v97;
  string_t v98;
  char *v99;
  signed int v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  void *v104;
  unint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  void *v110;
  _QWORD *v111;
  unint64_t v112;
  void *v113;
  unint64_t *v114;
  string_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  uint64_t v121;
  unint64_t v122;
  size_t v123;
  void *v124;
  size_t *v125;
  uint64_t v126;
  _BYTE *v127;
  uint64_t v128;
  int v129;
  _BYTE *v130;
  int v131;
  int v132;
  int v133;
  unint64_t v134;
  void *v135;
  unint64_t *v136;
  string_t v137;
  char *v138;
  signed int v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  void *v143;
  unint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  void *v149;
  unint64_t *v150;
  string_t v151;
  char *v152;
  uint64_t v153;
  char *v154;
  string_t v155;
  uint64_t v156;
  const void *v157;
  size_t v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  size_t v162;
  void *v163;
  size_t *v164;
  string_t v165;
  uint64_t v166;
  uint64_t v167;
  unint64_t v168;
  void *v169;
  unint64_t *v170;
  string_t v171;
  char *v172;
  signed int v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v176;
  void *v177;
  unint64_t *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  unint64_t v182;
  void *v183;
  _QWORD *v184;
  unint64_t v185;
  void *v186;
  unint64_t *v187;
  string_t v188;
  uint64_t v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  char *v193;
  uint64_t v194;
  unint64_t v195;
  size_t v196;
  void *v197;
  size_t *v198;
  uint64_t v199;
  _BYTE *v200;
  uint64_t v201;
  int v202;
  _BYTE *v203;
  int v204;
  int v205;
  int v206;
  unint64_t v207;
  void *v208;
  unint64_t *v209;
  string_t v210;
  char *v211;
  signed int v212;
  uint64_t v213;
  uint64_t v214;
  unint64_t v215;
  void *v216;
  unint64_t *v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  unint64_t v221;
  void *v222;
  unint64_t *v223;
  string_t v224;
  char *v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  uint64_t v229;
  unint64_t *v230;
  unint64_t v231;
  uint64_t v232;
  unint64_t v233;
  unint64_t v234;
  _QWORD *v235;
  int v236;
  unint64_t v237;
  unint64_t v238;
  _QWORD *v239;
  string_t v240;
  char *v241;
  uint64_t v242;
  const void *v243;
  size_t v244;
  uint64_t v245;
  uint64_t v246;
  unint64_t v247;
  size_t v248;
  void *v249;
  size_t *v250;
  string_t v251;
  uint64_t v252;
  uint64_t v253;
  unint64_t v254;
  void *v255;
  unint64_t *v256;
  string_t v257;
  signed int v258;
  uint64_t v259;
  uint64_t v260;
  unint64_t v261;
  void *v262;
  unint64_t *v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  unint64_t v267;
  uint64_t *v268;
  void *v269;
  unint64_t *v270;
  string_t v271;
  signed int v272;
  uint64_t v273;
  uint64_t v274;
  unint64_t v275;
  void *v276;
  unint64_t *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  unint64_t v281;
  void *v282;
  unint64_t *v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  uint64_t v287;
  unint64_t *v288;
  unint64_t v289;
  uint64_t v290;
  unint64_t v291;
  unint64_t v292;
  _QWORD *v293;
  int v294;
  unint64_t v295;
  unint64_t v296;
  uint64_t v297;
  string_t v298;
  uint64_t v299;
  const void *v300;
  size_t v301;
  uint64_t v302;
  uint64_t v303;
  unint64_t v304;
  size_t v305;
  void *v306;
  size_t *v307;
  string_t v308;
  uint64_t v309;
  uint64_t v310;
  unint64_t v311;
  void *v312;
  unint64_t *v313;
  string_t v314;
  signed int v315;
  uint64_t v316;
  uint64_t v317;
  unint64_t v318;
  void *v319;
  unint64_t *v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  unint64_t v324;
  void *v325;
  _QWORD *v326;
  string_t v327;
  uint64_t v328;
  unint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  unint64_t v333;
  size_t v334;
  void *v335;
  size_t *v336;
  uint64_t v337;
  _BYTE *v338;
  uint64_t v339;
  int v340;
  _BYTE *v341;
  int v342;
  int v343;
  int v344;
  unint64_t v345;
  void *v346;
  unint64_t *v347;
  unint64_t v348;
  unint64_t v349;
  unint64_t v350;
  uint64_t v351;
  unint64_t *v352;
  unint64_t v353;
  uint64_t v354;
  unint64_t v355;
  unint64_t v356;
  _QWORD *v357;
  int v358;
  unint64_t v359;
  unint64_t v360;
  _QWORD *v361;
  string_t v362;
  char *v363;
  uint64_t v364;
  const void *v365;
  size_t v366;
  uint64_t v367;
  uint64_t v368;
  unint64_t v369;
  size_t v370;
  void *v371;
  size_t *v372;
  string_t v373;
  uint64_t v374;
  uint64_t v375;
  unint64_t v376;
  void *v377;
  unint64_t *v378;
  string_t v379;
  char *v380;
  signed int v381;
  uint64_t v382;
  uint64_t v383;
  unint64_t v384;
  void *v385;
  unint64_t *v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  unint64_t v390;
  void *v391;
  _QWORD *v392;
  string_t v393;
  signed int v394;
  uint64_t v395;
  uint64_t v396;
  unint64_t v397;
  void *v398;
  unint64_t *v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  unint64_t v403;
  void *v404;
  unint64_t *v405;
  uint64_t v406;
  uint64_t v407;
  unint64_t v408;
  uint64_t v409;
  void *v410;
  unint64_t *v411;
  string_t v412;
  uint64_t v413;
  uint64_t v414;
  unint64_t v415;
  void *v416;
  unint64_t *v417;
  string_t v418;
  char *v419;
  uint64_t v420;
  uint64_t v421;
  unint64_t v422;
  void *v423;
  unint64_t *v424;
  uint64_t v425;
  unint64_t v426;
  unint64_t v427;
  uint64_t v428;
  void *v429;
  unint64_t *v430;
  string_t v431;
  uint64_t v432;
  uint64_t v433;
  unint64_t v434;
  void *v435;
  unint64_t *v436;
  unint64_t v437;
  uint64_t v438;
  void *v439;
  unint64_t *v440;
  string_t v441;
  uint64_t v442;
  uint64_t v443;
  unint64_t v444;
  void *v445;
  unint64_t *v446;
  string_t v447;
  char *v448;
  uint64_t v449;
  uint64_t v450;
  unint64_t v451;
  void *v452;
  unint64_t *v453;
  uint64_t v454;
  unint64_t v455;
  unint64_t v456;
  uint64_t v457;
  void *v458;
  unint64_t *v459;
  string_t v460;
  uint64_t v461;
  uint64_t v462;
  unint64_t v463;
  void *v464;
  unint64_t *v465;
  unint64_t v466;
  uint64_t v467;
  void *v468;
  unint64_t *v469;
  string_t v470;
  uint64_t v471;
  uint64_t v472;
  unint64_t v473;
  void *v474;
  unint64_t *v475;
  string_t v476;
  char *v477;
  uint64_t v478;
  uint64_t v479;
  unint64_t v480;
  void *v481;
  unint64_t *v482;
  uint64_t v483;
  unint64_t v484;
  unint64_t v485;
  uint64_t v486;
  void *v487;
  unint64_t *v488;
  string_t v489;
  uint64_t v490;
  uint64_t v491;
  unint64_t v492;
  void *v493;
  unint64_t *v494;
  unint64_t v495;
  uint64_t v496;
  void *v497;
  unint64_t *v498;
  string_t v499;
  uint64_t v500;
  uint64_t v501;
  unint64_t v502;
  void *v503;
  unint64_t *v504;
  string_t v505;
  char *v506;
  uint64_t v507;
  uint64_t v508;
  unint64_t v509;
  void *v510;
  unint64_t *v511;
  uint64_t v512;
  unint64_t v513;
  unint64_t v514;
  uint64_t v515;
  void *v516;
  unint64_t *v517;
  string_t v518;
  uint64_t v519;
  uint64_t v520;
  unint64_t v521;
  void *v522;
  unint64_t *v523;
  unint64_t v524;
  uint64_t v525;
  void *v526;
  unint64_t *v527;
  string_t v528;
  uint64_t v529;
  uint64_t v530;
  unint64_t v531;
  void *v532;
  unint64_t *v533;
  string_t v534;
  char *v535;
  uint64_t v536;
  uint64_t v537;
  unint64_t v538;
  void *v539;
  unint64_t *v540;
  uint64_t v541;
  unint64_t v542;
  unint64_t v543;
  uint64_t v544;
  void *v545;
  unint64_t *v546;
  string_t v547;
  uint64_t v548;
  uint64_t v549;
  unint64_t v550;
  void *v551;
  unint64_t *v552;
  unint64_t v553;
  uint64_t v554;
  void *v555;
  unint64_t *v556;
  string_t v557;
  uint64_t v558;
  uint64_t v559;
  unint64_t v560;
  void *v561;
  unint64_t *v562;
  string_t v563;
  char *v564;
  int v565;
  int v566;
  int v567;
  string_t v568;
  char *v569;
  int v570;
  char *v571;
  int v572;
  int v573;
  int v574;
  char *v575;
  int v576;
  int v577;
  int v578;
  int v579;
  int v580;
  char *v581;
  char *v582;
  int v583;
  int v584;
  int v585;
  int v586;
  char *v587;
  int v588;
  int v589;
  int v590;
  int v591;
  char *v592;
  int v593;
  char *v594;
  char *v595;
  int v596;
  int v597;
  int v598;
  int v599;
  char *v600;
  int v601;
  char *v602;
  unint64_t v603;
  BOOL v604;
  char *v605;
  uint64_t v606;
  uint64_t v607;
  unint64_t v608;
  void *v609;
  unint64_t *v610;
  int v611;
  char *v612;
  int v613;
  _BYTE *v614;
  char *v615;
  uint64_t v616;
  uint64_t v617;
  unint64_t v618;
  void *v619;
  unint64_t *v620;
  int v621;
  char *v622;
  uint64_t v623;
  char v624;
  char *v625;
  uint64_t v626;
  uint64_t v627;
  unint64_t v628;
  void *v629;
  unint64_t *v630;
  int v631;
  char *v632;
  unint64_t v633;
  unint64_t v635;
  char *v637;
  uint64_t v638;
  uint64_t v639;
  unint64_t v640;
  void *v641;
  unint64_t *v642;
  int v643;
  char *v644;
  char *v645;
  int v646;
  char *v647;
  int v648;
  int v649;
  int v650;
  unint64_t v651;
  char *v653;
  uint64_t v654;
  uint64_t v655;
  unint64_t v656;
  void *v657;
  unint64_t *v658;
  int v659;
  char *v660;
  int v661;
  char *v662;
  uint64_t v663;
  uint64_t v664;
  unint64_t v665;
  void *v666;
  unint64_t *v667;
  int v668;
  char *v669;
  int v670;
  char *v671;
  int v672;
  char *v673;
  char *v674;
  int v675;
  char *v676;
  unint64_t *v677;
  unsigned __int8 *v678;
  uint64_t v679;
  uint64_t v680;
  string_t v681;
  void *v682;
  void *v683;
  size_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  _BYTE *v688;
  _QWORD *v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  unint64_t v693;
  void *v694;
  _QWORD *v695;
  uint64_t v696;
  uint64_t v697;
  unint64_t v698;
  void *v699;
  unint64_t *v700;
  uint64_t v701;
  uint64_t v702;
  unint64_t v703;
  void *v704;
  unint64_t *v705;
  int v706;
  char *v707;
  int v708;
  char *v709;
  int v710;
  char *v711;
  int v712;
  char *v713;
  int v714;
  char *v715;
  int v716;
  char *v717;
  int v718;
  char *v719;
  uint64_t v720;
  uint64_t v721;
  unint64_t v722;
  void *v723;
  unint64_t *v724;
  uint64_t v725;
  uint64_t v726;
  unint64_t v727;
  void *v728;
  unint64_t *v729;
  string_t v730;
  uint64_t v731;
  uint64_t v732;
  unint64_t v733;
  void *v734;
  unint64_t *v735;
  string_t v736;
  char *v737;
  int v738;
  char *v739;
  int v740;
  int v741;
  int v742;
  int v743;
  int v744;
  int v745;
  int v746;
  unsigned __int8 *v747;
  uint64_t v748;
  uint64_t v749;
  unint64_t v750;
  void *v751;
  unint64_t *v752;
  string_t v753;
  unsigned __int8 *v754;
  uint64_t v755;
  uint64_t v756;
  unint64_t v757;
  void *v758;
  unint64_t *v759;
  string_t v760;
  unsigned __int8 *v761;
  int v762;
  unsigned __int8 *v763;
  int v764;
  unsigned __int8 *v765;
  int v766;
  int v767;
  string_t v768;
  unsigned __int8 *v769;
  int v770;
  unsigned __int8 *v771;
  int v772;
  unsigned __int8 *v773;
  int v774;
  int v775;
  string_t v776;
  char *v777;
  int v778;
  _BOOL4 v779;
  arb *v780;
  unsigned __int8 *v781;
  int v782;
  unsigned __int8 *v783;
  int v784;
  unsigned __int8 *v785;
  int v786;
  int v787;
  char *v788;
  char *v789;
  string_t v790;
  signed int v791;
  uint64_t v792;
  uint64_t v793;
  unint64_t v794;
  void *v795;
  unint64_t *v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  unint64_t v800;
  void *v801;
  _QWORD *v802;
  string_t v803;
  unint64_t *v804;
  uint64_t v805;
  uint64_t v806;
  unint64_t v807;
  void *v808;
  _QWORD *v809;
  string_t v810;
  string_t v811;
  unint64_t *v812;
  uint64_t v813;
  uint64_t v814;
  unint64_t v815;
  void *v816;
  _QWORD *v817;
  string_t v818;
  int v819;
  int v820;
  int v821;
  unsigned __int8 *v822;
  uint64_t v823;
  uint64_t v824;
  unint64_t v825;
  void *v826;
  unint64_t *v827;
  string_t v828;
  string_t v829;
  char *v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  unint64_t v834;
  void *v835;
  _QWORD *v836;
  string_t v837;
  int v838;
  int v839;
  int v840;
  uint64_t v841;
  uint64_t v842;
  unint64_t v843;
  unint64_t v844;
  size_t v845;
  void *v846;
  size_t *v847;
  string_t v848;
  char *v849;
  int v850;
  char *v851;
  int v852;
  int v853;
  int v854;
  int v855;
  int v856;
  int v857;
  int v858;
  unsigned __int8 *v859;
  uint64_t v860;
  uint64_t v861;
  unint64_t v862;
  void *v863;
  unint64_t *v864;
  string_t v865;
  unsigned __int8 *v866;
  uint64_t v867;
  uint64_t v868;
  unint64_t v869;
  void *v870;
  _QWORD *v871;
  string_t v872;
  int v873;
  int v874;
  unsigned __int8 *v875;
  int v876;
  int v877;
  string_t v878;
  char *v879;
  uint64_t v880;
  uint64_t v881;
  uint64_t v882;
  unint64_t v883;
  void *v884;
  _QWORD *v885;
  uint64_t v886;
  unint64_t v887;
  uint64_t v888;
  int v889;
  char *v890;
  int v891;
  int v892;
  int v893;
  unint64_t v894;
  string_t v895;
  int v896;
  int v897;
  int v898;
  unint64_t v899;
  unint64_t v900;
  size_t v901;
  void *v902;
  size_t *v903;
  string_t v904;
  char *v905;
  int v906;
  uint64_t v907;
  int v908;
  uint64_t v909;
  unint64_t v910;
  uint64_t v911;
  int v912;
  char *v913;
  int v914;
  int v915;
  int v916;
  void *v917;
  _QWORD *v918;
  uint64_t v919;
  int v920;
  int v921;
  uint64_t v922;
  uint64_t v923;
  unint64_t v924;
  unint64_t v925;
  size_t v926;
  void *v927;
  size_t *v928;
  int v929;
  int v930;
  int v931;
  int v932;
  uint64_t v933;
  uint64_t v934;
  unint64_t v935;
  void *v936;
  _QWORD *v937;
  char *v938;
  string_t v939;
  char *v940;
  uint64_t v941;
  uint64_t v942;
  unint64_t v943;
  void *v944;
  unint64_t *v945;
  string_t v946;
  string_t v947;
  int v948;
  int v949;
  int v950;
  int v951;
  uint64_t v952;
  uint64_t v953;
  unint64_t v954;
  void *v955;
  unint64_t *v956;
  char *v957;
  string_t v958;
  char *v959;
  uint64_t v960;
  uint64_t v961;
  unint64_t v962;
  void *v963;
  unint64_t *v964;
  string_t v965;
  char *v966;
  uint64_t v967;
  uint64_t v968;
  unint64_t v969;
  void *v970;
  unint64_t *v971;
  string_t v972;
  char *v973;
  uint64_t v974;
  uint64_t v975;
  unint64_t v976;
  void *v977;
  _QWORD *v978;
  string_t v979;
  int v980;
  char *v981;
  int v982;
  int v983;
  int v984;
  uint64_t v985;
  uint64_t v986;
  unint64_t v987;
  void *v988;
  _QWORD *v989;
  char *v990;
  string_t v991;
  char *v992;
  unint64_t *v993;
  uint64_t v994;
  uint64_t v995;
  unint64_t v996;
  void *v997;
  unint64_t *v998;
  string_t v999;
  string_t v1000;
  uint64_t v1001;
  unint64_t v1002;
  uint64_t v1003;
  int v1004;
  _BYTE *v1005;
  int v1006;
  int v1007;
  int v1008;
  unint64_t v1009;
  void *v1010;
  _QWORD *v1011;
  string_t v1012;
  int v1013;
  char *v1014;
  int v1015;
  int v1016;
  int v1017;
  char *v1018;
  char *v1019;
  uint64_t v1020;
  uint64_t v1021;
  unint64_t v1022;
  void *v1023;
  unint64_t *v1024;
  string_t v1025;
  char *v1026;
  unint64_t *v1027;
  uint64_t v1028;
  uint64_t v1029;
  unint64_t v1030;
  void *v1031;
  _QWORD *v1032;
  string_t v1033;
  int v1034;
  char *v1035;
  int v1036;
  int v1037;
  int v1038;
  uint64_t v1039;
  uint64_t v1040;
  unint64_t v1041;
  void *v1042;
  _QWORD *v1043;
  string_t v1044;
  int v1045;
  int v1046;
  int v1047;
  int v1048;
  int64_t v1049;
  string_t v1050;
  char *v1051;
  char *v1052;
  char *v1053;
  int v1054;
  int v1055;
  int v1056;
  uint64_t v1057;
  uint64_t v1058;
  unint64_t v1059;
  unint64_t v1060;
  size_t v1061;
  void *v1062;
  size_t *v1063;
  uint64_t v1064;
  unint64_t v1065;
  uint64_t v1066;
  int v1067;
  char *v1068;
  int v1069;
  int v1070;
  int v1071;
  unint64_t v1072;
  void *v1073;
  unint64_t *v1074;
  string_t v1075;
  uint64_t v1076;
  unsigned int v1078[2];
  char *v1079;
  char *v1080;
  char *__s1a;

  *(_QWORD *)v1078 = 0;
  v1080 = 0;
  __s1a = __s1;
  v1079 = 0;
  v6 = *__s1;
  if (*__s1)
  {
    if ((v6 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_3:
        v7 = *++__s1;
        v6 = v7;
      }
      while ((v7 - 33) > 0xFFFFFFDF);
    }
LABEL_4:
    if (v6 == 35)
    {
      ++__s1;
      while (1)
      {
        v6 = *__s1;
        if (!*__s1)
          break;
        v8 = *(__s1++ - 1);
        if (v8 == 10)
        {
          --__s1;
          if ((v6 - 33) >= 0xFFFFFFE0)
            goto LABEL_3;
          goto LABEL_4;
        }
      }
    }
  }
  __s1a = __s1;
  if (!*__s1)
    return;
  __s1a = (char *)header(__s1, &v1078[1]);
  if (!__s1a)
    return;
  arb::begin((string_t *)a2, HGString::_distill(char const*,unsigned int)::head, (const HGLimits *)a3, v9);
  v11 = *(_QWORD *)(a2 + 8);
  v10 = *(_QWORD *)(a2 + 16);
  v12 = v11 + 4;
  if (v10)
  {
    if (v12 >= *(_QWORD *)v10)
    {
      v13 = malloc_type_realloc(*(void **)(v10 + 16), (v11 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v14 = *(unint64_t **)(a2 + 16);
      v14[2] = (unint64_t)v13;
      *v14 = (v11 + 259) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)a2 = v13;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v12);
  }
  v15 = *(string_t *)a2;
  *(_QWORD *)(a2 + 8) += 4;
  *(_DWORD *)&v15[v11] = 170140451;
  v16 = operator new[]();
  v1076 = a3;
  if (*(_BYTE *)(a3 + 42))
  {
    if (*(_BYTE *)(a3 + 42) == 1
      || (qmemcpy((void *)(*(_QWORD *)a2 + 62), "OPTION ARB_draw_buffers;      \n", 31), *(_BYTE *)(a3 + 42)))
    {
      v17 = 0;
      do
      {
        while (1)
        {
          v21 = *(_QWORD *)(a2 + 8);
          v20 = *(_QWORD *)(a2 + 16);
          v22 = v21 + 9;
          if (v20)
          {
            if (v22 >= *(_QWORD *)v20)
            {
              v23 = malloc_type_realloc(*(void **)(v20 + 16), (v21 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v24 = *(unint64_t **)(a2 + 16);
              v24[2] = (unint64_t)v23;
              *v24 = (v21 + 264) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v23;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v22);
          }
          v25 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 9;
          v26 = (char *)&v25[v21];
          *(_QWORD *)v26 = *(_QWORD *)"OUTPUT $o";
          v26[8] = 111;
          v28 = *(_QWORD *)(a2 + 8);
          v27 = *(_QWORD *)(a2 + 16);
          v29 = v28 + 20;
          if (v27)
          {
            if (v29 >= *(_QWORD *)v27)
            {
              v30 = malloc_type_realloc(*(void **)(v27 + 16), (v28 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v31 = *(unint64_t **)(a2 + 16);
              v31[2] = (unint64_t)v30;
              *v31 = (v28 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v30;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v29);
          }
          v32 = itoa((char *)(*(_QWORD *)a2 + v28), v17);
          v33 = *(_QWORD *)(a2 + 16);
          v34 = *(_QWORD *)(a2 + 8) + v32;
          *(_QWORD *)(a2 + 8) = v34;
          if (!v17)
            break;
          v35 = v34 + 14;
          if (v33)
          {
            if (v35 >= *(_QWORD *)v33)
            {
              v36 = malloc_type_realloc(*(void **)(v33 + 16), (v34 + 269) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v37 = *(unint64_t **)(a2 + 16);
              v37[2] = (unint64_t)v36;
              *v37 = (v34 + 269) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v36;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v35);
          }
          v41 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 14;
          qmemcpy((void *)&v41[v34], "=result.color[", 14);
          v43 = *(_QWORD *)(a2 + 8);
          v42 = *(_QWORD *)(a2 + 16);
          v44 = v43 + 20;
          if (v42)
          {
            if (v44 >= *(_QWORD *)v42)
            {
              v45 = malloc_type_realloc(*(void **)(v42 + 16), (v43 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v46 = *(unint64_t **)(a2 + 16);
              v46[2] = (unint64_t)v45;
              *v46 = (v43 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v45;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v44);
          }
          v47 = itoa((char *)(*(_QWORD *)a2 + v43), v17);
          v48 = *(_QWORD *)(a2 + 16);
          v49 = *(_QWORD *)(a2 + 8) + v47;
          *(_QWORD *)(a2 + 8) = v49;
          v50 = v49 + 3;
          if (v48)
          {
            if (v50 >= *(_QWORD *)v48)
            {
              v51 = malloc_type_realloc(*(void **)(v48 + 16), (v49 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v52 = *(unint64_t **)(a2 + 16);
              v52[2] = (unint64_t)v51;
              *v52 = (v49 + 258) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v51;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v50);
          }
          v18 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 3;
          v19 = (char *)&v18[v49];
          v19[2] = 10;
          *(_WORD *)v19 = 15197;
          ++v17;
          a3 = v1076;
          if (v17 >= *(unsigned __int8 *)(v1076 + 42))
            goto LABEL_47;
        }
        v38 = v34 + 15;
        if (v33)
        {
          if (v38 >= *(_QWORD *)v33)
          {
            v39 = malloc_type_realloc(*(void **)(v33 + 16), (v34 + 270) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v40 = *(unint64_t **)(a2 + 16);
            v40[2] = (unint64_t)v39;
            *v40 = (v34 + 270) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v39;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v38);
        }
        v53 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 15;
        qmemcpy((void *)&v53[v34], "=result.color;\n", 15);
        v17 = 1;
        a3 = v1076;
      }
      while (*(unsigned __int8 *)(v1076 + 42) > 1uLL);
    }
  }
LABEL_47:
  v54 = a1;
  if (!*(_WORD *)(a3 + 36))
    goto LABEL_199;
  v55 = a1[1];
  if ((*(_DWORD *)v1076 & 0xF0000) != 0x60000)
  {
    if (!v55)
      goto LABEL_81;
    v68 = 0;
    v69 = 0;
    do
    {
      v70 = *a1;
      if (*(_UNKNOWN **)(*a1 + 88 * v68 + 40) == &vertexKind)
      {
        v71 = (unint64_t *)(v16 + 8 * v69);
        if (v69)
        {
          v72 = v69;
          v73 = v16;
          do
          {
            while (1)
            {
              v75 = v72 >> 1;
              v76 = (_QWORD *)(v73 + 8 * (v72 >> 1));
              v77 = *(_DWORD *)(v70 + 88 * v68 + 56) - *(_DWORD *)(v70 + 88 * *v76 + 56);
              if (v77 < 1)
                break;
              v74 = v75 + 1;
              v73 += 8 * v74;
              v72 -= v74;
              if (!v72)
                goto LABEL_76;
            }
            if ((v77 & 0x80000000) == 0)
            {
              *(_QWORD *)(v70 + 88 * *v76 + 80) |= *(_QWORD *)(v70 + 88 * v68 + 80);
              goto LABEL_68;
            }
            v71 = (unint64_t *)(v73 + 8 * (v72 >> 1));
            v72 >>= 1;
          }
          while (v75);
LABEL_76:
          if (!v71)
            goto LABEL_68;
        }
        v78 = ((uint64_t)v71 - v16) >> 3;
        v604 = v69 >= v78;
        v79 = v69 - v78;
        if (v79 != 0 && v604)
          memmove(v71 + 1, v71, 8 * v79);
        *v71 = v68;
        ++v69;
        v55 = a1[1];
      }
LABEL_68:
      ++v68;
    }
    while (v68 < v55);
    v1079 = (char *)v69;
    if (!v69)
      goto LABEL_199;
    v153 = 0;
    v154 = (char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::mods;
    while (1)
    {
      while (1)
      {
        v156 = 8 * (*(_QWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v153) + 80) & 7);
        v157 = *(const void **)&v154[v156];
        v158 = *(_QWORD *)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::modl
                         + v156);
        v160 = *(_QWORD *)(a2 + 8);
        v159 = *(_QWORD *)(a2 + 16);
        v161 = v160 + v158;
        if (v159)
        {
          if (v161 >= *(_QWORD *)v159)
          {
            v162 = (v161 + 255) & 0xFFFFFFFFFFFFFF00;
            v163 = malloc_type_realloc(*(void **)(v159 + 16), v162, 0xCCCD1039uLL);
            v164 = *(size_t **)(a2 + 16);
            v164[2] = (size_t)v163;
            *v164 = v162;
            v54 = a1;
            *(_QWORD *)a2 = v163;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v161);
        }
        v165 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += v158;
        memcpy((void *)&v165[v160], v157, v158);
        v167 = *(_QWORD *)(a2 + 8);
        v166 = *(_QWORD *)(a2 + 16);
        v168 = v167 + 9;
        if (v166)
        {
          if (v168 >= *(_QWORD *)v166)
          {
            v169 = malloc_type_realloc(*(void **)(v166 + 16), (v167 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v170 = *(unint64_t **)(a2 + 16);
            v170[2] = (unint64_t)v169;
            *v170 = (v167 + 264) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v169;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v168);
        }
        v171 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 9;
        v172 = (char *)&v171[v167];
        *(_QWORD *)v172 = *(_QWORD *)"ATTRIB $v";
        v172[8] = 118;
        v173 = *(_DWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v153) + 56);
        v175 = *(_QWORD *)(a2 + 8);
        v174 = *(_QWORD *)(a2 + 16);
        v176 = v175 + 20;
        if (v174)
        {
          if (v176 >= *(_QWORD *)v174)
          {
            v177 = malloc_type_realloc(*(void **)(v174 + 16), (v175 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v178 = *(unint64_t **)(a2 + 16);
            v178[2] = (unint64_t)v177;
            *v178 = (v175 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v177;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v176);
        }
        v179 = itoa((char *)(*(_QWORD *)a2 + v175), v173);
        v180 = *(_QWORD *)(a2 + 16);
        v181 = *(_QWORD *)(a2 + 8) + v179;
        *(_QWORD *)(a2 + 8) = v181;
        if (*(_QWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v153) + 64))
          break;
        v185 = v181 + 17;
        if (v180)
        {
          if (v185 >= *(_QWORD *)v180)
          {
            v186 = malloc_type_realloc(*(void **)(v180 + 16), (v181 + 272) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v187 = *(unint64_t **)(a2 + 16);
            v187[2] = (unint64_t)v186;
            *v187 = (v181 + 272) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v186;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v185);
        }
        v210 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 17;
        v211 = (char *)&v210[v181];
        *(_OWORD *)v211 = *(_OWORD *)"=vertex.texcoord[";
        v211[16] = 91;
        v212 = *(_DWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v153) + 56);
        v214 = *(_QWORD *)(a2 + 8);
        v213 = *(_QWORD *)(a2 + 16);
        v215 = v214 + 20;
        if (v213)
        {
          if (v215 >= *(_QWORD *)v213)
          {
            v216 = malloc_type_realloc(*(void **)(v213 + 16), (v214 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v217 = *(unint64_t **)(a2 + 16);
            v217[2] = (unint64_t)v216;
            *v217 = (v214 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v216;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v215);
        }
        v218 = itoa((char *)(*(_QWORD *)a2 + v214), v212);
        v219 = *(_QWORD *)(a2 + 16);
        v220 = *(_QWORD *)(a2 + 8) + v218;
        *(_QWORD *)(a2 + 8) = v220;
        v221 = v220 + 3;
        if (v219)
        {
          if (v221 >= *(_QWORD *)v219)
          {
            v222 = malloc_type_realloc(*(void **)(v219 + 16), (v220 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v223 = *(unint64_t **)(a2 + 16);
            v223[2] = (unint64_t)v222;
            *v223 = (v220 + 258) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v222;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v221);
        }
        v224 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 3;
        v225 = (char *)&v224[v220];
        v225[2] = 10;
        *(_WORD *)v225 = 15197;
        if (++v153 == v69)
          goto LABEL_199;
      }
      v182 = v181 + 1;
      if (v180)
      {
        if (v182 >= *(_QWORD *)v180)
        {
          v183 = malloc_type_realloc(*(void **)(v180 + 16), (v181 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
          v184 = *(_QWORD **)(a2 + 16);
          v184[2] = v183;
          *v184 = (v181 & 0xFFFFFFFFFFFFFF00) + 256;
          *(_QWORD *)a2 = v183;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v182);
      }
      v188 = *(string_t *)a2;
      ++*(_QWORD *)(a2 + 8);
      v188[v181] = 61;
      v189 = *v54 + 88 * *(_QWORD *)(v16 + 8 * v153);
      v190 = *(_QWORD *)(v189 + 72);
      v192 = *(_QWORD *)(a2 + 8);
      v191 = *(_QWORD *)(a2 + 16);
      if (v190)
        break;
LABEL_186:
      v207 = v192 + 2;
      if (v191)
      {
        if (v207 >= *(_QWORD *)v191)
        {
          v208 = malloc_type_realloc(*(void **)(v191 + 16), (v192 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v209 = *(unint64_t **)(a2 + 16);
          v209[2] = (unint64_t)v208;
          *v209 = (v192 + 257) & 0xFFFFFFFFFFFFFF00;
          *(_QWORD *)a2 = v208;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v207);
      }
      v155 = *(string_t *)a2;
      *(_QWORD *)(a2 + 8) += 2;
      *(_WORD *)&v155[v192] = 2619;
      if (++v153 == v69)
        goto LABEL_199;
    }
    v193 = v154;
    v194 = *(_QWORD *)(v189 + 64);
    v195 = v192 + v190;
    if (v191)
    {
      if (v195 >= *(_QWORD *)v191)
      {
        v196 = (v195 + 255) & 0xFFFFFFFFFFFFFF00;
        v197 = malloc_type_realloc(*(void **)(v191 + 16), v196, 0xCCCD1039uLL);
        v198 = *(size_t **)(a2 + 16);
        v198[2] = (size_t)v197;
        *v198 = v196;
        *(_QWORD *)a2 = v197;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v195);
    }
    v199 = 0;
    v200 = 0;
    v201 = *(_QWORD *)a2 + v192;
    while (1)
    {
      v202 = v200[v194];
      if ((v202 - 33) > 0xFFFFFFDF)
      {
        ++v200;
        v203 = &v200[v194];
        if (v200[v194] == 35)
        {
LABEL_177:
          v204 = 35;
LABEL_179:
          if (v204 == 35)
          {
            ++v203;
            while (1)
            {
              v204 = *v203;
              if (!*v203)
                break;
              v206 = *(v203++ - 1);
              if (v206 == 10)
              {
                --v203;
                if ((v204 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v205 = *++v203;
                    v204 = v205;
                  }
                  while ((v205 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_179;
              }
            }
          }
          v200 = &v203[-v194];
        }
      }
      else
      {
        *(_BYTE *)(v201 + v199++) = v202;
        ++v200;
        v203 = &v200[v194];
        if (v200[v194] == 35)
          goto LABEL_177;
      }
      if ((unint64_t)v200 >= v190)
      {
        v191 = *(_QWORD *)(a2 + 16);
        v192 = *(_QWORD *)(a2 + 8) + v199;
        *(_QWORD *)(a2 + 8) = v192;
        v154 = v193;
        goto LABEL_186;
      }
    }
  }
  if (!v55)
  {
LABEL_81:
    v1079 = 0;
    goto LABEL_199;
  }
  v56 = 0;
  v57 = 0;
  do
  {
    v58 = *a1;
    if (*(_UNKNOWN **)(*a1 + 88 * v56 + 40) == &fragmentKind)
    {
      v59 = (unint64_t *)(v16 + 8 * v57);
      if (v57)
      {
        v60 = v57;
        v61 = v16;
        do
        {
          while (1)
          {
            v63 = v60 >> 1;
            v64 = (_QWORD *)(v61 + 8 * (v60 >> 1));
            v65 = *(_DWORD *)(v58 + 88 * v56 + 56) - *(_DWORD *)(v58 + 88 * *v64 + 56);
            if (v65 < 1)
              break;
            v62 = v63 + 1;
            v61 += 8 * v62;
            v60 -= v62;
            if (!v60)
              goto LABEL_60;
          }
          if ((v65 & 0x80000000) == 0)
          {
            *(_QWORD *)(v58 + 88 * *v64 + 80) |= *(_QWORD *)(v58 + 88 * v56 + 80);
            goto LABEL_52;
          }
          v59 = (unint64_t *)(v61 + 8 * (v60 >> 1));
          v60 >>= 1;
        }
        while (v63);
LABEL_60:
        if (!v59)
          goto LABEL_52;
      }
      v66 = ((uint64_t)v59 - v16) >> 3;
      v604 = v57 >= v66;
      v67 = v57 - v66;
      if (v67 != 0 && v604)
        memmove(v59 + 1, v59, 8 * v67);
      *v59 = v56;
      ++v57;
      v55 = a1[1];
    }
LABEL_52:
    ++v56;
  }
  while (v56 < v55);
  v1079 = (char *)v57;
  if (v57)
  {
    v80 = 0;
    v81 = (char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::mods;
    while (1)
    {
      while (1)
      {
        v83 = 8 * (*(_QWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v80) + 80) & 7);
        v84 = *(const void **)&v81[v83];
        v85 = *(_QWORD *)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::modl
                        + v83);
        v87 = *(_QWORD *)(a2 + 8);
        v86 = *(_QWORD *)(a2 + 16);
        v88 = v87 + v85;
        if (v86)
        {
          if (v88 >= *(_QWORD *)v86)
          {
            v89 = (v88 + 255) & 0xFFFFFFFFFFFFFF00;
            v90 = malloc_type_realloc(*(void **)(v86 + 16), v89, 0xCCCD1039uLL);
            v91 = *(size_t **)(a2 + 16);
            v91[2] = (size_t)v90;
            *v91 = v89;
            v54 = a1;
            *(_QWORD *)a2 = v90;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v88);
        }
        v92 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += v85;
        memcpy((void *)&v92[v87], v84, v85);
        v94 = *(_QWORD *)(a2 + 8);
        v93 = *(_QWORD *)(a2 + 16);
        v95 = v94 + 9;
        if (v93)
        {
          if (v95 >= *(_QWORD *)v93)
          {
            v96 = malloc_type_realloc(*(void **)(v93 + 16), (v94 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v97 = *(unint64_t **)(a2 + 16);
            v97[2] = (unint64_t)v96;
            *v97 = (v94 + 264) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v96;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v95);
        }
        v98 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 9;
        v99 = (char *)&v98[v94];
        *(_QWORD *)v99 = *(_QWORD *)"ATTRIB $f";
        v99[8] = 102;
        v100 = *(_DWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v80) + 56);
        v102 = *(_QWORD *)(a2 + 8);
        v101 = *(_QWORD *)(a2 + 16);
        v103 = v102 + 20;
        if (v101)
        {
          if (v103 >= *(_QWORD *)v101)
          {
            v104 = malloc_type_realloc(*(void **)(v101 + 16), (v102 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v105 = *(unint64_t **)(a2 + 16);
            v105[2] = (unint64_t)v104;
            *v105 = (v102 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v104;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v103);
        }
        v106 = itoa((char *)(*(_QWORD *)a2 + v102), v100);
        v107 = *(_QWORD *)(a2 + 16);
        v108 = *(_QWORD *)(a2 + 8) + v106;
        *(_QWORD *)(a2 + 8) = v108;
        if (*(_QWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v80) + 64))
          break;
        v112 = v108 + 19;
        if (v107)
        {
          if (v112 >= *(_QWORD *)v107)
          {
            v113 = malloc_type_realloc(*(void **)(v107 + 16), (v108 + 274) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v114 = *(unint64_t **)(a2 + 16);
            v114[2] = (unint64_t)v113;
            *v114 = (v108 + 274) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v113;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v112);
        }
        v137 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 19;
        v138 = (char *)&v137[v108];
        *(_OWORD *)v138 = *(_OWORD *)"=fragment.texcoord[";
        *(_DWORD *)(v138 + 15) = 1533309551;
        v139 = *(_DWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v80) + 56);
        v141 = *(_QWORD *)(a2 + 8);
        v140 = *(_QWORD *)(a2 + 16);
        v142 = v141 + 20;
        if (v140)
        {
          if (v142 >= *(_QWORD *)v140)
          {
            v143 = malloc_type_realloc(*(void **)(v140 + 16), (v141 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v144 = *(unint64_t **)(a2 + 16);
            v144[2] = (unint64_t)v143;
            *v144 = (v141 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v143;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v142);
        }
        v145 = itoa((char *)(*(_QWORD *)a2 + v141), v139);
        v146 = *(_QWORD *)(a2 + 16);
        v147 = *(_QWORD *)(a2 + 8) + v145;
        *(_QWORD *)(a2 + 8) = v147;
        v148 = v147 + 3;
        if (v146)
        {
          if (v148 >= *(_QWORD *)v146)
          {
            v149 = malloc_type_realloc(*(void **)(v146 + 16), (v147 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v150 = *(unint64_t **)(a2 + 16);
            v150[2] = (unint64_t)v149;
            *v150 = (v147 + 258) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v149;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v148);
        }
        v151 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 3;
        v152 = (char *)&v151[v147];
        v152[2] = 10;
        *(_WORD *)v152 = 15197;
        if (++v80 == v57)
          goto LABEL_199;
      }
      v109 = v108 + 1;
      if (v107)
      {
        if (v109 >= *(_QWORD *)v107)
        {
          v110 = malloc_type_realloc(*(void **)(v107 + 16), (v108 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
          v111 = *(_QWORD **)(a2 + 16);
          v111[2] = v110;
          *v111 = (v108 & 0xFFFFFFFFFFFFFF00) + 256;
          *(_QWORD *)a2 = v110;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v109);
      }
      v115 = *(string_t *)a2;
      ++*(_QWORD *)(a2 + 8);
      v115[v108] = 61;
      v116 = *v54 + 88 * *(_QWORD *)(v16 + 8 * v80);
      v117 = *(_QWORD *)(v116 + 72);
      v119 = *(_QWORD *)(a2 + 8);
      v118 = *(_QWORD *)(a2 + 16);
      if (v117)
        break;
LABEL_127:
      v134 = v119 + 2;
      if (v118)
      {
        if (v134 >= *(_QWORD *)v118)
        {
          v135 = malloc_type_realloc(*(void **)(v118 + 16), (v119 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v136 = *(unint64_t **)(a2 + 16);
          v136[2] = (unint64_t)v135;
          *v136 = (v119 + 257) & 0xFFFFFFFFFFFFFF00;
          *(_QWORD *)a2 = v135;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v134);
      }
      v82 = *(string_t *)a2;
      *(_QWORD *)(a2 + 8) += 2;
      *(_WORD *)&v82[v119] = 2619;
      if (++v80 == v57)
        goto LABEL_199;
    }
    v120 = v81;
    v121 = *(_QWORD *)(v116 + 64);
    v122 = v119 + v117;
    if (v118)
    {
      if (v122 >= *(_QWORD *)v118)
      {
        v123 = (v122 + 255) & 0xFFFFFFFFFFFFFF00;
        v124 = malloc_type_realloc(*(void **)(v118 + 16), v123, 0xCCCD1039uLL);
        v125 = *(size_t **)(a2 + 16);
        v125[2] = (size_t)v124;
        *v125 = v123;
        *(_QWORD *)a2 = v124;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v122);
    }
    v126 = 0;
    v127 = 0;
    v128 = *(_QWORD *)a2 + v119;
    while (1)
    {
      v129 = v127[v121];
      if ((v129 - 33) > 0xFFFFFFDF)
      {
        ++v127;
        v130 = &v127[v121];
        if (v127[v121] == 35)
        {
LABEL_118:
          v131 = 35;
LABEL_120:
          if (v131 == 35)
          {
            ++v130;
            while (1)
            {
              v131 = *v130;
              if (!*v130)
                break;
              v133 = *(v130++ - 1);
              if (v133 == 10)
              {
                --v130;
                if ((v131 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v132 = *++v130;
                    v131 = v132;
                  }
                  while ((v132 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_120;
              }
            }
          }
          v127 = &v130[-v121];
        }
      }
      else
      {
        *(_BYTE *)(v128 + v126++) = v129;
        ++v127;
        v130 = &v127[v121];
        if (v127[v121] == 35)
          goto LABEL_118;
      }
      if ((unint64_t)v127 >= v117)
      {
        v118 = *(_QWORD *)(a2 + 16);
        v119 = *(_QWORD *)(a2 + 8) + v126;
        *(_QWORD *)(a2 + 8) = v119;
        v81 = v120;
        goto LABEL_127;
      }
    }
  }
LABEL_199:
  if (*(_WORD *)(v1076 + 22))
  {
    v226 = v54[1];
    if (v226)
    {
      v227 = 0;
      v228 = 0;
      do
      {
        v229 = *v54;
        if (*(_UNKNOWN **)(*v54 + 88 * v227 + 40) == &paramKind)
        {
          v230 = (unint64_t *)(v16 + 8 * v228);
          if (v228)
          {
            v231 = v228;
            v232 = v16;
            do
            {
              while (1)
              {
                v234 = v231 >> 1;
                v235 = (_QWORD *)(v232 + 8 * (v231 >> 1));
                v236 = *(_DWORD *)(v229 + 88 * v227 + 56) - *(_DWORD *)(v229 + 88 * *v235 + 56);
                if (v236 < 1)
                  break;
                v233 = v234 + 1;
                v232 += 8 * v233;
                v231 -= v233;
                if (!v231)
                  goto LABEL_211;
              }
              if ((v236 & 0x80000000) == 0)
              {
                *(_QWORD *)(v229 + 88 * *v235 + 80) |= *(_QWORD *)(v229 + 88 * v227 + 80);
                goto LABEL_203;
              }
              v230 = (unint64_t *)(v232 + 8 * (v231 >> 1));
              v231 >>= 1;
            }
            while (v234);
LABEL_211:
            if (!v230)
              goto LABEL_203;
          }
          v237 = ((uint64_t)v230 - v16) >> 3;
          v604 = v228 >= v237;
          v238 = v228 - v237;
          if (v238 != 0 && v604)
            memmove(v230 + 1, v230, 8 * v238);
          *v230 = v227;
          ++v228;
          v226 = v54[1];
        }
LABEL_203:
        ++v227;
      }
      while (v227 < v226);
      v1079 = (char *)v228;
      if (v228)
      {
        v239 = (_QWORD *)v16;
        do
        {
          v242 = 8 * (*(_QWORD *)(*v54 + 88 * *v239 + 80) & 7);
          v243 = *(const void **)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::mods
                                + v242);
          v244 = *(_QWORD *)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::modl
                           + v242);
          v246 = *(_QWORD *)(a2 + 8);
          v245 = *(_QWORD *)(a2 + 16);
          v247 = v246 + v244;
          if (v245)
          {
            if (v247 >= *(_QWORD *)v245)
            {
              v248 = (v247 + 255) & 0xFFFFFFFFFFFFFF00;
              v249 = malloc_type_realloc(*(void **)(v245 + 16), v248, 0xCCCD1039uLL);
              v250 = *(size_t **)(a2 + 16);
              v250[2] = (size_t)v249;
              *v250 = v248;
              v54 = a1;
              *(_QWORD *)a2 = v249;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v247);
          }
          v251 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += v244;
          memcpy((void *)&v251[v246], v243, v244);
          v253 = *(_QWORD *)(a2 + 8);
          v252 = *(_QWORD *)(a2 + 16);
          v254 = v253 + 8;
          if (v252)
          {
            if (v254 >= *(_QWORD *)v252)
            {
              v255 = malloc_type_realloc(*(void **)(v252 + 16), (v253 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v256 = *(unint64_t **)(a2 + 16);
              v256[2] = (unint64_t)v255;
              *v256 = (v253 + 263) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v255;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v254);
          }
          v257 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 8;
          *(_QWORD *)&v257[v253] = 0x7024204D41524150;
          v258 = *(_DWORD *)(*v54 + 88 * *v239 + 56);
          v260 = *(_QWORD *)(a2 + 8);
          v259 = *(_QWORD *)(a2 + 16);
          v261 = v260 + 20;
          if (v259)
          {
            if (v261 >= *(_QWORD *)v259)
            {
              v262 = malloc_type_realloc(*(void **)(v259 + 16), (v260 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v263 = *(unint64_t **)(a2 + 16);
              v263[2] = (unint64_t)v262;
              *v263 = (v260 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v262;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v261);
          }
          v264 = itoa((char *)(*(_QWORD *)a2 + v260), v258);
          v265 = *(_QWORD *)(a2 + 16);
          v266 = *(_QWORD *)(a2 + 8) + v264;
          *(_QWORD *)(a2 + 8) = v266;
          v267 = v266 + 15;
          if (v265)
          {
            v268 = a1;
            if (v267 >= *(_QWORD *)v265)
            {
              v269 = malloc_type_realloc(*(void **)(v265 + 16), (v266 + 270) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v270 = *(unint64_t **)(a2 + 16);
              v270[2] = (unint64_t)v269;
              *v270 = (v266 + 270) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v269;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v267);
            v268 = a1;
          }
          v271 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 15;
          qmemcpy((void *)&v271[v266], "=program.local[", 15);
          v272 = *(_DWORD *)(*v268 + 88 * *v239 + 56);
          v274 = *(_QWORD *)(a2 + 8);
          v273 = *(_QWORD *)(a2 + 16);
          v275 = v274 + 20;
          if (v273)
          {
            if (v275 >= *(_QWORD *)v273)
            {
              v276 = malloc_type_realloc(*(void **)(v273 + 16), (v274 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v277 = *(unint64_t **)(a2 + 16);
              v277[2] = (unint64_t)v276;
              *v277 = (v274 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v276;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v275);
          }
          v278 = itoa((char *)(*(_QWORD *)a2 + v274), v272);
          v279 = *(_QWORD *)(a2 + 16);
          v280 = *(_QWORD *)(a2 + 8) + v278;
          *(_QWORD *)(a2 + 8) = v280;
          v281 = v280 + 3;
          if (v279)
          {
            v54 = a1;
            if (v281 >= *(_QWORD *)v279)
            {
              v282 = malloc_type_realloc(*(void **)(v279 + 16), (v280 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v283 = *(unint64_t **)(a2 + 16);
              v283[2] = (unint64_t)v282;
              *v283 = (v280 + 258) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v282;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v281);
            v54 = a1;
          }
          v240 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 3;
          v241 = (char *)&v240[v280];
          v241[2] = 10;
          *(_WORD *)v241 = 15197;
          ++v239;
          --v228;
        }
        while (v228);
      }
    }
    else
    {
      v1079 = 0;
    }
  }
  if (*(_WORD *)(v1076 + 20))
  {
    v284 = v54[1];
    if (v284)
    {
      v285 = 0;
      v286 = 0;
      do
      {
        v287 = *v54;
        if (*(_UNKNOWN **)(*v54 + 88 * v285 + 40) == &constantKind)
        {
          v288 = (unint64_t *)(v16 + 8 * v286);
          if (v286)
          {
            v289 = v286;
            v290 = v16;
            do
            {
              while (1)
              {
                v292 = v289 >> 1;
                v293 = (_QWORD *)(v290 + 8 * (v289 >> 1));
                v294 = *(_DWORD *)(v287 + 88 * v285 + 56) - *(_DWORD *)(v287 + 88 * *v293 + 56);
                if (v294 < 1)
                  break;
                v291 = v292 + 1;
                v290 += 8 * v291;
                v289 -= v291;
                if (!v289)
                  goto LABEL_256;
              }
              if ((v294 & 0x80000000) == 0)
              {
                *(_QWORD *)(v287 + 88 * *v293 + 80) |= *(_QWORD *)(v287 + 88 * v285 + 80);
                goto LABEL_248;
              }
              v288 = (unint64_t *)(v290 + 8 * (v289 >> 1));
              v289 >>= 1;
            }
            while (v292);
LABEL_256:
            if (!v288)
              goto LABEL_248;
          }
          v295 = ((uint64_t)v288 - v16) >> 3;
          v604 = v286 >= v295;
          v296 = v286 - v295;
          if (v296 != 0 && v604)
            memmove(v288 + 1, v288, 8 * v296);
          *v288 = v285;
          ++v286;
          v284 = v54[1];
        }
LABEL_248:
        ++v285;
      }
      while (v285 < v284);
      v1079 = (char *)v286;
      if (v286)
      {
        v297 = 0;
        while (1)
        {
          v299 = 8 * (*(_QWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v297) + 80) & 7);
          v300 = *(const void **)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::mods
                                + v299);
          v301 = *(_QWORD *)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::modl
                           + v299);
          v303 = *(_QWORD *)(a2 + 8);
          v302 = *(_QWORD *)(a2 + 16);
          v304 = v303 + v301;
          if (v302)
          {
            if (v304 >= *(_QWORD *)v302)
            {
              v305 = (v304 + 255) & 0xFFFFFFFFFFFFFF00;
              v306 = malloc_type_realloc(*(void **)(v302 + 16), v305, 0xCCCD1039uLL);
              v307 = *(size_t **)(a2 + 16);
              v307[2] = (size_t)v306;
              *v307 = v305;
              v54 = a1;
              *(_QWORD *)a2 = v306;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v304);
          }
          v308 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += v301;
          memcpy((void *)&v308[v303], v300, v301);
          v310 = *(_QWORD *)(a2 + 8);
          v309 = *(_QWORD *)(a2 + 16);
          v311 = v310 + 8;
          if (v309)
          {
            if (v311 >= *(_QWORD *)v309)
            {
              v312 = malloc_type_realloc(*(void **)(v309 + 16), (v310 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v313 = *(unint64_t **)(a2 + 16);
              v313[2] = (unint64_t)v312;
              *v313 = (v310 + 263) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v312;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v311);
          }
          v314 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 8;
          *(_QWORD *)&v314[v310] = 0x6324204D41524150;
          v315 = *(_DWORD *)(*v54 + 88 * *(_QWORD *)(v16 + 8 * v297) + 56);
          v317 = *(_QWORD *)(a2 + 8);
          v316 = *(_QWORD *)(a2 + 16);
          v318 = v317 + 20;
          if (v316)
          {
            if (v318 >= *(_QWORD *)v316)
            {
              v319 = malloc_type_realloc(*(void **)(v316 + 16), (v317 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v320 = *(unint64_t **)(a2 + 16);
              v320[2] = (unint64_t)v319;
              *v320 = (v317 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v319;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v318);
          }
          v321 = itoa((char *)(*(_QWORD *)a2 + v317), v315);
          v322 = *(_QWORD *)(a2 + 16);
          v323 = *(_QWORD *)(a2 + 8) + v321;
          *(_QWORD *)(a2 + 8) = v323;
          v324 = v323 + 1;
          if (v322)
          {
            if (v324 >= *(_QWORD *)v322)
            {
              v325 = malloc_type_realloc(*(void **)(v322 + 16), (v323 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v326 = *(_QWORD **)(a2 + 16);
              v326[2] = v325;
              *v326 = (v323 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)a2 = v325;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v324);
          }
          v327 = *(string_t *)a2;
          ++*(_QWORD *)(a2 + 8);
          v327[v323] = 61;
          v328 = *v54 + 88 * *(_QWORD *)(v16 + 8 * v297);
          v329 = *(_QWORD *)(v328 + 72);
          v331 = *(_QWORD *)(a2 + 8);
          v330 = *(_QWORD *)(a2 + 16);
          if (v329)
            break;
LABEL_302:
          v345 = v331 + 2;
          if (v330)
          {
            if (v345 >= *(_QWORD *)v330)
            {
              v346 = malloc_type_realloc(*(void **)(v330 + 16), (v331 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v347 = *(unint64_t **)(a2 + 16);
              v347[2] = (unint64_t)v346;
              *v347 = (v331 + 257) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v346;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v345);
          }
          v298 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 2;
          *(_WORD *)&v298[v331] = 2619;
          if (++v297 == v286)
            goto LABEL_306;
        }
        v332 = *(_QWORD *)(v328 + 64);
        v333 = v331 + v329;
        if (v330)
        {
          if (v333 >= *(_QWORD *)v330)
          {
            v334 = (v333 + 255) & 0xFFFFFFFFFFFFFF00;
            v335 = malloc_type_realloc(*(void **)(v330 + 16), v334, 0xCCCD1039uLL);
            v336 = *(size_t **)(a2 + 16);
            v336[2] = (size_t)v335;
            *v336 = v334;
            *(_QWORD *)a2 = v335;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v333);
        }
        v337 = 0;
        v338 = 0;
        v339 = *(_QWORD *)a2 + v331;
        while (1)
        {
          v340 = v338[v332];
          if ((v340 - 33) > 0xFFFFFFDF)
          {
            ++v338;
            v341 = &v338[v332];
            if (v338[v332] == 35)
            {
LABEL_293:
              v342 = 35;
LABEL_295:
              if (v342 == 35)
              {
                ++v341;
                while (1)
                {
                  v342 = *v341;
                  if (!*v341)
                    break;
                  v344 = *(v341++ - 1);
                  if (v344 == 10)
                  {
                    --v341;
                    if ((v342 - 33) >= 0xFFFFFFE0)
                    {
                      do
                      {
                        v343 = *++v341;
                        v342 = v343;
                      }
                      while ((v343 - 33) > 0xFFFFFFDF);
                    }
                    goto LABEL_295;
                  }
                }
              }
              v338 = &v341[-v332];
            }
          }
          else
          {
            *(_BYTE *)(v339 + v337++) = v340;
            ++v338;
            v341 = &v338[v332];
            if (v338[v332] == 35)
              goto LABEL_293;
          }
          if ((unint64_t)v338 >= v329)
          {
            v330 = *(_QWORD *)(a2 + 16);
            v331 = *(_QWORD *)(a2 + 8) + v337;
            *(_QWORD *)(a2 + 8) = v331;
            goto LABEL_302;
          }
        }
      }
    }
    else
    {
      v1079 = 0;
    }
  }
LABEL_306:
  if (*(_WORD *)(v1076 + 34))
  {
    v348 = v54[1];
    if (v348)
    {
      v349 = 0;
      v350 = 0;
      do
      {
        v351 = *v54;
        if (*(_UNKNOWN **)(*v54 + 88 * v349 + 40) == &arrayKind)
        {
          v352 = (unint64_t *)(v16 + 8 * v350);
          if (v350)
          {
            v353 = v350;
            v354 = v16;
            do
            {
              while (1)
              {
                v356 = v353 >> 1;
                v357 = (_QWORD *)(v354 + 8 * (v353 >> 1));
                v358 = *(_DWORD *)(v351 + 88 * v349 + 56) - *(_DWORD *)(v351 + 88 * *v357 + 56);
                if (v358 < 1)
                  break;
                v355 = v356 + 1;
                v354 += 8 * v355;
                v353 -= v355;
                if (!v353)
                  goto LABEL_318;
              }
              if ((v358 & 0x80000000) == 0)
              {
                *(_QWORD *)(v351 + 88 * *v357 + 80) |= *(_QWORD *)(v351 + 88 * v349 + 80);
                goto LABEL_310;
              }
              v352 = (unint64_t *)(v354 + 8 * (v353 >> 1));
              v353 >>= 1;
            }
            while (v356);
LABEL_318:
            if (!v352)
              goto LABEL_310;
          }
          v359 = ((uint64_t)v352 - v16) >> 3;
          v604 = v350 >= v359;
          v360 = v350 - v359;
          if (v360 != 0 && v604)
            memmove(v352 + 1, v352, 8 * v360);
          *v352 = v349;
          ++v350;
          v348 = v54[1];
        }
LABEL_310:
        ++v349;
      }
      while (v349 < v348);
      v1079 = (char *)v350;
      if (v350)
      {
        v361 = (_QWORD *)v16;
        do
        {
          v364 = 8 * (*(_QWORD *)(*v54 + 88 * *v361 + 80) & 7);
          v365 = *(const void **)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::mods
                                + v364);
          v366 = *(_QWORD *)((char *)&arb::obj_write(arb::object_t *,string_t &,HGShaderBinding const*,HGLimits const*,unsigned int,HGLimits*,unsigned int,char const*)::modl
                           + v364);
          v368 = *(_QWORD *)(a2 + 8);
          v367 = *(_QWORD *)(a2 + 16);
          v369 = v368 + v366;
          if (v367)
          {
            if (v369 >= *(_QWORD *)v367)
            {
              v370 = (v369 + 255) & 0xFFFFFFFFFFFFFF00;
              v371 = malloc_type_realloc(*(void **)(v367 + 16), v370, 0xCCCD1039uLL);
              v372 = *(size_t **)(a2 + 16);
              v372[2] = (size_t)v371;
              *v372 = v370;
              v54 = a1;
              *(_QWORD *)a2 = v371;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v369);
          }
          v373 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += v366;
          memcpy((void *)&v373[v368], v365, v366);
          v375 = *(_QWORD *)(a2 + 8);
          v374 = *(_QWORD *)(a2 + 16);
          v376 = v375 + 7;
          if (v374)
          {
            if (v376 >= *(_QWORD *)v374)
            {
              v377 = malloc_type_realloc(*(void **)(v374 + 16), (v375 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v378 = *(unint64_t **)(a2 + 16);
              v378[2] = (unint64_t)v377;
              *v378 = (v375 + 262) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v377;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v376);
          }
          v379 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 7;
          v380 = (char *)&v379[v375];
          *(_DWORD *)(v380 + 3) = 1629757520;
          *(_DWORD *)v380 = 1347241300;
          v381 = *(_DWORD *)(*v54 + 88 * *v361 + 56);
          v383 = *(_QWORD *)(a2 + 8);
          v382 = *(_QWORD *)(a2 + 16);
          v384 = v383 + 20;
          if (v382)
          {
            if (v384 >= *(_QWORD *)v382)
            {
              v385 = malloc_type_realloc(*(void **)(v382 + 16), (v383 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v386 = *(unint64_t **)(a2 + 16);
              v386[2] = (unint64_t)v385;
              *v386 = (v383 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v385;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v384);
          }
          v387 = itoa((char *)(*(_QWORD *)a2 + v383), v381);
          v388 = *(_QWORD *)(a2 + 16);
          v389 = *(_QWORD *)(a2 + 8) + v387;
          *(_QWORD *)(a2 + 8) = v389;
          v390 = v389 + 1;
          if (v388)
          {
            if (v390 >= *(_QWORD *)v388)
            {
              v391 = malloc_type_realloc(*(void **)(v388 + 16), (v389 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v392 = *(_QWORD **)(a2 + 16);
              v392[2] = v391;
              *v392 = (v389 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)a2 = v391;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v390);
          }
          v393 = *(string_t *)a2;
          ++*(_QWORD *)(a2 + 8);
          v393[v389] = 91;
          v394 = *(_DWORD *)(*v54 + 88 * *v361 + 72);
          v396 = *(_QWORD *)(a2 + 8);
          v395 = *(_QWORD *)(a2 + 16);
          v397 = v396 + 20;
          if (v395)
          {
            if (v397 >= *(_QWORD *)v395)
            {
              v398 = malloc_type_realloc(*(void **)(v395 + 16), (v396 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v399 = *(unint64_t **)(a2 + 16);
              v399[2] = (unint64_t)v398;
              *v399 = (v396 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v398;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v397);
          }
          v400 = itoa((char *)(*(_QWORD *)a2 + v396), v394);
          v401 = *(_QWORD *)(a2 + 16);
          v402 = *(_QWORD *)(a2 + 8) + v400;
          *(_QWORD *)(a2 + 8) = v402;
          v403 = v402 + 3;
          if (v401)
          {
            if (v403 >= *(_QWORD *)v401)
            {
              v404 = malloc_type_realloc(*(void **)(v401 + 16), (v402 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v405 = *(unint64_t **)(a2 + 16);
              v405[2] = (unint64_t)v404;
              *v405 = (v402 + 258) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v404;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v403);
          }
          v362 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 3;
          v363 = (char *)&v362[v402];
          v363[2] = 10;
          *(_WORD *)v363 = 15197;
          ++v361;
          --v350;
        }
        while (v350);
      }
    }
    else
    {
      v1079 = 0;
    }
  }
  MEMORY[0x1B5E2914C](v16, 0x1000C8000313F17);
  v407 = *(_QWORD *)(a2 + 8);
  v406 = *(_QWORD *)(a2 + 16);
  v408 = v407 + 4;
  if (v406)
  {
    v409 = v1076;
    if (v408 >= *(_QWORD *)v406)
    {
      v410 = malloc_type_realloc(*(void **)(v406 + 16), (v407 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v411 = *(unint64_t **)(a2 + 16);
      v411[2] = (unint64_t)v410;
      *v411 = (v407 + 259) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)a2 = v410;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v408);
    v409 = v1076;
  }
  v412 = *(string_t *)a2;
  *(_QWORD *)(a2 + 8) += 4;
  *(_DWORD *)&v412[v407] = 170205987;
  if (*(_WORD *)(v409 + 24))
  {
    v414 = *(_QWORD *)(a2 + 8);
    v413 = *(_QWORD *)(a2 + 16);
    v415 = v414 + 6;
    if (v413)
    {
      if (v415 >= *(_QWORD *)v413)
      {
        v416 = malloc_type_realloc(*(void **)(v413 + 16), (v414 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v417 = *(unint64_t **)(a2 + 16);
        v417[2] = (unint64_t)v416;
        *v417 = (v414 + 261) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v416;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v415);
    }
    v418 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 6;
    v419 = (char *)&v418[v414];
    *((_WORD *)v419 + 2) = 29216;
    *(_DWORD *)v419 = 1347241300;
    v421 = *(_QWORD *)(a2 + 8);
    v420 = *(_QWORD *)(a2 + 16);
    v422 = v421 + 20;
    if (v420)
    {
      if (v422 >= *(_QWORD *)v420)
      {
        v423 = malloc_type_realloc(*(void **)(v420 + 16), (v421 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v424 = *(unint64_t **)(a2 + 16);
        v424[2] = (unint64_t)v423;
        *v424 = (v421 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v423;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v422);
    }
    *(_BYTE *)(*(_QWORD *)a2 + v421) = 48;
    v425 = *(_QWORD *)(a2 + 8) + 1;
    *(_QWORD *)(a2 + 8) = v425;
    if (*(unsigned __int16 *)(v409 + 24) >= 2u)
    {
      v426 = 1;
      do
      {
        v427 = v425 + 2;
        v428 = *(_QWORD *)(a2 + 16);
        if (v428)
        {
          if (v427 >= *(_QWORD *)v428)
          {
            v429 = malloc_type_realloc(*(void **)(v428 + 16), (v425 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v430 = *(unint64_t **)(a2 + 16);
            v430[2] = (unint64_t)v429;
            *v430 = (v425 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v429;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v427);
        }
        v431 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v431[v425] = 29228;
        v433 = *(_QWORD *)(a2 + 8);
        v432 = *(_QWORD *)(a2 + 16);
        v434 = v433 + 20;
        if (v432)
        {
          if (v434 >= *(_QWORD *)v432)
          {
            v435 = malloc_type_realloc(*(void **)(v432 + 16), (v433 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v436 = *(unint64_t **)(a2 + 16);
            v436[2] = (unint64_t)v435;
            *v436 = (v433 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v435;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v434);
        }
        v425 = *(_QWORD *)(a2 + 8) + itoa((char *)(*(_QWORD *)a2 + v433), v426);
        *(_QWORD *)(a2 + 8) = v425;
        ++v426;
      }
      while (v426 < *(unsigned __int16 *)(v409 + 24));
    }
    v437 = v425 + 2;
    v438 = *(_QWORD *)(a2 + 16);
    if (v438)
    {
      if (v437 >= *(_QWORD *)v438)
      {
        v439 = malloc_type_realloc(*(void **)(v438 + 16), (v425 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v440 = *(unint64_t **)(a2 + 16);
        v440[2] = (unint64_t)v439;
        *v440 = (v425 + 257) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v439;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v437);
    }
    v441 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 2;
    *(_WORD *)&v441[v425] = 2619;
  }
  if (*(_BYTE *)(v409 + 27))
  {
    v443 = *(_QWORD *)(a2 + 8);
    v442 = *(_QWORD *)(a2 + 16);
    v444 = v443 + 11;
    if (v442)
    {
      if (v444 >= *(_QWORD *)v442)
      {
        v445 = malloc_type_realloc(*(void **)(v442 + 16), (v443 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v446 = *(unint64_t **)(a2 + 16);
        v446[2] = (unint64_t)v445;
        *v446 = (v443 + 266) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v445;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v444);
    }
    v447 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 11;
    v448 = (char *)&v447[v443];
    *(_QWORD *)v448 = *(_QWORD *)"LONG TEMP l";
    *(_DWORD *)(v448 + 7) = 1814057037;
    v450 = *(_QWORD *)(a2 + 8);
    v449 = *(_QWORD *)(a2 + 16);
    v451 = v450 + 20;
    if (v449)
    {
      if (v451 >= *(_QWORD *)v449)
      {
        v452 = malloc_type_realloc(*(void **)(v449 + 16), (v450 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v453 = *(unint64_t **)(a2 + 16);
        v453[2] = (unint64_t)v452;
        *v453 = (v450 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v452;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v451);
    }
    *(_BYTE *)(*(_QWORD *)a2 + v450) = 48;
    v454 = *(_QWORD *)(a2 + 8) + 1;
    *(_QWORD *)(a2 + 8) = v454;
    if (*(unsigned __int8 *)(v409 + 27) >= 2u)
    {
      v455 = 1;
      do
      {
        v456 = v454 + 2;
        v457 = *(_QWORD *)(a2 + 16);
        if (v457)
        {
          if (v456 >= *(_QWORD *)v457)
          {
            v458 = malloc_type_realloc(*(void **)(v457 + 16), (v454 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v459 = *(unint64_t **)(a2 + 16);
            v459[2] = (unint64_t)v458;
            *v459 = (v454 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v458;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v456);
        }
        v460 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v460[v454] = 27692;
        v462 = *(_QWORD *)(a2 + 8);
        v461 = *(_QWORD *)(a2 + 16);
        v463 = v462 + 20;
        if (v461)
        {
          if (v463 >= *(_QWORD *)v461)
          {
            v464 = malloc_type_realloc(*(void **)(v461 + 16), (v462 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v465 = *(unint64_t **)(a2 + 16);
            v465[2] = (unint64_t)v464;
            *v465 = (v462 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v464;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v463);
        }
        v454 = *(_QWORD *)(a2 + 8) + itoa((char *)(*(_QWORD *)a2 + v462), v455);
        *(_QWORD *)(a2 + 8) = v454;
        ++v455;
      }
      while (v455 < *(unsigned __int8 *)(v409 + 27));
    }
    v466 = v454 + 2;
    v467 = *(_QWORD *)(a2 + 16);
    if (v467)
    {
      if (v466 >= *(_QWORD *)v467)
      {
        v468 = malloc_type_realloc(*(void **)(v467 + 16), (v454 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v469 = *(unint64_t **)(a2 + 16);
        v469[2] = (unint64_t)v468;
        *v469 = (v454 + 257) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v468;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v466);
    }
    v470 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 2;
    *(_WORD *)&v470[v454] = 2619;
  }
  if (*(_BYTE *)(v409 + 26))
  {
    v472 = *(_QWORD *)(a2 + 8);
    v471 = *(_QWORD *)(a2 + 16);
    v473 = v472 + 12;
    if (v471)
    {
      if (v473 >= *(_QWORD *)v471)
      {
        v474 = malloc_type_realloc(*(void **)(v471 + 16), (v472 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v475 = *(unint64_t **)(a2 + 16);
        v475[2] = (unint64_t)v474;
        *v475 = (v472 + 267) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v474;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v473);
    }
    v476 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 12;
    v477 = (char *)&v476[v472];
    *(_QWORD *)v477 = *(_QWORD *)"SHORT TEMP h";
    *((_DWORD *)v477 + 2) = 1746948173;
    v479 = *(_QWORD *)(a2 + 8);
    v478 = *(_QWORD *)(a2 + 16);
    v480 = v479 + 20;
    if (v478)
    {
      if (v480 >= *(_QWORD *)v478)
      {
        v481 = malloc_type_realloc(*(void **)(v478 + 16), (v479 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v482 = *(unint64_t **)(a2 + 16);
        v482[2] = (unint64_t)v481;
        *v482 = (v479 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v481;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v480);
    }
    *(_BYTE *)(*(_QWORD *)a2 + v479) = 48;
    v483 = *(_QWORD *)(a2 + 8) + 1;
    *(_QWORD *)(a2 + 8) = v483;
    if (*(unsigned __int8 *)(v409 + 26) >= 2u)
    {
      v484 = 1;
      do
      {
        v485 = v483 + 2;
        v486 = *(_QWORD *)(a2 + 16);
        if (v486)
        {
          if (v485 >= *(_QWORD *)v486)
          {
            v487 = malloc_type_realloc(*(void **)(v486 + 16), (v483 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v488 = *(unint64_t **)(a2 + 16);
            v488[2] = (unint64_t)v487;
            *v488 = (v483 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v487;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v485);
        }
        v489 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v489[v483] = 26668;
        v491 = *(_QWORD *)(a2 + 8);
        v490 = *(_QWORD *)(a2 + 16);
        v492 = v491 + 20;
        if (v490)
        {
          if (v492 >= *(_QWORD *)v490)
          {
            v493 = malloc_type_realloc(*(void **)(v490 + 16), (v491 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v494 = *(unint64_t **)(a2 + 16);
            v494[2] = (unint64_t)v493;
            *v494 = (v491 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v493;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v492);
        }
        v483 = *(_QWORD *)(a2 + 8) + itoa((char *)(*(_QWORD *)a2 + v491), v484);
        *(_QWORD *)(a2 + 8) = v483;
        ++v484;
      }
      while (v484 < *(unsigned __int8 *)(v409 + 26));
    }
    v495 = v483 + 2;
    v496 = *(_QWORD *)(a2 + 16);
    if (v496)
    {
      if (v495 >= *(_QWORD *)v496)
      {
        v497 = malloc_type_realloc(*(void **)(v496 + 16), (v483 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v498 = *(unint64_t **)(a2 + 16);
        v498[2] = (unint64_t)v497;
        *v498 = (v483 + 257) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v497;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v495);
    }
    v499 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 2;
    *(_WORD *)&v499[v483] = 2619;
  }
  if (*(_BYTE *)(v409 + 28))
  {
    v501 = *(_QWORD *)(a2 + 8);
    v500 = *(_QWORD *)(a2 + 16);
    v502 = v501 + 10;
    if (v500)
    {
      if (v502 >= *(_QWORD *)v500)
      {
        v503 = malloc_type_realloc(*(void **)(v500 + 16), (v501 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v504 = *(unint64_t **)(a2 + 16);
        v504[2] = (unint64_t)v503;
        *v504 = (v501 + 265) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v503;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v502);
    }
    v505 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 10;
    v506 = (char *)&v505[v501];
    *(_QWORD *)v506 = *(_QWORD *)"INT TEMP i";
    *((_WORD *)v506 + 4) = 26912;
    v508 = *(_QWORD *)(a2 + 8);
    v507 = *(_QWORD *)(a2 + 16);
    v509 = v508 + 20;
    if (v507)
    {
      if (v509 >= *(_QWORD *)v507)
      {
        v510 = malloc_type_realloc(*(void **)(v507 + 16), (v508 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v511 = *(unint64_t **)(a2 + 16);
        v511[2] = (unint64_t)v510;
        *v511 = (v508 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v510;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v509);
    }
    *(_BYTE *)(*(_QWORD *)a2 + v508) = 48;
    v512 = *(_QWORD *)(a2 + 8) + 1;
    *(_QWORD *)(a2 + 8) = v512;
    if (*(unsigned __int8 *)(v409 + 28) >= 2u)
    {
      v513 = 1;
      do
      {
        v514 = v512 + 2;
        v515 = *(_QWORD *)(a2 + 16);
        if (v515)
        {
          if (v514 >= *(_QWORD *)v515)
          {
            v516 = malloc_type_realloc(*(void **)(v515 + 16), (v512 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v517 = *(unint64_t **)(a2 + 16);
            v517[2] = (unint64_t)v516;
            *v517 = (v512 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v516;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v514);
        }
        v518 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v518[v512] = 26924;
        v520 = *(_QWORD *)(a2 + 8);
        v519 = *(_QWORD *)(a2 + 16);
        v521 = v520 + 20;
        if (v519)
        {
          if (v521 >= *(_QWORD *)v519)
          {
            v522 = malloc_type_realloc(*(void **)(v519 + 16), (v520 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v523 = *(unint64_t **)(a2 + 16);
            v523[2] = (unint64_t)v522;
            *v523 = (v520 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v522;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v521);
        }
        v512 = *(_QWORD *)(a2 + 8) + itoa((char *)(*(_QWORD *)a2 + v520), v513);
        *(_QWORD *)(a2 + 8) = v512;
        ++v513;
      }
      while (v513 < *(unsigned __int8 *)(v409 + 28));
    }
    v524 = v512 + 2;
    v525 = *(_QWORD *)(a2 + 16);
    if (v525)
    {
      if (v524 >= *(_QWORD *)v525)
      {
        v526 = malloc_type_realloc(*(void **)(v525 + 16), (v512 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v527 = *(unint64_t **)(a2 + 16);
        v527[2] = (unint64_t)v526;
        *v527 = (v512 + 257) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v526;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v524);
    }
    v528 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 2;
    *(_WORD *)&v528[v512] = 2619;
  }
  if (*(_BYTE *)(v409 + 29))
  {
    v530 = *(_QWORD *)(a2 + 8);
    v529 = *(_QWORD *)(a2 + 16);
    v531 = v530 + 11;
    if (v529)
    {
      if (v531 >= *(_QWORD *)v529)
      {
        v532 = malloc_type_realloc(*(void **)(v529 + 16), (v530 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v533 = *(unint64_t **)(a2 + 16);
        v533[2] = (unint64_t)v532;
        *v533 = (v530 + 266) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v532;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v531);
    }
    v534 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 11;
    v535 = (char *)&v534[v530];
    *(_QWORD *)v535 = *(_QWORD *)"UINT TEMP u";
    *(_DWORD *)(v535 + 7) = 1965051981;
    v537 = *(_QWORD *)(a2 + 8);
    v536 = *(_QWORD *)(a2 + 16);
    v538 = v537 + 20;
    if (v536)
    {
      if (v538 >= *(_QWORD *)v536)
      {
        v539 = malloc_type_realloc(*(void **)(v536 + 16), (v537 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v540 = *(unint64_t **)(a2 + 16);
        v540[2] = (unint64_t)v539;
        *v540 = (v537 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v539;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v538);
    }
    *(_BYTE *)(*(_QWORD *)a2 + v537) = 48;
    v541 = *(_QWORD *)(a2 + 8) + 1;
    *(_QWORD *)(a2 + 8) = v541;
    if (*(unsigned __int8 *)(v409 + 29) >= 2u)
    {
      v542 = 1;
      do
      {
        v543 = v541 + 2;
        v544 = *(_QWORD *)(a2 + 16);
        if (v544)
        {
          if (v543 >= *(_QWORD *)v544)
          {
            v545 = malloc_type_realloc(*(void **)(v544 + 16), (v541 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v546 = *(unint64_t **)(a2 + 16);
            v546[2] = (unint64_t)v545;
            *v546 = (v541 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v545;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v543);
        }
        v547 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v547[v541] = 29996;
        v549 = *(_QWORD *)(a2 + 8);
        v548 = *(_QWORD *)(a2 + 16);
        v550 = v549 + 20;
        if (v548)
        {
          if (v550 >= *(_QWORD *)v548)
          {
            v551 = malloc_type_realloc(*(void **)(v548 + 16), (v549 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v552 = *(unint64_t **)(a2 + 16);
            v552[2] = (unint64_t)v551;
            *v552 = (v549 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v551;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v550);
        }
        v541 = *(_QWORD *)(a2 + 8) + itoa((char *)(*(_QWORD *)a2 + v549), v542);
        *(_QWORD *)(a2 + 8) = v541;
        ++v542;
      }
      while (v542 < *(unsigned __int8 *)(v409 + 29));
    }
    v553 = v541 + 2;
    v554 = *(_QWORD *)(a2 + 16);
    if (v554)
    {
      if (v553 >= *(_QWORD *)v554)
      {
        v555 = malloc_type_realloc(*(void **)(v554 + 16), (v541 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v556 = *(unint64_t **)(a2 + 16);
        v556[2] = (unint64_t)v555;
        *v556 = (v541 + 257) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v555;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v553);
    }
    v557 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 2;
    *(_WORD *)&v557[v541] = 2619;
  }
  v559 = *(_QWORD *)(a2 + 8);
  v558 = *(_QWORD *)(a2 + 16);
  v560 = v559 + 4;
  if (v558)
  {
    if (v560 >= *(_QWORD *)v558)
    {
      v561 = malloc_type_realloc(*(void **)(v558 + 16), (v559 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v562 = *(unint64_t **)(a2 + 16);
      v562[2] = (unint64_t)v561;
      *v562 = (v559 + 259) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)a2 = v561;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v560);
  }
  v563 = *(string_t *)a2;
  *(_QWORD *)(a2 + 8) += 4;
  *(_DWORD *)&v563[v559] = 171975459;
  v564 = __s1a;
  v565 = *__s1a;
  if (v565 == 35)
  {
    while (v565 == 35)
    {
      ++v564;
      do
      {
        v565 = *v564;
        if (!*v564)
          goto LABEL_493;
        v567 = *(v564++ - 1);
      }
      while (v567 != 10);
      --v564;
      if ((v565 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          v566 = *++v564;
          v565 = v566;
        }
        while ((v566 - 33) > 0xFFFFFFDF);
      }
    }
LABEL_493:
    __s1a = v564;
  }
LABEL_500:
  v569 = v564;
  while (1)
  {
    while (1)
    {
      v570 = *v569;
      if (v570 == 35)
        break;
      if ((v570 - 58) < 2)
      {
        v577 = v569[1];
        v575 = v569 + 1;
        v576 = v577;
        if (!v577)
          goto LABEL_525;
        if ((v576 - 33) < 0xFFFFFFE0)
          goto LABEL_518;
        while (1)
        {
          do
          {
            v578 = *++v575;
            v576 = v578;
          }
          while ((v578 - 33) > 0xFFFFFFDF);
          do
          {
LABEL_518:
            if (v576 != 35)
              goto LABEL_525;
            ++v575;
            do
            {
              v576 = *v575;
              if (!*v575)
                goto LABEL_525;
              v579 = *(v575++ - 1);
            }
            while (v579 != 10);
            --v575;
          }
          while ((v576 - 33) < 0xFFFFFFE0);
        }
      }
      if (!*v569)
        goto LABEL_513;
      ++v569;
    }
LABEL_509:
    if ((v570 - 33) >= 0xFFFFFFE0)
    {
      do
      {
        v574 = *++v569;
        v570 = v574;
      }
      while ((v574 - 33) > 0xFFFFFFDF);
    }
    if (v570 == 35)
      break;
    if (!v570)
      goto LABEL_513;
  }
  v571 = v569;
  while (1)
  {
    v572 = *++v571;
    v570 = v572;
    if (!v572)
      break;
    v573 = *v569;
    v569 = v571;
    if (v573 == 10)
    {
      v569 = v571;
      goto LABEL_509;
    }
  }
LABEL_513:
  v575 = 0;
  if (!v564)
    goto LABEL_499;
  while (2)
  {
    switch(*v564)
    {
      case 'A':
        v599 = strncmp(v564, "ATTRIB", 6uLL);
        v600 = v564 + 6;
        if (v599)
          v600 = 0;
        v1080 = v600;
        if (!v599)
          goto LABEL_498;
        v1080 = (char *)arb::obj_alias((uint64_t)a1, v564, 0);
        if (v1080)
          goto LABEL_498;
        goto LABEL_676;
      case 'B':
        v601 = strncmp(v564, "BUFFER", 6uLL);
        v602 = v564 + 6;
        if (v601)
          v602 = 0;
        v1080 = v602;
        if (!v601)
          goto LABEL_498;
        goto LABEL_676;
      case 'C':
        v580 = strncmp(v564, "CENTROID", 8uLL);
        v581 = v564 + 8;
        if (v580)
          v582 = 0;
        else
          v582 = v564 + 8;
        v1080 = v582;
        if (v580)
          goto LABEL_676;
        v583 = *v581;
        if (!*v581)
          goto LABEL_524;
        if ((v583 - 33) >= 0xFFFFFFE0)
          goto LABEL_533;
LABEL_534:
        if (v583 == 35)
        {
          ++v581;
          while (1)
          {
            v583 = *v581;
            if (!*v581)
              break;
            v585 = *(v581++ - 1);
            if (v585 == 10)
            {
              --v581;
              if ((v583 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_533:
                  v584 = *++v581;
                  v583 = v584;
                }
                while ((v584 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_534;
            }
          }
        }
        goto LABEL_524;
      case 'D':
        v603 = a1[4];
        v604 = v603 < (unint64_t)v564 || v603 >= (unint64_t)v575;
        if (v604)
          goto LABEL_676;
        v605 = (char *)a1[5];
        v1080 = v605;
        v607 = *(_QWORD *)(a2 + 8);
        v606 = *(_QWORD *)(a2 + 16);
        v608 = v607 + 4;
        if (v606)
        {
          if (v608 >= *(_QWORD *)v606)
          {
            v609 = malloc_type_realloc(*(void **)(v606 + 16), (v607 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v610 = *(unint64_t **)(a2 + 16);
            v610[2] = (unint64_t)v609;
            *v610 = (v607 + 259) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v609;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v608);
        }
        v730 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 4;
        *(_DWORD *)&v730[v607] = 170861347;
        v678 = arb::obj_write_op(a1, a2, v564);
        v732 = *(_QWORD *)(a2 + 8);
        v731 = *(_QWORD *)(a2 + 16);
        v733 = v732 + 4;
        if (v731)
        {
          if (v733 >= *(_QWORD *)v731)
          {
            v734 = malloc_type_realloc(*(void **)(v731 + 16), (v732 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v735 = *(unint64_t **)(a2 + 16);
            v735[2] = (unint64_t)v734;
            *v735 = (v732 + 259) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v734;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v733);
        }
        v760 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 4;
        *(_DWORD *)&v760[v732] = 1448026890;
        v761 = arb::obj_write_dest(a1, (string_t *)a2, (arb *)(v605 + 4), (char *)&v1080, (const char **)&v1079, v678 == 0, 1);
        __s1a = (char *)v761;
        v762 = *v761;
        if (!*v761)
        {
          v788 = 0;
          goto LABEL_991;
        }
        v763 = v761;
        if ((v762 - 33) >= 0xFFFFFFE0)
          goto LABEL_766;
LABEL_767:
        if (v762 == 35)
        {
          v765 = v763;
          while (1)
          {
            v766 = *++v765;
            v762 = v766;
            if (!v766)
              break;
            v767 = *v763;
            v763 = v765;
            if (v767 == 10)
            {
              v763 = v765;
              if ((v762 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_766:
                  v764 = *++v763;
                  v762 = v764;
                }
                while ((v764 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_767;
            }
          }
        }
        else if (v762 == 44)
        {
          v930 = v763[1];
          v788 = (char *)(v763 + 1);
          v929 = v930;
          if (!v930)
            goto LABEL_991;
          if ((v929 - 33) < 0xFFFFFFE0)
            goto LABEL_984;
          while (1)
          {
            do
            {
              v931 = *++v788;
              v929 = v931;
            }
            while ((v931 - 33) > 0xFFFFFFDF);
            do
            {
LABEL_984:
              if (v929 != 35)
                goto LABEL_991;
              ++v788;
              do
              {
                v929 = *v788;
                if (!*v788)
                  goto LABEL_991;
                v932 = *(v788++ - 1);
              }
              while (v932 != 10);
              --v788;
            }
            while ((v929 - 33) < 0xFFFFFFE0);
          }
        }
        v788 = 0;
LABEL_991:
        __s1a = v788;
        v934 = *(_QWORD *)(a2 + 8);
        v933 = *(_QWORD *)(a2 + 16);
        v935 = v934 + 1;
        if (v933)
        {
          if (v935 >= *(_QWORD *)v933)
          {
            v936 = malloc_type_realloc(*(void **)(v933 + 16), (v934 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v937 = *(_QWORD **)(a2 + 16);
            v937[2] = v936;
            *v937 = (v934 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)a2 = v936;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v935);
        }
        v938 = 0;
        v939 = *(string_t *)a2;
        ++*(_QWORD *)(a2 + 8);
        v939[v934] = 44;
        do
        {
          v940 = &(v938++)[(_QWORD)v788];
          v1079 = v938;
        }
        while ((ctype[2 * v940[1]] & 0x40) != 0);
        arb::obj_write_symbol(a1, a2, v788, v788, v938, &v938[(_QWORD)v788]);
        v942 = *(_QWORD *)(a2 + 8);
        v941 = *(_QWORD *)(a2 + 16);
        v943 = v942 + 2;
        if (v941)
        {
          if (v943 >= *(_QWORD *)v941)
          {
            v944 = malloc_type_realloc(*(void **)(v941 + 16), (v942 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v945 = *(unint64_t **)(a2 + 16);
            v945[2] = (unint64_t)v944;
            *v945 = (v942 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v944;
          }
          v946 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 2;
          *(_WORD *)&v946[v942] = 2619;
          if (v678)
            goto LABEL_687;
        }
        else
        {
          str_alloc((string_t *)a2, v943);
          v947 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 2;
          *(_WORD *)&v947[v942] = 2619;
          if (v678)
            goto LABEL_687;
        }
        goto LABEL_1061;
      case 'E':
        if (!strncmp(v564, "END", 3uLL) && (ctype[2 * v564[3]] & 0x40) == 0)
          return;
        goto LABEL_676;
      case 'F':
        v586 = strncmp(v564, "FLAT", 4uLL);
        v581 = v564 + 4;
        if (v586)
          v587 = 0;
        else
          v587 = v564 + 4;
        v1080 = v587;
        if (v586)
        {
          v670 = strncmp(v564, "FLOAT", 5uLL);
          v671 = v564 + 5;
          if (v670)
            v671 = 0;
          v1080 = v671;
          if (!v670)
            goto LABEL_498;
LABEL_676:
          v678 = arb::obj_write_op(a1, a2, v564);
          __s1a = (char *)v678;
          v680 = *(_QWORD *)(a2 + 8);
          v679 = *(_QWORD *)(a2 + 16);
          if (v679)
          {
            if ((unint64_t)(v680 + 1) >= *(_QWORD *)v679)
            {
              v688 = malloc_type_realloc(*(void **)(v679 + 16), (v680 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v689 = *(_QWORD **)(a2 + 16);
              v689[2] = v688;
              *v689 = (v680 & 0xFFFFFFFFFFFFFF00) + 256;
              v690 = *(_QWORD *)(a2 + 8) + 1;
              *(_QWORD *)a2 = v688;
              *(_QWORD *)(a2 + 8) = v690;
              v688[v680] = 10;
              if (v678)
                goto LABEL_687;
            }
            else
            {
              v681 = *(string_t *)a2;
              ++*(_QWORD *)(a2 + 8);
              v681[v680] = 10;
              if (!v678)
                goto LABEL_1061;
LABEL_687:
              arb::obj_write_ssat((uint64_t)a1, a2, (arb *)v678, v677);
              v692 = *(_QWORD *)(a2 + 8);
              v691 = *(_QWORD *)(a2 + 16);
              v693 = v692 + 1;
              if (v691)
              {
LABEL_688:
                if (v693 >= *(_QWORD *)v691)
                {
                  v694 = malloc_type_realloc(*(void **)(v691 + 16), (v692 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                  v695 = *(_QWORD **)(a2 + 16);
                  v695[2] = v694;
                  *v695 = (v692 & 0xFFFFFFFFFFFFFF00) + 256;
                  *(_QWORD *)a2 = v694;
                }
              }
              else
              {
LABEL_1059:
                str_alloc((string_t *)a2, v693);
              }
              v1000 = *(string_t *)a2;
              ++*(_QWORD *)(a2 + 8);
              v1000[v692] = 10;
            }
LABEL_1061:
            v564 = v575;
            goto LABEL_499;
          }
          v682 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
          v683 = malloc_type_malloc((v680 & 0xFFFFFFFFFFFFFF00) + 256, 0x2BEB8FE7uLL);
          *((_QWORD *)v682 + 2) = v683;
          bzero(v683, (v680 & 0xFFFFFFFFFFFFFF00) + 256);
          *((_QWORD *)v682 + 1) = 1;
          v684 = *(_QWORD *)(a2 + 8);
          if (v684)
            memcpy(*((void **)v682 + 2), *(const void **)a2, v684);
          v685 = *(_QWORD *)(a2 + 16);
          if (v685)
            --*(_QWORD *)(v685 + 8);
          *(_QWORD *)v682 = (v680 & 0xFFFFFFFFFFFFFF00) + 256;
          *(_QWORD *)(a2 + 16) = v682;
          v686 = *((_QWORD *)v682 + 2);
          v687 = *(_QWORD *)(a2 + 8) + 1;
          *(_QWORD *)a2 = v686;
          *(_QWORD *)(a2 + 8) = v687;
          *(_BYTE *)(v686 + v680) = 10;
          if (!v678)
            goto LABEL_1061;
          goto LABEL_687;
        }
        v588 = *v581;
        if (*v581)
        {
          if ((v588 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_546:
              v589 = *++v581;
              v588 = v589;
            }
            while ((v589 - 33) > 0xFFFFFFDF);
          }
LABEL_547:
          if (v588 == 35)
          {
            ++v581;
            while (1)
            {
              v588 = *v581;
              if (!*v581)
                break;
              v590 = *(v581++ - 1);
              if (v590 == 10)
              {
                --v581;
                if ((v588 - 33) >= 0xFFFFFFE0)
                  goto LABEL_546;
                goto LABEL_547;
              }
            }
          }
        }
LABEL_524:
        __s1a = v581;
        v564 = v581;
LABEL_525:
        if (v564 == v575)
          goto LABEL_499;
        continue;
      case 'I':
        if (!strncmp(v564, "INTERPOLATE", 0xBuLL))
          goto LABEL_498;
        v611 = strncmp(v564, "INT", 3uLL);
        v612 = v564 + 3;
        if (v611)
          v612 = 0;
        v1080 = v612;
        if (!v611)
          goto LABEL_498;
        v613 = strncmp(v564, "IF", 2uLL);
        v614 = v564 + 2;
        if (v613)
          v615 = 0;
        else
          v615 = v564 + 2;
        v1080 = v615;
        if (v613)
          goto LABEL_676;
        v617 = *(_QWORD *)(a2 + 8);
        v616 = *(_QWORD *)(a2 + 16);
        v618 = v617 + 3;
        if (v616)
        {
          if (v618 >= *(_QWORD *)v616)
          {
            v619 = malloc_type_realloc(*(void **)(v616 + 16), (v617 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v620 = *(unint64_t **)(a2 + 16);
            v620[2] = (unint64_t)v619;
            *v620 = (v617 + 258) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v619;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v618);
        }
        v904 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 3;
        v905 = (char *)&v904[v617];
        v905[2] = 32;
        *(_WORD *)v905 = 17993;
        __s1a = v564 + 2;
        v906 = *v614;
        if (!*v614)
        {
          v907 = 2;
          goto LABEL_968;
        }
        v907 = 2;
        if (v906 == 59)
          goto LABEL_968;
        v907 = 2;
        while (2)
        {
          if (v906 != 35)
          {
            v906 = v564[++v907];
            goto LABEL_943;
          }
LABEL_936:
          if ((v906 - 33) >= 0xFFFFFFE0)
          {
            do
              v906 = v564[++v907];
            while ((v906 - 33) > 0xFFFFFFDF);
          }
          if (v906 != 35)
          {
LABEL_943:
            if (!v906 || v906 == 59)
              goto LABEL_968;
            continue;
          }
          break;
        }
        while (1)
        {
          v906 = v564[v907 + 1];
          if (!v564[v907 + 1])
            break;
          v908 = v564[v907++];
          if (v908 == 10)
            goto LABEL_936;
        }
        ++v907;
LABEL_968:
        v919 = v907 + 1;
        v920 = v564[v919];
        if (v564[v919])
        {
LABEL_969:
          if ((v920 - 33) >= 0xFFFFFFE0)
          {
            do
              v920 = v564[++v919];
            while ((v920 - 33) > 0xFFFFFFDF);
          }
          if (v920 == 35)
          {
            while (1)
            {
              v920 = v564[v919 + 1];
              if (!v564[v919 + 1])
                break;
              v921 = v564[v919++];
              if (v921 == 10)
                goto LABEL_969;
            }
            ++v919;
          }
        }
        v923 = *(_QWORD *)(a2 + 8);
        v922 = *(_QWORD *)(a2 + 16);
        v924 = v919 - 2;
        if (v919 == 2)
          goto LABEL_1079;
        v925 = v923 + v924;
        if (v922)
        {
          if (v925 >= *(_QWORD *)v922)
          {
            v926 = (v925 + 255) & 0xFFFFFFFFFFFFFF00;
            v927 = malloc_type_realloc(*(void **)(v922 + 16), v926, 0xCCCD1039uLL);
            v928 = *(size_t **)(a2 + 16);
            v928[2] = (size_t)v927;
            *v928 = v926;
            *(_QWORD *)a2 = v927;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v925);
        }
        v1001 = 0;
        v1002 = 0;
        v1003 = *(_QWORD *)a2 + v923;
        do
        {
          v1004 = v614[v1002];
          if ((v1004 - 33) > 0xFFFFFFDF)
          {
            v1005 = &v614[++v1002];
            if (v614[v1002] != 35)
              continue;
          }
          else
          {
            *(_BYTE *)(v1003 + v1001++) = v1004;
            v1005 = &v614[++v1002];
            if (v614[v1002] != 35)
              continue;
          }
          v1006 = 35;
LABEL_1072:
          if (v1006 == 35)
          {
            ++v1005;
            while (1)
            {
              v1006 = *v1005;
              if (!*v1005)
                break;
              v1008 = *(v1005++ - 1);
              if (v1008 == 10)
              {
                --v1005;
                if ((v1006 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v1007 = *++v1005;
                    v1006 = v1007;
                  }
                  while ((v1007 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_1072;
              }
            }
          }
          v1002 = v1005 - v614;
        }
        while (v1002 < v924);
        v922 = *(_QWORD *)(a2 + 16);
        v923 = *(_QWORD *)(a2 + 8) + v1001;
        *(_QWORD *)(a2 + 8) = v923;
LABEL_1079:
        v1009 = v923 + 1;
        if (v922)
        {
          if (v1009 >= *(_QWORD *)v922)
          {
            v1010 = malloc_type_realloc(*(void **)(v922 + 16), (v923 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v1011 = *(_QWORD **)(a2 + 16);
            v1011[2] = v1010;
            *v1011 = (v923 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)a2 = v1010;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v1009);
        }
        v1012 = *(string_t *)a2;
        ++*(_QWORD *)(a2 + 8);
        v1012[v923] = 10;
LABEL_498:
        v564 = v575;
LABEL_499:
        __s1a = v564;
        if (v564)
          goto LABEL_500;
        return;
      case 'K':
        v621 = strncmp(v564, "KIL", 3uLL);
        v622 = v564 + 3;
        if (v621)
          v622 = 0;
        v1080 = v622;
        if (v621)
          goto LABEL_676;
        v623 = 257;
        do
          v624 = ctype[2 * v564[v623++ - 254]];
        while ((v624 & 0x40) != 0);
        v625 = &v564[v623 - 255];
        v1080 = v625;
        v627 = *(_QWORD *)(a2 + 8);
        v626 = *(_QWORD *)(a2 + 16);
        v628 = v623 - 255 + v627;
        if (v626)
        {
          if (v628 >= *(_QWORD *)v626)
          {
            v629 = malloc_type_realloc(*(void **)(v626 + 16), (v627 + v623) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v630 = *(unint64_t **)(a2 + 16);
            v630[2] = (unint64_t)v629;
            *v630 = (v627 + v623) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v629;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v628);
        }
        v811 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) = *(_QWORD *)(a2 + 8) + v623 - 255;
        memcpy((void *)&v811[v627], v564, v623 - 255);
        v814 = *(_QWORD *)(a2 + 8);
        v813 = *(_QWORD *)(a2 + 16);
        v815 = v814 + 1;
        if (v813)
        {
          if (v815 >= *(_QWORD *)v813)
          {
            v816 = malloc_type_realloc(*(void **)(v813 + 16), (v814 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v817 = *(_QWORD **)(a2 + 16);
            v817[2] = v816;
            *v817 = (v814 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)a2 = v816;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v815);
        }
        v818 = *(string_t *)a2;
        ++*(_QWORD *)(a2 + 8);
        v818[v814] = 32;
        v819 = *v625;
        if (!*v625)
          goto LABEL_827;
        if ((v819 - 33) >= 0xFFFFFFE0)
          goto LABEL_820;
LABEL_821:
        if (v819 == 35)
        {
          ++v625;
          while (1)
          {
            v819 = *v625;
            if (!*v625)
              break;
            v821 = *(v625++ - 1);
            if (v821 == 10)
            {
              --v625;
              if ((v819 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_820:
                  v820 = *++v625;
                  v819 = v820;
                }
                while ((v820 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_821;
            }
          }
        }
LABEL_827:
        __s1a = v625;
        v822 = arb::asymbol((arb *)v625, (char *)&v1080, (const char **)&v1079, v812);
        arb::obj_write_symbol(a1, a2, __s1a, v1080, v1079, (char *)v822);
        v824 = *(_QWORD *)(a2 + 8);
        v823 = *(_QWORD *)(a2 + 16);
        v825 = v824 + 2;
        if (v823)
        {
          if (v825 >= *(_QWORD *)v823)
          {
            v826 = malloc_type_realloc(*(void **)(v823 + 16), (v824 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v827 = *(unint64_t **)(a2 + 16);
            v827[2] = (unint64_t)v826;
            *v827 = (v824 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v826;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v825);
        }
        v828 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v828[v824] = 2619;
        goto LABEL_1061;
      case 'L':
        v631 = strncmp(v564, "LONG", 4uLL);
        v632 = v564 + 4;
        if (v631)
          v632 = 0;
        v1080 = v632;
        if (!v631)
          goto LABEL_498;
        goto LABEL_676;
      case 'M':
        v633 = a1[3];
        if (v633 < (unint64_t)v564 || v633 >= (unint64_t)v575)
        {
          v635 = a1[4];
          if (v635 < (unint64_t)v564 || v635 >= (unint64_t)v575)
            goto LABEL_676;
          v637 = (char *)a1[5];
          v1080 = v637;
          v639 = *(_QWORD *)(a2 + 8);
          v638 = *(_QWORD *)(a2 + 16);
          v640 = v639 + 4;
          if (v638)
          {
            if (v640 >= *(_QWORD *)v638)
            {
              v641 = malloc_type_realloc(*(void **)(v638 + 16), (v639 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v642 = *(unint64_t **)(a2 + 16);
              v642[2] = (unint64_t)v641;
              *v642 = (v639 + 259) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v641;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v640);
          }
          v848 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 4;
          *(_DWORD *)&v848[v639] = 170861347;
          if (v564 < v637)
          {
            do
            {
              v849 = v564;
              v564 = v575;
              arb::obj_write_op(a1, a2, v849);
              while (1)
              {
                while (1)
                {
                  v850 = *v575;
                  if (v850 != 35)
                    break;
                  while (1)
                  {
                    if ((v850 - 33) >= 0xFFFFFFE0)
                    {
                      do
                      {
                        v854 = *++v575;
                        v850 = v854;
                      }
                      while ((v854 - 33) > 0xFFFFFFDF);
                    }
                    if (v850 != 35)
                      break;
                    v851 = v575;
                    do
                    {
                      v852 = *++v851;
                      v850 = v852;
                      if (!v852)
                        goto LABEL_865;
                      v853 = *v575;
                      v575 = v851;
                    }
                    while (v853 != 10);
                    v575 = v851;
                  }
                  if (!v850)
                  {
LABEL_865:
                    v575 = 0;
                    goto LABEL_866;
                  }
                }
                if ((v850 - 58) < 2)
                  break;
                if (!*v575)
                  goto LABEL_865;
                ++v575;
              }
              v856 = *++v575;
              v855 = v856;
              if (v856)
              {
                if ((v855 - 33) < 0xFFFFFFE0)
                  goto LABEL_871;
                do
                {
LABEL_870:
                  v857 = *++v575;
                  v855 = v857;
                }
                while ((v857 - 33) > 0xFFFFFFDF);
LABEL_871:
                while (v855 == 35)
                {
                  ++v575;
                  do
                  {
                    v855 = *v575;
                    if (!*v575)
                      goto LABEL_866;
                    v858 = *(v575++ - 1);
                  }
                  while (v858 != 10);
                  --v575;
                  if ((v855 - 33) >= 0xFFFFFFE0)
                    goto LABEL_870;
                }
              }
LABEL_866:
              ;
            }
            while (v564 < v1080);
          }
          v859 = arb::obj_write_op(a1, a2, v564);
          v861 = *(_QWORD *)(a2 + 8);
          v860 = *(_QWORD *)(a2 + 16);
          v862 = v861 + 8;
          if (v860)
          {
            if (v862 >= *(_QWORD *)v860)
            {
              v863 = malloc_type_realloc(*(void **)(v860 + 16), (v861 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v864 = *(unint64_t **)(a2 + 16);
              v864[2] = (unint64_t)v863;
              *v864 = (v861 + 263) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v863;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v862);
          }
          v865 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 8;
          *(_QWORD *)&v865[v861] = 0x5441535F4441230ALL;
          __s1a += 3;
          v866 = arb::obj_write_dest(a1, (string_t *)a2, (arb *)__s1a, (char *)&__s1a, (const char **)&v1079, 0, 0);
          __s1a = (char *)v866;
          v868 = *(_QWORD *)(a2 + 8);
          v867 = *(_QWORD *)(a2 + 16);
          v869 = v868 + 1;
          if (v867)
          {
            if (v869 >= *(_QWORD *)v867)
            {
              v870 = malloc_type_realloc(*(void **)(v867 + 16), (v868 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v871 = *(_QWORD **)(a2 + 16);
              v871[2] = v870;
              *v871 = (v868 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)a2 = v870;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v869);
          }
          v872 = *(string_t *)a2;
          ++*(_QWORD *)(a2 + 8);
          v872[v868] = 44;
          v873 = *v866;
          if (!*v866)
            goto LABEL_1094;
          if ((v873 - 33) < 0xFFFFFFE0)
            goto LABEL_888;
          do
          {
LABEL_887:
            v874 = *++v866;
            v873 = v874;
          }
          while ((v874 - 33) > 0xFFFFFFDF);
LABEL_888:
          while (v873 == 35)
          {
            v875 = v866;
            do
            {
              v876 = *++v875;
              v873 = v876;
              if (!v876)
                goto LABEL_1094;
              v877 = *v866;
              v866 = v875;
            }
            while (v877 != 10);
            v866 = v875;
            if ((v873 - 33) >= 0xFFFFFFE0)
              goto LABEL_887;
          }
          if (v873 == 44)
          {
            v1015 = v866[1];
            v1014 = (char *)(v866 + 1);
            v1013 = v1015;
            if (v1015)
            {
              if ((v1013 - 33) < 0xFFFFFFE0)
                goto LABEL_1088;
              do
              {
LABEL_1087:
                v1016 = *++v1014;
                v1013 = v1016;
              }
              while ((v1016 - 33) > 0xFFFFFFDF);
LABEL_1088:
              while (v1013 == 35)
              {
                ++v1014;
                do
                {
                  v1013 = *v1014;
                  if (!*v1014)
                    goto LABEL_1095;
                  v1017 = *(v1014++ - 1);
                }
                while (v1017 != 10);
                --v1014;
                if ((v1013 - 33) >= 0xFFFFFFE0)
                  goto LABEL_1087;
              }
            }
          }
          else
          {
LABEL_1094:
            v1014 = 0;
          }
LABEL_1095:
          v1018 = 0;
          __s1a = v1014;
          do
          {
            v1019 = &(v1018++)[(_QWORD)v1014];
            v1079 = v1018;
          }
          while ((ctype[2 * v1019[1]] & 0x40) != 0);
          __s1a = arb::obj_write_symbol(a1, a2, v1014, v1014, v1018, &v1018[(_QWORD)v1014]);
          v1021 = *(_QWORD *)(a2 + 8);
          v1020 = *(_QWORD *)(a2 + 16);
          v1022 = v1021 + 37;
          if (v1020)
          {
            if (v1022 >= *(_QWORD *)v1020)
            {
              v1023 = malloc_type_realloc(*(void **)(v1020 + 16), (v1021 + 292) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v1024 = *(unint64_t **)(a2 + 16);
              v1024[2] = (unint64_t)v1023;
              *v1024 = (v1021 + 292) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v1023;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v1022);
          }
          v1025 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 37;
          qmemcpy((void *)&v1025[v1021], ".w,{1e+6,1e+6,1e+6,0.},{0.,0.,0.,1.};", 37);
          v1026 = v1080;
          arb::obj_write_op(a1, a2, v1080);
          v1029 = *(_QWORD *)(a2 + 8);
          v1028 = *(_QWORD *)(a2 + 16);
          v1030 = v1029 + 1;
          if (v1028)
          {
            if (v1030 >= *(_QWORD *)v1028)
            {
              v1031 = malloc_type_realloc(*(void **)(v1028 + 16), (v1029 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v1032 = *(_QWORD **)(a2 + 16);
              v1032[2] = v1031;
              *v1032 = (v1029 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)a2 = v1031;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v1030);
          }
          v1033 = *(string_t *)a2;
          ++*(_QWORD *)(a2 + 8);
          v1033[v1029] = 10;
          while (1)
          {
            while (1)
            {
              v1034 = *v1026;
              if (v1034 == 35)
                break;
              if ((v1034 - 58) < 2)
              {
                v1046 = v1026[1];
                v564 = v1026 + 1;
                v1045 = v1046;
                if (v1046)
                {
                  if ((v1045 - 33) < 0xFFFFFFE0)
                    goto LABEL_1129;
                  do
                  {
LABEL_1128:
                    v1047 = *++v564;
                    v1045 = v1047;
                  }
                  while ((v1047 - 33) > 0xFFFFFFDF);
LABEL_1129:
                  while (v1045 == 35)
                  {
                    ++v564;
                    do
                    {
                      v1045 = *v564;
                      if (!*v564)
                        goto LABEL_1119;
                      v1048 = *(v564++ - 1);
                    }
                    while (v1048 != 10);
                    --v564;
                    if ((v1045 - 33) >= 0xFFFFFFE0)
                      goto LABEL_1128;
                  }
                }
LABEL_1119:
                if (v859)
                {
                  arb::obj_write_ssat((uint64_t)a1, a2, (arb *)v859, v1027);
                  v1040 = *(_QWORD *)(a2 + 8);
                  v1039 = *(_QWORD *)(a2 + 16);
                  v1041 = v1040 + 1;
                  if (v1039)
                  {
                    if (v1041 >= *(_QWORD *)v1039)
                    {
                      v1042 = malloc_type_realloc(*(void **)(v1039 + 16), (v1040 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                      v1043 = *(_QWORD **)(a2 + 16);
                      v1043[2] = v1042;
                      *v1043 = (v1040 & 0xFFFFFFFFFFFFFF00) + 256;
                      *(_QWORD *)a2 = v1042;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)a2, v1041);
                  }
                  v1044 = *(string_t *)a2;
                  ++*(_QWORD *)(a2 + 8);
                  v1044[v1040] = 10;
                }
                goto LABEL_499;
              }
              if (!*v1026)
                goto LABEL_1118;
              ++v1026;
            }
            while (1)
            {
              if ((v1034 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  v1038 = *++v1026;
                  v1034 = v1038;
                }
                while ((v1038 - 33) > 0xFFFFFFDF);
              }
              if (v1034 != 35)
                break;
              v1035 = v1026;
              do
              {
                v1036 = *++v1035;
                v1034 = v1036;
                if (!v1036)
                  goto LABEL_1118;
                v1037 = *v1026;
                v1026 = v1035;
              }
              while (v1037 != 10);
              v1026 = v1035;
            }
            if (!v1034)
            {
LABEL_1118:
              v564 = 0;
              goto LABEL_1119;
            }
          }
        }
        v697 = *(_QWORD *)(a2 + 8);
        v696 = *(_QWORD *)(a2 + 16);
        v698 = v697 + 4;
        if (v696)
        {
          if (v698 >= *(_QWORD *)v696)
          {
            v699 = malloc_type_realloc(*(void **)(v696 + 16), (v697 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v700 = *(unint64_t **)(a2 + 16);
            v700[2] = (unint64_t)v699;
            *v700 = (v697 + 259) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v699;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v698);
        }
        v753 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 4;
        *(_DWORD *)&v753[v697] = 170533667;
        v754 = arb::obj_write_op(a1, a2, v564);
        v756 = *(_QWORD *)(a2 + 8);
        v755 = *(_QWORD *)(a2 + 16);
        v757 = v756 + 4;
        if (v755)
        {
          if (v757 >= *(_QWORD *)v755)
          {
            v758 = malloc_type_realloc(*(void **)(v755 + 16), (v756 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v759 = *(unint64_t **)(a2 + 16);
            v759[2] = (unint64_t)v758;
            *v759 = (v756 + 259) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v758;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v757);
        }
        v776 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 4;
        *(_DWORD *)&v776[v756] = 1448026890;
        v778 = v564[3];
        v777 = v564 + 3;
        v779 = v778 == 65;
        if (v778 == 65)
          v780 = (arb *)(v777 + 1);
        else
          v780 = (arb *)v777;
        v781 = arb::obj_write_dest(a1, (string_t *)a2, v780, (char *)&v1080, (const char **)&v1079, v754 == 0, v779);
        __s1a = (char *)v781;
        v782 = *v781;
        if (!*v781)
          goto LABEL_1046;
        v783 = v781;
        if ((v782 - 33) < 0xFFFFFFE0)
          goto LABEL_790;
        do
        {
LABEL_789:
          v784 = *++v783;
          v782 = v784;
        }
        while ((v784 - 33) > 0xFFFFFFDF);
LABEL_790:
        while (v782 == 35)
        {
          v785 = v783;
          do
          {
            v786 = *++v785;
            v782 = v786;
            if (!v786)
              goto LABEL_1046;
            v787 = *v783;
            v783 = v785;
          }
          while (v787 != 10);
          v783 = v785;
          if ((v782 - 33) >= 0xFFFFFFE0)
            goto LABEL_789;
        }
        if (v782 == 44)
        {
          v982 = v783[1];
          v981 = (char *)(v783 + 1);
          v980 = v982;
          if (v982)
          {
            if ((v980 - 33) < 0xFFFFFFE0)
              goto LABEL_1040;
            do
            {
LABEL_1039:
              v983 = *++v981;
              v980 = v983;
            }
            while ((v983 - 33) > 0xFFFFFFDF);
LABEL_1040:
            while (v980 == 35)
            {
              ++v981;
              do
              {
                v980 = *v981;
                if (!*v981)
                  goto LABEL_1047;
                v984 = *(v981++ - 1);
              }
              while (v984 != 10);
              --v981;
              if ((v980 - 33) >= 0xFFFFFFE0)
                goto LABEL_1039;
            }
          }
        }
        else
        {
LABEL_1046:
          v981 = 0;
        }
LABEL_1047:
        __s1a = v981;
        v986 = *(_QWORD *)(a2 + 8);
        v985 = *(_QWORD *)(a2 + 16);
        v987 = v986 + 1;
        if (v985)
        {
          if (v987 >= *(_QWORD *)v985)
          {
            v988 = malloc_type_realloc(*(void **)(v985 + 16), (v986 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v989 = *(_QWORD **)(a2 + 16);
            v989[2] = v988;
            *v989 = (v986 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)a2 = v988;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v987);
        }
        v990 = 0;
        v991 = *(string_t *)a2;
        ++*(_QWORD *)(a2 + 8);
        v991[v986] = 44;
        do
        {
          v992 = &(v990++)[(_QWORD)v981];
          v1079 = v990;
        }
        while ((ctype[2 * v992[1]] & 0x40) != 0);
        arb::obj_write_symbol(a1, a2, v981, v981, v990, &v990[(_QWORD)v981]);
        v995 = *(_QWORD *)(a2 + 8);
        v994 = *(_QWORD *)(a2 + 16);
        v996 = v995 + 2;
        if (v994)
        {
          if (v996 >= *(_QWORD *)v994)
          {
            v997 = malloc_type_realloc(*(void **)(v994 + 16), (v995 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v998 = *(unint64_t **)(a2 + 16);
            v998[2] = (unint64_t)v997;
            *v998 = (v995 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v997;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v996);
        }
        v999 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v999[v995] = 2619;
        if (!v754)
          goto LABEL_1061;
        arb::obj_write_ssat((uint64_t)a1, a2, (arb *)v754, v993);
        v692 = *(_QWORD *)(a2 + 8);
        v691 = *(_QWORD *)(a2 + 16);
        v693 = v692 + 1;
        if (v691)
          goto LABEL_688;
        goto LABEL_1059;
      case 'O':
        v643 = strncmp(v564, "OUTPUT", 6uLL);
        v644 = v564 + 6;
        if (v643)
          v645 = 0;
        else
          v645 = v564 + 6;
        v1080 = v645;
        if (!v643)
          goto LABEL_498;
        v646 = strncmp(v564, "OPTION", 6uLL);
        if (v646)
          v647 = 0;
        else
          v647 = v564 + 6;
        v1080 = v647;
        if (v646)
          goto LABEL_676;
        v648 = *v644;
        if (!*v644)
          goto LABEL_696;
        if ((v648 - 33) >= 0xFFFFFFE0)
          goto LABEL_635;
LABEL_636:
        if (v648 == 35)
        {
          ++v644;
          while (1)
          {
            v648 = *v644;
            if (!*v644)
              break;
            v650 = *(v644++ - 1);
            if (v650 == 10)
            {
              --v644;
              if ((v648 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_635:
                  v649 = *++v644;
                  v648 = v649;
                }
                while ((v649 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_636;
            }
          }
        }
LABEL_696:
        __s1a = v644;
        v706 = strncmp(v644, "NV_fragment_program", 0x13uLL);
        v707 = v644 + 19;
        if (v706)
          v707 = 0;
        v1080 = v707;
        if (!v706)
          goto LABEL_498;
        v708 = strncmp(v644, "ARB_precision_hint_fastest", 0x1AuLL);
        v709 = v644 + 26;
        if (v708)
          v709 = 0;
        v1080 = v709;
        if (!v708)
          goto LABEL_498;
        v710 = strncmp(v644, "ARB_precision_hint_nicest", 0x19uLL);
        v711 = v644 + 25;
        if (v710)
          v711 = 0;
        v1080 = v711;
        if (!v710)
          goto LABEL_498;
        v712 = strncmp(v644, "ARB_draw_buffers", 0x10uLL);
        if (v712)
          v713 = 0;
        else
          v713 = v644 + 16;
        v1080 = v713;
        if (!v712)
          goto LABEL_1061;
        v714 = strncmp(v644, "ATI_draw_buffers", 0x10uLL);
        v715 = v714 ? 0 : v644 + 16;
        v1080 = v715;
        if (!v714)
          goto LABEL_1061;
        v716 = strncmp(v644, "NV_vertex_program", 0x11uLL);
        v717 = v644 + 17;
        if (v716)
          v717 = 0;
        v1080 = v717;
        if (!v716)
          goto LABEL_498;
        v718 = strncmp(v644, "ARB_position_invariant", 0x16uLL);
        v719 = v644 + 22;
        if (v718)
          v719 = 0;
        v1080 = v719;
        if (!v718)
          goto LABEL_498;
        v721 = *(_QWORD *)(a2 + 8);
        v720 = *(_QWORD *)(a2 + 16);
        v722 = v721 + 7;
        if (v720)
        {
          if (v722 >= *(_QWORD *)v720)
          {
            v723 = malloc_type_realloc(*(void **)(v720 + 16), (v721 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v724 = *(unint64_t **)(a2 + 16);
            v724[2] = (unint64_t)v723;
            *v724 = (v721 + 262) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v723;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v722);
        }
        v1049 = 0;
        v1050 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 7;
        v1051 = (char *)&v1050[v721];
        *(_DWORD *)(v1051 + 3) = 542003017;
        *(_DWORD *)v1051 = 1230262351;
        v1052 = v644;
        v1053 = v644;
        v1054 = *v644;
        if (v1054 != 35)
          goto LABEL_1137;
        do
        {
LABEL_1143:
          if ((v1054 - 33) < 0xFFFFFFE0)
            goto LABEL_1145;
          do
          {
LABEL_1144:
            v1055 = *++v1053;
            v1054 = v1055;
          }
          while ((v1055 - 33) > 0xFFFFFFDF);
LABEL_1145:
          while (v1054 == 35)
          {
            ++v1053;
            do
            {
              v1054 = *v1053;
              if (!*v1053)
                goto LABEL_1142;
              v1056 = *(v1053++ - 1);
            }
            while (v1056 != 10);
            --v1053;
            if ((v1054 - 33) >= 0xFFFFFFE0)
              goto LABEL_1144;
          }
LABEL_1142:
          v1049 = v1053 - v644;
          v1054 = *v1053;
        }
        while (v1054 == 35);
LABEL_1137:
        while (v1054 != 59)
        {
          ++v1049;
          if ((v1054 - 33) < 0xFFFFFFE0)
            v1052 = &v644[v1049];
          v1053 = &v644[v1049];
          v1054 = v644[v1049];
          if (v1054 == 35)
            goto LABEL_1143;
        }
        v1058 = *(_QWORD *)(a2 + 8);
        v1057 = *(_QWORD *)(a2 + 16);
        v1059 = v1052 - v644;
        if (v1052 == v644)
        {
LABEL_1172:
          v1072 = v1058 + 2;
          if (v1057)
          {
            if (v1072 >= *(_QWORD *)v1057)
            {
              v1073 = malloc_type_realloc(*(void **)(v1057 + 16), (v1058 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v1074 = *(unint64_t **)(a2 + 16);
              v1074[2] = (unint64_t)v1073;
              *v1074 = (v1058 + 257) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v1073;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v1072);
          }
          v1075 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 2;
          *(_WORD *)&v1075[v1058] = 2619;
          goto LABEL_498;
        }
        v1060 = v1058 + v1059;
        if (v1057)
        {
          if (v1060 >= *(_QWORD *)v1057)
          {
            v1061 = (v1060 + 255) & 0xFFFFFFFFFFFFFF00;
            v1062 = malloc_type_realloc(*(void **)(v1057 + 16), v1061, 0xCCCD1039uLL);
            v1063 = *(size_t **)(a2 + 16);
            v1063[2] = (size_t)v1062;
            *v1063 = v1061;
            *(_QWORD *)a2 = v1062;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v1060);
        }
        v1064 = 0;
        v1065 = 0;
        v1066 = *(_QWORD *)a2 + v1058;
        break;
      case 'P':
        v591 = strncmp(v564, "PARAM", 5uLL);
        v592 = v564 + 5;
        if (v591)
          v592 = 0;
        v1080 = v592;
        if (!v591)
          goto LABEL_497;
        v593 = strncmp(v564, "NOPERSPECTIVE", 0xDuLL);
        v594 = v564 + 13;
        if (v593)
          v595 = 0;
        else
          v595 = v564 + 13;
        v1080 = v595;
        if (v593)
        {
          v672 = strncmp(v564, "PRIMITIVE_IN", 0xCuLL);
          v673 = v564 + 12;
          if (v672)
            v674 = 0;
          else
            v674 = v564 + 12;
          v1080 = v674;
          if (v672)
          {
            v675 = strncmp(v564, "PRIMITIVE_OUT", 0xDuLL);
            if (v675)
              v676 = 0;
            else
              v676 = v564 + 13;
            v1080 = v676;
            if (v675)
              goto LABEL_676;
            v726 = *(_QWORD *)(a2 + 8);
            v725 = *(_QWORD *)(a2 + 16);
            v727 = v726 + 13;
            if (v725)
            {
              if (v727 >= *(_QWORD *)v725)
              {
                v728 = malloc_type_realloc(*(void **)(v725 + 16), (v726 + 268) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v729 = *(unint64_t **)(a2 + 16);
                v729[2] = (unint64_t)v728;
                *v729 = (v726 + 268) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)a2 = v728;
              }
            }
            else
            {
              str_alloc((string_t *)a2, v727);
            }
            v878 = *(string_t *)a2;
            *(_QWORD *)(a2 + 8) += 13;
            v879 = (char *)&v878[v726];
            v880 = *(_QWORD *)v564;
            *(_QWORD *)(v879 + 5) = *(_QWORD *)(v564 + 5);
            *(_QWORD *)v879 = v880;
            v882 = *(_QWORD *)(a2 + 8);
            v881 = *(_QWORD *)(a2 + 16);
            v883 = v882 + 1;
            if (v881)
            {
              if (v883 >= *(_QWORD *)v881)
              {
                v884 = malloc_type_realloc(*(void **)(v881 + 16), (v882 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                v885 = *(_QWORD **)(a2 + 16);
                v885[2] = v884;
                *v885 = (v882 & 0xFFFFFFFFFFFFFF00) + 256;
                *(_QWORD *)a2 = v884;
              }
            }
            else
            {
              str_alloc((string_t *)a2, v883);
            }
            v895 = *(string_t *)a2;
            ++*(_QWORD *)(a2 + 8);
            v895[v882] = 32;
            v896 = *v594;
            if (*v594)
            {
              if ((v896 - 33) < 0xFFFFFFE0)
                goto LABEL_921;
              do
              {
LABEL_920:
                v897 = *++v594;
                v896 = v897;
              }
              while ((v897 - 33) > 0xFFFFFFDF);
LABEL_921:
              while (v896 == 35)
              {
                ++v594;
                do
                {
                  v896 = *v594;
                  if (!*v594)
                    goto LABEL_927;
                  v898 = *(v594++ - 1);
                }
                while (v898 != 10);
                --v594;
                if ((v896 - 33) >= 0xFFFFFFE0)
                  goto LABEL_920;
              }
            }
LABEL_927:
            __s1a = v594;
            v842 = *(_QWORD *)(a2 + 8);
            v841 = *(_QWORD *)(a2 + 16);
            v899 = v575 - v594;
            if (v575 == v594)
              goto LABEL_963;
            v900 = v842 + v899;
            if (v841)
            {
              if (v900 >= *(_QWORD *)v841)
              {
                v901 = (v900 + 255) & 0xFFFFFFFFFFFFFF00;
                v902 = malloc_type_realloc(*(void **)(v841 + 16), v901, 0xCCCD1039uLL);
                v903 = *(size_t **)(a2 + 16);
                v903[2] = (size_t)v902;
                *v903 = v901;
                *(_QWORD *)a2 = v902;
              }
            }
            else
            {
              str_alloc((string_t *)a2, v900);
            }
            v909 = 0;
            v910 = 0;
            v911 = *(_QWORD *)a2 + v842;
            while (2)
            {
              v912 = v594[v910];
              if ((v912 - 33) > 0xFFFFFFDF)
              {
                v913 = &v594[++v910];
                if (v594[v910] == 35)
                {
LABEL_954:
                  v914 = 35;
                  while (v914 == 35)
                  {
                    ++v913;
                    do
                    {
                      v914 = *v913;
                      if (!*v913)
                        goto LABEL_948;
                      v916 = *(v913++ - 1);
                    }
                    while (v916 != 10);
                    --v913;
                    if ((v914 - 33) >= 0xFFFFFFE0)
                    {
                      do
                      {
                        v915 = *++v913;
                        v914 = v915;
                      }
                      while ((v915 - 33) > 0xFFFFFFDF);
                    }
                  }
LABEL_948:
                  v910 = v913 - v594;
                }
              }
              else
              {
                *(_BYTE *)(v911 + v909++) = v912;
                v913 = &v594[++v910];
                if (v594[v910] == 35)
                  goto LABEL_954;
              }
              if (v910 >= v899)
              {
                v841 = *(_QWORD *)(a2 + 16);
                v842 = *(_QWORD *)(a2 + 8) + v909;
                *(_QWORD *)(a2 + 8) = v842;
LABEL_963:
                v894 = v842 + 1;
                if (v841)
                {
LABEL_964:
                  if (v894 >= *(_QWORD *)v841)
                  {
                    v917 = malloc_type_realloc(*(void **)(v841 + 16), (v842 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                    v918 = *(_QWORD **)(a2 + 16);
                    v918[2] = v917;
                    *v918 = (v842 & 0xFFFFFFFFFFFFFF00) + 256;
                    *(_QWORD *)a2 = v917;
                  }
LABEL_496:
                  v568 = *(string_t *)a2;
                  ++*(_QWORD *)(a2 + 8);
                  v568[v842] = 10;
LABEL_497:
                  __s1a = v575;
                  goto LABEL_498;
                }
LABEL_495:
                str_alloc((string_t *)a2, v894);
                goto LABEL_496;
              }
              continue;
            }
          }
          v702 = *(_QWORD *)(a2 + 8);
          v701 = *(_QWORD *)(a2 + 16);
          v703 = v702 + 12;
          if (v701)
          {
            if (v703 >= *(_QWORD *)v701)
            {
              v704 = malloc_type_realloc(*(void **)(v701 + 16), (v702 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v705 = *(unint64_t **)(a2 + 16);
              v705[2] = (unint64_t)v704;
              *v705 = (v702 + 267) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)a2 = v704;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v703);
          }
          v829 = *(string_t *)a2;
          *(_QWORD *)(a2 + 8) += 12;
          v830 = (char *)&v829[v702];
          v831 = *(_QWORD *)v564;
          *((_DWORD *)v830 + 2) = *((_DWORD *)v564 + 2);
          *(_QWORD *)v830 = v831;
          v833 = *(_QWORD *)(a2 + 8);
          v832 = *(_QWORD *)(a2 + 16);
          v834 = v833 + 1;
          if (v832)
          {
            if (v834 >= *(_QWORD *)v832)
            {
              v835 = malloc_type_realloc(*(void **)(v832 + 16), (v833 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v836 = *(_QWORD **)(a2 + 16);
              v836[2] = v835;
              *v836 = (v833 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)a2 = v835;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v834);
          }
          v837 = *(string_t *)a2;
          ++*(_QWORD *)(a2 + 8);
          v837[v833] = 32;
          v838 = *v673;
          if (*v673)
          {
            if ((v838 - 33) < 0xFFFFFFE0)
              goto LABEL_840;
            do
            {
LABEL_839:
              v839 = *++v673;
              v838 = v839;
            }
            while ((v839 - 33) > 0xFFFFFFDF);
LABEL_840:
            while (v838 == 35)
            {
              ++v673;
              do
              {
                v838 = *v673;
                if (!*v673)
                  goto LABEL_846;
                v840 = *(v673++ - 1);
              }
              while (v840 != 10);
              --v673;
              if ((v838 - 33) >= 0xFFFFFFE0)
                goto LABEL_839;
            }
          }
LABEL_846:
          __s1a = v673;
          v842 = *(_QWORD *)(a2 + 8);
          v841 = *(_QWORD *)(a2 + 16);
          v843 = v575 - v673;
          if (v575 == v673)
            goto LABEL_915;
          v844 = v842 + v843;
          if (v841)
          {
            if (v844 >= *(_QWORD *)v841)
            {
              v845 = (v844 + 255) & 0xFFFFFFFFFFFFFF00;
              v846 = malloc_type_realloc(*(void **)(v841 + 16), v845, 0xCCCD1039uLL);
              v847 = *(size_t **)(a2 + 16);
              v847[2] = (size_t)v846;
              *v847 = v845;
              *(_QWORD *)a2 = v846;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v844);
          }
          v886 = 0;
          v887 = 0;
          v888 = *(_QWORD *)a2 + v842;
          while (2)
          {
            v889 = v673[v887];
            if ((v889 - 33) > 0xFFFFFFDF)
            {
              v890 = &v673[++v887];
              if (v673[v887] == 35)
              {
LABEL_906:
                v891 = 35;
                while (v891 == 35)
                {
                  ++v890;
                  do
                  {
                    v891 = *v890;
                    if (!*v890)
                      goto LABEL_900;
                    v893 = *(v890++ - 1);
                  }
                  while (v893 != 10);
                  --v890;
                  if ((v891 - 33) >= 0xFFFFFFE0)
                  {
                    do
                    {
                      v892 = *++v890;
                      v891 = v892;
                    }
                    while ((v892 - 33) > 0xFFFFFFDF);
                  }
                }
LABEL_900:
                v887 = v890 - v673;
              }
            }
            else
            {
              *(_BYTE *)(v888 + v886++) = v889;
              v890 = &v673[++v887];
              if (v673[v887] == 35)
                goto LABEL_906;
            }
            if (v887 >= v843)
            {
              v841 = *(_QWORD *)(a2 + 16);
              v842 = *(_QWORD *)(a2 + 8) + v886;
              *(_QWORD *)(a2 + 8) = v842;
LABEL_915:
              v894 = v842 + 1;
              if (v841)
                goto LABEL_964;
              goto LABEL_495;
            }
            continue;
          }
        }
        v596 = *v594;
        if (*v594)
        {
          if ((v596 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_562:
              v597 = *++v594;
              v596 = v597;
            }
            while ((v597 - 33) > 0xFFFFFFDF);
          }
LABEL_563:
          if (v596 == 35)
          {
            ++v594;
            while (1)
            {
              v596 = *v594;
              if (!*v594)
                break;
              v598 = *(v594++ - 1);
              if (v598 == 10)
              {
                --v594;
                if ((v596 - 33) >= 0xFFFFFFE0)
                  goto LABEL_562;
                goto LABEL_563;
              }
            }
          }
        }
        __s1a = v594;
        v564 = v594;
        if (v594 == v575)
          goto LABEL_499;
        continue;
      case 'R':
        v651 = a1[4];
        if (v651 < (unint64_t)v564 || v651 >= (unint64_t)v575)
          goto LABEL_676;
        v653 = (char *)a1[5];
        v1080 = v653;
        v655 = *(_QWORD *)(a2 + 8);
        v654 = *(_QWORD *)(a2 + 16);
        v656 = v655 + 4;
        if (v654)
        {
          if (v656 >= *(_QWORD *)v654)
          {
            v657 = malloc_type_realloc(*(void **)(v654 + 16), (v655 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v658 = *(unint64_t **)(a2 + 16);
            v658[2] = (unint64_t)v657;
            *v658 = (v655 + 259) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v657;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v656);
        }
        v736 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 4;
        *(_DWORD *)&v736[v655] = 170861347;
LABEL_732:
        if (v564 < v653)
        {
          v737 = v564;
          v564 = v575;
          arb::obj_write_op(a1, a2, v737);
          __s1a = v575;
          while (1)
          {
            while (1)
            {
              v738 = *v575;
              if (v738 == 35)
                break;
              if ((v738 - 58) < 2)
              {
                v744 = *++v575;
                v743 = v744;
                if (!v744)
                  goto LABEL_732;
                if ((v743 - 33) < 0xFFFFFFE0)
                  goto LABEL_750;
                while (1)
                {
                  do
                  {
                    v745 = *++v575;
                    v743 = v745;
                  }
                  while ((v745 - 33) > 0xFFFFFFDF);
                  do
                  {
LABEL_750:
                    if (v743 != 35)
                      goto LABEL_732;
                    ++v575;
                    do
                    {
                      v743 = *v575;
                      if (!*v575)
                        goto LABEL_732;
                      v746 = *(v575++ - 1);
                    }
                    while (v746 != 10);
                    --v575;
                  }
                  while ((v743 - 33) < 0xFFFFFFE0);
                }
              }
              if (!*v575)
                goto LABEL_731;
              ++v575;
            }
            while (1)
            {
              if ((v738 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  v742 = *++v575;
                  v738 = v742;
                }
                while ((v742 - 33) > 0xFFFFFFDF);
              }
              if (v738 != 35)
                break;
              v739 = v575;
              do
              {
                v740 = *++v739;
                v738 = v740;
                if (!v740)
                  goto LABEL_731;
                v741 = *v575;
                v575 = v739;
              }
              while (v741 != 10);
              v575 = v739;
            }
            if (!v738)
            {
LABEL_731:
              v575 = 0;
              goto LABEL_732;
            }
          }
        }
        v747 = arb::obj_write_op(a1, a2, v564);
        v749 = *(_QWORD *)(a2 + 8);
        v748 = *(_QWORD *)(a2 + 16);
        v750 = v749 + 4;
        if (v748)
        {
          if (v750 >= *(_QWORD *)v748)
          {
            v751 = malloc_type_realloc(*(void **)(v748 + 16), (v749 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v752 = *(unint64_t **)(a2 + 16);
            v752[2] = (unint64_t)v751;
            *v752 = (v749 + 259) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v751;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v750);
        }
        v768 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 4;
        *(_DWORD *)&v768[v749] = 1347232522;
        v769 = arb::obj_write_dest(a1, (string_t *)a2, (arb *)(v653 + 3), (char *)&v1080, (const char **)&v1079, v747 == 0, 1);
        __s1a = (char *)v769;
        v770 = *v769;
        if (*v769)
        {
          v771 = v769;
          if ((v770 - 33) < 0xFFFFFFE0)
            goto LABEL_777;
          do
          {
LABEL_776:
            v772 = *++v771;
            v770 = v772;
          }
          while ((v772 - 33) > 0xFFFFFFDF);
LABEL_777:
          while (v770 == 35)
          {
            v773 = v771;
            do
            {
              v774 = *++v773;
              v770 = v774;
              if (!v774)
                goto LABEL_1014;
              v775 = *v771;
              v771 = v773;
            }
            while (v775 != 10);
            v771 = v773;
            if ((v770 - 33) >= 0xFFFFFFE0)
              goto LABEL_776;
          }
          if (v770 == 44)
          {
            v949 = v771[1];
            v789 = (char *)(v771 + 1);
            v948 = v949;
            if (v949)
            {
              if ((v948 - 33) < 0xFFFFFFE0)
                goto LABEL_1008;
              do
              {
LABEL_1007:
                v950 = *++v789;
                v948 = v950;
              }
              while ((v950 - 33) > 0xFFFFFFDF);
LABEL_1008:
              while (v948 == 35)
              {
                ++v789;
                do
                {
                  v948 = *v789;
                  if (!*v789)
                    goto LABEL_1015;
                  v951 = *(v789++ - 1);
                }
                while (v951 != 10);
                --v789;
                if ((v948 - 33) >= 0xFFFFFFE0)
                  goto LABEL_1007;
              }
            }
          }
          else
          {
LABEL_1014:
            v789 = 0;
          }
        }
        else
        {
          v789 = 0;
        }
LABEL_1015:
        __s1a = v789;
        v953 = *(_QWORD *)(a2 + 8);
        v952 = *(_QWORD *)(a2 + 16);
        v954 = v953 + 2;
        if (v952)
        {
          if (v954 >= *(_QWORD *)v952)
          {
            v955 = malloc_type_realloc(*(void **)(v952 + 16), (v953 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v956 = *(unint64_t **)(a2 + 16);
            v956[2] = (unint64_t)v955;
            *v956 = (v953 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v955;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v954);
        }
        v957 = 0;
        v958 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v958[v953] = 11564;
        do
        {
          v959 = &(v957++)[(_QWORD)v789];
          v1079 = v957;
        }
        while ((ctype[2 * v959[1]] & 0x40) != 0);
        arb::obj_write_symbol(a1, a2, v789, v789, v957, &v957[(_QWORD)v789]);
        v961 = *(_QWORD *)(a2 + 8);
        v960 = *(_QWORD *)(a2 + 16);
        v962 = v961 + 3;
        if (v960)
        {
          if (v962 >= *(_QWORD *)v960)
          {
            v963 = malloc_type_realloc(*(void **)(v960 + 16), (v961 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v964 = *(unint64_t **)(a2 + 16);
            v964[2] = (unint64_t)v963;
            *v964 = (v961 + 258) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v963;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v962);
        }
        v965 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 3;
        v966 = (char *)&v965[v961];
        v966[2] = 44;
        *(_WORD *)v966 = 30510;
        arb::obj_write_symbol(a1, a2, __s1a, __s1a, v1079, &v1079[(_QWORD)__s1a]);
        v968 = *(_QWORD *)(a2 + 8);
        v967 = *(_QWORD *)(a2 + 16);
        v969 = v968 + 5;
        if (v967)
        {
          if (v969 >= *(_QWORD *)v967)
          {
            v970 = malloc_type_realloc(*(void **)(v967 + 16), (v968 + 260) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v971 = *(unint64_t **)(a2 + 16);
            v971[2] = (unint64_t)v970;
            *v971 = (v968 + 260) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v970;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v969);
        }
        v972 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 5;
        v973 = (char *)&v972[v968];
        v973[4] = 10;
        *(_DWORD *)v973 = 992882732;
        if (v747)
        {
LABEL_1030:
          arb::obj_write_ssat((uint64_t)a1, a2, (arb *)v747, v804);
          v975 = *(_QWORD *)(a2 + 8);
          v974 = *(_QWORD *)(a2 + 16);
          v976 = v975 + 1;
          if (v974)
          {
            if (v976 >= *(_QWORD *)v974)
            {
              v977 = malloc_type_realloc(*(void **)(v974 + 16), (v975 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v978 = *(_QWORD **)(a2 + 16);
              v978[2] = v977;
              *v978 = (v975 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)a2 = v977;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v976);
          }
          v979 = *(string_t *)a2;
          ++*(_QWORD *)(a2 + 8);
          v979[v975] = 10;
        }
LABEL_1035:
        __s1a = v575;
        goto LABEL_1061;
      case 'S':
        v659 = strncmp(v564, "SHORT", 5uLL);
        v660 = v564 + 5;
        if (v659)
          v660 = 0;
        v1080 = v660;
        if (!v659)
          goto LABEL_497;
        goto LABEL_676;
      case 'T':
        v1078[0] = -1;
        v661 = strncmp(v564, "TEMP", 4uLL);
        v662 = v564 + 4;
        if (v661)
          v662 = 0;
        v1080 = v662;
        if (!v661)
          goto LABEL_497;
        if (!arb::obj_texop((uint64_t)a1, (char *)v1078, (arb *)v564, 0, 0))
          goto LABEL_676;
        v664 = *(_QWORD *)(a2 + 8);
        v663 = *(_QWORD *)(a2 + 16);
        v665 = v664 + 2;
        if (v663)
        {
          if (v665 >= *(_QWORD *)v663)
          {
            v666 = malloc_type_realloc(*(void **)(v663 + 16), (v664 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v667 = *(unint64_t **)(a2 + 16);
            v667[2] = (unint64_t)v666;
            *v667 = (v664 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v666;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v665);
        }
        v790 = *(string_t *)a2;
        *(_QWORD *)(a2 + 8) += 2;
        *(_WORD *)&v790[v664] = 8995;
        v791 = v1078[0];
        v793 = *(_QWORD *)(a2 + 8);
        v792 = *(_QWORD *)(a2 + 16);
        v794 = v793 + 20;
        if (v792)
        {
          if (v794 >= *(_QWORD *)v792)
          {
            v795 = malloc_type_realloc(*(void **)(v792 + 16), (v793 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v796 = *(unint64_t **)(a2 + 16);
            v796[2] = (unint64_t)v795;
            *v796 = (v793 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)a2 = v795;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v794);
        }
        v797 = itoa((char *)(*(_QWORD *)a2 + v793), v791);
        v798 = *(_QWORD *)(a2 + 16);
        v799 = *(_QWORD *)(a2 + 8) + v797;
        *(_QWORD *)(a2 + 8) = v799;
        v800 = v799 + 1;
        if (v798)
        {
          if (v800 >= *(_QWORD *)v798)
          {
            v801 = malloc_type_realloc(*(void **)(v798 + 16), (v799 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v802 = *(_QWORD **)(a2 + 16);
            v802[2] = v801;
            *v802 = (v799 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)a2 = v801;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v800);
        }
        v803 = *(string_t *)a2;
        ++*(_QWORD *)(a2 + 8);
        v803[v799] = 10;
        v747 = arb::obj_write_op(a1, a2, v564);
        v1080 = (char *)v747;
        v806 = *(_QWORD *)(a2 + 8);
        v805 = *(_QWORD *)(a2 + 16);
        v807 = v806 + 1;
        if (v805)
        {
          if (v807 >= *(_QWORD *)v805)
          {
            v808 = malloc_type_realloc(*(void **)(v805 + 16), (v806 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
            v809 = *(_QWORD **)(a2 + 16);
            v809[2] = v808;
            *v809 = (v806 & 0xFFFFFFFFFFFFFF00) + 256;
            *(_QWORD *)a2 = v808;
          }
        }
        else
        {
          str_alloc((string_t *)a2, v807);
        }
        v810 = *(string_t *)a2;
        ++*(_QWORD *)(a2 + 8);
        v810[v806] = 10;
        if (!v747)
          goto LABEL_1035;
        goto LABEL_1030;
      case 'U':
        v668 = strncmp(v564, "UINT", 4uLL);
        v669 = v564 + 4;
        if (v668)
          v669 = 0;
        v1080 = v669;
        if (!v668)
          goto LABEL_497;
        goto LABEL_676;
      default:
        goto LABEL_676;
    }
    break;
  }
  while (1)
  {
    v1067 = v644[v1065];
    if ((v1067 - 33) > 0xFFFFFFDF)
    {
      v1068 = &v644[++v1065];
      if (v644[v1065] == 35)
      {
LABEL_1163:
        v1069 = 35;
        while (v1069 == 35)
        {
          ++v1068;
          do
          {
            v1069 = *v1068;
            if (!*v1068)
              goto LABEL_1157;
            v1071 = *(v1068++ - 1);
          }
          while (v1071 != 10);
          --v1068;
          if ((v1069 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              v1070 = *++v1068;
              v1069 = v1070;
            }
            while ((v1070 - 33) > 0xFFFFFFDF);
          }
        }
LABEL_1157:
        v1065 = v1068 - v644;
      }
    }
    else
    {
      *(_BYTE *)(v1066 + v1064++) = v1067;
      v1068 = &v644[++v1065];
      if (v644[v1065] == 35)
        goto LABEL_1163;
    }
    if (v1065 >= v1059)
    {
      v1057 = *(_QWORD *)(a2 + 16);
      v1058 = *(_QWORD *)(a2 + 8) + v1064;
      *(_QWORD *)(a2 + 8) = v1058;
      goto LABEL_1172;
    }
  }
}

uint64_t arb::end(string_t *a1, uint64_t a2, unsigned int *a3, double a4, double a5, uint32x4_t a6)
{
  string_t v9;
  string_t v10;
  unint64_t v11;
  const char *v12;
  char *v13;
  string_t v14;
  string_t v15;
  string_t v16;
  unint64_t v17;
  const char *v18;
  char *v19;
  string_t v20;
  char *v21;
  unsigned int v22;
  string_t v23;
  string_t v24;
  unint64_t v25;
  const char *v26;
  char *v27;
  uint32x2_t v28;
  uint32x2_t v29;
  int8x16_t v30;
  unsigned __int32 v31;
  int8x16_t v32;
  uint32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  uint32x4_t v37;
  int32x4_t v38;
  string_t v39;
  string_t v40;
  unint64_t v41;
  unint64_t v42;
  const char *v43;
  char *v44;
  string_t v45;
  unsigned int v46;
  string_t v47;
  string_t v48;
  unint64_t v49;
  const char *v50;
  char *v51;
  uint32x2_t v52;
  uint32x2_t v53;
  int8x16_t v54;
  unsigned __int32 v55;
  int8x16_t v56;
  uint32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int8x16_t v60;
  uint32x4_t v61;
  int32x4_t v62;
  string_t v63;
  string_t v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  char *v68;
  string_t v69;
  unsigned int v70;
  string_t v71;
  string_t v72;
  unint64_t v73;
  const char *v74;
  char *v75;
  uint32x2_t v76;
  uint32x2_t v77;
  int8x16_t v78;
  unsigned __int32 v79;
  int8x16_t v80;
  uint32x4_t v81;
  int32x4_t v82;
  int32x4_t v83;
  int8x16_t v84;
  uint32x4_t v85;
  int32x4_t v86;
  string_t v87;
  string_t v88;
  unint64_t v89;
  unint64_t v90;
  const char *v91;
  char *v92;
  string_t v93;
  unsigned int v94;
  string_t v95;
  string_t v96;
  unint64_t v97;
  const char *v98;
  char *v99;
  uint32x2_t v100;
  uint32x2_t v101;
  int8x16_t v102;
  unsigned __int32 v103;
  int8x16_t v104;
  uint32x4_t v105;
  int32x4_t v106;
  int32x4_t v107;
  int8x16_t v108;
  uint32x4_t v109;
  int32x4_t v110;
  string_t v111;
  string_t v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  char *v116;
  string_t v117;
  string_t v118;
  string_t v119;
  unint64_t v120;
  const char *v121;
  char *v122;
  const char *v123;
  char *v124;
  string_t v125;
  char *v126;
  unsigned int v127;
  string_t v128;
  string_t v129;
  unint64_t v130;
  const char *v131;
  char *v132;
  string_t v133;
  char *v134;
  uint32x2_t v135;
  uint32x2_t v136;
  int8x16_t v137;
  unsigned __int32 v138;
  int8x16_t v139;
  uint32x4_t v140;
  int32x4_t v141;
  int32x4_t v142;
  int8x16_t v143;
  uint32x4_t v144;
  int32x4_t v145;
  string_t v146;
  string_t v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  char *v151;
  string_t v152;
  unsigned int v153;
  string_t v154;
  string_t v155;
  unint64_t v156;
  const char *v157;
  char *v158;
  uint32x2_t v159;
  uint32x2_t v160;
  int8x16_t v161;
  unsigned __int32 v162;
  int8x16_t v163;
  uint32x4_t v164;
  int32x4_t v165;
  int32x4_t v166;
  int8x16_t v167;
  uint32x4_t v168;
  int32x4_t v169;
  string_t v170;
  string_t v171;
  unint64_t v172;
  unint64_t v173;
  const char *v174;
  char *v175;
  string_t v176;
  unsigned int v177;
  string_t v178;
  string_t v179;
  unint64_t v180;
  const char *v181;
  char *v182;
  uint32x2_t v183;
  uint32x2_t v184;
  int8x16_t v185;
  unsigned __int32 v186;
  int8x16_t v187;
  uint32x4_t v188;
  int32x4_t v189;
  int32x4_t v190;
  int8x16_t v191;
  uint32x4_t v192;
  int32x4_t v193;
  string_t v194;
  string_t v195;
  unint64_t v196;
  unint64_t v197;
  const char *v198;
  char *v199;
  string_t v200;
  unsigned int v201;
  string_t v202;
  string_t v203;
  unint64_t v204;
  const char *v205;
  char *v206;
  uint32x2_t v207;
  uint32x2_t v208;
  int8x16_t v209;
  unsigned __int32 v210;
  int8x16_t v211;
  uint32x4_t v212;
  int32x4_t v213;
  int32x4_t v214;
  int8x16_t v215;
  uint32x4_t v216;
  int32x4_t v217;
  string_t v218;
  string_t v219;
  unint64_t v220;
  unint64_t v221;
  const char *v222;
  char *v223;
  string_t v224;
  unsigned int v225;
  string_t v226;
  string_t v227;
  unint64_t v228;
  const char *v229;
  char *v230;
  char *v231;
  int v232;
  int32x2_t v233;
  int8x8_t v234;
  char v235;
  string_t v236;
  string_t v237;
  unint64_t v238;
  unint64_t v239;
  const char *v240;
  char *v241;
  string_t v242;
  unsigned int v243;
  string_t v244;
  string_t v245;
  unint64_t v246;
  const char *v247;
  char *v248;
  char *v249;
  int v250;
  int32x2_t v251;
  int8x8_t v252;
  char v253;
  string_t v254;
  string_t v255;
  unint64_t v256;
  unint64_t v257;
  const char *v258;
  char *v259;
  string_t v260;
  unsigned int v261;
  string_t v262;
  string_t v263;
  unint64_t v264;
  const char *v265;
  char *v266;
  char *v267;
  int v268;
  int32x2_t v269;
  int8x8_t v270;
  char v271;
  string_t v272;
  string_t v273;
  unint64_t v274;
  unint64_t v275;
  const char *v276;
  char *v277;
  string_t v278;
  unsigned int v279;
  string_t v280;
  string_t v281;
  unint64_t v282;
  const char *v283;
  char *v284;
  char *v285;
  int v286;
  char v287;
  string_t v288;
  string_t v289;
  string_t v290;
  unsigned int v291;
  unint64_t v292;
  size_t v293;
  const char *v294;
  char *v295;
  char *v296;
  int v297;
  char v298;
  string_t v299;
  string_t v300;
  unint64_t v301;
  unint64_t v302;
  const char *v303;
  char *v304;
  string_t v305;
  unsigned int v306;
  string_t v307;
  string_t v308;
  unint64_t v309;
  const char *v310;
  char *v311;
  char *v312;
  int v313;
  char v314;
  string_t v315;
  string_t v316;
  string_t v317;
  unsigned int v318;
  unint64_t v319;
  size_t v320;
  const char *v321;
  char *v322;
  char *v323;
  int v324;
  char v325;
  string_t v326;
  string_t v327;
  unint64_t v328;
  unint64_t v329;
  const char *v330;
  char *v331;
  string_t v332;
  unsigned int v333;
  string_t v334;
  string_t v335;
  unint64_t v336;
  const char *v337;
  char *v338;
  char *v339;
  int v340;
  int32x2_t v341;
  int8x8_t v342;
  char v343;
  string_t v344;
  string_t v345;
  unint64_t v346;
  unint64_t v347;
  const char *v348;
  char *v349;
  string_t v350;
  unsigned int v351;
  string_t v352;
  string_t v353;
  unint64_t v354;
  const char *v355;
  char *v356;
  char *v357;
  int v358;
  int32x2_t v359;
  int8x8_t v360;
  char v361;
  string_t v362;
  string_t v363;
  unint64_t v364;
  unint64_t v365;
  const char *v366;
  char *v367;
  string_t v368;
  unsigned int v369;
  string_t v370;
  string_t v371;
  unint64_t v372;
  const char *v373;
  char *v374;
  char *v375;
  int v376;
  int32x2_t v377;
  int8x8_t v378;
  char v379;
  string_t v380;
  string_t v381;
  unint64_t v382;
  unint64_t v383;
  const char *v384;
  char *v385;
  string_t v386;
  unsigned int v387;
  string_t v388;
  string_t v389;
  unint64_t v390;
  const char *v391;
  char *v392;
  char *v393;
  int v394;
  int32x2_t v395;
  int8x8_t v396;
  double v397;
  char v398;
  string_t v399;
  string_t v400;
  unint64_t v401;
  unint64_t v402;
  const char *v403;
  char *v404;
  string_t v405;
  unsigned int v406;
  string_t v407;
  string_t v408;
  unint64_t v409;
  const char *v410;
  char *v411;
  char *v412;
  int v413;
  char v414;
  string_t v415;
  string_t v416;
  unint64_t v417;
  unint64_t v418;
  const char *v419;
  char *v420;
  string_t v421;
  char v422;
  string_t v423;
  unint64_t v424;
  unint64_t v425;
  const char *v426;
  char *v427;
  char v428;
  string_t v429;
  string_t v430;
  unint64_t v431;
  unint64_t v432;
  const char *v433;
  char *v434;
  string_t v435;
  char v436;
  string_t v437;
  unint64_t v438;
  unint64_t v439;
  const char *v440;
  char *v441;
  char v442;
  string_t v443;
  string_t v444;
  unint64_t v445;
  unint64_t v446;
  const char *v447;
  char *v448;
  string_t v449;
  char v450;
  string_t v451;
  unint64_t v452;
  unint64_t v453;
  const char *v454;
  char *v455;
  char v456;
  string_t v457;
  string_t v458;
  unint64_t v459;
  unint64_t v460;
  const char *v461;
  char *v462;
  string_t v463;

  v10 = a1[1];
  v9 = a1[2];
  v11 = (unint64_t)(v10 + 4);
  if (v9)
  {
    if (v11 >= *(_QWORD *)v9)
    {
      v12 = (const char *)malloc_type_realloc(*((void **)v9 + 2), (unint64_t)(v10 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v13 = (char *)a1[2];
      *((_QWORD *)v13 + 2) = v12;
      *(_QWORD *)v13 = (unint64_t)(v10 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v12;
    }
  }
  else
  {
    str_alloc(a1, v11);
  }
  v14 = *a1;
  a1[1] += 4;
  *(_DWORD *)&v10[(_QWORD)v14] = 172248645;
  v16 = a1[1];
  v15 = a1[2];
  v17 = (unint64_t)(v16 + 6);
  if (v15)
  {
    if (v17 >= *(_QWORD *)v15)
    {
      v18 = (const char *)malloc_type_realloc(*((void **)v15 + 2), (unint64_t)(v16 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v19 = (char *)a1[2];
      *((_QWORD *)v19 + 2) = v18;
      *(_QWORD *)v19 = (unint64_t)(v16 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v18;
    }
  }
  else
  {
    str_alloc(a1, v17);
  }
  v20 = *a1;
  a1[1] += 6;
  v21 = (char *)&v16[(_QWORD)v20];
  *((_WORD *)v21 + 2) = 15669;
  *(_DWORD *)v21 = 1145905955;
  v22 = *a3;
  v24 = a1[1];
  v23 = a1[2];
  v25 = (unint64_t)(v24 + 8);
  if (v23)
  {
    if (v25 >= *(_QWORD *)v23)
    {
      v26 = (const char *)malloc_type_realloc(*((void **)v23 + 2), (unint64_t)(v24 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v27 = (char *)a1[2];
      *((_QWORD *)v27 + 2) = v26;
      *(_QWORD *)v27 = (unint64_t)(v24 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v26;
    }
  }
  else
  {
    str_alloc(a1, v25);
  }
  v28 = (uint32x2_t)vdup_n_s32(v22);
  v29 = vshl_u32(v28, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v30.i8 = vshl_u32(v28, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  a6.i32[0] = v22;
  v31 = vshrq_n_u32(a6, 0x1CuLL).u32[0];
  a6.i32[1] = HIBYTE(v22);
  a6.u64[1] = (unint64_t)v29;
  v30.i32[2] = v22 >> 4;
  v30.i32[3] = v22;
  v32.i64[0] = 0xF0000000FLL;
  v32.i64[1] = 0xF0000000FLL;
  v33 = (uint32x4_t)vandq_s8((int8x16_t)a6, v32);
  v34 = (int32x4_t)vandq_s8(v30, v32);
  v35 = (int32x4_t)v33;
  v35.i32[0] = v31;
  v33.i32[0] = v22;
  v36 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v33);
  v37.i64[0] = 0xA0000000ALL;
  v37.i64[1] = 0xA0000000ALL;
  v38.i64[0] = 0x5700000057;
  v38.i64[1] = 0x5700000057;
  *(int8x8_t *)&v24[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v36, (int8x16_t)(*(_OWORD *)&v35 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v35, v38)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v37, (uint32x4_t)v34), (int8x16_t)(*(_OWORD *)&v34 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v34, v38))));
  v40 = a1[1];
  v39 = a1[2];
  v41 = (unint64_t)(v40 + 8);
  a1[1] = v40 + 8;
  v42 = (unint64_t)(v40 + 9);
  if (v39)
  {
    if (v42 >= *(_QWORD *)v39)
    {
      v43 = (const char *)malloc_type_realloc(*((void **)v39 + 2), (v41 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v44 = (char *)a1[2];
      *((_QWORD *)v44 + 2) = v43;
      *(_QWORD *)v44 = (v41 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v43;
    }
  }
  else
  {
    str_alloc(a1, v42);
  }
  v45 = *a1;
  ++a1[1];
  v45[v41] = 58;
  v46 = a3[1];
  v48 = a1[1];
  v47 = a1[2];
  v49 = (unint64_t)(v48 + 8);
  if (v47)
  {
    if (v49 >= *(_QWORD *)v47)
    {
      v50 = (const char *)malloc_type_realloc(*((void **)v47 + 2), (unint64_t)(v48 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v51 = (char *)a1[2];
      *((_QWORD *)v51 + 2) = v50;
      *(_QWORD *)v51 = (unint64_t)(v48 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v50;
    }
  }
  else
  {
    str_alloc(a1, v49);
  }
  v52 = (uint32x2_t)vdup_n_s32(v46);
  v53 = vshl_u32(v52, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v54.i8 = vshl_u32(v52, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v36.i32[0] = v46;
  v55 = vshrq_n_u32((uint32x4_t)v36, 0x1CuLL).u32[0];
  v36.i32[1] = HIBYTE(v46);
  v36.u64[1] = (unint64_t)v53;
  v54.i32[2] = v46 >> 4;
  v54.i32[3] = v46;
  v56.i64[0] = 0xF0000000FLL;
  v56.i64[1] = 0xF0000000FLL;
  v57 = (uint32x4_t)vandq_s8(v36, v56);
  v58 = (int32x4_t)vandq_s8(v54, v56);
  v59 = (int32x4_t)v57;
  v59.i32[0] = v55;
  v57.i32[0] = v46;
  v60 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v57);
  v61.i64[0] = 0xA0000000ALL;
  v61.i64[1] = 0xA0000000ALL;
  v62.i64[0] = 0x5700000057;
  v62.i64[1] = 0x5700000057;
  *(int8x8_t *)&v48[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v60, (int8x16_t)(*(_OWORD *)&v59 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v59, v62)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v61, (uint32x4_t)v58), (int8x16_t)(*(_OWORD *)&v58 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v58, v62))));
  v64 = a1[1];
  v63 = a1[2];
  v65 = (unint64_t)(v64 + 8);
  a1[1] = v64 + 8;
  v66 = (unint64_t)(v64 + 9);
  if (v63)
  {
    if (v66 >= *(_QWORD *)v63)
    {
      v67 = (const char *)malloc_type_realloc(*((void **)v63 + 2), (v65 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v68 = (char *)a1[2];
      *((_QWORD *)v68 + 2) = v67;
      *(_QWORD *)v68 = (v65 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v67;
    }
  }
  else
  {
    str_alloc(a1, v66);
  }
  v69 = *a1;
  ++a1[1];
  v69[v65] = 58;
  v70 = a3[2];
  v72 = a1[1];
  v71 = a1[2];
  v73 = (unint64_t)(v72 + 8);
  if (v71)
  {
    if (v73 >= *(_QWORD *)v71)
    {
      v74 = (const char *)malloc_type_realloc(*((void **)v71 + 2), (unint64_t)(v72 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v75 = (char *)a1[2];
      *((_QWORD *)v75 + 2) = v74;
      *(_QWORD *)v75 = (unint64_t)(v72 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v74;
    }
  }
  else
  {
    str_alloc(a1, v73);
  }
  v76 = (uint32x2_t)vdup_n_s32(v70);
  v77 = vshl_u32(v76, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v78.i8 = vshl_u32(v76, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v60.i32[0] = v70;
  v79 = vshrq_n_u32((uint32x4_t)v60, 0x1CuLL).u32[0];
  v60.i32[1] = HIBYTE(v70);
  v60.u64[1] = (unint64_t)v77;
  v78.i32[2] = v70 >> 4;
  v78.i32[3] = v70;
  v80.i64[0] = 0xF0000000FLL;
  v80.i64[1] = 0xF0000000FLL;
  v81 = (uint32x4_t)vandq_s8(v60, v80);
  v82 = (int32x4_t)vandq_s8(v78, v80);
  v83 = (int32x4_t)v81;
  v83.i32[0] = v79;
  v81.i32[0] = v70;
  v84 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v81);
  v85.i64[0] = 0xA0000000ALL;
  v85.i64[1] = 0xA0000000ALL;
  v86.i64[0] = 0x5700000057;
  v86.i64[1] = 0x5700000057;
  *(int8x8_t *)&v72[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v84, (int8x16_t)(*(_OWORD *)&v83 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v83, v86)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v85, (uint32x4_t)v82), (int8x16_t)(*(_OWORD *)&v82 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v82, v86))));
  v88 = a1[1];
  v87 = a1[2];
  v89 = (unint64_t)(v88 + 8);
  a1[1] = v88 + 8;
  v90 = (unint64_t)(v88 + 9);
  if (v87)
  {
    if (v90 >= *(_QWORD *)v87)
    {
      v91 = (const char *)malloc_type_realloc(*((void **)v87 + 2), (v89 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v92 = (char *)a1[2];
      *((_QWORD *)v92 + 2) = v91;
      *(_QWORD *)v92 = (v89 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v91;
    }
  }
  else
  {
    str_alloc(a1, v90);
  }
  v93 = *a1;
  ++a1[1];
  v93[v89] = 58;
  v94 = a3[3];
  v96 = a1[1];
  v95 = a1[2];
  v97 = (unint64_t)(v96 + 8);
  if (v95)
  {
    if (v97 >= *(_QWORD *)v95)
    {
      v98 = (const char *)malloc_type_realloc(*((void **)v95 + 2), (unint64_t)(v96 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v99 = (char *)a1[2];
      *((_QWORD *)v99 + 2) = v98;
      *(_QWORD *)v99 = (unint64_t)(v96 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v98;
    }
  }
  else
  {
    str_alloc(a1, v97);
  }
  v100 = (uint32x2_t)vdup_n_s32(v94);
  v101 = vshl_u32(v100, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v102.i8 = vshl_u32(v100, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v84.i32[0] = v94;
  v103 = vshrq_n_u32((uint32x4_t)v84, 0x1CuLL).u32[0];
  v84.i32[1] = HIBYTE(v94);
  v84.u64[1] = (unint64_t)v101;
  v102.i32[2] = v94 >> 4;
  v102.i32[3] = v94;
  v104.i64[0] = 0xF0000000FLL;
  v104.i64[1] = 0xF0000000FLL;
  v105 = (uint32x4_t)vandq_s8(v84, v104);
  v106 = (int32x4_t)vandq_s8(v102, v104);
  v107 = (int32x4_t)v105;
  v107.i32[0] = v103;
  v105.i32[0] = v94;
  v108 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v105);
  v109.i64[0] = 0xA0000000ALL;
  v109.i64[1] = 0xA0000000ALL;
  v110.i64[0] = 0x5700000057;
  v110.i64[1] = 0x5700000057;
  *(int8x8_t *)&v96[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v108, (int8x16_t)(*(_OWORD *)&v107 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v107, v110)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v109, (uint32x4_t)v106), (int8x16_t)(*(_OWORD *)&v106 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v106, v110))));
  v112 = a1[1];
  v111 = a1[2];
  v113 = (unint64_t)(v112 + 8);
  a1[1] = v112 + 8;
  v114 = (unint64_t)(v112 + 9);
  if (v111)
  {
    if (v114 >= *(_QWORD *)v111)
    {
      v115 = (const char *)malloc_type_realloc(*((void **)v111 + 2), (v113 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v116 = (char *)a1[2];
      *((_QWORD *)v116 + 2) = v115;
      *(_QWORD *)v116 = (v113 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v115;
    }
  }
  else
  {
    str_alloc(a1, v114);
  }
  v117 = *a1;
  ++a1[1];
  v117[v113] = 10;
  v119 = a1[1];
  v118 = a1[2];
  v120 = (unint64_t)(v119 + 6);
  if ((*(_DWORD *)a2 & 0xFE00u) <= 0x5FF)
  {
    if (v118)
    {
      if (v120 >= *(_QWORD *)v118)
      {
        v123 = (const char *)malloc_type_realloc(*((void **)v118 + 2), (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v124 = (char *)a1[2];
        *((_QWORD *)v124 + 2) = v123;
        *(_QWORD *)v124 = (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00;
        *a1 = v123;
      }
    }
    else
    {
      str_alloc(a1, v120);
    }
    v133 = *a1;
    a1[1] += 6;
    v134 = (char *)&v119[(_QWORD)v133];
    *((_WORD *)v134 + 2) = 15687;
    *(_DWORD *)v134 = 1230185251;
    v127 = *(_DWORD *)(a2 + 4);
    v129 = a1[1];
    v128 = a1[2];
    v130 = (unint64_t)(v129 + 8);
    if (v128)
      goto LABEL_50;
LABEL_54:
    str_alloc(a1, v130);
    goto LABEL_55;
  }
  if (v118)
  {
    if (v120 >= *(_QWORD *)v118)
    {
      v121 = (const char *)malloc_type_realloc(*((void **)v118 + 2), (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v122 = (char *)a1[2];
      *((_QWORD *)v122 + 2) = v121;
      *(_QWORD *)v122 = (unint64_t)(v119 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v121;
    }
  }
  else
  {
    str_alloc(a1, v120);
  }
  v125 = *a1;
  a1[1] += 6;
  v126 = (char *)&v119[(_QWORD)v125];
  *((_WORD *)v126 + 2) = 15687;
  *(_DWORD *)v126 = 1230188335;
  v127 = *(_DWORD *)(a2 + 4);
  v129 = a1[1];
  v128 = a1[2];
  v130 = (unint64_t)(v129 + 8);
  if (!v128)
    goto LABEL_54;
LABEL_50:
  if (v130 >= *(_QWORD *)v128)
  {
    v131 = (const char *)malloc_type_realloc(*((void **)v128 + 2), (unint64_t)(v129 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
    v132 = (char *)a1[2];
    *((_QWORD *)v132 + 2) = v131;
    *(_QWORD *)v132 = (unint64_t)(v129 + 263) & 0xFFFFFFFFFFFFFF00;
    *a1 = v131;
  }
LABEL_55:
  v135 = (uint32x2_t)vdup_n_s32(v127);
  v136 = vshl_u32(v135, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v137.i8 = vshl_u32(v135, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v108.i32[0] = v127;
  v138 = vshrq_n_u32((uint32x4_t)v108, 0x1CuLL).u32[0];
  v108.i32[1] = HIBYTE(v127);
  v108.u64[1] = (unint64_t)v136;
  v137.i32[2] = v127 >> 4;
  v137.i32[3] = v127;
  v139.i64[0] = 0xF0000000FLL;
  v139.i64[1] = 0xF0000000FLL;
  v140 = (uint32x4_t)vandq_s8(v108, v139);
  v141 = (int32x4_t)vandq_s8(v137, v139);
  v142 = (int32x4_t)v140;
  v142.i32[0] = v138;
  v140.i32[0] = v127;
  v143 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v140);
  v144.i64[0] = 0xA0000000ALL;
  v144.i64[1] = 0xA0000000ALL;
  v145.i64[0] = 0x5700000057;
  v145.i64[1] = 0x5700000057;
  *(int8x8_t *)&v129[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v143, (int8x16_t)(*(_OWORD *)&v142 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v142, v145)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v144, (uint32x4_t)v141), (int8x16_t)(*(_OWORD *)&v141 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v141, v145))));
  v147 = a1[1];
  v146 = a1[2];
  v148 = (unint64_t)(v147 + 8);
  a1[1] = v147 + 8;
  v149 = (unint64_t)(v147 + 9);
  if (v146)
  {
    if (v149 >= *(_QWORD *)v146)
    {
      v150 = (const char *)malloc_type_realloc(*((void **)v146 + 2), (v148 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v151 = (char *)a1[2];
      *((_QWORD *)v151 + 2) = v150;
      *(_QWORD *)v151 = (v148 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v150;
    }
  }
  else
  {
    str_alloc(a1, v149);
  }
  v152 = *a1;
  ++a1[1];
  v152[v148] = 58;
  v153 = *(_DWORD *)(a2 + 8);
  v155 = a1[1];
  v154 = a1[2];
  v156 = (unint64_t)(v155 + 8);
  if (v154)
  {
    if (v156 >= *(_QWORD *)v154)
    {
      v157 = (const char *)malloc_type_realloc(*((void **)v154 + 2), (unint64_t)(v155 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v158 = (char *)a1[2];
      *((_QWORD *)v158 + 2) = v157;
      *(_QWORD *)v158 = (unint64_t)(v155 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v157;
    }
  }
  else
  {
    str_alloc(a1, v156);
  }
  v159 = (uint32x2_t)vdup_n_s32(v153);
  v160 = vshl_u32(v159, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v161.i8 = vshl_u32(v159, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v143.i32[0] = v153;
  v162 = vshrq_n_u32((uint32x4_t)v143, 0x1CuLL).u32[0];
  v143.i32[1] = HIBYTE(v153);
  v143.u64[1] = (unint64_t)v160;
  v161.i32[2] = v153 >> 4;
  v161.i32[3] = v153;
  v163.i64[0] = 0xF0000000FLL;
  v163.i64[1] = 0xF0000000FLL;
  v164 = (uint32x4_t)vandq_s8(v143, v163);
  v165 = (int32x4_t)vandq_s8(v161, v163);
  v166 = (int32x4_t)v164;
  v166.i32[0] = v162;
  v164.i32[0] = v153;
  v167 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v164);
  v168.i64[0] = 0xA0000000ALL;
  v168.i64[1] = 0xA0000000ALL;
  v169.i64[0] = 0x5700000057;
  v169.i64[1] = 0x5700000057;
  *(int8x8_t *)&v155[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v167, (int8x16_t)(*(_OWORD *)&v166 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v166, v169)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v168, (uint32x4_t)v165), (int8x16_t)(*(_OWORD *)&v165 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v165, v169))));
  v171 = a1[1];
  v170 = a1[2];
  v172 = (unint64_t)(v171 + 8);
  a1[1] = v171 + 8;
  v173 = (unint64_t)(v171 + 9);
  if (v170)
  {
    if (v173 >= *(_QWORD *)v170)
    {
      v174 = (const char *)malloc_type_realloc(*((void **)v170 + 2), (v172 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v175 = (char *)a1[2];
      *((_QWORD *)v175 + 2) = v174;
      *(_QWORD *)v175 = (v172 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v174;
    }
  }
  else
  {
    str_alloc(a1, v173);
  }
  v176 = *a1;
  ++a1[1];
  v176[v172] = 58;
  v177 = *(_DWORD *)(a2 + 12);
  v179 = a1[1];
  v178 = a1[2];
  v180 = (unint64_t)(v179 + 8);
  if (v178)
  {
    if (v180 >= *(_QWORD *)v178)
    {
      v181 = (const char *)malloc_type_realloc(*((void **)v178 + 2), (unint64_t)(v179 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v182 = (char *)a1[2];
      *((_QWORD *)v182 + 2) = v181;
      *(_QWORD *)v182 = (unint64_t)(v179 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v181;
    }
  }
  else
  {
    str_alloc(a1, v180);
  }
  v183 = (uint32x2_t)vdup_n_s32(v177);
  v184 = vshl_u32(v183, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v185.i8 = vshl_u32(v183, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v167.i32[0] = v177;
  v186 = vshrq_n_u32((uint32x4_t)v167, 0x1CuLL).u32[0];
  v167.i32[1] = HIBYTE(v177);
  v167.u64[1] = (unint64_t)v184;
  v185.i32[2] = v177 >> 4;
  v185.i32[3] = v177;
  v187.i64[0] = 0xF0000000FLL;
  v187.i64[1] = 0xF0000000FLL;
  v188 = (uint32x4_t)vandq_s8(v167, v187);
  v189 = (int32x4_t)vandq_s8(v185, v187);
  v190 = (int32x4_t)v188;
  v190.i32[0] = v186;
  v188.i32[0] = v177;
  v191 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v188);
  v192.i64[0] = 0xA0000000ALL;
  v192.i64[1] = 0xA0000000ALL;
  v193.i64[0] = 0x5700000057;
  v193.i64[1] = 0x5700000057;
  *(int8x8_t *)&v179[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v191, (int8x16_t)(*(_OWORD *)&v190 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v190, v193)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v192, (uint32x4_t)v189), (int8x16_t)(*(_OWORD *)&v189 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v189, v193))));
  v195 = a1[1];
  v194 = a1[2];
  v196 = (unint64_t)(v195 + 8);
  a1[1] = v195 + 8;
  v197 = (unint64_t)(v195 + 9);
  if (v194)
  {
    if (v197 >= *(_QWORD *)v194)
    {
      v198 = (const char *)malloc_type_realloc(*((void **)v194 + 2), (v196 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v199 = (char *)a1[2];
      *((_QWORD *)v199 + 2) = v198;
      *(_QWORD *)v199 = (v196 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v198;
    }
  }
  else
  {
    str_alloc(a1, v197);
  }
  v200 = *a1;
  ++a1[1];
  v200[v196] = 58;
  v201 = *(_DWORD *)(a2 + 16);
  v203 = a1[1];
  v202 = a1[2];
  v204 = (unint64_t)(v203 + 8);
  if (v202)
  {
    if (v204 >= *(_QWORD *)v202)
    {
      v205 = (const char *)malloc_type_realloc(*((void **)v202 + 2), (unint64_t)(v203 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v206 = (char *)a1[2];
      *((_QWORD *)v206 + 2) = v205;
      *(_QWORD *)v206 = (unint64_t)(v203 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v205;
    }
  }
  else
  {
    str_alloc(a1, v204);
  }
  v207 = (uint32x2_t)vdup_n_s32(v201);
  v208 = vshl_u32(v207, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v209.i8 = vshl_u32(v207, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v191.i32[0] = v201;
  v210 = vshrq_n_u32((uint32x4_t)v191, 0x1CuLL).u32[0];
  v191.i32[1] = HIBYTE(v201);
  v191.u64[1] = (unint64_t)v208;
  v209.i32[2] = v201 >> 4;
  v209.i32[3] = v201;
  v211.i64[0] = 0xF0000000FLL;
  v211.i64[1] = 0xF0000000FLL;
  v212 = (uint32x4_t)vandq_s8(v191, v211);
  v213 = (int32x4_t)vandq_s8(v209, v211);
  v214 = (int32x4_t)v212;
  v214.i32[0] = v210;
  v212.i32[0] = v201;
  v215 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v212);
  v216.i64[0] = 0xA0000000ALL;
  v216.i64[1] = 0xA0000000ALL;
  v217.i64[0] = 0x5700000057;
  v217.i64[1] = 0x5700000057;
  *(int8x8_t *)&v203[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v215, (int8x16_t)(*(_OWORD *)&v214 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v214, v217)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v216, (uint32x4_t)v213), (int8x16_t)(*(_OWORD *)&v213 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v213, v217))));
  v219 = a1[1];
  v218 = a1[2];
  v220 = (unint64_t)(v219 + 8);
  a1[1] = v219 + 8;
  v221 = (unint64_t)(v219 + 9);
  if (v218)
  {
    if (v221 >= *(_QWORD *)v218)
    {
      v222 = (const char *)malloc_type_realloc(*((void **)v218 + 2), (v220 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v223 = (char *)a1[2];
      *((_QWORD *)v223 + 2) = v222;
      *(_QWORD *)v223 = (v220 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v222;
    }
  }
  else
  {
    str_alloc(a1, v221);
  }
  v224 = *a1;
  ++a1[1];
  v224[v220] = 58;
  v225 = *(unsigned __int16 *)(a2 + 20);
  v227 = a1[1];
  v226 = a1[2];
  v228 = (unint64_t)(v227 + 4);
  if (v226)
  {
    if (v228 >= *(_QWORD *)v226)
    {
      v229 = (const char *)malloc_type_realloc(*((void **)v226 + 2), (unint64_t)(v227 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v230 = (char *)a1[2];
      *((_QWORD *)v230 + 2) = v229;
      *(_QWORD *)v230 = (unint64_t)(v227 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v229;
    }
  }
  else
  {
    str_alloc(a1, v228);
  }
  v231 = (char *)&v227[(_QWORD)*a1];
  v232 = (v225 >> 12) + 87;
  if (v225 < 0xA000)
    LOBYTE(v232) = (v225 >> 12) | 0x30;
  *v231 = v232;
  v233 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v225), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v234 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v233), (int8x8_t)(*(_QWORD *)&v233 | 0x3000000030), (int8x8_t)vadd_s32(v233, (int32x2_t)0x5700000057));
  v231[2] = v234.i8[4];
  v231[1] = v234.i8[0];
  if ((v225 & 0xF) >= 0xA)
    v235 = (v225 & 0xF) + 87;
  else
    v235 = v225 & 0xF | 0x30;
  v231[3] = v235;
  v237 = a1[1];
  v236 = a1[2];
  v238 = (unint64_t)(v237 + 4);
  a1[1] = v237 + 4;
  v239 = (unint64_t)(v237 + 5);
  if (v236)
  {
    if (v239 >= *(_QWORD *)v236)
    {
      v240 = (const char *)malloc_type_realloc(*((void **)v236 + 2), (v238 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v241 = (char *)a1[2];
      *((_QWORD *)v241 + 2) = v240;
      *(_QWORD *)v241 = (v238 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v240;
    }
  }
  else
  {
    str_alloc(a1, v239);
  }
  v242 = *a1;
  ++a1[1];
  v242[v238] = 58;
  v243 = *(unsigned __int16 *)(a2 + 22);
  v245 = a1[1];
  v244 = a1[2];
  v246 = (unint64_t)(v245 + 4);
  if (v244)
  {
    if (v246 >= *(_QWORD *)v244)
    {
      v247 = (const char *)malloc_type_realloc(*((void **)v244 + 2), (unint64_t)(v245 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v248 = (char *)a1[2];
      *((_QWORD *)v248 + 2) = v247;
      *(_QWORD *)v248 = (unint64_t)(v245 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v247;
    }
  }
  else
  {
    str_alloc(a1, v246);
  }
  v249 = (char *)&v245[(_QWORD)*a1];
  v250 = (v243 >> 12) + 87;
  if (v243 < 0xA000)
    LOBYTE(v250) = (v243 >> 12) | 0x30;
  *v249 = v250;
  v251 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v243), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v252 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v251), (int8x8_t)(*(_QWORD *)&v251 | 0x3000000030), (int8x8_t)vadd_s32(v251, (int32x2_t)0x5700000057));
  v249[2] = v252.i8[4];
  v249[1] = v252.i8[0];
  if ((v243 & 0xF) >= 0xA)
    v253 = (v243 & 0xF) + 87;
  else
    v253 = v243 & 0xF | 0x30;
  v249[3] = v253;
  v255 = a1[1];
  v254 = a1[2];
  v256 = (unint64_t)(v255 + 4);
  a1[1] = v255 + 4;
  v257 = (unint64_t)(v255 + 5);
  if (v254)
  {
    if (v257 >= *(_QWORD *)v254)
    {
      v258 = (const char *)malloc_type_realloc(*((void **)v254 + 2), (v256 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v259 = (char *)a1[2];
      *((_QWORD *)v259 + 2) = v258;
      *(_QWORD *)v259 = (v256 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v258;
    }
  }
  else
  {
    str_alloc(a1, v257);
  }
  v260 = *a1;
  ++a1[1];
  v260[v256] = 58;
  v261 = *(unsigned __int16 *)(a2 + 24);
  v263 = a1[1];
  v262 = a1[2];
  v264 = (unint64_t)(v263 + 4);
  if (v262)
  {
    if (v264 >= *(_QWORD *)v262)
    {
      v265 = (const char *)malloc_type_realloc(*((void **)v262 + 2), (unint64_t)(v263 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v266 = (char *)a1[2];
      *((_QWORD *)v266 + 2) = v265;
      *(_QWORD *)v266 = (unint64_t)(v263 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v265;
    }
  }
  else
  {
    str_alloc(a1, v264);
  }
  v267 = (char *)&v263[(_QWORD)*a1];
  v268 = (v261 >> 12) + 87;
  if (v261 < 0xA000)
    LOBYTE(v268) = (v261 >> 12) | 0x30;
  *v267 = v268;
  v269 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v261), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v270 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v269), (int8x8_t)(*(_QWORD *)&v269 | 0x3000000030), (int8x8_t)vadd_s32(v269, (int32x2_t)0x5700000057));
  v267[2] = v270.i8[4];
  v267[1] = v270.i8[0];
  if ((v261 & 0xF) >= 0xA)
    v271 = (v261 & 0xF) + 87;
  else
    v271 = v261 & 0xF | 0x30;
  v267[3] = v271;
  v273 = a1[1];
  v272 = a1[2];
  v274 = (unint64_t)(v273 + 4);
  a1[1] = v273 + 4;
  v275 = (unint64_t)(v273 + 5);
  if (v272)
  {
    if (v275 >= *(_QWORD *)v272)
    {
      v276 = (const char *)malloc_type_realloc(*((void **)v272 + 2), (v274 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v277 = (char *)a1[2];
      *((_QWORD *)v277 + 2) = v276;
      *(_QWORD *)v277 = (v274 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v276;
    }
  }
  else
  {
    str_alloc(a1, v275);
  }
  v278 = *a1;
  ++a1[1];
  v278[v274] = 58;
  v279 = *(unsigned __int8 *)(a2 + 26);
  v281 = a1[1];
  v280 = a1[2];
  v282 = (unint64_t)(v281 + 2);
  if (v280)
  {
    if (v282 >= *(_QWORD *)v280)
    {
      v283 = (const char *)malloc_type_realloc(*((void **)v280 + 2), (unint64_t)(v281 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v284 = (char *)a1[2];
      *((_QWORD *)v284 + 2) = v283;
      *(_QWORD *)v284 = (unint64_t)(v281 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v283;
    }
  }
  else
  {
    str_alloc(a1, v282);
  }
  v285 = (char *)&v281[(_QWORD)*a1];
  v286 = (v279 >> 4) + 87;
  if (v279 < 0xA0)
    LOBYTE(v286) = (v279 >> 4) | 0x30;
  *v285 = v286;
  if ((v279 & 0xF) >= 0xA)
    v287 = (v279 & 0xF) + 87;
  else
    v287 = v279 & 0xF | 0x30;
  v285[1] = v287;
  v288 = a1[1];
  v289 = a1[2];
  v290 = v288 + 2;
  a1[1] = v288 + 2;
  v291 = *(unsigned __int8 *)(a2 + 27);
  v292 = (unint64_t)(v288 + 4);
  if (v289)
  {
    if (v292 >= *(_QWORD *)v289)
    {
      v293 = (unint64_t)(v288 + 259) & 0xFFFFFFFFFFFFFF00;
      v294 = (const char *)malloc_type_realloc(*((void **)v289 + 2), v293, 0xCCCD1039uLL);
      v295 = (char *)a1[2];
      *((_QWORD *)v295 + 2) = v294;
      *(_QWORD *)v295 = v293;
      *a1 = v294;
    }
  }
  else
  {
    str_alloc(a1, v292);
  }
  v296 = (char *)&v290[(_QWORD)*a1];
  v297 = (v291 >> 4) + 87;
  if (v291 < 0xA0)
    LOBYTE(v297) = (v291 >> 4) | 0x30;
  *v296 = v297;
  if ((v291 & 0xF) >= 0xA)
    v298 = (v291 & 0xF) + 87;
  else
    v298 = v291 & 0xF | 0x30;
  v296[1] = v298;
  v300 = a1[1];
  v299 = a1[2];
  v301 = (unint64_t)(v300 + 2);
  a1[1] = v300 + 2;
  v302 = (unint64_t)(v300 + 3);
  if (v299)
  {
    if (v302 >= *(_QWORD *)v299)
    {
      v303 = (const char *)malloc_type_realloc(*((void **)v299 + 2), (v301 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v304 = (char *)a1[2];
      *((_QWORD *)v304 + 2) = v303;
      *(_QWORD *)v304 = (v301 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v303;
    }
  }
  else
  {
    str_alloc(a1, v302);
  }
  v305 = *a1;
  ++a1[1];
  v305[v301] = 58;
  v306 = *(unsigned __int8 *)(a2 + 28);
  v308 = a1[1];
  v307 = a1[2];
  v309 = (unint64_t)(v308 + 2);
  if (v307)
  {
    if (v309 >= *(_QWORD *)v307)
    {
      v310 = (const char *)malloc_type_realloc(*((void **)v307 + 2), (unint64_t)(v308 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v311 = (char *)a1[2];
      *((_QWORD *)v311 + 2) = v310;
      *(_QWORD *)v311 = (unint64_t)(v308 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v310;
    }
  }
  else
  {
    str_alloc(a1, v309);
  }
  v312 = (char *)&v308[(_QWORD)*a1];
  v313 = (v306 >> 4) + 87;
  if (v306 < 0xA0)
    LOBYTE(v313) = (v306 >> 4) | 0x30;
  *v312 = v313;
  if ((v306 & 0xF) >= 0xA)
    v314 = (v306 & 0xF) + 87;
  else
    v314 = v306 & 0xF | 0x30;
  v312[1] = v314;
  v315 = a1[1];
  v316 = a1[2];
  v317 = v315 + 2;
  a1[1] = v315 + 2;
  v318 = *(unsigned __int8 *)(a2 + 29);
  v319 = (unint64_t)(v315 + 4);
  if (v316)
  {
    if (v319 >= *(_QWORD *)v316)
    {
      v320 = (unint64_t)(v315 + 259) & 0xFFFFFFFFFFFFFF00;
      v321 = (const char *)malloc_type_realloc(*((void **)v316 + 2), v320, 0xCCCD1039uLL);
      v322 = (char *)a1[2];
      *((_QWORD *)v322 + 2) = v321;
      *(_QWORD *)v322 = v320;
      *a1 = v321;
    }
  }
  else
  {
    str_alloc(a1, v319);
  }
  v323 = (char *)&v317[(_QWORD)*a1];
  v324 = (v318 >> 4) + 87;
  if (v318 < 0xA0)
    LOBYTE(v324) = (v318 >> 4) | 0x30;
  *v323 = v324;
  if ((v318 & 0xF) >= 0xA)
    v325 = (v318 & 0xF) + 87;
  else
    v325 = v318 & 0xF | 0x30;
  v323[1] = v325;
  v327 = a1[1];
  v326 = a1[2];
  v328 = (unint64_t)(v327 + 2);
  a1[1] = v327 + 2;
  v329 = (unint64_t)(v327 + 3);
  if (v326)
  {
    if (v329 >= *(_QWORD *)v326)
    {
      v330 = (const char *)malloc_type_realloc(*((void **)v326 + 2), (v328 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v331 = (char *)a1[2];
      *((_QWORD *)v331 + 2) = v330;
      *(_QWORD *)v331 = (v328 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v330;
    }
  }
  else
  {
    str_alloc(a1, v329);
  }
  v332 = *a1;
  ++a1[1];
  v332[v328] = 58;
  v333 = *(unsigned __int16 *)(a2 + 30);
  v335 = a1[1];
  v334 = a1[2];
  v336 = (unint64_t)(v335 + 4);
  if (v334)
  {
    if (v336 >= *(_QWORD *)v334)
    {
      v337 = (const char *)malloc_type_realloc(*((void **)v334 + 2), (unint64_t)(v335 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v338 = (char *)a1[2];
      *((_QWORD *)v338 + 2) = v337;
      *(_QWORD *)v338 = (unint64_t)(v335 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v337;
    }
  }
  else
  {
    str_alloc(a1, v336);
  }
  v339 = (char *)&v335[(_QWORD)*a1];
  v340 = (v333 >> 12) + 87;
  if (v333 < 0xA000)
    LOBYTE(v340) = (v333 >> 12) | 0x30;
  *v339 = v340;
  v341 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v333), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v342 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v341), (int8x8_t)(*(_QWORD *)&v341 | 0x3000000030), (int8x8_t)vadd_s32(v341, (int32x2_t)0x5700000057));
  v339[2] = v342.i8[4];
  v339[1] = v342.i8[0];
  if ((v333 & 0xF) >= 0xA)
    v343 = (v333 & 0xF) + 87;
  else
    v343 = v333 & 0xF | 0x30;
  v339[3] = v343;
  v345 = a1[1];
  v344 = a1[2];
  v346 = (unint64_t)(v345 + 4);
  a1[1] = v345 + 4;
  v347 = (unint64_t)(v345 + 5);
  if (v344)
  {
    if (v347 >= *(_QWORD *)v344)
    {
      v348 = (const char *)malloc_type_realloc(*((void **)v344 + 2), (v346 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v349 = (char *)a1[2];
      *((_QWORD *)v349 + 2) = v348;
      *(_QWORD *)v349 = (v346 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v348;
    }
  }
  else
  {
    str_alloc(a1, v347);
  }
  v350 = *a1;
  ++a1[1];
  v350[v346] = 58;
  v351 = *(unsigned __int16 *)(a2 + 32);
  v353 = a1[1];
  v352 = a1[2];
  v354 = (unint64_t)(v353 + 4);
  if (v352)
  {
    if (v354 >= *(_QWORD *)v352)
    {
      v355 = (const char *)malloc_type_realloc(*((void **)v352 + 2), (unint64_t)(v353 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v356 = (char *)a1[2];
      *((_QWORD *)v356 + 2) = v355;
      *(_QWORD *)v356 = (unint64_t)(v353 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v355;
    }
  }
  else
  {
    str_alloc(a1, v354);
  }
  v357 = (char *)&v353[(_QWORD)*a1];
  v358 = (v351 >> 12) + 87;
  if (v351 < 0xA000)
    LOBYTE(v358) = (v351 >> 12) | 0x30;
  *v357 = v358;
  v359 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v351), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v360 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v359), (int8x8_t)(*(_QWORD *)&v359 | 0x3000000030), (int8x8_t)vadd_s32(v359, (int32x2_t)0x5700000057));
  v357[2] = v360.i8[4];
  v357[1] = v360.i8[0];
  if ((v351 & 0xF) >= 0xA)
    v361 = (v351 & 0xF) + 87;
  else
    v361 = v351 & 0xF | 0x30;
  v357[3] = v361;
  v363 = a1[1];
  v362 = a1[2];
  v364 = (unint64_t)(v363 + 4);
  a1[1] = v363 + 4;
  v365 = (unint64_t)(v363 + 5);
  if (v362)
  {
    if (v365 >= *(_QWORD *)v362)
    {
      v366 = (const char *)malloc_type_realloc(*((void **)v362 + 2), (v364 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v367 = (char *)a1[2];
      *((_QWORD *)v367 + 2) = v366;
      *(_QWORD *)v367 = (v364 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v366;
    }
  }
  else
  {
    str_alloc(a1, v365);
  }
  v368 = *a1;
  ++a1[1];
  v368[v364] = 58;
  v369 = *(unsigned __int16 *)(a2 + 34);
  v371 = a1[1];
  v370 = a1[2];
  v372 = (unint64_t)(v371 + 4);
  if (v370)
  {
    if (v372 >= *(_QWORD *)v370)
    {
      v373 = (const char *)malloc_type_realloc(*((void **)v370 + 2), (unint64_t)(v371 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v374 = (char *)a1[2];
      *((_QWORD *)v374 + 2) = v373;
      *(_QWORD *)v374 = (unint64_t)(v371 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v373;
    }
  }
  else
  {
    str_alloc(a1, v372);
  }
  v375 = (char *)&v371[(_QWORD)*a1];
  v376 = (v369 >> 12) + 87;
  if (v369 < 0xA000)
    LOBYTE(v376) = (v369 >> 12) | 0x30;
  *v375 = v376;
  v377 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v369), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v378 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v377), (int8x8_t)(*(_QWORD *)&v377 | 0x3000000030), (int8x8_t)vadd_s32(v377, (int32x2_t)0x5700000057));
  v375[2] = v378.i8[4];
  v375[1] = v378.i8[0];
  if ((v369 & 0xF) >= 0xA)
    v379 = (v369 & 0xF) + 87;
  else
    v379 = v369 & 0xF | 0x30;
  v375[3] = v379;
  v381 = a1[1];
  v380 = a1[2];
  v382 = (unint64_t)(v381 + 4);
  a1[1] = v381 + 4;
  v383 = (unint64_t)(v381 + 5);
  if (v380)
  {
    if (v383 >= *(_QWORD *)v380)
    {
      v384 = (const char *)malloc_type_realloc(*((void **)v380 + 2), (v382 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v385 = (char *)a1[2];
      *((_QWORD *)v385 + 2) = v384;
      *(_QWORD *)v385 = (v382 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v384;
    }
  }
  else
  {
    str_alloc(a1, v383);
  }
  v386 = *a1;
  ++a1[1];
  v386[v382] = 58;
  v387 = *(unsigned __int16 *)(a2 + 36);
  v389 = a1[1];
  v388 = a1[2];
  v390 = (unint64_t)(v389 + 4);
  if (v388)
  {
    if (v390 >= *(_QWORD *)v388)
    {
      v391 = (const char *)malloc_type_realloc(*((void **)v388 + 2), (unint64_t)(v389 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v392 = (char *)a1[2];
      *((_QWORD *)v392 + 2) = v391;
      *(_QWORD *)v392 = (unint64_t)(v389 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v391;
    }
  }
  else
  {
    str_alloc(a1, v390);
  }
  v393 = (char *)&v389[(_QWORD)*a1];
  v394 = (v387 >> 12) + 87;
  if (v387 < 0xA000)
    LOBYTE(v394) = (v387 >> 12) | 0x30;
  *v393 = v394;
  v395 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v387), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v396 = (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v395);
  *(int32x2_t *)v215.i8 = vadd_s32(v395, (int32x2_t)0x5700000057);
  v397 = COERCE_DOUBLE(vbsl_s8(v396, (int8x8_t)(*(_QWORD *)&v395 | 0x3000000030), *(int8x8_t *)v215.i8));
  v393[2] = BYTE4(v397);
  v393[1] = LOBYTE(v397);
  if ((v387 & 0xF) >= 0xA)
    v398 = (v387 & 0xF) + 87;
  else
    v398 = v387 & 0xF | 0x30;
  v393[3] = v398;
  v400 = a1[1];
  v399 = a1[2];
  v401 = (unint64_t)(v400 + 4);
  a1[1] = v400 + 4;
  v402 = (unint64_t)(v400 + 5);
  if (v399)
  {
    if (v402 >= *(_QWORD *)v399)
    {
      v403 = (const char *)malloc_type_realloc(*((void **)v399 + 2), (v401 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v404 = (char *)a1[2];
      *((_QWORD *)v404 + 2) = v403;
      *(_QWORD *)v404 = (v401 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v403;
    }
  }
  else
  {
    str_alloc(a1, v402);
  }
  v405 = *a1;
  ++a1[1];
  v405[v401] = 58;
  v406 = *(unsigned __int8 *)(a2 + 40);
  v408 = a1[1];
  v407 = a1[2];
  v409 = (unint64_t)(v408 + 2);
  if (v407)
  {
    if (v409 >= *(_QWORD *)v407)
    {
      v410 = (const char *)malloc_type_realloc(*((void **)v407 + 2), (unint64_t)(v408 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v411 = (char *)a1[2];
      *((_QWORD *)v411 + 2) = v410;
      *(_QWORD *)v411 = (unint64_t)(v408 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v410;
    }
  }
  else
  {
    str_alloc(a1, v409);
  }
  v412 = (char *)&v408[(_QWORD)*a1];
  v413 = (v406 >> 4) + 87;
  if (v406 < 0xA0)
    LOBYTE(v413) = (v406 >> 4) | 0x30;
  *v412 = v413;
  if ((v406 & 0xF) >= 0xA)
    v414 = (v406 & 0xF) + 87;
  else
    v414 = v406 & 0xF | 0x30;
  v412[1] = v414;
  v416 = a1[1];
  v415 = a1[2];
  v417 = (unint64_t)(v416 + 2);
  a1[1] = v416 + 2;
  v418 = (unint64_t)(v416 + 3);
  if (v415)
  {
    if (v418 >= *(_QWORD *)v415)
    {
      v419 = (const char *)malloc_type_realloc(*((void **)v415 + 2), (v417 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v420 = (char *)a1[2];
      *((_QWORD *)v420 + 2) = v419;
      *(_QWORD *)v420 = (v417 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v419;
    }
  }
  else
  {
    str_alloc(a1, v418);
  }
  v421 = *a1;
  ++a1[1];
  v421[v417] = 58;
  v422 = *(_BYTE *)(a2 + 41);
  v424 = (unint64_t)a1[1];
  v423 = a1[2];
  v425 = v424 + 1;
  if (v423)
  {
    if (v425 >= *(_QWORD *)v423)
    {
      v426 = (const char *)malloc_type_realloc(*((void **)v423 + 2), (v424 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v427 = (char *)a1[2];
      *((_QWORD *)v427 + 2) = v426;
      *(_QWORD *)v427 = (v424 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v426;
    }
  }
  else
  {
    str_alloc(a1, v425);
  }
  if ((v422 & 0xFu) >= 0xA)
    v428 = (v422 & 0xF) + 87;
  else
    v428 = v422 & 0xF | 0x30;
  (*a1)[v424] = v428;
  v430 = a1[1];
  v429 = a1[2];
  v431 = (unint64_t)(v430 + 1);
  a1[1] = v430 + 1;
  v432 = (unint64_t)(v430 + 2);
  if (v429)
  {
    if (v432 >= *(_QWORD *)v429)
    {
      v433 = (const char *)malloc_type_realloc(*((void **)v429 + 2), (v431 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v434 = (char *)a1[2];
      *((_QWORD *)v434 + 2) = v433;
      *(_QWORD *)v434 = (v431 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v433;
    }
  }
  else
  {
    str_alloc(a1, v432);
  }
  v435 = *a1;
  ++a1[1];
  v435[v431] = 58;
  v436 = *(_BYTE *)(a2 + 42);
  v438 = (unint64_t)a1[1];
  v437 = a1[2];
  v439 = v438 + 1;
  if (v437)
  {
    if (v439 >= *(_QWORD *)v437)
    {
      v440 = (const char *)malloc_type_realloc(*((void **)v437 + 2), (v438 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v441 = (char *)a1[2];
      *((_QWORD *)v441 + 2) = v440;
      *(_QWORD *)v441 = (v438 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v440;
    }
  }
  else
  {
    str_alloc(a1, v439);
  }
  if ((v436 & 0xFu) >= 0xA)
    v442 = (v436 & 0xF) + 87;
  else
    v442 = v436 & 0xF | 0x30;
  (*a1)[v438] = v442;
  v444 = a1[1];
  v443 = a1[2];
  v445 = (unint64_t)(v444 + 1);
  a1[1] = v444 + 1;
  v446 = (unint64_t)(v444 + 2);
  if (v443)
  {
    if (v446 >= *(_QWORD *)v443)
    {
      v447 = (const char *)malloc_type_realloc(*((void **)v443 + 2), (v445 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v448 = (char *)a1[2];
      *((_QWORD *)v448 + 2) = v447;
      *(_QWORD *)v448 = (v445 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v447;
    }
  }
  else
  {
    str_alloc(a1, v446);
  }
  v449 = *a1;
  ++a1[1];
  v449[v445] = 58;
  v450 = *(_BYTE *)(a2 + 43);
  v452 = (unint64_t)a1[1];
  v451 = a1[2];
  v453 = v452 + 1;
  if (v451)
  {
    if (v453 >= *(_QWORD *)v451)
    {
      v454 = (const char *)malloc_type_realloc(*((void **)v451 + 2), (v452 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v455 = (char *)a1[2];
      *((_QWORD *)v455 + 2) = v454;
      *(_QWORD *)v455 = (v452 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v454;
    }
  }
  else
  {
    str_alloc(a1, v453);
  }
  if ((v450 & 0xFu) >= 0xA)
    v456 = (v450 & 0xF) + 87;
  else
    v456 = v450 & 0xF | 0x30;
  (*a1)[v452] = v456;
  v458 = a1[1];
  v457 = a1[2];
  v459 = (unint64_t)(v458 + 1);
  a1[1] = v458 + 1;
  v460 = (unint64_t)(v458 + 2);
  if (v457)
  {
    if (v460 >= *(_QWORD *)v457)
    {
      v461 = (const char *)malloc_type_realloc(*((void **)v457 + 2), (v459 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v462 = (char *)a1[2];
      *((_QWORD *)v462 + 2) = v461;
      *(_QWORD *)v462 = (v459 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v461;
    }
  }
  else
  {
    str_alloc(a1, v460);
  }
  v463 = *a1;
  ++a1[1];
  v463[v459] = 10;
  return str_close(a1, v397, *(double *)&v396, (uint32x4_t)v215);
}

const char *str_ext(string_t *a1, uint64_t a2, uint64_t a3)
{
  string_t v5;
  string_t v6;
  unint64_t v7;
  size_t v8;
  const char *v9;
  char *v10;
  string_t v11;

  v6 = a1[1];
  v5 = a1[2];
  v7 = (unint64_t)&v6[a3];
  if (v5)
  {
    if (v7 >= *(_QWORD *)v5)
    {
      v8 = (v7 + 255) & 0xFFFFFFFFFFFFFF00;
      v9 = (const char *)malloc_type_realloc(*((void **)v5 + 2), v8, 0xCCCD1039uLL);
      v10 = (char *)a1[2];
      *((_QWORD *)v10 + 2) = v9;
      *(_QWORD *)v10 = v8;
      *a1 = v9;
    }
  }
  else
  {
    str_alloc(a1, v7);
  }
  v11 = *a1;
  a1[1] += a2;
  return &v6[(_QWORD)v11];
}

size_t str_puts(string_t *a1, const char *__src, size_t __n)
{
  string_t v6;
  string_t v7;
  unint64_t v8;
  size_t v9;
  const char *v10;
  char *v11;
  string_t v12;

  v7 = a1[1];
  v6 = a1[2];
  v8 = (unint64_t)&v7[__n];
  if (v6)
  {
    if (v8 >= *(_QWORD *)v6)
    {
      v9 = (v8 + 255) & 0xFFFFFFFFFFFFFF00;
      v10 = (const char *)malloc_type_realloc(*((void **)v6 + 2), v9, 0xCCCD1039uLL);
      v11 = (char *)a1[2];
      *((_QWORD *)v11 + 2) = v10;
      *(_QWORD *)v11 = v9;
      *a1 = v10;
    }
  }
  else
  {
    str_alloc(a1, v8);
  }
  v12 = *a1;
  a1[1] += __n;
  memcpy((void *)&v7[(_QWORD)v12], __src, __n);
  return __n;
}

void glsl::end(string_t *a1, uint64_t a2, unsigned int *a3, char a4, double a5, double a6, uint32x4_t a7)
{
  string_t v11;
  string_t v12;
  unint64_t v13;
  const char *v14;
  char *v15;
  string_t v16;
  char *v17;
  unsigned int v18;
  string_t v19;
  string_t v20;
  unint64_t v21;
  const char *v22;
  char *v23;
  uint32x2_t v24;
  uint32x2_t v25;
  int8x16_t v26;
  unsigned __int32 v27;
  int8x16_t v28;
  uint32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  int8x16_t v32;
  uint32x4_t v33;
  int32x4_t v34;
  string_t v35;
  string_t v36;
  unint64_t v37;
  unint64_t v38;
  const char *v39;
  char *v40;
  string_t v41;
  unsigned int v42;
  string_t v43;
  string_t v44;
  unint64_t v45;
  const char *v46;
  char *v47;
  uint32x2_t v48;
  uint32x2_t v49;
  int8x16_t v50;
  unsigned __int32 v51;
  int8x16_t v52;
  uint32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int8x16_t v56;
  uint32x4_t v57;
  int32x4_t v58;
  string_t v59;
  string_t v60;
  unint64_t v61;
  unint64_t v62;
  const char *v63;
  char *v64;
  string_t v65;
  unsigned int v66;
  string_t v67;
  string_t v68;
  unint64_t v69;
  const char *v70;
  char *v71;
  uint32x2_t v72;
  uint32x2_t v73;
  int8x16_t v74;
  unsigned __int32 v75;
  int8x16_t v76;
  uint32x4_t v77;
  int32x4_t v78;
  int32x4_t v79;
  int8x16_t v80;
  uint32x4_t v81;
  int32x4_t v82;
  string_t v83;
  string_t v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  char *v88;
  string_t v89;
  unsigned int v90;
  string_t v91;
  string_t v92;
  unint64_t v93;
  const char *v94;
  char *v95;
  uint32x2_t v96;
  uint32x2_t v97;
  int8x16_t v98;
  unsigned __int32 v99;
  int8x16_t v100;
  uint32x4_t v101;
  int32x4_t v102;
  int32x4_t v103;
  int8x16_t v104;
  uint32x4_t v105;
  int32x4_t v106;
  string_t v107;
  string_t v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  char *v112;
  string_t v113;
  string_t v114;
  string_t v115;
  unint64_t v116;
  const char *v117;
  char *v118;
  string_t v119;
  char *v120;
  unsigned int v121;
  string_t v122;
  string_t v123;
  unint64_t v124;
  const char *v125;
  char *v126;
  uint32x2_t v127;
  uint32x2_t v128;
  int8x16_t v129;
  unsigned __int32 v130;
  int8x16_t v131;
  uint32x4_t v132;
  int32x4_t v133;
  int32x4_t v134;
  int8x16_t v135;
  uint32x4_t v136;
  int32x4_t v137;
  string_t v138;
  string_t v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  char *v143;
  string_t v144;
  unsigned int v145;
  string_t v146;
  string_t v147;
  unint64_t v148;
  const char *v149;
  char *v150;
  uint32x2_t v151;
  uint32x2_t v152;
  int8x16_t v153;
  unsigned __int32 v154;
  int8x16_t v155;
  uint32x4_t v156;
  int32x4_t v157;
  int32x4_t v158;
  int8x16_t v159;
  uint32x4_t v160;
  int32x4_t v161;
  string_t v162;
  string_t v163;
  unint64_t v164;
  unint64_t v165;
  const char *v166;
  char *v167;
  string_t v168;
  unsigned int v169;
  string_t v170;
  string_t v171;
  unint64_t v172;
  const char *v173;
  char *v174;
  uint32x2_t v175;
  uint32x2_t v176;
  int8x16_t v177;
  unsigned __int32 v178;
  int8x16_t v179;
  uint32x4_t v180;
  int32x4_t v181;
  int32x4_t v182;
  int8x16_t v183;
  uint32x4_t v184;
  int32x4_t v185;
  string_t v186;
  string_t v187;
  unint64_t v188;
  unint64_t v189;
  const char *v190;
  char *v191;
  string_t v192;
  unsigned int v193;
  string_t v194;
  string_t v195;
  unint64_t v196;
  const char *v197;
  char *v198;
  uint32x2_t v199;
  uint32x2_t v200;
  int8x16_t v201;
  unsigned __int32 v202;
  int8x16_t v203;
  uint32x4_t v204;
  int32x4_t v205;
  int32x4_t v206;
  int8x16_t v207;
  uint32x4_t v208;
  int32x4_t v209;
  string_t v210;
  string_t v211;
  unint64_t v212;
  unint64_t v213;
  const char *v214;
  char *v215;
  string_t v216;
  unsigned int v217;
  string_t v218;
  string_t v219;
  unint64_t v220;
  const char *v221;
  char *v222;
  char *v223;
  int v224;
  int32x2_t v225;
  int8x8_t v226;
  char v227;
  string_t v228;
  string_t v229;
  unint64_t v230;
  unint64_t v231;
  const char *v232;
  char *v233;
  string_t v234;
  unsigned int v235;
  string_t v236;
  string_t v237;
  unint64_t v238;
  const char *v239;
  char *v240;
  char *v241;
  int v242;
  int32x2_t v243;
  int8x8_t v244;
  char v245;
  string_t v246;
  string_t v247;
  unint64_t v248;
  unint64_t v249;
  const char *v250;
  char *v251;
  string_t v252;
  unsigned int v253;
  string_t v254;
  string_t v255;
  unint64_t v256;
  const char *v257;
  char *v258;
  char *v259;
  int v260;
  int32x2_t v261;
  int8x8_t v262;
  char v263;
  string_t v264;
  string_t v265;
  unint64_t v266;
  unint64_t v267;
  const char *v268;
  char *v269;
  string_t v270;
  unsigned int v271;
  string_t v272;
  string_t v273;
  unint64_t v274;
  const char *v275;
  char *v276;
  char *v277;
  int v278;
  char v279;
  string_t v280;
  string_t v281;
  string_t v282;
  unsigned int v283;
  unint64_t v284;
  size_t v285;
  const char *v286;
  char *v287;
  char *v288;
  int v289;
  char v290;
  string_t v291;
  string_t v292;
  unint64_t v293;
  unint64_t v294;
  const char *v295;
  char *v296;
  string_t v297;
  unsigned int v298;
  string_t v299;
  string_t v300;
  unint64_t v301;
  const char *v302;
  char *v303;
  char *v304;
  int v305;
  char v306;
  string_t v307;
  string_t v308;
  string_t v309;
  unsigned int v310;
  unint64_t v311;
  size_t v312;
  const char *v313;
  char *v314;
  char *v315;
  int v316;
  char v317;
  string_t v318;
  string_t v319;
  unint64_t v320;
  unint64_t v321;
  const char *v322;
  char *v323;
  string_t v324;
  unsigned int v325;
  string_t v326;
  string_t v327;
  unint64_t v328;
  const char *v329;
  char *v330;
  char *v331;
  int v332;
  int32x2_t v333;
  int8x8_t v334;
  char v335;
  string_t v336;
  string_t v337;
  unint64_t v338;
  unint64_t v339;
  const char *v340;
  char *v341;
  string_t v342;
  unsigned int v343;
  string_t v344;
  string_t v345;
  unint64_t v346;
  const char *v347;
  char *v348;
  char *v349;
  int v350;
  int32x2_t v351;
  int8x8_t v352;
  char v353;
  string_t v354;
  string_t v355;
  unint64_t v356;
  unint64_t v357;
  const char *v358;
  char *v359;
  string_t v360;
  unsigned int v361;
  string_t v362;
  string_t v363;
  unint64_t v364;
  const char *v365;
  char *v366;
  char *v367;
  int v368;
  int32x2_t v369;
  int8x8_t v370;
  char v371;
  string_t v372;
  string_t v373;
  unint64_t v374;
  unint64_t v375;
  const char *v376;
  char *v377;
  string_t v378;
  unsigned int v379;
  string_t v380;
  string_t v381;
  unint64_t v382;
  const char *v383;
  char *v384;
  char *v385;
  int v386;
  int32x2_t v387;
  int8x8_t v388;
  double v389;
  char v390;
  string_t v391;
  string_t v392;
  unint64_t v393;
  unint64_t v394;
  const char *v395;
  char *v396;
  string_t v397;
  unsigned int v398;
  string_t v399;
  string_t v400;
  unint64_t v401;
  const char *v402;
  char *v403;
  char *v404;
  int v405;
  char v406;
  string_t v407;
  string_t v408;
  unint64_t v409;
  unint64_t v410;
  const char *v411;
  char *v412;
  string_t v413;
  char v414;
  string_t v415;
  unint64_t v416;
  unint64_t v417;
  const char *v418;
  char *v419;
  char v420;
  string_t v421;
  string_t v422;
  unint64_t v423;
  unint64_t v424;
  const char *v425;
  char *v426;
  string_t v427;
  char v428;
  string_t v429;
  unint64_t v430;
  unint64_t v431;
  const char *v432;
  char *v433;
  char v434;
  string_t v435;
  string_t v436;
  unint64_t v437;
  unint64_t v438;
  const char *v439;
  char *v440;
  string_t v441;
  char v442;
  string_t v443;
  unint64_t v444;
  unint64_t v445;
  const char *v446;
  char *v447;
  char v448;
  string_t v449;
  string_t v450;
  unint64_t v451;
  unint64_t v452;
  const char *v453;
  char *v454;
  string_t v455;
  string_t v456;

  v12 = a1[1];
  v11 = a1[2];
  v13 = (unint64_t)(v12 + 6);
  if (v11)
  {
    if (v13 >= *(_QWORD *)v11)
    {
      v14 = (const char *)malloc_type_realloc(*((void **)v11 + 2), (unint64_t)(v12 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v15 = (char *)a1[2];
      *((_QWORD *)v15 + 2) = v14;
      *(_QWORD *)v15 = (unint64_t)(v12 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v14;
    }
  }
  else
  {
    str_alloc(a1, v13);
  }
  v16 = *a1;
  a1[1] += 6;
  v17 = (char *)&v12[(_QWORD)v16];
  *((_WORD *)v17 + 2) = 15669;
  *(_DWORD *)v17 = 1145909039;
  v18 = *a3;
  v20 = a1[1];
  v19 = a1[2];
  v21 = (unint64_t)(v20 + 8);
  if (v19)
  {
    if (v21 >= *(_QWORD *)v19)
    {
      v22 = (const char *)malloc_type_realloc(*((void **)v19 + 2), (unint64_t)(v20 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v23 = (char *)a1[2];
      *((_QWORD *)v23 + 2) = v22;
      *(_QWORD *)v23 = (unint64_t)(v20 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v22;
    }
  }
  else
  {
    str_alloc(a1, v21);
  }
  v24 = (uint32x2_t)vdup_n_s32(v18);
  v25 = vshl_u32(v24, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v26.i8 = vshl_u32(v24, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  a7.i32[0] = v18;
  v27 = vshrq_n_u32(a7, 0x1CuLL).u32[0];
  a7.i32[1] = HIBYTE(v18);
  a7.u64[1] = (unint64_t)v25;
  v26.i32[2] = v18 >> 4;
  v26.i32[3] = v18;
  v28.i64[0] = 0xF0000000FLL;
  v28.i64[1] = 0xF0000000FLL;
  v29 = (uint32x4_t)vandq_s8((int8x16_t)a7, v28);
  v30 = (int32x4_t)vandq_s8(v26, v28);
  v31 = (int32x4_t)v29;
  v31.i32[0] = v27;
  v29.i32[0] = v18;
  v32 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v29);
  v33.i64[0] = 0xA0000000ALL;
  v33.i64[1] = 0xA0000000ALL;
  v34.i64[0] = 0x5700000057;
  v34.i64[1] = 0x5700000057;
  *(int8x8_t *)&v20[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v32, (int8x16_t)(*(_OWORD *)&v31 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v31, v34)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v33, (uint32x4_t)v30), (int8x16_t)(*(_OWORD *)&v30 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v30, v34))));
  v36 = a1[1];
  v35 = a1[2];
  v37 = (unint64_t)(v36 + 8);
  a1[1] = v36 + 8;
  v38 = (unint64_t)(v36 + 9);
  if (v35)
  {
    if (v38 >= *(_QWORD *)v35)
    {
      v39 = (const char *)malloc_type_realloc(*((void **)v35 + 2), (v37 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v40 = (char *)a1[2];
      *((_QWORD *)v40 + 2) = v39;
      *(_QWORD *)v40 = (v37 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v39;
    }
  }
  else
  {
    str_alloc(a1, v38);
  }
  v41 = *a1;
  ++a1[1];
  v41[v37] = 58;
  v42 = a3[1];
  v44 = a1[1];
  v43 = a1[2];
  v45 = (unint64_t)(v44 + 8);
  if (v43)
  {
    if (v45 >= *(_QWORD *)v43)
    {
      v46 = (const char *)malloc_type_realloc(*((void **)v43 + 2), (unint64_t)(v44 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v47 = (char *)a1[2];
      *((_QWORD *)v47 + 2) = v46;
      *(_QWORD *)v47 = (unint64_t)(v44 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v46;
    }
  }
  else
  {
    str_alloc(a1, v45);
  }
  v48 = (uint32x2_t)vdup_n_s32(v42);
  v49 = vshl_u32(v48, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v50.i8 = vshl_u32(v48, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v32.i32[0] = v42;
  v51 = vshrq_n_u32((uint32x4_t)v32, 0x1CuLL).u32[0];
  v32.i32[1] = HIBYTE(v42);
  v32.u64[1] = (unint64_t)v49;
  v50.i32[2] = v42 >> 4;
  v50.i32[3] = v42;
  v52.i64[0] = 0xF0000000FLL;
  v52.i64[1] = 0xF0000000FLL;
  v53 = (uint32x4_t)vandq_s8(v32, v52);
  v54 = (int32x4_t)vandq_s8(v50, v52);
  v55 = (int32x4_t)v53;
  v55.i32[0] = v51;
  v53.i32[0] = v42;
  v56 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v53);
  v57.i64[0] = 0xA0000000ALL;
  v57.i64[1] = 0xA0000000ALL;
  v58.i64[0] = 0x5700000057;
  v58.i64[1] = 0x5700000057;
  *(int8x8_t *)&v44[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v56, (int8x16_t)(*(_OWORD *)&v55 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v55, v58)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v57, (uint32x4_t)v54), (int8x16_t)(*(_OWORD *)&v54 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v54, v58))));
  v60 = a1[1];
  v59 = a1[2];
  v61 = (unint64_t)(v60 + 8);
  a1[1] = v60 + 8;
  v62 = (unint64_t)(v60 + 9);
  if (v59)
  {
    if (v62 >= *(_QWORD *)v59)
    {
      v63 = (const char *)malloc_type_realloc(*((void **)v59 + 2), (v61 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v64 = (char *)a1[2];
      *((_QWORD *)v64 + 2) = v63;
      *(_QWORD *)v64 = (v61 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v63;
    }
  }
  else
  {
    str_alloc(a1, v62);
  }
  v65 = *a1;
  ++a1[1];
  v65[v61] = 58;
  v66 = a3[2];
  v68 = a1[1];
  v67 = a1[2];
  v69 = (unint64_t)(v68 + 8);
  if (v67)
  {
    if (v69 >= *(_QWORD *)v67)
    {
      v70 = (const char *)malloc_type_realloc(*((void **)v67 + 2), (unint64_t)(v68 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v71 = (char *)a1[2];
      *((_QWORD *)v71 + 2) = v70;
      *(_QWORD *)v71 = (unint64_t)(v68 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v70;
    }
  }
  else
  {
    str_alloc(a1, v69);
  }
  v72 = (uint32x2_t)vdup_n_s32(v66);
  v73 = vshl_u32(v72, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v74.i8 = vshl_u32(v72, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v56.i32[0] = v66;
  v75 = vshrq_n_u32((uint32x4_t)v56, 0x1CuLL).u32[0];
  v56.i32[1] = HIBYTE(v66);
  v56.u64[1] = (unint64_t)v73;
  v74.i32[2] = v66 >> 4;
  v74.i32[3] = v66;
  v76.i64[0] = 0xF0000000FLL;
  v76.i64[1] = 0xF0000000FLL;
  v77 = (uint32x4_t)vandq_s8(v56, v76);
  v78 = (int32x4_t)vandq_s8(v74, v76);
  v79 = (int32x4_t)v77;
  v79.i32[0] = v75;
  v77.i32[0] = v66;
  v80 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v77);
  v81.i64[0] = 0xA0000000ALL;
  v81.i64[1] = 0xA0000000ALL;
  v82.i64[0] = 0x5700000057;
  v82.i64[1] = 0x5700000057;
  *(int8x8_t *)&v68[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v80, (int8x16_t)(*(_OWORD *)&v79 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v79, v82)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v81, (uint32x4_t)v78), (int8x16_t)(*(_OWORD *)&v78 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v78, v82))));
  v84 = a1[1];
  v83 = a1[2];
  v85 = (unint64_t)(v84 + 8);
  a1[1] = v84 + 8;
  v86 = (unint64_t)(v84 + 9);
  if (v83)
  {
    if (v86 >= *(_QWORD *)v83)
    {
      v87 = (const char *)malloc_type_realloc(*((void **)v83 + 2), (v85 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v88 = (char *)a1[2];
      *((_QWORD *)v88 + 2) = v87;
      *(_QWORD *)v88 = (v85 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v87;
    }
  }
  else
  {
    str_alloc(a1, v86);
  }
  v89 = *a1;
  ++a1[1];
  v89[v85] = 58;
  v90 = a3[3];
  v92 = a1[1];
  v91 = a1[2];
  v93 = (unint64_t)(v92 + 8);
  if (v91)
  {
    if (v93 >= *(_QWORD *)v91)
    {
      v94 = (const char *)malloc_type_realloc(*((void **)v91 + 2), (unint64_t)(v92 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v95 = (char *)a1[2];
      *((_QWORD *)v95 + 2) = v94;
      *(_QWORD *)v95 = (unint64_t)(v92 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v94;
    }
  }
  else
  {
    str_alloc(a1, v93);
  }
  v96 = (uint32x2_t)vdup_n_s32(v90);
  v97 = vshl_u32(v96, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v98.i8 = vshl_u32(v96, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v80.i32[0] = v90;
  v99 = vshrq_n_u32((uint32x4_t)v80, 0x1CuLL).u32[0];
  v80.i32[1] = HIBYTE(v90);
  v80.u64[1] = (unint64_t)v97;
  v98.i32[2] = v90 >> 4;
  v98.i32[3] = v90;
  v100.i64[0] = 0xF0000000FLL;
  v100.i64[1] = 0xF0000000FLL;
  v101 = (uint32x4_t)vandq_s8(v80, v100);
  v102 = (int32x4_t)vandq_s8(v98, v100);
  v103 = (int32x4_t)v101;
  v103.i32[0] = v99;
  v101.i32[0] = v90;
  v104 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v101);
  v105.i64[0] = 0xA0000000ALL;
  v105.i64[1] = 0xA0000000ALL;
  v106.i64[0] = 0x5700000057;
  v106.i64[1] = 0x5700000057;
  *(int8x8_t *)&v92[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v104, (int8x16_t)(*(_OWORD *)&v103 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v103, v106)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v105, (uint32x4_t)v102), (int8x16_t)(*(_OWORD *)&v102 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v102, v106))));
  v108 = a1[1];
  v107 = a1[2];
  v109 = (unint64_t)(v108 + 8);
  a1[1] = v108 + 8;
  v110 = (unint64_t)(v108 + 9);
  if (v107)
  {
    if (v110 >= *(_QWORD *)v107)
    {
      v111 = (const char *)malloc_type_realloc(*((void **)v107 + 2), (v109 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v112 = (char *)a1[2];
      *((_QWORD *)v112 + 2) = v111;
      *(_QWORD *)v112 = (v109 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v111;
    }
  }
  else
  {
    str_alloc(a1, v110);
  }
  v113 = *a1;
  ++a1[1];
  v113[v109] = 10;
  v115 = a1[1];
  v114 = a1[2];
  v116 = (unint64_t)(v115 + 6);
  if (v114)
  {
    if (v116 >= *(_QWORD *)v114)
    {
      v117 = (const char *)malloc_type_realloc(*((void **)v114 + 2), (unint64_t)(v115 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v118 = (char *)a1[2];
      *((_QWORD *)v118 + 2) = v117;
      *(_QWORD *)v118 = (unint64_t)(v115 + 261) & 0xFFFFFFFFFFFFFF00;
      *a1 = v117;
    }
  }
  else
  {
    str_alloc(a1, v116);
  }
  v119 = *a1;
  a1[1] += 6;
  v120 = (char *)&v115[(_QWORD)v119];
  *((_WORD *)v120 + 2) = 15687;
  *(_DWORD *)v120 = 1230188335;
  v121 = *(_DWORD *)(a2 + 4);
  v123 = a1[1];
  v122 = a1[2];
  v124 = (unint64_t)(v123 + 8);
  if (v122)
  {
    if (v124 >= *(_QWORD *)v122)
    {
      v125 = (const char *)malloc_type_realloc(*((void **)v122 + 2), (unint64_t)(v123 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v126 = (char *)a1[2];
      *((_QWORD *)v126 + 2) = v125;
      *(_QWORD *)v126 = (unint64_t)(v123 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v125;
    }
  }
  else
  {
    str_alloc(a1, v124);
  }
  v127 = (uint32x2_t)vdup_n_s32(v121);
  v128 = vshl_u32(v127, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v129.i8 = vshl_u32(v127, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v104.i32[0] = v121;
  v130 = vshrq_n_u32((uint32x4_t)v104, 0x1CuLL).u32[0];
  v104.i32[1] = HIBYTE(v121);
  v104.u64[1] = (unint64_t)v128;
  v129.i32[2] = v121 >> 4;
  v129.i32[3] = v121;
  v131.i64[0] = 0xF0000000FLL;
  v131.i64[1] = 0xF0000000FLL;
  v132 = (uint32x4_t)vandq_s8(v104, v131);
  v133 = (int32x4_t)vandq_s8(v129, v131);
  v134 = (int32x4_t)v132;
  v134.i32[0] = v130;
  v132.i32[0] = v121;
  v135 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v132);
  v136.i64[0] = 0xA0000000ALL;
  v136.i64[1] = 0xA0000000ALL;
  v137.i64[0] = 0x5700000057;
  v137.i64[1] = 0x5700000057;
  *(int8x8_t *)&v123[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v135, (int8x16_t)(*(_OWORD *)&v134 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v134, v137)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v136, (uint32x4_t)v133), (int8x16_t)(*(_OWORD *)&v133 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v133, v137))));
  v139 = a1[1];
  v138 = a1[2];
  v140 = (unint64_t)(v139 + 8);
  a1[1] = v139 + 8;
  v141 = (unint64_t)(v139 + 9);
  if (v138)
  {
    if (v141 >= *(_QWORD *)v138)
    {
      v142 = (const char *)malloc_type_realloc(*((void **)v138 + 2), (v140 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v143 = (char *)a1[2];
      *((_QWORD *)v143 + 2) = v142;
      *(_QWORD *)v143 = (v140 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v142;
    }
  }
  else
  {
    str_alloc(a1, v141);
  }
  v144 = *a1;
  ++a1[1];
  v144[v140] = 58;
  v145 = *(_DWORD *)(a2 + 8);
  v147 = a1[1];
  v146 = a1[2];
  v148 = (unint64_t)(v147 + 8);
  if (v146)
  {
    if (v148 >= *(_QWORD *)v146)
    {
      v149 = (const char *)malloc_type_realloc(*((void **)v146 + 2), (unint64_t)(v147 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v150 = (char *)a1[2];
      *((_QWORD *)v150 + 2) = v149;
      *(_QWORD *)v150 = (unint64_t)(v147 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v149;
    }
  }
  else
  {
    str_alloc(a1, v148);
  }
  v151 = (uint32x2_t)vdup_n_s32(v145);
  v152 = vshl_u32(v151, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v153.i8 = vshl_u32(v151, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v135.i32[0] = v145;
  v154 = vshrq_n_u32((uint32x4_t)v135, 0x1CuLL).u32[0];
  v135.i32[1] = HIBYTE(v145);
  v135.u64[1] = (unint64_t)v152;
  v153.i32[2] = v145 >> 4;
  v153.i32[3] = v145;
  v155.i64[0] = 0xF0000000FLL;
  v155.i64[1] = 0xF0000000FLL;
  v156 = (uint32x4_t)vandq_s8(v135, v155);
  v157 = (int32x4_t)vandq_s8(v153, v155);
  v158 = (int32x4_t)v156;
  v158.i32[0] = v154;
  v156.i32[0] = v145;
  v159 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v156);
  v160.i64[0] = 0xA0000000ALL;
  v160.i64[1] = 0xA0000000ALL;
  v161.i64[0] = 0x5700000057;
  v161.i64[1] = 0x5700000057;
  *(int8x8_t *)&v147[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v159, (int8x16_t)(*(_OWORD *)&v158 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v158, v161)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v160, (uint32x4_t)v157), (int8x16_t)(*(_OWORD *)&v157 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v157, v161))));
  v163 = a1[1];
  v162 = a1[2];
  v164 = (unint64_t)(v163 + 8);
  a1[1] = v163 + 8;
  v165 = (unint64_t)(v163 + 9);
  if (v162)
  {
    if (v165 >= *(_QWORD *)v162)
    {
      v166 = (const char *)malloc_type_realloc(*((void **)v162 + 2), (v164 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v167 = (char *)a1[2];
      *((_QWORD *)v167 + 2) = v166;
      *(_QWORD *)v167 = (v164 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v166;
    }
  }
  else
  {
    str_alloc(a1, v165);
  }
  v168 = *a1;
  ++a1[1];
  v168[v164] = 58;
  v169 = *(_DWORD *)(a2 + 12);
  v171 = a1[1];
  v170 = a1[2];
  v172 = (unint64_t)(v171 + 8);
  if (v170)
  {
    if (v172 >= *(_QWORD *)v170)
    {
      v173 = (const char *)malloc_type_realloc(*((void **)v170 + 2), (unint64_t)(v171 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v174 = (char *)a1[2];
      *((_QWORD *)v174 + 2) = v173;
      *(_QWORD *)v174 = (unint64_t)(v171 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v173;
    }
  }
  else
  {
    str_alloc(a1, v172);
  }
  v175 = (uint32x2_t)vdup_n_s32(v169);
  v176 = vshl_u32(v175, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v177.i8 = vshl_u32(v175, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v159.i32[0] = v169;
  v178 = vshrq_n_u32((uint32x4_t)v159, 0x1CuLL).u32[0];
  v159.i32[1] = HIBYTE(v169);
  v159.u64[1] = (unint64_t)v176;
  v177.i32[2] = v169 >> 4;
  v177.i32[3] = v169;
  v179.i64[0] = 0xF0000000FLL;
  v179.i64[1] = 0xF0000000FLL;
  v180 = (uint32x4_t)vandq_s8(v159, v179);
  v181 = (int32x4_t)vandq_s8(v177, v179);
  v182 = (int32x4_t)v180;
  v182.i32[0] = v178;
  v180.i32[0] = v169;
  v183 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v180);
  v184.i64[0] = 0xA0000000ALL;
  v184.i64[1] = 0xA0000000ALL;
  v185.i64[0] = 0x5700000057;
  v185.i64[1] = 0x5700000057;
  *(int8x8_t *)&v171[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v183, (int8x16_t)(*(_OWORD *)&v182 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v182, v185)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v184, (uint32x4_t)v181), (int8x16_t)(*(_OWORD *)&v181 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v181, v185))));
  v187 = a1[1];
  v186 = a1[2];
  v188 = (unint64_t)(v187 + 8);
  a1[1] = v187 + 8;
  v189 = (unint64_t)(v187 + 9);
  if (v186)
  {
    if (v189 >= *(_QWORD *)v186)
    {
      v190 = (const char *)malloc_type_realloc(*((void **)v186 + 2), (v188 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v191 = (char *)a1[2];
      *((_QWORD *)v191 + 2) = v190;
      *(_QWORD *)v191 = (v188 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v190;
    }
  }
  else
  {
    str_alloc(a1, v189);
  }
  v192 = *a1;
  ++a1[1];
  v192[v188] = 58;
  v193 = *(_DWORD *)(a2 + 16);
  v195 = a1[1];
  v194 = a1[2];
  v196 = (unint64_t)(v195 + 8);
  if (v194)
  {
    if (v196 >= *(_QWORD *)v194)
    {
      v197 = (const char *)malloc_type_realloc(*((void **)v194 + 2), (unint64_t)(v195 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v198 = (char *)a1[2];
      *((_QWORD *)v198 + 2) = v197;
      *(_QWORD *)v198 = (unint64_t)(v195 + 263) & 0xFFFFFFFFFFFFFF00;
      *a1 = v197;
    }
  }
  else
  {
    str_alloc(a1, v196);
  }
  v199 = (uint32x2_t)vdup_n_s32(v193);
  v200 = vshl_u32(v199, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v201.i8 = vshl_u32(v199, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  v183.i32[0] = v193;
  v202 = vshrq_n_u32((uint32x4_t)v183, 0x1CuLL).u32[0];
  v183.i32[1] = HIBYTE(v193);
  v183.u64[1] = (unint64_t)v200;
  v201.i32[2] = v193 >> 4;
  v201.i32[3] = v193;
  v203.i64[0] = 0xF0000000FLL;
  v203.i64[1] = 0xF0000000FLL;
  v204 = (uint32x4_t)vandq_s8(v183, v203);
  v205 = (int32x4_t)vandq_s8(v201, v203);
  v206 = (int32x4_t)v204;
  v206.i32[0] = v202;
  v204.i32[0] = v193;
  v207 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v204);
  v208.i64[0] = 0xA0000000ALL;
  v208.i64[1] = 0xA0000000ALL;
  v209.i64[0] = 0x5700000057;
  v209.i64[1] = 0x5700000057;
  *(int8x8_t *)&v195[(_QWORD)*a1] = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v207, (int8x16_t)(*(_OWORD *)&v206 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v206, v209)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v208, (uint32x4_t)v205), (int8x16_t)(*(_OWORD *)&v205 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v205, v209))));
  v211 = a1[1];
  v210 = a1[2];
  v212 = (unint64_t)(v211 + 8);
  a1[1] = v211 + 8;
  v213 = (unint64_t)(v211 + 9);
  if (v210)
  {
    if (v213 >= *(_QWORD *)v210)
    {
      v214 = (const char *)malloc_type_realloc(*((void **)v210 + 2), (v212 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v215 = (char *)a1[2];
      *((_QWORD *)v215 + 2) = v214;
      *(_QWORD *)v215 = (v212 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v214;
    }
  }
  else
  {
    str_alloc(a1, v213);
  }
  v216 = *a1;
  ++a1[1];
  v216[v212] = 58;
  v217 = *(unsigned __int16 *)(a2 + 20);
  v219 = a1[1];
  v218 = a1[2];
  v220 = (unint64_t)(v219 + 4);
  if (v218)
  {
    if (v220 >= *(_QWORD *)v218)
    {
      v221 = (const char *)malloc_type_realloc(*((void **)v218 + 2), (unint64_t)(v219 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v222 = (char *)a1[2];
      *((_QWORD *)v222 + 2) = v221;
      *(_QWORD *)v222 = (unint64_t)(v219 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v221;
    }
  }
  else
  {
    str_alloc(a1, v220);
  }
  v223 = (char *)&v219[(_QWORD)*a1];
  v224 = (v217 >> 12) + 87;
  if (v217 < 0xA000)
    LOBYTE(v224) = (v217 >> 12) | 0x30;
  *v223 = v224;
  v225 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v217), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v226 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v225), (int8x8_t)(*(_QWORD *)&v225 | 0x3000000030), (int8x8_t)vadd_s32(v225, (int32x2_t)0x5700000057));
  v223[2] = v226.i8[4];
  v223[1] = v226.i8[0];
  if ((v217 & 0xF) >= 0xA)
    v227 = (v217 & 0xF) + 87;
  else
    v227 = v217 & 0xF | 0x30;
  v223[3] = v227;
  v229 = a1[1];
  v228 = a1[2];
  v230 = (unint64_t)(v229 + 4);
  a1[1] = v229 + 4;
  v231 = (unint64_t)(v229 + 5);
  if (v228)
  {
    if (v231 >= *(_QWORD *)v228)
    {
      v232 = (const char *)malloc_type_realloc(*((void **)v228 + 2), (v230 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v233 = (char *)a1[2];
      *((_QWORD *)v233 + 2) = v232;
      *(_QWORD *)v233 = (v230 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v232;
    }
  }
  else
  {
    str_alloc(a1, v231);
  }
  v234 = *a1;
  ++a1[1];
  v234[v230] = 58;
  v235 = *(unsigned __int16 *)(a2 + 22);
  v237 = a1[1];
  v236 = a1[2];
  v238 = (unint64_t)(v237 + 4);
  if (v236)
  {
    if (v238 >= *(_QWORD *)v236)
    {
      v239 = (const char *)malloc_type_realloc(*((void **)v236 + 2), (unint64_t)(v237 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v240 = (char *)a1[2];
      *((_QWORD *)v240 + 2) = v239;
      *(_QWORD *)v240 = (unint64_t)(v237 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v239;
    }
  }
  else
  {
    str_alloc(a1, v238);
  }
  v241 = (char *)&v237[(_QWORD)*a1];
  v242 = (v235 >> 12) + 87;
  if (v235 < 0xA000)
    LOBYTE(v242) = (v235 >> 12) | 0x30;
  *v241 = v242;
  v243 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v235), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v244 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v243), (int8x8_t)(*(_QWORD *)&v243 | 0x3000000030), (int8x8_t)vadd_s32(v243, (int32x2_t)0x5700000057));
  v241[2] = v244.i8[4];
  v241[1] = v244.i8[0];
  if ((v235 & 0xF) >= 0xA)
    v245 = (v235 & 0xF) + 87;
  else
    v245 = v235 & 0xF | 0x30;
  v241[3] = v245;
  v247 = a1[1];
  v246 = a1[2];
  v248 = (unint64_t)(v247 + 4);
  a1[1] = v247 + 4;
  v249 = (unint64_t)(v247 + 5);
  if (v246)
  {
    if (v249 >= *(_QWORD *)v246)
    {
      v250 = (const char *)malloc_type_realloc(*((void **)v246 + 2), (v248 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v251 = (char *)a1[2];
      *((_QWORD *)v251 + 2) = v250;
      *(_QWORD *)v251 = (v248 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v250;
    }
  }
  else
  {
    str_alloc(a1, v249);
  }
  v252 = *a1;
  ++a1[1];
  v252[v248] = 58;
  v253 = *(unsigned __int16 *)(a2 + 24);
  v255 = a1[1];
  v254 = a1[2];
  v256 = (unint64_t)(v255 + 4);
  if (v254)
  {
    if (v256 >= *(_QWORD *)v254)
    {
      v257 = (const char *)malloc_type_realloc(*((void **)v254 + 2), (unint64_t)(v255 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v258 = (char *)a1[2];
      *((_QWORD *)v258 + 2) = v257;
      *(_QWORD *)v258 = (unint64_t)(v255 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v257;
    }
  }
  else
  {
    str_alloc(a1, v256);
  }
  v259 = (char *)&v255[(_QWORD)*a1];
  v260 = (v253 >> 12) + 87;
  if (v253 < 0xA000)
    LOBYTE(v260) = (v253 >> 12) | 0x30;
  *v259 = v260;
  v261 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v253), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v262 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v261), (int8x8_t)(*(_QWORD *)&v261 | 0x3000000030), (int8x8_t)vadd_s32(v261, (int32x2_t)0x5700000057));
  v259[2] = v262.i8[4];
  v259[1] = v262.i8[0];
  if ((v253 & 0xF) >= 0xA)
    v263 = (v253 & 0xF) + 87;
  else
    v263 = v253 & 0xF | 0x30;
  v259[3] = v263;
  v265 = a1[1];
  v264 = a1[2];
  v266 = (unint64_t)(v265 + 4);
  a1[1] = v265 + 4;
  v267 = (unint64_t)(v265 + 5);
  if (v264)
  {
    if (v267 >= *(_QWORD *)v264)
    {
      v268 = (const char *)malloc_type_realloc(*((void **)v264 + 2), (v266 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v269 = (char *)a1[2];
      *((_QWORD *)v269 + 2) = v268;
      *(_QWORD *)v269 = (v266 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v268;
    }
  }
  else
  {
    str_alloc(a1, v267);
  }
  v270 = *a1;
  ++a1[1];
  v270[v266] = 58;
  v271 = *(unsigned __int8 *)(a2 + 26);
  v273 = a1[1];
  v272 = a1[2];
  v274 = (unint64_t)(v273 + 2);
  if (v272)
  {
    if (v274 >= *(_QWORD *)v272)
    {
      v275 = (const char *)malloc_type_realloc(*((void **)v272 + 2), (unint64_t)(v273 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v276 = (char *)a1[2];
      *((_QWORD *)v276 + 2) = v275;
      *(_QWORD *)v276 = (unint64_t)(v273 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v275;
    }
  }
  else
  {
    str_alloc(a1, v274);
  }
  v277 = (char *)&v273[(_QWORD)*a1];
  v278 = (v271 >> 4) + 87;
  if (v271 < 0xA0)
    LOBYTE(v278) = (v271 >> 4) | 0x30;
  *v277 = v278;
  if ((v271 & 0xF) >= 0xA)
    v279 = (v271 & 0xF) + 87;
  else
    v279 = v271 & 0xF | 0x30;
  v277[1] = v279;
  v280 = a1[1];
  v281 = a1[2];
  v282 = v280 + 2;
  a1[1] = v280 + 2;
  v283 = *(unsigned __int8 *)(a2 + 27);
  v284 = (unint64_t)(v280 + 4);
  if (v281)
  {
    if (v284 >= *(_QWORD *)v281)
    {
      v285 = (unint64_t)(v280 + 259) & 0xFFFFFFFFFFFFFF00;
      v286 = (const char *)malloc_type_realloc(*((void **)v281 + 2), v285, 0xCCCD1039uLL);
      v287 = (char *)a1[2];
      *((_QWORD *)v287 + 2) = v286;
      *(_QWORD *)v287 = v285;
      *a1 = v286;
    }
  }
  else
  {
    str_alloc(a1, v284);
  }
  v288 = (char *)&v282[(_QWORD)*a1];
  v289 = (v283 >> 4) + 87;
  if (v283 < 0xA0)
    LOBYTE(v289) = (v283 >> 4) | 0x30;
  *v288 = v289;
  if ((v283 & 0xF) >= 0xA)
    v290 = (v283 & 0xF) + 87;
  else
    v290 = v283 & 0xF | 0x30;
  v288[1] = v290;
  v292 = a1[1];
  v291 = a1[2];
  v293 = (unint64_t)(v292 + 2);
  a1[1] = v292 + 2;
  v294 = (unint64_t)(v292 + 3);
  if (v291)
  {
    if (v294 >= *(_QWORD *)v291)
    {
      v295 = (const char *)malloc_type_realloc(*((void **)v291 + 2), (v293 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v296 = (char *)a1[2];
      *((_QWORD *)v296 + 2) = v295;
      *(_QWORD *)v296 = (v293 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v295;
    }
  }
  else
  {
    str_alloc(a1, v294);
  }
  v297 = *a1;
  ++a1[1];
  v297[v293] = 58;
  v298 = *(unsigned __int8 *)(a2 + 28);
  v300 = a1[1];
  v299 = a1[2];
  v301 = (unint64_t)(v300 + 2);
  if (v299)
  {
    if (v301 >= *(_QWORD *)v299)
    {
      v302 = (const char *)malloc_type_realloc(*((void **)v299 + 2), (unint64_t)(v300 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v303 = (char *)a1[2];
      *((_QWORD *)v303 + 2) = v302;
      *(_QWORD *)v303 = (unint64_t)(v300 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v302;
    }
  }
  else
  {
    str_alloc(a1, v301);
  }
  v304 = (char *)&v300[(_QWORD)*a1];
  v305 = (v298 >> 4) + 87;
  if (v298 < 0xA0)
    LOBYTE(v305) = (v298 >> 4) | 0x30;
  *v304 = v305;
  if ((v298 & 0xF) >= 0xA)
    v306 = (v298 & 0xF) + 87;
  else
    v306 = v298 & 0xF | 0x30;
  v304[1] = v306;
  v307 = a1[1];
  v308 = a1[2];
  v309 = v307 + 2;
  a1[1] = v307 + 2;
  v310 = *(unsigned __int8 *)(a2 + 29);
  v311 = (unint64_t)(v307 + 4);
  if (v308)
  {
    if (v311 >= *(_QWORD *)v308)
    {
      v312 = (unint64_t)(v307 + 259) & 0xFFFFFFFFFFFFFF00;
      v313 = (const char *)malloc_type_realloc(*((void **)v308 + 2), v312, 0xCCCD1039uLL);
      v314 = (char *)a1[2];
      *((_QWORD *)v314 + 2) = v313;
      *(_QWORD *)v314 = v312;
      *a1 = v313;
    }
  }
  else
  {
    str_alloc(a1, v311);
  }
  v315 = (char *)&v309[(_QWORD)*a1];
  v316 = (v310 >> 4) + 87;
  if (v310 < 0xA0)
    LOBYTE(v316) = (v310 >> 4) | 0x30;
  *v315 = v316;
  if ((v310 & 0xF) >= 0xA)
    v317 = (v310 & 0xF) + 87;
  else
    v317 = v310 & 0xF | 0x30;
  v315[1] = v317;
  v319 = a1[1];
  v318 = a1[2];
  v320 = (unint64_t)(v319 + 2);
  a1[1] = v319 + 2;
  v321 = (unint64_t)(v319 + 3);
  if (v318)
  {
    if (v321 >= *(_QWORD *)v318)
    {
      v322 = (const char *)malloc_type_realloc(*((void **)v318 + 2), (v320 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v323 = (char *)a1[2];
      *((_QWORD *)v323 + 2) = v322;
      *(_QWORD *)v323 = (v320 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v322;
    }
  }
  else
  {
    str_alloc(a1, v321);
  }
  v324 = *a1;
  ++a1[1];
  v324[v320] = 58;
  v325 = *(unsigned __int16 *)(a2 + 30);
  v327 = a1[1];
  v326 = a1[2];
  v328 = (unint64_t)(v327 + 4);
  if (v326)
  {
    if (v328 >= *(_QWORD *)v326)
    {
      v329 = (const char *)malloc_type_realloc(*((void **)v326 + 2), (unint64_t)(v327 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v330 = (char *)a1[2];
      *((_QWORD *)v330 + 2) = v329;
      *(_QWORD *)v330 = (unint64_t)(v327 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v329;
    }
  }
  else
  {
    str_alloc(a1, v328);
  }
  v331 = (char *)&v327[(_QWORD)*a1];
  v332 = (v325 >> 12) + 87;
  if (v325 < 0xA000)
    LOBYTE(v332) = (v325 >> 12) | 0x30;
  *v331 = v332;
  v333 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v325), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v334 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v333), (int8x8_t)(*(_QWORD *)&v333 | 0x3000000030), (int8x8_t)vadd_s32(v333, (int32x2_t)0x5700000057));
  v331[2] = v334.i8[4];
  v331[1] = v334.i8[0];
  if ((v325 & 0xF) >= 0xA)
    v335 = (v325 & 0xF) + 87;
  else
    v335 = v325 & 0xF | 0x30;
  v331[3] = v335;
  v337 = a1[1];
  v336 = a1[2];
  v338 = (unint64_t)(v337 + 4);
  a1[1] = v337 + 4;
  v339 = (unint64_t)(v337 + 5);
  if (v336)
  {
    if (v339 >= *(_QWORD *)v336)
    {
      v340 = (const char *)malloc_type_realloc(*((void **)v336 + 2), (v338 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v341 = (char *)a1[2];
      *((_QWORD *)v341 + 2) = v340;
      *(_QWORD *)v341 = (v338 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v340;
    }
  }
  else
  {
    str_alloc(a1, v339);
  }
  v342 = *a1;
  ++a1[1];
  v342[v338] = 58;
  v343 = *(unsigned __int16 *)(a2 + 32);
  v345 = a1[1];
  v344 = a1[2];
  v346 = (unint64_t)(v345 + 4);
  if (v344)
  {
    if (v346 >= *(_QWORD *)v344)
    {
      v347 = (const char *)malloc_type_realloc(*((void **)v344 + 2), (unint64_t)(v345 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v348 = (char *)a1[2];
      *((_QWORD *)v348 + 2) = v347;
      *(_QWORD *)v348 = (unint64_t)(v345 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v347;
    }
  }
  else
  {
    str_alloc(a1, v346);
  }
  v349 = (char *)&v345[(_QWORD)*a1];
  v350 = (v343 >> 12) + 87;
  if (v343 < 0xA000)
    LOBYTE(v350) = (v343 >> 12) | 0x30;
  *v349 = v350;
  v351 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v343), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v352 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v351), (int8x8_t)(*(_QWORD *)&v351 | 0x3000000030), (int8x8_t)vadd_s32(v351, (int32x2_t)0x5700000057));
  v349[2] = v352.i8[4];
  v349[1] = v352.i8[0];
  if ((v343 & 0xF) >= 0xA)
    v353 = (v343 & 0xF) + 87;
  else
    v353 = v343 & 0xF | 0x30;
  v349[3] = v353;
  v355 = a1[1];
  v354 = a1[2];
  v356 = (unint64_t)(v355 + 4);
  a1[1] = v355 + 4;
  v357 = (unint64_t)(v355 + 5);
  if (v354)
  {
    if (v357 >= *(_QWORD *)v354)
    {
      v358 = (const char *)malloc_type_realloc(*((void **)v354 + 2), (v356 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v359 = (char *)a1[2];
      *((_QWORD *)v359 + 2) = v358;
      *(_QWORD *)v359 = (v356 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v358;
    }
  }
  else
  {
    str_alloc(a1, v357);
  }
  v360 = *a1;
  ++a1[1];
  v360[v356] = 58;
  v361 = *(unsigned __int16 *)(a2 + 34);
  v363 = a1[1];
  v362 = a1[2];
  v364 = (unint64_t)(v363 + 4);
  if (v362)
  {
    if (v364 >= *(_QWORD *)v362)
    {
      v365 = (const char *)malloc_type_realloc(*((void **)v362 + 2), (unint64_t)(v363 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v366 = (char *)a1[2];
      *((_QWORD *)v366 + 2) = v365;
      *(_QWORD *)v366 = (unint64_t)(v363 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v365;
    }
  }
  else
  {
    str_alloc(a1, v364);
  }
  v367 = (char *)&v363[(_QWORD)*a1];
  v368 = (v361 >> 12) + 87;
  if (v361 < 0xA000)
    LOBYTE(v368) = (v361 >> 12) | 0x30;
  *v367 = v368;
  v369 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v361), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v370 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v369), (int8x8_t)(*(_QWORD *)&v369 | 0x3000000030), (int8x8_t)vadd_s32(v369, (int32x2_t)0x5700000057));
  v367[2] = v370.i8[4];
  v367[1] = v370.i8[0];
  if ((v361 & 0xF) >= 0xA)
    v371 = (v361 & 0xF) + 87;
  else
    v371 = v361 & 0xF | 0x30;
  v367[3] = v371;
  v373 = a1[1];
  v372 = a1[2];
  v374 = (unint64_t)(v373 + 4);
  a1[1] = v373 + 4;
  v375 = (unint64_t)(v373 + 5);
  if (v372)
  {
    if (v375 >= *(_QWORD *)v372)
    {
      v376 = (const char *)malloc_type_realloc(*((void **)v372 + 2), (v374 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v377 = (char *)a1[2];
      *((_QWORD *)v377 + 2) = v376;
      *(_QWORD *)v377 = (v374 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v376;
    }
  }
  else
  {
    str_alloc(a1, v375);
  }
  v378 = *a1;
  ++a1[1];
  v378[v374] = 58;
  v379 = *(unsigned __int16 *)(a2 + 36);
  v381 = a1[1];
  v380 = a1[2];
  v382 = (unint64_t)(v381 + 4);
  if (v380)
  {
    if (v382 >= *(_QWORD *)v380)
    {
      v383 = (const char *)malloc_type_realloc(*((void **)v380 + 2), (unint64_t)(v381 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v384 = (char *)a1[2];
      *((_QWORD *)v384 + 2) = v383;
      *(_QWORD *)v384 = (unint64_t)(v381 + 259) & 0xFFFFFFFFFFFFFF00;
      *a1 = v383;
    }
  }
  else
  {
    str_alloc(a1, v382);
  }
  v385 = (char *)&v381[(_QWORD)*a1];
  v386 = (v379 >> 12) + 87;
  if (v379 < 0xA000)
    LOBYTE(v386) = (v379 >> 12) | 0x30;
  *v385 = v386;
  v387 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v379), (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000FLL);
  v388 = (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v387);
  *(int32x2_t *)v207.i8 = vadd_s32(v387, (int32x2_t)0x5700000057);
  v389 = COERCE_DOUBLE(vbsl_s8(v388, (int8x8_t)(*(_QWORD *)&v387 | 0x3000000030), *(int8x8_t *)v207.i8));
  v385[2] = BYTE4(v389);
  v385[1] = LOBYTE(v389);
  if ((v379 & 0xF) >= 0xA)
    v390 = (v379 & 0xF) + 87;
  else
    v390 = v379 & 0xF | 0x30;
  v385[3] = v390;
  v392 = a1[1];
  v391 = a1[2];
  v393 = (unint64_t)(v392 + 4);
  a1[1] = v392 + 4;
  v394 = (unint64_t)(v392 + 5);
  if (v391)
  {
    if (v394 >= *(_QWORD *)v391)
    {
      v395 = (const char *)malloc_type_realloc(*((void **)v391 + 2), (v393 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v396 = (char *)a1[2];
      *((_QWORD *)v396 + 2) = v395;
      *(_QWORD *)v396 = (v393 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v395;
    }
  }
  else
  {
    str_alloc(a1, v394);
  }
  v397 = *a1;
  ++a1[1];
  v397[v393] = 58;
  v398 = *(unsigned __int8 *)(a2 + 40);
  v400 = a1[1];
  v399 = a1[2];
  v401 = (unint64_t)(v400 + 2);
  if (v399)
  {
    if (v401 >= *(_QWORD *)v399)
    {
      v402 = (const char *)malloc_type_realloc(*((void **)v399 + 2), (unint64_t)(v400 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v403 = (char *)a1[2];
      *((_QWORD *)v403 + 2) = v402;
      *(_QWORD *)v403 = (unint64_t)(v400 + 257) & 0xFFFFFFFFFFFFFF00;
      *a1 = v402;
    }
  }
  else
  {
    str_alloc(a1, v401);
  }
  v404 = (char *)&v400[(_QWORD)*a1];
  v405 = (v398 >> 4) + 87;
  if (v398 < 0xA0)
    LOBYTE(v405) = (v398 >> 4) | 0x30;
  *v404 = v405;
  if ((v398 & 0xF) >= 0xA)
    v406 = (v398 & 0xF) + 87;
  else
    v406 = v398 & 0xF | 0x30;
  v404[1] = v406;
  v408 = a1[1];
  v407 = a1[2];
  v409 = (unint64_t)(v408 + 2);
  a1[1] = v408 + 2;
  v410 = (unint64_t)(v408 + 3);
  if (v407)
  {
    if (v410 >= *(_QWORD *)v407)
    {
      v411 = (const char *)malloc_type_realloc(*((void **)v407 + 2), (v409 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v412 = (char *)a1[2];
      *((_QWORD *)v412 + 2) = v411;
      *(_QWORD *)v412 = (v409 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v411;
    }
  }
  else
  {
    str_alloc(a1, v410);
  }
  v413 = *a1;
  ++a1[1];
  v413[v409] = 58;
  v414 = *(_BYTE *)(a2 + 41);
  v416 = (unint64_t)a1[1];
  v415 = a1[2];
  v417 = v416 + 1;
  if (v415)
  {
    if (v417 >= *(_QWORD *)v415)
    {
      v418 = (const char *)malloc_type_realloc(*((void **)v415 + 2), (v416 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v419 = (char *)a1[2];
      *((_QWORD *)v419 + 2) = v418;
      *(_QWORD *)v419 = (v416 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v418;
    }
  }
  else
  {
    str_alloc(a1, v417);
  }
  if ((v414 & 0xFu) >= 0xA)
    v420 = (v414 & 0xF) + 87;
  else
    v420 = v414 & 0xF | 0x30;
  (*a1)[v416] = v420;
  v422 = a1[1];
  v421 = a1[2];
  v423 = (unint64_t)(v422 + 1);
  a1[1] = v422 + 1;
  v424 = (unint64_t)(v422 + 2);
  if (v421)
  {
    if (v424 >= *(_QWORD *)v421)
    {
      v425 = (const char *)malloc_type_realloc(*((void **)v421 + 2), (v423 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v426 = (char *)a1[2];
      *((_QWORD *)v426 + 2) = v425;
      *(_QWORD *)v426 = (v423 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v425;
    }
  }
  else
  {
    str_alloc(a1, v424);
  }
  v427 = *a1;
  ++a1[1];
  v427[v423] = 58;
  v428 = *(_BYTE *)(a2 + 42);
  v430 = (unint64_t)a1[1];
  v429 = a1[2];
  v431 = v430 + 1;
  if (v429)
  {
    if (v431 >= *(_QWORD *)v429)
    {
      v432 = (const char *)malloc_type_realloc(*((void **)v429 + 2), (v430 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v433 = (char *)a1[2];
      *((_QWORD *)v433 + 2) = v432;
      *(_QWORD *)v433 = (v430 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v432;
    }
  }
  else
  {
    str_alloc(a1, v431);
  }
  if ((v428 & 0xFu) >= 0xA)
    v434 = (v428 & 0xF) + 87;
  else
    v434 = v428 & 0xF | 0x30;
  (*a1)[v430] = v434;
  v436 = a1[1];
  v435 = a1[2];
  v437 = (unint64_t)(v436 + 1);
  a1[1] = v436 + 1;
  v438 = (unint64_t)(v436 + 2);
  if (v435)
  {
    if (v438 >= *(_QWORD *)v435)
    {
      v439 = (const char *)malloc_type_realloc(*((void **)v435 + 2), (v437 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v440 = (char *)a1[2];
      *((_QWORD *)v440 + 2) = v439;
      *(_QWORD *)v440 = (v437 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v439;
    }
  }
  else
  {
    str_alloc(a1, v438);
  }
  v441 = *a1;
  ++a1[1];
  v441[v437] = 58;
  v442 = *(_BYTE *)(a2 + 43);
  v444 = (unint64_t)a1[1];
  v443 = a1[2];
  v445 = v444 + 1;
  if (v443)
  {
    if (v445 >= *(_QWORD *)v443)
    {
      v446 = (const char *)malloc_type_realloc(*((void **)v443 + 2), (v444 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v447 = (char *)a1[2];
      *((_QWORD *)v447 + 2) = v446;
      *(_QWORD *)v447 = (v444 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v446;
    }
  }
  else
  {
    str_alloc(a1, v445);
  }
  if ((v442 & 0xFu) >= 0xA)
    v448 = (v442 & 0xF) + 87;
  else
    v448 = v442 & 0xF | 0x30;
  (*a1)[v444] = v448;
  v450 = a1[1];
  v449 = a1[2];
  v451 = (unint64_t)(v450 + 1);
  a1[1] = v450 + 1;
  v452 = (unint64_t)(v450 + 2);
  if (!v449)
  {
    str_alloc(a1, v452);
    v456 = *a1;
    ++a1[1];
    v456[v451] = 10;
    if ((a4 & 1) != 0)
      return;
LABEL_256:
    str_close(a1, v389, *(double *)&v388, (uint32x4_t)v207);
    return;
  }
  if (v452 >= *(_QWORD *)v449)
  {
    v453 = (const char *)malloc_type_realloc(*((void **)v449 + 2), (v451 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
    v454 = (char *)a1[2];
    *((_QWORD *)v454 + 2) = v453;
    *(_QWORD *)v454 = (v451 & 0xFFFFFFFFFFFFFF00) + 256;
    *a1 = v453;
  }
  v455 = *a1;
  ++a1[1];
  v455[v451] = 10;
  if ((a4 & 1) == 0)
    goto LABEL_256;
}

void HGString::HGString(HGString *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
}

void HGString::HGString(HGString *this, HGString *a2, int a3, unsigned int a4)
{
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  void *v14;
  size_t *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  size_t v19;
  void *v20;
  size_t *v21;
  uint64_t v22;
  double v23;
  double v24;
  uint32x4_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  void *v36;
  unint64_t *v37;
  uint64_t v38;
  _OWORD *v39;
  __int128 v40;
  __int128 v41;
  uint32x4_t v42;
  __int128 v43;

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  if (a2)
  {
    v8 = HGString::isdistilled(a2, (const char *)a2);
    v9 = v8;
    if (v8)
    {
      if (a4 != 255 || a3)
      {
        str_alloc((string_t *)this, v8);
        if (a4 == 255)
        {
          v11 = *((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
          v12 = v11 + v9;
          if (v10)
          {
            if (v12 >= *(_QWORD *)v10)
            {
              v13 = (v12 + 255) & 0xFFFFFFFFFFFFFF00;
              v14 = malloc_type_realloc(*(void **)(v10 + 16), v13, 0xCCCD1039uLL);
              v15 = (size_t *)*((_QWORD *)this + 2);
              v15[2] = (size_t)v14;
              *v15 = v13;
              *(_QWORD *)this = v14;
            }
          }
          else
          {
            str_alloc((string_t *)this, v12);
          }
          v22 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += v9;
          memcpy((void *)(v22 + v11), a2, v9);
          str_close((string_t *)this, v23, v24, v25);
        }
        else
        {
          v17 = *((_QWORD *)this + 1);
          v16 = *((_QWORD *)this + 2);
          v18 = v17 + v9 - 72;
          if (v16)
          {
            if (v18 >= *(_QWORD *)v16)
            {
              v19 = (v18 + 255) & 0xFFFFFFFFFFFFFF00;
              v20 = malloc_type_realloc(*(void **)(v16 + 16), v19, 0xCCCD1039uLL);
              v21 = (size_t *)*((_QWORD *)this + 2);
              v21[2] = (size_t)v20;
              *v21 = v19;
              *(_QWORD *)this = v20;
            }
          }
          else
          {
            str_alloc((string_t *)this, v18);
          }
          v26 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += v9 - 72;
          memcpy((void *)(v26 + v17), a2, v9 - 72);
          v28 = *((_QWORD *)this + 1);
          v27 = *((_QWORD *)this + 2);
          v29 = v28 + 8;
          if (v27)
          {
            if (v29 >= *(_QWORD *)v27)
            {
              v30 = malloc_type_realloc(*(void **)(v27 + 16), (v28 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v31 = (unint64_t *)*((_QWORD *)this + 2);
              v31[2] = (unint64_t)v30;
              *v31 = (v28 + 263) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v30;
            }
          }
          else
          {
            str_alloc((string_t *)this, v29);
          }
          v32 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 8;
          *(_QWORD *)(v32 + v28) = 0x3030303030303030;
          v34 = *((_QWORD *)this + 1);
          v33 = *((_QWORD *)this + 2);
          v35 = v34 + 64;
          if (v33)
          {
            if (v35 >= *(_QWORD *)v33)
            {
              v36 = malloc_type_realloc(*(void **)(v33 + 16), (v34 + 319) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v37 = (unint64_t *)*((_QWORD *)this + 2);
              v37[2] = (unint64_t)v36;
              *v37 = (v34 + 319) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v36;
            }
          }
          else
          {
            str_alloc((string_t *)this, v35);
          }
          v38 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 64;
          v39 = (_OWORD *)(v38 + v34);
          v40 = *(_OWORD *)((char *)a2 + v9 - 64);
          v41 = *(_OWORD *)((char *)a2 + v9 - 48);
          v42 = *(uint32x4_t *)((char *)a2 + v9 - 32);
          v43 = *(_OWORD *)((char *)a2 + v9 - 16);
          v39[2] = v42;
          v39[3] = v43;
          *v39 = v40;
          v39[1] = v41;
          str_close((string_t *)this, *(double *)&v40, *(double *)&v41, v42);
        }
      }
      else
      {
        *(_QWORD *)this = a2;
        *((_QWORD *)this + 1) = v8;
      }
    }
    else
    {
      HGString::_distill(this, (char *)a2, a4);
    }
  }
}

void sub_1B2A0D634(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(_QWORD *)(v1 + 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void str_alloc(string_t *a1, uint64_t a2)
{
  size_t v3;
  string_t v4;
  char *v5;
  char *v6;
  void *v7;
  void *v8;
  string_t v9;
  string_t v10;

  v3 = (a2 + 255) & 0xFFFFFFFFFFFFFF00;
  v4 = a1[2];
  if (v4 && *((_QWORD *)v4 + 1) < 2uLL)
  {
    v5 = (char *)malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
    *((_QWORD *)v5 + 2) = malloc_type_realloc(*((void **)a1[2] + 2), v3, 0xBA3C7595uLL);
    v6 = (char *)a1[2];
    *(_QWORD *)v5 = v3;
    *((_QWORD *)v5 + 1) = 1;
    a1[2] = v5;
    free(v6);
    *a1 = (string_t)*((_QWORD *)v5 + 2);
  }
  else
  {
    v7 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
    v8 = malloc_type_malloc(v3, 0x2BEB8FE7uLL);
    *((_QWORD *)v7 + 2) = v8;
    bzero(v8, v3);
    *((_QWORD *)v7 + 1) = 1;
    v9 = a1[1];
    if (v9)
      memcpy(*((void **)v7 + 2), *a1, (size_t)v9);
    v10 = a1[2];
    if (v10)
      --*((_QWORD *)v10 + 1);
    *(_QWORD *)v7 = v3;
    a1[2] = (string_t)v7;
    *a1 = (string_t)*((_QWORD *)v7 + 2);
  }
}

uint64_t str_close(string_t *a1, double a2, double a3, uint32x4_t a4)
{
  string_t v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  char *v9;
  unsigned int v10;
  uint32x2_t v11;
  uint32x2_t v12;
  int8x16_t v13;
  unsigned __int32 v14;
  int8x16_t v15;
  uint32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int8x16_t v19;
  int32x4_t v20;

  v6 = (unint64_t)a1[1];
  v5 = a1[2];
  v7 = v6 + 1;
  if (v5)
  {
    if (v7 >= *(_QWORD *)v5)
    {
      v8 = (const char *)malloc_type_realloc(*((void **)v5 + 2), (v6 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v9 = (char *)a1[2];
      *((_QWORD *)v9 + 2) = v8;
      *(_QWORD *)v9 = (v6 & 0xFFFFFFFFFFFFFF00) + 256;
      *a1 = v8;
    }
  }
  else
  {
    str_alloc(a1, v7);
  }
  (*a1)[v6] = 0;
  *((_BYTE *)*a1 + 22) = 48;
  *((_BYTE *)*a1 + 23) = 48;
  v10 = *((_DWORD *)a1 + 2);
  v11 = (uint32x2_t)vdup_n_s32(v10);
  v12 = vshl_u32(v11, (uint32x2_t)0xFFFFFFF0FFFFFFECLL);
  *(uint32x2_t *)v13.i8 = vshl_u32(v11, (uint32x2_t)0xFFFFFFF8FFFFFFF4);
  a4.i64[0] = v10 | 0xFFFFFFF800000000;
  v14 = vshrq_n_u32(a4, 0x1CuLL).u32[0];
  a4.i32[1] = HIBYTE(v10);
  a4.u64[1] = (unint64_t)v12;
  v13.i32[2] = v10 >> 4;
  v13.i32[3] = v10;
  v15.i64[0] = 0xF0000000FLL;
  v15.i64[1] = 0xF0000000FLL;
  v16 = (uint32x4_t)vandq_s8((int8x16_t)a4, v15);
  v17 = (int32x4_t)v16;
  v17.i32[0] = v14;
  v16.i32[0] = v10;
  v18 = (int32x4_t)vandq_s8(v13, v15);
  v19 = (int8x16_t)vcgtq_u32((uint32x4_t)xmmword_1B309D9E0, v16);
  v16.i64[0] = 0xA0000000ALL;
  v16.i64[1] = 0xA0000000ALL;
  v20.i64[0] = 0x5700000057;
  v20.i64[1] = 0x5700000057;
  *((int8x8_t *)*a1 + 3) = vmovn_s16(vuzp1q_s16((int16x8_t)vbslq_s8(v19, (int8x16_t)(*(_OWORD *)&v17 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v17, v20)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v16, (uint32x4_t)v18), (int8x16_t)(*(_OWORD *)&v18 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v18, v20))));
  return (uint64_t)*a1;
}

void HGString::HGString(HGString *this, const HGString *a2)
{
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  int64_t v7;
  char *v8;
  char *v9;

  v3 = *((_QWORD *)a2 + 1);
  *(_QWORD *)this = *(_QWORD *)a2;
  *((_QWORD *)this + 1) = v3;
  v4 = *((_QWORD *)a2 + 2);
  if (v4)
    ++*(_QWORD *)(v4 + 8);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = v4;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  v6 = (_BYTE *)*((_QWORD *)a2 + 3);
  v5 = (_BYTE *)*((_QWORD *)a2 + 4);
  v7 = v5 - v6;
  if (v5 != v6)
  {
    if (v7 < 0)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v8 = (char *)operator new(v5 - v6);
    *((_QWORD *)this + 3) = v8;
    *((_QWORD *)this + 4) = v8;
    v9 = &v8[2 * (v7 >> 1)];
    *((_QWORD *)this + 5) = v9;
    memcpy(v8, v6, v7);
    *((_QWORD *)this + 4) = v9;
  }
}

void sub_1B2A0D938(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void HGString::~HGString(HGString *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v2 = *((_QWORD *)this + 2);
  if (v2 && (v3 = *(_QWORD *)(v2 + 8) - 1, (*(_QWORD *)(v2 + 8) = v3) == 0))
  {
    free(*(void **)(v2 + 16));
    free(*((void **)this + 2));
    v4 = (void *)*((_QWORD *)this + 3);
    if (!v4)
      return;
  }
  else
  {
    v4 = (void *)*((_QWORD *)this + 3);
    if (!v4)
      return;
  }
  *((_QWORD *)this + 4) = v4;
  operator delete(v4);
}

string_t *HGString::set(string_t *this, HGString *a2, const char *a3, int a4, unsigned int a5)
{
  uint64_t v10;
  size_t v11;
  string_t v12;
  const char *v13;
  char *v14;
  string_t v15;
  string_t v17;
  uint64_t v18;
  size_t v19;
  string_t v20;
  const char *v21;
  char *v22;
  string_t v23;
  uint64_t v24;
  void *v25;
  string_t v26;
  string_t v27;
  unint64_t v28;
  const char *v29;
  char *v30;
  char *v31;
  unsigned int v32;
  char v33;
  char v34;
  string_t v35;
  string_t v36;
  string_t v37;
  uint32x4_t *v38;
  unint64_t v39;
  size_t v40;
  const char *v41;
  char *v42;
  uint64_t v43;
  uint32x4_t *v44;
  uint32x4_t v45;
  uint32x4_t v46;
  uint32x4_t v47;
  uint32x4_t v48;
  void *v49;

  if (*this != (string_t)a2)
  {
    if (a2)
    {
      v10 = HGString::isdistilled(a2, (const char *)a2);
      if (!v10)
      {
        this[1] = 0;
        HGString::_distill((HGString *)this, (char *)a2, a5);
        return this;
      }
      v11 = v10;
      str_alloc(this, v10);
      if (a5 != 255)
      {
        this[1] = 0;
        v19 = v11 - 72;
        v20 = this[2];
        if (v20)
        {
          if (v19 >= *(_QWORD *)v20)
          {
            v21 = (const char *)malloc_type_realloc(*((void **)v20 + 2), (v11 + 183) & 0x1FFFFFF00, 0xCCCD1039uLL);
            v22 = (char *)this[2];
            *((_QWORD *)v22 + 2) = v21;
            *(_QWORD *)v22 = (v11 + 183) & 0x1FFFFFF00;
            *this = v21;
          }
        }
        else
        {
          str_alloc(this, v11 - 72);
        }
        v25 = (void *)*this;
        this[1] += v19;
        memcpy(v25, a2, v11 - 72);
        v27 = this[1];
        v26 = this[2];
        v28 = (unint64_t)(v27 + 8);
        if (v26)
        {
          if (v28 >= *(_QWORD *)v26)
          {
            v29 = (const char *)malloc_type_realloc(*((void **)v26 + 2), (unint64_t)(v27 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v30 = (char *)this[2];
            *((_QWORD *)v30 + 2) = v29;
            *(_QWORD *)v30 = (unint64_t)(v27 + 263) & 0xFFFFFFFFFFFFFF00;
            *this = v29;
          }
        }
        else
        {
          str_alloc(this, v28);
        }
        v31 = (char *)&v27[(_QWORD)*this];
        v32 = a5 >> 4;
        if (v32 >= 0xA)
          v33 = v32 + 87;
        else
          v33 = (a5 >> 4) | 0x30;
        *((_WORD *)v31 + 2) = 12336;
        *(_DWORD *)v31 = 808464432;
        v31[6] = v33;
        if ((a5 & 0xF) >= 0xA)
          v34 = (a5 & 0xF) + 87;
        else
          v34 = a5 & 0xF | 0x30;
        v31[7] = v34;
        v35 = this[1];
        v36 = this[2];
        v37 = v35 + 8;
        this[1] = v35 + 8;
        v38 = (uint32x4_t *)((char *)a2 + v11 - 64);
        v39 = (unint64_t)(v35 + 72);
        if (v36)
        {
          if (v39 >= *(_QWORD *)v36)
          {
            v40 = (unint64_t)(v35 + 327) & 0xFFFFFFFFFFFFFF00;
            v41 = (const char *)malloc_type_realloc(*((void **)v36 + 2), v40, 0xCCCD1039uLL);
            v42 = (char *)this[2];
            *((_QWORD *)v42 + 2) = v41;
            *(_QWORD *)v42 = v40;
            *this = v41;
          }
        }
        else
        {
          str_alloc(this, v39);
        }
        v43 = (uint64_t)*this;
        this[1] += 64;
        v44 = (uint32x4_t *)&v37[v43];
        v45 = *v38;
        v46 = v38[1];
        v47 = v38[2];
        v48 = v38[3];
        v44[2] = v47;
        v44[3] = v48;
        *v44 = v45;
        v44[1] = v46;
        goto LABEL_46;
      }
      if (a4)
      {
        this[1] = 0;
        v12 = this[2];
        if (v12)
        {
          if (v11 >= *(_QWORD *)v12)
          {
            v13 = (const char *)malloc_type_realloc(*((void **)v12 + 2), (v11 + 255) & 0x1FFFFFF00, 0xCCCD1039uLL);
            v14 = (char *)this[2];
            *((_QWORD *)v14 + 2) = v13;
            *(_QWORD *)v14 = (v11 + 255) & 0x1FFFFFF00;
            *this = v13;
          }
        }
        else
        {
          str_alloc(this, v11);
        }
        v49 = (void *)*this;
        this[1] += v11;
        memcpy(v49, a2, v11);
LABEL_46:
        str_close(this, *(double *)v45.i64, *(double *)v46.i64, v47);
        return this;
      }
      v23 = this[2];
      if (v23)
      {
        v24 = *((_QWORD *)v23 + 1) - 1;
        *((_QWORD *)v23 + 1) = v24;
        if (!v24)
        {
          free(*((void **)v23 + 2));
          free((void *)this[2]);
        }
      }
      *this = (string_t)a2;
      this[1] = a3;
    }
    else
    {
      v17 = this[2];
      if (v17)
      {
        v18 = *((_QWORD *)v17 + 1) - 1;
        *((_QWORD *)v17 + 1) = v18;
        if (!v18)
        {
          free(*((void **)v17 + 2));
          free((void *)this[2]);
        }
      }
      *this = 0;
      this[1] = 0;
    }
    this[2] = 0;
    return this;
  }
  if (a2)
  {
    v15 = this[1];
    if (v15)
    {
      if (!a5
        && ctype[2 * *((unsigned __int8 *)a2 + (_QWORD)v15 - 65)] & 0xF | (16
                                                                                          * ctype[2
                                                                                                * *((unsigned __int8 *)a2
                                                                                                  + (_QWORD)v15
                                                                                                  - 66)]))
      {
        str_alloc(this, (uint64_t)v15);
        *(_QWORD *)&(*this)[(_QWORD)this[1] - 72] = 0x3030303030303030;
      }
    }
  }
  return this;
}

uint64_t HGString::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *a2;
  if (*(_QWORD *)a1 != *a2)
  {
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
    {
      v6 = *(_QWORD *)(v5 + 8) - 1;
      *(_QWORD *)(v5 + 8) = v6;
      if (!v6)
      {
        free(*(void **)(v5 + 16));
        free(*(void **)(a1 + 16));
        v3 = *a2;
      }
    }
    v8 = a2[1];
    v7 = a2[2];
    *(_QWORD *)a1 = v3;
    *(_QWORD *)(a1 + 8) = v8;
    *(_QWORD *)(a1 + 16) = v7;
    if (v7)
      ++*(_QWORD *)(v7 + 8);
  }
  return a1;
}

unint64_t HGString::hash(HGString *this, uint8x8_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint32x4_t v5;
  int64x2_t v6;
  int64x2_t v7;
  int8x16_t v8;
  int64x2_t v9;
  int64x2_t v10;
  int64x2_t v11;
  int64x2_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int8x16_t v27;
  uint8x8_t v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  uint32x4_t v33;
  int64x2_t v34;
  int64x2_t v35;
  int64x2_t v36;
  int64x2_t v37;
  int64x2_t v38;
  uint64x2_t v39;
  int64x2_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int8x16_t v54;

  v2 = *(_QWORD *)this + *((_QWORD *)this + 1);
  v3 = *(char *)(v2 - 132);
  if (v3 <= 96)
    v4 = 0;
  else
    v4 = 9;
  a2.i32[0] = *(_DWORD *)(v2 - 131);
  v5 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a2));
  v6.i64[0] = v5.u32[0];
  v6.i64[1] = v5.u32[1];
  v7 = v6;
  v8.i64[0] = 255;
  v8.i64[1] = 255;
  v9.i64[0] = vandq_s8((int8x16_t)v6, v8).u64[0];
  v6.i64[0] = v5.u32[2];
  v6.i64[1] = v5.u32[3];
  v10 = vshlq_n_s64(v6, 0x38uLL);
  v11 = vshrq_n_s64(vshlq_n_s64(v7, 0x38uLL), 0x38uLL);
  v9.i64[1] = v11.i64[1];
  v12 = vdupq_n_s64(0x60uLL);
  v13 = (int8x16_t)vdupq_n_s64(0xFFFFFFD9uLL);
  v14 = (int8x16_t)vaddq_s64((int64x2_t)vshlq_u64((uint64x2_t)vsraq_n_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(vshrq_n_s64(v10, 0x38uLL), v12), v13), v10, 0x38uLL), (uint64x2_t)xmmword_1B309DA10), (int64x2_t)xmmword_1B309DA20);
  v15 = (int8x16_t)vaddq_s64((int64x2_t)vshlq_u64((uint64x2_t)vaddq_s64(v9, (int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(v11, v12), (int8x16_t)xmmword_1B309D9F0)), (uint64x2_t)xmmword_1B309DA00), (int64x2_t)xmmword_1B309DA30);
  v16 = *(char *)(v2 - 127);
  v17 = v16 - 48;
  if (v16 <= 96)
    v18 = 0;
  else
    v18 = -39;
  v19 = (v17 + v18) << 8;
  v20 = *(char *)(v2 - 126);
  v21 = v20 - 48;
  if (v20 <= 96)
    v22 = 0;
  else
    v22 = -39;
  v23 = v21 + v22;
  v24 = *(char *)(v2 - 125);
  v25 = v24 - 48;
  if (v24 <= 96)
    v26 = 0;
  else
    v26 = -39;
  v27 = vorrq_s8(v15, v14);
  v28 = (uint8x8_t)vorr_s8(*(int8x8_t *)v27.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
  v29 = v28.i32[0] | ((v4 + v3) << 28) | v19 | (16 * v23) | (v25 + v26);
  v30 = *(char *)(v2 - 123);
  if (v30 <= 96)
    v31 = 0;
  else
    v31 = 9;
  v32 = v31 + v30;
  v28.i32[0] = *(_DWORD *)(v2 - 122);
  v33 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v28));
  v34.i64[0] = v33.u32[0];
  v34.i64[1] = v33.u32[1];
  v35 = v34;
  v36.i64[0] = vandq_s8((int8x16_t)v34, v8).u64[0];
  v34.i64[0] = v33.u32[2];
  v34.i64[1] = v33.u32[3];
  v37 = vshlq_n_s64(v34, 0x38uLL);
  v38 = vshrq_n_s64(vshlq_n_s64(v35, 0x38uLL), 0x38uLL);
  v36.i64[1] = v38.i64[1];
  v39 = (uint64x2_t)vsraq_n_s64((int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(vshrq_n_s64(v37, 0x38uLL), v12), v13), v37, 0x38uLL);
  v40 = (int64x2_t)vshlq_u64((uint64x2_t)vaddq_s64(v36, (int64x2_t)vandq_s8((int8x16_t)vcgtq_s64(v38, v12), (int8x16_t)xmmword_1B309D9F0)), (uint64x2_t)xmmword_1B309DA00);
  v41 = (int8x16_t)vaddq_s64((int64x2_t)vshlq_u64(v39, (uint64x2_t)xmmword_1B309DA10), (int64x2_t)xmmword_1B309DA20);
  v42 = (int8x16_t)vaddq_s64(v40, (int64x2_t)xmmword_1B309DA30);
  v43 = *(char *)(v2 - 118);
  v44 = v43 - 48;
  if (v43 <= 96)
    v45 = 0;
  else
    v45 = -39;
  v46 = (v44 + v45) << 8;
  v47 = *(char *)(v2 - 117);
  v48 = v47 - 48;
  if (v47 <= 96)
    v49 = 0;
  else
    v49 = -39;
  v50 = v48 + v49;
  v51 = *(char *)(v2 - 116);
  v52 = v51 - 48;
  if (v51 <= 96)
    v53 = 0;
  else
    v53 = -39;
  v54 = vorrq_s8(v42, v41);
  return v29 | ((unint64_t)(vorr_s8(*(int8x8_t *)v54.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)).u32[0] | (v32 << 28) | v46 | (16 * v50) | (v52 + v53)) << 32);
}

uint64_t HGString::Digest::isunpremult(HGString::Digest *this)
{
  return (*((unsigned __int8 *)this + 23) >> 4) & 1;
}

string_t HGString::c_str(string_t *this, double a2, double a3, uint32x4_t a4)
{
  if (!*this || this[2] || this[1][(_QWORD)*this])
    return (string_t)str_close(this, a2, a3, a4);
  else
    return *this;
}

uint64_t HGString::signature@<X0>(HGString **this@<X0>, uint64_t a2@<X8>)
{
  HGString *v4;
  unsigned int v5;
  HGString *v6;
  int v7;
  char *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  __int16 v103;
  __int16 v104;
  int v105;
  __int16 v106;
  __int16 v107;
  int v108;
  __int16 v109;
  __int16 v110;
  int v111;
  __int16 v112;
  int v113;
  __int16 v114;
  __int16 v115;
  int v116;
  __int16 v117;
  __int16 v118;
  int v119;
  __int16 v120;
  __int16 v121;
  int v122;
  __int16 v123;
  unsigned __int16 v124;
  int v125;
  __int16 v126;
  __int16 v127;
  int v128;
  __int16 v129;
  __int16 v130;
  int v131;
  __int16 v132;
  __int16 v133;
  int v134;
  __int16 v135;
  int v136;
  char v137;
  char v138;
  int v139;
  char v140;
  int v141;
  char v142;
  char v143;
  int v144;
  char v145;
  int v146;
  char v147;
  char v148;
  int v149;
  char v150;
  int v151;
  char v152;
  char v153;
  int v154;
  char v155;
  int v156;
  __int16 v157;
  __int16 v158;
  int v159;
  __int16 v160;
  __int16 v161;
  int v162;
  __int16 v163;
  __int16 v164;
  int v165;
  __int16 v166;
  int v167;
  __int16 v168;
  __int16 v169;
  int v170;
  __int16 v171;
  __int16 v172;
  int v173;
  __int16 v174;
  __int16 v175;
  int v176;
  __int16 v177;
  int v178;
  __int16 v179;
  __int16 v180;
  int v181;
  __int16 v182;
  __int16 v183;
  int v184;
  __int16 v185;
  __int16 v186;
  int v187;
  __int16 v188;
  int v189;
  __int16 v190;
  __int16 v191;
  int v192;
  __int16 v193;
  __int16 v194;
  int v195;
  __int16 v196;
  __int16 v197;
  int v198;
  uint64_t result;
  unsigned __int16 v200;
  int v201;
  char v202;
  char v203;
  int v204;
  char v205;
  int v206;
  char v207;
  int v208;
  char v209;
  int v210;
  char v211;

  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v4 = *this;
  if (v4)
  {
    v5 = HGString::target(v4, (const char *)(this[1] != 0));
    *(_DWORD *)a2 = v5;
    v6 = *this;
    if (v5)
    {
      v7 = 0;
      v8 = (char *)this[1] + (_QWORD)v6 - 90;
      goto LABEL_6;
    }
  }
  else
  {
    v6 = 0;
  }
  v8 = (char *)v6 + 48;
  v7 = 1;
LABEL_6:
  v9 = *v8;
  if (v9 <= 96)
    v10 = 0;
  else
    v10 = 9;
  v11 = v10 + v9;
  v12 = v8[1];
  if (v12 <= 96)
    v13 = 0;
  else
    v13 = 217;
  v14 = (((v12 + v13) << 24) - 805306368) | (v11 << 28);
  v15 = v8[2];
  if (v15 <= 96)
    v16 = 0;
  else
    v16 = -39;
  v17 = ((v15 + v16) << 20) - 50331648;
  v18 = v8[3];
  if (v18 <= 96)
    v19 = 0;
  else
    v19 = -39;
  v20 = v17 | (((v18 + v19) << 16) - 3145728);
  v21 = v8[4];
  if (v21 <= 96)
    v22 = 0;
  else
    v22 = -39;
  v23 = v14 | v20 | (((v21 + v22) << 12) - 196608);
  v24 = v8[5];
  if (v24 <= 96)
    v25 = 0;
  else
    v25 = -39;
  v26 = ((v24 + v25) << 8) - 12288;
  v27 = v8[6];
  if (v27 <= 96)
    v28 = 0;
  else
    v28 = -39;
  v29 = v26 | (16 * (v27 + v28) - 768);
  v30 = v8[7];
  if (v30 <= 96)
    v31 = 0;
  else
    v31 = -39;
  *(_DWORD *)(a2 + 4) = v23 | v29 | (v30 + v31 - 48);
  v32 = v8[9];
  if (v32 <= 96)
    v33 = 0;
  else
    v33 = 9;
  v34 = v33 + v32;
  v35 = v8[10];
  if (v35 <= 96)
    v36 = 0;
  else
    v36 = 217;
  v37 = (((v35 + v36) << 24) - 805306368) | (v34 << 28);
  v38 = v8[11];
  if (v38 <= 96)
    v39 = 0;
  else
    v39 = -39;
  v40 = ((v38 + v39) << 20) - 50331648;
  v41 = v8[12];
  if (v41 <= 96)
    v42 = 0;
  else
    v42 = -39;
  v43 = v40 | (((v41 + v42) << 16) - 3145728);
  v44 = v8[13];
  if (v44 <= 96)
    v45 = 0;
  else
    v45 = -39;
  v46 = v37 | v43 | (((v44 + v45) << 12) - 196608);
  v47 = v8[14];
  if (v47 <= 96)
    v48 = 0;
  else
    v48 = -39;
  v49 = ((v47 + v48) << 8) - 12288;
  v50 = v8[15];
  if (v50 <= 96)
    v51 = 0;
  else
    v51 = -39;
  v52 = v49 | (16 * (v50 + v51) - 768);
  v53 = v8[16];
  if (v53 <= 96)
    v54 = 0;
  else
    v54 = -39;
  v55 = v46 | v52 | (v53 + v54 - 48);
  *(_DWORD *)(a2 + 8) = v55;
  v56 = v8[18];
  if (v56 <= 96)
    v57 = 0;
  else
    v57 = 9;
  v58 = v57 + v56;
  v59 = v8[19];
  if (v59 <= 96)
    v60 = 0;
  else
    v60 = 217;
  v61 = (((v59 + v60) << 24) - 805306368) | (v58 << 28);
  v62 = v8[20];
  if (v62 <= 96)
    v63 = 0;
  else
    v63 = -39;
  v64 = ((v62 + v63) << 20) - 50331648;
  v65 = v8[21];
  if (v65 <= 96)
    v66 = 0;
  else
    v66 = -39;
  v67 = v64 | (((v65 + v66) << 16) - 3145728);
  v68 = v8[22];
  if (v68 <= 96)
    v69 = 0;
  else
    v69 = -39;
  v70 = v61 | v67 | (((v68 + v69) << 12) - 196608);
  v71 = v8[23];
  if (v71 <= 96)
    v72 = 0;
  else
    v72 = -39;
  v73 = ((v71 + v72) << 8) - 12288;
  v74 = v8[24];
  if (v74 <= 96)
    v75 = 0;
  else
    v75 = -39;
  v76 = v73 | (16 * (v74 + v75) - 768);
  v77 = v8[25];
  if (v77 <= 96)
    v78 = 0;
  else
    v78 = -39;
  *(_DWORD *)(a2 + 12) = v70 | v76 | (v77 + v78 - 48);
  v79 = v8[27];
  if (v79 <= 96)
    v80 = 0;
  else
    v80 = 9;
  v81 = v80 + v79;
  v82 = v8[28];
  if (v82 <= 96)
    v83 = 0;
  else
    v83 = 217;
  v84 = (((v82 + v83) << 24) - 805306368) | (v81 << 28);
  v85 = v8[29];
  if (v85 <= 96)
    v86 = 0;
  else
    v86 = -39;
  v87 = ((v85 + v86) << 20) - 50331648;
  v88 = v8[30];
  if (v88 <= 96)
    v89 = 0;
  else
    v89 = -39;
  v90 = v87 | (((v88 + v89) << 16) - 3145728);
  v91 = v8[31];
  if (v91 <= 96)
    v92 = 0;
  else
    v92 = -39;
  v93 = v84 | v90 | (((v91 + v92) << 12) - 196608);
  v94 = v8[32];
  if (v94 <= 96)
    v95 = 0;
  else
    v95 = -39;
  v96 = ((v94 + v95) << 8) - 12288;
  v97 = v8[33];
  if (v97 <= 96)
    v98 = 0;
  else
    v98 = -39;
  v99 = v96 | (16 * (v97 + v98) - 768);
  v100 = v8[34];
  if (v100 <= 96)
    v101 = 0;
  else
    v101 = -39;
  *(_DWORD *)(a2 + 16) = v93 | v99 | (v100 + v101 - 48);
  v102 = v8[36];
  if (v102 <= 96)
    v103 = 0;
  else
    v103 = 9;
  v104 = v103 + v102;
  v105 = v8[37];
  if (v105 <= 96)
    v106 = 0;
  else
    v106 = 217;
  v107 = ((((_WORD)v105 + v106) << 8) - 12288) | (v104 << 12);
  v108 = v8[38];
  if (v108 <= 96)
    v109 = 0;
  else
    v109 = 4057;
  v110 = 16 * (v108 + v109) - 768;
  v111 = v8[39];
  if (v111 <= 96)
    v112 = 0;
  else
    v112 = -39;
  *(_WORD *)(a2 + 20) = v107 | v110 | (v111 + v112 - 48);
  v113 = v8[41];
  if (v113 <= 96)
    v114 = 0;
  else
    v114 = 9;
  v115 = v114 + v113;
  v116 = v8[42];
  if (v116 <= 96)
    v117 = 0;
  else
    v117 = 217;
  v118 = ((((_WORD)v116 + v117) << 8) - 12288) | (v115 << 12);
  v119 = v8[43];
  if (v119 <= 96)
    v120 = 0;
  else
    v120 = 4057;
  v121 = 16 * (v119 + v120) - 768;
  v122 = v8[44];
  if (v122 <= 96)
    v123 = 0;
  else
    v123 = -39;
  v124 = v118 | v121 | (v122 + v123 - 48);
  *(_WORD *)(a2 + 22) = v124;
  v125 = v8[46];
  if (v125 <= 96)
    v126 = 0;
  else
    v126 = 9;
  v127 = v126 + v125;
  v128 = v8[47];
  if (v128 <= 96)
    v129 = 0;
  else
    v129 = 217;
  v130 = ((((_WORD)v128 + v129) << 8) - 12288) | (v127 << 12);
  v131 = v8[48];
  if (v131 <= 96)
    v132 = 0;
  else
    v132 = 4057;
  v133 = 16 * (v131 + v132) - 768;
  v134 = v8[49];
  if (v134 <= 96)
    v135 = 0;
  else
    v135 = -39;
  *(_WORD *)(a2 + 24) = v130 | v133 | (v134 + v135 - 48);
  v136 = v8[51];
  if (v136 <= 96)
    v137 = 96;
  else
    v137 = 9;
  v138 = v137 + v136;
  v139 = v8[52];
  if (v139 <= 96)
    v140 = 0;
  else
    v140 = -39;
  *(_BYTE *)(a2 + 26) = (v139 + v140 - 48) | (16 * v138);
  v141 = v8[53];
  if (v141 <= 96)
    v142 = 96;
  else
    v142 = 9;
  v143 = v142 + v141;
  v144 = v8[54];
  if (v144 <= 96)
    v145 = 0;
  else
    v145 = -39;
  *(_BYTE *)(a2 + 27) = (v144 + v145 - 48) | (16 * v143);
  v146 = v8[56];
  if (v146 <= 96)
    v147 = 96;
  else
    v147 = 9;
  v148 = v147 + v146;
  v149 = v8[57];
  if (v149 <= 96)
    v150 = 0;
  else
    v150 = -39;
  *(_BYTE *)(a2 + 28) = (v149 + v150 - 48) | (16 * v148);
  v151 = v8[58];
  if (v151 <= 96)
    v152 = 96;
  else
    v152 = 9;
  v153 = v152 + v151;
  v154 = v8[59];
  if (v154 <= 96)
    v155 = 0;
  else
    v155 = -39;
  *(_BYTE *)(a2 + 29) = (v154 + v155 - 48) | (16 * v153);
  v156 = v8[61];
  if (v156 <= 96)
    v157 = 0;
  else
    v157 = 9;
  v158 = v157 + v156;
  v159 = v8[62];
  if (v159 <= 96)
    v160 = 0;
  else
    v160 = 217;
  v161 = ((((_WORD)v159 + v160) << 8) - 12288) | (v158 << 12);
  v162 = v8[63];
  if (v162 <= 96)
    v163 = 0;
  else
    v163 = 4057;
  v164 = 16 * (v162 + v163) - 768;
  v165 = v8[64];
  if (v165 <= 96)
    v166 = 0;
  else
    v166 = -39;
  *(_WORD *)(a2 + 30) = v161 | v164 | (v165 + v166 - 48);
  v167 = v8[66];
  if (v167 <= 96)
    v168 = 0;
  else
    v168 = 9;
  v169 = v168 + v167;
  v170 = v8[67];
  if (v170 <= 96)
    v171 = 0;
  else
    v171 = 217;
  v172 = ((((_WORD)v170 + v171) << 8) - 12288) | (v169 << 12);
  v173 = v8[68];
  if (v173 <= 96)
    v174 = 0;
  else
    v174 = 4057;
  v175 = 16 * (v173 + v174) - 768;
  v176 = v8[69];
  if (v176 <= 96)
    v177 = 0;
  else
    v177 = -39;
  *(_WORD *)(a2 + 32) = v172 | v175 | (v176 + v177 - 48);
  v178 = v8[71];
  if (v178 <= 96)
    v179 = 0;
  else
    v179 = 9;
  v180 = v179 + v178;
  v181 = v8[72];
  if (v181 <= 96)
    v182 = 0;
  else
    v182 = 217;
  v183 = ((((_WORD)v181 + v182) << 8) - 12288) | (v180 << 12);
  v184 = v8[73];
  if (v184 <= 96)
    v185 = 0;
  else
    v185 = 4057;
  v186 = 16 * (v184 + v185) - 768;
  v187 = v8[74];
  if (v187 <= 96)
    v188 = 0;
  else
    v188 = -39;
  *(_WORD *)(a2 + 34) = v183 | v186 | (v187 + v188 - 48);
  v189 = v8[76];
  if (v189 <= 96)
    v190 = 0;
  else
    v190 = 9;
  v191 = v190 + v189;
  v192 = v8[77];
  if (v192 <= 96)
    v193 = 0;
  else
    v193 = 217;
  v194 = ((((_WORD)v192 + v193) << 8) - 12288) | (v191 << 12);
  v195 = v8[78];
  if (v195 <= 96)
    v196 = 0;
  else
    v196 = 4057;
  v197 = 16 * (v195 + v196) - 768;
  v198 = v8[79];
  if (v198 <= 96)
    result = 0;
  else
    result = 4294967257;
  v200 = v194 | v197 | (v198 + result - 48);
  *(_DWORD *)(a2 + 36) = v200;
  v201 = v8[81];
  if (v201 <= 96)
    v202 = 96;
  else
    v202 = 9;
  v203 = v202 + v201;
  v204 = v8[82];
  if (v204 <= 96)
    v205 = 0;
  else
    v205 = -39;
  *(_BYTE *)(a2 + 40) = (v204 + v205 - 48) | (16 * v203);
  v206 = v8[84];
  if (v206 <= 96)
    v207 = 0;
  else
    v207 = -39;
  *(_BYTE *)(a2 + 41) = v206 + v207 - 48;
  v208 = v8[86];
  if (v208 <= 96)
    v209 = 0;
  else
    v209 = -39;
  *(_BYTE *)(a2 + 42) = v208 + v209 - 48;
  v210 = v8[88];
  if (v210 <= 96)
    v211 = 0;
  else
    v211 = -39;
  *(_BYTE *)(a2 + 43) = v210 + v211 - 48;
  if (v7)
  {
    *(_WORD *)(a2 + 36) = v200 | ((_WORD)v55 << 8);
    *(_DWORD *)(a2 + 8) = v55 & 0xFFFFFF00;
  }
  *(_DWORD *)(a2 + 44) = 16 * v124;
  return result;
}

double HGString::digest@<D0>(HGString *this@<X0>, uint64_t a2@<X8>)
{
  double result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  size_t v9;
  size_t v10;
  int __dst[16];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  v5 = a2 + 16;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  v6 = *((_QWORD *)this + 1);
  if (v6)
  {
    if (v6 != 125 || strncmp(*(const char **)this, "//MD5=", 6uLL))
    {
      *(_QWORD *)a2 = HGString::hash(this, *(uint8x8_t *)&result);
      *(_QWORD *)(a2 + 8) = v7;
    }
    HGString::signature((HGString **)this, v5);
  }
  else
  {
    v8 = *(char **)this;
    if (*(_QWORD *)this)
    {
      v9 = strlen(v8);
      HGDigestInit((_OWORD *)a2);
      if (v9 >= 0x40)
      {
        v10 = v9 >> 6;
        do
        {
          HGDigestAdd((_DWORD *)a2, (int *)v8);
          v8 += 64;
          --v10;
        }
        while (v10);
        v9 &= 0x3Fu;
      }
      if (v9)
      {
        memcpy(__dst, v8, v9);
        bzero((char *)__dst + v9, 64 - v9);
        HGDigestAdd((_DWORD *)a2, __dst);
      }
      result = 0.0;
      *(_OWORD *)(a2 + 48) = 0u;
      *(_OWORD *)(a2 + 36) = 0u;
      *(_OWORD *)(a2 + 20) = 0u;
      *(_DWORD *)(a2 + 16) = 394768;
    }
  }
  return result;
}

void HGString::sample2d(HGString *this@<X0>, int a2@<W1>, int a3@<W2>, HGString *a4@<X8>)
{
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  int64_t v9;
  char *v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int8 v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int8 v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int8 v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int8 v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;

  if ((_DWORD)this == 394784)
  {
    switch(a2)
    {
      case 0:
        v11 = atomic_load((unsigned __int8 *)&qword_1ED4D96C0);
        if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96C0))
        {
          qword_1ED4D99F0 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture0;\n"
                                     "varying highp vec4 hg_TexCoord0;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
                                     "}\n"
                                     "//MD5=1d8d1a82:d291bc55:596ea65f:a606ed93\n"
                                     "//SIG=00000000:00000001:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
          qword_1ED4D99F8 = 413;
          xmmword_1ED4D9A00 = 0u;
          xmmword_1ED4D9A10 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D99F0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96C0);
        }
        v12 = qword_1ED4D99F8;
        *(_QWORD *)a4 = qword_1ED4D99F0;
        *((_QWORD *)a4 + 1) = v12;
        v13 = xmmword_1ED4D9A00;
        if ((_QWORD)xmmword_1ED4D9A00)
          ++*(_QWORD *)(xmmword_1ED4D9A00 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v13;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9A00 + 1);
        v9 = xmmword_1ED4D9A10 - *((_QWORD *)&xmmword_1ED4D9A00 + 1);
        if ((_QWORD)xmmword_1ED4D9A10 == *((_QWORD *)&xmmword_1ED4D9A00 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9A10 - *((_QWORD *)&xmmword_1ED4D9A00 + 1));
        break;
      case 1:
        v41 = atomic_load((unsigned __int8 *)&qword_1ED4D96C8);
        if ((v41 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96C8))
        {
          qword_1ED4D9A20 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture1;\n"
                                     "varying highp vec4 hg_TexCoord1;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
                                     "}\n"
                                     "//MD5=ac6d4b6f:fe3ac506:6576bd5e:27c645c3\n"
                                     "//SIG=00000000:00000002:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
          qword_1ED4D9A28 = 413;
          xmmword_1ED4D9A30 = 0u;
          xmmword_1ED4D9A40 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9A20, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96C8);
        }
        v42 = qword_1ED4D9A28;
        *(_QWORD *)a4 = qword_1ED4D9A20;
        *((_QWORD *)a4 + 1) = v42;
        v43 = xmmword_1ED4D9A30;
        if ((_QWORD)xmmword_1ED4D9A30)
          ++*(_QWORD *)(xmmword_1ED4D9A30 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v43;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9A30 + 1);
        v9 = xmmword_1ED4D9A40 - *((_QWORD *)&xmmword_1ED4D9A30 + 1);
        if ((_QWORD)xmmword_1ED4D9A40 == *((_QWORD *)&xmmword_1ED4D9A30 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9A40 - *((_QWORD *)&xmmword_1ED4D9A30 + 1));
        break;
      case 2:
        v23 = atomic_load((unsigned __int8 *)&qword_1ED4D96D0);
        if ((v23 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96D0))
        {
          qword_1ED4D9A50 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture2;\n"
                                     "varying highp vec4 hg_TexCoord2;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
                                     "}\n"
                                     "//MD5=64d01b6e:569dc44a:d1f1e083:2b518d16\n"
                                     "//SIG=00000000:00000004:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
          qword_1ED4D9A58 = 413;
          xmmword_1ED4D9A60 = 0u;
          xmmword_1ED4D9A70 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9A50, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96D0);
        }
        v24 = qword_1ED4D9A58;
        *(_QWORD *)a4 = qword_1ED4D9A50;
        *((_QWORD *)a4 + 1) = v24;
        v25 = xmmword_1ED4D9A60;
        if ((_QWORD)xmmword_1ED4D9A60)
          ++*(_QWORD *)(xmmword_1ED4D9A60 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v25;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9A60 + 1);
        v9 = xmmword_1ED4D9A70 - *((_QWORD *)&xmmword_1ED4D9A60 + 1);
        if ((_QWORD)xmmword_1ED4D9A70 == *((_QWORD *)&xmmword_1ED4D9A60 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9A70 - *((_QWORD *)&xmmword_1ED4D9A60 + 1));
        break;
      case 3:
        v35 = atomic_load((unsigned __int8 *)&qword_1ED4D96D8);
        if ((v35 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96D8))
        {
          qword_1ED4D9A80 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture3;\n"
                                     "varying highp vec4 hg_TexCoord3;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
                                     "}\n"
                                     "//MD5=59bfeda2:66444b75:343be20d:f7a096c6\n"
                                     "//SIG=00000000:00000008:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
          qword_1ED4D9A88 = 413;
          xmmword_1ED4D9A90 = 0u;
          xmmword_1ED4D9AA0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9A80, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96D8);
        }
        v36 = qword_1ED4D9A88;
        *(_QWORD *)a4 = qword_1ED4D9A80;
        *((_QWORD *)a4 + 1) = v36;
        v37 = xmmword_1ED4D9A90;
        if ((_QWORD)xmmword_1ED4D9A90)
          ++*(_QWORD *)(xmmword_1ED4D9A90 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v37;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9A90 + 1);
        v9 = xmmword_1ED4D9AA0 - *((_QWORD *)&xmmword_1ED4D9A90 + 1);
        if ((_QWORD)xmmword_1ED4D9AA0 == *((_QWORD *)&xmmword_1ED4D9A90 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9AA0 - *((_QWORD *)&xmmword_1ED4D9A90 + 1));
        break;
      case 4:
        v17 = atomic_load((unsigned __int8 *)&qword_1ED4D96E0);
        if ((v17 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96E0))
        {
          qword_1ED4D9AB0 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture4;\n"
                                     "varying highp vec4 hg_TexCoord4;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
                                     "}\n"
                                     "//MD5=a55c80ef:87e7f7dc:a3f787cf:27bdb14f\n"
                                     "//SIG=00000000:00000010:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
          qword_1ED4D9AB8 = 413;
          xmmword_1ED4D9AC0 = 0u;
          xmmword_1ED4D9AD0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9AB0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96E0);
        }
        v18 = qword_1ED4D9AB8;
        *(_QWORD *)a4 = qword_1ED4D9AB0;
        *((_QWORD *)a4 + 1) = v18;
        v19 = xmmword_1ED4D9AC0;
        if ((_QWORD)xmmword_1ED4D9AC0)
          ++*(_QWORD *)(xmmword_1ED4D9AC0 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v19;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9AC0 + 1);
        v9 = xmmword_1ED4D9AD0 - *((_QWORD *)&xmmword_1ED4D9AC0 + 1);
        if ((_QWORD)xmmword_1ED4D9AD0 == *((_QWORD *)&xmmword_1ED4D9AC0 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9AD0 - *((_QWORD *)&xmmword_1ED4D9AC0 + 1));
        break;
      case 5:
        v50 = atomic_load((unsigned __int8 *)&qword_1ED4D96E8);
        if ((v50 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96E8))
        {
          qword_1ED4D9AE0 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture5;\n"
                                     "varying highp vec4 hg_TexCoord5;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
                                     "}\n"
                                     "//MD5=05661ebe:db59835f:7507946b:b29cf29a\n"
                                     "//SIG=00000000:00000020:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
          qword_1ED4D9AE8 = 413;
          xmmword_1ED4D9AF0 = 0u;
          xmmword_1ED4D9B00 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9AE0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96E8);
        }
        v51 = qword_1ED4D9AE8;
        *(_QWORD *)a4 = qword_1ED4D9AE0;
        *((_QWORD *)a4 + 1) = v51;
        v52 = xmmword_1ED4D9AF0;
        if ((_QWORD)xmmword_1ED4D9AF0)
          ++*(_QWORD *)(xmmword_1ED4D9AF0 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v52;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9AF0 + 1);
        v9 = xmmword_1ED4D9B00 - *((_QWORD *)&xmmword_1ED4D9AF0 + 1);
        if ((_QWORD)xmmword_1ED4D9B00 == *((_QWORD *)&xmmword_1ED4D9AF0 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9B00 - *((_QWORD *)&xmmword_1ED4D9AF0 + 1));
        break;
      case 6:
        v53 = atomic_load((unsigned __int8 *)&qword_1ED4D96F0);
        if ((v53 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96F0))
        {
          qword_1ED4D9B10 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture6;\n"
                                     "varying highp vec4 hg_TexCoord6;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture6, hg_TexCoord6.xy);\n"
                                     "}\n"
                                     "//MD5=22ccfeea:0aa3beb7:0667a734:f532af78\n"
                                     "//SIG=00000000:00000040:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
          qword_1ED4D9B18 = 413;
          xmmword_1ED4D9B20 = 0u;
          xmmword_1ED4D9B30 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9B10, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96F0);
        }
        v54 = qword_1ED4D9B18;
        *(_QWORD *)a4 = qword_1ED4D9B10;
        *((_QWORD *)a4 + 1) = v54;
        v55 = xmmword_1ED4D9B20;
        if ((_QWORD)xmmword_1ED4D9B20)
          ++*(_QWORD *)(xmmword_1ED4D9B20 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v55;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9B20 + 1);
        v9 = xmmword_1ED4D9B30 - *((_QWORD *)&xmmword_1ED4D9B20 + 1);
        if ((_QWORD)xmmword_1ED4D9B30 == *((_QWORD *)&xmmword_1ED4D9B20 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9B30 - *((_QWORD *)&xmmword_1ED4D9B20 + 1));
        break;
      case 7:
        v38 = atomic_load((unsigned __int8 *)&qword_1ED4D96F8);
        if ((v38 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96F8))
        {
          qword_1ED4D9B40 = (uint64_t)"//GLfs2.0      \n"
                                     "//LEN=000000019d\n"
                                     "#ifndef GL_ES\n"
                                     "#define lowp\n"
                                     "#define mediump\n"
                                     "#define highp\n"
                                     "#endif\n"
                                     "#define defaultp mediump\n"
                                     "uniform defaultp sampler2D hg_Texture7;\n"
                                     "varying highp vec4 hg_TexCoord7;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_FragColor = texture2D(hg_Texture7, hg_TexCoord7.xy);\n"
                                     "}\n"
                                     "//MD5=bbf4ec74:245e90b8:e9ac0fd8:351c5b3a\n"
                                     "//SIG=00000000:00000080:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
          qword_1ED4D9B48 = 413;
          xmmword_1ED4D9B50 = 0u;
          xmmword_1ED4D9B60 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9B40, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96F8);
        }
        v39 = qword_1ED4D9B48;
        *(_QWORD *)a4 = qword_1ED4D9B40;
        *((_QWORD *)a4 + 1) = v39;
        v40 = xmmword_1ED4D9B50;
        if ((_QWORD)xmmword_1ED4D9B50)
          ++*(_QWORD *)(xmmword_1ED4D9B50 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v40;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9B50 + 1);
        v9 = xmmword_1ED4D9B60 - *((_QWORD *)&xmmword_1ED4D9B50 + 1);
        if ((_QWORD)xmmword_1ED4D9B60 == *((_QWORD *)&xmmword_1ED4D9B50 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9B60 - *((_QWORD *)&xmmword_1ED4D9B50 + 1));
        break;
      default:
        goto LABEL_25;
    }
    goto LABEL_111;
  }
  if ((_DWORD)this == 394000)
  {
    switch(a2)
    {
      case 0:
        v5 = atomic_load((unsigned __int8 *)&_MergedGlobals_6);
        if ((v5 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_6))
        {
          qword_1ED4D9870 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f0=fragment.texcoord[0];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##0\n"
                                     "TEX $o0,$f0,texture[0],2D;\n"
                                     "END\n"
                                     "##MD5=16e93a90:20a9533a:c6576d6f:12e8ee4d\n"
                                     "##SIG=00000000:00000001:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
          unk_1ED4D9878 = 411;
          xmmword_1ED4D9880 = 0u;
          xmmword_1ED4D9890 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9870, &dword_1B2737000);
          __cxa_guard_release(&_MergedGlobals_6);
        }
        v6 = unk_1ED4D9878;
        *(_QWORD *)a4 = qword_1ED4D9870;
        *((_QWORD *)a4 + 1) = v6;
        v7 = xmmword_1ED4D9880;
        if ((_QWORD)xmmword_1ED4D9880)
          ++*(_QWORD *)(xmmword_1ED4D9880 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v7;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9880 + 1);
        v9 = xmmword_1ED4D9890 - *((_QWORD *)&xmmword_1ED4D9880 + 1);
        if ((_QWORD)xmmword_1ED4D9890 == *((_QWORD *)&xmmword_1ED4D9880 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9890 - *((_QWORD *)&xmmword_1ED4D9880 + 1));
        break;
      case 1:
        v32 = atomic_load((unsigned __int8 *)&qword_1ED4D9688);
        if ((v32 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9688))
        {
          qword_1ED4D98A0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f1=fragment.texcoord[1];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##1\n"
                                     "TEX $o0,$f1,texture[1],2D;\n"
                                     "END\n"
                                     "##MD5=b736e8a9:2ce9f250:7cba081b:ac720bf8\n"
                                     "##SIG=00000000:00000002:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
          qword_1ED4D98A8 = 411;
          xmmword_1ED4D98B0 = 0u;
          xmmword_1ED4D98C0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D98A0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9688);
        }
        v33 = qword_1ED4D98A8;
        *(_QWORD *)a4 = qword_1ED4D98A0;
        *((_QWORD *)a4 + 1) = v33;
        v34 = xmmword_1ED4D98B0;
        if ((_QWORD)xmmword_1ED4D98B0)
          ++*(_QWORD *)(xmmword_1ED4D98B0 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v34;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D98B0 + 1);
        v9 = xmmword_1ED4D98C0 - *((_QWORD *)&xmmword_1ED4D98B0 + 1);
        if ((_QWORD)xmmword_1ED4D98C0 == *((_QWORD *)&xmmword_1ED4D98B0 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D98C0 - *((_QWORD *)&xmmword_1ED4D98B0 + 1));
        break;
      case 2:
        v20 = atomic_load((unsigned __int8 *)&qword_1ED4D9690);
        if ((v20 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9690))
        {
          qword_1ED4D98D0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f2=fragment.texcoord[2];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##2\n"
                                     "TEX $o0,$f2,texture[2],2D;\n"
                                     "END\n"
                                     "##MD5=f65ae3b0:67c9ec7f:86a5b786:54ad4649\n"
                                     "##SIG=00000000:00000004:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
          qword_1ED4D98D8 = 411;
          xmmword_1ED4D98E0 = 0u;
          xmmword_1ED4D98F0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D98D0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9690);
        }
        v21 = qword_1ED4D98D8;
        *(_QWORD *)a4 = qword_1ED4D98D0;
        *((_QWORD *)a4 + 1) = v21;
        v22 = xmmword_1ED4D98E0;
        if ((_QWORD)xmmword_1ED4D98E0)
          ++*(_QWORD *)(xmmword_1ED4D98E0 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v22;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D98E0 + 1);
        v9 = xmmword_1ED4D98F0 - *((_QWORD *)&xmmword_1ED4D98E0 + 1);
        if ((_QWORD)xmmword_1ED4D98F0 == *((_QWORD *)&xmmword_1ED4D98E0 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D98F0 - *((_QWORD *)&xmmword_1ED4D98E0 + 1));
        break;
      case 3:
        v26 = atomic_load((unsigned __int8 *)&qword_1ED4D9698);
        if ((v26 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9698))
        {
          qword_1ED4D9900 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f3=fragment.texcoord[3];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##3\n"
                                     "TEX $o0,$f3,texture[3],2D;\n"
                                     "END\n"
                                     "##MD5=3899c790:e60c7f5f:7881594e:b87c7ab6\n"
                                     "##SIG=00000000:00000008:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
          qword_1ED4D9908 = 411;
          xmmword_1ED4D9910 = 0u;
          xmmword_1ED4D9920 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9900, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9698);
        }
        v27 = qword_1ED4D9908;
        *(_QWORD *)a4 = qword_1ED4D9900;
        *((_QWORD *)a4 + 1) = v27;
        v28 = xmmword_1ED4D9910;
        if ((_QWORD)xmmword_1ED4D9910)
          ++*(_QWORD *)(xmmword_1ED4D9910 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v28;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9910 + 1);
        v9 = xmmword_1ED4D9920 - *((_QWORD *)&xmmword_1ED4D9910 + 1);
        if ((_QWORD)xmmword_1ED4D9920 == *((_QWORD *)&xmmword_1ED4D9910 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9920 - *((_QWORD *)&xmmword_1ED4D9910 + 1));
        break;
      case 4:
        v14 = atomic_load((unsigned __int8 *)&qword_1ED4D96A0);
        if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96A0))
        {
          qword_1ED4D9930 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f4=fragment.texcoord[4];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##4\n"
                                     "TEX $o0,$f4,texture[4],2D;\n"
                                     "END\n"
                                     "##MD5=7dc2386c:febf27ca:d6e811c9:91dd69db\n"
                                     "##SIG=00000000:00000010:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
          qword_1ED4D9938 = 411;
          xmmword_1ED4D9940 = 0u;
          xmmword_1ED4D9950 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9930, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96A0);
        }
        v15 = qword_1ED4D9938;
        *(_QWORD *)a4 = qword_1ED4D9930;
        *((_QWORD *)a4 + 1) = v15;
        v16 = xmmword_1ED4D9940;
        if ((_QWORD)xmmword_1ED4D9940)
          ++*(_QWORD *)(xmmword_1ED4D9940 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v16;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9940 + 1);
        v9 = xmmword_1ED4D9950 - *((_QWORD *)&xmmword_1ED4D9940 + 1);
        if ((_QWORD)xmmword_1ED4D9950 == *((_QWORD *)&xmmword_1ED4D9940 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9950 - *((_QWORD *)&xmmword_1ED4D9940 + 1));
        break;
      case 5:
        v44 = atomic_load((unsigned __int8 *)&qword_1ED4D96A8);
        if ((v44 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96A8))
        {
          qword_1ED4D9960 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f5=fragment.texcoord[5];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##5\n"
                                     "TEX $o0,$f5,texture[5],2D;\n"
                                     "END\n"
                                     "##MD5=3383524a:11b3f71a:c55ccc0e:8d9dc0e3\n"
                                     "##SIG=00000000:00000020:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
          qword_1ED4D9968 = 411;
          xmmword_1ED4D9970 = 0u;
          xmmword_1ED4D9980 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9960, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96A8);
        }
        v45 = qword_1ED4D9968;
        *(_QWORD *)a4 = qword_1ED4D9960;
        *((_QWORD *)a4 + 1) = v45;
        v46 = xmmword_1ED4D9970;
        if ((_QWORD)xmmword_1ED4D9970)
          ++*(_QWORD *)(xmmword_1ED4D9970 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v46;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D9970 + 1);
        v9 = xmmword_1ED4D9980 - *((_QWORD *)&xmmword_1ED4D9970 + 1);
        if ((_QWORD)xmmword_1ED4D9980 == *((_QWORD *)&xmmword_1ED4D9970 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D9980 - *((_QWORD *)&xmmword_1ED4D9970 + 1));
        break;
      case 6:
        v47 = atomic_load((unsigned __int8 *)&qword_1ED4D96B0);
        if ((v47 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96B0))
        {
          qword_1ED4D9990 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f6=fragment.texcoord[6];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##6\n"
                                     "TEX $o0,$f6,texture[6],2D;\n"
                                     "END\n"
                                     "##MD5=dc6255ee:ec02b910:da88252c:9affa0c5\n"
                                     "##SIG=00000000:00000040:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
          qword_1ED4D9998 = 411;
          xmmword_1ED4D99A0 = 0u;
          xmmword_1ED4D99B0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9990, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96B0);
        }
        v48 = qword_1ED4D9998;
        *(_QWORD *)a4 = qword_1ED4D9990;
        *((_QWORD *)a4 + 1) = v48;
        v49 = xmmword_1ED4D99A0;
        if ((_QWORD)xmmword_1ED4D99A0)
          ++*(_QWORD *)(xmmword_1ED4D99A0 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v49;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D99A0 + 1);
        v9 = xmmword_1ED4D99B0 - *((_QWORD *)&xmmword_1ED4D99A0 + 1);
        if ((_QWORD)xmmword_1ED4D99B0 == *((_QWORD *)&xmmword_1ED4D99A0 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D99B0 - *((_QWORD *)&xmmword_1ED4D99A0 + 1));
        break;
      case 7:
        v29 = atomic_load((unsigned __int8 *)&qword_1ED4D96B8);
        if ((v29 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D96B8))
        {
          qword_1ED4D99C0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000019b\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "ATTRIB $f7=fragment.texcoord[7];\n"
                                     "##%\n"
                                     "##@\n"
                                     "##7\n"
                                     "TEX $o0,$f7,texture[7],2D;\n"
                                     "END\n"
                                     "##MD5=4ef19759:2d6000ec:2c5f0d39:0e366cec\n"
                                     "##SIG=00000000:00000080:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
          qword_1ED4D99C8 = 411;
          xmmword_1ED4D99D0 = 0u;
          xmmword_1ED4D99E0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D99C0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D96B8);
        }
        v30 = qword_1ED4D99C8;
        *(_QWORD *)a4 = qword_1ED4D99C0;
        *((_QWORD *)a4 + 1) = v30;
        v31 = xmmword_1ED4D99D0;
        if ((_QWORD)xmmword_1ED4D99D0)
          ++*(_QWORD *)(xmmword_1ED4D99D0 + 8);
        *((_QWORD *)a4 + 3) = 0;
        *((_QWORD *)a4 + 2) = v31;
        *((_QWORD *)a4 + 4) = 0;
        *((_QWORD *)a4 + 5) = 0;
        v8 = (const void *)*((_QWORD *)&xmmword_1ED4D99D0 + 1);
        v9 = xmmword_1ED4D99E0 - *((_QWORD *)&xmmword_1ED4D99D0 + 1);
        if ((_QWORD)xmmword_1ED4D99E0 == *((_QWORD *)&xmmword_1ED4D99D0 + 1))
          return;
        if (v9 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v10 = (char *)operator new(xmmword_1ED4D99E0 - *((_QWORD *)&xmmword_1ED4D99D0 + 1));
        break;
      default:
        goto LABEL_25;
    }
LABEL_111:
    *((_QWORD *)a4 + 3) = v10;
    *((_QWORD *)a4 + 4) = v10;
    v56 = &v10[2 * (v9 >> 1)];
    *((_QWORD *)a4 + 5) = v56;
    memcpy(v10, v8, v9);
    *((_QWORD *)a4 + 4) = v56;
    return;
  }
  if ((_DWORD)this == 396048 && a3)
  {
    switch(a2)
    {
      case 0:
        metal_sample2d0_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9B70);
        break;
      case 1:
        metal_sample2d1_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9BA0);
        break;
      case 2:
        metal_sample2d2_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9BD0);
        break;
      case 3:
        metal_sample2d3_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9C00);
        break;
      case 4:
        metal_sample2d4_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9C30);
        break;
      case 5:
        metal_sample2d5_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9C60);
        break;
      case 6:
        metal_sample2d6_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9C90);
        break;
      case 7:
        metal_sample2d7_half_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9CC0);
        break;
      default:
        goto LABEL_25;
    }
  }
  else if ((_DWORD)this == 396048)
  {
    switch(a2)
    {
      case 0:
        metal_sample2d0_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9CF0);
        break;
      case 1:
        metal_sample2d1_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9D20);
        break;
      case 2:
        metal_sample2d2_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9D50);
        break;
      case 3:
        metal_sample2d3_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9D80);
        break;
      case 4:
        metal_sample2d4_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9DB0);
        break;
      case 5:
        metal_sample2d5_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9DE0);
        break;
      case 6:
        metal_sample2d6_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9E10);
        break;
      case 7:
        metal_sample2d7_s();
        HGString::HGString(a4, (const HGString *)&qword_1ED4D9E40);
        break;
      default:
        goto LABEL_25;
    }
  }
  else
  {
LABEL_25:
    *((_OWORD *)a4 + 1) = 0u;
    *((_OWORD *)a4 + 2) = 0u;
    *(_OWORD *)a4 = 0u;
  }
}

void sub_1B2A0FA38(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void metal_sample2d0_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9700);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9700))
    {
      qword_1ED4D9B70 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
                                 "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=17b31ac2:0d32b286:d460af2f:68ac1617\n"
                                 "//SIG=00400000:00000001:00000000:00000001:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
      qword_1ED4D9B78 = 519;
      xmmword_1ED4D9B80 = 0u;
      xmmword_1ED4D9B90 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9B70, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9700);
    }
  }
}

void metal_sample2d1_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9708);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9708))
    {
      qword_1ED4D9BA0 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
                                 "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=66126f08:7a0a0541:50cb14b8:dc20ab48\n"
                                 "//SIG=00400000:00000002:00000000:00000002:0000:0000:0000:0000:0000:0000:0004:0000:0002:02:0:1:0\n";
      qword_1ED4D9BA8 = 519;
      xmmword_1ED4D9BB0 = 0u;
      xmmword_1ED4D9BC0 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9BA0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9708);
    }
  }
}

void metal_sample2d2_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9710);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9710))
    {
      qword_1ED4D9BD0 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
                                 "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=e29ca5bf:3aefc427:e9cb6767:1fb5bfae\n"
                                 "//SIG=00400000:00000004:00000000:00000004:0000:0000:0000:0000:0000:0000:0008:0000:0003:03:0:1:0\n";
      qword_1ED4D9BD8 = 519;
      xmmword_1ED4D9BE0 = 0u;
      xmmword_1ED4D9BF0 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9BD0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9710);
    }
  }
}

void metal_sample2d3_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9718);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9718))
    {
      qword_1ED4D9C00 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
                                 "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=26246cf2:677801c1:4ecdf5a0:4b8d05e2\n"
                                 "//SIG=00400000:00000008:00000000:00000008:0000:0000:0000:0000:0000:0000:0010:0000:0004:04:0:1:0\n";
      qword_1ED4D9C08 = 519;
      xmmword_1ED4D9C10 = 0u;
      xmmword_1ED4D9C20 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9C00, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9718);
    }
  }
}

void metal_sample2d4_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9720);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9720))
    {
      qword_1ED4D9C30 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
                                 "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=e58b568d:54c2b894:b659516b:b176e5ac\n"
                                 "//SIG=00400000:00000010:00000000:00000010:0000:0000:0000:0000:0000:0000:0020:0000:0005:05:0:1:0\n";
      qword_1ED4D9C38 = 519;
      xmmword_1ED4D9C40 = 0u;
      xmmword_1ED4D9C50 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9C30, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9720);
    }
  }
}

void metal_sample2d5_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9728);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9728))
    {
      qword_1ED4D9C60 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float5* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
                                 "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=66f8f1b6:850d7b58:5ce020bb:4d7656a8\n"
                                 "//SIG=00400000:00000020:00000000:00000020:0000:0000:0000:0000:0000:0000:0040:0000:0006:06:0:1:0\n";
      qword_1ED4D9C68 = 519;
      xmmword_1ED4D9C70 = 0u;
      xmmword_1ED4D9C80 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9C60, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9728);
    }
  }
}

void metal_sample2d6_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9730);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9730))
    {
      qword_1ED4D9C90 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture6 [[ texture(6) ]], \n"
                                 "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=71cedd26:3f95a3bd:40380951:bd74d411\n"
                                 "//SIG=00400000:00000040:00000000:00000040:0000:0000:0000:0000:0000:0000:0080:0000:0007:07:0:1:0\n";
      qword_1ED4D9C98 = 519;
      xmmword_1ED4D9CA0 = 0u;
      xmmword_1ED4D9CB0 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9C90, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9730);
    }
  }
}

void metal_sample2d7_half_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9738);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9738))
    {
      qword_1ED4D9CC0 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=0000000207\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< half > hg_Texture7 [[ texture(7) ]], \n"
                                 "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = (float4) hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=366faa97:74f51e41:1aae0693:9870a122\n"
                                 "//SIG=00400000:00000080:00000000:00000080:0000:0000:0000:0000:0000:0000:0100:0000:0008:08:0:1:0\n";
      qword_1ED4D9CC8 = 519;
      xmmword_1ED4D9CD0 = 0u;
      xmmword_1ED4D9CE0 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9CC0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9738);
    }
  }
}

void metal_sample2d0_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9740);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9740))
    {
      qword_1ED4D9CF0 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
                                 "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=6f669bc0:cf2c4116:fad604f7:6fdb36bb\n"
                                 "//SIG=00000000:00000001:00000000:00000000:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
      qword_1ED4D9CF8 = 511;
      xmmword_1ED4D9D00 = 0u;
      xmmword_1ED4D9D10 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9CF0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9740);
    }
  }
}

void metal_sample2d1_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9748);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9748))
    {
      qword_1ED4D9D20 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
                                 "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=337083c6:b5efb30c:e0498c87:962e883b\n"
                                 "//SIG=00000000:00000002:00000000:00000000:0000:0000:0000:0000:0000:0000:0004:0000:0002:02:0:1:0\n";
      qword_1ED4D9D28 = 511;
      xmmword_1ED4D9D30 = 0u;
      xmmword_1ED4D9D40 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9D20, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9748);
    }
  }
}

void metal_sample2d2_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9750);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9750))
    {
      qword_1ED4D9D50 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
                                 "    sampler hg_Sampler2 [[ sampler(2) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=78787321:d0f473ee:95960d97:3438eca2\n"
                                 "//SIG=00000000:00000004:00000000:00000000:0000:0000:0000:0000:0000:0000:0008:0000:0003:03:0:1:0\n";
      qword_1ED4D9D58 = 511;
      xmmword_1ED4D9D60 = 0u;
      xmmword_1ED4D9D70 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9D50, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9750);
    }
  }
}

void metal_sample2d3_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9758);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9758))
    {
      qword_1ED4D9D80 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
                                 "    sampler hg_Sampler3 [[ sampler(3) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=cd8bb6cc:4819f5f1:ddf3db57:3dfec92f\n"
                                 "//SIG=00000000:00000008:00000000:00000000:0000:0000:0000:0000:0000:0000:0010:0000:0004:04:0:1:0\n";
      qword_1ED4D9D88 = 511;
      xmmword_1ED4D9D90 = 0u;
      xmmword_1ED4D9DA0 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9D80, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9758);
    }
  }
}

void metal_sample2d4_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9760);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9760))
    {
      qword_1ED4D9DB0 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
                                 "    sampler hg_Sampler4 [[ sampler(4) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=2e9dff36:f2698c51:cfa8aed7:24c4c84e\n"
                                 "//SIG=00000000:00000010:00000000:00000000:0000:0000:0000:0000:0000:0000:0020:0000:0005:05:0:1:0\n";
      qword_1ED4D9DB8 = 511;
      xmmword_1ED4D9DC0 = 0u;
      xmmword_1ED4D9DD0 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9DB0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9760);
    }
  }
}

void metal_sample2d5_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9768);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9768))
    {
      qword_1ED4D9DE0 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
                                 "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=cc86252f:23fe64ab:2c3c7c52:1bfd6a43\n"
                                 "//SIG=00000000:00000020:00000000:00000000:0000:0000:0000:0000:0000:0000:0040:0000:0006:06:0:1:0\n";
      qword_1ED4D9DE8 = 511;
      xmmword_1ED4D9DF0 = 0u;
      xmmword_1ED4D9E00 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9DE0, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9768);
    }
  }
}

void metal_sample2d6_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9770);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9770))
    {
      qword_1ED4D9E10 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture6 [[ texture(6) ]], \n"
                                 "    sampler hg_Sampler6 [[ sampler(6) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture6.sample(hg_Sampler6, frag._texCoord6.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=99bcb848:93607e3e:f6e46520:b61c284e\n"
                                 "//SIG=00000000:00000040:00000000:00000000:0000:0000:0000:0000:0000:0000:0080:0000:0007:07:0:1:0\n";
      qword_1ED4D9E18 = 511;
      xmmword_1ED4D9E20 = 0u;
      xmmword_1ED4D9E30 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9E10, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9770);
    }
  }
}

void metal_sample2d7_s(void)
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED4D9778);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED4D9778))
    {
      qword_1ED4D9E40 = (uint64_t)"//Metal1.0     \n"
                                 "//LEN=00000001ff\n"
                                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                                 "    texture2d< float > hg_Texture7 [[ texture(7) ]], \n"
                                 "    sampler hg_Sampler7 [[ sampler(7) ]])\n"
                                 "{\n"
                                 "    FragmentOut output;\n"
                                 "\n"
                                 "    output.color0 = hg_Texture7.sample(hg_Sampler7, frag._texCoord7.xy);\n"
                                 "    return output;\n"
                                 "}\n"
                                 "//MD5=5dc21ffb:da771f51:4ded01d3:f8c247ab\n"
                                 "//SIG=00000000:00000080:00000000:00000000:0000:0000:0000:0000:0000:0000:0100:0000:0008:08:0:1:0\n";
      qword_1ED4D9E48 = 511;
      xmmword_1ED4D9E50 = 0u;
      xmmword_1ED4D9E60 = 0u;
      __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9E40, &dword_1B2737000);
      __cxa_guard_release(&qword_1ED4D9778);
    }
  }
}

void HGString::sampleRect(int a1@<W1>, _QWORD *a2@<X8>)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  int64_t v8;
  char *v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;

  switch(a1)
  {
    case 0:
      v4 = atomic_load((unsigned __int8 *)&qword_1ED4D9780);
      if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9780))
      {
        qword_1ED4D9E70 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f0=fragment.texcoord[0];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##0\n"
                                   "TEX $o0,$f0,texture[0],RECT;\n"
                                   "END\n"
                                   "##MD5=13e335a2:9b4d2bf6:db2e47e2:03487278\n"
                                   "##SIG=00000000:00000001:00000001:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
        qword_1ED4D9E78 = 413;
        xmmword_1ED4D9E80 = 0u;
        xmmword_1ED4D9E90 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9E70, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D9780);
      }
      v5 = qword_1ED4D9E78;
      *a2 = qword_1ED4D9E70;
      a2[1] = v5;
      v6 = xmmword_1ED4D9E80;
      if ((_QWORD)xmmword_1ED4D9E80)
        ++*(_QWORD *)(xmmword_1ED4D9E80 + 8);
      a2[3] = 0;
      a2[2] = v6;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9E80 + 1);
      v8 = xmmword_1ED4D9E90 - *((_QWORD *)&xmmword_1ED4D9E80 + 1);
      if ((_QWORD)xmmword_1ED4D9E90 != *((_QWORD *)&xmmword_1ED4D9E80 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9E90 - *((_QWORD *)&xmmword_1ED4D9E80 + 1));
        goto LABEL_53;
      }
      break;
    case 1:
      v22 = atomic_load((unsigned __int8 *)&qword_1ED4D9788);
      if ((v22 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9788))
      {
        qword_1ED4D9EA0 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f1=fragment.texcoord[1];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##1\n"
                                   "TEX $o0,$f1,texture[1],RECT;\n"
                                   "END\n"
                                   "##MD5=187ebb5e:75f053ee:b9cd2328:68d3c628\n"
                                   "##SIG=00000000:00000002:00000002:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
        qword_1ED4D9EA8 = 413;
        xmmword_1ED4D9EB0 = 0u;
        xmmword_1ED4D9EC0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9EA0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D9788);
      }
      v23 = qword_1ED4D9EA8;
      *a2 = qword_1ED4D9EA0;
      a2[1] = v23;
      v24 = xmmword_1ED4D9EB0;
      if ((_QWORD)xmmword_1ED4D9EB0)
        ++*(_QWORD *)(xmmword_1ED4D9EB0 + 8);
      a2[3] = 0;
      a2[2] = v24;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9EB0 + 1);
      v8 = xmmword_1ED4D9EC0 - *((_QWORD *)&xmmword_1ED4D9EB0 + 1);
      if ((_QWORD)xmmword_1ED4D9EC0 != *((_QWORD *)&xmmword_1ED4D9EB0 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9EC0 - *((_QWORD *)&xmmword_1ED4D9EB0 + 1));
        goto LABEL_53;
      }
      break;
    case 2:
      v13 = atomic_load((unsigned __int8 *)&qword_1ED4D9790);
      if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9790))
      {
        qword_1ED4D9ED0 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f2=fragment.texcoord[2];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##2\n"
                                   "TEX $o0,$f2,texture[2],RECT;\n"
                                   "END\n"
                                   "##MD5=040e4cc4:32c92579:c792bf9b:f6c58a30\n"
                                   "##SIG=00000000:00000004:00000004:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0003:03:0:1:0\n";
        qword_1ED4D9ED8 = 413;
        xmmword_1ED4D9EE0 = 0u;
        xmmword_1ED4D9EF0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9ED0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D9790);
      }
      v14 = qword_1ED4D9ED8;
      *a2 = qword_1ED4D9ED0;
      a2[1] = v14;
      v15 = xmmword_1ED4D9EE0;
      if ((_QWORD)xmmword_1ED4D9EE0)
        ++*(_QWORD *)(xmmword_1ED4D9EE0 + 8);
      a2[3] = 0;
      a2[2] = v15;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9EE0 + 1);
      v8 = xmmword_1ED4D9EF0 - *((_QWORD *)&xmmword_1ED4D9EE0 + 1);
      if ((_QWORD)xmmword_1ED4D9EF0 != *((_QWORD *)&xmmword_1ED4D9EE0 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9EF0 - *((_QWORD *)&xmmword_1ED4D9EE0 + 1));
        goto LABEL_53;
      }
      break;
    case 3:
      v16 = atomic_load((unsigned __int8 *)&qword_1ED4D9798);
      if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9798))
      {
        qword_1ED4D9F00 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f3=fragment.texcoord[3];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##3\n"
                                   "TEX $o0,$f3,texture[3],RECT;\n"
                                   "END\n"
                                   "##MD5=f09d8453:c175c072:e9ec1c7d:df7723d4\n"
                                   "##SIG=00000000:00000008:00000008:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
        qword_1ED4D9F08 = 413;
        xmmword_1ED4D9F10 = 0u;
        xmmword_1ED4D9F20 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9F00, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D9798);
      }
      v17 = qword_1ED4D9F08;
      *a2 = qword_1ED4D9F00;
      a2[1] = v17;
      v18 = xmmword_1ED4D9F10;
      if ((_QWORD)xmmword_1ED4D9F10)
        ++*(_QWORD *)(xmmword_1ED4D9F10 + 8);
      a2[3] = 0;
      a2[2] = v18;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9F10 + 1);
      v8 = xmmword_1ED4D9F20 - *((_QWORD *)&xmmword_1ED4D9F10 + 1);
      if ((_QWORD)xmmword_1ED4D9F20 != *((_QWORD *)&xmmword_1ED4D9F10 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9F20 - *((_QWORD *)&xmmword_1ED4D9F10 + 1));
        goto LABEL_53;
      }
      break;
    case 4:
      v10 = atomic_load((unsigned __int8 *)&qword_1ED4D97A0);
      if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97A0))
      {
        qword_1ED4D9F30 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f4=fragment.texcoord[4];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##4\n"
                                   "TEX $o0,$f4,texture[4],RECT;\n"
                                   "END\n"
                                   "##MD5=0d4c4995:9892fdda:25d75c20:e69d0655\n"
                                   "##SIG=00000000:00000010:00000010:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0005:05:0:1:0\n";
        qword_1ED4D9F38 = 413;
        xmmword_1ED4D9F40 = 0u;
        xmmword_1ED4D9F50 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9F30, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D97A0);
      }
      v11 = qword_1ED4D9F38;
      *a2 = qword_1ED4D9F30;
      a2[1] = v11;
      v12 = xmmword_1ED4D9F40;
      if ((_QWORD)xmmword_1ED4D9F40)
        ++*(_QWORD *)(xmmword_1ED4D9F40 + 8);
      a2[3] = 0;
      a2[2] = v12;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9F40 + 1);
      v8 = xmmword_1ED4D9F50 - *((_QWORD *)&xmmword_1ED4D9F40 + 1);
      if ((_QWORD)xmmword_1ED4D9F50 != *((_QWORD *)&xmmword_1ED4D9F40 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9F50 - *((_QWORD *)&xmmword_1ED4D9F40 + 1));
        goto LABEL_53;
      }
      break;
    case 5:
      v25 = atomic_load((unsigned __int8 *)&qword_1ED4D97A8);
      if ((v25 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97A8))
      {
        qword_1ED4D9F60 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f5=fragment.texcoord[5];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##5\n"
                                   "TEX $o0,$f5,texture[5],RECT;\n"
                                   "END\n"
                                   "##MD5=05fcc9b2:9b232369:60268b6e:77392bc9\n"
                                   "##SIG=00000000:00000020:00000020:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
        qword_1ED4D9F68 = 413;
        xmmword_1ED4D9F70 = 0u;
        xmmword_1ED4D9F80 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9F60, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D97A8);
      }
      v26 = qword_1ED4D9F68;
      *a2 = qword_1ED4D9F60;
      a2[1] = v26;
      v27 = xmmword_1ED4D9F70;
      if ((_QWORD)xmmword_1ED4D9F70)
        ++*(_QWORD *)(xmmword_1ED4D9F70 + 8);
      a2[3] = 0;
      a2[2] = v27;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9F70 + 1);
      v8 = xmmword_1ED4D9F80 - *((_QWORD *)&xmmword_1ED4D9F70 + 1);
      if ((_QWORD)xmmword_1ED4D9F80 != *((_QWORD *)&xmmword_1ED4D9F70 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9F80 - *((_QWORD *)&xmmword_1ED4D9F70 + 1));
        goto LABEL_53;
      }
      break;
    case 6:
      v28 = atomic_load((unsigned __int8 *)&qword_1ED4D97B0);
      if ((v28 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97B0))
      {
        qword_1ED4D9F90 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f6=fragment.texcoord[6];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##6\n"
                                   "TEX $o0,$f6,texture[6],RECT;\n"
                                   "END\n"
                                   "##MD5=612cfe17:9d77fa2d:25c645b8:3fc04f19\n"
                                   "##SIG=00000000:00000040:00000040:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0007:07:0:1:0\n";
        qword_1ED4D9F98 = 413;
        xmmword_1ED4D9FA0 = 0u;
        xmmword_1ED4D9FB0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9F90, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D97B0);
      }
      v29 = qword_1ED4D9F98;
      *a2 = qword_1ED4D9F90;
      a2[1] = v29;
      v30 = xmmword_1ED4D9FA0;
      if ((_QWORD)xmmword_1ED4D9FA0)
        ++*(_QWORD *)(xmmword_1ED4D9FA0 + 8);
      a2[3] = 0;
      a2[2] = v30;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9FA0 + 1);
      v8 = xmmword_1ED4D9FB0 - *((_QWORD *)&xmmword_1ED4D9FA0 + 1);
      if ((_QWORD)xmmword_1ED4D9FB0 != *((_QWORD *)&xmmword_1ED4D9FA0 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9FB0 - *((_QWORD *)&xmmword_1ED4D9FA0 + 1));
        goto LABEL_53;
      }
      break;
    case 7:
      v19 = atomic_load((unsigned __int8 *)&qword_1ED4D97B8);
      if ((v19 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97B8))
      {
        qword_1ED4D9FC0 = (uint64_t)"!!ARBfp1.0     \n"
                                   "##LEN=000000019d\n"
                                   "##                          \n"
                                   "##                            \n"
                                   "##                                \n"
                                   "##                                     \n"
                                   "##$\n"
                                   "OUTPUT $o0=result.color;\n"
                                   "ATTRIB $f7=fragment.texcoord[7];\n"
                                   "##%\n"
                                   "##@\n"
                                   "##7\n"
                                   "TEX $o0,$f7,texture[7],RECT;\n"
                                   "END\n"
                                   "##MD5=dd11faf4:09e5515e:92d0cd6f:ce9e10ae\n"
                                   "##SIG=00000000:00000080:00000080:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0008:08:0:1:0\n";
        qword_1ED4D9FC8 = 413;
        xmmword_1ED4D9FD0 = 0u;
        xmmword_1ED4D9FE0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9FC0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D97B8);
      }
      v20 = qword_1ED4D9FC8;
      *a2 = qword_1ED4D9FC0;
      a2[1] = v20;
      v21 = xmmword_1ED4D9FD0;
      if ((_QWORD)xmmword_1ED4D9FD0)
        ++*(_QWORD *)(xmmword_1ED4D9FD0 + 8);
      a2[3] = 0;
      a2[2] = v21;
      a2[4] = 0;
      a2[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4D9FD0 + 1);
      v8 = xmmword_1ED4D9FE0 - *((_QWORD *)&xmmword_1ED4D9FD0 + 1);
      if ((_QWORD)xmmword_1ED4D9FE0 != *((_QWORD *)&xmmword_1ED4D9FD0 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4D9FE0 - *((_QWORD *)&xmmword_1ED4D9FD0 + 1));
LABEL_53:
        a2[3] = v9;
        a2[4] = v9;
        v31 = &v9[2 * (v8 >> 1)];
        a2[5] = v31;
        memcpy(v9, v7, v8);
        a2[4] = v31;
      }
      break;
    default:
      *((_OWORD *)a2 + 1) = 0u;
      *((_OWORD *)a2 + 2) = 0u;
      *(_OWORD *)a2 = 0u;
      break;
  }
}

void sub_1B2A109F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGString::zero(HGString *this@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  int64_t v8;
  char *v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;

  if ((_DWORD)this == 394784)
  {
    if (a2 == 1)
    {
      v10 = atomic_load((unsigned __int8 *)&qword_1ED4D97E0);
      if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97E0))
      {
        qword_1ED4DA0B0 = (uint64_t)"//GLfs2.0      \n"
                                   "//LEN=0000000142\n"
                                   "#ifndef GL_ES\n"
                                   "#define lowp\n"
                                   "#define mediump\n"
                                   "#define highp\n"
                                   "#endif\n"
                                   "#define defaultp mediump\n"
                                   "void main()\n"
                                   "{\n"
                                   "\n"
                                   "    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
                                   "}\n"
                                   "//MD5=7adfdc9a:833a3e83:3a6b376d:41cc225f\n"
                                   "//SIG=00000000:00000000:00000000:00000000:0008:0000:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
        qword_1ED4DA0B8 = 322;
        xmmword_1ED4DA0C0 = 0u;
        xmmword_1ED4DA0D0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA0B0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D97E0);
      }
      v11 = qword_1ED4DA0B8;
      *a3 = qword_1ED4DA0B0;
      a3[1] = v11;
      v12 = xmmword_1ED4DA0C0;
      if ((_QWORD)xmmword_1ED4DA0C0)
        ++*(_QWORD *)(xmmword_1ED4DA0C0 + 8);
      a3[3] = 0;
      a3[2] = v12;
      a3[4] = 0;
      a3[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA0C0 + 1);
      v8 = xmmword_1ED4DA0D0 - *((_QWORD *)&xmmword_1ED4DA0C0 + 1);
      if ((_QWORD)xmmword_1ED4DA0D0 != *((_QWORD *)&xmmword_1ED4DA0C0 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA0D0 - *((_QWORD *)&xmmword_1ED4DA0C0 + 1));
        goto LABEL_45;
      }
      return;
    }
LABEL_25:
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
    return;
  }
  if ((_DWORD)this == 394000)
  {
    switch(a2)
    {
      case 1:
        v4 = atomic_load((unsigned __int8 *)&qword_1ED4D97C0);
        if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97C0))
        {
          qword_1ED4D9FF0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=0000000166\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "END\n"
                                     "##MD5=3ceff9da:f8e4fe0b:1f0d94c2:9c9fb061\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
          qword_1ED4D9FF8 = 358;
          xmmword_1ED4DA000 = 0u;
          xmmword_1ED4DA010 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4D9FF0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D97C0);
        }
        v5 = qword_1ED4D9FF8;
        *a3 = qword_1ED4D9FF0;
        a3[1] = v5;
        v6 = xmmword_1ED4DA000;
        if ((_QWORD)xmmword_1ED4DA000)
          ++*(_QWORD *)(xmmword_1ED4DA000 + 8);
        a3[3] = 0;
        a3[2] = v6;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA000 + 1);
        v8 = xmmword_1ED4DA010 - *((_QWORD *)&xmmword_1ED4DA000 + 1);
        if ((_QWORD)xmmword_1ED4DA010 == *((_QWORD *)&xmmword_1ED4DA000 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA010 - *((_QWORD *)&xmmword_1ED4DA000 + 1));
        break;
      case 2:
        v22 = atomic_load((unsigned __int8 *)&qword_1ED4D97C8);
        if ((v22 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97C8))
        {
          qword_1ED4DA020 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000018d\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "MOV $o1,0;\n"
                                     "END\n"
                                     "##MD5=4220a7e0:dd39f279:15beca1d:51f222cf\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:2:0\n";
          qword_1ED4DA028 = 397;
          xmmword_1ED4DA030 = 0u;
          xmmword_1ED4DA040 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA020, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D97C8);
        }
        v23 = qword_1ED4DA028;
        *a3 = qword_1ED4DA020;
        a3[1] = v23;
        v24 = xmmword_1ED4DA030;
        if ((_QWORD)xmmword_1ED4DA030)
          ++*(_QWORD *)(xmmword_1ED4DA030 + 8);
        a3[3] = 0;
        a3[2] = v24;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA030 + 1);
        v8 = xmmword_1ED4DA040 - *((_QWORD *)&xmmword_1ED4DA030 + 1);
        if ((_QWORD)xmmword_1ED4DA040 == *((_QWORD *)&xmmword_1ED4DA030 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA040 - *((_QWORD *)&xmmword_1ED4DA030 + 1));
        break;
      case 3:
        v16 = atomic_load((unsigned __int8 *)&qword_1ED4D97D0);
        if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97D0))
        {
          qword_1ED4DA050 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=00000001b4\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "MOV $o1,0;\n"
                                     "MOV $o2,0;\n"
                                     "END\n"
                                     "##MD5=c57659bc:b333a723:e93c4b2e:3d8afb44\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:3:0\n";
          qword_1ED4DA058 = 436;
          xmmword_1ED4DA060 = 0u;
          xmmword_1ED4DA070 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA050, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D97D0);
        }
        v17 = qword_1ED4DA058;
        *a3 = qword_1ED4DA050;
        a3[1] = v17;
        v18 = xmmword_1ED4DA060;
        if ((_QWORD)xmmword_1ED4DA060)
          ++*(_QWORD *)(xmmword_1ED4DA060 + 8);
        a3[3] = 0;
        a3[2] = v18;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA060 + 1);
        v8 = xmmword_1ED4DA070 - *((_QWORD *)&xmmword_1ED4DA060 + 1);
        if ((_QWORD)xmmword_1ED4DA070 == *((_QWORD *)&xmmword_1ED4DA060 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA070 - *((_QWORD *)&xmmword_1ED4DA060 + 1));
        break;
      case 4:
        v19 = atomic_load((unsigned __int8 *)&qword_1ED4D97D8);
        if ((v19 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97D8))
        {
          qword_1ED4DA080 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=00000001db\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "OUTPUT $o3=result.color[3];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,0;\n"
                                     "MOV $o1,0;\n"
                                     "MOV $o2,0;\n"
                                     "MOV $o3,0;\n"
                                     "END\n"
                                     "##MD5=cadf4aa4:08ce60f0:fa35326a:3fdb468b\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00:0:4:0\n";
          qword_1ED4DA088 = 475;
          xmmword_1ED4DA090 = 0u;
          xmmword_1ED4DA0A0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA080, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D97D8);
        }
        v20 = qword_1ED4DA088;
        *a3 = qword_1ED4DA080;
        a3[1] = v20;
        v21 = xmmword_1ED4DA090;
        if ((_QWORD)xmmword_1ED4DA090)
          ++*(_QWORD *)(xmmword_1ED4DA090 + 8);
        a3[3] = 0;
        a3[2] = v21;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA090 + 1);
        v8 = xmmword_1ED4DA0A0 - *((_QWORD *)&xmmword_1ED4DA090 + 1);
        if ((_QWORD)xmmword_1ED4DA0A0 == *((_QWORD *)&xmmword_1ED4DA090 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA0A0 - *((_QWORD *)&xmmword_1ED4DA090 + 1));
        break;
      default:
        goto LABEL_25;
    }
LABEL_45:
    a3[3] = v9;
    a3[4] = v9;
    v25 = &v9[2 * (v8 >> 1)];
    a3[5] = v25;
    memcpy(v9, v7, v8);
    a3[4] = v25;
    return;
  }
  if ((_DWORD)this != 396048 || a2 != 1)
    goto LABEL_25;
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4D97E8);
  if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97E8))
  {
    qword_1ED4DA0E0 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=0000000144\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]])\n"
                               "{\n"
                               "    FragmentOut out;\n"
                               "    out.color0 = float4(0.0, 0.0, 0.0, 0.0);\n"
                               "    return out;\n"
                               "}\n"
                               "//MD5=0e8c5223:95470a31:cf2258f7:9d6891f3\n"
                               "//SIG=00000000:00000000:00000000:00000000:0004:0000:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
    qword_1ED4DA0E8 = 324;
    xmmword_1ED4DA0F0 = 0u;
    xmmword_1ED4DA100 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA0E0, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4D97E8);
  }
  v14 = qword_1ED4DA0E8;
  *a3 = qword_1ED4DA0E0;
  a3[1] = v14;
  v15 = xmmword_1ED4DA0F0;
  if ((_QWORD)xmmword_1ED4DA0F0)
    ++*(_QWORD *)(xmmword_1ED4DA0F0 + 8);
  a3[3] = 0;
  a3[2] = v15;
  a3[4] = 0;
  a3[5] = 0;
  v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA0F0 + 1);
  v8 = xmmword_1ED4DA100 - *((_QWORD *)&xmmword_1ED4DA0F0 + 1);
  if ((_QWORD)xmmword_1ED4DA100 != *((_QWORD *)&xmmword_1ED4DA0F0 + 1))
  {
    if (v8 < 0)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v9 = (char *)operator new(xmmword_1ED4DA100 - *((_QWORD *)&xmmword_1ED4DA0F0 + 1));
    goto LABEL_45;
  }
}

void sub_1B2A10FBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGString::uniform(HGString *this@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  int64_t v8;
  char *v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;

  if ((_DWORD)this == 394784)
  {
    if (a2 == 1)
    {
      v10 = atomic_load((unsigned __int8 *)&qword_1ED4D9810);
      if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9810))
      {
        qword_1ED4DA1D0 = (uint64_t)"//GLfs2.0      \n"
                                   "//LEN=0000000161\n"
                                   "#ifndef GL_ES\n"
                                   "#define lowp\n"
                                   "#define mediump\n"
                                   "#define highp\n"
                                   "#endif\n"
                                   "#define defaultp mediump\n"
                                   "uniform defaultp vec4 hg_ProgramLocal0;\n"
                                   "void main()\n"
                                   "{\n"
                                   "    gl_FragColor = hg_ProgramLocal0;\n"
                                   "}\n"
                                   "//MD5=6f46fc08:7f6efe98:42430a53:9b0c48ab\n"
                                   "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
        qword_1ED4DA1D8 = 353;
        xmmword_1ED4DA1E0 = 0u;
        xmmword_1ED4DA1F0 = 0u;
        __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA1D0, &dword_1B2737000);
        __cxa_guard_release(&qword_1ED4D9810);
      }
      v11 = qword_1ED4DA1D8;
      *a3 = qword_1ED4DA1D0;
      a3[1] = v11;
      v12 = xmmword_1ED4DA1E0;
      if ((_QWORD)xmmword_1ED4DA1E0)
        ++*(_QWORD *)(xmmword_1ED4DA1E0 + 8);
      a3[3] = 0;
      a3[2] = v12;
      a3[4] = 0;
      a3[5] = 0;
      v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA1E0 + 1);
      v8 = xmmword_1ED4DA1F0 - *((_QWORD *)&xmmword_1ED4DA1E0 + 1);
      if ((_QWORD)xmmword_1ED4DA1F0 != *((_QWORD *)&xmmword_1ED4DA1E0 + 1))
      {
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA1F0 - *((_QWORD *)&xmmword_1ED4DA1E0 + 1));
        goto LABEL_45;
      }
      return;
    }
LABEL_25:
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
    return;
  }
  if ((_DWORD)this == 394000)
  {
    switch(a2)
    {
      case 1:
        v4 = atomic_load((unsigned __int8 *)&qword_1ED4D97F0);
        if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97F0))
        {
          qword_1ED4DA110 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=0000000184\n"
                                     "##                          \n"
                                     "##                            \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "END\n"
                                     "##MD5=d462425f:378ab328:d024cd98:47c08aa4\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
          qword_1ED4DA118 = 388;
          xmmword_1ED4DA120 = 0u;
          xmmword_1ED4DA130 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA110, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D97F0);
        }
        v5 = qword_1ED4DA118;
        *a3 = qword_1ED4DA110;
        a3[1] = v5;
        v6 = xmmword_1ED4DA120;
        if ((_QWORD)xmmword_1ED4DA120)
          ++*(_QWORD *)(xmmword_1ED4DA120 + 8);
        a3[3] = 0;
        a3[2] = v6;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA120 + 1);
        v8 = xmmword_1ED4DA130 - *((_QWORD *)&xmmword_1ED4DA120 + 1);
        if ((_QWORD)xmmword_1ED4DA130 == *((_QWORD *)&xmmword_1ED4DA120 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA130 - *((_QWORD *)&xmmword_1ED4DA120 + 1));
        break;
      case 2:
        v22 = atomic_load((unsigned __int8 *)&qword_1ED4D97F8);
        if ((v22 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D97F8))
        {
          qword_1ED4DA140 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=00000001c9\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "PARAM $p1=program.local[1];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "MOV $o1,$p1;\n"
                                     "END\n"
                                     "##MD5=738a1d38:64b2f1bf:c3afc4a3:dc2a01ed\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0002:0000:0000:0000:0000:0000:0000:0000:00:0:2:0\n";
          qword_1ED4DA148 = 457;
          xmmword_1ED4DA150 = 0u;
          xmmword_1ED4DA160 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA140, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D97F8);
        }
        v23 = qword_1ED4DA148;
        *a3 = qword_1ED4DA140;
        a3[1] = v23;
        v24 = xmmword_1ED4DA150;
        if ((_QWORD)xmmword_1ED4DA150)
          ++*(_QWORD *)(xmmword_1ED4DA150 + 8);
        a3[3] = 0;
        a3[2] = v24;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA150 + 1);
        v8 = xmmword_1ED4DA160 - *((_QWORD *)&xmmword_1ED4DA150 + 1);
        if ((_QWORD)xmmword_1ED4DA160 == *((_QWORD *)&xmmword_1ED4DA150 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA160 - *((_QWORD *)&xmmword_1ED4DA150 + 1));
        break;
      case 3:
        v16 = atomic_load((unsigned __int8 *)&qword_1ED4D9800);
        if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9800))
        {
          qword_1ED4DA170 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=000000020e\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "PARAM $p1=program.local[1];\n"
                                     "PARAM $p2=program.local[2];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "MOV $o1,$p1;\n"
                                     "MOV $o2,$p2;\n"
                                     "END\n"
                                     "##MD5=f7bc6585:49c7c440:b099ae3e:eb448ac4\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0003:0000:0000:0000:0000:0000:0000:0000:00:0:3:0\n";
          qword_1ED4DA178 = 526;
          xmmword_1ED4DA180 = 0u;
          xmmword_1ED4DA190 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA170, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9800);
        }
        v17 = qword_1ED4DA178;
        *a3 = qword_1ED4DA170;
        a3[1] = v17;
        v18 = xmmword_1ED4DA180;
        if ((_QWORD)xmmword_1ED4DA180)
          ++*(_QWORD *)(xmmword_1ED4DA180 + 8);
        a3[3] = 0;
        a3[2] = v18;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA180 + 1);
        v8 = xmmword_1ED4DA190 - *((_QWORD *)&xmmword_1ED4DA180 + 1);
        if ((_QWORD)xmmword_1ED4DA190 == *((_QWORD *)&xmmword_1ED4DA180 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA190 - *((_QWORD *)&xmmword_1ED4DA180 + 1));
        break;
      case 4:
        v19 = atomic_load((unsigned __int8 *)&qword_1ED4D9808);
        if ((v19 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9808))
        {
          qword_1ED4DA1A0 = (uint64_t)"!!ARBfp1.0     \n"
                                     "##LEN=0000000253\n"
                                     "##                          \n"
                                     "OPTION ARB_draw_buffers;      \n"
                                     "##                                \n"
                                     "##                                     \n"
                                     "##$\n"
                                     "OUTPUT $o0=result.color;\n"
                                     "OUTPUT $o1=result.color[1];\n"
                                     "OUTPUT $o2=result.color[2];\n"
                                     "OUTPUT $o3=result.color[3];\n"
                                     "PARAM $p0=program.local[0];\n"
                                     "PARAM $p1=program.local[1];\n"
                                     "PARAM $p2=program.local[2];\n"
                                     "PARAM $p3=program.local[3];\n"
                                     "##%\n"
                                     "##@\n"
                                     "MOV $o0,$p0;\n"
                                     "MOV $o1,$p1;\n"
                                     "MOV $o2,$p2;\n"
                                     "MOV $o3,$p3;\n"
                                     "END\n"
                                     "##MD5=b167705d:4bee0a9e:4099e1d1:d66d666c\n"
                                     "##SIG=00000000:00000000:00000000:00000000:0000:0004:0000:0000:0000:0000:0000:0000:0000:00:0:4:0\n";
          qword_1ED4DA1A8 = 595;
          xmmword_1ED4DA1B0 = 0u;
          xmmword_1ED4DA1C0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA1A0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9808);
        }
        v20 = qword_1ED4DA1A8;
        *a3 = qword_1ED4DA1A0;
        a3[1] = v20;
        v21 = xmmword_1ED4DA1B0;
        if ((_QWORD)xmmword_1ED4DA1B0)
          ++*(_QWORD *)(xmmword_1ED4DA1B0 + 8);
        a3[3] = 0;
        a3[2] = v21;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA1B0 + 1);
        v8 = xmmword_1ED4DA1C0 - *((_QWORD *)&xmmword_1ED4DA1B0 + 1);
        if ((_QWORD)xmmword_1ED4DA1C0 == *((_QWORD *)&xmmword_1ED4DA1B0 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA1C0 - *((_QWORD *)&xmmword_1ED4DA1B0 + 1));
        break;
      default:
        goto LABEL_25;
    }
LABEL_45:
    a3[3] = v9;
    a3[4] = v9;
    v25 = &v9[2 * (v8 >> 1)];
    a3[5] = v25;
    memcpy(v9, v7, v8);
    a3[4] = v25;
    return;
  }
  if ((_DWORD)this != 396048 || a2 != 1)
    goto LABEL_25;
  v13 = atomic_load((unsigned __int8 *)&qword_1ED4D9818);
  if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9818))
  {
    qword_1ED4DA200 = (uint64_t)"//Metal1.0     \n"
                               "//LEN=000000016d\n"
                               "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                               "    const constant float4* hg_Params [[ buffer(0) ]])\n"
                               "{\n"
                               "    FragmentOut out;\n"
                               "    out.color0 = hg_Params[0];\n"
                               "    return out;\n"
                               "}\n"
                               "//MD5=4c294923:0d8b5516:557382a3:0e90cae8\n"
                               "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0000:00:0:1:0\n";
    qword_1ED4DA208 = 365;
    xmmword_1ED4DA210 = 0u;
    xmmword_1ED4DA220 = 0u;
    __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA200, &dword_1B2737000);
    __cxa_guard_release(&qword_1ED4D9818);
  }
  v14 = qword_1ED4DA208;
  *a3 = qword_1ED4DA200;
  a3[1] = v14;
  v15 = xmmword_1ED4DA210;
  if ((_QWORD)xmmword_1ED4DA210)
    ++*(_QWORD *)(xmmword_1ED4DA210 + 8);
  a3[3] = 0;
  a3[2] = v15;
  a3[4] = 0;
  a3[5] = 0;
  v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA210 + 1);
  v8 = xmmword_1ED4DA220 - *((_QWORD *)&xmmword_1ED4DA210 + 1);
  if ((_QWORD)xmmword_1ED4DA220 != *((_QWORD *)&xmmword_1ED4DA210 + 1))
  {
    if (v8 < 0)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v9 = (char *)operator new(xmmword_1ED4DA220 - *((_QWORD *)&xmmword_1ED4DA210 + 1));
    goto LABEL_45;
  }
}

void sub_1B2A11580(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGString::transform(HGString *this@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  int64_t v8;
  char *v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;

  if ((_DWORD)this == 329232)
  {
    switch(a2)
    {
      case 0:
        v4 = atomic_load((unsigned __int8 *)&qword_1ED4D9820);
        if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9820))
        {
          qword_1ED4DA230 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000132\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "}\n"
                                     "//MD5=798335e4:f8112073:f251d283:ad257ca6\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0004:0000:0000:0000:0000:0000:0000:0000:00:0:0:0\n";
          qword_1ED4DA238 = 306;
          xmmword_1ED4DA240 = 0u;
          xmmword_1ED4DA250 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA230, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9820);
        }
        v5 = qword_1ED4DA238;
        *a3 = qword_1ED4DA230;
        a3[1] = v5;
        v6 = xmmword_1ED4DA240;
        if ((_QWORD)xmmword_1ED4DA240)
          ++*(_QWORD *)(xmmword_1ED4DA240 + 8);
        a3[3] = 0;
        a3[2] = v6;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA240 + 1);
        v8 = xmmword_1ED4DA250 - *((_QWORD *)&xmmword_1ED4DA240 + 1);
        if ((_QWORD)xmmword_1ED4DA250 == *((_QWORD *)&xmmword_1ED4DA240 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA250 - *((_QWORD *)&xmmword_1ED4DA240 + 1));
        break;
      case 1:
        v22 = atomic_load((unsigned __int8 *)&qword_1ED4D9828);
        if ((v22 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9828))
        {
          qword_1ED4DA260 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000001c9\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "}\n"
                                     "//MD5=71174425:010f0f7c:df2f36ee:91448d34\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0008:0000:0000:0000:0000:0000:0000:0001:00:0:0:0\n";
          qword_1ED4DA268 = 457;
          xmmword_1ED4DA270 = 0u;
          xmmword_1ED4DA280 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA260, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9828);
        }
        v23 = qword_1ED4DA268;
        *a3 = qword_1ED4DA260;
        a3[1] = v23;
        v24 = xmmword_1ED4DA270;
        if ((_QWORD)xmmword_1ED4DA270)
          ++*(_QWORD *)(xmmword_1ED4DA270 + 8);
        a3[3] = 0;
        a3[2] = v24;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA270 + 1);
        v8 = xmmword_1ED4DA280 - *((_QWORD *)&xmmword_1ED4DA270 + 1);
        if ((_QWORD)xmmword_1ED4DA280 == *((_QWORD *)&xmmword_1ED4DA270 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA280 - *((_QWORD *)&xmmword_1ED4DA270 + 1));
        break;
      case 2:
        v13 = atomic_load((unsigned __int8 *)&qword_1ED4D9830);
        if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9830))
        {
          qword_1ED4DA290 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000260\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "}\n"
                                     "//MD5=0d16a22d:f5ee5b44:fa0fdd4e:171d7327\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:000c:0000:0000:0000:0000:0000:0000:0002:00:0:0:0\n";
          qword_1ED4DA298 = 608;
          xmmword_1ED4DA2A0 = 0u;
          xmmword_1ED4DA2B0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA290, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9830);
        }
        v14 = qword_1ED4DA298;
        *a3 = qword_1ED4DA290;
        a3[1] = v14;
        v15 = xmmword_1ED4DA2A0;
        if ((_QWORD)xmmword_1ED4DA2A0)
          ++*(_QWORD *)(xmmword_1ED4DA2A0 + 8);
        a3[3] = 0;
        a3[2] = v15;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA2A0 + 1);
        v8 = xmmword_1ED4DA2B0 - *((_QWORD *)&xmmword_1ED4DA2A0 + 1);
        if ((_QWORD)xmmword_1ED4DA2B0 == *((_QWORD *)&xmmword_1ED4DA2A0 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA2B0 - *((_QWORD *)&xmmword_1ED4DA2A0 + 1));
        break;
      case 3:
        v16 = atomic_load((unsigned __int8 *)&qword_1ED4D9838);
        if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9838))
        {
          qword_1ED4DA2C0 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000002f7\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "}\n"
                                     "//MD5=46e1660d:64e5cba3:90dbf667:6da3c1bc\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0010:0000:0000:0000:0000:0000:0000:0003:00:0:0:0\n";
          qword_1ED4DA2C8 = 759;
          xmmword_1ED4DA2D0 = 0u;
          xmmword_1ED4DA2E0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA2C0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9838);
        }
        v17 = qword_1ED4DA2C8;
        *a3 = qword_1ED4DA2C0;
        a3[1] = v17;
        v18 = xmmword_1ED4DA2D0;
        if ((_QWORD)xmmword_1ED4DA2D0)
          ++*(_QWORD *)(xmmword_1ED4DA2D0 + 8);
        a3[3] = 0;
        a3[2] = v18;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA2D0 + 1);
        v8 = xmmword_1ED4DA2E0 - *((_QWORD *)&xmmword_1ED4DA2D0 + 1);
        if ((_QWORD)xmmword_1ED4DA2E0 == *((_QWORD *)&xmmword_1ED4DA2D0 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA2E0 - *((_QWORD *)&xmmword_1ED4DA2D0 + 1));
        break;
      case 4:
        v10 = atomic_load((unsigned __int8 *)&qword_1ED4D9840);
        if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9840))
        {
          qword_1ED4DA2F0 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=000000038e\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "}\n"
                                     "//MD5=50ca4534:b10918ea:75eb3624:be748584\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0014:0000:0000:0000:0000:0000:0000:0004:00:0:0:0\n";
          qword_1ED4DA2F8 = 910;
          xmmword_1ED4DA300 = 0u;
          xmmword_1ED4DA310 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA2F0, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9840);
        }
        v11 = qword_1ED4DA2F8;
        *a3 = qword_1ED4DA2F0;
        a3[1] = v11;
        v12 = xmmword_1ED4DA300;
        if ((_QWORD)xmmword_1ED4DA300)
          ++*(_QWORD *)(xmmword_1ED4DA300 + 8);
        a3[3] = 0;
        a3[2] = v12;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA300 + 1);
        v8 = xmmword_1ED4DA310 - *((_QWORD *)&xmmword_1ED4DA300 + 1);
        if ((_QWORD)xmmword_1ED4DA310 == *((_QWORD *)&xmmword_1ED4DA300 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA310 - *((_QWORD *)&xmmword_1ED4DA300 + 1));
        break;
      case 5:
        v25 = atomic_load((unsigned __int8 *)&qword_1ED4D9848);
        if ((v25 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9848))
        {
          qword_1ED4DA320 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000425\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "}\n"
                                     "//MD5=9d94f62f:3562211b:261ee061:c15dfe35\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0018:0000:0000:0000:0000:0000:0000:0005:00:0:0:0\n";
          qword_1ED4DA328 = 1061;
          xmmword_1ED4DA330 = 0u;
          xmmword_1ED4DA340 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA320, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9848);
        }
        v26 = qword_1ED4DA328;
        *a3 = qword_1ED4DA320;
        a3[1] = v26;
        v27 = xmmword_1ED4DA330;
        if ((_QWORD)xmmword_1ED4DA330)
          ++*(_QWORD *)(xmmword_1ED4DA330 + 8);
        a3[3] = 0;
        a3[2] = v27;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA330 + 1);
        v8 = xmmword_1ED4DA340 - *((_QWORD *)&xmmword_1ED4DA330 + 1);
        if ((_QWORD)xmmword_1ED4DA340 == *((_QWORD *)&xmmword_1ED4DA330 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA340 - *((_QWORD *)&xmmword_1ED4DA330 + 1));
        break;
      case 6:
        v28 = atomic_load((unsigned __int8 *)&qword_1ED4D9850);
        if ((v28 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9850))
        {
          qword_1ED4DA350 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000004bc\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "uniform mat4 hg_TextureMatrix5;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "attribute vec4 hg_MultiTexCoord5;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "varying vec4 hg_TexCoord5;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "    hg_TexCoord5 = hg_TextureMatrix5 * hg_MultiTexCoord5;\n"
                                     "}\n"
                                     "//MD5=450acf6f:24c8abd8:64c7ce12:3c4bd63d\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:001c:0000:0000:0000:0000:0000:0000:0006:00:0:0:0\n";
          qword_1ED4DA358 = 1212;
          xmmword_1ED4DA360 = 0u;
          xmmword_1ED4DA370 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA350, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9850);
        }
        v29 = qword_1ED4DA358;
        *a3 = qword_1ED4DA350;
        a3[1] = v29;
        v30 = xmmword_1ED4DA360;
        if ((_QWORD)xmmword_1ED4DA360)
          ++*(_QWORD *)(xmmword_1ED4DA360 + 8);
        a3[3] = 0;
        a3[2] = v30;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA360 + 1);
        v8 = xmmword_1ED4DA370 - *((_QWORD *)&xmmword_1ED4DA360 + 1);
        if ((_QWORD)xmmword_1ED4DA370 == *((_QWORD *)&xmmword_1ED4DA360 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA370 - *((_QWORD *)&xmmword_1ED4DA360 + 1));
        break;
      case 7:
        v19 = atomic_load((unsigned __int8 *)&qword_1ED4D9858);
        if ((v19 & 1) == 0 && __cxa_guard_acquire(&qword_1ED4D9858))
        {
          qword_1ED4DA380 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=0000000553\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "uniform mat4 hg_TextureMatrix5;\n"
                                     "uniform mat4 hg_TextureMatrix6;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "attribute vec4 hg_MultiTexCoord5;\n"
                                     "attribute vec4 hg_MultiTexCoord6;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "varying vec4 hg_TexCoord5;\n"
                                     "varying vec4 hg_TexCoord6;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "    hg_TexCoord5 = hg_TextureMatrix5 * hg_MultiTexCoord5;\n"
                                     "    hg_TexCoord6 = hg_TextureMatrix6 * hg_MultiTexCoord6;\n"
                                     "}\n"
                                     "//MD5=7dfc62a1:3d3ce3a2:d06f47b1:41964040\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0020:0000:0000:0000:0000:0000:0000:0007:00:0:0:0\n";
          qword_1ED4DA388 = 1363;
          xmmword_1ED4DA390 = 0u;
          xmmword_1ED4DA3A0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA380, &dword_1B2737000);
          __cxa_guard_release(&qword_1ED4D9858);
        }
        v20 = qword_1ED4DA388;
        *a3 = qword_1ED4DA380;
        a3[1] = v20;
        v21 = xmmword_1ED4DA390;
        if ((_QWORD)xmmword_1ED4DA390)
          ++*(_QWORD *)(xmmword_1ED4DA390 + 8);
        a3[3] = 0;
        a3[2] = v21;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA390 + 1);
        v8 = xmmword_1ED4DA3A0 - *((_QWORD *)&xmmword_1ED4DA390 + 1);
        if ((_QWORD)xmmword_1ED4DA3A0 == *((_QWORD *)&xmmword_1ED4DA390 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA3A0 - *((_QWORD *)&xmmword_1ED4DA390 + 1));
        break;
      case 8:
        v31 = atomic_load((unsigned __int8 *)qword_1ED4D9860);
        if ((v31 & 1) == 0 && __cxa_guard_acquire(qword_1ED4D9860))
        {
          qword_1ED4DA3B0 = (uint64_t)"//GLvs2.0      \n"
                                     "//LEN=00000005ea\n"
                                     "attribute vec4 hg_Position;\n"
                                     "uniform mat4 hg_ProjectionMatrix;\n"
                                     "uniform mat4 hg_TextureMatrix0;\n"
                                     "uniform mat4 hg_TextureMatrix1;\n"
                                     "uniform mat4 hg_TextureMatrix2;\n"
                                     "uniform mat4 hg_TextureMatrix3;\n"
                                     "uniform mat4 hg_TextureMatrix4;\n"
                                     "uniform mat4 hg_TextureMatrix5;\n"
                                     "uniform mat4 hg_TextureMatrix6;\n"
                                     "uniform mat4 hg_TextureMatrix7;\n"
                                     "attribute vec4 hg_MultiTexCoord0;\n"
                                     "attribute vec4 hg_MultiTexCoord1;\n"
                                     "attribute vec4 hg_MultiTexCoord2;\n"
                                     "attribute vec4 hg_MultiTexCoord3;\n"
                                     "attribute vec4 hg_MultiTexCoord4;\n"
                                     "attribute vec4 hg_MultiTexCoord5;\n"
                                     "attribute vec4 hg_MultiTexCoord6;\n"
                                     "attribute vec4 hg_MultiTexCoord7;\n"
                                     "varying vec4 hg_TexCoord0;\n"
                                     "varying vec4 hg_TexCoord1;\n"
                                     "varying vec4 hg_TexCoord2;\n"
                                     "varying vec4 hg_TexCoord3;\n"
                                     "varying vec4 hg_TexCoord4;\n"
                                     "varying vec4 hg_TexCoord5;\n"
                                     "varying vec4 hg_TexCoord6;\n"
                                     "varying vec4 hg_TexCoord7;\n"
                                     "void main(void)\n"
                                     "{\n"
                                     "    gl_Position = hg_ProjectionMatrix * hg_Position;\n"
                                     "    hg_TexCoord0 = hg_TextureMatrix0 * hg_MultiTexCoord0;\n"
                                     "    hg_TexCoord1 = hg_TextureMatrix1 * hg_MultiTexCoord1;\n"
                                     "    hg_TexCoord2 = hg_TextureMatrix2 * hg_MultiTexCoord2;\n"
                                     "    hg_TexCoord3 = hg_TextureMatrix3 * hg_MultiTexCoord3;\n"
                                     "    hg_TexCoord4 = hg_TextureMatrix4 * hg_MultiTexCoord4;\n"
                                     "    hg_TexCoord5 = hg_TextureMatrix5 * hg_MultiTexCoord5;\n"
                                     "    hg_TexCoord6 = hg_TextureMatrix6 * hg_MultiTexCoord6;\n"
                                     "    hg_TexCoord7 = hg_TextureMatrix7 * hg_MultiTexCoord7;\n"
                                     "}\n"
                                     "//MD5=b215da98:d83418c2:544c293f:9ac9d419\n"
                                     "//SIG=00000000:00000000:00000000:00000000:0000:0024:0000:0000:0000:0000:0000:0000:0008:00:0:0:0\n";
          qword_1ED4DA3B8 = 1514;
          xmmword_1ED4DA3C0 = 0u;
          xmmword_1ED4DA3D0 = 0u;
          __cxa_atexit((void (*)(void *))string_t::~string_t, &qword_1ED4DA3B0, &dword_1B2737000);
          __cxa_guard_release(qword_1ED4D9860);
        }
        v32 = qword_1ED4DA3B8;
        *a3 = qword_1ED4DA3B0;
        a3[1] = v32;
        v33 = xmmword_1ED4DA3C0;
        if ((_QWORD)xmmword_1ED4DA3C0)
          ++*(_QWORD *)(xmmword_1ED4DA3C0 + 8);
        a3[3] = 0;
        a3[2] = v33;
        a3[4] = 0;
        a3[5] = 0;
        v7 = (const void *)*((_QWORD *)&xmmword_1ED4DA3C0 + 1);
        v8 = xmmword_1ED4DA3D0 - *((_QWORD *)&xmmword_1ED4DA3C0 + 1);
        if ((_QWORD)xmmword_1ED4DA3D0 == *((_QWORD *)&xmmword_1ED4DA3C0 + 1))
          return;
        if (v8 < 0)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v9 = (char *)operator new(xmmword_1ED4DA3D0 - *((_QWORD *)&xmmword_1ED4DA3C0 + 1));
        break;
      default:
        goto LABEL_9;
    }
    a3[3] = v9;
    a3[4] = v9;
    v34 = &v9[2 * (v8 >> 1)];
    a3[5] = v34;
    memcpy(v9, v7, v8);
    a3[4] = v34;
  }
  else
  {
LABEL_9:
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
  }
}

void sub_1B2A11D7C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

__n128 HGString::Digest::operator=(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

char *arb::begin(string_t *this, string_t *a2, const HGLimits *a3, const HGLimits *a4)
{
  int v7;
  string_t v8;
  unsigned int v9;
  char *result;
  int v11;
  int v12;
  _OWORD *v13;
  int v14;
  int v15;
  int v16;
  __int16 v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  int v22;
  signed int v23;
  int v24;
  __int16 v25;
  __int16 v26;
  string_t v27;
  string_t v28;
  const char *v29;
  const char *v30;
  const char *v31;
  char *v32;
  unsigned int v33;
  const char *v34;
  __int128 v35;
  uint64_t v36;
  string_t v37;
  char *v38;
  uint64_t v39;
  size_t v40;
  unsigned int v41;
  int v42;

  v7 = *(_DWORD *)a3;
  v8 = this[1];
  if (v8)
  {
    str_alloc(this, (uint64_t)v8);
    (*this)[(_QWORD)this[1] - 142] = 35;
    v9 = v7 & 0xFE00;
    result = (char *)*this;
    v11 = *(_DWORD *)a2;
    v12 = *(_DWORD *)a3;
    if (*(_DWORD *)a2 == *(_DWORD *)a3)
      goto LABEL_3;
  }
  else
  {
    str_alloc(this, 168);
    this[1] = (string_t)168;
    v9 = v7 & 0xFE00;
    result = (char *)*this;
    v11 = *(_DWORD *)a2;
    v12 = *(_DWORD *)a3;
    if (*(_DWORD *)a2 == *(_DWORD *)a3)
    {
LABEL_3:
      v13 = result + 62;
      if (v9 >= 0x600)
      {
LABEL_4:
        qmemcpy(v13, "//                            \n//                                \n##                                     \n", 106);
        return result;
      }
      goto LABEL_74;
    }
  }
  v14 = v7 >> 4;
  v15 = v7 & 0xF;
  v16 = v7 & 0xFFF00;
  if ((v7 & 0xFFF00u) > 0x505FF)
  {
    if ((v7 & 0xFFF00u) > 0x603FF)
    {
      if ((v7 & 0xFFF00u) > 0x605FF)
      {
        if (v16 != 394752)
        {
          if (v16 != 395008)
          {
            if (v16 != 460288)
              return result;
            v17 = 29557;
            goto LABEL_47;
          }
          v18 = 29542;
LABEL_49:
          *((_WORD *)result + 2) = v18;
          v22 = 1195585327;
          goto LABEL_57;
        }
        v17 = 29542;
        goto LABEL_47;
      }
      if (v16 != 394240)
      {
        if (v16 != 394496)
          return result;
        v20 = 28774;
LABEL_40:
        *((_WORD *)result + 2) = v20;
        v22 = 1195909409;
LABEL_57:
        *(_DWORD *)result = v22;
        result += 6;
        goto LABEL_58;
      }
      if ((v12 & 0xC0) != 0)
      {
        v26 = 28774;
LABEL_56:
        *((_WORD *)result + 2) = v26;
        v22 = 1447960865;
        goto LABEL_57;
      }
      v15 = 0;
      v42 = 1885749842;
LABEL_104:
      *(_DWORD *)(result + 3) = v42;
      *(_DWORD *)result = 1380000033;
      result += 7;
      v14 = 1;
      goto LABEL_58;
    }
    if ((v7 & 0xFFF00u) <= 0x601FF)
    {
      if (v16 != 329216)
      {
        if (v16 != 329472)
          return result;
        v18 = 29558;
        goto LABEL_49;
      }
      v17 = 29558;
LABEL_47:
      *((_WORD *)result + 2) = v17;
      v22 = 1279733551;
      goto LABEL_57;
    }
    if (v16 != 393728)
    {
      if (v16 != 393984)
        return result;
      v19 = 1885749842;
      goto LABEL_36;
    }
    v23 = v7 & 0xFFF00000;
    if ((int)(v7 & 0xFFF00000) > 69206015)
    {
      if (v23 <= 72351743)
      {
        if (v23 != 69206016)
        {
          v24 = 70254592;
          goto LABEL_107;
        }
LABEL_108:
        *(_DWORD *)(result + 3) = 1885750611;
        v21 = 1397956897;
        goto LABEL_109;
      }
      if (v23 == 72351744)
        goto LABEL_108;
      v24 = 73400320;
LABEL_107:
      if (v23 != v24)
        goto LABEL_58;
      goto LABEL_108;
    }
    if (v23)
    {
      if (v23 != 0x1000000)
      {
        v24 = 68157440;
        goto LABEL_107;
      }
      v25 = 30579;
    }
    else
    {
      v25 = 28774;
    }
LABEL_52:
    *((_WORD *)result + 2) = v25;
    v22 = 1229136161;
    goto LABEL_57;
  }
  if ((v7 & 0xFFF00u) > 0x501FF)
  {
    if ((v7 & 0xFFF00u) > 0x503FF)
    {
      if (v16 != 328704)
      {
        if (v16 != 328960)
          return result;
        v20 = 28790;
        goto LABEL_40;
      }
      v41 = v12 >> 4;
      if (v41 <= 1)
      {
        *(_DWORD *)result = 1347821857;
        result += 4;
        goto LABEL_58;
      }
      if (v41 > 3)
      {
        v26 = 28790;
        goto LABEL_56;
      }
      v15 = 0;
      v42 = 1886798418;
      goto LABEL_104;
    }
    if (v16 != 328192)
    {
      if (v16 != 328448)
        return result;
      v19 = 1886798418;
LABEL_36:
      *(_DWORD *)(result + 3) = v19;
      v21 = 1380000033;
LABEL_109:
      *(_DWORD *)result = v21;
      result += 7;
      goto LABEL_58;
    }
    v25 = 28790;
    goto LABEL_52;
  }
  if ((v7 & 0xFFF00u) <= 0x303FF)
  {
    if (v16 != 66048)
    {
      if (v16 != 132608)
        return result;
      v17 = 29552;
      goto LABEL_47;
    }
    v25 = 28784;
    goto LABEL_52;
  }
  if (v16 == 197632)
  {
    v26 = 28775;
    goto LABEL_56;
  }
  if (v16 != 263168)
    return result;
  result[4] = 80;
  *(_DWORD *)result = 1398153505;
  result += 5;
LABEL_58:
  if (v15 | v14)
  {
    *result = v14 | 0x30;
    result[1] = 46;
    result[2] = v15 | 0x30;
    result += 3;
  }
  v27 = *this;
  v28 = *this + 15;
  result = (char *)memset(result, 32, v28 - result);
  *((_BYTE *)v27 + 15) = 10;
  *((_BYTE *)v27 + 32) = 10;
  if (v9 < 0x600)
    v29 = "##LEN=0000000000\n";
  else
    v29 = "//LEN=0000000000\n";
  *((_OWORD *)v27 + 1) = *(_OWORD *)v29;
  if (v7 > 394255)
  {
    if (v7 == 394256)
    {
      v30 = "OPTION NV_fragment_program; \n";
      goto LABEL_72;
    }
    if (v7 == 394272)
    {
      v30 = "OPTION NV_fragment_program2;\n";
      goto LABEL_72;
    }
LABEL_93:
    v13 = v28 + 47;
    if (v9 >= 0x600)
    {
      qmemcpy((void *)(v28 + 18), "//                          \n", 29);
      goto LABEL_4;
    }
    qmemcpy((void *)(v28 + 18), "##                          \n", 29);
    goto LABEL_73;
  }
  if (v7 == 328736)
  {
    v30 = "OPTION NV_vertex_program2;  \n";
    goto LABEL_72;
  }
  if (v7 != 328752)
    goto LABEL_93;
  v30 = "OPTION NV_vertex_program3;  \n";
LABEL_72:
  *(_OWORD *)(v28 + 18) = *(_OWORD *)v30;
  *(_OWORD *)(v28 + 31) = *(_OWORD *)(v30 + 13);
  v13 = v28 + 47;
LABEL_73:
  v11 = *(_DWORD *)a2;
LABEL_74:
  if (!v11
    || *((unsigned __int8 *)a2 + 42) != *((unsigned __int8 *)a3 + 42)
    || (*((_DWORD *)a3 + 1) ^ *((_DWORD *)a2 + 1)) >> 30)
  {
    if (*((_DWORD *)a3 + 1) >> 30 == 3)
    {
      v31 = "OPTION ARB_position_invariant;\n";
    }
    else if ((*(_DWORD *)a3 & 0xF0000) == 0x60000 && *((unsigned __int8 *)a3 + 42) >= 2u)
    {
      v31 = "OPTION ARB_draw_buffers;      \n";
    }
    else
    {
      v31 = "##                            \n";
    }
    *v13 = *(_OWORD *)v31;
    *(_OWORD *)((char *)v13 + 15) = *(_OWORD *)(v31 + 15);
    v32 = (char *)v13 + 31;
    v33 = *((_DWORD *)a3 + 1) & 0xC0000000;
    if (v33 == 0x80000000)
    {
      *(_DWORD *)(v32 + 31) = 169884532;
      v34 = "OPTION ARB_precision_hint_nicest; \n";
    }
    else if (v33 == 0x40000000)
    {
      *(_DWORD *)(v32 + 31) = 171668595;
      v34 = "OPTION ARB_precision_hint_fastest;\n";
    }
    else
    {
      *(_DWORD *)(v32 + 31) = 169877536;
      v34 = "##                                \n";
    }
    v35 = *((_OWORD *)v34 + 1);
    *(_OWORD *)v32 = *(_OWORD *)v34;
    *((_OWORD *)v32 + 1) = v35;
  }
  v36 = *((unsigned __int8 *)a3 + 43);
  if (v36 <= 7)
  {
    v37 = *this;
    v38 = (char *)(*this + 128);
    if (*((_BYTE *)a3 + 43))
    {
      v39 = 4 * v36;
      v40 = 4 * v36 + 4;
      memcpy(v38, "TEMP $t0,$t1,$t2,$t3,$t4,$t5,$t6,$t7;  \n", v40);
      v38[v40] = 59;
      result = (char *)memset(&v38[v40 + 1], 32, 34 - v39);
      *((_BYTE *)v37 + 167) = 10;
    }
    else
    {
      qmemcpy(v38, "##                                     \n", 40);
    }
  }
  return result;
}

void arb::write(string_t *this, string_t *a2, const HGShaderBinding *a3, const HGLimits *a4, unsigned int a5, const HGLimits *__src, int a7, const char *a8, BOOL a9, unsigned int a10, int a11, BOOL a12)
{
  int v12;
  const char *v13;
  unsigned __int8 *v16;
  const char *v17;
  int v18;
  unsigned __int8 *v19;
  string_t v20;
  string_t v21;
  unint64_t v22;
  size_t v23;
  const char *v24;
  char *v25;
  int v26;
  _BYTE *v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  size_t v35;
  string_t v36;
  string_t v37;
  unint64_t v38;
  size_t v39;
  const char *v40;
  char *v41;
  string_t v42;
  string_t v43;
  unint64_t v44;
  size_t v45;
  const char *v46;
  char *v47;
  int v48;
  int v49;
  const char *v50;
  size_t v51;
  string_t v52;
  string_t v53;
  unint64_t v54;
  size_t v55;
  const char *v56;
  char *v57;
  size_t v58;
  string_t v59;
  string_t v60;
  unint64_t v61;
  size_t v62;
  const char *v63;
  char *v64;
  string_t v65;
  int v66;
  unsigned int v67;
  signed int v68;
  int v69;
  string_t v70;
  int v71;
  int v72;
  unsigned int v73;
  unsigned int v74;
  int v75;
  int v76;
  int v77;
  int64_t v78;
  string_t v79;
  string_t v80;
  unint64_t v81;
  size_t v82;
  const char *v83;
  char *v84;
  string_t v85;
  string_t v86;
  unint64_t v87;
  const char *v88;
  char *v89;
  string_t v90;
  arb *v91;
  int v92;
  int *v93;
  int v94;
  int v95;
  size_t v96;
  string_t v97;
  string_t v98;
  unint64_t v99;
  size_t v100;
  const char *v101;
  char *v102;
  string_t v103;
  unsigned int *v104;
  unsigned __int8 *v105;
  string_t v106;
  unint64_t v107;
  unint64_t v108;
  const char *v109;
  char *v110;
  string_t v111;
  signed int v112;
  string_t v113;
  string_t v114;
  unint64_t v115;
  const char *v116;
  char *v117;
  uint64_t v118;
  string_t v119;
  const char *v120;
  unint64_t v121;
  const char *v122;
  char *v123;
  string_t v124;
  string_t v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  char *v129;
  string_t v130;
  int v131;
  string_t v132;
  string_t v133;
  unint64_t v134;
  const char *v135;
  char *v136;
  BOOL v137;
  string_t v138;
  string_t v139;
  string_t v140;
  const char *v141;
  unsigned int v142;
  unsigned int v143;
  int v144;
  const char *v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  const char *v151;
  unsigned int v152;
  unsigned int v153;
  int v154;
  const char *v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  string_t v161;
  string_t v162;
  unint64_t v163;
  const char *v164;
  char *v165;
  string_t v166;
  string_t v167;
  unint64_t v168;
  const char *v169;
  char *v170;
  string_t v171;
  char *v172;
  unsigned __int8 *v173;
  uint64_t v174;
  int v175;
  uint64_t v176;
  string_t v177;
  string_t v178;
  const char *v179;
  size_t v180;
  void *v181;
  void *v182;
  string_t v183;
  string_t v184;
  char *v185;
  unsigned __int8 *v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  string_t v192;
  string_t v193;
  signed int v194;
  char *v195;
  uint64_t v196;
  void *v197;
  void *v198;
  string_t v199;
  string_t v200;
  const char *v201;
  const char *v202;
  char *v203;
  uint32x4_t v204;
  int16x8_t v205;
  uint8x8_t v206;
  __int32 v207;
  unsigned int v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  string_t v217;
  string_t v218;
  unint64_t v219;
  const char *v220;
  char *v221;
  string_t v222;
  string_t v223;
  string_t v224;
  unint64_t v225;
  const char *v226;
  char *v227;
  string_t v228;
  string_t v229;
  string_t v230;
  unint64_t v231;
  const char *v232;
  char *v233;
  int v234;
  string_t v235;
  int v236;
  int v237;
  string_t v238;
  string_t v239;
  unint64_t v240;
  const char *v241;
  char *v242;
  string_t v243;
  string_t v244;
  string_t v245;
  string_t v246;
  unint64_t v247;
  const char *v248;
  char *v249;
  string_t v250;
  string_t v251;
  unint64_t v252;
  const char *v253;
  char *v254;
  unsigned int v255;
  signed int v256;
  uint64_t v257;
  int v258;
  int v259;
  int v260;
  int v261;
  int v262;
  int v263;
  int v264;
  int v265;
  size_t v266;
  const char *v267;
  int v268;
  unint64_t v270;
  string_t v271;
  size_t v272;
  const char *v273;
  char *v274;
  unint64_t v275;
  string_t v276;
  size_t v277;
  const char *v278;
  char *v279;
  unsigned __int8 *v280;
  string_t v281;
  int v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  string_t v288;
  string_t v289;
  unint64_t v290;
  const char *v291;
  char *v292;
  signed int v293;
  char *v294;
  uint64_t v295;
  string_t v296;
  int v297;
  string_t v298;
  string_t v299;
  unint64_t v300;
  const char *v301;
  char *v302;
  int v303;
  int v304;
  string_t v305;
  int v306;
  int v307;
  string_t v308;
  string_t v309;
  unint64_t v310;
  const char *v311;
  char *v312;
  char *v313;
  uint32x4_t v314;
  int16x8_t v315;
  uint8x8_t v316;
  __int32 v317;
  unsigned int v318;
  int v319;
  int v320;
  int v321;
  int v322;
  int v323;
  int v324;
  int v325;
  int v326;
  uint32x4_t v327;
  int16x8_t v328;
  uint8x8_t v329;
  __int32 v330;
  unint64_t v331;
  string_t v332;
  size_t v333;
  const char *v334;
  char *v335;
  string_t v336;
  int v337;
  int v338;
  int v339;
  string_t v340;
  string_t v341;
  unint64_t v342;
  const char *v343;
  char *v344;
  int v345;
  uint64_t v346;
  string_t v347;
  char *v348;
  int v349;
  int64_t v350;
  size_t v351;
  string_t v352;
  string_t v353;
  unint64_t v354;
  const char *v355;
  char *v356;
  uint64_t v357;
  string_t v358;
  char *v359;
  int v360;
  int64_t v361;
  size_t v362;
  string_t v363;
  string_t v364;
  unint64_t v365;
  const char *v366;
  char *v367;
  string_t v368;
  const char *v369;
  unsigned int v370;
  unsigned int v371;
  int v372;
  const char *v373;
  int v374;
  int v375;
  int v376;
  int v377;
  int v378;
  string_t v379;
  string_t v380;
  unint64_t v381;
  const char *v382;
  char *v383;
  string_t v384;
  const char *v385;
  unsigned int v386;
  unsigned int v387;
  int v388;
  const char *v389;
  int v390;
  int v391;
  int v392;
  int v393;
  int v394;
  string_t v395;
  string_t v396;
  unint64_t v397;
  const char *v398;
  char *v399;
  uint64_t v400;
  string_t v401;
  char *v402;
  int v403;
  int64_t v404;
  size_t v405;
  string_t v406;
  string_t v407;
  unint64_t v408;
  const char *v409;
  char *v410;
  uint64_t v411;
  string_t v412;
  char *v413;
  int v414;
  int64_t v415;
  size_t v416;
  string_t v417;
  string_t v418;
  unint64_t v419;
  const char *v420;
  char *v421;
  string_t v422;
  string_t v423;
  unsigned int v424;
  unsigned int v425;
  int v426;
  const char *v427;
  int v428;
  int v429;
  int v430;
  int v431;
  int v432;
  string_t v433;
  string_t v434;
  unint64_t v435;
  const char *v436;
  char *v437;
  uint64_t v438;
  string_t v439;
  char *v440;
  int v441;
  int64_t v442;
  size_t v443;
  string_t v444;
  string_t v445;
  unint64_t v446;
  const char *v447;
  char *v448;
  string_t v449;
  string_t v450;
  string_t v451;
  unint64_t v452;
  size_t v453;
  const char *v454;
  char *v455;
  string_t v456;
  signed int v459;
  char *v460;
  string_t *v461;
  int v462;
  string_t *v463;
  char v466[4];

  v459 = (int)a4;
  *(_DWORD *)v466 = 0;
  v13 = (char *)__src + 168;
  v12 = *((unsigned __int8 *)__src + 168);
  if (!*((_BYTE *)__src + 168))
    return;
  v460 = (char *)a2 + 12;
  v461 = a2 + 1;
  v463 = a2 + 2;
  v16 = (unsigned __int8 *)__src + 168;
LABEL_6:
  while (v12 == 36)
  {
    v27 = v13 + 1;
    v26 = v13[1];
    v28 = v26 > 99;
    if (v26 > 97)
      ++v28;
    if (v26 > 102)
      ++v28;
    if (v26 > 111)
      ++v28;
    v29 = *((_DWORD *)a2 + v28 - (v26 > 112) - (v26 > 116));
    if (!v29)
    {
      v30 = *((unsigned __int8 *)v13 + 1) - 102;
      if (v30 > 0x10 || ((1 << v30) & 0x10201) == 0)
      {
        v13 += 2;
LABEL_127:
        v33 = v16;
        goto LABEL_147;
      }
    }
    v31 = (unsigned __int8 *)(v13 + 2);
    v32 = *((unsigned __int8 *)v13 + 2);
    if ((v32 - 58) >= 0xFFFFFFF6)
    {
      v48 = 0;
      v33 = (unsigned __int8 *)(v13 + 2);
      do
      {
        v48 = v32 + 10 * v48 - 48;
        v49 = *++v33;
        v32 = v49;
      }
      while ((v49 - 58) > 0xFFFFFFF5);
      *(_DWORD *)v466 = v48;
      if (*v33 != 61)
      {
LABEL_25:
        if (*v27 != 111 || a7 == 0)
        {
          if (!v29)
          {
            v13 = (const char *)v33;
            goto LABEL_127;
          }
          v35 = v31 - v16;
          v37 = this[1];
          v36 = this[2];
          v38 = (unint64_t)&v37[v35];
          if (v36)
          {
            if (v38 >= *(_QWORD *)v36)
            {
              v39 = (v38 + 255) & 0xFFFFFFFFFFFFFF00;
              v40 = (const char *)malloc_type_realloc(*((void **)v36 + 2), v39, 0xCCCD1039uLL);
              v41 = (char *)this[2];
              *((_QWORD *)v41 + 2) = v40;
              *(_QWORD *)v41 = v39;
              *this = v40;
            }
          }
          else
          {
            str_alloc(this, v38);
          }
          v138 = *this;
          this[1] += v35;
          memcpy((void *)&v37[(_QWORD)v138], v16, v35);
          v131 = *(_DWORD *)v466;
          v133 = this[1];
          v132 = this[2];
          v134 = (unint64_t)(v133 + 20);
          if (!v132)
            goto LABEL_145;
LABEL_138:
          if (v134 >= *(_QWORD *)v132)
          {
            v135 = (const char *)malloc_type_realloc(*((void **)v132 + 2), (unint64_t)(v133 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v136 = (char *)this[2];
            *((_QWORD *)v136 + 2) = v135;
            *(_QWORD *)v136 = (unint64_t)(v133 + 275) & 0xFFFFFFFFFFFFFF00;
            *this = v135;
          }
        }
        else
        {
          v58 = v27 - v16;
          v60 = this[1];
          v59 = this[2];
          v61 = (unint64_t)&v60[v58];
          if (v59)
          {
            if (v61 >= *(_QWORD *)v59)
            {
              v62 = (v61 + 255) & 0xFFFFFFFFFFFFFF00;
              v63 = (const char *)malloc_type_realloc(*((void **)v59 + 2), v62, 0xCCCD1039uLL);
              v64 = (char *)this[2];
              *((_QWORD *)v64 + 2) = v63;
              *(_QWORD *)v64 = v62;
              *this = v63;
            }
          }
          else
          {
            str_alloc(this, v61);
          }
          v124 = *this;
          this[1] += v58;
          memcpy((void *)&v60[(_QWORD)v124], v16, v58);
          v126 = (unint64_t)this[1];
          v125 = this[2];
          v127 = v126 + 1;
          if (v125)
          {
            if (v127 >= *(_QWORD *)v125)
            {
              v128 = (const char *)malloc_type_realloc(*((void **)v125 + 2), (v126 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v129 = (char *)this[2];
              *((_QWORD *)v129 + 2) = v128;
              *(_QWORD *)v129 = (v126 & 0xFFFFFFFFFFFFFF00) + 256;
              *this = v128;
            }
          }
          else
          {
            str_alloc(this, v127);
          }
          v130 = *this;
          ++this[1];
          v130[v126] = 116;
          v131 = *(_DWORD *)v466;
          v133 = this[1];
          v132 = this[2];
          v134 = (unint64_t)(v133 + 20);
          if (v132)
            goto LABEL_138;
LABEL_145:
          str_alloc(this, v134);
        }
        this[1] += itoa((char *)&v133[(_QWORD)*this], v131 + v29);
        v13 = (const char *)v33;
        goto LABEL_147;
      }
    }
    else
    {
      v33 = 0;
      if (MEMORY[0] != 61)
        goto LABEL_25;
    }
    v462 = v29;
    v50 = a8;
    v51 = v31 - v16;
    v53 = this[1];
    v52 = this[2];
    v54 = (unint64_t)&v53[v51];
    if (v52)
    {
      if (v54 >= *(_QWORD *)v52)
      {
        v55 = (v54 + 255) & 0xFFFFFFFFFFFFFF00;
        v56 = (const char *)malloc_type_realloc(*((void **)v52 + 2), v55, 0xCCCD1039uLL);
        v57 = (char *)this[2];
        *((_QWORD *)v57 + 2) = v56;
        *(_QWORD *)v57 = v55;
        *this = v56;
      }
    }
    else
    {
      str_alloc(this, v54);
    }
    v70 = *this;
    this[1] += v51;
    memcpy((void *)&v53[(_QWORD)v70], v16, v51);
    v71 = *v27;
    if (v71 == 102)
    {
      v72 = *(_DWORD *)v466;
      a8 = v50;
      if ((_DWORD)v50)
      {
        v73 = v50 >> v466[0];
        v74 = *(_DWORD *)v466;
        v75 = v462;
        if ((v73 & 1) == 0)
          goto LABEL_78;
        goto LABEL_65;
      }
      v75 = v462;
      if (v459 == -1)
      {
        if (a5 == -1)
          goto LABEL_78;
        v74 = *(_DWORD *)v466 - a5;
        if (*(_DWORD *)v466 < a5)
          goto LABEL_78;
LABEL_65:
        if (v74 == -1)
          goto LABEL_78;
      }
      else if (a5 == -1)
      {
        if (*(_DWORD *)v466)
          goto LABEL_78;
      }
      else if (*(_DWORD *)v466 != a5)
      {
        goto LABEL_78;
      }
      this[1] -= 9;
      do
      {
        v76 = *(unsigned __int8 *)v13++;
        v33 = (unsigned __int8 *)v13;
      }
      while (v76 != 10);
      goto LABEL_147;
    }
    if (v71 != 111 || (a7 & 1) == 0)
    {
      v72 = *(_DWORD *)v466;
      a8 = v50;
      v75 = v462;
LABEL_78:
      v86 = this[1];
      v85 = this[2];
      v87 = (unint64_t)(v86 + 20);
      if (v85)
      {
        if (v87 >= *(_QWORD *)v85)
        {
          v88 = (const char *)malloc_type_realloc(*((void **)v85 + 2), (unint64_t)(v86 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v89 = (char *)this[2];
          *((_QWORD *)v89 + 2) = v88;
          *(_QWORD *)v89 = (unint64_t)(v86 + 275) & 0xFFFFFFFFFFFFFF00;
          *this = v88;
        }
      }
      else
      {
        str_alloc(this, v87);
      }
      this[1] += itoa((char *)&v86[(_QWORD)*this], v72 + v75);
      v13 = (const char *)(v33 + 1);
      v12 = v33[1];
      while (2)
      {
        while (2)
        {
          if (v12 == 59)
            goto LABEL_148;
          if ((v12 - 48) < 0xA || (ctype[2 * v12] & 0x40) == 0)
          {
            ++v13;
LABEL_96:
            v12 = *(unsigned __int8 *)v13;
            continue;
          }
          break;
        }
        if (!strncmp(v13, "program.local", 0xDuLL))
        {
          v91 = (arb *)(v13 + 13);
          v95 = *(_DWORD *)v463;
          v96 = v13 + 13 - (const char *)v33;
          v98 = this[1];
          v97 = this[2];
          v99 = (unint64_t)&v98[v96];
          if (v97)
            goto LABEL_103;
        }
        else if (!strncmp(v13, "fragment.texcoord", 0x11uLL))
        {
          v91 = (arb *)(v13 + 17);
          v95 = *(_DWORD *)v461;
          v96 = v13 + 17 - (const char *)v33;
          v98 = this[1];
          v97 = this[2];
          v99 = (unint64_t)&v98[v96];
          if (v97)
            goto LABEL_103;
        }
        else
        {
          if (!strncmp(v13, "result.color", 0xCuLL))
          {
            v91 = (arb *)(v13 + 12);
            v93 = (int *)v460;
            goto LABEL_102;
          }
          v91 = (arb *)(v13 + 15);
          if (!strncmp(v13, "vertex.texcoord", 0xFuLL))
          {
            v95 = *(_DWORD *)v461;
            v96 = v91 - (arb *)v33;
            v98 = this[1];
            v97 = this[2];
            v99 = (unint64_t)&v98[v91 - (arb *)v33];
            if (v97)
              goto LABEL_103;
          }
          else
          {
            v92 = strncmp(v13, "result.texcoord", 0xFuLL);
            v93 = (int *)v460;
            if (v92)
            {
              do
                v94 = *(unsigned __int8 *)++v13;
              while ((ctype[2 * v94] & 0x40) != 0);
              goto LABEL_96;
            }
LABEL_102:
            v95 = *v93;
            v96 = v91 - (arb *)v33;
            v98 = this[1];
            v97 = this[2];
            v99 = (unint64_t)&v98[v91 - (arb *)v33];
            if (v97)
            {
LABEL_103:
              if (v99 >= *(_QWORD *)v97)
              {
                v100 = (v99 + 255) & 0xFFFFFFFFFFFFFF00;
                v101 = (const char *)malloc_type_realloc(*((void **)v97 + 2), v100, 0xCCCD1039uLL);
                v102 = (char *)this[2];
                *((_QWORD *)v102 + 2) = v101;
                *(_QWORD *)v102 = v100;
                *this = v101;
              }
              goto LABEL_107;
            }
          }
        }
        str_alloc(this, v99);
LABEL_107:
        v103 = *this;
        this[1] += v96;
        memcpy((void *)&v98[(_QWORD)v103], v33, v96);
        *(_DWORD *)v466 = 0;
        v105 = arb::aidx(v91, v466, 0, v104);
        if (v105)
          v33 = v105;
        else
          v33 = (unsigned __int8 *)v91;
        *(_DWORD *)v466 += v95;
        if (!*(_DWORD *)v466 && *v13 == 114 && v13[7] == 99)
        {
          v13 = (const char *)v33;
          v12 = *v33;
        }
        else
        {
          v107 = (unint64_t)this[1];
          v106 = this[2];
          v108 = v107 + 1;
          if (v106)
          {
            if (v108 >= *(_QWORD *)v106)
            {
              v109 = (const char *)malloc_type_realloc(*((void **)v106 + 2), (v107 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v110 = (char *)this[2];
              *((_QWORD *)v110 + 2) = v109;
              *(_QWORD *)v110 = (v107 & 0xFFFFFFFFFFFFFF00) + 256;
              *this = v109;
            }
          }
          else
          {
            str_alloc(this, v108);
          }
          v111 = *this;
          ++this[1];
          v111[v107] = 91;
          v112 = *(_DWORD *)v466;
          v114 = this[1];
          v113 = this[2];
          v115 = (unint64_t)(v114 + 20);
          if (v113)
          {
            if (v115 >= *(_QWORD *)v113)
            {
              v116 = (const char *)malloc_type_realloc(*((void **)v113 + 2), (unint64_t)(v114 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v117 = (char *)this[2];
              *((_QWORD *)v117 + 2) = v116;
              *(_QWORD *)v117 = (unint64_t)(v114 + 275) & 0xFFFFFFFFFFFFFF00;
              *this = v116;
            }
          }
          else
          {
            str_alloc(this, v115);
          }
          v118 = itoa((char *)&v114[(_QWORD)*this], v112);
          v119 = this[2];
          v120 = &this[1][v118];
          this[1] = v120;
          v121 = (unint64_t)(v120 + 1);
          if (v119)
          {
            if (v121 >= *(_QWORD *)v119)
            {
              v122 = (const char *)malloc_type_realloc(*((void **)v119 + 2), ((unint64_t)v120 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v123 = (char *)this[2];
              *((_QWORD *)v123 + 2) = v122;
              *(_QWORD *)v123 = ((unint64_t)v120 & 0xFFFFFFFFFFFFFF00) + 256;
              *this = v122;
            }
          }
          else
          {
            str_alloc(this, v121);
          }
          v90 = *this;
          ++this[1];
          v120[(_QWORD)v90] = 93;
          v13 = (const char *)v33;
          v12 = *v33;
        }
        continue;
      }
    }
    this[1] -= 9;
    a8 = v50;
    do
    {
      v77 = *(unsigned __int8 *)v13++;
      v33 = (unsigned __int8 *)v13;
    }
    while (v77 != 10);
LABEL_147:
    v12 = *(unsigned __int8 *)v13;
LABEL_148:
    v16 = v33;
    if (!v12)
      return;
  }
  if (v12 == 35)
  {
    v19 = (unsigned __int8 *)(v13 + 2);
    v18 = *((unsigned __int8 *)v13 + 2);
    if ((v18 - 58) < 0xFFFFFFF6)
    {
      if (v18 != 37)
      {
        if (v18 == 42)
        {
          v21 = this[1];
          v20 = this[2];
          v22 = (unint64_t)&v21[v13 - (const char *)v16];
          if (v20)
          {
            if (v22 >= *(_QWORD *)v20)
            {
              v23 = (v22 + 255) & 0xFFFFFFFFFFFFFF00;
              v24 = (const char *)malloc_type_realloc(*((void **)v20 + 2), v23, 0xCCCD1039uLL);
              v25 = (char *)this[2];
              *((_QWORD *)v25 + 2) = v24;
              *(_QWORD *)v25 = v23;
              *this = v24;
            }
          }
          else
          {
            str_alloc(this, v22);
          }
          v139 = *this;
          this[1] += v13 - (const char *)v16;
          memcpy((void *)&v21[(_QWORD)v139], v16, v13 - (const char *)v16);
          v17 = v13 + 4;
          v13 += 4;
          goto LABEL_5;
        }
        v17 = v13 + 4;
LABEL_4:
        v13 = (const char *)v16;
        goto LABEL_5;
      }
      v17 = v13 + 4;
      v78 = v13 + 4 - (const char *)v16;
      v80 = this[1];
      v79 = this[2];
      v81 = (unint64_t)&v80[v78];
      if (v79)
      {
        if (v81 >= *(_QWORD *)v79)
        {
          v82 = (v81 + 255) & 0xFFFFFFFFFFFFFF00;
          v83 = (const char *)malloc_type_realloc(*((void **)v79 + 2), v82, 0xCCCD1039uLL);
          v84 = (char *)this[2];
          *((_QWORD *)v84 + 2) = v83;
          *(_QWORD *)v84 = v82;
          *this = v83;
        }
      }
      else
      {
        str_alloc(this, v81);
      }
      v140 = *this;
      this[1] += v78;
      memcpy((void *)&v80[(_QWORD)v140], v16, v13 + 4 - (const char *)v16);
      if (!strncmp(v13 + 4, "TEMP r", 6uLL))
      {
        v141 = v13 + 10;
        v142 = *((unsigned __int16 *)a3 + 12);
        v143 = *(_DWORD *)v466;
        while (1)
        {
          v144 = *(unsigned __int8 *)v141;
          if ((v144 - 58) >= 0xFFFFFFF6)
          {
            v143 = 0;
            v145 = v141;
            do
            {
              v143 = v144 + 10 * v143 - 48;
              v146 = *(unsigned __int8 *)++v145;
              v144 = v146;
            }
            while ((v146 - 58) > 0xFFFFFFF5);
            *(_DWORD *)v466 = v143;
            v147 = *(unsigned __int8 *)v145;
            if (*v145)
            {
              if ((v147 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_161:
                  v148 = *(unsigned __int8 *)++v145;
                  v147 = v148;
                }
                while ((v148 - 33) > 0xFFFFFFDF);
              }
LABEL_162:
              if (v147 == 35)
              {
                ++v145;
                while (1)
                {
                  v147 = *(unsigned __int8 *)v145;
                  if (!*v145)
                    break;
                  v149 = *((unsigned __int8 *)v145++ - 1);
                  if (v149 == 10)
                  {
                    --v145;
                    if ((v147 - 33) >= 0xFFFFFFE0)
                      goto LABEL_161;
                    goto LABEL_162;
                  }
                }
              }
            }
          }
          else
          {
            v145 = 0;
          }
          if (v143 >= v142)
            break;
          v150 = *(unsigned __int8 *)v145;
          v17 = v145 + 2;
          v141 = v17;
          if (v150 == 59)
            goto LABEL_170;
        }
        v246 = this[1];
        v245 = this[2];
        v247 = (unint64_t)(v246 + 6);
        if (v245)
        {
          if (v247 >= *(_QWORD *)v245)
          {
            v248 = (const char *)malloc_type_realloc(*((void **)v245 + 2), (unint64_t)(v246 + 261) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v249 = (char *)this[2];
            *((_QWORD *)v249 + 2) = v248;
            *(_QWORD *)v249 = (unint64_t)(v246 + 261) & 0xFFFFFFFFFFFFFF00;
            *this = v248;
          }
        }
        else
        {
          str_alloc(this, v247);
        }
        v346 = 0;
        v347 = *this;
        this[1] += 6;
        v348 = (char *)&v246[(_QWORD)v347];
        *((_WORD *)v348 + 2) = 29216;
        *(_DWORD *)v348 = 1347241300;
        do
          v349 = v145[v346++ - 2];
        while (v349 != 59);
        v350 = v145 - v141;
        v351 = v145 - v141 + v346 - 1;
        v353 = this[1];
        v352 = this[2];
        v354 = (unint64_t)&v353[v351];
        if (v352)
        {
          if (v354 >= *(_QWORD *)v352)
          {
            v355 = (const char *)malloc_type_realloc(*((void **)v352 + 2), (unint64_t)&v353[v350 + 254 + v346] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v356 = (char *)this[2];
            *((_QWORD *)v356 + 2) = v355;
            *(_QWORD *)v356 = (unint64_t)&v353[v350 + 254 + v346] & 0xFFFFFFFFFFFFFF00;
            *this = v355;
          }
        }
        else
        {
          str_alloc(this, v354);
        }
        v17 = &v145[v346 - 1];
        v368 = *this;
        this[1] = &this[1][v350 - 1 + v346];
        memcpy((void *)&v353[(_QWORD)v368], v141, v351);
        if (strncmp(v17, "LONG TEMP l", 0xBuLL))
        {
LABEL_393:
          if (!strncmp(v17, "SHORT TEMP h", 0xCuLL))
            goto LABEL_394;
LABEL_416:
          if (!strncmp(v17, "INT TEMP i", 0xAuLL))
            goto LABEL_417;
LABEL_451:
          if (strncmp(v17, "UINT TEMP u", 0xBuLL))
            goto LABEL_452;
          goto LABEL_455;
        }
      }
      else
      {
LABEL_170:
        if (strncmp(v17, "LONG TEMP l", 0xBuLL))
          goto LABEL_393;
      }
      v151 = v17 + 11;
      v152 = *((unsigned __int8 *)a3 + 27);
      v153 = *(_DWORD *)v466;
      while (1)
      {
        v154 = *(unsigned __int8 *)v151;
        if ((v154 - 58) >= 0xFFFFFFF6)
        {
          v153 = 0;
          v155 = v151;
          do
          {
            v153 = v154 + 10 * v153 - 48;
            v156 = *(unsigned __int8 *)++v155;
            v154 = v156;
          }
          while ((v156 - 58) > 0xFFFFFFF5);
          *(_DWORD *)v466 = v153;
          v157 = *(unsigned __int8 *)v155;
          if (*v155)
          {
            if ((v157 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_178:
                v158 = *(unsigned __int8 *)++v155;
                v157 = v158;
              }
              while ((v158 - 33) > 0xFFFFFFDF);
            }
LABEL_179:
            if (v157 == 35)
            {
              ++v155;
              while (1)
              {
                v157 = *(unsigned __int8 *)v155;
                if (!*v155)
                  break;
                v159 = *((unsigned __int8 *)v155++ - 1);
                if (v159 == 10)
                {
                  --v155;
                  if ((v157 - 33) >= 0xFFFFFFE0)
                    goto LABEL_178;
                  goto LABEL_179;
                }
              }
            }
          }
        }
        else
        {
          v155 = 0;
        }
        if (v153 >= v152)
          break;
        v160 = *(unsigned __int8 *)v155;
        v17 = v155 + 2;
        v151 = v17;
        if (v160 == 59)
          goto LABEL_393;
      }
      v251 = this[1];
      v250 = this[2];
      v252 = (unint64_t)(v251 + 11);
      if (v250)
      {
        if (v252 >= *(_QWORD *)v250)
        {
          v253 = (const char *)malloc_type_realloc(*((void **)v250 + 2), (unint64_t)(v251 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v254 = (char *)this[2];
          *((_QWORD *)v254 + 2) = v253;
          *(_QWORD *)v254 = (unint64_t)(v251 + 266) & 0xFFFFFFFFFFFFFF00;
          *this = v253;
        }
      }
      else
      {
        str_alloc(this, v252);
      }
      v357 = 0;
      v358 = *this;
      this[1] += 11;
      v359 = (char *)&v251[(_QWORD)v358];
      *(_QWORD *)v359 = *(_QWORD *)"LONG TEMP l";
      *(_DWORD *)(v359 + 7) = 1814057037;
      do
        v360 = v155[v357++ - 2];
      while (v360 != 59);
      v361 = v155 - v151;
      v362 = v155 - v151 + v357 - 1;
      v364 = this[1];
      v363 = this[2];
      v365 = (unint64_t)&v364[v362];
      if (v363)
      {
        if (v365 >= *(_QWORD *)v363)
        {
          v366 = (const char *)malloc_type_realloc(*((void **)v363 + 2), (unint64_t)&v364[v361 + 254 + v357] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v367 = (char *)this[2];
          *((_QWORD *)v367 + 2) = v366;
          *(_QWORD *)v367 = (unint64_t)&v364[v361 + 254 + v357] & 0xFFFFFFFFFFFFFF00;
          *this = v366;
        }
      }
      else
      {
        str_alloc(this, v365);
      }
      v17 = &v155[v357 - 1];
      v384 = *this;
      this[1] = &this[1][v361 - 1 + v357];
      memcpy((void *)&v364[(_QWORD)v384], v151, v362);
      if (strncmp(v17, "SHORT TEMP h", 0xCuLL))
        goto LABEL_416;
LABEL_394:
      v369 = v17 + 12;
      v370 = *((unsigned __int8 *)a3 + 26);
      v371 = *(_DWORD *)v466;
      while (1)
      {
        v372 = *(unsigned __int8 *)v369;
        if ((v372 - 58) >= 0xFFFFFFF6)
        {
          v371 = 0;
          v373 = v369;
          do
          {
            v371 = v372 + 10 * v371 - 48;
            v374 = *(unsigned __int8 *)++v373;
            v372 = v374;
          }
          while ((v374 - 58) > 0xFFFFFFF5);
          *(_DWORD *)v466 = v371;
          v375 = *(unsigned __int8 *)v373;
          if (*v373)
          {
            if ((v375 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_401:
                v376 = *(unsigned __int8 *)++v373;
                v375 = v376;
              }
              while ((v376 - 33) > 0xFFFFFFDF);
            }
LABEL_402:
            if (v375 == 35)
            {
              ++v373;
              while (1)
              {
                v375 = *(unsigned __int8 *)v373;
                if (!*v373)
                  break;
                v377 = *((unsigned __int8 *)v373++ - 1);
                if (v377 == 10)
                {
                  --v373;
                  if ((v375 - 33) >= 0xFFFFFFE0)
                    goto LABEL_401;
                  goto LABEL_402;
                }
              }
            }
          }
        }
        else
        {
          v373 = 0;
        }
        if (v371 >= v370)
          break;
        v378 = *(unsigned __int8 *)v373;
        v17 = v373 + 2;
        v369 = v17;
        if (v378 == 59)
          goto LABEL_416;
      }
      v380 = this[1];
      v379 = this[2];
      v381 = (unint64_t)(v380 + 12);
      if (v379)
      {
        if (v381 >= *(_QWORD *)v379)
        {
          v382 = (const char *)malloc_type_realloc(*((void **)v379 + 2), (unint64_t)(v380 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v383 = (char *)this[2];
          *((_QWORD *)v383 + 2) = v382;
          *(_QWORD *)v383 = (unint64_t)(v380 + 267) & 0xFFFFFFFFFFFFFF00;
          *this = v382;
        }
      }
      else
      {
        str_alloc(this, v381);
      }
      v400 = 0;
      v401 = *this;
      this[1] += 12;
      v402 = (char *)&v380[(_QWORD)v401];
      *(_QWORD *)v402 = *(_QWORD *)"SHORT TEMP h";
      *((_DWORD *)v402 + 2) = 1746948173;
      do
        v403 = v373[v400++ - 2];
      while (v403 != 59);
      v404 = v373 - v369;
      v405 = v373 - v369 + v400 - 1;
      v407 = this[1];
      v406 = this[2];
      v408 = (unint64_t)&v407[v405];
      if (v406)
      {
        if (v408 >= *(_QWORD *)v406)
        {
          v409 = (const char *)malloc_type_realloc(*((void **)v406 + 2), (unint64_t)&v407[v404 + 254 + v400] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v410 = (char *)this[2];
          *((_QWORD *)v410 + 2) = v409;
          *(_QWORD *)v410 = (unint64_t)&v407[v404 + 254 + v400] & 0xFFFFFFFFFFFFFF00;
          *this = v409;
        }
      }
      else
      {
        str_alloc(this, v408);
      }
      v17 = &v373[v400 - 1];
      v422 = *this;
      this[1] = &this[1][v404 - 1 + v400];
      memcpy((void *)&v407[(_QWORD)v422], v369, v405);
      if (strncmp(v17, "INT TEMP i", 0xAuLL))
        goto LABEL_451;
LABEL_417:
      v385 = v17 + 10;
      v386 = *((unsigned __int8 *)a3 + 28);
      v387 = *(_DWORD *)v466;
      while (1)
      {
        v388 = *(unsigned __int8 *)v385;
        if ((v388 - 58) >= 0xFFFFFFF6)
        {
          v387 = 0;
          v389 = v385;
          do
          {
            v387 = v388 + 10 * v387 - 48;
            v390 = *(unsigned __int8 *)++v389;
            v388 = v390;
          }
          while ((v390 - 58) > 0xFFFFFFF5);
          *(_DWORD *)v466 = v387;
          v391 = *(unsigned __int8 *)v389;
          if (*v389)
          {
            if ((v391 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_424:
                v392 = *(unsigned __int8 *)++v389;
                v391 = v392;
              }
              while ((v392 - 33) > 0xFFFFFFDF);
            }
LABEL_425:
            if (v391 == 35)
            {
              ++v389;
              while (1)
              {
                v391 = *(unsigned __int8 *)v389;
                if (!*v389)
                  break;
                v393 = *((unsigned __int8 *)v389++ - 1);
                if (v393 == 10)
                {
                  --v389;
                  if ((v391 - 33) >= 0xFFFFFFE0)
                    goto LABEL_424;
                  goto LABEL_425;
                }
              }
            }
          }
        }
        else
        {
          v389 = 0;
        }
        if (v387 >= v386)
          break;
        v394 = *(unsigned __int8 *)v389;
        v17 = v389 + 2;
        v385 = v17;
        if (v394 == 59)
          goto LABEL_451;
      }
      v396 = this[1];
      v395 = this[2];
      v397 = (unint64_t)(v396 + 10);
      if (v395)
      {
        if (v397 >= *(_QWORD *)v395)
        {
          v398 = (const char *)malloc_type_realloc(*((void **)v395 + 2), (unint64_t)(v396 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v399 = (char *)this[2];
          *((_QWORD *)v399 + 2) = v398;
          *(_QWORD *)v399 = (unint64_t)(v396 + 265) & 0xFFFFFFFFFFFFFF00;
          *this = v398;
        }
      }
      else
      {
        str_alloc(this, v397);
      }
      v411 = 0;
      v412 = *this;
      this[1] += 10;
      v413 = (char *)&v396[(_QWORD)v412];
      *(_QWORD *)v413 = *(_QWORD *)"INT TEMP i";
      *((_WORD *)v413 + 4) = 26912;
      do
        v414 = v389[v411++ - 2];
      while (v414 != 59);
      v415 = v389 - v385;
      v416 = v389 - v385 + v411 - 1;
      v418 = this[1];
      v417 = this[2];
      v419 = (unint64_t)&v418[v416];
      if (v417)
      {
        if (v419 >= *(_QWORD *)v417)
        {
          v420 = (const char *)malloc_type_realloc(*((void **)v417 + 2), (unint64_t)&v418[v415 + 254 + v411] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v421 = (char *)this[2];
          *((_QWORD *)v421 + 2) = v420;
          *(_QWORD *)v421 = (unint64_t)&v418[v415 + 254 + v411] & 0xFFFFFFFFFFFFFF00;
          *this = v420;
        }
      }
      else
      {
        str_alloc(this, v419);
      }
      v17 = &v389[v411 - 1];
      v423 = *this;
      this[1] = &this[1][v415 - 1 + v411];
      memcpy((void *)&v418[(_QWORD)v423], v385, v416);
      if (strncmp(v17, "UINT TEMP u", 0xBuLL))
      {
LABEL_452:
        v13 = v17;
        goto LABEL_5;
      }
LABEL_455:
      v13 = v17 + 11;
      v424 = *((unsigned __int8 *)a3 + 29);
      v425 = *(_DWORD *)v466;
      while (1)
      {
        v426 = *(unsigned __int8 *)v13;
        if ((v426 - 58) >= 0xFFFFFFF6)
        {
          v425 = 0;
          v427 = v13;
          do
          {
            v425 = v426 + 10 * v425 - 48;
            v428 = *(unsigned __int8 *)++v427;
            v426 = v428;
          }
          while ((v428 - 58) > 0xFFFFFFF5);
          *(_DWORD *)v466 = v425;
          v429 = *(unsigned __int8 *)v427;
          if (*v427)
          {
            if ((v429 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_462:
                v430 = *(unsigned __int8 *)++v427;
                v429 = v430;
              }
              while ((v430 - 33) > 0xFFFFFFDF);
            }
LABEL_463:
            if (v429 == 35)
            {
              ++v427;
              while (1)
              {
                v429 = *(unsigned __int8 *)v427;
                if (!*v427)
                  break;
                v431 = *((unsigned __int8 *)v427++ - 1);
                if (v431 == 10)
                {
                  --v427;
                  if ((v429 - 33) >= 0xFFFFFFE0)
                    goto LABEL_462;
                  goto LABEL_463;
                }
              }
            }
          }
        }
        else
        {
          v427 = 0;
        }
        if (v425 >= v424)
          break;
        v432 = *(unsigned __int8 *)v427;
        v17 = v427 + 2;
        v13 = v17;
        if (v432 == 59)
          goto LABEL_5;
      }
      v434 = this[1];
      v433 = this[2];
      v435 = (unint64_t)(v434 + 11);
      if (v433)
      {
        if (v435 >= *(_QWORD *)v433)
        {
          v436 = (const char *)malloc_type_realloc(*((void **)v433 + 2), (unint64_t)(v434 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v437 = (char *)this[2];
          *((_QWORD *)v437 + 2) = v436;
          *(_QWORD *)v437 = (unint64_t)(v434 + 266) & 0xFFFFFFFFFFFFFF00;
          *this = v436;
        }
      }
      else
      {
        str_alloc(this, v435);
      }
      v438 = 0;
      v439 = *this;
      this[1] += 11;
      v440 = (char *)&v434[(_QWORD)v439];
      *(_QWORD *)v440 = *(_QWORD *)"UINT TEMP u";
      *(_DWORD *)(v440 + 7) = 1965051981;
      do
        v441 = v427[v438++ - 2];
      while (v441 != 59);
      v442 = v427 - v13;
      v443 = v427 - v13 + v438 - 1;
      v445 = this[1];
      v444 = this[2];
      v446 = (unint64_t)&v445[v443];
      if (v444)
      {
        if (v446 >= *(_QWORD *)v444)
        {
          v447 = (const char *)malloc_type_realloc(*((void **)v444 + 2), (unint64_t)&v445[v442 + 254 + v438] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v448 = (char *)this[2];
          *((_QWORD *)v448 + 2) = v447;
          *(_QWORD *)v448 = (unint64_t)&v445[v442 + 254 + v438] & 0xFFFFFFFFFFFFFF00;
          *this = v447;
        }
      }
      else
      {
        str_alloc(this, v446);
      }
      v17 = &v427[v438 - 1];
      v449 = *this;
      this[1] = &this[1][v442 - 1 + v438];
      memcpy((void *)&v445[(_QWORD)v449], v13, v443);
      goto LABEL_5;
    }
    v43 = this[1];
    v42 = this[2];
    v44 = (unint64_t)&v43[v13 - (const char *)v16];
    if (v42)
    {
      if (v44 >= *(_QWORD *)v42)
      {
        v45 = (v44 + 255) & 0xFFFFFFFFFFFFFF00;
        v46 = (const char *)malloc_type_realloc(*((void **)v42 + 2), v45, 0xCCCD1039uLL);
        v47 = (char *)this[2];
        *((_QWORD *)v47 + 2) = v46;
        *(_QWORD *)v47 = v45;
        *this = v46;
      }
    }
    else
    {
      str_alloc(this, v44);
    }
    v65 = *this;
    this[1] += v13 - (const char *)v16;
    memcpy((void *)&v43[(_QWORD)v65], v16, v13 - (const char *)v16);
    v66 = *v19;
    if ((v66 - 58) >= 0xFFFFFFF6)
    {
      v67 = 0;
      do
      {
        v67 = v66 + 10 * v67 - 48;
        v69 = *++v19;
        v66 = v69;
      }
      while ((v69 - 58) > 0xFFFFFFF5);
      *(_DWORD *)v466 = v67;
      if (!(_DWORD)a8)
        goto LABEL_57;
LABEL_51:
      if (((a8 >> v67) & 1) == 0)
        goto LABEL_189;
    }
    else
    {
      v19 = 0;
      v67 = *(_DWORD *)v466;
      if ((_DWORD)a8)
        goto LABEL_51;
LABEL_57:
      if (v459 != -1)
      {
        if (a5 == -1)
        {
          v68 = v459;
          if (!v67)
          {
LABEL_193:
            v167 = this[1];
            v166 = this[2];
            v168 = (unint64_t)(v167 + 3);
            if (v166)
            {
              if (v168 >= *(_QWORD *)v166)
              {
                v169 = (const char *)malloc_type_realloc(*((void **)v166 + 2), (unint64_t)(v167 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v170 = (char *)this[2];
                *((_QWORD *)v170 + 2) = v169;
                *(_QWORD *)v170 = (unint64_t)(v167 + 258) & 0xFFFFFFFFFFFFFF00;
                *this = v169;
              }
            }
            else
            {
              str_alloc(this, v168);
            }
            v171 = *this;
            this[1] += 3;
            v172 = (char *)&v167[(_QWORD)v171];
            v172[2] = 86;
            *(_WORD *)v172 = 20301;
            v173 = v19 + 4;
            v174 = 256;
            v175 = *v173;
            if (v175 == 44)
            {
LABEL_248:
              v218 = this[1];
              v217 = this[2];
              v219 = (unint64_t)&v218[v174 - 255];
              if (v217)
              {
                if (v219 >= *(_QWORD *)v217)
                {
                  v220 = (const char *)malloc_type_realloc(*((void **)v217 + 2), (unint64_t)&v218[v174] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v221 = (char *)this[2];
                  *((_QWORD *)v221 + 2) = v220;
                  *(_QWORD *)v221 = (unint64_t)&v218[v174] & 0xFFFFFFFFFFFFFF00;
                  *this = v220;
                }
              }
              else
              {
                str_alloc(this, v219);
              }
              v222 = *this;
              this[1] = &this[1][v174 - 255];
              memcpy((void *)&v218[(_QWORD)v222], v173, v174 - 255);
              v224 = this[1];
              v223 = this[2];
              v225 = (unint64_t)(v224 + 2);
              if (v223)
              {
                if (v225 >= *(_QWORD *)v223)
                {
                  v226 = (const char *)malloc_type_realloc(*((void **)v223 + 2), (unint64_t)(v224 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v227 = (char *)this[2];
                  *((_QWORD *)v227 + 2) = v226;
                  *(_QWORD *)v227 = (unint64_t)(v224 + 257) & 0xFFFFFFFFFFFFFF00;
                  *this = v226;
                }
              }
              else
              {
                str_alloc(this, v225);
              }
              v228 = *this;
              this[1] += 2;
              *(_WORD *)&v224[(_QWORD)v228] = 29732;
              v230 = this[1];
              v229 = this[2];
              v231 = (unint64_t)(v230 + 20);
              if (v229)
              {
                if (v231 >= *(_QWORD *)v229)
                {
                  v232 = (const char *)malloc_type_realloc(*((void **)v229 + 2), (unint64_t)(v230 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v233 = (char *)this[2];
                  *((_QWORD *)v233 + 2) = v232;
                  *(_QWORD *)v233 = (unint64_t)(v230 + 275) & 0xFFFFFFFFFFFFFF00;
                  *this = v232;
                }
              }
              else
              {
                str_alloc(this, v231);
              }
              this[1] += itoa((char *)&v230[(_QWORD)*this], v68);
              v17 = (const char *)(v173 - 1);
              do
              {
                v234 = *(unsigned __int8 *)++v17;
                v13 = v17;
              }
              while (v234 != 59);
              goto LABEL_5;
            }
            while (2)
            {
              while (v175 != 36)
              {
                v175 = v173[++v174 - 256];
                if (v175 == 44)
                  goto LABEL_248;
              }
              v176 = v174 - 254;
              v178 = this[1];
              v177 = this[2];
              if (v177)
              {
                if ((unint64_t)&v178[v176] < *(_QWORD *)v177)
                {
                  v179 = *this;
                  goto LABEL_212;
                }
                v179 = (const char *)malloc_type_realloc(*((void **)v177 + 2), (unint64_t)&v178[v174 + 1] & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v185 = (char *)this[2];
                *((_QWORD *)v185 + 2) = v179;
                *(_QWORD *)v185 = (unint64_t)&v178[v174 + 1] & 0xFFFFFFFFFFFFFF00;
              }
              else
              {
                v180 = (unint64_t)&v178[v174 + 1] & 0xFFFFFFFFFFFFFF00;
                v181 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
                v182 = malloc_type_malloc(v180, 0x2BEB8FE7uLL);
                *((_QWORD *)v181 + 2) = v182;
                bzero(v182, v180);
                *((_QWORD *)v181 + 1) = 1;
                v183 = this[1];
                if (v183)
                  memcpy(*((void **)v181 + 2), *this, (size_t)v183);
                v184 = this[2];
                if (v184)
                  --*((_QWORD *)v184 + 1);
                *(_QWORD *)v181 = v180;
                this[2] = (string_t)v181;
                v179 = (const char *)*((_QWORD *)v181 + 2);
              }
              *this = v179;
LABEL_212:
              v186 = &v173[v176];
              this[1] = &this[1][v174 - 254];
              memcpy((void *)&v178[(_QWORD)v179], v173, v174 - 254);
              v187 = v173[v176];
              if ((v187 - 58) >= 0xFFFFFFF6)
              {
                v188 = 0;
                v173 += v176;
                do
                {
                  v188 = v187 + 10 * v188 - 48;
                  v189 = *++v173;
                  v187 = v189;
                }
                while ((v189 - 58) > 0xFFFFFFF5);
                *(_DWORD *)v466 = v188;
                LOBYTE(v187) = *v186;
              }
              else
              {
                v173 = 0;
                v188 = *(_DWORD *)v466;
              }
              v190 = (char)v187 > 99;
              if ((char)v187 > 97)
                ++v190;
              if ((char)v187 > 102)
                ++v190;
              if ((char)v187 > 111)
                ++v190;
              v191 = *((_DWORD *)a2 + v190 - ((char)v187 > 112) - ((char)v187 > 116));
              v193 = this[1];
              v192 = this[2];
              if (v192)
              {
                if ((unint64_t)(v193 + 20) < *(_QWORD *)v192)
                {
                  v194 = v188 + v191;
                  v195 = (char *)&v193[(_QWORD)*this];
                  if (v188 + v191 < 0)
                    break;
LABEL_234:
                  v196 = 0;
LABEL_235:
                  v204 = (uint32x4_t)vdupq_n_s32(v194);
                  v205 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v204, (uint32x4_t)xmmword_1B309DA50), (int16x8_t)vcgtq_u32(v204, (uint32x4_t)xmmword_1B309DA40)), (int8x16_t)xmmword_1B309DA60);
                  v205.i32[0] = vaddvq_s16(v205);
                  v206 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v205.i8);
                  v206.i16[0] = vaddlv_u8(v206);
                  v207 = v206.i32[0];
                  if (v194 > 9)
                    v207 = v206.i32[0] + 1;
                  switch(v207)
                  {
                    case 1:
                      goto LABEL_246;
                    case 2:
                      goto LABEL_245;
                    case 3:
                      goto LABEL_244;
                    case 4:
                      goto LABEL_243;
                    case 5:
                      goto LABEL_242;
                    case 6:
                      goto LABEL_241;
                    case 7:
                      goto LABEL_240;
                    case 8:
                      goto LABEL_239;
                    case 9:
                      v208 = v194 / 0x3B9ACA00u;
                      v194 %= 0x3B9ACA00u;
                      v195[v196++] = v208 | 0x30;
LABEL_239:
                      v209 = v194 / 100000000;
                      v194 %= 100000000;
                      v195[v196++] = v209 + 48;
LABEL_240:
                      v210 = v194 / 10000000;
                      v194 %= 10000000;
                      v195[v196++] = v210 + 48;
LABEL_241:
                      v211 = v194 / 1000000;
                      v194 %= 1000000;
                      v195[v196++] = v211 + 48;
LABEL_242:
                      v212 = v194 / 100000;
                      v194 %= 100000;
                      v195[v196++] = v212 + 48;
LABEL_243:
                      v213 = v194 / 10000;
                      v194 %= 10000;
                      v195[v196++] = v213 + 48;
LABEL_244:
                      v214 = v194 / 1000;
                      v194 %= 1000;
                      v195[v196++] = v214 + 48;
LABEL_245:
                      v215 = v194 / 100;
                      v194 %= 100;
                      v195[v196++] = v215 + 48;
LABEL_246:
                      v216 = v194 / 10;
                      v194 %= 10;
                      v195[v196++] = v216 + 48;
                      break;
                    default:
                      break;
                  }
                  v195[v196] = v194 + 48;
                  this[1] += v196 + 1;
                  v174 = 256;
                  v175 = *v173;
                  if (v175 == 44)
                    goto LABEL_248;
                  continue;
                }
                v202 = (const char *)malloc_type_realloc(*((void **)v192 + 2), (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v203 = (char *)this[2];
                *((_QWORD *)v203 + 2) = v202;
                *(_QWORD *)v203 = (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00;
                *this = v202;
                v194 = v188 + v191;
                v195 = (char *)&v193[(_QWORD)v202];
                if (((v188 + v191) & 0x80000000) == 0)
                  goto LABEL_234;
              }
              else
              {
                v197 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
                v198 = malloc_type_malloc((unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00, 0x2BEB8FE7uLL);
                *((_QWORD *)v197 + 2) = v198;
                bzero(v198, (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00);
                *((_QWORD *)v197 + 1) = 1;
                v199 = this[1];
                if (v199)
                  memcpy(*((void **)v197 + 2), *this, (size_t)v199);
                v200 = this[2];
                if (v200)
                  --*((_QWORD *)v200 + 1);
                *(_QWORD *)v197 = (unint64_t)(v193 + 275) & 0xFFFFFFFFFFFFFF00;
                this[2] = (string_t)v197;
                v201 = (const char *)*((_QWORD *)v197 + 2);
                *this = v201;
                v194 = v188 + v191;
                v195 = (char *)&v193[(_QWORD)v201];
                if (((v188 + v191) & 0x80000000) == 0)
                  goto LABEL_234;
              }
              break;
            }
            *v195 = 45;
            v194 = -v194;
            v196 = 1;
            goto LABEL_235;
          }
        }
        else
        {
          v68 = v459;
          if (v67 == a5)
            goto LABEL_193;
        }
        goto LABEL_189;
      }
      if (a5 == -1 || (v137 = v67 >= a5, v67 -= a5, !v137))
      {
LABEL_189:
        if (!*((_DWORD *)a2 + 6))
        {
          v17 = (const char *)(v19 + 2);
          goto LABEL_5;
        }
        v162 = this[1];
        v161 = this[2];
        v163 = (unint64_t)(v162 + 2);
        if (v161)
        {
          if (v163 >= *(_QWORD *)v161)
          {
            v164 = (const char *)malloc_type_realloc(*((void **)v161 + 2), (unint64_t)(v162 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v165 = (char *)this[2];
            *((_QWORD *)v165 + 2) = v164;
            *(_QWORD *)v165 = (unint64_t)(v162 + 257) & 0xFFFFFFFFFFFFFF00;
            *this = v164;
          }
        }
        else
        {
          str_alloc(this, v163);
        }
        v235 = *this;
        this[1] += 2;
        *(_WORD *)&v162[(_QWORD)v235] = 8995;
        v236 = *((_DWORD *)a2 + 6);
        v237 = *(_DWORD *)v466;
        v239 = this[1];
        v238 = this[2];
        v240 = (unint64_t)(v239 + 20);
        if (v238)
        {
          if (v240 >= *(_QWORD *)v238)
          {
            v241 = (const char *)malloc_type_realloc(*((void **)v238 + 2), (unint64_t)(v239 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v242 = (char *)this[2];
            *((_QWORD *)v242 + 2) = v241;
            *(_QWORD *)v242 = (unint64_t)(v239 + 275) & 0xFFFFFFFFFFFFFF00;
            *this = v241;
          }
        }
        else
        {
          str_alloc(this, v240);
        }
        v243 = (string_t)itoa((char *)&v239[(_QWORD)*this], v237 + v236);
        v244 = this[1];
LABEL_291:
        v266 = 0;
        v267 = &v243[(_QWORD)v244];
        this[1] = &v243[(_QWORD)v244];
        while (1)
        {
          v268 = v19[v266];
          if (v268 == 101)
          {
            if (v19[v266 + 1] == 91 && v19[v266 - 7] != 46)
            {
              v331 = (unint64_t)&v243[(_QWORD)v244 + 2 + v266];
              v332 = this[2];
              if (v332)
              {
                if (v331 >= *(_QWORD *)v332)
                {
                  v333 = (unint64_t)&v243[(_QWORD)v244 + 257 + v266] & 0xFFFFFFFFFFFFFF00;
                  v334 = (const char *)malloc_type_realloc(*((void **)v332 + 2), v333, 0xCCCD1039uLL);
                  v335 = (char *)this[2];
                  *((_QWORD *)v335 + 2) = v334;
                  *(_QWORD *)v335 = v333;
                  *this = v334;
                }
              }
              else
              {
                str_alloc(this, v331);
              }
              v17 = (const char *)&v19[v266 + 2];
              v336 = *this;
              this[1] += v266 + 2;
              memcpy((void *)&v267[(_QWORD)v336], v19, v266 + 2);
              v337 = *(unsigned __int8 *)v17;
              if ((v337 - 58) >= 0xFFFFFFF6)
              {
                v338 = 0;
                do
                {
                  v338 = v337 + 10 * v338 - 48;
                  v345 = *(unsigned __int8 *)++v17;
                  v337 = v345;
                }
                while ((v345 - 58) > 0xFFFFFFF5);
                *(_DWORD *)v466 = v338;
                v339 = *((_DWORD *)a2 + 6);
                v341 = this[1];
                v340 = this[2];
                v342 = (unint64_t)(v341 + 20);
                if (v340)
                  goto LABEL_372;
LABEL_377:
                str_alloc(this, v342);
                goto LABEL_378;
              }
              v17 = 0;
              v338 = *(_DWORD *)v466;
              v339 = *((_DWORD *)a2 + 6);
              v341 = this[1];
              v340 = this[2];
              v342 = (unint64_t)(v341 + 20);
              if (!v340)
                goto LABEL_377;
LABEL_372:
              if (v342 >= *(_QWORD *)v340)
              {
                v343 = (const char *)malloc_type_realloc(*((void **)v340 + 2), (unint64_t)(v341 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v344 = (char *)this[2];
                *((_QWORD *)v344 + 2) = v343;
                *(_QWORD *)v344 = (unint64_t)(v341 + 275) & 0xFFFFFFFFFFFFFF00;
                *this = v343;
              }
LABEL_378:
              this[1] += itoa((char *)&v341[(_QWORD)*this], v338 + v339);
              v13 = v17;
LABEL_5:
              v16 = (unsigned __int8 *)v13;
              v12 = *(unsigned __int8 *)v17;
              v13 = v17;
              goto LABEL_6;
            }
          }
          else if (v268 == 36)
          {
            if (v19[v266 + 1] == 111 && a7 != 0)
            {
              v275 = (unint64_t)&v243[(_QWORD)v244 + v266];
              v276 = this[2];
              if (v276)
              {
                if (v275 >= *(_QWORD *)v276)
                {
                  v277 = (unint64_t)&v243[(_QWORD)v244 + 255 + v266] & 0xFFFFFFFFFFFFFF00;
                  v278 = (const char *)malloc_type_realloc(*((void **)v276 + 2), v277, 0xCCCD1039uLL);
                  v279 = (char *)this[2];
                  *((_QWORD *)v279 + 2) = v278;
                  *(_QWORD *)v279 = v277;
                  *this = v278;
                }
              }
              else
              {
                str_alloc(this, v275);
              }
              v296 = *this;
              this[1] += v266;
              memcpy((void *)&v267[(_QWORD)v296], v19, v266);
              v280 = &v19[v266 + 2];
              v297 = *v280;
              if ((v297 - 58) >= 0xFFFFFFF6)
              {
                v303 = 0;
                do
                {
                  v303 = v297 + 10 * v303 - 48;
                  v304 = *++v280;
                  v297 = v304;
                }
                while ((v304 - 58) > 0xFFFFFFF5);
                *(_DWORD *)v466 = v303;
                v299 = this[1];
                v298 = this[2];
                v300 = (unint64_t)(v299 + 2);
                if (v298)
                  goto LABEL_329;
              }
              else
              {
                v280 = 0;
                v299 = this[1];
                v298 = this[2];
                v300 = (unint64_t)(v299 + 2);
                if (v298)
                {
LABEL_329:
                  if (v300 >= *(_QWORD *)v298)
                  {
                    v301 = (const char *)malloc_type_realloc(*((void **)v298 + 2), (unint64_t)(v299 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v302 = (char *)this[2];
                    *((_QWORD *)v302 + 2) = v301;
                    *(_QWORD *)v302 = (unint64_t)(v299 + 257) & 0xFFFFFFFFFFFFFF00;
                    *this = v301;
                  }
LABEL_335:
                  v305 = *this;
                  this[1] += 2;
                  *(_WORD *)&v299[(_QWORD)v305] = 29732;
                  v306 = (char)(v466[0] + 111);
                  v307 = v306 > 99;
                  if (v306 > 97)
                    ++v307;
                  if (v306 > 102)
                    ++v307;
                  if (v306 > 111)
                    ++v307;
                  v256 = *((_DWORD *)a2 + v307 - (v306 > 112) - (v306 > 116));
                  v309 = this[1];
                  v308 = this[2];
                  v310 = (unint64_t)(v309 + 20);
                  if (v308)
                  {
                    if (v310 >= *(_QWORD *)v308)
                    {
                      v311 = (const char *)malloc_type_realloc(*((void **)v308 + 2), (unint64_t)(v309 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      v312 = (char *)this[2];
                      *((_QWORD *)v312 + 2) = v311;
                      *(_QWORD *)v312 = (unint64_t)(v309 + 275) & 0xFFFFFFFFFFFFFF00;
                      *this = v311;
                    }
                    v313 = (char *)&v309[(_QWORD)*this];
                    if ((v256 & 0x80000000) == 0)
                    {
LABEL_345:
                      v257 = 0;
                      goto LABEL_363;
                    }
                  }
                  else
                  {
                    str_alloc(this, v310);
                    v313 = (char *)&v309[(_QWORD)*this];
                    if ((v256 & 0x80000000) == 0)
                      goto LABEL_345;
                  }
                  *v313 = 45;
                  v256 = -v256;
                  v257 = 1;
LABEL_363:
                  v327 = (uint32x4_t)vdupq_n_s32(v256);
                  v328 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v327, (uint32x4_t)xmmword_1B309DA50), (int16x8_t)vcgtq_u32(v327, (uint32x4_t)xmmword_1B309DA40)), (int8x16_t)xmmword_1B309DA60);
                  v328.i32[0] = vaddvq_s16(v328);
                  v329 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v328.i8);
                  v329.i16[0] = vaddlv_u8(v329);
                  v330 = v329.i32[0];
                  if (v256 > 9)
                    v330 = v329.i32[0] + 1;
                  switch(v330)
                  {
                    case 1:
                      goto LABEL_288;
                    case 2:
                      goto LABEL_287;
                    case 3:
                      goto LABEL_286;
                    case 4:
                      goto LABEL_285;
                    case 5:
                      goto LABEL_284;
                    case 6:
                      goto LABEL_283;
                    case 7:
                      goto LABEL_282;
                    case 8:
                      goto LABEL_281;
                    case 9:
                      v255 = v256 / 0x3B9ACA00u;
                      v256 %= 0x3B9ACA00u;
                      v313[v257++] = v255 | 0x30;
LABEL_281:
                      v258 = v256 / 100000000;
                      v256 %= 100000000;
                      v313[v257++] = v258 + 48;
LABEL_282:
                      v259 = v256 / 10000000;
                      v256 %= 10000000;
                      v313[v257++] = v259 + 48;
LABEL_283:
                      v260 = v256 / 1000000;
                      v256 %= 1000000;
                      v313[v257++] = v260 + 48;
LABEL_284:
                      v261 = v256 / 100000;
                      v256 %= 100000;
                      v313[v257++] = v261 + 48;
LABEL_285:
                      v262 = v256 / 10000;
                      v256 %= 10000;
                      v313[v257++] = v262 + 48;
LABEL_286:
                      v263 = v256 / 1000;
                      v256 %= 1000;
                      v313[v257++] = v263 + 48;
LABEL_287:
                      v264 = v256 / 100;
                      v256 %= 100;
                      v313[v257++] = v264 + 48;
LABEL_288:
                      v265 = v256 / 10;
                      v256 %= 10;
                      v313[v257++] = v265 + 48;
                      break;
                    default:
                      break;
                  }
                  v244 = (string_t)(v257 + 1);
                  v313[v257] = v256 + 48;
LABEL_290:
                  v243 = this[1];
                  v19 = v280;
                  goto LABEL_291;
                }
              }
              str_alloc(this, v300);
              goto LABEL_335;
            }
            v270 = (unint64_t)&v243[(_QWORD)v244 + 2 + v266];
            v271 = this[2];
            if (v271)
            {
              if (v270 >= *(_QWORD *)v271)
              {
                v272 = (unint64_t)&v243[(_QWORD)v244 + 257 + v266] & 0xFFFFFFFFFFFFFF00;
                v273 = (const char *)malloc_type_realloc(*((void **)v271 + 2), v272, 0xCCCD1039uLL);
                v274 = (char *)this[2];
                *((_QWORD *)v274 + 2) = v273;
                *(_QWORD *)v274 = v272;
                *this = v273;
              }
            }
            else
            {
              str_alloc(this, v270);
            }
            v280 = &v19[v266 + 2];
            v281 = *this;
            this[1] += v266 + 2;
            memcpy((void *)&v267[(_QWORD)v281], v19, v266 + 2);
            v282 = *v280;
            if ((v282 - 58) >= 0xFFFFFFF6)
            {
              v283 = 0;
              do
              {
                v283 = v282 + 10 * v283 - 48;
                v284 = *++v280;
                v282 = v284;
              }
              while ((v284 - 58) > 0xFFFFFFF5);
              *(_DWORD *)v466 = v283;
            }
            else
            {
              v280 = 0;
              v283 = *(_DWORD *)v466;
            }
            v285 = (char)v19[v266 + 1];
            v286 = v285 > 99;
            if (v285 > 97)
              ++v286;
            if (v285 > 102)
              ++v286;
            if (v285 > 111)
              ++v286;
            v287 = *((_DWORD *)a2 + v286 - (v285 > 112) - (v285 > 116));
            v289 = this[1];
            v288 = this[2];
            v290 = (unint64_t)(v289 + 20);
            if (v288)
            {
              if (v290 >= *(_QWORD *)v288)
              {
                v291 = (const char *)malloc_type_realloc(*((void **)v288 + 2), (unint64_t)(v289 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v292 = (char *)this[2];
                *((_QWORD *)v292 + 2) = v291;
                *(_QWORD *)v292 = (unint64_t)(v289 + 275) & 0xFFFFFFFFFFFFFF00;
                *this = v291;
              }
              v293 = v283 + v287;
              v294 = (char *)&v289[(_QWORD)*this];
              if (((v283 + v287) & 0x80000000) == 0)
              {
LABEL_325:
                v295 = 0;
LABEL_348:
                v314 = (uint32x4_t)vdupq_n_s32(v293);
                v315 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v314, (uint32x4_t)xmmword_1B309DA50), (int16x8_t)vcgtq_u32(v314, (uint32x4_t)xmmword_1B309DA40)), (int8x16_t)xmmword_1B309DA60);
                v315.i32[0] = vaddvq_s16(v315);
                v316 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v315.i8);
                v316.i16[0] = vaddlv_u8(v316);
                v317 = v316.i32[0];
                if (v293 > 9)
                  v317 = v316.i32[0] + 1;
                switch(v317)
                {
                  case 1:
                    goto LABEL_359;
                  case 2:
                    goto LABEL_358;
                  case 3:
                    goto LABEL_357;
                  case 4:
                    goto LABEL_356;
                  case 5:
                    goto LABEL_355;
                  case 6:
                    goto LABEL_354;
                  case 7:
                    goto LABEL_353;
                  case 8:
                    goto LABEL_352;
                  case 9:
                    v318 = v293 / 0x3B9ACA00u;
                    v293 %= 0x3B9ACA00u;
                    v294[v295++] = v318 | 0x30;
LABEL_352:
                    v319 = v293 / 100000000;
                    v293 %= 100000000;
                    v294[v295++] = v319 + 48;
LABEL_353:
                    v320 = v293 / 10000000;
                    v293 %= 10000000;
                    v294[v295++] = v320 + 48;
LABEL_354:
                    v321 = v293 / 1000000;
                    v293 %= 1000000;
                    v294[v295++] = v321 + 48;
LABEL_355:
                    v322 = v293 / 100000;
                    v293 %= 100000;
                    v294[v295++] = v322 + 48;
LABEL_356:
                    v323 = v293 / 10000;
                    v293 %= 10000;
                    v294[v295++] = v323 + 48;
LABEL_357:
                    v324 = v293 / 1000;
                    v293 %= 1000;
                    v294[v295++] = v324 + 48;
LABEL_358:
                    v325 = v293 / 100;
                    v293 %= 100;
                    v294[v295++] = v325 + 48;
LABEL_359:
                    v326 = v293 / 10;
                    v293 %= 10;
                    v294[v295++] = v326 + 48;
                    break;
                  default:
                    break;
                }
                v244 = (string_t)(v295 + 1);
                v294[v295] = v293 + 48;
                goto LABEL_290;
              }
            }
            else
            {
              str_alloc(this, v290);
              v293 = v283 + v287;
              v294 = (char *)&v289[(_QWORD)*this];
              if (((v283 + v287) & 0x80000000) == 0)
                goto LABEL_325;
            }
            *v294 = 45;
            v293 = -v293;
            v295 = 1;
            goto LABEL_348;
          }
          ++v266;
        }
      }
    }
    v68 = v67;
    if (v67 != -1)
      goto LABEL_193;
    goto LABEL_189;
  }
  if (strncmp(v13 - 1, "\nEND\n", 5uLL))
  {
    v17 = v13 + 1;
    goto LABEL_4;
  }
  v451 = this[1];
  v450 = this[2];
  v452 = (unint64_t)&v451[v13 - (const char *)v16];
  if (v450)
  {
    if (v452 >= *(_QWORD *)v450)
    {
      v453 = (v452 + 255) & 0xFFFFFFFFFFFFFF00;
      v454 = (const char *)malloc_type_realloc(*((void **)v450 + 2), v453, 0xCCCD1039uLL);
      v455 = (char *)this[2];
      *((_QWORD *)v455 + 2) = v454;
      *(_QWORD *)v455 = v453;
      *this = v454;
    }
  }
  else
  {
    str_alloc(this, v452);
  }
  v456 = *this;
  this[1] += v13 - (const char *)v16;
  memcpy((void *)&v451[(_QWORD)v456], v16, v13 - (const char *)v16);
}

uint64_t HGString::Digest::push(HGString::Digest *this, const HGString::Digest *a2, const HGLimits *a3)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  unsigned __int16 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  uint64_t v11;

  v3 = *(_OWORD *)a2;
  v4 = *((_OWORD *)a2 + 1);
  v5 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v5;
  *(_OWORD *)this = v3;
  *((_OWORD *)this + 1) = v4;
  v6 = *((_WORD *)this + 26) + 1;
  *((_WORD *)this + 26) = v6;
  v7 = *((_BYTE *)this + 56) + 1;
  *((_BYTE *)this + 56) = v7;
  v8 = *((_BYTE *)this + 59) + 1;
  *((_BYTE *)this + 59) = v8;
  v9 = *((_BYTE *)this + 58) + 1;
  *((_BYTE *)this + 58) = v9;
  if (v6 <= 0xFFu)
  {
    v6 |= (unsigned __int16)(v6 << 12) | ((v7 & 0xF) << 8);
    *((_WORD *)this + 26) = v6;
  }
  if (a3)
  {
    if (*((unsigned __int16 *)a3 + 18) < v6)
      return 0xFFFFFFFFLL;
    v11 = 0xFFFFFFFFLL;
    if (*((unsigned __int8 *)a3 + 40) < v7 || v8 > 8u)
      return v11;
    if (*((unsigned __int16 *)this + 20)
       + v8
       + *((unsigned __int8 *)this + 43)
       + *((unsigned __int8 *)this + 42)
       + *((unsigned __int8 *)this + 44)
       + *((unsigned __int16 *)this + 25) > *((unsigned __int8 *)a3 + 27)
                                                        + *((unsigned __int16 *)a3 + 12)
                                                        + *((unsigned __int8 *)a3 + 26)
                                                        + *((unsigned __int8 *)a3 + 28)
                                                        + *((unsigned __int16 *)a3 + 17)
                                                        + *((unsigned __int8 *)a3 + 43))
      return 0xFFFFFFFFLL;
    if (*((unsigned __int8 *)a3 + 42) < v9)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned __int8 *)a2 + 56);
}

uint64_t HGString::push(HGString *this, const HGLimits *a2)
{
  __int16 v4;
  unsigned __int8 v5;
  uint64_t v6;
  const HGLimits *v7;
  double v8;
  double v9;
  uint32x4_t v10;
  int v11;
  uint64_t v12;
  double v13;
  double v14;
  uint32x4_t v15;
  string_t *v16;
  char v17;
  int v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  __int16 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _OWORD v29[2];
  __int128 v30;

  HGString::digest(this, (uint64_t)&v28);
  v24 = v28;
  v25 = v29[0];
  v26 = v29[1];
  v27 = v30;
  v4 = WORD2(v30) + 1;
  WORD2(v27) = WORD2(v30) + 1;
  v5 = BYTE8(v30) + 1;
  BYTE8(v27) = BYTE8(v30) + 1;
  BYTE11(v27) = BYTE11(v30) + 1;
  BYTE10(v27) = BYTE10(v30) + 1;
  if ((unsigned __int16)(WORD2(v30) + 1) <= 0xFFu)
  {
    v4 |= (v4 << 12) | ((v5 & 0xF) << 8);
    WORD2(v27) = v4;
  }
  if (!a2)
    goto LABEL_10;
  if (*((unsigned __int16 *)a2 + 18) < v4)
    return 0xFFFFFFFFLL;
  v6 = 0xFFFFFFFFLL;
  if (*((unsigned __int8 *)a2 + 40) >= v5
    && (BYTE11(v30) + 1) <= 8u
    && WORD4(v26)
     + (BYTE11(v30) + 1)
     + BYTE11(v26)
     + BYTE10(v26)
     + BYTE12(v26)
     + WORD1(v27) <= *((unsigned __int8 *)a2 + 27)
                                 + *((unsigned __int16 *)a2 + 12)
                                 + *((unsigned __int8 *)a2 + 26)
                                 + *((unsigned __int8 *)a2 + 28)
                                 + *((unsigned __int16 *)a2 + 17)
                                 + *((unsigned __int8 *)a2 + 43)
    && *((unsigned __int8 *)a2 + 42) >= (BYTE10(v30) + 1))
  {
LABEL_10:
    v6 = BYTE8(v30);
    LOBYTE(v23) = 1;
    HIBYTE(v23) = BYTE8(v30) + 1;
    HGString::appendHistory(this, &v23);
    if ((v29[0] & 0xFFFFF) - 394305 >= 0xFFFFFECF)
    {
      arb::begin((string_t *)this, (string_t *)v29, (const HGLimits *)&v25, v7);
      arb::end((string_t *)this, (uint64_t)&v25, (unsigned int *)&v24, v13, v14, v15);
      return v6;
    }
    if ((v29[0] & 0xFFFFF) - 394785 >= 0xFFFFFFEF)
    {
      v8 = glsl::begin((string_t *)this, (string_t *)v29, (const HGLimits *)&v25, v7);
    }
    else
    {
      if ((v29[0] & 0xFFFFF) != 0x60B10)
      {
        if (LODWORD(v29[0]))
          return v6;
        DWORD2(v25) |= (unsigned __int16)(v4 & 0xFF00) >> 8;
        *((_QWORD *)this + 1) = 0;
        v16 = (string_t *)this;
        v17 = 1;
        goto LABEL_19;
      }
      v11 = v25;
      v12 = *((_QWORD *)this + 1);
      if (v12)
      {
        str_alloc((string_t *)this, v12);
        if (LODWORD(v29[0]) != v11)
          goto LABEL_24;
      }
      else
      {
        str_alloc((string_t *)this, 33);
        *((_QWORD *)this + 1) = 33;
        if (LODWORD(v29[0]) != v11)
        {
LABEL_24:
          v19 = v11 >> 4;
          v20 = *(_QWORD *)this;
          *(_DWORD *)(v20 + 3) = 1818326117;
          *(_DWORD *)v20 = 1699557167;
          if (v19 | v11 & 0xF)
          {
            *(_BYTE *)(v20 + 7) = v19 | 0x30;
            *(_BYTE *)(v20 + 8) = 46;
            v21 = (void *)(v20 + 10);
            *(_BYTE *)(v20 + 9) = v11 & 0xF | 0x30;
          }
          else
          {
            v21 = (void *)(v20 + 7);
          }
          v22 = *(_QWORD *)this;
          memset(v21, 32, *(_QWORD *)this + 15 - (_QWORD)v21);
          qmemcpy((void *)(v22 + 15), "\n//LEN=0000000000\n", 18);
          v8 = *(double *)"//LEN=0000000000\n";
        }
      }
    }
    v16 = (string_t *)this;
    v17 = 0;
LABEL_19:
    glsl::end(v16, (uint64_t)&v25, (unsigned int *)&v24, v17, v8, v9, v10);
  }
  return v6;
}

void HGString::appendHistory(_QWORD *a1, _WORD *a2)
{
  unint64_t v4;
  char *v5;
  char *v6;
  _WORD *v7;
  void **v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  _WORD *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _OWORD *v20;
  __int128 *v21;
  unint64_t v22;
  __int128 v23;
  __int16 v24;

  v5 = (char *)a1[4];
  v4 = a1[5];
  v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    v8 = (void **)(a1 + 3);
    v9 = (char *)a1[3];
    v10 = v5 - v9;
    if (v5 - v9 <= -3)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v10 >> 1;
    v12 = v4 - (_QWORD)v9;
    if (v12 <= (v10 >> 1) + 1)
      v13 = v11 + 1;
    else
      v13 = v12;
    if (v12 >= 0x7FFFFFFFFFFFFFFELL)
      v14 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
    {
      if (v14 < 0)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v15 = operator new(2 * v14);
    }
    else
    {
      v15 = 0;
    }
    v16 = &v15[2 * v11];
    *v16 = *a2;
    v7 = v16 + 1;
    if (v5 != v9)
    {
      v17 = v5 - v9 - 2;
      if (v17 < 0x1E)
        goto LABEL_29;
      if (v5 - v15 - (v10 & 0xFFFFFFFFFFFFFFFELL) < 0x20)
        goto LABEL_29;
      v18 = (v17 >> 1) + 1;
      v19 = 2 * (v18 & 0xFFFFFFFFFFFFFFF0);
      v6 = &v5[-v19];
      v16 = (_WORD *)((char *)v16 - v19);
      v20 = &v15[2 * v11 - 16];
      v21 = (__int128 *)(v5 - 16);
      v22 = v18 & 0xFFFFFFFFFFFFFFF0;
      do
      {
        v23 = *v21;
        *(v20 - 1) = *(v21 - 1);
        *v20 = v23;
        v20 -= 2;
        v21 -= 2;
        v22 -= 16;
      }
      while (v22);
      if (v18 != (v18 & 0xFFFFFFFFFFFFFFF0))
      {
LABEL_29:
        do
        {
          v24 = *((_WORD *)v6 - 1);
          v6 -= 2;
          *--v16 = v24;
        }
        while (v6 != v9);
      }
      v6 = (char *)*v8;
    }
    a1[3] = v16;
    a1[4] = v7;
    a1[5] = &v15[2 * v14];
    if (v6)
      operator delete(v6);
  }
  else
  {
    *(_WORD *)v5 = *a2;
    v7 = v5 + 2;
  }
  a1[4] = v7;
}

double glsl::begin(string_t *this, string_t *a2, const HGLimits *a3, const HGLimits *a4)
{
  int v7;
  string_t v8;
  double result;
  char *v10;
  int v11;
  __int16 v12;
  __int16 v13;
  int v14;
  char v15;
  void *v16;
  string_t v17;

  v7 = *(_DWORD *)a3;
  v8 = this[1];
  if (v8)
  {
    str_alloc(this, (uint64_t)v8);
    if (*(_DWORD *)a2 == *(_DWORD *)a3)
      return result;
  }
  else
  {
    str_alloc(this, 33);
    this[1] = (string_t)33;
    if (*(_DWORD *)a2 == *(_DWORD *)a3)
      return result;
  }
  v10 = (char *)*this;
  v11 = v7 & 0xFFF00;
  if ((v7 & 0xFFF00u) <= 0x605FF)
  {
    switch(v11)
    {
      case 132608:
        v13 = 29552;
        break;
      case 329216:
        v13 = 29558;
        break;
      case 329472:
        v12 = 29558;
        goto LABEL_20;
      default:
        return result;
    }
LABEL_17:
    *((_WORD *)v10 + 2) = v13;
    *(_DWORD *)v10 = 1279733551;
    v14 = v7 >> 4;
    v15 = v7 & 0xF;
    if (!(v14 | v7 & 0xF))
    {
LABEL_21:
      v16 = v10 + 6;
      goto LABEL_22;
    }
LABEL_18:
    v10[6] = v14 | 0x30;
    v10[7] = 46;
    v16 = v10 + 9;
    v10[8] = v15 | 0x30;
LABEL_22:
    v17 = *this;
    memset(v16, 32, v17 + 15 - (_BYTE *)v16);
    qmemcpy((void *)(v17 + 15), "\n//LEN=0000000000\n", 18);
    return *(double *)"//LEN=0000000000\n";
  }
  switch(v11)
  {
    case 394752:
      v13 = 29542;
      goto LABEL_17;
    case 395008:
      v12 = 29542;
LABEL_20:
      *((_WORD *)v10 + 2) = v12;
      *(_DWORD *)v10 = 1195585327;
      v14 = v7 >> 4;
      v15 = v7 & 0xF;
      if (!(v14 | v7 & 0xF))
        goto LABEL_21;
      goto LABEL_18;
    case 460288:
      v13 = 29557;
      goto LABEL_17;
  }
  return result;
}

uint64_t HGString::Digest::push(HGString::Digest *this, HGShaderBinding *a2, const HGString::Digest *a3, const HGString::Digest *a4, int a5, const HGLimits *a6)
{
  int v6;
  int v7;
  int v9;
  unsigned int v13;
  unsigned __int8 v14;
  unsigned int v15;
  int v16;
  int v17;
  __int16 v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned int v27;
  __int16 v28;
  __int16 v29;
  char v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int8x8_t v35;
  uint8x8_t v36;
  __int16 v37;
  unsigned __int8 v38;
  unsigned __int16 v39;
  char v40;
  unsigned __int8 v41;
  int v42;
  unsigned __int16 v43;
  unsigned __int16 v44;
  unsigned int v45;
  int16x8_t v46;
  unsigned __int16 v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  char v60;
  unsigned int v61;
  char v62;

  v6 = *((_DWORD *)a3 + 4);
  if (!v6)
  {
    v9 = *((_DWORD *)a4 + 4);
    if ((v9 & 0xFFFFFu) - 394000 < 0x131 || (v9 & 0xFFFFFu) - 394768 < 0x11 || (v9 & 0xFFFFF) == 396048)
      goto LABEL_27;
    goto LABEL_16;
  }
  v7 = v6 & 0xFFFFF;
  if (v7 != 396048 && (v7 - 394000) >= 0x131 && (v7 - 394768) > 0x10)
    return 0xFFFFFFFFLL;
  if ((v7 - 394305) >= 0xFFFFFECF)
  {
    if ((*((_DWORD *)a4 + 4) & 0xFFFFFu) - 394305 < 0xFFFFFECF)
      goto LABEL_24;
  }
  else
  {
    if ((v7 - 394785) < 0xFFFFFFEF)
    {
      if (v7 == 396048)
      {
        v9 = *((_DWORD *)a4 + 4);
        if ((v9 & 0xFFFFF) == 0x60B10)
          goto LABEL_27;
LABEL_16:
        if (v9)
          return 0xFFFFFFFFLL;
        return *((unsigned __int8 *)a3 + 58);
      }
LABEL_24:
      if (*((_DWORD *)a4 + 4))
        return 0xFFFFFFFFLL;
      return *((unsigned __int8 *)a3 + 58);
    }
    if ((*((_DWORD *)a4 + 4) & 0xFFFFFu) - 394785 < 0xFFFFFFEF)
      goto LABEL_24;
  }
LABEL_27:
  if (a5 && (*((unsigned __int16 *)a4 + 26) > 1u || *((unsigned __int8 *)a4 + 56) > 1u)
    || (*((_DWORD *)a3 + 5) & *((_DWORD *)a4 + 5) & 0x8000000) != 0
    || *((_BYTE *)a4 + 58) != 1)
  {
    return 0xFFFFFFFFLL;
  }
  v13 = *((unsigned __int8 *)a4 + 59);
  if (v13 <= 1)
    LOBYTE(v13) = 1;
  v14 = v13 + *((_BYTE *)a3 + 58);
  *((_BYTE *)this + 59) = v14;
  v15 = v14 <= *((unsigned __int8 *)a3 + 59) ? *((unsigned __int8 *)a3 + 59) : v14;
  *((_BYTE *)this + 59) = v15;
  if (v15 > 8)
    return 0xFFFFFFFFLL;
  v16 = *((unsigned __int16 *)a3 + 25);
  v17 = *((unsigned __int16 *)a3 + 18);
  *(_DWORD *)a2 = v16;
  *((_DWORD *)a2 + 1) = v17;
  v18 = *((_WORD *)a3 + 26);
  v19 = *((unsigned __int8 *)a3 + 58);
  *((_DWORD *)a2 + 2) = v18;
  *((_DWORD *)a2 + 3) = v19;
  v20 = *((unsigned __int16 *)a3 + 19);
  v21 = *((_DWORD *)a3 + 15);
  *((_DWORD *)a2 + 4) = v20;
  *((_DWORD *)a2 + 5) = v21;
  v22 = *((unsigned __int8 *)a3 + 56);
  *((_DWORD *)a2 + 6) = v22;
  *(_QWORD *)((char *)a2 + 28) = 0xFFFFFFFFLL;
  v24 = *((_DWORD *)a3 + 4);
  v23 = *((_DWORD *)a3 + 5);
  v25 = *((_DWORD *)a4 + 5);
  if (v24 <= *((_DWORD *)a4 + 4))
    v24 = *((_DWORD *)a4 + 4);
  if (v19)
    v26 = *((_DWORD *)a3 + 5);
  else
    v26 = *((_DWORD *)a4 + 5);
  v27 = v25 & 0xEFFFFFFF | v23 & 0xDBFFFFFF | v26 & 0x20000000;
  v28 = *((_WORD *)a4 + 24) | *((_WORD *)a3 + 24);
  v29 = *((_WORD *)a4 + 23) | *((_WORD *)a3 + 23);
  v30 = *((_BYTE *)a4 + 57) | *((_BYTE *)a3 + 57);
  v31 = v25 | v23;
  v32 = v23 & v25 & 0xC0000000;
  if (v31 < 0)
    v32 = 0x80000000;
  v33 = v27 | v32;
  v34 = (*((_DWORD *)a4 + 8) << v22) | *((_DWORD *)a3 + 8);
  *((_DWORD *)this + 4) = v24;
  *((_DWORD *)this + 5) = v33;
  v35 = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)((char *)a4 + 24), (uint32x2_t)vdup_n_s32(v22)), (int8x8_t)0xFF000000FFLL);
  v36 = (uint8x8_t)vorr_s8(v35, *(int8x8_t *)((char *)a3 + 24));
  *((uint8x8_t *)this + 3) = v36;
  *((_DWORD *)this + 8) = v34;
  *((_WORD *)this + 24) = v28;
  *((_WORD *)this + 23) = v29;
  *((_BYTE *)this + 58) = v19 + 1;
  *((_BYTE *)this + 57) = v30;
  v37 = *((_WORD *)a4 + 26);
  if (a5)
    v37 = 1;
  v38 = v37 + v18;
  v39 = (v37 + v18) | v18 & 0xFF00;
  *((_WORD *)this + 26) = v39;
  v40 = *((_BYTE *)a4 + 56);
  if (a5)
    v40 = 1;
  v41 = v40 + v22;
  *((_BYTE *)this + 56) = v40 + v22;
  v42 = *((_DWORD *)a2 + 6);
  if (!a5 && !*((_DWORD *)a2 + 2) && !v42 && (*((_DWORD *)a4 + 4) & 0xFFFFF) != 0x60B10)
  {
    if (v39 > v41)
      v41 = v38;
    *((_BYTE *)this + 56) = v41;
    LOBYTE(v39) = v41;
    *((_WORD *)this + 26) = v41;
  }
  v43 = *((_WORD *)a4 + 19) + v20;
  *((_WORD *)this + 19) = v43;
  *((_DWORD *)this + 15) = *((_DWORD *)a4 + 15) + v21;
  v44 = *((_WORD *)a4 + 18) + v17;
  *((_WORD *)this + 18) = v44;
  v45 = *((unsigned __int16 *)a4 + 20);
  if (v45 <= *((unsigned __int16 *)a3 + 20))
    v45 = *((unsigned __int16 *)a3 + 20);
  *((_WORD *)this + 20) = v45;
  v36.i32[0] = *(_DWORD *)((char *)a4 + 42);
  v46 = (int16x8_t)vmovl_u8(v36);
  v35.i32[0] = *(_DWORD *)((char *)a3 + 42);
  *(uint16x4_t *)v46.i8 = vmax_u16(*(uint16x4_t *)v46.i8, (uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v35));
  *(_DWORD *)((char *)this + 42) = vmovn_s16(v46).u32[0];
  v47 = *((_WORD *)a4 + 25) + v16;
  *((_WORD *)this + 25) = v47;
  if (a6)
  {
    if (*((unsigned __int16 *)a6 + 18) < v39)
      return 0xFFFFFFFFLL;
    if (*((unsigned __int8 *)a6 + 40) < v41)
      return 0xFFFFFFFFLL;
    if (*((unsigned __int16 *)a6 + 11) < v43)
      return 0xFFFFFFFFLL;
    v48 = *((unsigned __int16 *)a6 + 10);
    if (v44 > v48
      || v44 + v43 > v48
      || v45 + v15 + v46.u8[2] + v46.u8[0] + v46.u8[4] + v47 > *((unsigned __int8 *)a6 + 27)
                                                             + *((unsigned __int16 *)a6 + 12)
                                                             + *((unsigned __int8 *)a6 + 26)
                                                             + *((unsigned __int8 *)a6 + 28)
                                                             + *((unsigned __int16 *)a6 + 17)
                                                             + *((unsigned __int8 *)a6 + 43))
    {
      return 0xFFFFFFFFLL;
    }
  }
  if (v42)
  {
    v49 = *(_DWORD *)a4;
    if (v42 < 1)
    {
      v58 = *((_DWORD *)a4 + 2);
      v57 = *((_DWORD *)a4 + 3);
      v52 = (v57 >> v42) | (v49 >> -(char)v42);
      v59 = *((_DWORD *)a4 + 1);
      v54 = (v59 >> -(char)v42) | (v49 >> v42);
      v55 = (v58 >> -(char)v42) | (v59 >> v42);
      v56 = (v58 >> v42) | (v57 >> -(char)v42);
    }
    else
    {
      v51 = *((_DWORD *)a4 + 2);
      v50 = *((_DWORD *)a4 + 3);
      v52 = (v50 >> -(char)v42) | (v49 << v42);
      v53 = *((_DWORD *)a4 + 1);
      v54 = (v53 << v42) | (v49 >> -(char)v42);
      v55 = (v51 << v42) | (v53 >> -(char)v42);
      v56 = (v51 >> -(char)v42) | (v50 << v42);
    }
  }
  else
  {
    v52 = *(_DWORD *)a4;
    v54 = *((_DWORD *)a4 + 1);
    v55 = *((_DWORD *)a4 + 2);
    v56 = *((_DWORD *)a4 + 3);
  }
  if (v19)
  {
    v60 = v19 & 7;
    v61 = v52 << (v19 & 7);
    v62 = -(char)v19 & 7;
    v52 = (v61 | (v52 >> v62)) | (unsigned __int16)(((v52 >> 8 << v60) | (BYTE1(v52) >> v62)) << 8) | (((HIWORD(v52) << v60) | (BYTE2(v52) >> v62)) << 16) | (((HIBYTE(v52) << v60) | (HIBYTE(v52) >> v62)) << 24);
    v54 = ((v54 << v60) | (v54 >> v62)) | (unsigned __int16)(((v54 >> 8 << v60) | (BYTE1(v54) >> v62)) << 8) | (((HIWORD(v54) << v60) | (BYTE2(v54) >> v62)) << 16) | (((HIBYTE(v54) << v60) | (HIBYTE(v54) >> v62)) << 24);
    v55 = ((v55 << v60) | (v55 >> v62)) | (unsigned __int16)(((v55 >> 8 << v60) | (BYTE1(v55) >> v62)) << 8) | (((HIWORD(v55) << v60) | (BYTE2(v55) >> v62)) << 16) | (((HIBYTE(v55) << v60) | (HIBYTE(v55) >> v62)) << 24);
    v56 = ((v56 << v60) | (v56 >> v62)) | (unsigned __int16)(((v56 >> 8 << v60) | (BYTE1(v56) >> v62)) << 8) | (((HIWORD(v56) << v60) | (BYTE2(v56) >> v62)) << 16) | (((HIBYTE(v56) << v60) | (HIBYTE(v56) >> v62)) << 24);
  }
  *(_DWORD *)this = *(_DWORD *)a3 ^ v52;
  *((_DWORD *)this + 1) = *((_DWORD *)a3 + 1) ^ v54;
  *((_DWORD *)this + 2) = *((_DWORD *)a3 + 2) ^ v55;
  *((_DWORD *)this + 3) = *((_DWORD *)a3 + 3) ^ v56;
  return *((unsigned int *)a2 + 3);
}

uint64_t HGString::push(HGString *this, HGShaderBinding *a2, const HGString *a3, BOOL a4, int a5, const HGLimits *a6)
{
  uint64_t v11;
  const HGLimits *v12;
  int v13;
  uint64_t v14;
  const char *v15;
  double v16;
  double v17;
  uint32x4_t v18;
  unsigned int v19;
  const char *v20;
  double v21;
  double v22;
  uint32x4_t v23;
  int v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  BOOL v29;
  unsigned int v30;
  _BYTE v31[5];
  __int16 v32;
  unsigned int v33[4];
  _OWORD v34[2];
  __int128 v35;
  _BYTE v36[16];
  int v37;
  char v38;
  _BYTE v39[16];
  string_t v40[6];

  HGString::digest(this, (uint64_t)v39);
  HGString::digest(a3, (uint64_t)v36);
  v35 = 0u;
  memset(v34, 0, sizeof(v34));
  if (!LODWORD(v40[0]))
    *((_QWORD *)this + 1) = 0;
  v11 = HGString::Digest::push((HGString::Digest *)v33, a2, (const HGString::Digest *)v39, (const HGString::Digest *)v36, a5, a6);
  if ((_DWORD)v11 != -1)
  {
    LOBYTE(v32) = v38;
    HIBYTE(v32) = BYTE8(v35);
    HGString::appendHistory(this, &v32);
    if ((v37 & 0xFFFFFu) - 394305 >= 0xFFFFFECF)
    {
      arb::begin((string_t *)this, v40, (const HGLimits *)v34, v12);
      arb::write((string_t *)this, (string_t *)a2, (const HGShaderBinding *)v40, (const HGLimits *)0xFFFFFFFFLL, 0xFFFFFFFF, *(const HGLimits **)a3, 1, 0, v29, v30, *(int *)v31, v31[4]);
      arb::end((string_t *)this, (uint64_t)v34, v33, v16, v17, v18);
    }
    else
    {
      if ((v37 & 0xFFFFFu) - 394785 >= 0xFFFFFFEF)
      {
        glsl::begin((string_t *)this, v40, (const HGLimits *)v34, v12);
        v21 = glsl::write(this, (string_t *)a2, (const HGShaderBinding *)0xFFFFFFFFLL, *(const HGLimits **)a3, 1, 0, v19, v20, v29, v30, *(int *)v31, v31[4]);
LABEL_19:
        glsl::end((string_t *)this, (uint64_t)v34, v33, 0, v21, v22, v23);
        return v11;
      }
      if ((v37 & 0xFFFFF) == 0x60B10)
      {
        v13 = v34[0];
        v14 = *((_QWORD *)this + 1);
        if (v14)
        {
          str_alloc((string_t *)this, v14);
          if (LODWORD(v40[0]) == v13)
            goto LABEL_18;
        }
        else
        {
          str_alloc((string_t *)this, 33);
          *((_QWORD *)this + 1) = 33;
          if (LODWORD(v40[0]) == v13)
          {
LABEL_18:
            metal::write(this, (string_t *)a2, (const HGShaderBinding *)v34, (const HGLimits *)0xFFFFFFFFLL, *(_QWORD *)a3, (const HGLimits *)1, 0, v15, v29, v30, *(int *)v31, v31[4]);
            goto LABEL_19;
          }
        }
        v24 = v13 >> 4;
        v25 = *(_QWORD *)this;
        *(_DWORD *)(v25 + 3) = 1818326117;
        *(_DWORD *)v25 = 1699557167;
        if (v24 | v13 & 0xF)
        {
          *(_BYTE *)(v25 + 7) = v24 | 0x30;
          *(_BYTE *)(v25 + 8) = 46;
          v26 = (void *)(v25 + 10);
          *(_BYTE *)(v25 + 9) = v13 & 0xF | 0x30;
        }
        else
        {
          v26 = (void *)(v25 + 7);
        }
        v27 = *(_QWORD *)this;
        memset(v26, 32, *(_QWORD *)this + 15 - (_QWORD)v26);
        qmemcpy((void *)(v27 + 15), "\n//LEN=0000000000\n", 18);
        goto LABEL_18;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v11;
}

double glsl::write(glsl *this, string_t *a2, const HGShaderBinding *a3, const HGLimits *__s1, int a5, const HGLimits *a6, unsigned int a7, const char *a8, BOOL a9, unsigned int a10, int a11, BOOL a12)
{
  int v13;
  unsigned __int8 *v14;
  _BOOL4 v15;
  __int128 v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  unsigned int v26;
  unsigned __int8 *i;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  size_t v35;
  void *v36;
  void *v37;
  size_t v38;
  uint64_t v39;
  size_t v40;
  size_t *v41;
  int v42;
  BOOL v43;
  int v44;
  BOOL v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  size_t v52;
  void *v53;
  size_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  size_t v58;
  void *v59;
  size_t *v60;
  int v61;
  unsigned __int8 *v62;
  int v63;
  unsigned __int8 *v64;
  int v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  size_t v70;
  void *v71;
  size_t *v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  size_t v77;
  void *v78;
  size_t *v79;
  int v80;
  int v81;
  signed int v82;
  uint64_t v83;
  signed int v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  void *v88;
  unint64_t *v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  void *v93;
  size_t *v94;
  int v95;
  char *v96;
  signed int v97;
  int v98;
  signed int v99;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  void *v105;
  unint64_t *v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  void *v110;
  size_t *v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  void *v117;
  unint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  void *v123;
  unint64_t *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  void *v129;
  _QWORD *v130;
  uint64_t v131;
  int v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v138;
  void *v139;
  unint64_t *v140;
  uint64_t v141;
  uint64_t v142;
  signed int v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  void *v147;
  unint64_t *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unint64_t v152;
  void *v153;
  unint64_t *v154;
  unint64_t v155;
  void *v156;
  unint64_t *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  void *v162;
  unint64_t *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  void *v168;
  unint64_t *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unint64_t v173;
  void *v174;
  _QWORD *v175;
  uint64_t v176;
  int v177;
  int64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  size_t v182;
  void *v183;
  size_t *v184;
  unsigned __int8 *v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t v188;
  size_t v189;
  void *v190;
  size_t *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  unint64_t v196;
  size_t v197;
  void *v198;
  size_t *v199;
  int v200;
  unsigned __int8 *v201;
  int64_t v202;
  uint64_t v203;
  uint64_t v204;
  unint64_t v205;
  size_t v206;
  void *v207;
  size_t *v208;
  uint64_t v209;
  int v210;
  unsigned __int8 *v211;
  int v212;
  int v213;
  uint64_t v214;
  uint64_t v215;
  unint64_t v216;
  size_t v217;
  void *v218;
  size_t *v219;
  int v220;
  uint64_t v221;
  signed int v222;
  uint64_t v223;
  uint64_t v224;
  unint64_t v225;
  void *v226;
  unint64_t *v227;
  int v228;
  unsigned int v229;
  uint64_t v230;
  int v231;
  unsigned __int8 *v232;
  int v233;
  size_t v234;
  const char *v235;
  uint64_t v236;
  uint64_t v237;
  unint64_t v238;
  void *v239;
  size_t *v240;
  uint64_t v241;
  uint64_t v242;
  unint64_t v243;
  size_t v244;
  void *v245;
  size_t *v246;
  int v247;
  unsigned int v248;
  uint64_t v249;
  int v250;
  unsigned __int8 *v251;
  int v252;
  uint64_t v253;
  uint64_t v254;
  unint64_t v255;
  uint64_t v256;
  int v257;
  uint64_t v258;
  int v259;
  unsigned __int8 *v260;
  int v261;
  unint64_t v262;
  void *v263;
  unint64_t *v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  unint64_t v268;
  void *v269;
  unint64_t *v270;
  size_t v271;
  const char *v272;
  uint64_t v273;
  uint64_t v274;
  unint64_t v275;
  void *v276;
  size_t *v277;
  uint64_t v278;
  uint64_t v279;
  unint64_t v280;
  size_t v281;
  void *v282;
  size_t *v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  unint64_t v289;
  void *v290;
  unint64_t *v291;
  uint64_t v292;
  int v293;
  int v294;
  uint64_t v295;
  int v296;
  uint64_t v297;
  unsigned __int8 *v298;
  size_t v300;
  size_t v301;
  int v302;
  unsigned int v303;
  _BOOL4 v304;
  unsigned int v305;

  v305 = a6;
  v303 = a3;
  v14 = (unsigned __int8 *)__s1 + 33;
  v13 = *((unsigned __int8 *)__s1 + 33);
  v15 = v13 == 35;
  if (v13 != 35)
  {
    v304 = 0;
    if (!*((_BYTE *)__s1 + 33))
      return *(double *)&v17;
    goto LABEL_13;
  }
  if (strncmp((const char *)__s1 + 33, "#ifndef GL_ES", 0xDuLL))
  {
    v304 = 0;
LABEL_13:
    v25 = 0;
    v302 = 0;
    v26 = 0;
    for (i = v14; ; i += 9)
    {
      while (1)
      {
        while (1)
        {
          --i;
          do
          {
            v29 = *++i;
            v28 = v29;
          }
          while ((v29 - 33) > 0xFFFFFFDF);
          v30 = v25;
          if (v28 != 47)
            break;
          while (i[1] == 47)
          {
            v32 = *((_QWORD *)this + 1);
            v31 = *((_QWORD *)this + 2);
            v33 = v32 + i - v14;
            if (v31)
            {
              if (v33 >= *(_QWORD *)v31)
              {
                v40 = (v33 + 255) & 0xFFFFFFFFFFFFFF00;
                v34 = (char *)malloc_type_realloc(*(void **)(v31 + 16), v40, 0xCCCD1039uLL);
                v41 = (size_t *)*((_QWORD *)this + 2);
                v41[2] = (size_t)v34;
                *v41 = v40;
                *(_QWORD *)this = v34;
              }
              else
              {
                v34 = *(char **)this;
              }
            }
            else
            {
              v35 = (v33 + 255) & 0xFFFFFFFFFFFFFF00;
              v36 = malloc_type_malloc(0x18uLL, 0x1010040A79CA2DEuLL);
              v37 = malloc_type_malloc(v35, 0x2BEB8FE7uLL);
              *((_QWORD *)v36 + 2) = v37;
              bzero(v37, v35);
              *((_QWORD *)v36 + 1) = 1;
              v38 = *((_QWORD *)this + 1);
              if (v38)
                memcpy(*((void **)v36 + 2), *(const void **)this, v38);
              v39 = *((_QWORD *)this + 2);
              if (v39)
                --*(_QWORD *)(v39 + 8);
              *(_QWORD *)v36 = v35;
              *((_QWORD *)this + 2) = v36;
              v34 = (char *)*((_QWORD *)v36 + 2);
              *(_QWORD *)this = v34;
              v25 = v30;
            }
            *((_QWORD *)this + 1) += i - v14;
            memcpy(&v34[v32], v14, i - v14);
            v42 = *i;
            if (*i)
              v43 = v42 == 10;
            else
              v43 = 1;
            if (!v43)
            {
              do
              {
                v44 = *++i;
                v42 = v44;
                if (v44)
                  v45 = v42 == 10;
                else
                  v45 = 1;
              }
              while (!v45);
            }
            if (v42 == 10)
              ++i;
            v28 = *i;
            v14 = i;
            if (v28 != 47)
              goto LABEL_39;
          }
LABEL_88:
          if ((v28 - 48) >= 0xA && (ctype[2 * v28] & 0x40) != 0)
          {
            do
              v73 = *++i;
            while ((ctype[2 * v73] & 0x40) != 0);
            goto LABEL_215;
          }
LABEL_130:
          if (!*++i)
            return *(double *)&v17;
        }
LABEL_39:
        if (!v28)
          return *(double *)&v17;
        if (v28 == 118)
          break;
        if (v28 != 116 || (a5 & 1) != 0)
        {
          switch(v28)
          {
            case 'g':
              if (i[1] != 108 || i[2] != 95)
                goto LABEL_88;
              if (strncmp((const char *)i + 3, "TexCoord[", 9uLL))
              {
                if ((a5 & 1) != 0 && !strncmp((const char *)i + 3, "FragColor", 9uLL))
                {
                  v215 = *((_QWORD *)this + 1);
                  v214 = *((_QWORD *)this + 2);
                  v216 = v215 + i - v14;
                  if (v214)
                  {
                    if (v216 >= *(_QWORD *)v214)
                    {
                      v217 = (v216 + 255) & 0xFFFFFFFFFFFFFF00;
                      v218 = malloc_type_realloc(*(void **)(v214 + 16), v217, 0xCCCD1039uLL);
                      v219 = (size_t *)*((_QWORD *)this + 2);
                      v219[2] = (size_t)v218;
                      *v219 = v217;
                      *(_QWORD *)this = v218;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v216);
                  }
                  v265 = *(_QWORD *)this;
                  *((_QWORD *)this + 1) += i - v14;
                  memcpy((void *)(v265 + v215), v14, i - v14);
                  v267 = *((_QWORD *)this + 1);
                  v266 = *((_QWORD *)this + 2);
                  v268 = v267 + 12;
                  if (v266)
                  {
                    if (v268 >= *(_QWORD *)v266)
                    {
                      v269 = malloc_type_realloc(*(void **)(v266 + 16), (v267 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      v270 = (unint64_t *)*((_QWORD *)this + 2);
                      v270[2] = (unint64_t)v269;
                      *v270 = (v267 + 267) & 0xFFFFFFFFFFFFFF00;
                      *(_QWORD *)this = v269;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v268);
                  }
                  v284 = *(_QWORD *)this;
                  *((_QWORD *)this + 1) += 12;
                  v285 = v284 + v267;
                  *(_QWORD *)v285 = *(_QWORD *)"hg_FragColor";
                  *(_DWORD *)(v285 + 8) = 1919904879;
                  i += 12;
                  v14 = i;
                }
                else
                {
                  do
                    v48 = *++i;
                  while ((ctype[2 * v48] & 0x40) != 0);
                }
                break;
              }
              v178 = i + 11 - v14;
              v180 = *((_QWORD *)this + 1);
              v179 = *((_QWORD *)this + 2);
              v181 = v180 + v178;
              if (v179)
              {
                if (v181 >= *(_QWORD *)v179)
                {
                  v182 = (v181 + 255) & 0xFFFFFFFFFFFFFF00;
                  v183 = malloc_type_realloc(*(void **)(v179 + 16), v182, 0xCCCD1039uLL);
                  v184 = (size_t *)*((_QWORD *)this + 2);
                  v184[2] = (size_t)v183;
                  *v184 = v182;
                  *(_QWORD *)this = v183;
                }
              }
              else
              {
                str_alloc((string_t *)this, v181);
              }
              v209 = *(_QWORD *)this;
              *((_QWORD *)this + 1) += v178;
              memcpy((void *)(v209 + v180), v14, i + 11 - v14);
              v210 = i[11];
              if ((v210 - 58) >= 0xFFFFFFF6)
              {
                v26 = 0;
                v211 = i + 11;
                do
                {
                  v26 = v210 + 10 * v26 - 48;
                  v212 = *++v211;
                  v210 = v212;
                }
                while ((v212 - 58) > 0xFFFFFFF5);
              }
              else
              {
                v26 = 0;
                v211 = 0;
              }
              if (v211)
                i = v211;
              else
                i += 11;
              v213 = *((_DWORD *)a2 + 2);
              goto LABEL_289;
            case 'h':
              if (i[1] != 103 || i[2] != 95)
                goto LABEL_88;
              if (!strncmp((const char *)i + 3, "Texture", 7uLL))
              {
                v185 = i + 10;
                if (a5)
                {
                  v187 = *((_QWORD *)this + 1);
                  v186 = *((_QWORD *)this + 2);
                  v188 = v187 + v185 - v14;
                  if (v186)
                  {
                    if (v188 >= *(_QWORD *)v186)
                    {
                      v189 = (v188 + 255) & 0xFFFFFFFFFFFFFF00;
                      v190 = malloc_type_realloc(*(void **)(v186 + 16), v189, 0xCCCD1039uLL);
                      v191 = (size_t *)*((_QWORD *)this + 2);
                      v191[2] = (size_t)v190;
                      *v191 = v189;
                      *(_QWORD *)this = v190;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v188);
                  }
                  v230 = *(_QWORD *)this;
                  *((_QWORD *)this + 1) += v185 - v14;
                  memcpy((void *)(v230 + v187), v14, v185 - v14);
                  v231 = *v185;
                  if ((v231 - 58) >= 0xFFFFFFF6)
                  {
                    v26 = 0;
                    v232 = i + 10;
                    do
                    {
                      v26 = v231 + 10 * v26 - 48;
                      v233 = *++v232;
                      v231 = v233;
                    }
                    while ((v233 - 58) > 0xFFFFFFF5);
                  }
                  else
                  {
                    v26 = 0;
                    v232 = 0;
                  }
                  if (v232)
                    i = v232;
                  else
                    i += 10;
                  v213 = *((_DWORD *)a2 + 6);
LABEL_304:
                  v254 = *((_QWORD *)this + 1);
                  v253 = *((_QWORD *)this + 2);
                  v262 = v254 + 20;
                  if (v253)
                  {
                    v25 = v30;
                    if (v262 >= *(_QWORD *)v253)
                    {
LABEL_306:
                      v263 = malloc_type_realloc(*(void **)(v253 + 16), (v254 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      v264 = (unint64_t *)*((_QWORD *)this + 2);
                      v264[2] = (unint64_t)v263;
                      *v264 = (v254 + 275) & 0xFFFFFFFFFFFFFF00;
                      *(_QWORD *)this = v263;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v262);
                    v25 = v30;
                  }
LABEL_308:
                  v97 = v213 + v26;
                  v96 = (char *)(*(_QWORD *)this + v254);
                  goto LABEL_121;
                }
                v200 = *v185;
                if ((v200 - 58) >= 0xFFFFFFF6)
                {
                  v26 = 0;
                  v201 = i + 10;
                  do
                  {
                    v26 = v200 + 10 * v26 - 48;
                    v228 = *++v201;
                    v200 = v228;
                  }
                  while ((v228 - 58) > 0xFFFFFFF5);
                }
                else
                {
                  v26 = 0;
                  v201 = 0;
                }
                if (v305)
                {
                  v229 = v26;
                  if (((v305 >> v26) & 1) == 0)
                    goto LABEL_272;
LABEL_262:
                  if (v229 != -1)
                  {
                    if (!v201)
                      v201 = i;
                    v234 = v201 - v14;
                    v235 = (const char *)v201;
                    v25 = v30;
                    while (*v235 != 117 || strncmp(v235, "uniform", 7uLL))
                    {
                      --v235;
                      --v234;
                    }
                    v237 = *((_QWORD *)this + 1);
                    v236 = *((_QWORD *)this + 2);
                    v238 = v237 + v234;
                    if (v236)
                    {
                      if (v238 >= *(_QWORD *)v236)
                      {
                        v239 = malloc_type_realloc(*(void **)(v236 + 16), (v237 + v234 + 255) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                        v240 = (size_t *)*((_QWORD *)this + 2);
                        v240[2] = (size_t)v239;
                        *v240 = (v237 + v234 + 255) & 0xFFFFFFFFFFFFFF00;
                        *(_QWORD *)this = v239;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v238);
                    }
                    v292 = *(_QWORD *)this;
                    *((_QWORD *)this + 1) += v234;
                    memcpy((void *)(v292 + v237), v14, v234);
                    v293 = *v201;
                    if (*v201)
                    {
                      do
                      {
                        if (v293 == 59)
                          break;
                        v294 = *++v201;
                        v293 = v294;
                      }
                      while (v294);
                    }
                    goto LABEL_349;
                  }
                }
                else if (v303 != -1)
                {
                  v229 = v26 - v303;
                  if (v26 >= v303)
                    goto LABEL_262;
                }
LABEL_272:
                v242 = *((_QWORD *)this + 1);
                v241 = *((_QWORD *)this + 2);
                v243 = v242 + v185 - v14;
                if (v241)
                {
                  if (v243 >= *(_QWORD *)v241)
                  {
                    v244 = (v243 + 255) & 0xFFFFFFFFFFFFFF00;
                    v245 = malloc_type_realloc(*(void **)(v241 + 16), v244, 0xCCCD1039uLL);
                    v246 = (size_t *)*((_QWORD *)this + 2);
                    v246[2] = (size_t)v245;
                    *v246 = v244;
                    *(_QWORD *)this = v245;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v243);
                }
                v256 = *(_QWORD *)this;
                *((_QWORD *)this + 1) += v185 - v14;
                memcpy((void *)(v256 + v242), v14, v185 - v14);
                v257 = *((_DWORD *)a2 + 6);
LABEL_332:
                v288 = *((_QWORD *)this + 1);
                v287 = *((_QWORD *)this + 2);
                v289 = v288 + 20;
                if (v287)
                {
                  if (v289 >= *(_QWORD *)v287)
                  {
                    v290 = malloc_type_realloc(*(void **)(v287 + 16), (v288 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v291 = (unint64_t *)*((_QWORD *)this + 2);
                    v291[2] = (unint64_t)v290;
                    *v291 = (v288 + 275) & 0xFFFFFFFFFFFFFF00;
                    *(_QWORD *)this = v290;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v289);
                }
                *((_QWORD *)this + 1) += itoa((char *)(*(_QWORD *)this + v288), v257 + v26);
                if (v201)
                  i = v201;
                else
                  i = v185;
                v14 = i;
                v25 = v30;
                break;
              }
              if (!strncmp((const char *)i + 3, "TexCoord", 8uLL))
              {
                v185 = i + 11;
                if (a5)
                {
                  v195 = *((_QWORD *)this + 1);
                  v194 = *((_QWORD *)this + 2);
                  v196 = v195 + v185 - v14;
                  if (v194)
                  {
                    if (v196 >= *(_QWORD *)v194)
                    {
                      v197 = (v196 + 255) & 0xFFFFFFFFFFFFFF00;
                      v198 = malloc_type_realloc(*(void **)(v194 + 16), v197, 0xCCCD1039uLL);
                      v199 = (size_t *)*((_QWORD *)this + 2);
                      v199[2] = (size_t)v198;
                      *v199 = v197;
                      *(_QWORD *)this = v198;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v196);
                  }
                  v258 = *(_QWORD *)this;
                  *((_QWORD *)this + 1) += v185 - v14;
                  memcpy((void *)(v258 + v195), v14, v185 - v14);
                  v259 = *v185;
                  if ((v259 - 58) >= 0xFFFFFFF6)
                  {
                    v26 = 0;
                    v260 = i + 11;
                    do
                    {
                      v26 = v259 + 10 * v26 - 48;
                      v261 = *++v260;
                      v259 = v261;
                    }
                    while ((v261 - 58) > 0xFFFFFFF5);
                  }
                  else
                  {
                    v26 = 0;
                    v260 = 0;
                  }
                  if (v260)
                    i = v260;
                  else
                    i += 11;
                  v213 = *((_DWORD *)a2 + 2);
                  goto LABEL_304;
                }
                v220 = *v185;
                if ((v220 - 58) >= 0xFFFFFFF6)
                {
                  v26 = 0;
                  v201 = i + 11;
                  do
                  {
                    v26 = v220 + 10 * v26 - 48;
                    v247 = *++v201;
                    v220 = v247;
                  }
                  while ((v247 - 58) > 0xFFFFFFF5);
                }
                else
                {
                  v26 = 0;
                  v201 = 0;
                }
                if (v305)
                {
                  v248 = v26;
                  if (((v305 >> v26) & 1) == 0)
                  {
LABEL_325:
                    v279 = *((_QWORD *)this + 1);
                    v278 = *((_QWORD *)this + 2);
                    v280 = v279 + v185 - v14;
                    if (v278)
                    {
                      if (v280 >= *(_QWORD *)v278)
                      {
                        v281 = (v280 + 255) & 0xFFFFFFFFFFFFFF00;
                        v282 = malloc_type_realloc(*(void **)(v278 + 16), v281, 0xCCCD1039uLL);
                        v283 = (size_t *)*((_QWORD *)this + 2);
                        v283[2] = (size_t)v282;
                        *v283 = v281;
                        *(_QWORD *)this = v282;
                      }
                    }
                    else
                    {
                      str_alloc((string_t *)this, v280);
                    }
                    v286 = *(_QWORD *)this;
                    *((_QWORD *)this + 1) += v185 - v14;
                    memcpy((void *)(v286 + v279), v14, v185 - v14);
                    v257 = *((_DWORD *)a2 + 2);
                    goto LABEL_332;
                  }
                }
                else
                {
                  if (v303 == -1)
                    goto LABEL_325;
                  v248 = v26 - v303;
                  if (v26 < v303)
                    goto LABEL_325;
                }
                if (v248 != -1)
                {
                  if (!v201)
                    v201 = i;
                  v271 = v201 - v14;
                  v272 = (const char *)v201;
                  v25 = v30;
                  while (*v272 != 118 || strncmp(v272, "varying", 7uLL))
                  {
                    --v272;
                    --v271;
                  }
                  v274 = *((_QWORD *)this + 1);
                  v273 = *((_QWORD *)this + 2);
                  v275 = v274 + v271;
                  if (v273)
                  {
                    if (v275 >= *(_QWORD *)v273)
                    {
                      v276 = malloc_type_realloc(*(void **)(v273 + 16), (v274 + v271 + 255) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      v277 = (size_t *)*((_QWORD *)this + 2);
                      v277[2] = (size_t)v276;
                      *v277 = (v274 + v271 + 255) & 0xFFFFFFFFFFFFFF00;
                      *(_QWORD *)this = v276;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)this, v275);
                  }
                  v295 = *(_QWORD *)this;
                  *((_QWORD *)this + 1) += v271;
                  memcpy((void *)(v295 + v274), v14, v271);
                  v293 = *v201;
                  if (*v201)
                  {
                    do
                    {
                      if (v293 == 59)
                        break;
                      v296 = *++v201;
                      v293 = v296;
                    }
                    while (v296);
                  }
LABEL_349:
                  v43 = v293 == 59;
                  v297 = v293 == 59;
                  if (v43)
                    v298 = v201 + 1;
                  else
                    v298 = v201;
                  if (*v298 == 10)
                    ++v297;
                  i = &v201[v297];
                  v14 = &v201[v297];
                  break;
                }
                goto LABEL_325;
              }
              if (!strncmp((const char *)i + 3, "ProgramLocal", 0xCuLL))
              {
                v202 = i + 15 - v14;
                v204 = *((_QWORD *)this + 1);
                v203 = *((_QWORD *)this + 2);
                v205 = v204 + v202;
                if (v203)
                {
                  if (v205 >= *(_QWORD *)v203)
                  {
                    v206 = (v205 + 255) & 0xFFFFFFFFFFFFFF00;
                    v207 = malloc_type_realloc(*(void **)(v203 + 16), v206, 0xCCCD1039uLL);
                    v208 = (size_t *)*((_QWORD *)this + 2);
                    v208[2] = (size_t)v207;
                    *v208 = v206;
                    *(_QWORD *)this = v207;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v205);
                }
                v249 = *(_QWORD *)this;
                *((_QWORD *)this + 1) += v202;
                memcpy((void *)(v249 + v204), v14, i + 15 - v14);
                v250 = i[15];
                if ((v250 - 58) >= 0xFFFFFFF6)
                {
                  v26 = 0;
                  v251 = i + 15;
                  do
                  {
                    v26 = v250 + 10 * v26 - 48;
                    v252 = *++v251;
                    v250 = v252;
                  }
                  while ((v252 - 58) > 0xFFFFFFF5);
                }
                else
                {
                  v26 = 0;
                  v251 = 0;
                }
                if (v251)
                  i = v251;
                else
                  i += 15;
                v213 = *((_DWORD *)a2 + 4);
LABEL_289:
                v254 = *((_QWORD *)this + 1);
                v253 = *((_QWORD *)this + 2);
                v255 = v254 + 20;
                if (v253)
                {
                  if (v255 >= *(_QWORD *)v253)
                    goto LABEL_306;
                }
                else
                {
                  str_alloc((string_t *)this, v255);
                }
                goto LABEL_308;
              }
              do
                v66 = *++i;
              while ((ctype[2 * v66] & 0x40) != 0);
              break;
            case '{':
              if (v302 || (_DWORD)v25 != 1)
              {
                v80 = v302 + 1;
                goto LABEL_129;
              }
              ++i;
              v75 = *((_QWORD *)this + 1);
              v74 = *((_QWORD *)this + 2);
              v76 = v75 + i - v14;
              if (v74)
              {
                if (v76 >= *(_QWORD *)v74)
                {
                  v77 = (v76 + 255) & 0xFFFFFFFFFFFFFF00;
                  v78 = malloc_type_realloc(*(void **)(v74 + 16), v77, 0xCCCD1039uLL);
                  v79 = (size_t *)*((_QWORD *)this + 2);
                  v79[2] = (size_t)v78;
                  *v79 = v77;
                  *(_QWORD *)this = v78;
                }
              }
              else
              {
                str_alloc((string_t *)this, v76);
              }
              v149 = *(_QWORD *)this;
              *((_QWORD *)this + 1) += i - v14;
              memcpy((void *)(v149 + v75), v14, i - v14);
              v151 = *((_QWORD *)this + 1);
              v150 = *((_QWORD *)this + 2);
              if (v304)
              {
                v152 = v151 + 32;
                if (v150)
                {
                  if (v152 >= *(_QWORD *)v150)
                  {
                    v153 = malloc_type_realloc(*(void **)(v150 + 16), (v151 + 287) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v154 = (unint64_t *)*((_QWORD *)this + 2);
                    v154[2] = (unint64_t)v153;
                    *v154 = (v151 + 287) & 0xFFFFFFFFFFFFFF00;
                    *(_QWORD *)this = v153;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v152);
                }
                v192 = *(_QWORD *)this;
                *((_QWORD *)this + 1) += 32;
                *(_QWORD *)&v17 = *(_QWORD *)"\n    defaultp vec4 hg_FragColor;";
                qmemcpy((void *)(v192 + v151), "\n    defaultp vec4 hg_FragColor;", 32);
              }
              else
              {
                v155 = v151 + 23;
                if (v150)
                {
                  if (v155 >= *(_QWORD *)v150)
                  {
                    v156 = malloc_type_realloc(*(void **)(v150 + 16), (v151 + 278) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v157 = (unint64_t *)*((_QWORD *)this + 2);
                    v157[2] = (unint64_t)v156;
                    *v157 = (v151 + 278) & 0xFFFFFFFFFFFFFF00;
                    *(_QWORD *)this = v156;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v155);
                }
                v193 = *(_QWORD *)this;
                *((_QWORD *)this + 1) += 23;
                *(_QWORD *)&v17 = *(_QWORD *)"\n    vec4 hg_FragColor;";
                qmemcpy((void *)(v193 + v151), "\n    vec4 hg_FragColor;", 23);
              }
              v302 = 1;
              v14 = i;
              v25 = 1;
              break;
            case '}':
              v80 = v302 - 1;
              if (v302 != 1)
                goto LABEL_129;
              if ((_DWORD)v25 == -1)
              {
                str_puts((string_t *)this, (const char *)v14, i - v14);
                *(_WORD *)str_ext((string_t *)this, 2, 2) = 2685;
                return *(double *)&v17;
              }
              if ((_DWORD)v25 == 1)
              {
                str_puts((string_t *)this, (const char *)v14, i - v14);
                qmemcpy((void *)str_ext((string_t *)this, 27, 27), "    return hg_FragColor;\n}\n", 27);
                *(_QWORD *)&v17 = *(_QWORD *)"hg_FragColor;\n}\n";
                return *(double *)&v17;
              }
LABEL_129:
              v302 = v80;
              goto LABEL_130;
            default:
              if (v28 != 109 || !a5 || i[1] != 97 || i[2] != 105 || i[3] != 110)
                goto LABEL_88;
              i += 4;
              v68 = *((_QWORD *)this + 1);
              v67 = *((_QWORD *)this + 2);
              v69 = v68 + i - v14;
              if (v67)
              {
                if (v69 >= *(_QWORD *)v67)
                {
                  v70 = (v69 + 255) & 0xFFFFFFFFFFFFFF00;
                  v71 = malloc_type_realloc(*(void **)(v67 + 16), v70, 0xCCCD1039uLL);
                  v72 = (size_t *)*((_QWORD *)this + 2);
                  v72[2] = (size_t)v71;
                  *v72 = v70;
                  *(_QWORD *)this = v71;
                }
              }
              else
              {
                str_alloc((string_t *)this, v69);
              }
              v221 = *(_QWORD *)this;
              *((_QWORD *)this + 1) += i - v14;
              memcpy((void *)(v221 + v68), v14, i - v14);
              v222 = *((_DWORD *)a2 + 3);
              v224 = *((_QWORD *)this + 1);
              v223 = *((_QWORD *)this + 2);
              v225 = v224 + 20;
              if (v223)
              {
                if (v225 >= *(_QWORD *)v223)
                {
                  v226 = malloc_type_realloc(*(void **)(v223 + 16), (v224 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v227 = (unint64_t *)*((_QWORD *)this + 2);
                  v227[2] = (unint64_t)v226;
                  *v227 = (v224 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v226;
                }
              }
              else
              {
                str_alloc((string_t *)this, v225);
              }
              v96 = (char *)(*(_QWORD *)this + v224);
              v97 = v222;
              goto LABEL_121;
          }
LABEL_215:
          if (!*i)
            return *(double *)&v17;
        }
        else
        {
          if (!strncmp((const char *)i + 1, "exture2DRect(hg_Texture", 0x17uLL))
          {
            v62 = i + 24;
            v61 = i[24];
            if ((v61 - 58) >= 0xFFFFFFF6)
            {
              v26 = 0;
              do
              {
                v26 = v61 + 10 * v26 - 48;
                v81 = *++v62;
                v61 = v81;
              }
              while ((v81 - 58) > 0xFFFFFFF5);
            }
            else
            {
              v62 = 0;
            }
            if (v305)
            {
              v82 = v26;
              if (((v305 >> v26) & 1) == 0 || v26 == -1)
                goto LABEL_117;
            }
            else if (v303 == -1 || v26 < v303 || (v82 = v26 - v303, v26 - v303 == -1))
            {
              do
LABEL_117:
                v95 = *++i;
              while ((ctype[2 * v95] & 0x40) != 0);
              goto LABEL_215;
            }
            v91 = *((_QWORD *)this + 1);
            v90 = *((_QWORD *)this + 2);
            v92 = v91 + i - v14;
            if (v90)
            {
              if (v92 >= *(_QWORD *)v90)
              {
                v300 = (v92 + 255) & 0xFFFFFFFFFFFFFF00;
                v93 = malloc_type_realloc(*(void **)(v90 + 16), v300, 0xCCCD1039uLL);
                v94 = (size_t *)*((_QWORD *)this + 2);
                v94[2] = (size_t)v93;
                *v94 = v300;
                *(_QWORD *)this = v93;
              }
            }
            else
            {
              str_alloc((string_t *)this, v92);
            }
            v113 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += i - v14;
            memcpy((void *)(v113 + v91), v14, i - v14);
            v115 = *((_QWORD *)this + 1);
            v114 = *((_QWORD *)this + 2);
            v116 = v115 + 4;
            if (v114)
            {
              v25 = v30;
              if (v116 >= *(_QWORD *)v114)
              {
                v117 = malloc_type_realloc(*(void **)(v114 + 16), (v115 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v118 = (unint64_t *)*((_QWORD *)this + 2);
                v118[2] = (unint64_t)v117;
                *v118 = (v115 + 259) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v117;
              }
            }
            else
            {
              str_alloc((string_t *)this, v116);
              v25 = v30;
            }
            v119 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 4;
            *(_DWORD *)(v119 + v115) = 1852399981;
            v121 = *((_QWORD *)this + 1);
            v120 = *((_QWORD *)this + 2);
            v122 = v121 + 20;
            if (v120)
            {
              if (v122 >= *(_QWORD *)v120)
              {
                v123 = malloc_type_realloc(*(void **)(v120 + 16), (v121 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v124 = (unint64_t *)*((_QWORD *)this + 2);
                v124[2] = (unint64_t)v123;
                *v124 = (v121 + 275) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v123;
              }
            }
            else
            {
              str_alloc((string_t *)this, v122);
            }
            v125 = itoa((char *)(*(_QWORD *)this + v121), v82);
            v126 = *((_QWORD *)this + 2);
            v127 = *((_QWORD *)this + 1) + v125;
            *((_QWORD *)this + 1) = v127;
            v128 = v127 + 1;
            if (v126)
            {
              if (v128 >= *(_QWORD *)v126)
              {
                v129 = malloc_type_realloc(*(void **)(v126 + 16), (v127 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                v130 = (_QWORD *)*((_QWORD *)this + 2);
                v130[2] = v129;
                *v130 = (v127 & 0xFFFFFFFFFFFFFF00) + 256;
                *(_QWORD *)this = v129;
              }
            }
            else
            {
              str_alloc((string_t *)this, v128);
            }
            v131 = *(_QWORD *)this;
            ++*((_QWORD *)this + 1);
            *(_BYTE *)(v131 + v127) = 40;
            if (v62)
              i = v62;
            v132 = *i;
            if (*i)
            {
              do
              {
                if (v132 == 41)
                  break;
                v133 = *++i;
                v132 = v133;
              }
              while (v133);
            }
          }
          else
          {
            if (strncmp((const char *)i + 1, "exture2D(hg_Texture", 0x13uLL))
            {
              do
                v47 = *++i;
              while ((ctype[2 * v47] & 0x40) != 0);
              goto LABEL_215;
            }
            v64 = i + 20;
            v63 = i[20];
            if ((v63 - 58) >= 0xFFFFFFF6)
            {
              v26 = 0;
              do
              {
                v26 = v63 + 10 * v26 - 48;
                v98 = *++v64;
                v63 = v98;
              }
              while ((v98 - 58) > 0xFFFFFFF5);
            }
            else
            {
              v64 = 0;
            }
            if (v305)
            {
              v99 = v26;
              if (((v305 >> v26) & 1) == 0 || v26 == -1)
                goto LABEL_143;
            }
            else if (v303 == -1 || v26 < v303 || (v99 = v26 - v303, v26 - v303 == -1))
            {
              do
LABEL_143:
                v112 = *++i;
              while ((ctype[2 * v112] & 0x40) != 0);
              goto LABEL_215;
            }
            v108 = *((_QWORD *)this + 1);
            v107 = *((_QWORD *)this + 2);
            v109 = v108 + i - v14;
            if (v107)
            {
              if (v109 >= *(_QWORD *)v107)
              {
                v301 = (v109 + 255) & 0xFFFFFFFFFFFFFF00;
                v110 = malloc_type_realloc(*(void **)(v107 + 16), v301, 0xCCCD1039uLL);
                v111 = (size_t *)*((_QWORD *)this + 2);
                v111[2] = (size_t)v110;
                *v111 = v301;
                *(_QWORD *)this = v110;
              }
            }
            else
            {
              str_alloc((string_t *)this, v109);
            }
            v158 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += i - v14;
            memcpy((void *)(v158 + v108), v14, i - v14);
            v160 = *((_QWORD *)this + 1);
            v159 = *((_QWORD *)this + 2);
            v161 = v160 + 4;
            if (v159)
            {
              v25 = v30;
              if (v161 >= *(_QWORD *)v159)
              {
                v162 = malloc_type_realloc(*(void **)(v159 + 16), (v160 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v163 = (unint64_t *)*((_QWORD *)this + 2);
                v163[2] = (unint64_t)v162;
                *v163 = (v160 + 259) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v162;
              }
            }
            else
            {
              str_alloc((string_t *)this, v161);
              v25 = v30;
            }
            v164 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 4;
            *(_DWORD *)(v164 + v160) = 1852399981;
            v166 = *((_QWORD *)this + 1);
            v165 = *((_QWORD *)this + 2);
            v167 = v166 + 20;
            if (v165)
            {
              if (v167 >= *(_QWORD *)v165)
              {
                v168 = malloc_type_realloc(*(void **)(v165 + 16), (v166 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v169 = (unint64_t *)*((_QWORD *)this + 2);
                v169[2] = (unint64_t)v168;
                *v169 = (v166 + 275) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v168;
              }
            }
            else
            {
              str_alloc((string_t *)this, v167);
            }
            v170 = itoa((char *)(*(_QWORD *)this + v166), v99);
            v171 = *((_QWORD *)this + 2);
            v172 = *((_QWORD *)this + 1) + v170;
            *((_QWORD *)this + 1) = v172;
            v173 = v172 + 1;
            if (v171)
            {
              if (v173 >= *(_QWORD *)v171)
              {
                v174 = malloc_type_realloc(*(void **)(v171 + 16), (v172 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                v175 = (_QWORD *)*((_QWORD *)this + 2);
                v175[2] = v174;
                *v175 = (v172 & 0xFFFFFFFFFFFFFF00) + 256;
                *(_QWORD *)this = v174;
              }
            }
            else
            {
              str_alloc((string_t *)this, v173);
            }
            v176 = *(_QWORD *)this;
            ++*((_QWORD *)this + 1);
            *(_BYTE *)(v176 + v172) = 40;
            if (v64)
              i = v64;
            v132 = *i;
            if (*i)
            {
              do
              {
                if (v132 == 41)
                  break;
                v177 = *++i;
                v132 = v177;
              }
              while (v177);
            }
          }
          v14 = i;
          if (!v132)
            return *(double *)&v17;
        }
      }
      if (!strncmp((const char *)i + 1, "ec4 main", 8uLL))
      {
        i += 9;
        if (a5)
        {
          v50 = *((_QWORD *)this + 1);
          v49 = *((_QWORD *)this + 2);
          v51 = v50 + i - v14;
          if (v49)
          {
            if (v51 >= *(_QWORD *)v49)
            {
              v52 = (v51 + 255) & 0xFFFFFFFFFFFFFF00;
              v53 = malloc_type_realloc(*(void **)(v49 + 16), v52, 0xCCCD1039uLL);
              v54 = (size_t *)*((_QWORD *)this + 2);
              v54[2] = (size_t)v53;
              *v54 = v52;
              *(_QWORD *)this = v53;
            }
          }
          else
          {
            str_alloc((string_t *)this, v51);
          }
          v83 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += i - v14;
          memcpy((void *)(v83 + v50), v14, i - v14);
          v84 = *((_DWORD *)a2 + 3);
          v86 = *((_QWORD *)this + 1);
          v85 = *((_QWORD *)this + 2);
          v87 = v86 + 20;
          if (v85)
          {
            if (v87 >= *(_QWORD *)v85)
            {
              v88 = malloc_type_realloc(*(void **)(v85 + 16), (v86 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v89 = (unint64_t *)*((_QWORD *)this + 2);
              v89[2] = (unint64_t)v88;
              *v89 = (v86 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v88;
            }
          }
          else
          {
            str_alloc((string_t *)this, v87);
          }
          v96 = (char *)(*(_QWORD *)this + v86);
          v97 = v84;
LABEL_121:
          *((_QWORD *)this + 1) += itoa(v96, v97);
          v14 = i;
        }
        goto LABEL_215;
      }
      if (strncmp((const char *)i + 1, "oid main", 8uLL))
      {
        do
          v46 = *++i;
        while ((ctype[2 * v46] & 0x40) != 0);
        goto LABEL_215;
      }
      if (a5)
      {
        v56 = *((_QWORD *)this + 1);
        v55 = *((_QWORD *)this + 2);
        v57 = v56 + i - v14;
        if (v55)
        {
          if (v57 >= *(_QWORD *)v55)
          {
            v58 = (v57 + 255) & 0xFFFFFFFFFFFFFF00;
            v59 = malloc_type_realloc(*(void **)(v55 + 16), v58, 0xCCCD1039uLL);
            v60 = (size_t *)*((_QWORD *)this + 2);
            v60[2] = (size_t)v59;
            *v60 = v58;
            *(_QWORD *)this = v59;
          }
        }
        else
        {
          str_alloc((string_t *)this, v57);
        }
        v101 = *(_QWORD *)this;
        *((_QWORD *)this + 1) += i - v14;
        memcpy((void *)(v101 + v56), v14, i - v14);
        if (v304)
        {
          v103 = *((_QWORD *)this + 1);
          v102 = *((_QWORD *)this + 2);
          v104 = v103 + 9;
          if (v102)
          {
            if (v104 >= *(_QWORD *)v102)
            {
              v105 = malloc_type_realloc(*(void **)(v102 + 16), (v103 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v106 = (unint64_t *)*((_QWORD *)this + 2);
              v106[2] = (unint64_t)v105;
              *v106 = (v103 + 264) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v105;
            }
          }
          else
          {
            str_alloc((string_t *)this, v104);
          }
          v134 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 9;
          v135 = v134 + v103;
          *(_QWORD *)v135 = *(_QWORD *)"defaultp ";
          *(_BYTE *)(v135 + 8) = 32;
        }
        v137 = *((_QWORD *)this + 1);
        v136 = *((_QWORD *)this + 2);
        v138 = v137 + 9;
        if (v136)
        {
          if (v138 >= *(_QWORD *)v136)
          {
            v139 = malloc_type_realloc(*(void **)(v136 + 16), (v137 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v140 = (unint64_t *)*((_QWORD *)this + 2);
            v140[2] = (unint64_t)v139;
            *v140 = (v137 + 264) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v139;
          }
        }
        else
        {
          str_alloc((string_t *)this, v138);
        }
        v141 = *(_QWORD *)this;
        *((_QWORD *)this + 1) += 9;
        v142 = v141 + v137;
        *(_QWORD *)v142 = *(_QWORD *)"vec4 main";
        *(_BYTE *)(v142 + 8) = 110;
        v143 = *((_DWORD *)a2 + 3);
        v145 = *((_QWORD *)this + 1);
        v144 = *((_QWORD *)this + 2);
        v146 = v145 + 20;
        if (v144)
        {
          if (v146 >= *(_QWORD *)v144)
          {
            v147 = malloc_type_realloc(*(void **)(v144 + 16), (v145 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v148 = (unint64_t *)*((_QWORD *)this + 2);
            v148[2] = (unint64_t)v147;
            *v148 = (v145 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v147;
          }
        }
        else
        {
          str_alloc((string_t *)this, v146);
        }
        *((_QWORD *)this + 1) += itoa((char *)(*(_QWORD *)this + v145), v143);
        i += 9;
        v25 = 1;
        v14 = i;
        goto LABEL_215;
      }
      v25 = 0xFFFFFFFFLL;
      if (!i[9])
        return *(double *)&v17;
    }
  }
  v304 = v15;
  if (*((_QWORD *)this + 1) == 33)
  {
    v18 = *((_QWORD *)this + 2);
    if (v18)
    {
      if (*(_QWORD *)v18 <= 0x7AuLL)
      {
        v19 = malloc_type_realloc(*(void **)(v18 + 16), 0x100uLL, 0xCCCD1039uLL);
        v20 = (_QWORD *)*((_QWORD *)this + 2);
        v20[2] = v19;
        *v20 = 256;
        *(_QWORD *)this = v19;
      }
    }
    else
    {
      str_alloc((string_t *)this, 122);
    }
    v21 = *(_QWORD *)this;
    *((_QWORD *)this + 1) += 89;
    v17 = *((_OWORD *)v14 + 1);
    *(_OWORD *)(v21 + 33) = *(_OWORD *)v14;
    v22 = *((_OWORD *)v14 + 2);
    v23 = *((_OWORD *)v14 + 3);
    v24 = *((_OWORD *)v14 + 4);
    *(_OWORD *)(v21 + 106) = *(_OWORD *)(v14 + 73);
    *(_OWORD *)(v21 + 97) = v24;
    *(_OWORD *)(v21 + 81) = v23;
    *(_OWORD *)(v21 + 65) = v22;
    *(_OWORD *)(v21 + 49) = v17;
  }
  v14 = (unsigned __int8 *)__s1 + 122;
  if (*((_BYTE *)__s1 + 122))
    goto LABEL_13;
  return *(double *)&v17;
}

void metal::write(metal *this, string_t *a2, const HGShaderBinding *a3, const HGLimits *a4, uint64_t a5, const HGLimits *a6, unsigned int a7, const char *a8, BOOL a9, unsigned int a10, int a11, BOOL a12)
{
  unsigned __int8 *v12;
  unsigned int v14;
  unsigned __int8 *v15;
  uint64_t v16;
  _DWORD *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  unsigned __int8 *v23;
  int64_t v24;
  size_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  void *v29;
  unint64_t *v30;
  int64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  void *v35;
  unint64_t *v36;
  int64_t v37;
  size_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  void *v42;
  unint64_t *v43;
  unsigned __int8 *v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  int v55;
  BOOL v56;
  int v57;
  BOOL v58;
  int v59;
  unsigned int v60;
  int64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  void *v65;
  unint64_t *v66;
  int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  int64_t v71;
  size_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  void *v76;
  unint64_t *v77;
  int64_t v78;
  size_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  void *v83;
  unint64_t *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  void *v90;
  unint64_t *v91;
  int64_t v92;
  size_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  void *v97;
  unint64_t *v98;
  int v99;
  int v100;
  int v102;
  int v104;
  int64_t v105;
  size_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  void *v110;
  unint64_t *v111;
  int64_t v112;
  size_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  void *v117;
  unint64_t *v118;
  uint64_t v119;
  signed int v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  void *v124;
  unint64_t *v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  size_t v129;
  void *v130;
  size_t *v131;
  uint64_t v132;
  unsigned int v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;
  void *v138;
  _QWORD *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  unint64_t v143;
  void *v144;
  _QWORD *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  void *v150;
  unint64_t *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  size_t v156;
  void *v157;
  size_t *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  void *v163;
  unint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  void *v168;
  unint64_t *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unint64_t v173;
  void *v174;
  unint64_t *v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unint64_t v180;
  void *v181;
  unint64_t *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  unint64_t v187;
  void *v188;
  unint64_t *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t v193;
  void *v194;
  unint64_t *v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  unint64_t v199;
  void *v200;
  _QWORD *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  unint64_t v205;
  void *v206;
  _QWORD *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  unint64_t v211;
  void *v212;
  unint64_t *v213;
  uint64_t v214;
  uint64_t v215;
  unint64_t v216;
  size_t v217;
  void *v218;
  unint64_t v219;
  size_t v220;
  void *v221;
  size_t *v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  unint64_t v227;
  void *v228;
  unint64_t *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  void *v234;
  unint64_t *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  unint64_t v240;
  void *v241;
  unint64_t *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unint64_t v246;
  void *v247;
  unint64_t *v248;
  uint64_t v249;
  uint64_t v250;
  void *v251;
  const void *v252;
  uint64_t v253;
  unsigned __int8 *v254;
  uint64_t v255;
  unsigned __int8 *v256;
  uint64_t v257;
  unsigned __int8 *v258;
  const char *v259;
  int v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  unint64_t v264;
  void *v265;
  unint64_t *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  unint64_t v270;
  void *v271;
  unint64_t *v272;
  int v273;
  int v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  unint64_t v278;
  void *v279;
  unint64_t *v280;
  unsigned __int8 *v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  size_t v285;
  uint64_t v286;
  uint64_t v287;
  unint64_t v288;
  void *v289;
  unint64_t *v290;
  int v291;
  int v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  unint64_t v296;
  void *v297;
  unint64_t *v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  unint64_t v305;
  void *v306;
  unint64_t *v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  unint64_t v313;
  size_t v314;
  void *v315;
  size_t *v316;
  uint64_t v317;
  uint64_t v318;
  int v319;
  int v320;
  int v321;
  int v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  unint64_t v326;
  unsigned int v327;
  void *v328;
  unint64_t *v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  unint64_t v334;
  void *v335;
  unint64_t *v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  unint64_t v340;
  void *v341;
  _QWORD *v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  unint64_t v346;
  void *v347;
  unint64_t *v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  unint64_t v352;
  void *v353;
  unint64_t *v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  unint64_t v358;
  void *v359;
  unint64_t *v360;
  uint64_t v361;
  uint64_t v362;
  _BYTE *v363;
  signed int v364;
  uint64_t v365;
  int v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  unint64_t v370;
  void *v371;
  unint64_t *v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  unint64_t v376;
  void *v377;
  unint64_t *v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  unint64_t v383;
  void *v384;
  unint64_t *v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  unint64_t v390;
  void *v391;
  unint64_t *v392;
  int v393;
  int v394;
  uint64_t v395;
  uint64_t v396;
  unint64_t v397;
  uint64_t v398;
  void *v399;
  unint64_t *v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  unint64_t v404;
  void *v405;
  unint64_t *v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  unint64_t v411;
  void *v412;
  unint64_t *v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  unint64_t v417;
  void *v418;
  unint64_t *v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  unint64_t v423;
  void *v424;
  unint64_t *v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  unint64_t v430;
  void *v431;
  unint64_t *v432;
  unsigned __int8 *v433;
  int v434;
  uint64_t v435;
  uint64_t v436;
  unint64_t v437;
  void *v438;
  unint64_t *v439;
  uint64_t v440;
  unsigned __int8 *v441;
  uint64_t v442;
  int v443;
  int v444;
  uint64_t v445;
  uint64_t v446;
  unint64_t v447;
  void *v448;
  unint64_t *v449;
  int v450;
  int v451;
  int v452;
  unsigned int v453;
  unsigned __int8 *v456;
  int v458;
  unsigned int v459;

  v458 = (int)a6;
  v459 = 0;
  v12 = (unsigned __int8 *)a5;
  v453 = a4;
  if (!strncmp((const char *)(a5 + 16), "//LEN=", 6uLL))
  {
    atox(v12 + 22, &v459);
    if (v459 >= 0x22)
    {
      v14 = 0;
      v456 = &v12[v459];
      v15 = v12 + 33;
      while (1)
      {
        v19 = 0;
        v20 = v15 + 1;
        do
        {
          v21 = v20;
          v22 = v15[v19++];
          ++v20;
        }
        while ((v22 - 33) > 0xFFFFFFDF);
        v18 = &v15[v19];
        v23 = &v15[v19 - 1];
        if ((_DWORD)v22 != 47 || *v18 != 47)
          break;
        v24 = v15 - v12;
        v25 = v15 - v12 + v19 - 1;
        v27 = *((_QWORD *)this + 1);
        v26 = *((_QWORD *)this + 2);
        v28 = v25 + v27;
        if (v26)
        {
          if (v28 >= *(_QWORD *)v26)
          {
            v29 = malloc_type_realloc(*(void **)(v26 + 16), (v27 + v24 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v30 = (unint64_t *)*((_QWORD *)this + 2);
            v30[2] = (unint64_t)v29;
            *v30 = (v27 + v24 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v29;
          }
        }
        else
        {
          str_alloc((string_t *)this, v28);
        }
        v54 = *(_QWORD *)this;
        *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v24 + v19 - 1;
        memcpy((void *)(v54 + v27), v12, v25);
        v55 = *v23;
        if (*v23)
          v56 = v55 == 10;
        else
          v56 = 1;
        if (!v56)
        {
          do
          {
            v57 = *++v23;
            v55 = v57;
            if (v57)
              v58 = v55 == 10;
            else
              v58 = 1;
          }
          while (!v58);
        }
        if (v55 == 10)
          v12 = v23 + 1;
        else
          v12 = v23;
LABEL_6:
        v18 = v12;
LABEL_7:
        v15 = v18;
        if (v18 >= v456)
          return;
      }
      if (!strncmp((const char *)&v15[v19 - 1], "[[ visible ]]", 0xDuLL))
      {
        v37 = v15 - v12;
        v38 = v15 - v12 + v19 - 1;
        v40 = *((_QWORD *)this + 1);
        v39 = *((_QWORD *)this + 2);
        v41 = v38 + v40;
        if (v39)
        {
          if (v41 >= *(_QWORD *)v39)
          {
            v42 = malloc_type_realloc(*(void **)(v39 + 16), (v40 + v37 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v43 = (unint64_t *)*((_QWORD *)this + 2);
            v43[2] = (unint64_t)v42;
            *v43 = (v40 + v37 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v42;
          }
        }
        else
        {
          str_alloc((string_t *)this, v41);
        }
        v47 = *(_QWORD *)this;
        *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v37 + v19 - 1;
        memcpy((void *)(v47 + v40), v12, v38);
        v48 = (uint64_t)&v15[v19 - 1];
        v49 = *v23;
        if (*v23)
        {
          do
          {
            if (v49 == 41)
              break;
            ++v21;
            v50 = *(unsigned __int8 *)++v48;
            v49 = v50;
          }
          while (v50);
        }
        v56 = v49 == 41;
        v51 = v49 == 41;
        if (v56)
          v18 = (unsigned __int8 *)(v48 + 1);
        else
          v18 = (unsigned __int8 *)v48;
        v52 = *v18;
        if (v52 != 59)
        {
          do
          {
            do
            {
              v53 = v52;
              v52 = v21[v51++];
            }
            while (v53 != 125);
          }
          while (v52 != 10);
          v18 = &v21[v51 - 2];
        }
        v12 = &v15[v19 - 1];
        goto LABEL_7;
      }
      if (v458)
      {
        if (!strncmp((const char *)&v15[v19 - 1], "fragment ", 9uLL))
        {
          v61 = v15 - v12;
          v63 = *((_QWORD *)this + 1);
          v62 = *((_QWORD *)this + 2);
          v64 = v15 - v12 + v19 - 1 + v63;
          if (v62)
          {
            if (v64 >= *(_QWORD *)v62)
            {
              v65 = malloc_type_realloc(*(void **)(v62 + 16), (v63 + v61 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v66 = (unint64_t *)*((_QWORD *)this + 2);
              v66[2] = (unint64_t)v65;
              *v66 = (v63 + v61 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v65;
            }
          }
          else
          {
            str_alloc((string_t *)this, v64);
          }
          v86 = *(_QWORD *)this;
          *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v61 + v19 - 1;
          memcpy((void *)(v86 + v63), v12, v15 - v12 + v19 - 1);
          v88 = *((_QWORD *)this + 1);
          v87 = *((_QWORD *)this + 2);
          v89 = v88 + 7;
          if (v87)
          {
            if (v89 >= *(_QWORD *)v87)
            {
              v90 = malloc_type_realloc(*(void **)(v87 + 16), (v88 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v91 = (unint64_t *)*((_QWORD *)this + 2);
              v91[2] = (unint64_t)v90;
              *v91 = (v88 + 262) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v90;
            }
          }
          else
          {
            str_alloc((string_t *)this, v89);
          }
          v12 = &v15[v19 + 8];
          v16 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 7;
          v17 = (_DWORD *)(v16 + v88);
          *(_DWORD *)((char *)v17 + 3) = 543385972;
          *v17 = 1952543859;
          goto LABEL_6;
        }
        if (strncmp((const char *)&v15[v19 - 1], "fragmentFunc", 0xCuLL))
        {
LABEL_26:
          v44 = &v15[v19];
          v45 = (uint64_t)&v15[v19 + 9];
          if (strncmp((const char *)&v15[v19 - 1], "hg_Texture", 0xAuLL))
          {
            if (strncmp((const char *)&v15[v19 - 1], "hg_Sampler", 0xAuLL))
            {
              if (!strncmp((const char *)&v15[v19 - 1], "hg_Params[", 0xAuLL))
              {
                v71 = v15 - v12;
                v72 = v15 - v12 + v19 + 9;
                v74 = *((_QWORD *)this + 1);
                v73 = *((_QWORD *)this + 2);
                v75 = v72 + v74;
                if (v73)
                {
                  if (v75 >= *(_QWORD *)v73)
                  {
                    v76 = malloc_type_realloc(*(void **)(v73 + 16), (v74 + v71 + v19 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v77 = (unint64_t *)*((_QWORD *)this + 2);
                    v77[2] = (unint64_t)v76;
                    *v77 = (v74 + v71 + v19 + 264) & 0xFFFFFFFFFFFFFF00;
                    *(_QWORD *)this = v76;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v75);
                }
                v318 = *(_QWORD *)this;
                *((_QWORD *)this + 1) += v71 + v19 + 9;
                memcpy((void *)(v318 + v74), v12, v72);
                v319 = v44[9];
                v12 = &v15[v19 + 9];
                if ((v319 - 58) >= 0xFFFFFFF6)
                {
                  v320 = 0;
                  v12 = &v15[v19 + 9];
                  do
                  {
                    v320 = v319 + 10 * v320 - 48;
                    v321 = *++v12;
                    v319 = v321;
                  }
                  while ((v321 - 58) > 0xFFFFFFF5);
                  v322 = *((_DWORD *)a2 + 4);
LABEL_395:
                  v14 = v322 + v320;
                }
              }
              else
              {
                if (strncmp((const char *)&v15[v19 - 1], "_texCoord", 9uLL))
                {
                  if ((v22 - 48) < 0xA || (ctype[2 * v22] & 0x40) == 0)
                    goto LABEL_7;
                  do
                    v46 = *++v23;
                  while ((ctype[2 * v46] & 0x40) != 0);
                  goto LABEL_110;
                }
                v112 = v15 - v12;
                v113 = v15 - v12 + v19 + 8;
                v115 = *((_QWORD *)this + 1);
                v114 = *((_QWORD *)this + 2);
                v116 = v113 + v115;
                if (v114)
                {
                  if (v116 >= *(_QWORD *)v114)
                  {
                    v117 = malloc_type_realloc(*(void **)(v114 + 16), (v115 + v112 + v19 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v118 = (unint64_t *)*((_QWORD *)this + 2);
                    v118[2] = (unint64_t)v117;
                    *v118 = (v115 + v112 + v19 + 263) & 0xFFFFFFFFFFFFFF00;
                    *(_QWORD *)this = v117;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v116);
                }
                v441 = &v15[v19];
                v442 = *(_QWORD *)this;
                *((_QWORD *)this + 1) += v112 + v19 + 8;
                memcpy((void *)(v442 + v115), v12, v113);
                v443 = v441[8];
                v12 = v441 + 8;
                if ((v443 - 58) >= 0xFFFFFFF6)
                {
                  v320 = 0;
                  v12 = v441 + 8;
                  do
                  {
                    v320 = v443 + 10 * v320 - 48;
                    v444 = *++v12;
                    v443 = v444;
                  }
                  while ((v444 - 58) > 0xFFFFFFF5);
                  v322 = *((_DWORD *)a2 + 2);
                  goto LABEL_395;
                }
              }
              v446 = *((_QWORD *)this + 1);
              v445 = *((_QWORD *)this + 2);
              v447 = v446 + 20;
              if (v445)
              {
                if (v447 >= *(_QWORD *)v445)
                {
                  v448 = malloc_type_realloc(*(void **)(v445 + 16), (v446 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v449 = (unint64_t *)*((_QWORD *)this + 2);
                  v449[2] = (unint64_t)v448;
                  *v449 = (v446 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v448;
                }
              }
              else
              {
                str_alloc((string_t *)this, v447);
              }
              *((_QWORD *)this + 1) += itoa((char *)(*(_QWORD *)this + v446), v14);
              goto LABEL_6;
            }
            v67 = v44[9];
            if ((v67 - 58) >= 0xFFFFFFF6)
            {
              v14 = 0;
              v68 = a7;
              do
              {
                v14 = v67 + 10 * v14 - 48;
                v99 = *(unsigned __int8 *)++v45;
                v67 = v99;
              }
              while ((v99 - 58) > 0xFFFFFFF5);
            }
            else
            {
              v45 = 0;
              v68 = a7;
            }
            v100 = v14 - v453;
            if (v14 < v453 || v453 == -1)
              v100 = -1;
            if (((v68 >> v14) & 1) != 0)
              v102 = v14;
            else
              v102 = -1;
            if (v68)
              v100 = v102;
            if (v100 == -1 && v458 == 0)
            {
              v452 = *((_DWORD *)a2 + 6);
              v105 = v15 - v12;
              v106 = v15 - v12 + v19 - 1;
              v108 = *((_QWORD *)this + 1);
              v107 = *((_QWORD *)this + 2);
              v109 = v106 + v108;
              if (v107)
              {
                if (v109 >= *(_QWORD *)v107)
                {
                  v110 = malloc_type_realloc(*(void **)(v107 + 16), (v108 + v105 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v111 = (unint64_t *)*((_QWORD *)this + 2);
                  v111[2] = (unint64_t)v110;
                  *v111 = (v108 + v105 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v110;
                }
              }
              else
              {
                str_alloc((string_t *)this, v109);
              }
              v373 = *(_QWORD *)this;
              *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v105 + v19 - 1;
              memcpy((void *)(v373 + v108), v12, v106);
              v375 = *((_QWORD *)this + 1);
              v374 = *((_QWORD *)this + 2);
              v376 = v375 + 10;
              if (v374)
              {
                if (v376 >= *(_QWORD *)v374)
                {
                  v377 = malloc_type_realloc(*(void **)(v374 + 16), (v375 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v378 = (unint64_t *)*((_QWORD *)this + 2);
                  v378[2] = (unint64_t)v377;
                  *v378 = (v375 + 265) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v377;
                }
              }
              else
              {
                str_alloc((string_t *)this, v376);
              }
              v386 = *(_QWORD *)this;
              *((_QWORD *)this + 1) += 10;
              v387 = v386 + v375;
              *(_QWORD *)v387 = *(_QWORD *)"hg_Sampler";
              *(_WORD *)(v387 + 8) = 29285;
              v389 = *((_QWORD *)this + 1);
              v388 = *((_QWORD *)this + 2);
              v390 = v389 + 20;
              if (v388)
              {
                if (v390 >= *(_QWORD *)v388)
                {
                  v391 = malloc_type_realloc(*(void **)(v388 + 16), (v389 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v392 = (unint64_t *)*((_QWORD *)this + 2);
                  v392[2] = (unint64_t)v391;
                  *v392 = (v389 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v391;
                }
              }
              else
              {
                str_alloc((string_t *)this, v390);
              }
              *((_QWORD *)this + 1) += itoa((char *)(*(_QWORD *)this + v389), v452 + v14);
              if (v45)
                v12 = (unsigned __int8 *)v45;
              else
                v12 = &v15[v19 - 1];
              v18 = v12;
              do
                v394 = *++v18;
              while ((ctype[2 * v394] & 0x40) != 0);
              goto LABEL_7;
            }
            do
              v104 = *++v23;
            while ((ctype[2 * v104] & 0x40) != 0);
LABEL_110:
            v18 = v23;
            goto LABEL_7;
          }
          v59 = v44[9];
          if ((v59 - 58) >= 0xFFFFFFF6)
          {
            v14 = 0;
            v60 = a7;
            do
            {
              v14 = v59 + 10 * v14 - 48;
              v69 = *(unsigned __int8 *)++v45;
              v59 = v69;
            }
            while ((v69 - 58) > 0xFFFFFFF5);
          }
          else
          {
            v45 = 0;
            v60 = a7;
          }
          if (v60)
          {
            v70 = v14;
            if (((v60 >> v14) & 1) == 0)
              goto LABEL_82;
          }
          else if (v453 == -1 || (v70 = v14 - v453, v14 < v453))
          {
LABEL_82:
            if (!v458)
            {
              v92 = v15 - v12;
              v93 = v15 - v12 + v19 - 1;
              v95 = *((_QWORD *)this + 1);
              v94 = *((_QWORD *)this + 2);
              v96 = v93 + v95;
              v451 = *((_DWORD *)a2 + 6);
              if (v94)
              {
                if (v96 >= *(_QWORD *)v94)
                {
                  v97 = malloc_type_realloc(*(void **)(v94 + 16), (v95 + v92 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v98 = (unint64_t *)*((_QWORD *)this + 2);
                  v98[2] = (unint64_t)v97;
                  *v98 = (v95 + v92 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v97;
                }
              }
              else
              {
                str_alloc((string_t *)this, v96);
              }
              v367 = *(_QWORD *)this;
              *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v92 + v19 - 1;
              memcpy((void *)(v367 + v95), v12, v93);
              v369 = *((_QWORD *)this + 1);
              v368 = *((_QWORD *)this + 2);
              v370 = v369 + 10;
              if (v368)
              {
                if (v370 >= *(_QWORD *)v368)
                {
                  v371 = malloc_type_realloc(*(void **)(v368 + 16), (v369 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v372 = (unint64_t *)*((_QWORD *)this + 2);
                  v372[2] = (unint64_t)v371;
                  *v372 = (v369 + 265) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v371;
                }
              }
              else
              {
                str_alloc((string_t *)this, v370);
              }
              v379 = *(_QWORD *)this;
              *((_QWORD *)this + 1) += 10;
              v380 = v379 + v369;
              *(_QWORD *)v380 = *(_QWORD *)"hg_Texture";
              *(_WORD *)(v380 + 8) = 25970;
              v382 = *((_QWORD *)this + 1);
              v381 = *((_QWORD *)this + 2);
              v383 = v382 + 20;
              if (v381)
              {
                if (v383 >= *(_QWORD *)v381)
                {
                  v384 = malloc_type_realloc(*(void **)(v381 + 16), (v382 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                  v385 = (unint64_t *)*((_QWORD *)this + 2);
                  v385[2] = (unint64_t)v384;
                  *v385 = (v382 + 275) & 0xFFFFFFFFFFFFFF00;
                  *(_QWORD *)this = v384;
                }
              }
              else
              {
                str_alloc((string_t *)this, v383);
              }
              *((_QWORD *)this + 1) += itoa((char *)(*(_QWORD *)this + v382), v451 + v14);
              if (v45)
                v12 = (unsigned __int8 *)v45;
              else
                v12 = &v15[v19 - 1];
              v18 = v12;
              do
                v393 = *++v18;
              while ((ctype[2 * v393] & 0x40) != 0);
              goto LABEL_7;
            }
            do
              v85 = *++v23;
            while ((ctype[2 * v85] & 0x40) != 0);
            goto LABEL_110;
          }
          if (v70 == -1)
            goto LABEL_82;
          v450 = v70;
          v78 = v15 - v12;
          v79 = v15 - v12 + v19 - 1;
          v81 = *((_QWORD *)this + 1);
          v80 = *((_QWORD *)this + 2);
          v82 = v79 + v81;
          if (v80)
          {
            if (v82 >= *(_QWORD *)v80)
            {
              v83 = malloc_type_realloc(*(void **)(v80 + 16), (v81 + v78 + v19 + 254) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v84 = (unint64_t *)*((_QWORD *)this + 2);
              v84[2] = (unint64_t)v83;
              *v84 = (v81 + v78 + v19 + 254) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v83;
            }
          }
          else
          {
            str_alloc((string_t *)this, v82);
          }
          v323 = *(_QWORD *)this;
          *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v78 + v19 - 1;
          memcpy((void *)(v323 + v81), v12, v79);
          v325 = *((_QWORD *)this + 1);
          v324 = *((_QWORD *)this + 2);
          v326 = v325 + 12;
          if (v324)
          {
            v327 = v450;
            if (v326 >= *(_QWORD *)v324)
            {
              v328 = malloc_type_realloc(*(void **)(v324 + 16), (v325 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v329 = (unint64_t *)*((_QWORD *)this + 2);
              v329[2] = (unint64_t)v328;
              *v329 = (v325 + 267) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v328;
            }
          }
          else
          {
            str_alloc((string_t *)this, v326);
            v327 = v450;
          }
          v330 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 12;
          v331 = v330 + v325;
          *(_QWORD *)v331 = *(_QWORD *)"fragmentFunc";
          *(_DWORD *)(v331 + 8) = 1668183366;
          v333 = *((_QWORD *)this + 1);
          v332 = *((_QWORD *)this + 2);
          v334 = v333 + 20;
          if (v332)
          {
            if (v334 >= *(_QWORD *)v332)
            {
              v335 = malloc_type_realloc(*(void **)(v332 + 16), (v333 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v336 = (unint64_t *)*((_QWORD *)this + 2);
              v336[2] = (unint64_t)v335;
              *v336 = (v333 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v335;
            }
          }
          else
          {
            str_alloc((string_t *)this, v334);
          }
          v337 = itoa((char *)(*(_QWORD *)this + v333), v327);
          v338 = *((_QWORD *)this + 2);
          v339 = *((_QWORD *)this + 1) + v337;
          *((_QWORD *)this + 1) = v339;
          v340 = v339 + 1;
          if (v338)
          {
            if (v340 >= *(_QWORD *)v338)
            {
              v341 = malloc_type_realloc(*(void **)(v338 + 16), (v339 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v342 = (_QWORD *)*((_QWORD *)this + 2);
              v342[2] = v341;
              *v342 = (v339 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)this = v341;
            }
          }
          else
          {
            str_alloc((string_t *)this, v340);
          }
          v343 = *(_QWORD *)this;
          ++*((_QWORD *)this + 1);
          *(_BYTE *)(v343 + v339) = 40;
          v345 = *((_QWORD *)this + 1);
          v344 = *((_QWORD *)this + 2);
          v346 = v345 + 4;
          if (v344)
          {
            if (v346 >= *(_QWORD *)v344)
            {
              v347 = malloc_type_realloc(*(void **)(v344 + 16), (v345 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v348 = (unint64_t *)*((_QWORD *)this + 2);
              v348[2] = (unint64_t)v347;
              *v348 = (v345 + 259) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v347;
            }
          }
          else
          {
            str_alloc((string_t *)this, v346);
          }
          v349 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 4;
          *(_DWORD *)(v349 + v345) = 1734439526;
          v351 = *((_QWORD *)this + 1);
          v350 = *((_QWORD *)this + 2);
          v352 = v351 + 2;
          if (v350)
          {
            if (v352 >= *(_QWORD *)v350)
            {
              v353 = malloc_type_realloc(*(void **)(v350 + 16), (v351 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v354 = (unint64_t *)*((_QWORD *)this + 2);
              v354[2] = (unint64_t)v353;
              *v354 = (v351 + 257) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v353;
            }
          }
          else
          {
            str_alloc((string_t *)this, v352);
          }
          v355 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 2;
          *(_WORD *)(v355 + v351) = 8236;
          v357 = *((_QWORD *)this + 1);
          v356 = *((_QWORD *)this + 2);
          v358 = v357 + 9;
          if (v356)
          {
            if (v358 >= *(_QWORD *)v356)
            {
              v359 = malloc_type_realloc(*(void **)(v356 + 16), (v357 + 264) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v360 = (unint64_t *)*((_QWORD *)this + 2);
              v360[2] = (unint64_t)v359;
              *v360 = (v357 + 264) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v359;
            }
          }
          else
          {
            str_alloc((string_t *)this, v358);
          }
          v361 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 9;
          v362 = v361 + v357;
          *(_QWORD *)v362 = *(_QWORD *)"hg_Params";
          *(_BYTE *)(v362 + 8) = 115;
          v363 = (_BYTE *)*((_QWORD *)this + 3);
          if (v327)
          {
            if (v327 >= (unint64_t)((uint64_t)(*((_QWORD *)this + 4) - (_QWORD)v363) >> 1))
            {
              v364 = 0;
              v395 = 2 * v327;
              v366 = v363[v395];
              if (!v363[v395])
              {
LABEL_379:
                if (v45)
                  v433 = (unsigned __int8 *)v45;
                else
                  v433 = v23;
                v12 = v433 + 1;
                v434 = *v433;
                if (v434)
                {
                  do
                  {
                    if (v434 == 41)
                      break;
                    v434 = *v12++;
                  }
                  while (*(v12 - 1));
                }
                v436 = *((_QWORD *)this + 1);
                v435 = *((_QWORD *)this + 2);
                v437 = v436 + 8;
                if (v435)
                {
                  if (v437 >= *(_QWORD *)v435)
                  {
                    v438 = malloc_type_realloc(*(void **)(v435 + 16), (v436 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v439 = (unint64_t *)*((_QWORD *)this + 2);
                    v439[2] = (unint64_t)v438;
                    *v439 = (v436 + 263) & 0xFFFFFFFFFFFFFF00;
                    *(_QWORD *)this = v438;
                  }
                }
                else
                {
                  str_alloc((string_t *)this, v437);
                }
                v440 = *(_QWORD *)this;
                *((_QWORD *)this + 1) += 8;
                *(_QWORD *)(v440 + v436) = 0x30726F6C6F632E29;
                goto LABEL_6;
              }
            }
            else
            {
              v364 = v363[2 * v327 - 1];
              v365 = 2 * v327;
              v366 = v363[v365];
              if (!v363[v365])
                goto LABEL_379;
            }
          }
          else
          {
            v364 = 0;
            v366 = *v363;
            if (!*v363)
              goto LABEL_379;
          }
          v396 = *((_QWORD *)this + 1);
          do
          {
            v397 = v396 + 2;
            v398 = *((_QWORD *)this + 2);
            if (v398)
            {
              if (v397 >= *(_QWORD *)v398)
              {
                v399 = malloc_type_realloc(*(void **)(v398 + 16), (v396 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v400 = (unint64_t *)*((_QWORD *)this + 2);
                v400[2] = (unint64_t)v399;
                *v400 = (v396 + 257) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v399;
              }
            }
            else
            {
              str_alloc((string_t *)this, v397);
            }
            v401 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 2;
            *(_WORD *)(v401 + v396) = 8236;
            v403 = *((_QWORD *)this + 1);
            v402 = *((_QWORD *)this + 2);
            v404 = v403 + 10;
            if (v402)
            {
              if (v404 >= *(_QWORD *)v402)
              {
                v405 = malloc_type_realloc(*(void **)(v402 + 16), (v403 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v406 = (unint64_t *)*((_QWORD *)this + 2);
                v406[2] = (unint64_t)v405;
                *v406 = (v403 + 265) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v405;
              }
            }
            else
            {
              str_alloc((string_t *)this, v404);
            }
            v407 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 10;
            v408 = v407 + v403;
            *(_QWORD *)v408 = *(_QWORD *)"hg_Texture";
            *(_WORD *)(v408 + 8) = 25970;
            v410 = *((_QWORD *)this + 1);
            v409 = *((_QWORD *)this + 2);
            v411 = v410 + 20;
            if (v409)
            {
              if (v411 >= *(_QWORD *)v409)
              {
                v412 = malloc_type_realloc(*(void **)(v409 + 16), (v410 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v413 = (unint64_t *)*((_QWORD *)this + 2);
                v413[2] = (unint64_t)v412;
                *v413 = (v410 + 275) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v412;
              }
            }
            else
            {
              str_alloc((string_t *)this, v411);
            }
            v414 = itoa((char *)(*(_QWORD *)this + v410), v364);
            v415 = *((_QWORD *)this + 2);
            v416 = *((_QWORD *)this + 1) + v414;
            *((_QWORD *)this + 1) = v416;
            v417 = v416 + 2;
            if (v415)
            {
              if (v417 >= *(_QWORD *)v415)
              {
                v418 = malloc_type_realloc(*(void **)(v415 + 16), (v416 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v419 = (unint64_t *)*((_QWORD *)this + 2);
                v419[2] = (unint64_t)v418;
                *v419 = (v416 + 257) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v418;
              }
            }
            else
            {
              str_alloc((string_t *)this, v417);
            }
            v420 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 2;
            *(_WORD *)(v420 + v416) = 8236;
            v422 = *((_QWORD *)this + 1);
            v421 = *((_QWORD *)this + 2);
            v423 = v422 + 10;
            if (v421)
            {
              if (v423 >= *(_QWORD *)v421)
              {
                v424 = malloc_type_realloc(*(void **)(v421 + 16), (v422 + 265) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v425 = (unint64_t *)*((_QWORD *)this + 2);
                v425[2] = (unint64_t)v424;
                *v425 = (v422 + 265) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v424;
              }
            }
            else
            {
              str_alloc((string_t *)this, v423);
            }
            v426 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 10;
            v427 = v426 + v422;
            *(_QWORD *)v427 = *(_QWORD *)"hg_Sampler";
            *(_WORD *)(v427 + 8) = 29285;
            v429 = *((_QWORD *)this + 1);
            v428 = *((_QWORD *)this + 2);
            v430 = v429 + 20;
            if (v428)
            {
              if (v430 >= *(_QWORD *)v428)
              {
                v431 = malloc_type_realloc(*(void **)(v428 + 16), (v429 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v432 = (unint64_t *)*((_QWORD *)this + 2);
                v432[2] = (unint64_t)v431;
                *v432 = (v429 + 275) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v431;
              }
            }
            else
            {
              str_alloc((string_t *)this, v430);
            }
            v396 = *((_QWORD *)this + 1) + itoa((char *)(*(_QWORD *)this + v429), v364);
            *((_QWORD *)this + 1) = v396;
            ++v364;
            --v366;
          }
          while (v366);
          goto LABEL_379;
        }
        v31 = v15 - v12;
        v33 = *((_QWORD *)this + 1);
        v32 = *((_QWORD *)this + 2);
        v34 = v15 - v12 + v19 + 11 + v33;
        if (v32)
        {
          if (v34 >= *(_QWORD *)v32)
          {
            v35 = malloc_type_realloc(*(void **)(v32 + 16), (v33 + v31 + v19 + 266) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v36 = (unint64_t *)*((_QWORD *)this + 2);
            v36[2] = (unint64_t)v35;
            *v36 = (v33 + v31 + v19 + 266) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v35;
          }
        }
        else
        {
          str_alloc((string_t *)this, v34);
        }
        v119 = *(_QWORD *)this;
        *((_QWORD *)this + 1) += v31 + v19 + 11;
        memcpy((void *)(v119 + v33), v12, v15 - v12 + v19 + 11);
        v120 = *((_DWORD *)a2 + 3);
        v122 = *((_QWORD *)this + 1);
        v121 = *((_QWORD *)this + 2);
        v123 = v122 + 20;
        if (v121)
        {
          if (v123 >= *(_QWORD *)v121)
          {
            v124 = malloc_type_realloc(*(void **)(v121 + 16), (v122 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v125 = (unint64_t *)*((_QWORD *)this + 2);
            v125[2] = (unint64_t)v124;
            *v125 = (v122 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v124;
          }
        }
        else
        {
          str_alloc((string_t *)this, v123);
        }
        v18 = &v15[v19 + 11];
        *((_QWORD *)this + 1) += itoa((char *)(*(_QWORD *)this + v122), v120);
        v12 = v18;
        if (*v18 != 40)
          goto LABEL_7;
      }
      else
      {
        if (strncmp((const char *)&v15[v19 - 1], "fragmentFunc", 0xCuLL))
          goto LABEL_26;
        v18 = &v15[v19 + 11];
        if (*v18 != 40)
          goto LABEL_7;
      }
      v127 = *((_QWORD *)this + 1);
      v126 = *((_QWORD *)this + 2);
      v128 = v127 + v18 - v12;
      if (v126)
      {
        if (v128 >= *(_QWORD *)v126)
        {
          v129 = (v128 + 255) & 0xFFFFFFFFFFFFFF00;
          v130 = malloc_type_realloc(*(void **)(v126 + 16), v129, 0xCCCD1039uLL);
          v131 = (size_t *)*((_QWORD *)this + 2);
          v131[2] = (size_t)v130;
          *v131 = v129;
          *(_QWORD *)this = v130;
        }
      }
      else
      {
        str_alloc((string_t *)this, v128);
      }
      v132 = *(_QWORD *)this;
      *((_QWORD *)this + 1) += v18 - v12;
      memcpy((void *)(v132 + v127), v12, v18 - v12);
      v12 = &v15[v19 + 12];
      if (*v12 == 41)
      {
LABEL_128:
        if ((v458 & 1) != 0 || !*((_BYTE *)a3 + 40))
        {
LABEL_281:
          v312 = *((_QWORD *)this + 1);
          v311 = *((_QWORD *)this + 2);
          v313 = v12 - v18 + v312;
          if (v311)
          {
            if (v313 >= *(_QWORD *)v311)
            {
              v314 = (v313 + 255) & 0xFFFFFFFFFFFFFF00;
              v315 = malloc_type_realloc(*(void **)(v311 + 16), v314, 0xCCCD1039uLL);
              v316 = (size_t *)*((_QWORD *)this + 2);
              v316[2] = (size_t)v315;
              *v316 = v314;
              *(_QWORD *)this = v315;
            }
          }
          else
          {
            str_alloc((string_t *)this, v313);
          }
          v317 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += v12 - v18;
          memcpy((void *)(v317 + v312), v18, v12 - v18);
          goto LABEL_6;
        }
        v133 = 0;
        while (1)
        {
          v136 = *((_QWORD *)this + 1);
          v135 = *((_QWORD *)this + 2);
          v137 = v136 + 1;
          if (v135)
          {
            if (v137 >= *(_QWORD *)v135)
            {
              v138 = malloc_type_realloc(*(void **)(v135 + 16), (v136 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v139 = (_QWORD *)*((_QWORD *)this + 2);
              v139[2] = v138;
              *v139 = (v136 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)this = v138;
            }
          }
          else
          {
            str_alloc((string_t *)this, v137);
          }
          v140 = *(_QWORD *)this;
          ++*((_QWORD *)this + 1);
          *(_BYTE *)(v140 + v136) = 44;
          v142 = *((_QWORD *)this + 1);
          v141 = *((_QWORD *)this + 2);
          v143 = v142 + 1;
          if (v141)
          {
            if (v143 >= *(_QWORD *)v141)
            {
              v144 = malloc_type_realloc(*(void **)(v141 + 16), (v142 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v145 = (_QWORD *)*((_QWORD *)this + 2);
              v145[2] = v144;
              *v145 = (v142 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)this = v144;
            }
          }
          else
          {
            str_alloc((string_t *)this, v143);
          }
          v146 = *(_QWORD *)this;
          ++*((_QWORD *)this + 1);
          *(_BYTE *)(v146 + v142) = 10;
          v148 = *((_QWORD *)this + 1);
          v147 = *((_QWORD *)this + 2);
          v149 = v148 + 4;
          if (v147)
          {
            if (v149 >= *(_QWORD *)v147)
            {
              v150 = malloc_type_realloc(*(void **)(v147 + 16), (v148 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v151 = (unint64_t *)*((_QWORD *)this + 2);
              v151[2] = (unint64_t)v150;
              *v151 = (v148 + 259) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v150;
            }
          }
          else
          {
            str_alloc((string_t *)this, v149);
          }
          v152 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 4;
          *(_DWORD *)(v152 + v148) = 538976288;
          v154 = *((_QWORD *)this + 1);
          v153 = *((_QWORD *)this + 2);
          v155 = v154 + v12 - v18;
          if (v153)
          {
            if (v155 >= *(_QWORD *)v153)
            {
              v156 = (v155 + 255) & 0xFFFFFFFFFFFFFF00;
              v157 = malloc_type_realloc(*(void **)(v153 + 16), v156, 0xCCCD1039uLL);
              v158 = (size_t *)*((_QWORD *)this + 2);
              v158[2] = (size_t)v157;
              *v158 = v156;
              *(_QWORD *)this = v157;
            }
          }
          else
          {
            str_alloc((string_t *)this, v155);
          }
          v159 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += v12 - v18;
          memcpy((void *)(v159 + v154), v18, v12 - v18);
          if (v133 <= 7 && ((*((_DWORD *)a3 + 4) >> v133) & 1) != 0)
          {
            v161 = *((_QWORD *)this + 1);
            v160 = *((_QWORD *)this + 2);
            v162 = v161 + 28;
            if (v160)
            {
              if (v162 >= *(_QWORD *)v160)
              {
                v163 = malloc_type_realloc(*(void **)(v160 + 16), (v161 + 283) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v164 = (unint64_t *)*((_QWORD *)this + 2);
                v164[2] = (unint64_t)v163;
                *v164 = (v161 + 283) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v163;
              }
            }
            else
            {
              str_alloc((string_t *)this, v162);
            }
            v176 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 28;
            qmemcpy((void *)(v176 + v161), "texture2d< half > hg_Texture", 28);
            v172 = *((_QWORD *)this + 1);
            v171 = *((_QWORD *)this + 2);
            v173 = v172 + 20;
            if (!v171)
              goto LABEL_163;
          }
          else
          {
            v166 = *((_QWORD *)this + 1);
            v165 = *((_QWORD *)this + 2);
            v167 = v166 + 29;
            if (v165)
            {
              if (v167 >= *(_QWORD *)v165)
              {
                v168 = malloc_type_realloc(*(void **)(v165 + 16), (v166 + 284) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v169 = (unint64_t *)*((_QWORD *)this + 2);
                v169[2] = (unint64_t)v168;
                *v169 = (v166 + 284) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v168;
              }
            }
            else
            {
              str_alloc((string_t *)this, v167);
            }
            v170 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += 29;
            qmemcpy((void *)(v170 + v166), "texture2d< float > hg_Texture", 29);
            v172 = *((_QWORD *)this + 1);
            v171 = *((_QWORD *)this + 2);
            v173 = v172 + 20;
            if (!v171)
            {
LABEL_163:
              str_alloc((string_t *)this, v173);
              goto LABEL_164;
            }
          }
          if (v173 >= *(_QWORD *)v171)
          {
            v174 = malloc_type_realloc(*(void **)(v171 + 16), (v172 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v175 = (unint64_t *)*((_QWORD *)this + 2);
            v175[2] = (unint64_t)v174;
            *v175 = (v172 + 275) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v174;
          }
LABEL_164:
          v177 = itoa((char *)(*(_QWORD *)this + v172), v133);
          v178 = *((_QWORD *)this + 2);
          v179 = *((_QWORD *)this + 1) + v177;
          *((_QWORD *)this + 1) = v179;
          v180 = v179 + 12;
          if (v178)
          {
            if (v180 >= *(_QWORD *)v178)
            {
              v181 = malloc_type_realloc(*(void **)(v178 + 16), (v179 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v182 = (unint64_t *)*((_QWORD *)this + 2);
              v182[2] = (unint64_t)v181;
              *v182 = (v179 + 267) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v181;
            }
          }
          else
          {
            str_alloc((string_t *)this, v180);
          }
          v183 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 12;
          v184 = v183 + v179;
          *(_QWORD *)v184 = *(_QWORD *)" [[ texture(";
          *(_DWORD *)(v184 + 8) = 677737077;
          v186 = *((_QWORD *)this + 1);
          v185 = *((_QWORD *)this + 2);
          v187 = v186 + 20;
          if (v185)
          {
            if (v187 >= *(_QWORD *)v185)
            {
              v188 = malloc_type_realloc(*(void **)(v185 + 16), (v186 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v189 = (unint64_t *)*((_QWORD *)this + 2);
              v189[2] = (unint64_t)v188;
              *v189 = (v186 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v188;
            }
          }
          else
          {
            str_alloc((string_t *)this, v187);
          }
          v190 = itoa((char *)(*(_QWORD *)this + v186), v133);
          v191 = *((_QWORD *)this + 2);
          v192 = *((_QWORD *)this + 1) + v190;
          *((_QWORD *)this + 1) = v192;
          v193 = v192 + 4;
          if (v191)
          {
            if (v193 >= *(_QWORD *)v191)
            {
              v194 = malloc_type_realloc(*(void **)(v191 + 16), (v192 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v195 = (unint64_t *)*((_QWORD *)this + 2);
              v195[2] = (unint64_t)v194;
              *v195 = (v192 + 259) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v194;
            }
          }
          else
          {
            str_alloc((string_t *)this, v193);
          }
          v196 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 4;
          *(_DWORD *)(v196 + v192) = 1566384169;
          v198 = *((_QWORD *)this + 1);
          v197 = *((_QWORD *)this + 2);
          v199 = v198 + 1;
          if (v197)
          {
            if (v199 >= *(_QWORD *)v197)
            {
              v200 = malloc_type_realloc(*(void **)(v197 + 16), (v198 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v201 = (_QWORD *)*((_QWORD *)this + 2);
              v201[2] = v200;
              *v201 = (v198 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)this = v200;
            }
          }
          else
          {
            str_alloc((string_t *)this, v199);
          }
          v202 = *(_QWORD *)this;
          ++*((_QWORD *)this + 1);
          *(_BYTE *)(v202 + v198) = 44;
          v204 = *((_QWORD *)this + 1);
          v203 = *((_QWORD *)this + 2);
          v205 = v204 + 1;
          if (v203)
          {
            if (v205 >= *(_QWORD *)v203)
            {
              v206 = malloc_type_realloc(*(void **)(v203 + 16), (v204 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
              v207 = (_QWORD *)*((_QWORD *)this + 2);
              v207[2] = v206;
              *v207 = (v204 & 0xFFFFFFFFFFFFFF00) + 256;
              *(_QWORD *)this = v206;
            }
          }
          else
          {
            str_alloc((string_t *)this, v205);
          }
          v208 = *(_QWORD *)this;
          ++*((_QWORD *)this + 1);
          *(_BYTE *)(v208 + v204) = 10;
          v210 = *((_QWORD *)this + 1);
          v209 = *((_QWORD *)this + 2);
          v211 = v210 + 4;
          if (v209)
          {
            if (v211 >= *(_QWORD *)v209)
            {
              v212 = malloc_type_realloc(*(void **)(v209 + 16), (v210 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v213 = (unint64_t *)*((_QWORD *)this + 2);
              v213[2] = (unint64_t)v212;
              *v213 = (v210 + 259) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v212;
            }
          }
          else
          {
            str_alloc((string_t *)this, v211);
          }
          v214 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 4;
          *(_DWORD *)(v214 + v210) = 538976288;
          v216 = *((_QWORD *)this + 1);
          v215 = *((_QWORD *)this + 2);
          if (v215)
          {
            v217 = *(_QWORD *)v215;
            if (v216 >= *(_QWORD *)v215)
            {
              v217 = (v216 + 255) & 0xFFFFFFFFFFFFFF00;
              v218 = malloc_type_realloc(*(void **)(v215 + 16), v217, 0xCCCD1039uLL);
              v216 = *((_QWORD *)this + 1);
              v215 = *((_QWORD *)this + 2);
              *(_QWORD *)(v215 + 16) = v218;
              *(_QWORD *)v215 = v217;
              *(_QWORD *)this = v218;
            }
            v219 = v216 + 18;
            if (v216 + 18 < v217)
              goto LABEL_197;
LABEL_195:
            v220 = (v219 + 255) & 0xFFFFFFFFFFFFFF00;
            v221 = malloc_type_realloc(*(void **)(v215 + 16), v220, 0xCCCD1039uLL);
            v222 = (size_t *)*((_QWORD *)this + 2);
            v222[2] = (size_t)v221;
            *v222 = v220;
            *(_QWORD *)this = v221;
            goto LABEL_197;
          }
          str_alloc((string_t *)this, *((_QWORD *)this + 1));
          v216 = *((_QWORD *)this + 1);
          v215 = *((_QWORD *)this + 2);
          v219 = v216 + 18;
          if (!v215)
          {
            str_alloc((string_t *)this, v219);
            goto LABEL_197;
          }
          if (v219 >= *(_QWORD *)v215)
            goto LABEL_195;
LABEL_197:
          v223 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 18;
          v224 = v223 + v216;
          *(_OWORD *)v224 = *(_OWORD *)"sampler hg_Sampler";
          *(_WORD *)(v224 + 16) = 29285;
          v226 = *((_QWORD *)this + 1);
          v225 = *((_QWORD *)this + 2);
          v227 = v226 + 20;
          if (v225)
          {
            if (v227 >= *(_QWORD *)v225)
            {
              v228 = malloc_type_realloc(*(void **)(v225 + 16), (v226 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v229 = (unint64_t *)*((_QWORD *)this + 2);
              v229[2] = (unint64_t)v228;
              *v229 = (v226 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v228;
            }
          }
          else
          {
            str_alloc((string_t *)this, v227);
          }
          v230 = itoa((char *)(*(_QWORD *)this + v226), v133);
          v231 = *((_QWORD *)this + 2);
          v232 = *((_QWORD *)this + 1) + v230;
          *((_QWORD *)this + 1) = v232;
          v233 = v232 + 12;
          if (v231)
          {
            if (v233 >= *(_QWORD *)v231)
            {
              v234 = malloc_type_realloc(*(void **)(v231 + 16), (v232 + 267) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v235 = (unint64_t *)*((_QWORD *)this + 2);
              v235[2] = (unint64_t)v234;
              *v235 = (v232 + 267) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v234;
            }
          }
          else
          {
            str_alloc((string_t *)this, v233);
          }
          v236 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 12;
          v237 = v236 + v232;
          *(_QWORD *)v237 = *(_QWORD *)" [[ sampler(";
          *(_DWORD *)(v237 + 8) = 678585708;
          v239 = *((_QWORD *)this + 1);
          v238 = *((_QWORD *)this + 2);
          v240 = v239 + 20;
          if (v238)
          {
            if (v240 >= *(_QWORD *)v238)
            {
              v241 = malloc_type_realloc(*(void **)(v238 + 16), (v239 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v242 = (unint64_t *)*((_QWORD *)this + 2);
              v242[2] = (unint64_t)v241;
              *v242 = (v239 + 275) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v241;
            }
          }
          else
          {
            str_alloc((string_t *)this, v240);
          }
          v243 = itoa((char *)(*(_QWORD *)this + v239), v133);
          v244 = *((_QWORD *)this + 2);
          v245 = *((_QWORD *)this + 1) + v243;
          *((_QWORD *)this + 1) = v245;
          v246 = v245 + 4;
          if (v244)
          {
            if (v246 >= *(_QWORD *)v244)
            {
              v247 = malloc_type_realloc(*(void **)(v244 + 16), (v245 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v248 = (unint64_t *)*((_QWORD *)this + 2);
              v248[2] = (unint64_t)v247;
              *v248 = (v245 + 259) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v247;
            }
          }
          else
          {
            str_alloc((string_t *)this, v246);
          }
          v134 = *(_QWORD *)this;
          *((_QWORD *)this + 1) += 4;
          *(_DWORD *)(v134 + v245) = 1566384169;
          ++v133;
          v18 = v12;
          if (v133 >= *((unsigned __int8 *)a3 + 40))
          {
            v18 = v12;
            goto LABEL_281;
          }
        }
      }
      v249 = (uint64_t)&v15[v19 + 12];
      while (1)
      {
        v253 = 0;
        v254 = (unsigned __int8 *)(v249 + 12);
        v255 = v249 + 1;
        do
        {
          v256 = v254;
          v257 = *(unsigned __int8 *)(v249 + v253);
          v258 = (unsigned __int8 *)v255;
          ++v253;
          ++v254;
          ++v255;
        }
        while ((v257 - 33) > 0xFFFFFFDF);
        v12 = (unsigned __int8 *)(v249 + v253);
        v259 = (const char *)(v249 + v253 - 1);
        if (!strncmp(v259, "[[ stage_in", 0xBuLL))
          break;
        if (!strncmp((const char *)(v249 + v253 - 1), "[[ buffer(", 0xAuLL))
        {
          v267 = v249 - (_QWORD)v18;
          v269 = *((_QWORD *)this + 1);
          v268 = *((_QWORD *)this + 2);
          v270 = v249 - (_QWORD)v18 + v253 - 2 + v269;
          if (v268)
          {
            if (v270 >= *(_QWORD *)v268)
            {
              v271 = malloc_type_realloc(*(void **)(v268 + 16), (v269 + v267 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
              v272 = (unint64_t *)*((_QWORD *)this + 2);
              v272[2] = (unint64_t)v271;
              *v272 = (v269 + v267 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
              *(_QWORD *)this = v271;
            }
          }
          else
          {
            str_alloc((string_t *)this, v270);
          }
          v299 = v249 + v253 - 2;
          v300 = *(_QWORD *)this;
          *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v267 + v253 - 2;
          memcpy((void *)(v300 + v269), v18, v249 - (_QWORD)v18 + v253 - 2);
          v301 = 0;
          v302 = v249 + v253;
          while (*(_BYTE *)(v302 + v301 - 2) != 93 || *(_BYTE *)(v302 + v301 - 1) != 93)
            ++v301;
          v18 = (unsigned __int8 *)(v249 + v253 + v301);
          if ((v458 & 1) == 0)
          {
            v285 = v301 + 2;
            v304 = *((_QWORD *)this + 1);
            v303 = *((_QWORD *)this + 2);
            v305 = v301 + 2 + v304;
            if (v303)
            {
              if (v305 >= *(_QWORD *)v303)
              {
                v306 = malloc_type_realloc(*(void **)(v303 + 16), (v304 + v301 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v307 = (unint64_t *)*((_QWORD *)this + 2);
                v307[2] = (unint64_t)v306;
                *v307 = (v304 + v301 + 257) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v306;
              }
            }
            else
            {
              str_alloc((string_t *)this, v305);
            }
            v308 = *(_QWORD *)this;
            *((_QWORD *)this + 1) += v301 + 2;
            v251 = (void *)(v308 + v304);
            v252 = (const void *)v299;
            goto LABEL_215;
          }
          goto LABEL_216;
        }
        if (!strncmp((const char *)(v249 + v253 - 1), "[[ texture(", 0xBuLL))
        {
          v273 = v12[10];
          if ((v273 - 58) >= 0xFFFFFFF6)
          {
            v14 = 0;
            do
            {
              v14 = v273 + 10 * v14 - 48;
              v274 = *v256++;
              v273 = v274;
            }
            while ((v274 - 58) > 0xFFFFFFF5);
          }
          if (v458)
          {
            v275 = v249 - (_QWORD)v18;
            v277 = *((_QWORD *)this + 1);
            v276 = *((_QWORD *)this + 2);
            v278 = v275 + v253 - 2 + v277;
            if (v276)
            {
              if (v278 >= *(_QWORD *)v276)
              {
                v279 = malloc_type_realloc(*(void **)(v276 + 16), (v277 + v275 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v280 = (unint64_t *)*((_QWORD *)this + 2);
                v280[2] = (unint64_t)v279;
                *v280 = (v277 + v275 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v279;
              }
            }
            else
            {
              str_alloc((string_t *)this, v278);
            }
            v309 = *(_QWORD *)this;
            *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v275 + v253 - 2;
            memcpy((void *)(v309 + v277), v18, v275 + v253 - 2);
          }
          while (*(v258 - 2) != 93 || *(v258 - 1) != 93)
            ++v258;
        }
        else
        {
          if (strncmp((const char *)(v249 + v253 - 1), "[[ sampler(", 0xBuLL))
          {
            if ((v257 - 48) >= 0xA && (ctype[2 * v257] & 0x40) != 0)
            {
              do
                v260 = *(unsigned __int8 *)++v259;
              while ((ctype[2 * v260] & 0x40) != 0);
              v12 = (unsigned __int8 *)v259;
            }
            goto LABEL_217;
          }
          v291 = v12[10];
          if ((v291 - 58) >= 0xFFFFFFF6)
          {
            v14 = 0;
            do
            {
              v14 = v291 + 10 * v14 - 48;
              v292 = *v256++;
              v291 = v292;
            }
            while ((v292 - 58) > 0xFFFFFFF5);
          }
          if (v458)
          {
            v293 = v249 - (_QWORD)v18;
            v295 = *((_QWORD *)this + 1);
            v294 = *((_QWORD *)this + 2);
            v296 = v293 + v253 - 2 + v295;
            if (v294)
            {
              if (v296 >= *(_QWORD *)v294)
              {
                v297 = malloc_type_realloc(*(void **)(v294 + 16), (v295 + v293 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                v298 = (unint64_t *)*((_QWORD *)this + 2);
                v298[2] = (unint64_t)v297;
                *v298 = (v295 + v293 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
                *(_QWORD *)this = v297;
              }
            }
            else
            {
              str_alloc((string_t *)this, v296);
            }
            v310 = *(_QWORD *)this;
            *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v293 + v253 - 2;
            memcpy((void *)(v310 + v295), v18, v293 + v253 - 2);
          }
          while (*(v258 - 2) != 93 || *(v258 - 1) != 93)
            ++v258;
        }
        v18 = v258;
        v12 = v258;
LABEL_217:
        v249 = (uint64_t)v12;
        if (*v12 == 41)
          goto LABEL_128;
      }
      v261 = v249 - (_QWORD)v18;
      v263 = *((_QWORD *)this + 1);
      v262 = *((_QWORD *)this + 2);
      v264 = v249 - (_QWORD)v18 + v253 - 2 + v263;
      if (v262)
      {
        if (v264 >= *(_QWORD *)v262)
        {
          v265 = malloc_type_realloc(*(void **)(v262 + 16), (v263 + v261 + v253 + 253) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
          v266 = (unint64_t *)*((_QWORD *)this + 2);
          v266[2] = (unint64_t)v265;
          *v266 = (v263 + v261 + v253 + 253) & 0xFFFFFFFFFFFFFF00;
          *(_QWORD *)this = v265;
        }
      }
      else
      {
        str_alloc((string_t *)this, v264);
      }
      v281 = v12 - 2;
      v282 = *(_QWORD *)this;
      *((_QWORD *)this + 1) = *((_QWORD *)this + 1) + v261 + v253 - 2;
      memcpy((void *)(v282 + v263), v18, v249 - (_QWORD)v18 + v253 - 2);
      v283 = 0;
      v284 = v249 + v253;
      while (*(_BYTE *)(v284 + v283 - 2) != 93 || *(_BYTE *)(v284 + v283 - 1) != 93)
        ++v283;
      v18 = (unsigned __int8 *)(v249 + v253 + v283);
      if ((v458 & 1) == 0)
      {
        v285 = v283 + 2;
        v287 = *((_QWORD *)this + 1);
        v286 = *((_QWORD *)this + 2);
        v288 = v283 + 2 + v287;
        if (v286)
        {
          if (v288 >= *(_QWORD *)v286)
          {
            v289 = malloc_type_realloc(*(void **)(v286 + 16), (v287 + v283 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
            v290 = (unint64_t *)*((_QWORD *)this + 2);
            v290[2] = (unint64_t)v289;
            *v290 = (v287 + v283 + 257) & 0xFFFFFFFFFFFFFF00;
            *(_QWORD *)this = v289;
          }
        }
        else
        {
          str_alloc((string_t *)this, v288);
        }
        v250 = *(_QWORD *)this;
        *((_QWORD *)this + 1) += v283 + 2;
        v251 = (void *)(v250 + v287);
        v252 = v281;
LABEL_215:
        memcpy(v251, v252, v285);
      }
LABEL_216:
      v12 = v18;
      goto LABEL_217;
    }
  }
}

uint64_t HGString::Digest::pop(HGString::Digest *this, HGShaderBinding *a2, const HGString::Digest *a3, const HGString::Digest *a4, int a5, const HGLimits *a6)
{
  unsigned int v6;
  int v7;
  BOOL v8;
  unsigned int v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  int8x8_t v26;
  unsigned int v27;
  __int16 v28;
  __int16 v29;
  char v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  int8x8_t v35;
  uint8x8_t v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  unsigned int v39;
  int16x8_t v40;
  unsigned __int16 v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;

  v6 = *((_DWORD *)a3 + 4);
  v7 = v6 & 0xFFFFF;
  if ((v6 & 0xFFFFF) - 394305 > 0xFFFFFECE)
  {
    v9 = *((_DWORD *)a4 + 4);
    if ((v9 & 0xFFFFF) - 394305 >= 0xFFFFFECF)
      goto LABEL_18;
    goto LABEL_12;
  }
  v8 = v7 != 396048 && (v7 - 394768) >= 0x11;
  if (v8)
  {
    if (*((_DWORD *)a4 + 4))
    {
      *((_DWORD *)a2 + 8) = 0;
      *(_OWORD *)a2 = 0u;
      *((_OWORD *)a2 + 1) = 0u;
      v11 = *(_OWORD *)a4;
      v12 = *((_OWORD *)a4 + 1);
      v13 = *((_OWORD *)a4 + 3);
      *((_OWORD *)this + 2) = *((_OWORD *)a4 + 2);
      *((_OWORD *)this + 3) = v13;
      *(_OWORD *)this = v11;
      *((_OWORD *)this + 1) = v12;
      return *((unsigned __int8 *)a4 + 58);
    }
    return 0xFFFFFFFFLL;
  }
  if ((v7 - 394785) >= 0xFFFFFFEF)
  {
    v9 = *((_DWORD *)a4 + 4);
    if ((v9 & 0xFFFFF) - 394785 >= 0xFFFFFFEF)
      goto LABEL_18;
LABEL_12:
    if (!*((_DWORD *)a4 + 4))
      return *((unsigned __int8 *)a3 + 58);
    return 0xFFFFFFFFLL;
  }
  if (v7 != 396048)
    goto LABEL_12;
  v9 = *((_DWORD *)a4 + 4);
  if ((v9 & 0xFFFFF) != 0x60B10)
  {
    if (!v9)
      return *((unsigned __int8 *)a3 + 58);
    return 0xFFFFFFFFLL;
  }
LABEL_18:
  v15 = *((_DWORD *)a3 + 5);
  v16 = *((_DWORD *)a4 + 5);
  if ((v16 & v15 & 0x8000000) != 0)
    return 0xFFFFFFFFLL;
  if (!*((_BYTE *)a4 + 56))
  {
    v18 = 0;
LABEL_33:
    v22 = 0;
    v23 = *((unsigned __int8 *)a3 + 52) - v18;
    goto LABEL_35;
  }
  v17 = 0;
  v18 = 0;
  v19 = -1;
  do
  {
    if (((1 << v17) & a5) != 0)
      ++v18;
    if (v19 == -1 && ((1 << v17) & a5) == 0)
      v19 = v17;
    ++v17;
  }
  while (*((unsigned __int8 *)a4 + 56) != v17);
  if (v19 == -1)
    goto LABEL_33;
  v21 = *((unsigned __int16 *)a3 + 26);
  if (v21 > 0xFF)
  {
    v24 = ~v19;
    v22 = ((v21 >> 8) & 0xF) + v24;
    v23 = v24 + (v21 >> 12);
  }
  else
  {
    v22 = *((unsigned __int8 *)a3 + 56) - v19;
    v23 = *((_WORD *)a3 + 26) - v19;
  }
LABEL_35:
  if (v6 <= v9)
    v6 = v9;
  *((_DWORD *)this + 4) = v6;
  v25 = *((_DWORD *)a3 + 6);
  v26 = *(int8x8_t *)((char *)a3 + 28);
  v27 = v16 & 0xEFFFFFFF | v15 & 0xDBFFFFFF;
  v28 = *((_WORD *)a4 + 24) | *((_WORD *)a3 + 24);
  v29 = *((_WORD *)a4 + 23) | *((_WORD *)a3 + 23);
  v30 = *((_BYTE *)a4 + 57) | *((_BYTE *)a3 + 57);
  if ((v16 | v15) >= 0)
    v31 = v16 & v15 & 0xC0000000;
  else
    v31 = 0x80000000;
  v32 = v27 | v31;
  v33 = *((_DWORD *)a4 + 6) & ~a5;
  if ((v22 & 0x80000000) != 0)
    v34 = v33 >> -(char)v22;
  else
    v34 = v33 << v22;
  v35 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(*(int8x8_t *)((char *)a4 + 28), (int8x8_t)vdup_n_s32(~a5)), (uint32x2_t)vdup_n_s32(v22)), (int8x8_t)0xFF000000FFLL);
  *((_DWORD *)this + 5) = v32;
  *((_DWORD *)this + 6) = v34 | v25;
  v36 = (uint8x8_t)vorr_s8(v35, v26);
  *(uint8x8_t *)((char *)this + 28) = v36;
  *((_WORD *)this + 24) = v28;
  *((_WORD *)this + 23) = v29;
  v37 = *((_WORD *)a4 + 18) + *((_WORD *)a3 + 18);
  *((_WORD *)this + 18) = v37;
  v38 = *((_WORD *)a4 + 19) + *((_WORD *)a3 + 19);
  *((_WORD *)this + 19) = v38;
  *((_DWORD *)this + 15) = *((_DWORD *)a4 + 15) + *((_DWORD *)a3 + 15);
  v39 = *((unsigned __int16 *)a4 + 20);
  if (v39 <= *((unsigned __int16 *)a3 + 20))
    v39 = *((unsigned __int16 *)a3 + 20);
  *((_WORD *)this + 20) = v39;
  v36.i32[0] = *(_DWORD *)((char *)a4 + 42);
  v40 = (int16x8_t)vmovl_u8(v36);
  v35.i32[0] = *(_DWORD *)((char *)a3 + 42);
  *(uint16x4_t *)v40.i8 = vmax_u16(*(uint16x4_t *)v40.i8, (uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v35));
  *(_DWORD *)((char *)this + 42) = vmovn_s16(v40).u32[0];
  v41 = *((_WORD *)a4 + 25) + *((_WORD *)a3 + 25);
  *((_WORD *)this + 25) = v41;
  v42 = (unsigned __int16)(*((_WORD *)a4 + 26) + v23);
  *((_WORD *)this + 26) = *((_WORD *)a4 + 26) + v23;
  if (*((unsigned __int8 *)a3 + 52) <= v42)
    v43 = v42;
  else
    v43 = *((unsigned __int8 *)a3 + 52);
  *((_WORD *)this + 26) = v43;
  v44 = (*((_BYTE *)a4 + 56) + v22);
  *((_BYTE *)this + 56) = *((_BYTE *)a4 + 56) + v22;
  if (*((unsigned __int8 *)a3 + 56) <= v44)
    v45 = v44;
  else
    v45 = *((unsigned __int8 *)a3 + 56);
  *((_BYTE *)this + 56) = v45;
  *((_BYTE *)this + 57) = v30;
  v46 = *((unsigned __int8 *)a4 + 58);
  *((_BYTE *)this + 58) = v46;
  v47 = *((unsigned __int8 *)a4 + 59);
  if (*((unsigned __int8 *)a3 + 59) > v47)
    v47 = *((unsigned __int8 *)a3 + 59);
  *((_BYTE *)this + 59) = v47;
  if (!a6)
    goto LABEL_62;
  if (v43 > *((unsigned __int16 *)a6 + 18)
    || v45 > *((unsigned __int8 *)a6 + 40)
    || *((unsigned __int16 *)a6 + 11) < v38)
  {
    return 0xFFFFFFFFLL;
  }
  v48 = *((unsigned __int16 *)a6 + 10);
  v14 = 0xFFFFFFFFLL;
  if (v37 > v48 || v37 + v38 > v48)
    return v14;
  if (v39 + v40.u8[2] + v40.u8[0] + v40.u8[4] + v41 + v47 > *((unsigned __int8 *)a6 + 27)
                                                           + *((unsigned __int16 *)a6 + 12)
                                                           + *((unsigned __int8 *)a6 + 26)
                                                           + *((unsigned __int8 *)a6 + 28)
                                                           + *((unsigned __int16 *)a6 + 17)
                                                           + *((unsigned __int8 *)a6 + 43)
    || v46 > *((unsigned __int8 *)a6 + 42))
  {
    return 0xFFFFFFFFLL;
  }
LABEL_62:
  v49 = *((unsigned __int16 *)a3 + 18);
  *(_DWORD *)a2 = *((unsigned __int16 *)a3 + 25);
  *((_DWORD *)a2 + 1) = v49;
  *((_DWORD *)a2 + 2) = v23;
  *((_DWORD *)a2 + 3) = 0;
  v50 = *((_DWORD *)a3 + 15);
  *((_DWORD *)a2 + 4) = *((unsigned __int16 *)a3 + 19);
  *((_DWORD *)a2 + 5) = v50;
  *((_DWORD *)a2 + 6) = v22;
  *(_QWORD *)((char *)a2 + 28) = 0xFFFFFFFFLL;
  v51 = bswap32(*(_DWORD *)a3);
  v52 = bswap32(*((_DWORD *)a3 + 1));
  v53 = bswap32(*((_DWORD *)a3 + 2));
  v54 = bswap32(*((_DWORD *)a3 + 3));
  v8 = v51 >= *(_DWORD *)a4;
  *(_DWORD *)this = v51 - *(_DWORD *)a4;
  v55 = !v8;
  v56 = v52 - *((_DWORD *)a4 + 1) - v55;
  *((_DWORD *)this + 1) = v56;
  v57 = (__PAIR64__(v53, v52) - __PAIR64__(*((_DWORD *)a4 + 2), v56)) >> 32;
  *((_DWORD *)this + 2) = v57;
  *((_DWORD *)this + 3) = (__PAIR64__(v54, v53) - __PAIR64__(*((_DWORD *)a4 + 3), v57)) >> 32;
  return *((unsigned int *)a2 + 3);
}

uint64_t HGString::pop(HGString *this, HGShaderBinding *a2, const HGString *a3, const char *a4, const HGLimits *a5)
{
  const HGLimits *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  const char *v14;
  double v15;
  double v16;
  uint32x4_t v17;
  unsigned int v18;
  const char *v19;
  double v20;
  double v21;
  uint32x4_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _BOOL4 v28;
  unsigned int v29;
  int v30;
  BOOL v31;
  _OWORD v32[3];
  _BYTE v33[16];
  int v34;
  _BYTE v35[16];
  string_t v36[6];

  HGString::digest(this, (uint64_t)v35);
  HGString::digest(a3, (uint64_t)v33);
  memset(v32, 0, sizeof(v32));
  v11 = HGString::Digest::pop((HGString::Digest *)&v28, a2, (const HGString::Digest *)v35, (const HGString::Digest *)v33, (int)a4, a5);
  if ((_DWORD)v11 != -1)
  {
    if ((v34 & 0xFFFFFu) - 394305 >= 0xFFFFFECF)
    {
      arb::begin((string_t *)this, v36, (const HGLimits *)v32, v10);
      arb::write((string_t *)this, (string_t *)a2, (const HGShaderBinding *)v36, (const HGLimits *)0xFFFFFFFFLL, 0, *(const HGLimits **)a3, 0, a4, v28, v29, v30, v31);
      arb::end((string_t *)this, (uint64_t)v32, (unsigned int *)&v28, v15, v16, v17);
    }
    else
    {
      if ((v34 & 0xFFFFFu) - 394785 >= 0xFFFFFFEF)
      {
        glsl::begin((string_t *)this, v36, (const HGLimits *)v32, v10);
        v20 = glsl::write(this, (string_t *)a2, 0, *(const HGLimits **)a3, 0, (const HGLimits *)a4, v18, v19, v28, v29, v30, v31);
LABEL_17:
        glsl::end((string_t *)this, (uint64_t)v32, (unsigned int *)&v28, 0, v20, v21, v22);
        return v11;
      }
      if ((v34 & 0xFFFFF) == 0x60B10)
      {
        v12 = v32[0];
        v13 = *((_QWORD *)this + 1);
        if (v13)
        {
          str_alloc((string_t *)this, v13);
          if (LODWORD(v36[0]) == v12)
            goto LABEL_16;
        }
        else
        {
          str_alloc((string_t *)this, 33);
          *((_QWORD *)this + 1) = 33;
          if (LODWORD(v36[0]) == v12)
          {
LABEL_16:
            metal::write(this, (string_t *)a2, (const HGShaderBinding *)v32, 0, *(_QWORD *)a3, 0, a4, v14, v28, v29, v30, v31);
            goto LABEL_17;
          }
        }
        v23 = v12 >> 4;
        v24 = *(_QWORD *)this;
        *(_DWORD *)(v24 + 3) = 1818326117;
        *(_DWORD *)v24 = 1699557167;
        if (v23 | v12 & 0xF)
        {
          *(_BYTE *)(v24 + 7) = v23 | 0x30;
          *(_BYTE *)(v24 + 8) = 46;
          v25 = (void *)(v24 + 10);
          *(_BYTE *)(v24 + 9) = v12 & 0xF | 0x30;
        }
        else
        {
          v25 = (void *)(v24 + 7);
        }
        v26 = *(_QWORD *)this;
        memset(v25, 32, *(_QWORD *)this + 15 - (_QWORD)v25);
        qmemcpy((void *)(v26 + 15), "\n//LEN=0000000000\n", 18);
        goto LABEL_16;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v11;
}

uint64_t HGString::undo(HGString *this)
{
  uint64_t v2;
  string_t *v3;
  const char *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  string_t *v9;
  uint64_t v10;
  int64_t v11;
  const char *v12;
  const char *v13;
  int64_t v14;
  const char *v15;
  void *v16;
  int v18[12];

  v2 = *((_QWORD *)this + 1);
  HGString::signature((HGString **)this, (uint64_t)v18);
  if ((v18[0] & 0xFFFFFu) - 394305 >= 0xFFFFFECF)
  {
    arb::undo(this, v3);
    v2 = arb::undo(this, v9);
    v10 = *((_QWORD *)this + 4);
    if (*((_QWORD *)this + 3) == v10)
      return v2;
    goto LABEL_27;
  }
  if ((v18[0] & 0xFFFFF) != 0x60B10)
    goto LABEL_26;
  v4 = *(const char **)this;
  v5 = *((_QWORD *)this + 1);
  v6 = *(const char **)this;
  if (*(_QWORD *)this + v5 - 139 != *(_QWORD *)this)
  {
    v7 = v5 - 139;
    do
    {
      v8 = &v4[v7];
      if (v4[v7] == 47 && v8[1] == 47 && !strncmp(v8, "//SIG=", 6uLL))
      {
        v6 = &v4[v7];
        goto LABEL_13;
      }
      --v7;
    }
    while (v7);
    v6 = v4;
  }
LABEL_13:
  if (strncmp(v6, "//Metal1.0     \n", 0x10uLL))
  {
    v11 = v6 + 96 - v4;
    bzero((void *)(v6 + 96), v5 - v11);
    *((_QWORD *)this + 1) = v11;
    v12 = *(const char **)this;
    v13 = *(const char **)this;
    if (*(_QWORD *)this + v11 - 139 == *(_QWORD *)this)
      goto LABEL_24;
LABEL_17:
    v14 = v11 - 139;
    do
    {
      v15 = &v12[v14];
      if (v12[v14] == 47 && v15[1] == 47 && !strncmp(v15, "//SIG=", 6uLL))
      {
        v13 = &v12[v14];
        goto LABEL_24;
      }
      --v14;
    }
    while (v14);
    v13 = v12;
    goto LABEL_24;
  }
  *((_QWORD *)this + 1) = 0;
  *v4 = 0;
  v12 = *(const char **)this;
  v11 = *((_QWORD *)this + 1);
  v13 = *(const char **)this;
  if (*(_QWORD *)this + v11 - 139 != *(_QWORD *)this)
    goto LABEL_17;
LABEL_24:
  if (!strncmp(v13, "//Metal1.0     \n", 0x10uLL))
  {
    *((_QWORD *)this + 1) = 0;
    *v12 = 0;
    v2 = *((_QWORD *)this + 1);
    v10 = *((_QWORD *)this + 4);
    if (*((_QWORD *)this + 3) == v10)
      return v2;
    goto LABEL_27;
  }
  v16 = (void *)(v13 + 96);
  v2 = v13 + 96 - v12;
  bzero(v16, v11 - v2);
  *((_QWORD *)this + 1) = v2;
LABEL_26:
  v10 = *((_QWORD *)this + 4);
  if (*((_QWORD *)this + 3) != v10)
LABEL_27:
    *((_QWORD *)this + 4) = v10 - 2;
  return v2;
}

uint64_t arb::undo(arb *this, string_t *a2)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  int v10;
  unsigned __int8 *v11;
  uint64_t i;
  int v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  char v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v28;
  int v29;
  int v30;
  unsigned int v31;
  _BYTE *v32;
  uint64_t v33;

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v7 = *(_QWORD *)this;
  v6 = *((_QWORD *)this + 1);
  v8 = *(_BYTE **)this;
  v9 = *(_QWORD *)this + v6;
  v10 = *(unsigned __int8 *)(v9 - 3);
  v11 = (unsigned __int8 *)(v9 - 143);
  for (i = v6; ; --i)
  {
    v13 = *v11;
    if (v13 != 36)
      break;
    if (v11[1] == 116)
    {
      v14 = v11 + 2;
      v15 = v11[2];
      if ((v15 - 58) >= 0xFFFFFFF6)
      {
        v3 = 0;
        do
        {
          v3 = v15 + 10 * v3 - 48;
          v16 = *++v14;
          v15 = v16;
        }
        while ((v16 - 58) > 0xFFFFFFF5);
        if (v15)
        {
          if ((v15 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_11:
              v17 = *++v14;
              v15 = v17;
            }
            while ((v17 - 33) > 0xFFFFFFDF);
          }
LABEL_12:
          if (v15 == 35)
          {
            v18 = v14;
            while (1)
            {
              v19 = *++v18;
              v15 = v19;
              if (!v19)
                break;
              v20 = *v14;
              v14 = v18;
              if (v20 == 10)
              {
                v14 = v18;
                if ((v15 - 33) >= 0xFFFFFFE0)
                  goto LABEL_11;
                goto LABEL_12;
              }
            }
          }
        }
      }
      if (v3 + 1 <= v5 + v4)
        v21 = v5;
      else
        v21 = v3 + 1 - v4;
      v22 = v5 + v4 - v3;
      if (v3 >= v4)
      {
        v5 = v21;
      }
      else
      {
        v4 = v3;
        v5 = v22;
      }
    }
LABEL_3:
    --v11;
  }
  if (v13 != 64)
    goto LABEL_3;
  while (v13 != 35 || *(_BYTE *)(v7 + i - 141) != 36)
    v13 = *(unsigned __int8 *)(v7 + i-- - 144);
  if ((unint64_t)(i - 143) > 0xA8)
  {
    if (v10 != 59 || *(_BYTE *)(v7 + i - 146) != 59)
    {
      if (v6)
      {
        v23 = v5 + v4;
        if (v23 <= 8 && v6 - 142 >= 0 && v5)
        {
          v24 = v23 - 1;
          v25 = v6 + v7 - 149;
          do
          {
            if (*(_BYTE *)(v25 + 7) == 36 && *(_BYTE *)(v25 + 8) == 116 && *(char *)(v25 + 9) == (char)(v24 + 48))
            {
              if (!strncmp((const char *)v25, "#UTPUT ", 7uLL))
              {
                *(_BYTE *)v25 = 79;
                --v24;
                --v5;
              }
              else
              {
                *(_BYTE *)(v25 + 8) = 111;
              }
            }
            v26 = v25 + 6;
            v8 = *(_BYTE **)this;
            --v25;
          }
          while (v26 >= *(_QWORD *)this && v5 != 0);
        }
      }
      v28 = v7 + i;
      v29 = *(char *)(v28 - 146);
      if (v29 <= 96)
        v30 = 0;
      else
        v30 = -39;
      v31 = v29 + v30 - 48;
      if (v31 <= 7)
      {
        v32 = v8 + 128;
        if (v31)
        {
          v33 = 4 * v31;
          memcpy(v8 + 128, "TEMP $t0,$t1,$t2,$t3,$t4,$t5,$t6,$t7;  \n", v33 + 4);
          v32[v33 + 4] = 59;
          memset(&v32[v33 + 5], 32, 34 - v33);
          v8[167] = 10;
        }
        else
        {
          qmemcpy(v8 + 128, "##                                     \n", 40);
        }
      }
      *((_QWORD *)this + 1) = v28 - *(_QWORD *)this - 143;
      *(_BYTE *)(v28 - 285) = 69;
    }
  }
  else
  {
    *((_QWORD *)this + 1) = 0;
    *v8 = 0;
  }
  return *((_QWORD *)this + 1);
}

uint64_t HGString::setp(HGString *this, uint64_t a2)
{
  const char *v2;
  _DWORD *v6;
  int v7;
  unsigned int v8;
  uint64_t v9;

  v2 = *(const char **)this;
  if (**(_BYTE **)this != 47
    || strncmp(*(const char **)this, "//GLfs", 6uLL)
    || strncmp(v2 + 33, "#ifndef GL_ES\n#define lowp\n#define mediump\n#define highp\n#endif\n#define defaultp ", 0x51uLL))
  {
    return 0;
  }
  v6 = v2 + 114;
  v7 = *((unsigned __int8 *)v2 + 114);
  if (v7 == 104)
    v8 = 2;
  else
    v8 = 1;
  if (v7 == 108)
    v9 = 0;
  else
    v9 = v8;
  if ((_DWORD)v9 == (_DWORD)a2)
    return a2;
  str_alloc((string_t *)this, *((_QWORD *)this + 1));
  if ((_DWORD)a2 == 2)
  {
    *(_DWORD *)((char *)v6 + 3) = 538996840;
    *v6 = 1751607656;
    return v9;
  }
  else
  {
    if ((_DWORD)a2)
    {
      *(_DWORD *)((char *)v6 + 3) = 1886221673;
      *v6 = 1768187245;
    }
    else
    {
      *(_DWORD *)((char *)v6 + 3) = 538976368;
      *v6 = 1886875500;
    }
    return v9;
  }
}

unsigned __int8 *atox(unsigned __int8 *result, unsigned int *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;

  v2 = *result;
  if ((ctype[2 * v2] & 0x10) != 0)
  {
    if ((char)v2 <= 96)
      v3 = 0;
    else
      v3 = -39;
    v4 = (char)v2 + v3 - 48;
    v5 = result[1];
    if ((ctype[2 * v5] & 0x10) != 0)
    {
      v6 = (char)v5 <= 96 ? 0 : -39;
      v4 = ((char)v5 + v6 - 48) | (16 * v4);
      v7 = result[2];
      if ((ctype[2 * v7] & 0x10) != 0)
      {
        v8 = (char)v7 <= 96 ? 0 : -39;
        v4 = ((char)v7 + v8 - 48) | (16 * v4);
        v9 = result[3];
        if ((ctype[2 * v9] & 0x10) != 0)
        {
          v10 = (char)v9 <= 96 ? 0 : -39;
          v4 = ((char)v9 + v10 - 48) | (16 * v4);
          v11 = result[4];
          if ((ctype[2 * v11] & 0x10) != 0)
          {
            v12 = (char)v11 <= 96 ? 0 : -39;
            v4 = ((char)v11 + v12 - 48) | (16 * v4);
            v13 = result[5];
            if ((ctype[2 * v13] & 0x10) != 0)
            {
              v14 = (char)v13 <= 96 ? 0 : -39;
              v4 = ((char)v13 + v14 - 48) | (16 * v4);
              v15 = result[6];
              if ((ctype[2 * v15] & 0x10) != 0)
              {
                v16 = (char)v15 <= 96 ? 0 : -39;
                v4 = ((char)v15 + v16 - 48) | (16 * v4);
                v17 = result[7];
                if ((ctype[2 * v17] & 0x10) != 0)
                {
                  v18 = (char)v17 <= 96 ? 0 : -39;
                  v4 = ((char)v17 + v18 - 48) | (16 * v4);
                  v19 = result[8];
                  if ((ctype[2 * v19] & 0x10) != 0)
                  {
                    v20 = (char)v19 <= 96 ? 0 : -39;
                    v4 = ((char)v19 + v20 - 48) | (16 * v4);
                    v21 = result[9];
                    if ((ctype[2 * v21] & 0x10) != 0)
                    {
                      if ((char)v21 <= 96)
                        v22 = 0;
                      else
                        v22 = -39;
                      v4 = ((char)v21 + v22 - 48) | (16 * v4);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    *a2 = v4;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

uint32x2_t *merge(uint32x2_t *result, int8x8_t *a2, int8x8_t *a3, int a4, int a5)
{
  unsigned int v5;
  unsigned __int8 v6;
  unsigned int v7;
  unsigned int v8;
  __int32 v9;
  __int32 v10;
  unsigned int v11;
  __int8 v12;
  __int32 v13;
  __int16 v14;
  __int16 v15;
  __int8 v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  char v24;

  v5 = result[5].u8[3];
  if (v5 <= 1)
    LOBYTE(v5) = 1;
  v6 = v5 + a2[5].i8[2];
  v7 = v6;
  a3[5].i8[3] = v6;
  v8 = a2[5].u8[3];
  if (v7 > v8)
    LOBYTE(v8) = v7;
  a3[5].i8[3] = v8;
  v9 = a2->i32[1];
  v10 = result->i32[1];
  v11 = v10 & 0xEFFFFFFF | v9 & 0xDBFFFFFF;
  v12 = a2[5].i8[2];
  if (v12)
    v13 = a2->i32[1];
  else
    v13 = result->i32[1];
  v14 = result[4].i16[0] | a2[4].i16[0];
  v15 = result[3].i16[3] | a2[3].i16[3];
  v16 = result[5].i8[1] | a2[5].i8[1];
  v17 = v10 | v9;
  v18 = v13 & 0x20000000;
  v19 = v9 & v10 & 0xC0000000;
  if (v17 < 0)
    v19 = 0x80000000;
  v20 = v11 | v19 | v18;
  v21 = a2[4].i16[2];
  v22 = (result[2].i32[0] << v21) | a2[2].i32[0];
  a3->i32[0] = a2->i32[0];
  a3->i32[1] = v20;
  a3[1] = vorr_s8(vand_s8((int8x8_t)vshl_u32(result[1], (uint32x2_t)vdup_n_s32(v21)), (int8x8_t)0xFF000000FFLL), a2[1]);
  a3[2].i32[0] = v22;
  a3[4].i16[0] = v14;
  a3[3].i16[3] = v15;
  a3[5].i8[2] = v12 + 1;
  a3[5].i8[1] = v16;
  v23 = result[4].i16[2];
  if ((a4 & a5) != 0)
    v23 = 1;
  a3[4].i16[2] = (v23 + v21) | v21 & 0xFF00;
  v24 = result[5].i8[0];
  if ((a4 & a5) != 0)
    v24 = 1;
  a3[5].i8[0] = v24 + a2[5].i8[0];
  a3[2].i16[3] = result[2].i16[3] + a2[2].i16[3];
  a3[5].i32[1] = result[5].i32[1] + a2[5].i32[1];
  return result;
}

uint64_t arb::obj_decl(uint64_t a1, _BYTE *a2, arb *this, uint64_t a4, uint64_t a5)
{
  int v5;
  arb *v7;
  int v9;
  arb *v10;
  int v11;
  int v12;
  unsigned int *v13;
  const char **v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned __int8 *v19;
  int v20;
  unint64_t v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  unsigned __int8 *v25;
  int v26;
  int v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  int v31;
  int v32;
  uint64_t result;
  size_t v34;
  int v35;
  arb *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  unsigned __int8 *v41;
  int v42;
  int v43;
  int v44;
  arb *v45;
  int v46;
  int v47;
  int v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  int v51;
  int v52;
  unsigned __int8 *v53;
  int v54;
  int v55;
  arb *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  unint64_t v61;
  char *v64;
  unsigned int v65;
  unint64_t v66;
  unsigned int v67;
  char v68[8];

  v5 = *(unsigned __int8 *)this;
  if (!*(_BYTE *)this)
    return 0;
  v7 = this;
  v67 = 0;
  if ((v5 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_3:
      v9 = *((unsigned __int8 *)v7 + 1);
      v7 = (arb *)((char *)v7 + 1);
      v5 = v9;
    }
    while ((v9 - 33) > 0xFFFFFFDF);
  }
LABEL_4:
  if (v5 == 35)
  {
    v10 = v7;
    while (1)
    {
      v11 = *((unsigned __int8 *)v10 + 1);
      v10 = (arb *)((char *)v10 + 1);
      v5 = v11;
      if (!v11)
        return 0;
      v12 = *(unsigned __int8 *)v7;
      v7 = v10;
      if (v12 == 10)
      {
        v7 = v10;
        if ((v5 - 33) >= 0xFFFFFFE0)
          goto LABEL_3;
        goto LABEL_4;
      }
    }
  }
  if (!v5)
    return 0;
  v14 = (const char **)arb::alen(v7, (const char *)1);
  v66 = 0;
  v15 = *(char **)a1;
  v16 = *(_QWORD *)(a1 + 8);
  v17 = *(_QWORD *)a1 + 88 * v16;
  v64 = *(char **)a1;
  if (!v16)
    goto LABEL_22;
  while (1)
  {
    v18 = v16 >> 1;
    *(_QWORD *)v68 = v7;
    v19 = (unsigned __int8 *)&v15[88 * (v16 >> 1)];
    v20 = arb::ascan((unsigned __int8 **)v68, v14, v19, (const char *)1);
    if (!v20)
      break;
    if (v20 > 0)
    {
      v21 = v18 + 1;
    }
    else
    {
      v17 = (uint64_t)&v15[88 * (v16 >> 1)];
      v21 = 0;
    }
    v15 += 88 * v21;
    if (v20 <= 0)
      v16 >>= 1;
    else
      v16 -= v18 + 1;
    if (!v16)
      goto LABEL_22;
  }
  if (!v15)
LABEL_22:
    v19 = (unsigned __int8 *)v17;
  v66 = 0x2E8BA2E8BA2E8BA3 * ((v19 - (unsigned __int8 *)v64) >> 3);
  v22 = (unsigned __int8 *)v14 + (_QWORD)v7;
  v23 = *((unsigned __int8 *)v14 + (_QWORD)v7);
  if (!*((_BYTE *)v14 + (_QWORD)v7))
    return 0;
  if ((v23 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_25:
      v24 = *++v22;
      v23 = v24;
    }
    while ((v24 - 33) > 0xFFFFFFDF);
  }
LABEL_26:
  if (v23 == 35)
  {
    v25 = v22;
    while (1)
    {
      v26 = *++v25;
      v23 = v26;
      if (!v26)
        return 0;
      v27 = *v22;
      v22 = v25;
      if (v27 == 10)
      {
        v22 = v25;
        if ((v23 - 33) >= 0xFFFFFFE0)
          goto LABEL_25;
        goto LABEL_26;
      }
    }
  }
  if (v23 != 61)
    return 0;
  v30 = v22[1];
  v29 = v22 + 1;
  v28 = v30;
  if (v30)
  {
    if ((v28 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_35:
        v31 = *++v29;
        v28 = v31;
      }
      while ((v31 - 33) > 0xFFFFFFDF);
    }
LABEL_36:
    if (v28 == 35)
    {
      ++v29;
      while (1)
      {
        v28 = *v29;
        if (!*v29)
          break;
        v32 = *(v29++ - 1);
        if (v32 == 10)
        {
          --v29;
          if ((v28 - 33) >= 0xFFFFFFE0)
            goto LABEL_35;
          goto LABEL_36;
        }
      }
    }
  }
  v34 = 0;
  do
    v35 = *((unsigned __int8 *)v7 + ++v34);
  while ((ctype[2 * v35] & 0x40) != 0);
  v36 = (arb *)((char *)v7 + v34);
  if (v35)
  {
    if ((v35 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_47:
        v37 = *((unsigned __int8 *)v36 + 1);
        v36 = (arb *)((char *)v36 + 1);
        v35 = v37;
      }
      while ((v37 - 33) > 0xFFFFFFDF);
    }
LABEL_48:
    if (v35 == 35)
    {
      v36 = (arb *)((char *)v36 + 1);
      while (1)
      {
        v35 = *(unsigned __int8 *)v36;
        if (!*(_BYTE *)v36)
          break;
        v38 = *((unsigned __int8 *)v36 - 1);
        v36 = (arb *)((char *)v36 + 1);
        if (v38 == 10)
        {
          v36 = (arb *)((char *)v36 - 1);
          if ((v35 - 33) >= 0xFFFFFFE0)
            goto LABEL_47;
          goto LABEL_48;
        }
      }
    }
  }
  *(_DWORD *)v68 = 0;
  v65 = 0;
  if (!arb::aidx(v36, v68, &v65, v13))
  {
    v67 = -1;
    arb::obj_declare((char **)a1, &v66, a2, v7, v34, (signed int *)&v67, (arb *)v29, a4, a5);
    return 1;
  }
  if (v65 != -1)
    v65 = *(_DWORD *)v68 - 1;
  *(_DWORD *)v68 = 0;
  v39 = *v29;
  if (!*v29)
    goto LABEL_78;
  if ((v39 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_59:
      v40 = *++v29;
      v39 = v40;
    }
    while ((v40 - 33) > 0xFFFFFFDF);
  }
LABEL_60:
  if (v39 == 35)
  {
    v41 = v29;
    while (1)
    {
      v42 = *++v41;
      v39 = v42;
      if (!v42)
        goto LABEL_78;
      v43 = *v29;
      v29 = v41;
      if (v43 == 10)
      {
        v29 = v41;
        if ((v39 - 33) >= 0xFFFFFFE0)
          goto LABEL_59;
        goto LABEL_60;
      }
    }
  }
  if (v39 != 123)
  {
LABEL_78:
    v45 = 0;
    goto LABEL_79;
  }
  v46 = v29[1];
  v45 = (arb *)(v29 + 1);
  v44 = v46;
  if (v46)
  {
    if ((v44 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_71:
        v47 = *((unsigned __int8 *)v45 + 1);
        v45 = (arb *)((char *)v45 + 1);
        v44 = v47;
      }
      while ((v47 - 33) > 0xFFFFFFDF);
    }
LABEL_72:
    if (v44 == 35)
    {
      v45 = (arb *)((char *)v45 + 1);
      while (1)
      {
        v44 = *(unsigned __int8 *)v45;
        if (!*(_BYTE *)v45)
          break;
        v48 = *((unsigned __int8 *)v45 - 1);
        v45 = (arb *)((char *)v45 + 1);
        if (v48 == 10)
        {
          v45 = (arb *)((char *)v45 - 1);
          if ((v44 - 33) >= 0xFFFFFFE0)
            goto LABEL_71;
          goto LABEL_72;
        }
      }
    }
  }
LABEL_79:
  v67 = 0;
  v49 = arb::obj_declare((char **)a1, &v66, a2, v7, v34, (signed int *)&v67, v45, a4, a5);
  if (v49)
  {
    v50 = v49;
    while (v67 <= v65)
    {
      v51 = *v50;
      if (!*v50)
        break;
      if ((v51 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_84:
          v52 = *++v50;
          v51 = v52;
        }
        while ((v52 - 33) > 0xFFFFFFDF);
      }
LABEL_85:
      if (v51 == 35)
      {
        v53 = v50;
        while (1)
        {
          v54 = *++v53;
          v51 = v54;
          if (!v54)
            return 1;
          v55 = *v50;
          v50 = v53;
          if (v55 == 10)
          {
            v50 = v53;
            if ((v51 - 33) >= 0xFFFFFFE0)
              goto LABEL_84;
            goto LABEL_85;
          }
        }
      }
      if (v51 != 44)
        return 1;
      v58 = v50[1];
      v56 = (arb *)(v50 + 1);
      v57 = v58;
      if (v58)
      {
        if ((v57 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_94:
            v59 = *((unsigned __int8 *)v56 + 1);
            v56 = (arb *)((char *)v56 + 1);
            v57 = v59;
          }
          while ((v59 - 33) > 0xFFFFFFDF);
        }
LABEL_95:
        if (v57 == 35)
        {
          v56 = (arb *)((char *)v56 + 1);
          while (1)
          {
            v57 = *(unsigned __int8 *)v56;
            if (!*(_BYTE *)v56)
              break;
            v60 = *((unsigned __int8 *)v56 - 1);
            v56 = (arb *)((char *)v56 + 1);
            if (v60 == 10)
            {
              v56 = (arb *)((char *)v56 - 1);
              if ((v57 - 33) >= 0xFFFFFFE0)
                goto LABEL_94;
              goto LABEL_95;
            }
          }
        }
      }
      v50 = arb::obj_declare((char **)a1, &v66, a2, v7, v34, (signed int *)&v67, v56, a4, a5);
      if (!v50)
        goto LABEL_102;
    }
    return 1;
  }
LABEL_102:
  v61 = *(_QWORD *)(a1 + 8);
  if (v66 + 1 < v61)
  {
    memcpy((void *)(*(_QWORD *)a1 + 88 * v66), (const void *)(*(_QWORD *)a1 + 88 * v66 + 88), 88 * (v61 + ~v66));
    v61 = *(_QWORD *)(a1 + 8);
  }
  result = 0;
  *(_QWORD *)(a1 + 8) = v61 - 1;
  return result;
}

unsigned __int8 *arb::obj_alias(uint64_t a1, char *__s1, uint64_t a3)
{
  int v6;
  unsigned __int8 *result;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  int64_t v15;
  unsigned __int8 *v16;
  int i;
  int v18;
  int v19;
  const char **v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  int v25;
  char *v26;
  int v27;
  int v28;
  int v29;
  int64_t v30;
  char *v31;
  char *v32;
  int v33;
  int v34;
  int v35;
  const char **v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  char *v46;
  unint64_t v47;
  int v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  int v52;
  unint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  int64_t v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  int v66;
  int64_t v67;
  uint64_t v68;
  unsigned __int8 *v69;
  int64_t v70;
  uint64_t v71;
  char **v72[2];
  const char **v73;
  unsigned __int8 *v74;

  v6 = strncmp(__s1, "ALIAS", 5uLL);
  result = 0;
  v8 = (unsigned __int8 *)(__s1 + 5);
  if (v6)
    v9 = 0;
  else
    v9 = v8;
  if (v6)
    return result;
  v10 = *v8;
  if (!*v8)
  {
    v9 = v8;
    goto LABEL_15;
  }
LABEL_7:
  if ((v10 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      v11 = *++v8;
      v10 = v11;
    }
    while ((v11 - 33) > 0xFFFFFFDF);
  }
  if (v10 == 35)
  {
    v12 = v8;
    while (1)
    {
      v13 = *++v8;
      v10 = v13;
      if (!v13)
        goto LABEL_15;
      v14 = *v12;
      v12 = v8;
      if (v14 == 10)
        goto LABEL_7;
    }
  }
  if (!v10)
  {
LABEL_15:
    v15 = 0;
    result = v9;
    v16 = v9;
    i = *v9;
    if (i == 35)
      goto LABEL_18;
    while (i != 59)
    {
      ++v15;
      if ((i - 33) < 0xFFFFFFE0)
        result = &v9[v15];
      v16 = &v9[v15];
      for (i = v9[v15]; i == 35; i = *v16)
      {
LABEL_18:
        if ((i - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_19:
            v18 = *++v16;
            i = v18;
          }
          while ((v18 - 33) > 0xFFFFFFDF);
        }
LABEL_20:
        if (i == 35)
        {
          ++v16;
          while (1)
          {
            i = *v16;
            if (!*v16)
              break;
            v19 = *(v16++ - 1);
            if (v19 == 10)
            {
              --v16;
              if ((i - 33) >= 0xFFFFFFE0)
                goto LABEL_19;
              goto LABEL_20;
            }
          }
        }
        v15 = v16 - v9;
      }
    }
    return result;
  }
  v20 = 0;
  do
  {
    v21 = *((unsigned __int8 *)v20 + (_QWORD)v8 + 1);
    v20 = (const char **)((char *)v20 + 1);
  }
  while ((ctype[2 * v21] & 0x40) != 0);
  v22 = (unsigned __int8 *)v20 + (_QWORD)v8;
  if (v21)
  {
    if ((v21 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_36:
        v23 = *++v22;
        v21 = v23;
      }
      while ((v23 - 33) > 0xFFFFFFDF);
    }
LABEL_37:
    if (v21 == 35)
    {
      ++v22;
      while (1)
      {
        v21 = *v22;
        if (!*v22)
          break;
        v24 = *(v22++ - 1);
        if (v24 == 10)
        {
          --v22;
          if ((v21 - 33) >= 0xFFFFFFE0)
            goto LABEL_36;
          goto LABEL_37;
        }
      }
    }
  }
  v27 = v22[1];
  v26 = (char *)(v22 + 1);
  v25 = v27;
  if (v27)
  {
    if ((v25 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_45:
        v28 = *++v26;
        v25 = v28;
      }
      while ((v28 - 33) > 0xFFFFFFDF);
    }
LABEL_46:
    if (v25 == 35)
    {
      ++v26;
      while (1)
      {
        v25 = *v26;
        if (!*v26)
          break;
        v29 = *(v26++ - 1);
        if (v29 == 10)
        {
          --v26;
          if ((v25 - 33) >= 0xFFFFFFE0)
            goto LABEL_45;
          goto LABEL_46;
        }
      }
    }
  }
  v30 = 0;
  v31 = v26;
  if (v25 != 35)
    goto LABEL_55;
  do
  {
LABEL_59:
    v32 = &v26[v30];
    v33 = 35;
LABEL_61:
    if (v33 == 35)
    {
      ++v32;
      while (1)
      {
        v33 = *v32;
        if (!*v32)
          break;
        v35 = *(v32++ - 1);
        if (v35 == 10)
        {
          --v32;
          if ((v33 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              v34 = *++v32;
              v33 = v34;
            }
            while ((v34 - 33) > 0xFFFFFFDF);
          }
          goto LABEL_61;
        }
      }
    }
    v30 = v32 - v26;
    v25 = *v32;
  }
  while (v25 == 35);
LABEL_55:
  while (v25 != 59)
  {
    ++v30;
    if ((v25 - 33) < 0xFFFFFFE0)
      v31 = &v26[v30];
    v25 = v26[v30];
    if (v25 == 35)
      goto LABEL_59;
  }
  v36 = (const char **)(v31 - v26);
  v37 = arb::obj_add(a1, v26, (const char **)(v31 - v26), a3, 0);
  if (v37)
  {
    v38 = *((_QWORD *)v37 + 5);
    v39 = *((_QWORD *)v37 + 6);
    v40 = *((_DWORD *)v37 + 14);
    v41 = *((_QWORD *)v37 + 8);
    *(_OWORD *)v72 = *(_OWORD *)(v37 + 72);
    v42 = *(_QWORD *)a1 + 88 * arb::obj_key((char **)a1, v8, v20);
    *(_QWORD *)(v42 + 40) = v38;
    *(_QWORD *)(v42 + 48) = v39;
    *(_DWORD *)(v42 + 56) = v40;
    *(_QWORD *)(v42 + 64) = v41;
    *(_OWORD *)(v42 + 72) = *(_OWORD *)v72;
    goto LABEL_15;
  }
  v73 = v36;
  v44 = *(char **)a1;
  v43 = *(_QWORD *)(a1 + 8);
  if (!v43)
    goto LABEL_79;
  v45 = *(_QWORD *)(a1 + 8);
  v46 = *(char **)a1;
  while (1)
  {
    v47 = v45 >> 1;
    v74 = (unsigned __int8 *)v26;
    v48 = arb::ascan(&v74, v73, (unsigned __int8 *)&v46[88 * (v45 >> 1)], (const char *)1);
    if (!v48)
      break;
    if (v48 > 0)
      v49 = v47 + 1;
    else
      v49 = 0;
    v46 += 88 * v49;
    if (v48 <= 0)
      v45 >>= 1;
    else
      v45 -= v47 + 1;
    if (!v45)
      goto LABEL_79;
  }
  v9 = v74;
  v51 = &v46[88 * (v45 >> 1)];
  if (!v46)
  {
LABEL_79:
    if (!v43)
      goto LABEL_101;
    while (1)
    {
      v50 = v43 >> 1;
      v74 = (unsigned __int8 *)v26;
      v51 = &v44[88 * (v43 >> 1)];
      v52 = arb::ascan(&v74, v73, (unsigned __int8 *)v51, 0);
      if (!v52)
        break;
      if (v52 > 0)
        v53 = v50 + 1;
      else
        v53 = 0;
      v44 += 88 * v53;
      if (v52 <= 0)
        v43 >>= 1;
      else
        v43 -= v50 + 1;
      if (!v43)
        goto LABEL_101;
    }
    v9 = v74;
    if (!v44)
    {
LABEL_101:
      v58 = *(_QWORD *)a1 + 88 * arb::obj_key((char **)a1, v8, v20);
      *(_QWORD *)(v58 + 40) = v26;
      *(_QWORD *)(v58 + 48) = v20;
      *(_DWORD *)(v58 + 56) = -1;
      *(_QWORD *)(v58 + 72) = 0;
      *(_QWORD *)(v58 + 80) = 0;
      *(_QWORD *)(v58 + 64) = 0;
      goto LABEL_15;
    }
  }
  v54 = arb::obj_key((char **)a1, v8, v20);
  v55 = *v9;
  if (*v9)
  {
    if ((v55 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_94:
        v56 = *++v9;
        v55 = v56;
      }
      while ((v56 - 33) > 0xFFFFFFDF);
    }
LABEL_95:
    if (v55 == 35)
    {
      ++v9;
      while (1)
      {
        v55 = *v9;
        if (!*v9)
          break;
        v57 = *(v9++ - 1);
        if (v57 == 10)
        {
          --v9;
          if ((v55 - 33) >= 0xFFFFFFE0)
            goto LABEL_94;
          goto LABEL_95;
        }
      }
    }
  }
  v59 = 0;
  v60 = v9;
  if (v55 != 35)
    goto LABEL_105;
  do
  {
LABEL_109:
    v61 = &v9[v59];
    v62 = 35;
LABEL_111:
    if (v62 == 35)
    {
      ++v61;
      while (1)
      {
        v62 = *v61;
        if (!*v61)
          break;
        v64 = *(v61++ - 1);
        if (v64 == 10)
        {
          --v61;
          if ((v62 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              v63 = *++v61;
              v62 = v63;
            }
            while ((v63 - 33) > 0xFFFFFFDF);
          }
          goto LABEL_111;
        }
      }
    }
    v59 = v61 - v9;
    v55 = *v61;
  }
  while (v55 == 35);
LABEL_105:
  while (v55 != 59)
  {
    ++v59;
    if ((v55 - 33) < 0xFFFFFFE0)
      v60 = &v9[v59];
    v55 = v9[v59];
    if (v55 == 35)
      goto LABEL_109;
  }
  v65 = *((_QWORD *)v51 + 6);
  v66 = *((_DWORD *)v51 + 14);
  v67 = v60 - v9;
  if (v67)
  {
    v68 = *((_QWORD *)v51 + 10) | 0x20;
    v69 = v9;
    v70 = v67;
  }
  else
  {
    v69 = (unsigned __int8 *)*((_QWORD *)v51 + 8);
    v70 = *((_QWORD *)v51 + 9);
    v68 = *((_QWORD *)v51 + 10);
  }
  v71 = *(_QWORD *)a1 + 88 * v54;
  *(_QWORD *)(v71 + 40) = *((_QWORD *)v51 + 5);
  *(_QWORD *)(v71 + 48) = v65;
  *(_DWORD *)(v71 + 56) = v66;
  *(_QWORD *)(v71 + 64) = v69;
  *(_QWORD *)(v71 + 72) = v70;
  *(_QWORD *)(v71 + 80) = v68;
  return &v9[v67];
}

char *arb::isunpremult(uint64_t a1, char *__s1, uint64_t a3)
{
  int v6;
  unint64_t *v7;
  arb *v8;
  char *v9;
  int v10;
  int v11;
  char *v12;
  char *v13;
  int v14;
  _BYTE *v15;
  int v16;
  char *result;
  char *v18;
  int v19;
  _BYTE *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned __int8 *v26;
  unint64_t *v27;
  const char *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  const char *v34;
  int v35;
  int v36;
  size_t v37;
  int v38;
  char *v39;
  int v40;
  char *v41;
  int v42;
  int v43;
  int v44;
  char *v45;
  int v46;
  char *v47;
  int v48;
  int v49;
  int v50;
  arb *v51;
  int v52;
  int v53;
  int v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  char **v57;
  int v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  unint64_t v64;
  unsigned __int8 *v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  const char *v71;
  int v72;
  int v73;
  int v74;
  int v75;
  unint64_t *v76;
  arb *v77;
  unsigned __int8 *v78;
  arb *v79;
  char **v80;
  unsigned __int8 *v81;
  arb *v82;
  unint64_t *v83;
  char **v84;
  unsigned __int8 *v85;
  const char *v86;
  const char *v87;
  unint64_t *v88;
  arb *v89;
  char **v90;
  unsigned __int8 *v91;
  int v92;
  const char *v93;
  _BYTE *v94;
  const char *v95;
  int v96;
  char *v97;
  char *v98;
  const char *v99;
  arb *v100;
  unint64_t *v101;
  unsigned __int8 *v102;
  unint64_t *v103;
  arb *v104;
  unsigned __int8 *v105;
  arb *v106;
  char **v107;
  unsigned __int8 *v108;
  char *v109;
  _BYTE *v110;
  const char *v111;
  const char *v112;
  arb *v113;
  char *v114;
  char *v115;
  int v116;
  _BYTE *v117;
  char **v118;
  char v119[8];
  arb *v120;

  v118 = 0;
  v6 = strncmp(__s1, "DIVA", 4uLL);
  v8 = (arb *)(__s1 + 4);
  if (v6)
    v9 = 0;
  else
    v9 = __s1 + 4;
  *(_QWORD *)v119 = v9;
  if (!v6)
  {
    v10 = *(unsigned __int8 *)v8;
    if ((v10 - 33) >= 0xFFFFFFE0)
    {
LABEL_28:
      if ((v10 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          v24 = *((unsigned __int8 *)v8 + 1);
          v8 = (arb *)((char *)v8 + 1);
          v10 = v24;
        }
        while ((v24 - 33) > 0xFFFFFFDF);
      }
      if (v10 == 35)
      {
        v8 = (arb *)((char *)v8 + 1);
        while (1)
        {
          v10 = *(unsigned __int8 *)v8;
          if (!*(_BYTE *)v8)
            break;
          v25 = *((unsigned __int8 *)v8 - 1);
          v8 = (arb *)((char *)v8 + 1);
          if (v25 == 10)
          {
            v8 = (arb *)((char *)v8 - 1);
            goto LABEL_28;
          }
        }
      }
      v26 = arb::asymbol(v8, v119, (const char **)&v118, v7);
      if (v8 != *(arb **)v119)
        return 0;
      v28 = (const char *)v26;
      if ((unsigned __int8 *)v118 + (_QWORD)v8 == v26 || !strncmp((const char *)v26 - 4, "xyzw", 4uLL))
      {
        if (!v28)
          return 0;
      }
      else
      {
        v29 = strncmp(v28 - 4, "rgba", 4uLL);
        result = 0;
        if (v29 || !v28)
          return result;
      }
      v32 = *(unsigned __int8 *)v28;
      if (*v28)
      {
        if ((v32 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_53:
            v33 = *(unsigned __int8 *)++v28;
            v32 = v33;
          }
          while ((v33 - 33) > 0xFFFFFFDF);
        }
LABEL_54:
        if (v32 == 35)
        {
          v34 = v28;
          while (1)
          {
            v35 = *(unsigned __int8 *)++v34;
            v32 = v35;
            if (!v35)
              break;
            v36 = *(unsigned __int8 *)v28;
            v28 = v34;
            if (v36 == 10)
            {
              v28 = v34;
              if ((v32 - 33) >= 0xFFFFFFE0)
                goto LABEL_53;
              goto LABEL_54;
            }
          }
        }
        else if (v32 == 44)
        {
          v52 = *((unsigned __int8 *)v28 + 1);
          v51 = (arb *)(v28 + 1);
          v50 = v52;
          if (v52)
          {
            if ((v50 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_85:
                v53 = *((unsigned __int8 *)v51 + 1);
                v51 = (arb *)((char *)v51 + 1);
                v50 = v53;
              }
              while ((v53 - 33) > 0xFFFFFFDF);
            }
LABEL_86:
            if (v50 == 35)
            {
              v51 = (arb *)((char *)v51 + 1);
              while (1)
              {
                v50 = *(unsigned __int8 *)v51;
                if (!*(_BYTE *)v51)
                  break;
                v54 = *((unsigned __int8 *)v51 - 1);
                v51 = (arb *)((char *)v51 + 1);
                if (v54 == 10)
                {
                  v51 = (arb *)((char *)v51 - 1);
                  if ((v50 - 33) >= 0xFFFFFFE0)
                    goto LABEL_85;
                  goto LABEL_86;
                }
              }
            }
          }
LABEL_93:
          v55 = arb::asymbol(v51, v119, (const char **)&v118, v27);
          if (v51 == *(arb **)v119)
          {
            v56 = v55;
            v57 = v118;
            if ((unsigned __int8 *)v118 + (_QWORD)v51 == v55 || !strncmp((const char *)v55 - 4, "xyzw", 4uLL))
            {
              if (!v56)
                return 0;
            }
            else
            {
              v58 = strncmp((const char *)v56 - 4, "rgba", 4uLL);
              result = 0;
              if (v58 || !v56)
                return result;
            }
            v59 = *(_QWORD *)(a1 + 8);
            if (v59)
            {
              v60 = *(_QWORD *)a1;
              while (1)
              {
                v61 = v59 >> 1;
                v120 = v51;
                v62 = v60 + 88 * (v59 >> 1);
                v63 = arb::ascan((unsigned __int8 **)&v120, (const char **)v57, (unsigned __int8 *)v62, (const char *)1);
                if (!v63)
                  break;
                if (v63 > 0)
                  v64 = v61 + 1;
                else
                  v64 = 0;
                v60 += 88 * v64;
                if (v63 <= 0)
                  v59 >>= 1;
                else
                  v59 -= v61 + 1;
                if (!v59)
                  goto LABEL_110;
              }
            }
            else
            {
LABEL_110:
              v62 = 0;
            }
            if (*(_QWORD *)(v62 + 40) != *(_QWORD *)(a1 + 48))
              return 0;
            result = __s1;
            if (*(_DWORD *)(v62 + 56) != *(_DWORD *)(a1 + 56))
              return 0;
            goto LABEL_113;
          }
          return 0;
        }
      }
      v51 = 0;
      goto LABEL_93;
    }
  }
  v11 = strncmp(__s1, "MAX", 3uLL);
  v12 = __s1 + 3;
  if (v11)
    v13 = 0;
  else
    v13 = __s1 + 3;
  *(_QWORD *)v119 = v13;
  if (!v11
    && (v14 = *v12, (v14 - 33) >= 0xFFFFFFE0)
    && !strncmp((const char *)a3, "RCP", 3uLL)
    && (v15 = (_BYTE *)(a3 + 3), *(unsigned __int8 *)(a3 + 3) - 33 >= 0xFFFFFFE0))
  {
LABEL_43:
    if ((v14 - 33) >= 0xFFFFFFE0)
    {
      do
      {
        v30 = *++v12;
        v14 = v30;
      }
      while ((v30 - 33) > 0xFFFFFFDF);
    }
    if (v14 == 35)
    {
      ++v12;
      while (1)
      {
        v14 = *v12;
        if (!*v12)
          break;
        v31 = *(v12++ - 1);
        if (v31 == 10)
        {
          --v12;
          goto LABEL_43;
        }
      }
    }
    v37 = -1;
    do
      v38 = v12[++v37];
    while ((ctype[2 * v38] & 0x40) != 0);
    if (!v38)
      return 0;
    v39 = &v12[v37];
    if ((v38 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_64:
        v40 = *++v39;
        v38 = v40;
      }
      while ((v40 - 33) > 0xFFFFFFDF);
    }
LABEL_65:
    if (v38 == 35)
    {
      v41 = v39;
      while (1)
      {
        v42 = *++v41;
        v38 = v42;
        if (!v42)
          return 0;
        v43 = *v39;
        v39 = v41;
        if (v43 == 10)
        {
          v39 = v41;
          if ((v38 - 33) >= 0xFFFFFFE0)
            goto LABEL_64;
          goto LABEL_65;
        }
      }
    }
    if (v38 != 46)
      return 0;
    v67 = v39[1];
    v65 = (unsigned __int8 *)(v39 + 1);
    v66 = v67;
    if (v67)
    {
      if ((v66 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_117:
          v68 = *++v65;
          v66 = v68;
        }
        while ((v68 - 33) > 0xFFFFFFDF);
      }
LABEL_118:
      if (v66 == 35)
      {
        ++v65;
        while (1)
        {
          v66 = *v65;
          if (!*v65)
            break;
          v69 = *(v65++ - 1);
          if (v69 == 10)
          {
            --v65;
            if ((v66 - 33) >= 0xFFFFFFE0)
              goto LABEL_117;
            goto LABEL_118;
          }
        }
      }
    }
    *(_QWORD *)v119 = v65;
    v75 = *v65;
    if (v75 != 119 && v75 != 97)
      return 0;
    result = arb::achr((arb *)(v65 + 1), (const char *)0x2C);
    if (!result)
      return result;
    v77 = (arb *)result;
    v78 = arb::asymbol((arb *)result, v119, (const char **)&v118, v76);
    v80 = v118;
    v79 = *(arb **)v119;
    result = (char *)arb::isidentity(v77, *(arb **)v119, (const char *)v118, (const char *)v78, (const char *)4);
    if (!result)
      return result;
    v81 = arb::obj_search(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), (unsigned __int8 *)v79, (const char **)v80);
    if (*((_QWORD *)v81 + 5) != *(_QWORD *)(a1 + 48))
      return 0;
    if (*((_DWORD *)v81 + 14) != *(_DWORD *)(a1 + 56))
      return 0;
    v82 = (arb *)arb::achr((arb *)v78, (const char *)0x2C);
    arb::asymbol(v82, v119, (const char **)&v118, v83);
    if (v82 != *(arb **)v119)
      return 0;
    v84 = v118;
    v85 = arb::obj_search(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), (unsigned __int8 *)v82, (const char **)v118);
    if ((!v85
       || *((_UNKNOWN **)v85 + 5) != &constantKind
       || !arb::isepsilon(*((arb **)v85 + 8), (const char *)v84 + (_QWORD)v82, v86))
      && !arb::isepsilon(v82, (const char *)v84 + (_QWORD)v82, v86))
    {
      return 0;
    }
    v111 = arb::atok(v15, v87);
    if (strncmp(v111, v12, v37) || (ctype[2 * v111[v37]] & 0x40) != 0)
      return 0;
    v113 = (arb *)arb::atok(&v111[v37], v112);
    result = arb::achr(v113, (const char *)0x2E);
    if (!result)
      return result;
    v114 = result;
    if (strncmp(result, "xyz", 3uLL) && strncmp(v114, "rgb", 3uLL))
      return 0;
    result = arb::achr((arb *)(v114 + 3), (const char *)0x2C);
    if (!result)
      return result;
    v115 = result;
    if (strncmp(result, v12, v37) || (ctype[2 * v115[v37]] & 0x40) != 0)
      return 0;
    result = arb::achr((arb *)&v115[v37], (const char *)0x2E);
    if (!result)
      return result;
    v116 = *result;
    if (v116 != 119 && v116 != 97)
      return 0;
    v117 = arb::achr((arb *)(result + 1), (const char *)0x3B);
    if (strncmp(v117, "SWZ", 3uLL))
      return 0;
    v94 = v117 + 3;
    if (v117[3] - 33 < 0xFFFFFFE0)
      return 0;
  }
  else
  {
    v16 = strncmp(__s1, "RCP", 3uLL);
    result = 0;
    if (v16)
      v18 = 0;
    else
      v18 = __s1 + 3;
    *(_QWORD *)v119 = v18;
    if (v16)
      return result;
    v19 = *v12;
    if ((v19 - 33) < 0xFFFFFFE0)
      return 0;
    if (strncmp((const char *)a3, "SWZ", 3uLL))
      return 0;
    v21 = *(unsigned __int8 *)(a3 + 3);
    v20 = (_BYTE *)(a3 + 3);
    if ((v21 - 33) < 0xFFFFFFE0)
      return 0;
    if ((v19 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_21:
        v22 = *++v12;
        v19 = v22;
      }
      while ((v22 - 33) > 0xFFFFFFDF);
    }
LABEL_22:
    if (v19 == 35)
    {
      ++v12;
      while (1)
      {
        v19 = *v12;
        if (!*v12)
          break;
        v23 = *(v12++ - 1);
        if (v23 == 10)
        {
          --v12;
          if ((v19 - 33) >= 0xFFFFFFE0)
            goto LABEL_21;
          goto LABEL_22;
        }
      }
    }
    v37 = -1;
    do
      v44 = v12[++v37];
    while ((ctype[2 * v44] & 0x40) != 0);
    if (!v44)
      return 0;
    v45 = &v12[v37];
    if ((v44 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_75:
        v46 = *++v45;
        v44 = v46;
      }
      while ((v46 - 33) > 0xFFFFFFDF);
    }
LABEL_76:
    if (v44 == 35)
    {
      v47 = v45;
      while (1)
      {
        v48 = *++v47;
        v44 = v48;
        if (!v48)
          return 0;
        v49 = *v45;
        v45 = v47;
        if (v49 == 10)
        {
          v45 = v47;
          if ((v44 - 33) >= 0xFFFFFFE0)
            goto LABEL_75;
          goto LABEL_76;
        }
      }
    }
    if (v44 != 46)
      return 0;
    v72 = v45[1];
    v71 = v45 + 1;
    v70 = v72;
    if (v72)
    {
      if ((v70 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_127:
          v73 = *(unsigned __int8 *)++v71;
          v70 = v73;
        }
        while ((v73 - 33) > 0xFFFFFFDF);
      }
LABEL_128:
      if (v70 == 35)
      {
        ++v71;
        while (1)
        {
          v70 = *(unsigned __int8 *)v71;
          if (!*v71)
            break;
          v74 = *((unsigned __int8 *)v71++ - 1);
          if (v74 == 10)
          {
            --v71;
            if ((v70 - 33) >= 0xFFFFFFE0)
              goto LABEL_127;
            goto LABEL_128;
          }
        }
      }
    }
    *(_QWORD *)v119 = v71;
    if (strncmp(v71, "xyz", 3uLL))
    {
      if (strncmp(v71, "rgb", 3uLL))
        return 0;
    }
    result = arb::achr((arb *)(v71 + 3), (const char *)0x2C);
    if (!result)
      return result;
    arb::asymbol((arb *)result, v119, (const char **)&v118, v88);
    v90 = v118;
    v89 = *(arb **)v119;
    v91 = arb::obj_search(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(unsigned __int8 **)v119, (const char **)v118);
    if (*((_QWORD *)v91 + 5) != *(_QWORD *)(a1 + 48))
      return 0;
    if (*((_DWORD *)v91 + 14) != *(_DWORD *)(a1 + 56))
      return 0;
    if (*((_BYTE *)v90 + (_QWORD)v89) != 46)
      return 0;
    v92 = *((unsigned __int8 *)v89 + (_QWORD)v90 + 1);
    if (v92 != 119 && v92 != 97)
      return 0;
    result = arb::achr((arb *)((char *)v90 + (_QWORD)v89 + 2), (const char *)0x3B);
    if (!result)
      return result;
    v94 = v20;
  }
  v95 = arb::atok(v94, v93);
  if (strncmp(v95, v12, v37) || (ctype[2 * v95[v37]] & 0x40) != 0)
    return 0;
  result = arb::achr((arb *)&v95[v37], (const char *)0x2E);
  if (result)
  {
    v96 = *result;
    if (v96 != 119 && v96 != 97)
      return 0;
    result = arb::achr((arb *)(result + 1), (const char *)0x2C);
    if (result)
    {
      v97 = result;
      if (strncmp(result, v12, v37) || (ctype[2 * v97[v37]] & 0x40) != 0)
        return 0;
      result = arb::achr((arb *)&v97[v37], (const char *)0x2C);
      if (result)
      {
        if (*result == 120)
        {
          result = arb::achr((arb *)(result + 1), (const char *)0x2C);
          if (!result)
            return result;
          if (*result == 121)
          {
            result = arb::achr((arb *)(result + 1), (const char *)0x2C);
            if (!result)
              return result;
            if (*result == 122)
            {
              result = arb::achr((arb *)(result + 1), (const char *)0x2C);
              if (!result)
                return result;
              if (*result == 49)
              {
                result = arb::achr((arb *)(result + 1), (const char *)0x3B);
                if (!result)
                  return result;
                v98 = result;
                if (!strncmp(result, "MUL", 3uLL))
                {
                  v100 = (arb *)arb::atok(v98 + 3, v99);
                  v102 = arb::asymbol(v100, v119, (const char **)&v118, v101);
                  result = arb::achr((arb *)v102, (const char *)0x2C);
                  if (result)
                  {
                    v104 = (arb *)result;
                    v105 = arb::asymbol((arb *)result, v119, (const char **)&v118, v103);
                    v107 = v118;
                    v106 = *(arb **)v119;
                    result = (char *)arb::isidentity(v104, *(arb **)v119, (const char *)v118, (const char *)v105, (const char *)4);
                    if (result)
                    {
                      v108 = arb::obj_search(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), (unsigned __int8 *)v106, (const char **)v107);
                      if (*((_QWORD *)v108 + 5) != *(_QWORD *)(a1 + 48)
                        || *((_DWORD *)v108 + 14) != *(_DWORD *)(a1 + 56))
                      {
                        return 0;
                      }
                      result = arb::achr((arb *)v105, (const char *)0x2C);
                      if (result)
                      {
                        v109 = result;
                        if (strncmp(result, v12, v37))
                          return 0;
                        if ((ctype[2 * v109[v37]] & 0x40) != 0)
                          return 0;
                        v110 = arb::achr((arb *)&v109[v37], (const char *)0x3B);
                        result = v98;
                        if (!v110)
                          return 0;
LABEL_113:
                        *(_QWORD *)(a1 + 32) = __s1;
                        *(_QWORD *)(a1 + 40) = result;
                        return result;
                      }
                    }
                  }
                  return result;
                }
              }
            }
          }
        }
        return 0;
      }
    }
  }
  return result;
}

unsigned __int8 *arb::aidx(arb *this, char *a2, unsigned int *a3, unsigned int *a4)
{
  int v4;
  int v5;
  arb *v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  char v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;

  v4 = *(unsigned __int8 *)this;
  if (!*(_BYTE *)this)
    return 0;
  if ((v4 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_3:
      v5 = *((unsigned __int8 *)this + 1);
      this = (arb *)((char *)this + 1);
      v4 = v5;
    }
    while ((v5 - 33) > 0xFFFFFFDF);
  }
LABEL_4:
  if (v4 == 35)
  {
    v6 = this;
    while (1)
    {
      v7 = *((unsigned __int8 *)v6 + 1);
      v6 = (arb *)((char *)v6 + 1);
      v4 = v7;
      if (!v7)
        return 0;
      v8 = *(unsigned __int8 *)this;
      this = v6;
      if (v8 == 10)
      {
        this = v6;
        if ((v4 - 33) >= 0xFFFFFFE0)
          goto LABEL_3;
        goto LABEL_4;
      }
    }
  }
  if (v4 != 91)
    return 0;
  v11 = *((unsigned __int8 *)this + 1);
  v9 = (unsigned __int8 *)this + 1;
  v10 = v11;
  if (!v11)
  {
LABEL_21:
    if (a3)
    {
      if (a2)
        *(_DWORD *)a2 = 0;
      goto LABEL_24;
    }
    return 0;
  }
  if ((v10 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_13:
      v12 = *++v9;
      v10 = v12;
    }
    while ((v12 - 33) > 0xFFFFFFDF);
  }
LABEL_14:
  if (v10 == 35)
  {
    ++v9;
    while (1)
    {
      v10 = *v9;
      if (!*v9)
        goto LABEL_21;
      v13 = *(v9++ - 1);
      if (v13 == 10)
      {
        --v9;
        if ((v10 - 33) >= 0xFFFFFFE0)
          goto LABEL_13;
        goto LABEL_14;
      }
    }
  }
  if ((v10 - 58) < 0xFFFFFFF6)
    goto LABEL_21;
  v21 = 0;
  do
  {
    v21 = v10 + 10 * v21 - 48;
    v22 = *++v9;
    v10 = v22;
  }
  while ((v22 - 58) > 0xFFFFFFF5);
  if (v10)
  {
    if ((v10 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_44:
        v23 = *++v9;
        v10 = v23;
      }
      while ((v23 - 33) > 0xFFFFFFDF);
    }
LABEL_45:
    if (v10 == 35)
    {
      ++v9;
      while (1)
      {
        v10 = *v9;
        if (!*v9)
          break;
        v24 = *(v9++ - 1);
        if (v24 == 10)
        {
          --v9;
          if ((v10 - 33) >= 0xFFFFFFE0)
            goto LABEL_44;
          goto LABEL_45;
        }
      }
    }
  }
  if (a2)
    *(_DWORD *)a2 = v21;
  if (!a3)
    goto LABEL_26;
  *a3 = v21;
  v15 = *v9;
  if (v15 == 46)
  {
    if (v9[1] != 46)
      goto LABEL_26;
    v26 = v9[2];
    v9 += 2;
    v25 = v26;
    if (v26)
    {
      v27 = v9;
      if ((v25 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_58:
          v28 = *++v27;
          v25 = v28;
        }
        while ((v28 - 33) > 0xFFFFFFDF);
      }
LABEL_59:
      if (v25 == 35)
      {
        v29 = v27;
        while (1)
        {
          v30 = *++v29;
          v25 = v30;
          if (!v30)
            break;
          v31 = *v27;
          v27 = v29;
          if (v31 == 10)
          {
            v27 = v29;
            if ((v25 - 33) >= 0xFFFFFFE0)
              goto LABEL_58;
            goto LABEL_59;
          }
        }
      }
      else if ((v25 - 58) >= 0xFFFFFFF6)
      {
        v14 = 0;
        do
        {
          v14 = v25 + 10 * v14 - 48;
          v32 = *++v27;
          v25 = v32;
        }
        while ((v32 - 58) > 0xFFFFFFF5);
        if (!v25)
          goto LABEL_77;
        if ((v25 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_70:
            v33 = *++v27;
            v25 = v33;
          }
          while ((v33 - 33) > 0xFFFFFFDF);
        }
LABEL_71:
        if (v25 == 35)
        {
          v9 = v27 + 1;
          while (1)
          {
            v25 = *v9;
            if (!*v9)
              break;
            v34 = *(v9++ - 1);
            if (v34 == 10)
            {
              v27 = v9 - 1;
              if ((v25 - 33) >= 0xFFFFFFE0)
                goto LABEL_70;
              goto LABEL_71;
            }
          }
        }
        else
        {
LABEL_77:
          v9 = v27;
        }
        goto LABEL_25;
      }
    }
LABEL_24:
    v14 = -1;
LABEL_25:
    *a3 = v14;
LABEL_26:
    v15 = *v9;
  }
  if (!v15)
    return 0;
  if ((v15 - 33) >= 0xE0u)
  {
    do
    {
LABEL_29:
      v16 = *++v9;
      LOBYTE(v15) = v16;
    }
    while ((v16 - 33) > 0xDFu);
  }
LABEL_30:
  if (v15 == 35)
  {
    v17 = v9;
    while (1)
    {
      v18 = *++v17;
      LOBYTE(v15) = v18;
      if (!v18)
        return 0;
      v19 = *v9;
      v9 = v17;
      if (v19 == 10)
      {
        v9 = v17;
        if ((v15 - 33) >= 0xE0u)
          goto LABEL_29;
        goto LABEL_30;
      }
    }
  }
  if (v15 == 93)
    return v9 + 1;
  else
    return 0;
}

uint64_t arb::obj_key(char **a1, unsigned __int8 *a2, const char **a3)
{
  char *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  unsigned __int8 *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v18;
  unint64_t v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  char *v26;
  char *v27;
  unsigned __int8 *v29;

  v5 = *a1;
  v6 = (unint64_t)a1[1];
  v7 = (uint64_t)&(*a1)[88 * v6];
  if (!v6)
    goto LABEL_13;
  v8 = (unint64_t)a1[1];
  v9 = *a1;
  while (1)
  {
    v10 = v8 >> 1;
    v29 = a2;
    v11 = (unsigned __int8 *)&v9[88 * (v8 >> 1)];
    v12 = arb::ascan(&v29, a3, v11, (const char *)1);
    if (!v12)
      break;
    if (v12 > 0)
    {
      v13 = v10 + 1;
    }
    else
    {
      v7 = (uint64_t)&v9[88 * (v8 >> 1)];
      v13 = 0;
    }
    v9 += 88 * v13;
    if (v12 <= 0)
      v8 >>= 1;
    else
      v8 -= v10 + 1;
    if (!v8)
      goto LABEL_13;
  }
  if (!v9)
  {
LABEL_13:
    v14 = 0x2E8BA2E8BA2E8BA3 * ((v7 - (uint64_t)v5) >> 3);
    v15 = (unint64_t)a1[2];
    v16 = (v6 & 0xFFFFFFFFFFFFFFF0) + 16;
    if (v6 + 1 > v15 && v15 != v16)
    {
      a1[2] = (char *)v16;
      v26 = (char *)malloc_type_realloc(v5, 88 * v16, 0x10500400A17BEF8uLL);
      v5 = v26;
      *a1 = v26;
      v6 = (unint64_t)a1[1];
      v27 = a1[2];
      if (v6 > (unint64_t)v27)
      {
        a1[1] = v27;
        v6 = (unint64_t)v27;
      }
    }
    if (v6 > v14)
    {
      memmove(&v5[88 * v14 + 88], &v5[88 * v14], 88 * (v6 - v14));
      v5 = *a1;
      v6 = (unint64_t)a1[1];
    }
    a1[1] = (char *)(v6 + 1);
    v11 = (unsigned __int8 *)&v5[88 * v14];
    v18 = 0;
    if (a3)
    {
      v19 = 0;
      do
      {
        v20 = a2[v19];
        if ((v20 - 33) <= 0xFFFFFFDF)
        {
          v11[v18++] = v20;
          v21 = &a2[++v19];
          if (a2[v19] == 35)
          {
LABEL_28:
            v22 = 35;
LABEL_30:
            if (v22 == 35)
            {
              ++v21;
              while (1)
              {
                v22 = *v21;
                if (!*v21)
                  break;
                v24 = *(v21++ - 1);
                if (v24 == 10)
                {
                  --v21;
                  if ((v22 - 33) >= 0xFFFFFFE0)
                  {
                    do
                    {
                      v23 = *++v21;
                      v22 = v23;
                    }
                    while ((v23 - 33) > 0xFFFFFFDF);
                  }
                  goto LABEL_30;
                }
              }
            }
            v19 = v21 - a2;
          }
        }
        else
        {
          v21 = &a2[++v19];
          if (a2[v19] == 35)
            goto LABEL_28;
        }
      }
      while (v19 < (unint64_t)a3);
    }
    v11[v18] = 0;
    v5 = *a1;
  }
  return 0x2E8BA2E8BA2E8BA3 * ((v11 - (unsigned __int8 *)v5) >> 3);
}

_BYTE *arb::achr(arb *this, const char *a2)
{
  char v2;
  char v3;
  int v4;
  _BYTE *result;
  int v6;
  int v7;
  int v8;
  int v9;

  v2 = *(_BYTE *)this;
  if (*(_BYTE *)this)
  {
    if ((v2 - 33) >= 0xE0u)
    {
      do
      {
LABEL_3:
        v3 = *((_BYTE *)this + 1);
        this = (arb *)((char *)this + 1);
        v2 = v3;
      }
      while ((v3 - 33) > 0xDFu);
    }
LABEL_4:
    if (v2 == 35)
    {
      this = (arb *)((char *)this + 1);
      while (1)
      {
        v2 = *(_BYTE *)this;
        if (!*(_BYTE *)this)
          break;
        v4 = *((unsigned __int8 *)this - 1);
        this = (arb *)((char *)this + 1);
        if (v4 == 10)
        {
          this = (arb *)((char *)this - 1);
          if ((v2 - 33) >= 0xE0u)
            goto LABEL_3;
          goto LABEL_4;
        }
      }
    }
  }
  if (v2 != a2)
    return 0;
  v7 = *((unsigned __int8 *)this + 1);
  result = (char *)this + 1;
  v6 = v7;
  if (v7)
  {
    if ((v6 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_13:
        v8 = *++result;
        v6 = v8;
      }
      while ((v8 - 33) > 0xFFFFFFDF);
    }
LABEL_14:
    if (v6 == 35)
    {
      ++result;
      while (1)
      {
        v6 = *result;
        if (!*result)
          break;
        v9 = *(result++ - 1);
        if (v9 == 10)
        {
          --result;
          if ((v6 - 33) >= 0xFFFFFFE0)
            goto LABEL_13;
          goto LABEL_14;
        }
      }
    }
  }
  return result;
}

char *arb::obj_texop(uint64_t a1, char *a2, arb *this, int a4, int8x8_t *a5)
{
  uint64_t v5;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  unint64_t *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  int v20;
  _BYTE *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned __int8 *v28;
  unint64_t *v29;
  int v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v40;
  int v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  int v45;
  unsigned __int8 *v46;
  int v47;
  int v48;
  int v49;
  arb *v50;
  int v51;
  int v52;
  int v53;
  char *v54;
  const char *v55;
  BOOL v56;
  int v57;
  void *v58;
  const char *v59;
  int v60;
  const char *v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  char *v67;
  int v68;
  int v69;
  int v70;
  unint64_t *v71;
  char *v72;
  unsigned __int8 *v73;
  unint64_t *v74;
  int v75;
  int v76;
  unsigned __int8 *v77;
  int v78;
  int v79;
  int v80;
  arb *v81;
  int v82;
  int v83;
  int v84;
  unsigned __int8 *v85;
  int v86;
  int v87;
  unsigned __int8 *v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  unsigned int *v95;
  arb *v96;
  unsigned __int8 *v97;
  char *v98;
  void *v99;
  uint64_t v102;
  _BYTE *v103;
  const char *v104;
  const char *v105;
  int v106;
  int v107;
  arb *v108;
  _BYTE *v109;
  int *v110;
  arb *v111;
  unsigned __int8 *v112;
  char v113[4];
  char *v114;
  char v115[8];
  char **v116;
  char *__s1;
  char *v118;
  char **v119;

  v5 = 1;
  if (*((_BYTE *)this + 1) == 69)
    v5 = 2;
  v119 = (char **)v5;
  if (*((_BYTE *)this + v5) != 88)
    return 0;
  __s1 = 0;
  v118 = 0;
  v116 = 0;
  v10 = (unsigned __int8 *)this + 2;
  v11 = *((unsigned __int8 *)this + 2);
  v12 = arb::isssat(this, a2);
  do
  {
    v15 = *++v10;
    v14 = v15;
  }
  while ((ctype[2 * v15] & 0x40) != 0);
  if (v11 == 88)
    v16 = a4;
  else
    v16 = 0;
  v112 = v12;
  if (v14)
  {
    if ((v14 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_11:
        v17 = *++v10;
        v14 = v17;
      }
      while ((v17 - 33) > 0xFFFFFFDF);
    }
LABEL_12:
    if (v14 == 35)
    {
      ++v10;
      while (1)
      {
        v14 = *v10;
        if (!*v10)
          break;
        v18 = *(v10++ - 1);
        if (v18 == 10)
        {
          --v10;
          if ((v14 - 33) >= 0xFFFFFFE0)
            goto LABEL_11;
          goto LABEL_12;
        }
      }
    }
    else
    {
      while (v14 == 46)
      {
        v22 = v10[1];
        v21 = v10 + 1;
        v20 = v22;
        if (v22)
        {
          if ((v20 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_21:
              v23 = *++v21;
              v20 = v23;
            }
            while ((v23 - 33) > 0xFFFFFFDF);
          }
LABEL_22:
          if (v20 == 35)
          {
            ++v21;
            while (1)
            {
              v20 = *v21;
              if (!*v21)
                break;
              v24 = *(v21++ - 1);
              if (v24 == 10)
              {
                --v21;
                if ((v20 - 33) >= 0xFFFFFFE0)
                  goto LABEL_21;
                goto LABEL_22;
              }
            }
          }
        }
        v10 = v21 - 1;
        do
        {
          v25 = *++v10;
          v14 = v25;
        }
        while ((ctype[2 * v25] & 0x40) != 0);
        if (!v14)
          break;
        if ((v14 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_32:
            v26 = *++v10;
            v14 = v26;
          }
          while ((v26 - 33) > 0xFFFFFFDF);
        }
LABEL_33:
        if (v14 == 35)
        {
          ++v10;
          while (1)
          {
            v14 = *v10;
            if (!*v10)
              goto LABEL_40;
            v27 = *(v10++ - 1);
            if (v27 == 10)
            {
              --v10;
              if ((v14 - 33) >= 0xFFFFFFE0)
                goto LABEL_32;
              goto LABEL_33;
            }
          }
        }
      }
    }
  }
LABEL_40:
  v28 = arb::asymbol((arb *)v10, (char *)&v118, (const char **)&v116, v13);
  v30 = *v28;
  if (!*v28)
    goto LABEL_93;
  v31 = v28;
LABEL_42:
  if ((v30 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      v32 = *++v31;
      v30 = v32;
    }
    while ((v32 - 33) > 0xFFFFFFDF);
  }
  if (v30 == 35)
  {
    v33 = v31;
    while (1)
    {
      v34 = *++v31;
      v30 = v34;
      if (!v34)
        goto LABEL_93;
      v35 = *v33;
      v33 = v31;
      if (v35 == 10)
        goto LABEL_42;
    }
  }
  if (v30 != 40)
    goto LABEL_74;
  while (1)
  {
    if (v30 != 35)
    {
      v38 = *++v31;
      v30 = v38;
      goto LABEL_60;
    }
LABEL_53:
    if (v30 == 35)
      break;
LABEL_60:
    if (v30 == 41 || v30 == 0)
      goto LABEL_65;
  }
  ++v31;
  while (1)
  {
    v30 = *v31;
    if (!*v31)
      break;
    v37 = *(v31++ - 1);
    if (v37 == 10)
    {
      --v31;
      if ((v30 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          v36 = *++v31;
          v30 = v36;
        }
        while ((v36 - 33) > 0xFFFFFFDF);
      }
      goto LABEL_53;
    }
  }
LABEL_65:
  v40 = *++v31;
  v30 = v40;
  if (v40)
  {
    if ((v30 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_67:
        v41 = *++v31;
        v30 = v41;
      }
      while ((v41 - 33) > 0xFFFFFFDF);
    }
LABEL_68:
    if (v30 == 35)
    {
      v42 = v31;
      while (1)
      {
        v43 = *++v42;
        v30 = v43;
        if (!v43)
          goto LABEL_93;
        v44 = *v31;
        v31 = v42;
        if (v44 == 10)
        {
          v31 = v42;
          if ((v30 - 33) >= 0xFFFFFFE0)
            goto LABEL_67;
          goto LABEL_68;
        }
      }
    }
LABEL_74:
    if (!v30)
      goto LABEL_93;
    if ((v30 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_76:
        v45 = *++v31;
        v30 = v45;
      }
      while ((v45 - 33) > 0xFFFFFFDF);
    }
LABEL_77:
    if (v30 == 35)
    {
      v46 = v31;
      while (1)
      {
        v47 = *++v46;
        v30 = v47;
        if (!v47)
          goto LABEL_93;
        v48 = *v31;
        v31 = v46;
        if (v48 == 10)
        {
          v31 = v46;
          if ((v30 - 33) >= 0xFFFFFFE0)
            goto LABEL_76;
          goto LABEL_77;
        }
      }
    }
    if (v30 != 44)
      goto LABEL_93;
    v51 = v31[1];
    v50 = (arb *)(v31 + 1);
    v49 = v51;
    if (v51)
    {
      if ((v49 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_86:
          v52 = *((unsigned __int8 *)v50 + 1);
          v50 = (arb *)((char *)v50 + 1);
          v49 = v52;
        }
        while ((v52 - 33) > 0xFFFFFFDF);
      }
LABEL_87:
      if (v49 == 35)
      {
        v50 = (arb *)((char *)v50 + 1);
        while (1)
        {
          v49 = *(unsigned __int8 *)v50;
          if (!*(_BYTE *)v50)
            break;
          v53 = *((unsigned __int8 *)v50 - 1);
          v50 = (arb *)((char *)v50 + 1);
          if (v53 == 10)
          {
            v50 = (arb *)((char *)v50 - 1);
            if ((v49 - 33) >= 0xFFFFFFE0)
              goto LABEL_86;
            goto LABEL_87;
          }
        }
      }
    }
  }
  else
  {
LABEL_93:
    v50 = 0;
  }
  v114 = 0;
  *(_QWORD *)v115 = 0;
  v54 = (char *)arb::asymbol(v50, v115, (const char **)&v114, v29);
  v55 = v54;
  if (v11 == 81)
  {
    v16 = 0;
    v56 = 1;
    v57 = *v54;
    if (!*v54)
      goto LABEL_122;
LABEL_100:
    v59 = v55;
    if ((v57 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_101:
        v60 = *(unsigned __int8 *)++v59;
        v57 = v60;
      }
      while ((v60 - 33) > 0xFFFFFFDF);
    }
LABEL_102:
    if (v57 == 35)
    {
      v61 = v59;
      while (1)
      {
        v62 = *(unsigned __int8 *)++v61;
        v57 = v62;
        if (!v62)
          goto LABEL_122;
        v63 = *(unsigned __int8 *)v59;
        v59 = v61;
        if (v63 == 10)
        {
          v59 = v61;
          if ((v57 - 33) >= 0xFFFFFFE0)
            goto LABEL_101;
          goto LABEL_102;
        }
      }
    }
    if (v57 != 44)
      goto LABEL_122;
    v68 = *((unsigned __int8 *)v59 + 1);
    v67 = (char *)(v59 + 1);
    v66 = v68;
    if (v68)
    {
      if ((v66 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_115:
          v69 = *++v67;
          v66 = v69;
        }
        while ((v69 - 33) > 0xFFFFFFDF);
      }
LABEL_116:
      if (v66 == 35)
      {
        ++v67;
        while (1)
        {
          v66 = *v67;
          if (!*v67)
            break;
          v70 = *(v67++ - 1);
          if (v70 == 10)
          {
            --v67;
            if ((v66 - 33) >= 0xFFFFFFE0)
              goto LABEL_115;
            goto LABEL_116;
          }
        }
      }
    }
  }
  else
  {
    if (v50 != *(arb **)v115
      || (v58 = v54, &v114[(_QWORD)v50] != v54)
      && (v64 = strncmp(v54 - 4, "xyzw", 4uLL), v58 = (void *)v55, v64)
      && (v65 = strncmp(v55 - 4, "rgba", 4uLL), v58 = (void *)v55, v65))
    {
      v58 = 0;
    }
    v56 = v58 != 0;
    v57 = *(unsigned __int8 *)v55;
    if (*v55)
      goto LABEL_100;
LABEL_122:
    v67 = 0;
  }
  v72 = arb::obj_add(a1, *(char **)v115, (const char **)v114, (uint64_t)a5, 0);
  if (v11 != 68)
  {
LABEL_165:
    if (strncmp(v67, "texture", 7uLL))
      goto LABEL_177;
LABEL_166:
    v96 = (arb *)(v67 + 7);
    *(_DWORD *)a2 = 0;
    v97 = arb::aidx(v96, a2, 0, v95);
    if (!v97)
      v97 = (unsigned __int8 *)v96;
    if (a5)
    {
      a5->i32[1] |= 1 << *(_DWORD *)a2;
      if (*(_DWORD *)a2 >= a5[5].u8[0])
        a5[5].i8[0] = *(_DWORD *)a2 + 1;
    }
    if (!v72 || *((_UNKNOWN **)v72 + 5) != &fragmentKind)
    {
      if (a5)
        v56 = 0;
      goto LABEL_177;
    }
    v102 = *((_QWORD *)v72 + 8);
    if (v16)
    {
      if (v102)
      {
LABEL_195:
        v56 = 0;
        LOBYTE(v16) = 1;
        goto LABEL_177;
      }
      if (*(_DWORD *)a2 == *((_DWORD *)v72 + 14))
      {
        if (a5)
        {
          v103 = arb::achr((arb *)v97, (const char *)0x2C);
          v105 = arb::atok(v103, v104);
          if (strncmp(v105, "RECT", 4uLL))
          {
            LOBYTE(v16) = 0;
            goto LABEL_177;
          }
          if (!arb::isidentity(v50, *(arb **)v115, v114, v55, (const char *)2))
            goto LABEL_195;
          v108 = (arb *)arb::achr((arb *)(v105 + 4), (const char *)0x2C);
          if (v108)
          {
            v109 = arb::achr(v108, (const char *)0x28);
            if (v109)
            {
              *(_DWORD *)v113 = 0;
              do
              {
                v111 = (arb *)arb::atoi(v109, v113, v110);
                if (!v111)
                  break;
                if (*(_DWORD *)v113)
                  goto LABEL_195;
                v109 = arb::achr(v111, (const char *)0x2C);
              }
              while (v109);
            }
          }
        }
        LOBYTE(v16) = 1;
        goto LABEL_177;
      }
    }
    else if (v102)
    {
      LOBYTE(v16) = 0;
      v56 = 0;
      goto LABEL_177;
    }
    v56 = 0;
    if (a5)
    {
      v106 = *((_DWORD *)v72 + 14);
      if (*(_DWORD *)a2 != v106)
      {
        v56 = 0;
        v107 = 1 << v106;
        a5[1] = vand_s8(a5[1], (int8x8_t)vdup_n_s32(~v107));
        a5[2].i32[0] &= ~v107;
      }
    }
    goto LABEL_177;
  }
  if (!a5)
    goto LABEL_176;
  v73 = arb::asymbol((arb *)v67, (char *)&__s1, (const char **)&v119, v71);
  arb::obj_add(a1, __s1, (const char **)v119, (uint64_t)a5, 1);
  v75 = *v73;
  if (!*v73)
    goto LABEL_144;
  if ((v75 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_127:
      v76 = *++v73;
      v75 = v76;
    }
    while ((v76 - 33) > 0xFFFFFFDF);
  }
LABEL_128:
  if (v75 == 35)
  {
    v77 = v73;
    while (1)
    {
      v78 = *++v77;
      v75 = v78;
      if (!v78)
        break;
      v79 = *v73;
      v73 = v77;
      if (v79 == 10)
      {
        v73 = v77;
        if ((v75 - 33) >= 0xFFFFFFE0)
          goto LABEL_127;
        goto LABEL_128;
      }
    }
LABEL_144:
    v81 = 0;
  }
  else
  {
    if (v75 != 44)
      goto LABEL_144;
    v82 = v73[1];
    v81 = (arb *)(v73 + 1);
    v80 = v82;
    if (v82)
    {
      if ((v80 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_137:
          v83 = *((unsigned __int8 *)v81 + 1);
          v81 = (arb *)((char *)v81 + 1);
          v80 = v83;
        }
        while ((v83 - 33) > 0xFFFFFFDF);
      }
LABEL_138:
      if (v80 == 35)
      {
        v81 = (arb *)((char *)v81 + 1);
        while (1)
        {
          v80 = *(unsigned __int8 *)v81;
          if (!*(_BYTE *)v81)
            break;
          v84 = *((unsigned __int8 *)v81 - 1);
          v81 = (arb *)((char *)v81 + 1);
          if (v84 == 10)
          {
            v81 = (arb *)((char *)v81 - 1);
            if ((v80 - 33) >= 0xFFFFFFE0)
              goto LABEL_137;
            goto LABEL_138;
          }
        }
      }
    }
  }
  v85 = arb::asymbol(v81, (char *)&__s1, (const char **)&v119, v74);
  arb::obj_add(a1, __s1, (const char **)v119, (uint64_t)a5, 1);
  v86 = *v85;
  if (!*v85)
  {
LABEL_164:
    v16 = 0;
    v67 = 0;
    goto LABEL_165;
  }
  if ((v86 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_147:
      v87 = *++v85;
      v86 = v87;
    }
    while ((v87 - 33) > 0xFFFFFFDF);
  }
LABEL_148:
  if (v86 == 35)
  {
    v88 = v85;
    while (1)
    {
      v89 = *++v88;
      v86 = v89;
      if (!v89)
        goto LABEL_164;
      v90 = *v85;
      v85 = v88;
      if (v90 == 10)
      {
        v85 = v88;
        if ((v86 - 33) >= 0xFFFFFFE0)
          goto LABEL_147;
        goto LABEL_148;
      }
    }
  }
  if (v86 != 44)
    goto LABEL_164;
  v92 = v85[1];
  v67 = (char *)(v85 + 1);
  v91 = v92;
  if (v92)
  {
    if ((v91 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_157:
        v93 = *++v67;
        v91 = v93;
      }
      while ((v93 - 33) > 0xFFFFFFDF);
    }
LABEL_158:
    if (v91 == 35)
    {
      ++v67;
      while (1)
      {
        v91 = *v67;
        if (!*v67)
          break;
        v94 = *(v67++ - 1);
        if (v94 == 10)
        {
          --v67;
          if ((v91 - 33) >= 0xFFFFFFE0)
            goto LABEL_157;
          goto LABEL_158;
        }
      }
    }
  }
LABEL_176:
  v16 = 0;
  if (!strncmp(v67, "texture", 7uLL))
    goto LABEL_166;
LABEL_177:
  v19 = v118;
  if (v118)
  {
    v98 = arb::obj_add(a1, v118, (const char **)v116, (uint64_t)a5, 1);
    if (a5)
    {
      if (v98)
      {
        v99 = (void *)*((_QWORD *)v98 + 5);
        *(_QWORD *)(a1 + 48) = v99;
        *(_DWORD *)(a1 + 56) = *((_DWORD *)v98 + 14);
        if (v99 == &outputKind && v112 != 0)
          *(_DWORD *)(a1 + 60) = 1;
LABEL_186:
        if (v56)
        {
          if ((v16 & 1) != 0)
          {
LABEL_191:
            a5[2].i32[0] &= ~(1 << *(_DWORD *)a2);
            return v19;
          }
        }
        else
        {
          a5[1].i32[0] &= ~(1 << *(_DWORD *)a2);
        }
        a5[1].i32[1] &= ~(1 << *(_DWORD *)a2);
        goto LABEL_191;
      }
    }
  }
  if (a5)
    goto LABEL_186;
  return v19;
}

uint64_t arb::alen(arb *this, const char *a2)
{
  BOOL v3;
  const char *v4;
  int v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  arb *v11;
  uint64_t v12;
  char v13;
  const char *v14;
  const char *v15;
  arb *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  char *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  const char *v31;
  int v32;
  unsigned __int8 *v33;
  int v34;
  unsigned __int8 *v35;
  int v36;
  int v37;
  char v38;
  char v39;

  v3 = *(unsigned __int8 *)this - 48 < 0xA || (ctype[2 * *(unsigned __int8 *)this] & 0x40) == 0;
  v4 = (const char *)this;
  if (!v3)
  {
    v5 = (int)a2;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = "state";
    v10 = "texgen";
    v11 = this;
    v4 = (const char *)this;
    while (1)
    {
      v12 = 0;
      do
        v13 = ctype[2 * v4[++v12]];
      while ((v13 & 0x40) != 0);
      if (!v12)
        return v4 - (const char *)this;
      if (v7)
      {
        v14 = v10;
        v15 = v9;
        if (!strncmp(v4, "eye", 3uLL))
        {
          v7 = 0;
          v6 = v4 + 3;
          v16 = (arb *)&v4[v12];
          v17 = v4[v12];
          if (!v4[v12])
            goto LABEL_76;
        }
        else
        {
          v18 = strncmp(v4, "object", 6uLL);
          v7 = 0;
          if (v18)
            v6 = 0;
          else
            v6 = v4 + 6;
          v16 = (arb *)&v4[v12];
          v17 = v4[v12];
          if (!v4[v12])
            goto LABEL_76;
        }
      }
      else if (v8)
      {
        v15 = v9;
        v14 = v10;
        v19 = strncmp(v4, v10, 6uLL);
        v8 = 0;
        v7 = v4 + 6;
        if (v19)
          v7 = 0;
        v16 = (arb *)&v4[v12];
        v17 = v4[v12];
        if (!v4[v12])
        {
LABEL_76:
          v31 = (const char *)v16;
          goto LABEL_72;
        }
      }
      else
      {
        v14 = v10;
        if (v11 == this)
        {
          v15 = v9;
          v20 = strncmp(v4, v9, 5uLL);
          v7 = 0;
          if (v20)
            v8 = 0;
          else
            v8 = v4 + 5;
          v16 = (arb *)&v4[v12];
          v17 = v4[v12];
          if (!v4[v12])
            goto LABEL_76;
        }
        else
        {
          v15 = v9;
          v8 = 0;
          v7 = 0;
          v16 = (arb *)&v4[v12];
          v17 = v4[v12];
          if (!v4[v12])
            goto LABEL_76;
        }
      }
      v21 = (unsigned __int8 *)v16;
      while (1)
      {
        v11 = v16;
        v22 = v17;
        v16 = (arb *)v21;
        if ((v17 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_32:
            v23 = *((unsigned __int8 *)v16 + 1);
            v16 = (arb *)((char *)v16 + 1);
            v22 = v23;
          }
          while ((v23 - 33) > 0xFFFFFFDF);
        }
LABEL_33:
        v24 = (char *)v16;
        if (v22 == 35)
          break;
        if (v22 != 91)
          goto LABEL_52;
        do
        {
          v28 = *++v24;
          v27 = v28;
          if (!v28)
            break;
          if ((v27 - 33) >= 0xFFFFFFE0)
          {
            do
            {
LABEL_41:
              v29 = *++v24;
              v27 = v29;
            }
            while ((v29 - 33) > 0xFFFFFFDF);
          }
LABEL_42:
          if (v27 == 35)
          {
            ++v24;
            while (1)
            {
              v27 = *v24;
              if (!*v24)
                goto LABEL_50;
              v30 = *(v24++ - 1);
              if (v30 == 10)
              {
                --v24;
                if ((v27 - 33) >= 0xFFFFFFE0)
                  goto LABEL_41;
                goto LABEL_42;
              }
            }
          }
        }
        while (v27 && v27 != 93);
LABEL_50:
        v32 = v24[1];
        v31 = v24 + 1;
        v17 = v32;
        v21 = (unsigned __int8 *)v31;
        if (!v32)
          goto LABEL_72;
      }
      while (1)
      {
        v25 = *++v24;
        v22 = v25;
        if (!v25)
          break;
        v26 = *(unsigned __int8 *)v16;
        v16 = (arb *)v24;
        if (v26 == 10)
        {
          v16 = (arb *)v24;
          if ((v22 - 33) >= 0xFFFFFFE0)
            goto LABEL_32;
          goto LABEL_33;
        }
      }
LABEL_52:
      v33 = v21;
      if ((v17 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_53:
          v34 = *++v33;
          v17 = v34;
        }
        while ((v34 - 33) > 0xFFFFFFDF);
      }
LABEL_54:
      if (v17 == 35)
      {
        v35 = v33;
        while (1)
        {
          v36 = *++v35;
          v17 = v36;
          if (!v36)
            break;
          v37 = *v33;
          v33 = v35;
          if (v37 == 10)
          {
            v33 = v35;
            if ((v17 - 33) >= 0xFFFFFFE0)
              goto LABEL_53;
            goto LABEL_54;
          }
        }
LABEL_71:
        v31 = (const char *)v21;
        v16 = v11;
LABEL_72:
        if (v5)
          v4 = v31;
        else
          v4 = (const char *)v16;
        return v4 - (const char *)this;
      }
      if (v17 != 46)
        goto LABEL_71;
      v4 = (const char *)(v33 + 1);
      v38 = ctype[2 * v33[1]];
      if (!v6 && (ctype[2 * v33[1]] & 0x20) != 0)
      {
        v39 = ctype[2 * v33[2]];
        if ((v39 & 0x20) != 0)
        {
          v39 = ctype[2 * v33[3]];
          if ((v39 & 0x20) != 0)
          {
            v39 = ctype[2 * v33[4]];
            if ((v39 & 0x20) != 0)
              v39 = ctype[2 * v33[5]];
          }
        }
        if ((v39 & 0x40) == 0)
        {
          if (v5)
            v4 = (const char *)v21;
          else
            v4 = (const char *)v11;
          return v4 - (const char *)this;
        }
      }
      if (v33[1] - 48 >= 0xA)
      {
        v9 = v15;
        v10 = v14;
        if ((v38 & 0x40) != 0)
          continue;
      }
      return v4 - (const char *)this;
    }
  }
  return v4 - (const char *)this;
}

unsigned __int8 *arb::obj_declare(char **a1, unint64_t *a2, _BYTE *a3, const void *a4, size_t __n, signed int *a6, arb *this, uint64_t a8, uint64_t a9)
{
  uint64_t v14;
  int v15;
  arb *v16;
  int v17;
  arb *v18;
  int v19;
  int v20;
  int v21;
  _BYTE *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v27;
  int v28;
  unint64_t v29;
  signed int v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  _BYTE *v36;
  unsigned int *v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  int v40;
  void *v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  char *v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  unsigned __int8 *v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  BOOL v60;
  unint64_t v61;
  signed int v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char *v66;
  char *v67;
  char *v68;
  size_t v69;
  int v70;
  const char *v71;
  const char *v72;
  unint64_t v73;
  signed int v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  unint64_t *v79;
  char *v80;
  uint64_t v81;
  unsigned __int8 *v82;
  char *v83;
  unint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  int v89;
  unsigned int v90;
  int v91;
  int v92;
  int v93;
  unint64_t *v94;
  uint64_t v95;
  size_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  signed int v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  size_t v109;
  unint64_t v110;
  signed int v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  char *v115;
  char *v116;
  unsigned __int8 *v117;
  char *v118;
  unint64_t v119;
  uint64_t v120;
  const char *v121;
  const char *v122;
  const char *v123;
  const char *v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  char *v129;
  char *v130;
  char *v131;
  unint64_t v132;
  int v133;
  uint64_t v134;
  int v135;
  int v136;
  int v137;
  unsigned __int8 *v138;
  size_t v140;
  size_t v142;
  uint64_t v143;
  signed int v144;
  char v147[8];

  *(_QWORD *)v147 = 0;
  v14 = *(unsigned __int8 *)this;
  if (*(_BYTE *)this)
  {
    v15 = *(unsigned __int8 *)this;
    v16 = this;
    if ((v14 - 33) < 0xFFFFFFE0)
      goto LABEL_4;
    do
    {
LABEL_3:
      v17 = *((unsigned __int8 *)v16 + 1);
      v16 = (arb *)((char *)v16 + 1);
      v15 = v17;
    }
    while ((v17 - 33) > 0xFFFFFFDF);
LABEL_4:
    while (v15 == 35)
    {
      v18 = v16;
      do
      {
        v19 = *((unsigned __int8 *)v18 + 1);
        v18 = (arb *)((char *)v18 + 1);
        v15 = v19;
        if (!v19)
          goto LABEL_20;
        v20 = *(unsigned __int8 *)v16;
        v16 = v18;
      }
      while (v20 != 10);
      v16 = v18;
      if ((v15 - 33) >= 0xFFFFFFE0)
        goto LABEL_3;
    }
    if (v15 == 123)
    {
      v23 = *((unsigned __int8 *)v16 + 1);
      v22 = (char *)v16 + 1;
      v21 = v23;
      if (v23)
      {
        if ((v21 - 33) < 0xFFFFFFE0)
          goto LABEL_14;
        do
        {
LABEL_13:
          v24 = *++v22;
          v21 = v24;
        }
        while ((v24 - 33) > 0xFFFFFFDF);
LABEL_14:
        while (v21 == 35)
        {
          ++v22;
          do
          {
            v21 = *v22;
            if (!*v22)
              goto LABEL_199;
            v25 = *(v22++ - 1);
          }
          while (v25 != 10);
          --v22;
          if ((v21 - 33) >= 0xFFFFFFE0)
            goto LABEL_13;
        }
        if (v21)
        {
          do
          {
            while (1)
            {
              if ((v21 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  v135 = *++v22;
                  v21 = v135;
                }
                while ((v135 - 33) > 0xFFFFFFDF);
              }
              if (v21 != 35)
                break;
              ++v22;
              do
              {
                v21 = *v22;
                if (!*v22)
                  goto LABEL_199;
                v137 = *(v22++ - 1);
              }
              while (v137 != 10);
              --v22;
            }
            if (!v21)
              break;
            if (v21 == 125)
              break;
            v136 = *++v22;
            v21 = v136;
          }
          while (v136);
        }
      }
LABEL_199:
      v125 = *a2;
      v144 = *a6;
      v126 = (unint64_t)a1[1];
      v127 = (unint64_t)a1[2];
      if (v126 + 1 <= v127)
      {
        v129 = *a1;
      }
      else
      {
        v128 = (v126 & 0xFFFFFFFFFFFFFFF0) + 16;
        v129 = *a1;
        if (v127 != v128)
        {
          a1[2] = (char *)v128;
          v129 = (char *)malloc_type_realloc(v129, 88 * v128, 0x10500400A17BEF8uLL);
          *a1 = v129;
          v126 = (unint64_t)a1[1];
          v130 = a1[2];
          if (v126 > (unint64_t)v130)
          {
            a1[1] = v130;
            v126 = (unint64_t)v130;
          }
        }
      }
      if (v126 > v125)
      {
        memmove(&v129[88 * v125 + 88], &v129[88 * v125], 88 * (v126 - v125));
        v129 = *a1;
        v126 = (unint64_t)a1[1];
      }
      v39 = v22 + 1;
      a1[1] = (char *)(v126 + 1);
      v131 = &v129[88 * v125];
      memcpy(v131, a4, __n);
      if (v144 != -1)
      {
        v131[__n] = 91;
        __n += itoa(&v131[__n + 1], v144) + 2;
        v131[__n - 1] = 93;
      }
      v131[__n] = 0;
      v132 = (*a2)++;
      v133 = *(unsigned __int16 *)(a9 + 20);
      v134 = (uint64_t)&(*a1)[88 * v132];
      *(_QWORD *)(v134 + 40) = &constantKind;
      *(_QWORD *)(v134 + 48) = 2;
      *(_DWORD *)(v134 + 56) = v133;
      *(_QWORD *)(v134 + 64) = this;
      *(_QWORD *)(v134 + 72) = v39 - (unsigned __int8 *)this;
      *(_QWORD *)(v134 + 80) = a8;
      ++*a6;
      *(_WORD *)(a9 + 20) = v133 + 1;
      return v39;
    }
  }
LABEL_20:
  if ((v14 - 48) < 0xA || (ctype[2 * v14] & 0x40) == 0)
  {
    v27 = 0;
    do
      v28 = (char)ctype[2 * *((unsigned __int8 *)this + v27++)];
    while (v28 < 0);
    v29 = *a2;
    v30 = *a6;
    v31 = (unint64_t)a1[1];
    v32 = (unint64_t)a1[2];
    if (v31 + 1 <= v32)
    {
      v34 = *a1;
    }
    else
    {
      v33 = (v31 & 0xFFFFFFFFFFFFFFF0) + 16;
      v34 = *a1;
      if (v32 != v33)
      {
        a1[2] = (char *)v33;
        v34 = (char *)malloc_type_realloc(v34, 88 * v33, 0x10500400A17BEF8uLL);
        *a1 = v34;
        v31 = (unint64_t)a1[1];
        v35 = a1[2];
        if (v31 > (unint64_t)v35)
        {
          a1[1] = v35;
          v31 = (unint64_t)v35;
        }
      }
    }
    if (v31 > v29)
    {
      memmove(&v34[88 * v29 + 88], &v34[88 * v29], 88 * (v31 - v29));
      v34 = *a1;
      v31 = (unint64_t)a1[1];
    }
    v39 = (unsigned __int8 *)this + v27 - 1;
    a1[1] = (char *)(v31 + 1);
    v45 = &v34[88 * v29];
    memcpy(v45, a4, __n);
    if (v30 != -1)
    {
      v45[__n] = 91;
      __n += itoa(&v45[__n + 1], v30) + 2;
      v45[__n - 1] = 93;
    }
    v45[__n] = 0;
    v46 = (*a2)++;
    v47 = *(unsigned __int16 *)(a9 + 20);
    v48 = (uint64_t)&(*a1)[88 * v46];
    *(_QWORD *)(v48 + 40) = &constantKind;
    *(_QWORD *)(v48 + 48) = 2;
    *(_DWORD *)(v48 + 56) = v47;
    *(_QWORD *)(v48 + 64) = this;
    *(_QWORD *)(v48 + 72) = v27 - 1;
    *(_QWORD *)(v48 + 80) = a8;
    ++*a6;
    *(_WORD *)(a9 + 20) = v47 + 1;
    return v39;
  }
  v143 = arb::alen(this, 0);
  v36 = (char *)this + v143;
  v38 = arb::aidx((arb *)((char *)this + v143), &v147[4], (unsigned int *)v147, v37);
  if (!v38)
  {
    v42 = 0;
    v49 = 0;
    *(_QWORD *)v147 = 0;
    v39 = (unsigned __int8 *)this + v143;
    v41 = a3;
    goto LABEL_82;
  }
  v39 = v38;
  v40 = *v38;
  v41 = a3;
  if (!*v38)
    goto LABEL_81;
  v42 = v38;
  if ((v40 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_34:
      v43 = *++v42;
      v40 = v43;
    }
    while ((v43 - 33) > 0xFFFFFFDF);
  }
LABEL_35:
  if (v40 == 35)
  {
    ++v42;
    while (1)
    {
      v40 = *v42;
      if (!*v42)
        goto LABEL_52;
      v44 = *(v42++ - 1);
      if (v44 == 10)
      {
        --v42;
        if ((v40 - 33) >= 0xFFFFFFE0)
          goto LABEL_34;
        goto LABEL_35;
      }
    }
  }
  if (v40 <= 58)
  {
    if (!v40)
    {
LABEL_52:
      v39 = v42;
      v49 = v42;
      goto LABEL_82;
    }
    if (v40 != 44)
      goto LABEL_56;
LABEL_55:
    v49 = 0;
    v42 = v38;
    goto LABEL_82;
  }
  if (v40 == 59 || v40 == 125)
    goto LABEL_55;
LABEL_56:
  v50 = 0;
  v39 = v42;
  while (1)
  {
    if (!(_DWORD)v50)
    {
      v51 = 0;
      v42 = v39;
      v49 = v39;
      switch(v40)
      {
        case '#':
          goto LABEL_69;
        case '$':
        case '%':
        case '&':
        case '\'':
        case '*':
        case '+':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '\\':
          goto LABEL_77;
        case '(':
        case '[':
          goto LABEL_76;
        case ')':
        case ']':
          goto LABEL_64;
        case ',':
        case ';':
          goto LABEL_82;
        default:
          if (v40 == 123)
            goto LABEL_76;
          if (v40 == 125)
            goto LABEL_81;
          goto LABEL_77;
      }
    }
    if (v40 <= 90)
      break;
    v51 = v50;
    switch(v40)
    {
      case '[':
      case '{':
        goto LABEL_76;
      case '\\':
      case '^':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '|':
        break;
      case ']':
      case '}':
        goto LABEL_64;
      default:
        goto LABEL_80;
    }
LABEL_77:
    v54 = *++v39;
    v40 = v54;
    v50 = v51;
LABEL_78:
    v42 = v39;
    v49 = v39;
    if (!v40)
      goto LABEL_82;
  }
  if (v40 != 35)
  {
    if (v40 == 40)
    {
LABEL_76:
      v51 = (v50 + 1);
    }
    else if (v40 == 41)
    {
LABEL_64:
      v51 = (v50 - 1);
    }
    else
    {
LABEL_80:
      v51 = v50;
    }
    goto LABEL_77;
  }
LABEL_69:
  if ((v40 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      v53 = *++v39;
      v40 = v53;
    }
    while ((v53 - 33) > 0xFFFFFFDF);
  }
  if (v40 != 35)
    goto LABEL_78;
  ++v39;
  while (1)
  {
    v40 = *v39;
    if (!*v39)
      break;
    v52 = *(v39++ - 1);
    if (v52 == 10)
    {
      --v39;
      goto LABEL_69;
    }
  }
LABEL_81:
  v42 = v39;
  v49 = v39;
LABEL_82:
  if (v41 == &paramKind)
  {
    if (!v49)
    {
      if (strncmp((const char *)this, "program", 7uLL)
        || (v121 = arb::achr((arb *)((char *)this + 7), (const char *)0x2E)) == 0
        || strncmp(v121, "local", 5uLL))
      {
        if (!strncmp((const char *)this, "state", 5uLL)
          && (v122 = arb::achr((arb *)((char *)this + 5), (const char *)0x2E)) != 0
          && !strncmp(v122, "matrix", 6uLL))
        {
          if (strncmp((const char *)this + v143 - 3, "row", 3uLL))
          {
            *(_DWORD *)v147 = 3;
            *(_DWORD *)&v147[4] = 0;
            a8 |= 0x10uLL;
            if (v42)
              v39 = v42;
          }
        }
        else
        {
          v89 = *(_DWORD *)&v147[4];
          if (!v42)
            v89 = -1;
          *(_DWORD *)&v147[4] = v89;
        }
        *(_DWORD *)(a9 + 4) |= 0x8000000u;
LABEL_133:
        v90 = *(_DWORD *)&v147[4];
        if (*(_DWORD *)&v147[4] != -1)
        {
LABEL_134:
          if ((a8 & 0x10) == 0)
          {
            v91 = *v36;
            if (*v36)
            {
              if ((v91 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_137:
                  v92 = *++v36;
                  v91 = v92;
                }
                while ((v92 - 33) > 0xFFFFFFDF);
              }
LABEL_138:
              if (v91 == 35)
              {
                ++v36;
                while (1)
                {
                  v91 = *v36;
                  if (!*v36)
                    break;
                  v93 = *(v36++ - 1);
                  if (v93 == 10)
                  {
                    --v36;
                    if ((v91 - 33) >= 0xFFFFFFE0)
                      goto LABEL_137;
                    goto LABEL_138;
                  }
                }
              }
            }
            v143 = v36 - (_BYTE *)this + 1;
          }
          if (v90 > *(_DWORD *)v147)
            return v39;
          v138 = v39;
          v94 = a2;
          v95 = a8;
          v96 = __n;
          v140 = __n + 2;
          v142 = __n + 1;
          v97 = v90;
          do
          {
            v100 = v94;
            v101 = *v94;
            v102 = (*a6)++;
            v103 = (unint64_t)a1[1];
            v104 = (unint64_t)a1[2];
            if (v103 + 1 <= v104)
            {
              v106 = *a1;
            }
            else
            {
              v105 = (v103 & 0xFFFFFFFFFFFFFFF0) + 16;
              v106 = *a1;
              if (v104 != v105)
              {
                a1[2] = (char *)v105;
                v106 = (char *)malloc_type_realloc(v106, 88 * v105, 0x10500400A17BEF8uLL);
                *a1 = v106;
                v103 = (unint64_t)a1[1];
                v107 = a1[2];
                if (v103 > (unint64_t)v107)
                {
                  a1[1] = v107;
                  v103 = (unint64_t)v107;
                }
              }
            }
            if (v103 > v101)
            {
              memmove(&v106[88 * v101 + 88], &v106[88 * v101], 88 * (v103 - v101));
              v106 = *a1;
              v103 = (unint64_t)a1[1];
            }
            a1[1] = (char *)(v103 + 1);
            v108 = &v106[88 * v101];
            memcpy(v108, a4, v96);
            v109 = v96;
            if (v102 != -1)
            {
              v108[v96] = 91;
              v109 = v140 + itoa(&v108[v142], v102);
              v108[v109 - 1] = 93;
            }
            v108[v109] = 0;
            v94 = v100;
            v98 = (*v100)++;
            v99 = (uint64_t)&(*a1)[88 * v98];
            *(_QWORD *)(v99 + 40) = this;
            *(_QWORD *)(v99 + 48) = v143;
            *(_DWORD *)(v99 + 56) = v97;
            *(_QWORD *)(v99 + 64) = 0;
            *(_QWORD *)(v99 + 72) = 0;
            *(_QWORD *)(v99 + 80) = v95;
            v60 = v97++ >= *(unsigned int *)v147;
          }
          while (!v60);
          return v138;
        }
LABEL_165:
        v110 = *a2;
        v111 = (*a6)++;
        v112 = (unint64_t)a1[1];
        v113 = (unint64_t)a1[2];
        if (v112 + 1 <= v113)
        {
          v115 = *a1;
        }
        else
        {
          v114 = (v112 & 0xFFFFFFFFFFFFFFF0) + 16;
          v115 = *a1;
          if (v113 != v114)
          {
            a1[2] = (char *)v114;
            v115 = (char *)malloc_type_realloc(v115, 88 * v114, 0x10500400A17BEF8uLL);
            *a1 = v115;
            v112 = (unint64_t)a1[1];
            v116 = a1[2];
            if (v112 > (unint64_t)v116)
            {
              a1[1] = v116;
              v112 = (unint64_t)v116;
            }
          }
        }
        v117 = v39;
        if (v112 > v110)
        {
          memmove(&v115[88 * v110 + 88], &v115[88 * v110], 88 * (v112 - v110));
          v115 = *a1;
          v112 = (unint64_t)a1[1];
        }
        a1[1] = (char *)(v112 + 1);
        v118 = &v115[88 * v110];
        memcpy(v118, a4, __n);
        if (v111 != -1)
        {
          v118[__n] = 91;
          __n += itoa(&v118[__n + 1], v111) + 2;
          v118[__n - 1] = 93;
        }
        v118[__n] = 0;
        v119 = (*a2)++;
        v39 = v117;
        v120 = (uint64_t)&(*a1)[88 * v119];
        *(_QWORD *)(v120 + 40) = this;
        *(_QWORD *)(v120 + 48) = v117 - (unsigned __int8 *)this;
        *(_DWORD *)(v120 + 56) = -1;
        *(_QWORD *)(v120 + 64) = 0;
        *(_QWORD *)(v120 + 72) = 0;
        *(_QWORD *)(v120 + 80) = a8;
        return v39;
      }
      v55 = *(_DWORD *)v147;
      if (*(_DWORD *)v147 >= *(unsigned __int16 *)(a9 + 22))
      {
        *(_WORD *)(a9 + 22) = *(_WORD *)v147 + 1;
        *(_DWORD *)(a9 + 44) = 16 * (unsigned __int16)(v55 + 1);
      }
      goto LABEL_89;
    }
    v70 = *(unsigned __int16 *)(a9 + 22);
    *(_WORD *)(a9 + 22) = v70 + 1;
LABEL_113:
    *(_DWORD *)v147 = v70;
    *(_DWORD *)&v147[4] = v70;
    goto LABEL_114;
  }
  if (v41 == &fragmentKind)
  {
    if (v49)
    {
LABEL_112:
      v70 = *(unsigned __int16 *)(a9 + 36);
      *(_WORD *)(a9 + 36) = v70 + 1;
      goto LABEL_113;
    }
    if (!strncmp((const char *)this, "fragment", 8uLL))
    {
      v71 = arb::achr((arb *)((char *)this + 8), (const char *)0x2E);
      if (v71)
      {
        v72 = v71;
        if (!strncmp(v71, "texcoord", 8uLL))
          goto LABEL_192;
        if (!strncmp(v72, "position", 8uLL))
        {
LABEL_162:
          v90 = *(_DWORD *)&v147[4];
          if (!v42)
            v90 = -1;
          *(_DWORD *)&v147[4] = v90;
          if (v90 != -1)
            goto LABEL_134;
          goto LABEL_165;
        }
      }
    }
LABEL_161:
    *(_DWORD *)(a9 + 4) |= 0x8000000u;
    goto LABEL_162;
  }
  if (v41 == &vertexKind)
  {
    if (v49)
      goto LABEL_112;
    if (!strncmp((const char *)this, "vertex", 6uLL))
    {
      v123 = arb::achr((arb *)((char *)this + 6), (const char *)0x2E);
      if (v123)
      {
        if (!strncmp(v123, "texcoord", 8uLL))
        {
LABEL_192:
          v55 = *(_DWORD *)v147;
          if (*(_DWORD *)v147 >= *(unsigned __int16 *)(a9 + 36))
            *(_WORD *)(a9 + 36) = *(_WORD *)v147 + 1;
          goto LABEL_89;
        }
      }
    }
    goto LABEL_161;
  }
  if (v41 == &outputKind)
  {
    if (v49)
    {
      v70 = *(unsigned __int8 *)(a9 + 42);
      *(_BYTE *)(a9 + 42) = v70 + 1;
      goto LABEL_113;
    }
    if (strncmp((const char *)this, "result", 6uLL)
      || (v124 = arb::achr((arb *)((char *)this + 6), (const char *)0x2E)) == 0
      || strncmp(v124, "color", 5uLL))
    {
      *(_DWORD *)(a9 + 12) = 0;
      v90 = *(_DWORD *)&v147[4];
      if (!v42)
        v90 = -1;
      *(_DWORD *)&v147[4] = v90;
      if (v90 != -1)
        goto LABEL_134;
      goto LABEL_165;
    }
    v55 = *(_DWORD *)v147;
    if (*(_DWORD *)v147 >= *(unsigned __int8 *)(a9 + 42))
      *(_BYTE *)(a9 + 42) = v147[0] + 1;
LABEL_89:
    v56 = *(unsigned int *)&v147[4];
    if (*(_DWORD *)&v147[4] > v55)
      return v39;
    v138 = v39;
    do
    {
      v61 = *a2;
      v62 = (*a6)++;
      v63 = (unint64_t)a1[1];
      v64 = (unint64_t)a1[2];
      if (v63 + 1 <= v64)
      {
        v66 = *a1;
      }
      else
      {
        v65 = (v63 & 0xFFFFFFFFFFFFFFF0) + 16;
        v66 = *a1;
        if (v64 != v65)
        {
          a1[2] = (char *)v65;
          v66 = (char *)malloc_type_realloc(v66, 88 * v65, 0x10500400A17BEF8uLL);
          *a1 = v66;
          v63 = (unint64_t)a1[1];
          v67 = a1[2];
          if (v63 > (unint64_t)v67)
          {
            a1[1] = v67;
            v63 = (unint64_t)v67;
          }
        }
      }
      if (v63 > v61)
      {
        memmove(&v66[88 * v61 + 88], &v66[88 * v61], 88 * (v63 - v61));
        v66 = *a1;
        v63 = (unint64_t)a1[1];
      }
      a1[1] = (char *)(v63 + 1);
      v68 = &v66[88 * v61];
      memcpy(v68, a4, __n);
      v69 = __n;
      if (v62 != -1)
      {
        v68[__n] = 91;
        v69 = __n + 2 + itoa(&v68[__n + 1], v62);
        v68[v69 - 1] = 93;
      }
      v68[v69] = 0;
      v57 = (*a2)++;
      v58 = 1;
      if (a3[1])
        v58 = 2;
      v59 = (uint64_t)&(*a1)[88 * v57];
      *(_QWORD *)(v59 + 40) = a3;
      *(_QWORD *)(v59 + 48) = v58;
      *(_DWORD *)(v59 + 56) = v56;
      *(_QWORD *)(v59 + 64) = 0;
      *(_QWORD *)(v59 + 72) = 0;
      *(_QWORD *)(v59 + 80) = a8;
      v60 = v56++ >= *(unsigned int *)v147;
    }
    while (!v60);
    return v138;
  }
  if (!v41)
    goto LABEL_133;
  if (!v49)
  {
    v55 = *(_DWORD *)v147;
    goto LABEL_89;
  }
LABEL_114:
  v73 = *a2;
  v74 = (*a6)++;
  v75 = (unint64_t)a1[1];
  v76 = (unint64_t)a1[2];
  if (v75 + 1 <= v76)
  {
    v79 = a2;
    v78 = *a1;
  }
  else
  {
    v77 = (v75 & 0xFFFFFFFFFFFFFFF0) + 16;
    v78 = *a1;
    v79 = a2;
    if (v76 != v77)
    {
      a1[2] = (char *)v77;
      v78 = (char *)malloc_type_realloc(v78, 88 * v77, 0x10500400A17BEF8uLL);
      *a1 = v78;
      v75 = (unint64_t)a1[1];
      v80 = a1[2];
      if (v75 > (unint64_t)v80)
      {
        a1[1] = v80;
        v75 = (unint64_t)v80;
      }
    }
  }
  v81 = a8;
  v82 = v39;
  if (v75 > v73)
  {
    memmove(&v78[88 * v73 + 88], &v78[88 * v73], 88 * (v75 - v73));
    v78 = *a1;
    v75 = (unint64_t)a1[1];
  }
  a1[1] = (char *)(v75 + 1);
  v83 = &v78[88 * v73];
  memcpy(v83, a4, __n);
  if (v74 != -1)
  {
    v83[__n] = 91;
    __n += itoa(&v83[__n + 1], v74) + 2;
    v83[__n - 1] = 93;
  }
  v83[__n] = 0;
  v84 = (*v79)++;
  v85 = 1;
  if (a3[1])
    v85 = 2;
  v86 = *(_DWORD *)&v147[4];
  v87 = (uint64_t)&(*a1)[88 * v84];
  *(_QWORD *)(v87 + 40) = a3;
  *(_QWORD *)(v87 + 48) = v85;
  *(_DWORD *)(v87 + 56) = v86;
  *(_QWORD *)(v87 + 64) = this;
  *(_QWORD *)(v87 + 72) = v49 - (unsigned __int8 *)this;
  *(_QWORD *)(v87 + 80) = v81;
  return v82;
}

uint64_t arb::ascan(unsigned __int8 **this, const char **a2, unsigned __int8 *a3, const char *a4)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  int v8;
  _BYTE *v9;
  int v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  _BYTE *v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  int v31;
  int v33;

  v4 = *this;
  v5 = (unsigned __int8 *)a2 + (_QWORD)*this;
  while (1)
  {
    while (1)
    {
      if (v4 < v5)
      {
        v6 = *v4;
        if ((ctype[2 * v6] & 0x40) != 0)
          break;
      }
      v7 = 0;
      v8 = *a3;
      v9 = &ctype[2 * *a3];
      v10 = v9[1];
      if ((*v9 & 0x40) != 0)
        goto LABEL_18;
LABEL_6:
      if (!v8)
      {
        if ((_DWORD)a4)
        {
          if (*v4 == 91)
          {
            v27 = v4 + 1;
            v26 = v4[1];
            if (v4[1])
            {
              if ((v26 - 33) >= 0xFFFFFFE0)
              {
                do
                {
LABEL_48:
                  v28 = *++v27;
                  v26 = v28;
                }
                while ((v28 - 33) > 0xFFFFFFDF);
              }
LABEL_49:
              if (v26 != 35)
              {
                v13 = v4;
                if ((v26 - 58) >= 0xFFFFFFF6)
                {
                  v7 = 0;
                  v13 = v27;
                  do
                  {
                    v10 = 0;
                    v7 = v26 + 10 * v7 - 48;
                    v33 = *++v13;
                    v26 = v33;
                  }
                  while ((v33 - 58) > 0xFFFFFFF5);
                }
                goto LABEL_57;
              }
              v29 = v27;
              while (1)
              {
                v30 = *++v29;
                v26 = v30;
                if (!v30)
                  break;
                v31 = *v27;
                v27 = v29;
                if (v31 == 10)
                {
                  v27 = v29;
                  if ((v26 - 33) >= 0xFFFFFFE0)
                    goto LABEL_48;
                  goto LABEL_49;
                }
              }
            }
          }
        }
LABEL_55:
        *this = v4;
        return (v7 - v10);
      }
      if (v7)
        goto LABEL_55;
      v11 = *v4;
      if (!*v4)
        goto LABEL_20;
      if ((v11 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_10:
          v12 = *++v4;
          v11 = v12;
        }
        while ((v12 - 33) > 0xFFFFFFDF);
      }
LABEL_11:
      if (v11 == 35)
      {
        v13 = v4 + 1;
        while (1)
        {
          v11 = *v13;
          if (!*v13)
            break;
          v14 = *(v13++ - 1);
          if (v14 == 10)
          {
            v4 = v13 - 1;
            if ((v11 - 33) >= 0xFFFFFFE0)
              goto LABEL_10;
            goto LABEL_11;
          }
        }
      }
      else
      {
LABEL_20:
        v13 = v4;
      }
      if (v13 >= v5)
      {
        v7 = 0;
        if (v10)
          goto LABEL_57;
      }
      else
      {
        v7 = ctype[2 * v11 + 1];
        if (v7 != v10)
          goto LABEL_57;
      }
      if (v8 == 91)
      {
        v17 = *++a3;
        v16 = v17;
        if ((v17 - 58) < 0xFFFFFFF6)
          goto LABEL_39;
        v10 = 0;
        v18 = a3;
        do
        {
          v10 = v16 + 10 * v10 - 48;
          v19 = *++v18;
          v16 = v19;
        }
        while ((v19 - 58) > 0xFFFFFFF5);
        v4 = v13 + 1;
        v20 = v13[1];
        if (!v13[1])
          goto LABEL_39;
        if ((v20 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_31:
            v21 = *++v4;
            v20 = v21;
          }
          while ((v21 - 33) > 0xFFFFFFDF);
        }
LABEL_32:
        if (v20 == 35)
        {
          v22 = v4;
          while (1)
          {
            v23 = *++v22;
            v20 = v23;
            if (!v23)
              break;
            v24 = *v4;
            v4 = v22;
            if (v24 == 10)
            {
              v4 = v22;
              if ((v20 - 33) >= 0xFFFFFFE0)
                goto LABEL_31;
              goto LABEL_32;
            }
          }
LABEL_39:
          v4 = v13 + 1;
        }
        else
        {
          if ((v20 - 58) < 0xFFFFFFF6)
            goto LABEL_39;
          v7 = 0;
          do
          {
            v7 = v20 + 10 * v7 - 48;
            v25 = *++v4;
            v20 = v25;
          }
          while ((v25 - 58) > 0xFFFFFFF5);
          a3 = v18;
          if (v7 != v10)
            goto LABEL_57;
        }
      }
      else
      {
        v4 = v13 + 1;
        ++a3;
      }
    }
    v7 = ctype[2 * v6 + 1];
    v8 = *a3;
    v15 = &ctype[2 * *a3];
    v10 = v15[1];
    if ((*v15 & 0x40) == 0)
      goto LABEL_6;
LABEL_18:
    if (v7 != v10)
      break;
    ++a3;
    ++v4;
  }
  v13 = v4;
LABEL_57:
  *this = v13;
  return (v7 - v10);
}

char *map_insert(char **a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  char *v8;

  v4 = (unint64_t)a1[1];
  v5 = (unint64_t)a1[2];
  if (v4 + 1 <= v5)
  {
    v7 = *a1;
  }
  else
  {
    v6 = (v4 & 0xFFFFFFFFFFFFFFF0) + 16;
    v7 = *a1;
    if (v5 != v6)
    {
      a1[2] = (char *)v6;
      v7 = (char *)malloc_type_realloc(v7, 88 * v6, 0x10500400A17BEF8uLL);
      *a1 = v7;
      v4 = (unint64_t)a1[1];
      v8 = a1[2];
      if (v4 > (unint64_t)v8)
      {
        a1[1] = v8;
        v4 = (unint64_t)v8;
      }
    }
  }
  if (v4 > a2)
  {
    memmove(&v7[88 * a2 + 88], &v7[88 * a2], 88 * (v4 - a2));
    v7 = *a1;
    v4 = (unint64_t)a1[1];
  }
  a1[1] = (char *)(v4 + 1);
  return &v7[88 * a2];
}

uint64_t itoa(char *a1, signed int a2)
{
  uint64_t v2;
  uint32x4_t v3;
  int16x8_t v4;
  uint8x8_t v5;
  __int32 v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  if (a2 < 0)
  {
    *a1 = 45;
    a2 = -a2;
    v2 = 1;
  }
  else
  {
    v2 = 0;
  }
  v3 = (uint32x4_t)vdupq_n_s32(a2);
  v4 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v3, (uint32x4_t)xmmword_1B309DA50), (int16x8_t)vcgtq_u32(v3, (uint32x4_t)xmmword_1B309DA40)), (int8x16_t)xmmword_1B309DA60);
  v4.i32[0] = vaddvq_s16(v4);
  v5 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v4.i8);
  v5.i16[0] = vaddlv_u8(v5);
  v6 = v5.i32[0];
  if (a2 > 9)
    v6 = v5.i32[0] + 1;
  switch(v6)
  {
    case 1:
      goto LABEL_15;
    case 2:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_11;
    case 6:
      goto LABEL_10;
    case 7:
      goto LABEL_9;
    case 8:
      goto LABEL_8;
    case 9:
      v7 = a2 / 0x3B9ACA00u;
      a2 %= 0x3B9ACA00u;
      a1[v2++] = v7 | 0x30;
LABEL_8:
      v8 = a2 / 100000000;
      a2 %= 100000000;
      a1[v2++] = v8 + 48;
LABEL_9:
      v9 = a2 / 10000000;
      a2 %= 10000000;
      a1[v2++] = v9 + 48;
LABEL_10:
      v10 = a2 / 1000000;
      a2 %= 1000000;
      a1[v2++] = v10 + 48;
LABEL_11:
      v11 = a2 / 100000;
      a2 %= 100000;
      a1[v2++] = v11 + 48;
LABEL_12:
      v12 = a2 / 10000;
      a2 %= 10000;
      a1[v2++] = v12 + 48;
LABEL_13:
      v13 = a2 / 1000;
      a2 %= 1000;
      a1[v2++] = v13 + 48;
LABEL_14:
      v14 = a2 / 100;
      a2 %= 100;
      a1[v2++] = v14 + 48;
LABEL_15:
      v15 = a2 / 10;
      a2 %= 10;
      a1[v2++] = v15 + 48;
      break;
    default:
      break;
  }
  a1[v2] = a2 + 48;
  return v2 + 1;
}

char *arb::obj_add(uint64_t a1, char *__s1, const char **a3, uint64_t a4, int a5)
{
  unint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  int v14;
  unint64_t v15;
  unsigned __int8 *v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  unsigned int *v28;
  char *v29;
  const char *v30;
  const char *v31;
  unsigned int *v32;
  int v33;
  int v34;
  int v35;
  const char *v37;
  unsigned int *v38;
  int v39;
  arb *v40;
  unsigned int *v41;
  int v42;
  int v43;
  unsigned __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  const char *v48;
  int v49;
  int v50;
  int v51;
  char *v52;
  char v54[4];
  unsigned __int8 *v55;

  *(_DWORD *)v54 = 0;
  v10 = *(char **)a1;
  v9 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)a1 + 88 * v9;
  v52 = *(char **)a1;
  if (!v9)
    goto LABEL_26;
  while (1)
  {
    v12 = v9 >> 1;
    v55 = (unsigned __int8 *)__s1;
    v13 = &v10[88 * (v9 >> 1)];
    v14 = arb::ascan(&v55, a3, (unsigned __int8 *)v13, (const char *)1);
    if (!v14)
      break;
    if (v14 > 0)
    {
      v15 = v12 + 1;
    }
    else
    {
      v11 = (uint64_t)&v10[88 * (v9 >> 1)];
      v15 = 0;
    }
    v10 += 88 * v15;
    if (v14 <= 0)
      v9 >>= 1;
    else
      v9 -= v12 + 1;
    if (!v9)
      goto LABEL_26;
  }
  if (!v10)
  {
LABEL_26:
    v13 = 0;
    if ((unint64_t)a3 < 0xC || !a4)
      return v13;
    v13 = 0;
    switch(*__s1)
    {
      case 'f':
        if (strncmp(__s1, "fragment", 8uLL))
          goto LABEL_44;
        v24 = arb::achr((arb *)(__s1 + 8), (const char *)0x2E);
        if (!v24)
          goto LABEL_44;
        v25 = v24;
        if (strncmp(v24, "texcoord", 8uLL))
        {
          if (strncmp(v25, "position", 8uLL))
            goto LABEL_44;
          return 0;
        }
        v40 = (arb *)(v25 + 8);
        if (arb::achr(v40, (const char *)0x5B) && !arb::aidx(v40, v54, 0, v41))
        {
          if (*(unsigned __int16 *)(a4 + 36) > 7u)
            return 0;
          v13 = 0;
          v46 = 8;
          goto LABEL_62;
        }
        v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
        arb::acpy((uint64_t)v13, __s1, (const char *)a3);
        v42 = *(_DWORD *)v54;
        *((_QWORD *)v13 + 5) = &fragmentKind;
        *((_QWORD *)v13 + 6) = 2;
        *((_DWORD *)v13 + 14) = v42;
        *((_QWORD *)v13 + 9) = 0;
        *((_QWORD *)v13 + 10) = 0;
        *((_QWORD *)v13 + 8) = 0;
        if (*(_DWORD *)v54 >= *(unsigned __int16 *)(a4 + 36))
          *(_WORD *)(a4 + 36) = *(_WORD *)v54 + 1;
        if (a5)
          *(_DWORD *)(a4 + 12) &= ~(1 << *((_DWORD *)v13 + 14));
        return v13;
      case 'p':
        if (strncmp(__s1, "program", 7uLL))
          goto LABEL_44;
        v26 = arb::achr((arb *)(__s1 + 7), (const char *)0x2E);
        if (!v26)
          goto LABEL_44;
        v27 = v26;
        if (strncmp(v26, "local", 5uLL))
          return 0;
        arb::aidx((arb *)(v27 + 5), v54, 0, v28);
        v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
        arb::acpy((uint64_t)v13, __s1, (const char *)a3);
        v43 = *(_DWORD *)v54;
        *((_QWORD *)v13 + 5) = &paramKind;
        *((_QWORD *)v13 + 6) = 2;
        *((_DWORD *)v13 + 14) = v43;
        *((_QWORD *)v13 + 9) = 0;
        *((_QWORD *)v13 + 10) = 0;
        *((_QWORD *)v13 + 8) = 0;
        if (*(_DWORD *)v54 >= *(unsigned __int16 *)(a4 + 22))
        {
          v44 = *(_WORD *)v54 + 1;
          *(_WORD *)(a4 + 22) = *(_WORD *)v54 + 1;
          *(_DWORD *)(a4 + 44) = 16 * v44;
        }
        return v13;
      case 'r':
        if (strncmp(__s1, "result", 6uLL))
          goto LABEL_44;
        v29 = __s1 + 6;
        v30 = arb::achr((arb *)(__s1 + 6), (const char *)0x2E);
        if (!v30)
          goto LABEL_50;
        v31 = v30;
        if (strncmp(v30, "color", 5uLL))
          goto LABEL_50;
        arb::aidx((arb *)(v31 + 5), v54, 0, v32);
        v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
        arb::acpy((uint64_t)v13, __s1, (const char *)a3);
        v33 = *(_DWORD *)v54;
        *((_QWORD *)v13 + 5) = &outputKind;
        *((_QWORD *)v13 + 6) = 2;
        *((_DWORD *)v13 + 14) = v33;
        *((_QWORD *)v13 + 9) = 0;
        *((_QWORD *)v13 + 10) = 0;
        *((_QWORD *)v13 + 8) = 0;
        if (*(_DWORD *)v54 >= *(unsigned __int8 *)(a4 + 42))
          *(_BYTE *)(a4 + 42) = v54[0] + 1;
        return v13;
      case 's':
        goto LABEL_44;
      case 'v':
        if (!strncmp(__s1, "vertex", 6uLL) && (v37 = arb::achr((arb *)(__s1 + 6), (const char *)0x2E)) != 0)
        {
          v29 = (char *)v37;
          if (!strncmp(v37, "texcoord", 8uLL))
          {
            arb::aidx((arb *)(v29 + 8), v54, 0, v38);
            v13 = map_insert((char **)a1, 0x2E8BA2E8BA2E8BA3 * ((v11 - (uint64_t)v52) >> 3));
            arb::acpy((uint64_t)v13, __s1, (const char *)a3);
            v45 = *(_DWORD *)v54;
            *((_QWORD *)v13 + 5) = &vertexKind;
            *((_QWORD *)v13 + 6) = 2;
            *((_DWORD *)v13 + 14) = v45;
            *((_QWORD *)v13 + 9) = 0;
            *((_QWORD *)v13 + 10) = 0;
            *((_QWORD *)v13 + 8) = 0;
            if (*(_DWORD *)v54 >= *(unsigned __int16 *)(a4 + 36))
            {
              v46 = *(_WORD *)v54 + 1;
LABEL_62:
              *(_WORD *)(a4 + 36) = v46;
            }
            return v13;
          }
LABEL_50:
          v39 = strncmp(v29, "position", 8uLL);
          v34 = *(_DWORD *)(a4 + 4);
          v13 = 0;
          if (!v39)
            goto LABEL_51;
        }
        else
        {
LABEL_44:
          v13 = 0;
          v34 = *(_DWORD *)(a4 + 4);
        }
        v35 = v34 | 0x8000000;
        goto LABEL_46;
      default:
        return v13;
    }
  }
  if (!a4)
    return v13;
  v16 = *(unsigned __int8 **)&v10[88 * v12 + 40];
  if (a5 && v16 == (unsigned __int8 *)&fragmentKind)
  {
    *(_DWORD *)(a4 + 12) &= ~(1 << *(_DWORD *)&v10[88 * v12 + 56]);
    v16 = (unsigned __int8 *)&fragmentKind;
  }
  if (strncmp((const char *)v16, "vertex", 6uLL))
    return v13;
  v19 = v16[6];
  v18 = v16 + 6;
  v17 = v19;
  if (!v19)
    return v13;
  if ((v17 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_19:
      v20 = *++v18;
      v17 = v20;
    }
    while ((v20 - 33) > 0xFFFFFFDF);
  }
LABEL_20:
  if (v17 == 35)
  {
    v21 = v18;
    while (1)
    {
      v22 = *++v21;
      v17 = v22;
      if (!v22)
        return v13;
      v23 = *v18;
      v18 = v21;
      if (v23 == 10)
      {
        v18 = v21;
        if ((v17 - 33) >= 0xFFFFFFE0)
          goto LABEL_19;
        goto LABEL_20;
      }
    }
  }
  if (v17 == 46)
  {
    v49 = v18[1];
    v48 = (const char *)(v18 + 1);
    v47 = v49;
    if (v49)
    {
      if ((v47 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_66:
          v50 = *(unsigned __int8 *)++v48;
          v47 = v50;
        }
        while ((v50 - 33) > 0xFFFFFFDF);
      }
LABEL_67:
      if (v47 == 35)
      {
        ++v48;
        while (1)
        {
          v47 = *(unsigned __int8 *)v48;
          if (!*v48)
            break;
          v51 = *((unsigned __int8 *)v48++ - 1);
          if (v51 == 10)
          {
            --v48;
            if ((v47 - 33) >= 0xFFFFFFE0)
              goto LABEL_66;
            goto LABEL_67;
          }
        }
      }
    }
    if (!strncmp(v48, "position", 8uLL))
    {
      v34 = *(_DWORD *)(a4 + 4);
LABEL_51:
      v35 = v34 & 0x3FFFFFFF;
LABEL_46:
      *(_DWORD *)(a4 + 4) = v35;
    }
  }
  return v13;
}

uint64_t arb::acpy(uint64_t this, char *a2, const char *a3)
{
  uint64_t v3;
  unint64_t v4;
  int v5;
  char *v6;
  int v7;
  int v8;
  int v9;

  v3 = 0;
  if (a3)
  {
    v4 = 0;
    do
    {
      v5 = a2[v4];
      if ((v5 - 33) <= 0xFFFFFFDF)
      {
        *(_BYTE *)(this + v3++) = v5;
        v6 = &a2[++v4];
        if (a2[v4] == 35)
        {
LABEL_9:
          v7 = 35;
LABEL_11:
          if (v7 == 35)
          {
            ++v6;
            while (1)
            {
              v7 = *v6;
              if (!*v6)
                break;
              v9 = *(v6++ - 1);
              if (v9 == 10)
              {
                --v6;
                if ((v7 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v8 = *++v6;
                    v7 = v8;
                  }
                  while ((v8 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_11;
              }
            }
          }
          v4 = v6 - a2;
        }
      }
      else
      {
        v6 = &a2[++v4];
        if (a2[v4] == 35)
          goto LABEL_9;
      }
    }
    while (v4 < (unint64_t)a3);
  }
  *(_BYTE *)(this + v3) = 0;
  return this;
}

unsigned __int8 *arb::asymbol(arb *this, char *a2, const char **a3, unint64_t *a4)
{
  arb *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int *v15;
  int v16;
  arb *v18;
  int v19;
  int v20;
  int v21;
  const char *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  int v31;
  unsigned __int8 *v32;
  int v33;
  unsigned __int8 *result;
  int v35;
  int v36;
  unsigned __int8 *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unsigned __int8 *v49;
  int v50;
  unsigned __int8 *v51;
  int v52;
  unsigned __int8 *v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  unsigned __int8 *v59;
  int v60;
  unsigned __int8 *v61;
  int v62;
  unsigned __int8 *v63;
  int v64;
  int v65;
  unsigned __int8 *v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  unsigned __int8 *v72;
  int v73;
  unsigned __int8 *v74;
  int v75;
  int v76;
  int v77;
  int v78;
  const char *v79;
  const char *v80;
  unsigned __int8 *v81;
  unsigned __int8 *v82;
  unsigned __int8 *v83;
  char v84;
  unsigned __int8 *v85;
  int v86;
  int v87;
  const char *v88;
  int v89;

  v6 = this;
  v7 = *(unsigned __int8 *)this;
  if (v7 != 45)
    goto LABEL_209;
  v6 = (arb *)((char *)this + 1);
  v7 = *((unsigned __int8 *)this + 1);
  if (!*((_BYTE *)this + 1))
    goto LABEL_21;
  if ((v7 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_4:
      v8 = *((unsigned __int8 *)v6 + 1);
      v6 = (arb *)((char *)v6 + 1);
      v7 = v8;
    }
    while ((v8 - 33) > 0xFFFFFFDF);
  }
LABEL_5:
  if (v7 == 35)
  {
    v6 = (arb *)((char *)v6 + 1);
    while (1)
    {
      v7 = *(unsigned __int8 *)v6;
      if (!*(_BYTE *)v6)
        break;
      v9 = *((unsigned __int8 *)v6 - 1);
      v6 = (arb *)((char *)v6 + 1);
      if (v9 == 10)
      {
        v6 = (arb *)((char *)v6 - 1);
        if ((v7 - 33) >= 0xFFFFFFE0)
          goto LABEL_4;
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_209:
    if (v7 == 124)
    {
      v11 = *((unsigned __int8 *)v6 + 1);
      v6 = (arb *)((char *)v6 + 1);
      v10 = v11;
      if (v11)
      {
        if ((v10 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_14:
            v12 = *((unsigned __int8 *)v6 + 1);
            v6 = (arb *)((char *)v6 + 1);
            v10 = v12;
          }
          while ((v12 - 33) > 0xFFFFFFDF);
        }
LABEL_15:
        if (v10 == 35)
        {
          v6 = (arb *)((char *)v6 + 1);
          while (1)
          {
            v10 = *(unsigned __int8 *)v6;
            if (!*(_BYTE *)v6)
              break;
            v13 = *((unsigned __int8 *)v6 - 1);
            v6 = (arb *)((char *)v6 + 1);
            if (v13 == 10)
            {
              v6 = (arb *)((char *)v6 - 1);
              if ((v10 - 33) >= 0xFFFFFFE0)
                goto LABEL_14;
              goto LABEL_15;
            }
          }
        }
      }
    }
  }
LABEL_21:
  v14 = strncmp((const char *)v6, "state", 5uLL);
  *(_QWORD *)a2 = v6;
  *a3 = 0;
  v16 = *(unsigned __int8 *)v6;
  if ((v16 - 48) < 0xA || (ctype[2 * *(unsigned __int8 *)v6] & 0x40) == 0)
  {
    if (v16 == 123)
    {
      v18 = v6;
      do
      {
        if (v16 == 35)
        {
          while (v16 == 35)
          {
            v18 = (arb *)((char *)v18 + 1);
            do
            {
              v16 = *(unsigned __int8 *)v18;
              if (!*(_BYTE *)v18)
                goto LABEL_43;
              v20 = *((unsigned __int8 *)v18 - 1);
              v18 = (arb *)((char *)v18 + 1);
            }
            while (v20 != 10);
            v18 = (arb *)((char *)v18 - 1);
            if ((v16 - 33) >= 0xFFFFFFE0)
            {
              do
              {
                v19 = *((unsigned __int8 *)v18 + 1);
                v18 = (arb *)((char *)v18 + 1);
                v16 = v19;
              }
              while ((v19 - 33) > 0xFFFFFFDF);
            }
          }
        }
        else
        {
          v21 = *((unsigned __int8 *)v18 + 1);
          v18 = (arb *)((char *)v18 + 1);
          v16 = v21;
        }
      }
      while (v16 != 125 && v16 != 0);
LABEL_43:
      v25 = *((unsigned __int8 *)v18 + 1);
      v23 = (char *)v18 + 1;
      v24 = v25;
      if (v25)
      {
        if ((v24 - 33) < 0xFFFFFFE0)
          goto LABEL_46;
        do
        {
LABEL_45:
          v26 = *(unsigned __int8 *)++v23;
          v24 = v26;
        }
        while ((v26 - 33) > 0xFFFFFFDF);
LABEL_46:
        while (v24 == 35)
        {
          ++v23;
          do
          {
            v24 = *(unsigned __int8 *)v23;
            if (!*v23)
              goto LABEL_183;
            v27 = *((unsigned __int8 *)v23++ - 1);
          }
          while (v27 != 10);
          --v23;
          if ((v24 - 33) >= 0xFFFFFFE0)
            goto LABEL_45;
        }
      }
LABEL_183:
      v79 = (const char *)(v23 - (const char *)v6);
    }
    else
    {
      if ((ctype[2 * *(unsigned __int8 *)v6] & 0x80) == 0)
        return 0;
      if (*((_BYTE *)v6 + 1) == 68)
      {
        result = (unsigned __int8 *)v6 + 2;
        *a3 = (const char *)2;
        return result;
      }
      v88 = 0;
      do
        v89 = (char)ctype[2 * (v88++)[(_QWORD)v6 + 1]];
      while (v89 < 0);
      *a3 = v88;
      v23 = &v88[(_QWORD)v6];
      if ((ctype[2 * v88[(_QWORD)v6]] & 0x20) == 0)
      {
LABEL_185:
        v80 = &v23[((unint64_t)ctype[2 * *(unsigned __int8 *)v23] >> 5) & 1];
        v81 = (unsigned __int8 *)&v80[((unint64_t)ctype[2 * *(unsigned __int8 *)v80] >> 5) & 1];
        v82 = &v81[((unint64_t)ctype[2 * *v81] >> 5) & 1];
        return &v82[((unint64_t)ctype[2 * *v82] >> 5) & 1];
      }
      v79 = v88 - 1;
    }
    *a3 = v79;
    goto LABEL_185;
  }
  v28 = v14;
  v29 = (unsigned __int8 *)v6;
  while (1)
  {
    do
    {
      v31 = *++v29;
      v30 = v31;
    }
    while ((ctype[2 * v31] & 0x40) != 0);
    if (!v30)
      break;
    v32 = v29;
    if ((v30 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_55:
        v33 = *++v32;
        v30 = v33;
      }
      while ((v33 - 33) > 0xFFFFFFDF);
    }
LABEL_56:
    if (v30 == 35)
    {
      result = v32 + 1;
      while (1)
      {
        v30 = *result;
        if (!*result)
          goto LABEL_91;
        v35 = *(result++ - 1);
        if (v35 == 10)
        {
          v32 = result - 1;
          if ((v30 - 33) >= 0xFFFFFFE0)
            goto LABEL_55;
          goto LABEL_56;
        }
      }
    }
    if (v30 != 91)
    {
      result = v32;
      *a3 = (const char *)(v29 - (unsigned __int8 *)v6);
      v36 = *v32;
      if (v36 == 46)
        goto LABEL_93;
      goto LABEL_188;
    }
    result = arb::aidx((arb *)v32, 0, 0, v15);
    v37 = result;
    if (result)
      goto LABEL_92;
    v38 = 91;
    while (1)
    {
      if (v38 != 35)
      {
        v41 = *++v32;
        v38 = v41;
        goto LABEL_77;
      }
LABEL_70:
      if (v38 == 35)
        break;
LABEL_77:
      if (v38 == 93 || v38 == 0)
        goto LABEL_82;
    }
    ++v32;
    while (1)
    {
      v38 = *v32;
      if (!*v32)
        break;
      v40 = *(v32++ - 1);
      if (v40 == 10)
      {
        --v32;
        if ((v38 - 33) >= 0xFFFFFFE0)
        {
          do
          {
            v39 = *++v32;
            v38 = v39;
          }
          while ((v39 - 33) > 0xFFFFFFDF);
        }
        goto LABEL_70;
      }
    }
LABEL_82:
    v43 = v32[1];
    result = v32 + 1;
    if (v32[1])
    {
      if ((v43 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_84:
          v44 = *++result;
          v43 = v44;
        }
        while ((v44 - 33) > 0xFFFFFFDF);
      }
LABEL_85:
      if (v43 == 35)
      {
        ++result;
        while (1)
        {
          v43 = *result;
          if (!*result)
            break;
          v45 = *(result++ - 1);
          if (v45 == 10)
          {
            --result;
            if ((v43 - 33) >= 0xFFFFFFE0)
              goto LABEL_84;
            goto LABEL_85;
          }
        }
      }
    }
LABEL_91:
    v37 = v29;
LABEL_92:
    *a3 = (const char *)(v37 - (unsigned __int8 *)v6);
    v36 = *result;
    if (v36 != 46)
      goto LABEL_188;
LABEL_93:
    v46 = result[1];
    v29 = result + 1;
    if (result[1])
    {
      if ((v46 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_95:
          v47 = *++v29;
          v46 = v47;
        }
        while ((v47 - 33) > 0xFFFFFFDF);
      }
LABEL_96:
      if (v46 == 35)
      {
        ++v29;
        while (1)
        {
          v46 = *v29;
          if (!*v29)
            break;
          v48 = *(v29++ - 1);
          if (v48 == 10)
          {
            --v29;
            if ((v46 - 33) >= 0xFFFFFFE0)
              goto LABEL_95;
            goto LABEL_96;
          }
        }
      }
    }
    if (!strncmp((const char *)v29, "row", 3uLL) && (ctype[2 * v29[3]] & 0x40) == 0)
    {
      v49 = arb::aidx((arb *)(v29 + 3), 0, 0, v15);
      v50 = *v49;
      if (!*v49)
        goto LABEL_186;
      v51 = v49;
      if ((v50 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_106:
          v52 = *++v51;
          v50 = v52;
        }
        while ((v52 - 33) > 0xFFFFFFDF);
      }
LABEL_107:
      if (v50 == 35)
      {
        v53 = v51;
        while (1)
        {
          v54 = *++v53;
          v50 = v54;
          if (!v54)
            break;
          v55 = *v51;
          v51 = v53;
          if (v55 == 10)
          {
            v51 = v53;
            if ((v50 - 33) >= 0xFFFFFFE0)
              goto LABEL_106;
            goto LABEL_107;
          }
        }
LABEL_186:
        v29 = v49;
        goto LABEL_187;
      }
      if (v50 != 46)
        goto LABEL_186;
      v56 = v51[1];
      v29 = v51 + 1;
      v46 = v56;
      if (v56)
      {
        if ((v46 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_118:
            v57 = *++v29;
            v46 = v57;
          }
          while ((v57 - 33) > 0xFFFFFFDF);
        }
LABEL_119:
        if (v46 == 35)
        {
          ++v29;
          while (1)
          {
            v46 = *v29;
            if (!*v29)
              break;
            v58 = *(v29++ - 1);
            if (v58 == 10)
            {
              --v29;
              if ((v46 - 33) >= 0xFFFFFFE0)
                goto LABEL_118;
              goto LABEL_119;
            }
          }
        }
      }
    }
    if (!v28)
    {
      if (!strncmp((const char *)v29, "eye", 3uLL))
      {
        v59 = v29 + 3;
        v60 = v29[3];
        if (v29[3])
          goto LABEL_138;
      }
      else
      {
        if (strncmp((const char *)v29, "object", 6uLL))
          goto LABEL_126;
        v59 = v29 + 6;
        v60 = v29[6];
        if (!v29[6])
          goto LABEL_146;
LABEL_138:
        v61 = v59;
        if ((v60 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_139:
            v62 = *++v61;
            v60 = v62;
          }
          while ((v62 - 33) > 0xFFFFFFDF);
        }
LABEL_140:
        if (v60 == 35)
        {
          v63 = v61;
          while (1)
          {
            v64 = *++v63;
            v60 = v64;
            if (!v64)
              break;
            v65 = *v61;
            v61 = v63;
            if (v65 == 10)
            {
              v61 = v63;
              if ((v60 - 33) >= 0xFFFFFFE0)
                goto LABEL_139;
              goto LABEL_140;
            }
          }
        }
      }
LABEL_146:
      v68 = v59[1];
      v66 = v59 + 1;
      v67 = v68;
      if (v68)
      {
        if ((v67 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_148:
            v69 = *++v66;
            v67 = v69;
          }
          while ((v69 - 33) > 0xFFFFFFDF);
        }
LABEL_149:
        if (v67 == 35)
        {
          ++v66;
          while (1)
          {
            v67 = *v66;
            if (!*v66)
              break;
            v70 = *(v66++ - 1);
            if (v70 == 10)
            {
              --v66;
              if ((v67 - 33) >= 0xFFFFFFE0)
                goto LABEL_148;
              goto LABEL_149;
            }
          }
        }
      }
      v29 = v66 + 1;
      *a3 = (const char *)(v66 + 1 - (unsigned __int8 *)v6);
      v71 = v66[1];
      if (!v66[1])
        goto LABEL_187;
      v72 = v66 + 1;
      if ((v71 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_157:
          v73 = *++v72;
          v71 = v73;
        }
        while ((v73 - 33) > 0xFFFFFFDF);
      }
LABEL_158:
      if (v71 == 35)
      {
        v74 = v72;
        while (1)
        {
          v75 = *++v74;
          v71 = v75;
          if (!v75)
            goto LABEL_187;
          v76 = *v72;
          v72 = v74;
          if (v76 == 10)
          {
            v72 = v74;
            if ((v71 - 33) >= 0xFFFFFFE0)
              goto LABEL_157;
            goto LABEL_158;
          }
        }
      }
      if (v71 != 46)
        goto LABEL_187;
      v46 = v72[1];
      v29 = v72 + 1;
      if (v72[1])
      {
        if ((v46 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_174:
            v77 = *++v29;
            v46 = v77;
          }
          while ((v77 - 33) > 0xFFFFFFDF);
        }
LABEL_175:
        if (v46 == 35)
        {
          ++v29;
          while (1)
          {
            v46 = *v29;
            if (!*v29)
              break;
            v78 = *(v29++ - 1);
            if (v78 == 10)
            {
              --v29;
              if ((v46 - 33) >= 0xFFFFFFE0)
                goto LABEL_174;
              goto LABEL_175;
            }
          }
        }
      }
    }
LABEL_126:
    if ((ctype[2 * v46] & 0x20) != 0)
    {
      if ((ctype[2 * v29[1]] & 0x20) != 0)
      {
        if ((ctype[2 * v29[2]] & 0x20) != 0)
        {
          if ((ctype[2 * v29[3]] & 0x20) != 0)
          {
            if ((ctype[2 * v29[4]] & 0x40) == 0)
            {
              v29 += 4;
              goto LABEL_187;
            }
          }
          else if ((ctype[2 * v29[3]] & 0x40) == 0)
          {
            v29 += 3;
            goto LABEL_187;
          }
        }
        else if ((ctype[2 * v29[2]] & 0x40) == 0)
        {
          v29 += 2;
          goto LABEL_187;
        }
      }
      else if ((ctype[2 * v29[1]] & 0x40) == 0)
      {
        ++v29;
        goto LABEL_187;
      }
    }
    if ((v46 - 48) < 0xA || (ctype[2 * v46] & 0x40) == 0)
    {
LABEL_187:
      v36 = *v29;
      result = v29;
      goto LABEL_188;
    }
  }
  result = v29;
  *a3 = (const char *)(v29 - (unsigned __int8 *)v6);
  v36 = *v29;
  if (v36 == 46)
    goto LABEL_93;
LABEL_188:
  if (v36)
  {
    v83 = result;
    if ((v36 - 33) >= 0xE0u)
    {
      do
      {
LABEL_190:
        v84 = *++v83;
        LOBYTE(v36) = v84;
      }
      while ((v84 - 33) > 0xDFu);
    }
LABEL_191:
    if (v36 == 35)
    {
      v85 = v83;
      while (1)
      {
        v86 = *++v85;
        LOBYTE(v36) = v86;
        if (!v86)
          break;
        v87 = *v83;
        v83 = v85;
        if (v87 == 10)
        {
          v83 = v85;
          if ((v36 - 33) >= 0xE0u)
            goto LABEL_190;
          goto LABEL_191;
        }
      }
    }
    else if (v36 == 124)
    {
      return v83 + 1;
    }
  }
  return result;
}

const char *arb::isidentity(arb *this, arb *a2, const char *a3, const char *a4, const char *a5)
{
  const char *v5;
  unsigned int v7;

  if (this != a2)
    return 0;
  v5 = a4;
  if (&a3[(_QWORD)this] != a4)
  {
    v7 = a5;
    if (strncmp(a4 - 4, "xyzw", 4uLL))
    {
      if (strncmp(v5 - 4, "rgba", 4uLL) && strncmp(&v5[-v7], "xyzw", v7) && strncmp(&v5[-v7], "rgba", v7))
        return 0;
    }
  }
  return v5;
}

unsigned __int8 *arb::obj_search(uint64_t a1, unint64_t a2, unsigned __int8 *a3, const char **a4)
{
  unint64_t v6;
  unint64_t v8;
  unsigned __int8 *v9;
  int v10;
  unint64_t v11;
  unsigned __int8 *v13;

  if (!a2)
    return 0;
  v6 = a2;
  while (1)
  {
    v8 = v6 >> 1;
    v13 = a3;
    v9 = (unsigned __int8 *)(a1 + 88 * (v6 >> 1));
    v10 = arb::ascan(&v13, a4, v9, (const char *)1);
    if (!v10)
      break;
    if (v10 > 0)
      v11 = v8 + 1;
    else
      v11 = 0;
    a1 += 88 * v11;
    if (v10 <= 0)
      v6 >>= 1;
    else
      v6 -= v8 + 1;
    if (!v6)
      return 0;
  }
  return v9;
}

BOOL arb::isepsilon(arb *this, const char *a2, const char *a3)
{
  const char *v3;
  const char *v4;
  char v5;
  int v6;
  char v7;
  const char *v8;
  int v9;
  int v10;
  char v11;
  int v12;
  int v13;
  int v14;
  int v15;
  const char *v17;
  int v18;
  int v19;
  int v20;
  const char *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  BOOL v30;

  v3 = (const char *)this;
  if (*a2 == 46)
  {
    v6 = *((unsigned __int8 *)a2 + 1);
    v4 = a2 + 1;
    v5 = v6;
    if (v6)
    {
      if ((v5 - 33) >= 0xE0u)
      {
        do
        {
LABEL_4:
          v7 = *++v4;
          v5 = v7;
        }
        while ((v7 - 33) > 0xDFu);
      }
LABEL_5:
      if (v5 != 35)
      {
        v28 = v5;
        v12 = 3;
        v29 = v28 - 98;
        if (v29 > 0x18)
        {
          v11 = 0;
        }
        else if (((1 << v29) & 0x410000) != 0)
        {
          v12 = 0;
          v11 = 1;
        }
        else if (((1 << v29) & 0x800020) != 0)
        {
          v11 = 0;
          v12 = 1;
        }
        else
        {
          v30 = ((1 << v29) & 0x1000001) == 0;
          v11 = 0;
          if (v30)
            v12 = 3;
          else
            v12 = 2;
        }
        goto LABEL_12;
      }
      v8 = v4;
      while (1)
      {
        v9 = *(unsigned __int8 *)++v8;
        v5 = v9;
        if (!v9)
          break;
        v10 = *(unsigned __int8 *)v4;
        v4 = v8;
        if (v10 == 10)
        {
          v4 = v8;
          if ((v5 - 33) >= 0xE0u)
            goto LABEL_4;
          goto LABEL_5;
        }
      }
    }
  }
  v11 = 0;
  v12 = 3;
  if (*(_BYTE *)this != 123)
    return !strncmp(v3, "9.999999975e-07", 0xFuLL) || strncmp(v3, "1e-6", 4uLL) == 0;
LABEL_12:
  v3 = (char *)this + 1;
  v13 = *((unsigned __int8 *)this + 1);
  if (*((_BYTE *)this + 1))
  {
    if ((v13 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_15:
        v14 = *(unsigned __int8 *)++v3;
        v13 = v14;
      }
      while ((v14 - 33) > 0xFFFFFFDF);
    }
LABEL_16:
    if (v13 == 35)
    {
      ++v3;
      while (1)
      {
        v13 = *(unsigned __int8 *)v3;
        if (!*v3)
          break;
        v15 = *((unsigned __int8 *)v3++ - 1);
        if (v15 == 10)
        {
          --v3;
          if ((v13 - 33) >= 0xFFFFFFE0)
            goto LABEL_15;
          goto LABEL_16;
        }
      }
    }
  }
  if ((v11 & 1) == 0)
  {
    while (1)
    {
      v17 = v3 - 1;
      do
      {
        v19 = *(unsigned __int8 *)++v17;
        v18 = v19;
      }
      while ((char)ctype[2 * v19] < 0);
      if (!v18)
        return 0;
      if ((v18 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_30:
          v20 = *(unsigned __int8 *)++v17;
          v18 = v20;
        }
        while ((v20 - 33) > 0xFFFFFFDF);
      }
LABEL_31:
      if (v18 == 35)
      {
        v21 = v17;
        while (1)
        {
          v22 = *(unsigned __int8 *)++v21;
          v18 = v22;
          if (!v22)
            return 0;
          v23 = *(unsigned __int8 *)v17;
          v17 = v21;
          if (v23 == 10)
          {
            v17 = v21;
            if ((v18 - 33) >= 0xFFFFFFE0)
              goto LABEL_30;
            goto LABEL_31;
          }
        }
      }
      if (v18 != 44)
        return 0;
      v25 = *((unsigned __int8 *)v17 + 1);
      v3 = v17 + 1;
      v24 = v25;
      if (v25)
      {
        if ((v24 - 33) >= 0xFFFFFFE0)
        {
          do
          {
LABEL_40:
            v26 = *(unsigned __int8 *)++v3;
            v24 = v26;
          }
          while ((v26 - 33) > 0xFFFFFFDF);
        }
LABEL_41:
        if (v24 == 35)
        {
          ++v3;
          while (1)
          {
            v24 = *(unsigned __int8 *)v3;
            if (!*v3)
              break;
            v27 = *((unsigned __int8 *)v3++ - 1);
            if (v27 == 10)
            {
              --v3;
              if ((v24 - 33) >= 0xFFFFFFE0)
                goto LABEL_40;
              goto LABEL_41;
            }
          }
        }
      }
      if (!--v12)
        return !strncmp(v3, "9.999999975e-07", 0xFuLL) || strncmp(v3, "1e-6", 4uLL) == 0;
    }
  }
  else
  {
    return !strncmp(v3, "9.999999975e-07", 0xFuLL) || strncmp(v3, "1e-6", 4uLL) == 0;
  }
}

unsigned __int8 *arb::isssat(arb *this, const char *a2)
{
  int v2;
  unsigned __int8 *v3;
  const char *i;
  int v6;
  int v7;
  unsigned __int8 *v8;
  int v9;

  v2 = *(unsigned __int8 *)this;
  if ((ctype[2 * *(unsigned __int8 *)this] & 0x40) == 0)
    return 0;
  for (i = (char *)this - 1; ; ++i)
  {
    v6 = v2;
    v2 = *((unsigned __int8 *)i + 2);
    if (v6 != 95 || v2 != 83)
      goto LABEL_6;
    if (i[3] == 83)
      break;
    v2 = 83;
LABEL_6:
    if ((ctype[2 * v2] & 0x40) == 0)
      return 0;
  }
  v3 = (unsigned __int8 *)(i + 1);
  v7 = *(unsigned __int8 *)i;
  if ((v7 - 48) < 2)
  {
    v9 = *((unsigned __int8 *)i - 1);
    v8 = (unsigned __int8 *)(i - 1);
    if (v9 == 67)
      return v8;
    return v3;
  }
  if (v7 != 67 || !strncmp(i - 2, "FRC", 3uLL) && (ctype[2 * *((unsigned __int8 *)i - 3)] & 0x40) == 0)
    return v3;
  if (strncmp(i - 4, "TRUNC", 5uLL))
    return (unsigned __int8 *)i;
  return v3;
}

_BYTE *arb::atoi(_BYTE *this, char *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  _BYTE *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;

  v3 = *this;
  if (v3 == 45)
  {
    v4 = -1;
LABEL_13:
    v9 = *++this;
    v3 = v9;
    if (!v9)
      return 0;
    goto LABEL_4;
  }
  v4 = 1;
  if (v3 == 43)
    goto LABEL_13;
  if (!*this)
    return 0;
LABEL_4:
  if ((v3 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_5:
      v5 = *++this;
      v3 = v5;
    }
    while ((v5 - 33) > 0xFFFFFFDF);
  }
LABEL_6:
  if (v3 == 35)
  {
    v6 = this;
    while (1)
    {
      v7 = *++v6;
      v3 = v7;
      if (!v7)
        return 0;
      v8 = *this;
      this = v6;
      if (v8 == 10)
      {
        this = v6;
        if ((v3 - 33) >= 0xFFFFFFE0)
          goto LABEL_5;
        goto LABEL_6;
      }
    }
  }
  if ((v3 - 58) < 0xFFFFFFF6)
    return 0;
  v10 = 0;
  do
  {
    v10 = v3 + 10 * v10 - 48;
    v11 = *++this;
    v3 = v11;
  }
  while ((v11 - 58) > 0xFFFFFFF5);
  *(_DWORD *)a2 = v10 * v4;
  v12 = *this;
  if (*this)
  {
    if ((v12 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_21:
        v13 = *++this;
        v12 = v13;
      }
      while ((v13 - 33) > 0xFFFFFFDF);
    }
LABEL_22:
    if (v12 == 35)
    {
      ++this;
      while (1)
      {
        v12 = *this;
        if (!*this)
          break;
        v14 = *(this++ - 1);
        if (v14 == 10)
        {
          --this;
          if ((v12 - 33) >= 0xFFFFFFE0)
            goto LABEL_21;
          goto LABEL_22;
        }
      }
    }
  }
  return this;
}

unsigned __int8 *arb::obj_write_op(uint64_t *a1, uint64_t a2, char *__s1)
{
  int v6;
  const char *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  char *v10;
  int v11;
  int v12;
  char *v13;
  int v14;
  char *v15;
  int v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  size_t v22;
  void *v23;
  size_t *v24;
  int64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  size_t v29;
  void *v30;
  size_t *v31;
  uint64_t *v32;
  string_t *v33;
  arb *v34;
  int v35;
  string_t v36;
  unint64_t *v37;
  arb *v38;
  int v39;
  int v40;
  arb *v41;
  int v42;
  arb *v43;
  int v44;
  int v45;
  int v46;
  arb *v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  void *v54;
  _QWORD *v55;
  string_t v56;
  unsigned __int8 *v57;
  int v58;
  arb *v59;
  int v60;
  int v61;
  int v62;
  int v64;
  int v65;
  int v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  size_t v72;
  void *v73;
  size_t *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  int v78;
  _BYTE *v79;
  int v80;
  int v81;
  int v82;
  arb *v83;
  arb *v84;
  int v85;
  int v86;
  int v87;
  int v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  size_t v93;
  void *v94;
  size_t *v95;
  int v96;
  int v97;
  int v98;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  _BYTE *v104;
  int v105;
  int v106;
  int v107;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  char *v113;
  int v114;
  int v115;
  int v116;
  const char *v117;
  char *v118;
  char v119[8];
  char v120[8];

  v6 = strncmp(__s1, "SWZ", 3uLL);
  v8 = arb::isssat((arb *)__s1, v7);
  v9 = v8;
  v10 = __s1 - 1;
  do
  {
    v12 = *++v10;
    v11 = v12;
  }
  while ((ctype[2 * v12] & 0x40) != 0);
  *(_QWORD *)v119 = 0;
  *(_QWORD *)v120 = 0;
  v117 = 0;
  v118 = 0;
  if (v11)
  {
    v13 = v10;
    if ((v11 - 33) < 0xFFFFFFE0)
      goto LABEL_6;
    do
    {
LABEL_5:
      v14 = *++v13;
      v11 = v14;
    }
    while ((v14 - 33) > 0xFFFFFFDF);
LABEL_6:
    while (v11 == 35)
    {
      v15 = v13;
      do
      {
        v16 = *++v15;
        v11 = v16;
        if (!v16)
          goto LABEL_17;
        v17 = *v13;
        v13 = v15;
      }
      while (v17 != 10);
      v13 = v15;
      if ((v11 - 33) >= 0xFFFFFFE0)
        goto LABEL_5;
    }
    if ((v11 & 0xFE) == 0x3A)
    {
      v18 = v13 + 1 - __s1;
      if (v13 + 1 == __s1)
        return 0;
      v20 = *(_QWORD *)(a2 + 8);
      v19 = *(_QWORD *)(a2 + 16);
      v21 = v20 + v18;
      if (v19)
      {
        if (v21 >= *(_QWORD *)v19)
        {
          v22 = (v21 + 255) & 0xFFFFFFFFFFFFFF00;
          v23 = malloc_type_realloc(*(void **)(v19 + 16), v22, 0xCCCD1039uLL);
          v24 = *(size_t **)(a2 + 16);
          v24[2] = (size_t)v23;
          *v24 = v22;
          *(_QWORD *)a2 = v23;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v21);
      }
      v109 = 0;
      v110 = 0;
      v111 = *(_QWORD *)a2 + v20;
      while (1)
      {
        v112 = __s1[v110];
        if ((v112 - 33) > 0xFFFFFFDF)
        {
          v113 = &__s1[++v110];
          if (__s1[v110] != 35)
            goto LABEL_155;
        }
        else
        {
          *(_BYTE *)(v111 + v109++) = v112;
          v113 = &__s1[++v110];
          if (__s1[v110] != 35)
            goto LABEL_155;
        }
        v114 = 35;
        while (v114 == 35)
        {
          ++v113;
          do
          {
            v114 = *v113;
            if (!*v113)
              goto LABEL_154;
            v116 = *(v113++ - 1);
          }
          while (v116 != 10);
          --v113;
          if ((v114 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              v115 = *++v113;
              v114 = v115;
            }
            while ((v115 - 33) > 0xFFFFFFDF);
          }
        }
LABEL_154:
        v110 = v113 - __s1;
LABEL_155:
        if (v110 >= v18)
        {
          *(_QWORD *)(a2 + 8) += v109;
          return 0;
        }
      }
    }
  }
LABEL_17:
  if (v8)
  {
    v25 = v8 - (unsigned __int8 *)__s1;
    v27 = *(_QWORD *)(a2 + 8);
    v26 = *(_QWORD *)(a2 + 16);
    v28 = v27 + v8 - (unsigned __int8 *)__s1;
    if (v26)
    {
      if (v28 >= *(_QWORD *)v26)
      {
        v29 = (v28 + 255) & 0xFFFFFFFFFFFFFF00;
        v30 = malloc_type_realloc(*(void **)(v26 + 16), v29, 0xCCCD1039uLL);
        v31 = *(size_t **)(a2 + 16);
        v31[2] = (size_t)v30;
        *v31 = v29;
        *(_QWORD *)a2 = v30;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v28);
    }
    v36 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += v25;
    memcpy((void *)&v36[v27], __s1, v9 - (unsigned __int8 *)__s1);
    v32 = a1;
    v33 = (string_t *)a2;
    v34 = (arb *)v10;
    v35 = 0;
  }
  else
  {
    v32 = a1;
    v33 = (string_t *)a2;
    v34 = (arb *)__s1;
    v35 = 1;
  }
  v38 = (arb *)arb::obj_write_dest(v32, v33, v34, v120, &v117, v35, 1);
LABEL_25:
  v39 = *(unsigned __int8 *)v38;
  if (!*(_BYTE *)v38)
  {
    v83 = v38;
    goto LABEL_102;
  }
  v40 = *(unsigned __int8 *)v38;
  v41 = v38;
  if ((v39 - 33) >= 0xFFFFFFE0)
  {
    do
    {
LABEL_27:
      v42 = *((unsigned __int8 *)v41 + 1);
      v41 = (arb *)((char *)v41 + 1);
      v40 = v42;
    }
    while ((v42 - 33) > 0xFFFFFFDF);
  }
LABEL_28:
  if (v40 != 35)
  {
    if (v40 != 44)
      goto LABEL_100;
    v48 = *((unsigned __int8 *)v41 + 1);
    v47 = (arb *)((char *)v41 + 1);
    v46 = v48;
    if (v48)
    {
      if ((v46 - 33) >= 0xFFFFFFE0)
      {
        do
        {
LABEL_37:
          v49 = *((unsigned __int8 *)v47 + 1);
          v47 = (arb *)((char *)v47 + 1);
          v46 = v49;
        }
        while ((v49 - 33) > 0xFFFFFFDF);
      }
LABEL_38:
      if (v46 == 35)
      {
        v47 = (arb *)((char *)v47 + 1);
        while (1)
        {
          v46 = *(unsigned __int8 *)v47;
          if (!*(_BYTE *)v47)
            break;
          v50 = *((unsigned __int8 *)v47 - 1);
          v47 = (arb *)((char *)v47 + 1);
          if (v50 == 10)
          {
            v47 = (arb *)((char *)v47 - 1);
            if ((v46 - 33) >= 0xFFFFFFE0)
              goto LABEL_37;
            goto LABEL_38;
          }
        }
      }
    }
    v52 = *(_QWORD *)(a2 + 8);
    v51 = *(_QWORD *)(a2 + 16);
    v53 = v52 + 1;
    if (v51)
    {
      if (v53 >= *(_QWORD *)v51)
      {
        v54 = malloc_type_realloc(*(void **)(v51 + 16), (v52 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
        v55 = *(_QWORD **)(a2 + 16);
        v55[2] = v54;
        *v55 = (v52 & 0xFFFFFFFFFFFFFF00) + 256;
        *(_QWORD *)a2 = v54;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v53);
    }
    v56 = *(string_t *)a2;
    ++*(_QWORD *)(a2 + 8);
    v56[v52] = 44;
    v57 = arb::asymbol(v47, v119, (const char **)&v118, v37);
    if (v57)
    {
      v38 = (arb *)arb::obj_write_symbol(a1, a2, (const char *)v47, *(const char **)v119, v118, (char *)v57);
      goto LABEL_98;
    }
    v58 = *(unsigned __int8 *)v47;
    if (v58 != 40)
    {
LABEL_80:
      v38 = v47;
      goto LABEL_98;
    }
    v59 = v47;
    while (1)
    {
      if (v58 == 35)
      {
LABEL_55:
        if (v58 == 35)
        {
          v59 = (arb *)((char *)v59 + 1);
          while (1)
          {
            v58 = *(unsigned __int8 *)v59;
            if (!*(_BYTE *)v59)
              break;
            v61 = *((unsigned __int8 *)v59 - 1);
            v59 = (arb *)((char *)v59 + 1);
            if (v61 == 10)
            {
              v59 = (arb *)((char *)v59 - 1);
              if ((v58 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  v60 = *((unsigned __int8 *)v59 + 1);
                  v59 = (arb *)((char *)v59 + 1);
                  v58 = v60;
                }
                while ((v60 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_55;
            }
          }
LABEL_67:
          v65 = *((unsigned __int8 *)v59 + 1);
          v38 = (arb *)((char *)v59 + 1);
          v64 = v65;
          if (v65)
          {
            if ((v64 - 33) >= 0xFFFFFFE0)
            {
              do
              {
LABEL_69:
                v66 = *((unsigned __int8 *)v38 + 1);
                v38 = (arb *)((char *)v38 + 1);
                v64 = v66;
              }
              while ((v66 - 33) > 0xFFFFFFDF);
            }
LABEL_70:
            if (v64 == 35)
            {
              v38 = (arb *)((char *)v38 + 1);
              while (1)
              {
                v64 = *(unsigned __int8 *)v38;
                if (!*(_BYTE *)v38)
                  break;
                v67 = *((unsigned __int8 *)v38 - 1);
                v38 = (arb *)((char *)v38 + 1);
                if (v67 == 10)
                {
                  v38 = (arb *)((char *)v38 - 1);
                  if ((v64 - 33) >= 0xFFFFFFE0)
                    goto LABEL_69;
                  goto LABEL_70;
                }
              }
            }
          }
          v68 = v38 - v47;
          if (v38 == v47)
            goto LABEL_80;
          v70 = *(_QWORD *)(a2 + 8);
          v69 = *(_QWORD *)(a2 + 16);
          v71 = v70 + v68;
          if (v69)
          {
            if (v71 >= *(_QWORD *)v69)
            {
              v72 = (v71 + 255) & 0xFFFFFFFFFFFFFF00;
              v73 = malloc_type_realloc(*(void **)(v69 + 16), v72, 0xCCCD1039uLL);
              v74 = *(size_t **)(a2 + 16);
              v74[2] = (size_t)v73;
              *v74 = v72;
              *(_QWORD *)a2 = v73;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v71);
          }
          v75 = 0;
          v76 = 0;
          v77 = *(_QWORD *)a2 + v70;
          while (2)
          {
            v78 = *((unsigned __int8 *)v47 + v76);
            if ((v78 - 33) > 0xFFFFFFDF)
            {
              ++v76;
              v79 = (char *)v47 + v76;
              if (*((_BYTE *)v47 + v76) == 35)
              {
LABEL_89:
                v80 = 35;
LABEL_91:
                if (v80 == 35)
                {
                  ++v79;
                  while (1)
                  {
                    v80 = *v79;
                    if (!*v79)
                      break;
                    v82 = *(v79++ - 1);
                    if (v82 == 10)
                    {
                      --v79;
                      if ((v80 - 33) >= 0xFFFFFFE0)
                      {
                        do
                        {
                          v81 = *++v79;
                          v80 = v81;
                        }
                        while ((v81 - 33) > 0xFFFFFFDF);
                      }
                      goto LABEL_91;
                    }
                  }
                }
                v76 = v79 - (_BYTE *)v47;
              }
            }
            else
            {
              *(_BYTE *)(v77 + v75++) = v78;
              ++v76;
              v79 = (char *)v47 + v76;
              if (*((_BYTE *)v47 + v76) == 35)
                goto LABEL_89;
            }
            if (v76 < v68)
              continue;
            break;
          }
          *(_QWORD *)(a2 + 8) += v75;
LABEL_98:
          if (!v6)
          {
            v39 = *(unsigned __int8 *)v38;
            goto LABEL_100;
          }
          goto LABEL_25;
        }
      }
      else
      {
        v62 = *((unsigned __int8 *)v59 + 1);
        v59 = (arb *)((char *)v59 + 1);
        v58 = v62;
      }
      if (v58 == 41 || v58 == 0)
        goto LABEL_67;
    }
  }
  v43 = v41;
  while (1)
  {
    v44 = *((unsigned __int8 *)v43 + 1);
    v43 = (arb *)((char *)v43 + 1);
    v40 = v44;
    if (!v44)
      break;
    v45 = *(unsigned __int8 *)v41;
    v41 = v43;
    if (v45 == 10)
    {
      v41 = v43;
      if ((v40 - 33) >= 0xFFFFFFE0)
        goto LABEL_27;
      goto LABEL_28;
    }
  }
LABEL_100:
  v83 = v38;
  if (!v39 || v39 == 59)
    goto LABEL_102;
  while (2)
  {
    if (v39 != 35)
    {
      v98 = *((unsigned __int8 *)v83 + 1);
      v83 = (arb *)((char *)v83 + 1);
      v39 = v98;
LABEL_125:
      if (v39 == 59 || v39 == 0)
        goto LABEL_102;
      continue;
    }
    break;
  }
LABEL_118:
  if (v39 != 35)
    goto LABEL_125;
  v83 = (arb *)((char *)v83 + 1);
  while (1)
  {
    v39 = *(unsigned __int8 *)v83;
    if (!*(_BYTE *)v83)
      break;
    v97 = *((unsigned __int8 *)v83 - 1);
    v83 = (arb *)((char *)v83 + 1);
    if (v97 == 10)
    {
      v83 = (arb *)((char *)v83 - 1);
      if ((v39 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          v96 = *((unsigned __int8 *)v83 + 1);
          v83 = (arb *)((char *)v83 + 1);
          v39 = v96;
        }
        while ((v96 - 33) > 0xFFFFFFDF);
      }
      goto LABEL_118;
    }
  }
LABEL_102:
  v86 = *((unsigned __int8 *)v83 + 1);
  v84 = (arb *)((char *)v83 + 1);
  v85 = v86;
  if (v86)
  {
    if ((v85 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_104:
        v87 = *((unsigned __int8 *)v84 + 1);
        v84 = (arb *)((char *)v84 + 1);
        v85 = v87;
      }
      while ((v87 - 33) > 0xFFFFFFDF);
    }
LABEL_105:
    if (v85 == 35)
    {
      v84 = (arb *)((char *)v84 + 1);
      while (1)
      {
        v85 = *(unsigned __int8 *)v84;
        if (!*(_BYTE *)v84)
          break;
        v88 = *((unsigned __int8 *)v84 - 1);
        v84 = (arb *)((char *)v84 + 1);
        if (v88 == 10)
        {
          v84 = (arb *)((char *)v84 - 1);
          if ((v85 - 33) >= 0xFFFFFFE0)
            goto LABEL_104;
          goto LABEL_105;
        }
      }
    }
  }
  v89 = v84 - v38;
  if (v84 == v38)
    goto LABEL_148;
  v91 = *(_QWORD *)(a2 + 8);
  v90 = *(_QWORD *)(a2 + 16);
  v92 = v91 + v89;
  if (v90)
  {
    if (v92 >= *(_QWORD *)v90)
    {
      v93 = (v92 + 255) & 0xFFFFFFFFFFFFFF00;
      v94 = malloc_type_realloc(*(void **)(v90 + 16), v93, 0xCCCD1039uLL);
      v95 = *(size_t **)(a2 + 16);
      v95[2] = (size_t)v94;
      *v95 = v93;
      *(_QWORD *)a2 = v94;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v92);
  }
  v100 = 0;
  v101 = 0;
  v102 = *(_QWORD *)a2 + v91;
  while (2)
  {
    v103 = *((unsigned __int8 *)v38 + v101);
    if ((v103 - 33) > 0xFFFFFFDF)
    {
      ++v101;
      v104 = (char *)v38 + v101;
      if (*((_BYTE *)v38 + v101) == 35)
      {
LABEL_139:
        v105 = 35;
LABEL_141:
        if (v105 == 35)
        {
          ++v104;
          while (1)
          {
            v105 = *v104;
            if (!*v104)
              break;
            v107 = *(v104++ - 1);
            if (v107 == 10)
            {
              --v104;
              if ((v105 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  v106 = *++v104;
                  v105 = v106;
                }
                while ((v106 - 33) > 0xFFFFFFDF);
              }
              goto LABEL_141;
            }
          }
        }
        v101 = v104 - (_BYTE *)v38;
      }
    }
    else
    {
      *(_BYTE *)(v102 + v100++) = v103;
      ++v101;
      v104 = (char *)v38 + v101;
      if (*((_BYTE *)v38 + v101) == 35)
        goto LABEL_139;
    }
    if (v101 < v89)
      continue;
    break;
  }
  *(_QWORD *)(a2 + 8) += v100;
LABEL_148:
  if (!v9)
    return 0;
  return v9;
}

unsigned __int8 *arb::obj_write_dest(uint64_t *a1, string_t *a2, arb *this, char *a4, const char **a5, int a6, int a7)
{
  char *v10;
  arb *v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  const char *v22;
  unint64_t v23;
  unint64_t v24;
  string_t v25;
  size_t v27;
  const char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  const char *v32;
  int v33;
  _BYTE *v34;
  int v35;
  int v36;
  int v37;
  unint64_t v38;
  string_t v39;
  const char *v40;
  char *v41;
  string_t v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  int v45;
  char *v46;
  unint64_t v47;
  unsigned __int8 *v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  unint64_t v53;
  const char *v54;
  char *v55;
  _QWORD *v56;
  string_t *v57;
  const char *v58;
  char *v59;
  int v60;
  const char *v61;
  int v62;
  const char *v63;
  int v64;
  int v65;
  string_t v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  char *v70;
  const char *v71;
  int v72;
  int v73;
  int v74;
  int v76;
  int v77;
  int v78;
  int v79;
  string_t v81;
  signed int v82;
  string_t v83;
  string_t v84;
  unint64_t v85;
  const char *v86;
  char *v87;
  int v88;
  int v89;
  const char **v90;
  unsigned __int8 *v92;

  v10 = a4;
  v13 = this;
  while (1)
  {
    do
    {
      v14 = (unsigned __int8 *)v13;
      v16 = *(unsigned __int8 *)v13;
      v13 = (arb *)((char *)v13 + 1);
      v15 = v16;
    }
    while ((ctype[2 * v16] & 0x40) != 0);
    if (!v15)
      break;
    if ((v15 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_5:
        v17 = *++v14;
        v15 = v17;
      }
      while ((v17 - 33) > 0xFFFFFFDF);
    }
LABEL_6:
    if (v15 == 35)
    {
      ++v14;
      while (1)
      {
        v15 = *v14;
        if (!*v14)
          goto LABEL_24;
        v18 = *(v14++ - 1);
        if (v18 == 10)
        {
          --v14;
          if ((v15 - 33) >= 0xFFFFFFE0)
            goto LABEL_5;
          goto LABEL_6;
        }
      }
    }
    if (v15 != 46)
      break;
    v19 = v14[1];
    v13 = (arb *)(v14 + 1);
    if (!v14[1])
    {
LABEL_23:
      v14 = (unsigned __int8 *)v13;
      break;
    }
    if ((v19 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_15:
        v20 = *((unsigned __int8 *)v13 + 1);
        v13 = (arb *)((char *)v13 + 1);
        v19 = v20;
      }
      while ((v20 - 33) > 0xFFFFFFDF);
    }
LABEL_16:
    if (v19 == 35)
    {
      v14 = (unsigned __int8 *)v13 + 1;
      while (1)
      {
        v19 = *v14;
        if (!*v14)
          goto LABEL_24;
        v21 = *(v14++ - 1);
        if (v21 == 10)
        {
          v13 = (arb *)(v14 - 1);
          if ((v19 - 33) >= 0xFFFFFFE0)
            goto LABEL_15;
          goto LABEL_16;
        }
      }
    }
    if (!v19)
      goto LABEL_23;
  }
LABEL_24:
  v22 = a2[1];
  v23 = v14 - (unsigned __int8 *)this;
  if (v14 == (unsigned __int8 *)this)
    goto LABEL_45;
  v24 = (unint64_t)&v22[v23];
  v25 = a2[2];
  if (v25)
  {
    if (v24 >= *(_QWORD *)v25)
    {
      v27 = (v24 + 255) & 0xFFFFFFFFFFFFFF00;
      v28 = (const char *)malloc_type_realloc(*((void **)v25 + 2), v27, 0xCCCD1039uLL);
      v29 = (char *)a2[2];
      *((_QWORD *)v29 + 2) = v28;
      *(_QWORD *)v29 = v27;
      v10 = a4;
      *a2 = v28;
    }
  }
  else
  {
    str_alloc(a2, v24);
  }
  v30 = 0;
  v31 = 0;
  v32 = &v22[(_QWORD)*a2];
  do
  {
    v33 = *((unsigned __int8 *)this + v31);
    if ((v33 - 33) <= 0xFFFFFFDF)
    {
      v32[v30++] = v33;
      ++v31;
      v34 = (char *)this + v31;
      if (*((_BYTE *)this + v31) != 35)
        continue;
    }
    else
    {
      ++v31;
      v34 = (char *)this + v31;
      if (*((_BYTE *)this + v31) != 35)
        continue;
    }
    v35 = 35;
LABEL_38:
    if (v35 == 35)
    {
      ++v34;
      while (1)
      {
        v35 = *v34;
        if (!*v34)
          break;
        v37 = *(v34++ - 1);
        if (v37 == 10)
        {
          --v34;
          if ((v35 - 33) >= 0xFFFFFFE0)
          {
            do
            {
              v36 = *++v34;
              v35 = v36;
            }
            while ((v36 - 33) > 0xFFFFFFDF);
          }
          goto LABEL_38;
        }
      }
    }
    v31 = v34 - (_BYTE *)this;
  }
  while (v31 < v23);
  v22 = &a2[1][v30];
  a2[1] = v22;
LABEL_45:
  v38 = (unint64_t)(v22 + 1);
  v39 = a2[2];
  if (v39)
  {
    if (v38 >= *(_QWORD *)v39)
    {
      v40 = (const char *)malloc_type_realloc(*((void **)v39 + 2), ((unint64_t)v22 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v41 = (char *)a2[2];
      *((_QWORD *)v41 + 2) = v40;
      *(_QWORD *)v41 = ((unint64_t)v22 & 0xFFFFFFFFFFFFFF00) + 256;
      *a2 = v40;
    }
  }
  else
  {
    str_alloc(a2, v38);
  }
  v42 = *a2;
  ++a2[1];
  v22[(_QWORD)v42] = 32;
  v43 = arb::asymbol((arb *)v14, v10, a5, (unint64_t *)a4);
  if (!v43)
  {
    v44 = v14;
    goto LABEL_67;
  }
  v44 = v43;
  if ((a6 & 1) != 0)
    goto LABEL_62;
  v45 = a6;
  v46 = v10;
  v90 = a5;
  v88 = v45;
  v89 = a7;
  v47 = a1[1];
  if (!v47)
  {
LABEL_61:
    a7 = v89;
    v10 = v46;
    a6 = v88;
LABEL_62:
    v54 = *(const char **)v10;
    v55 = (char *)*a5;
    if (a7)
    {
      v56 = a1;
      v57 = a2;
      v58 = (const char *)v14;
      v59 = (char *)v44;
    }
    else
    {
      v59 = &v55[(_QWORD)v54];
      v56 = a1;
      v57 = a2;
      v58 = *(const char **)v10;
    }
    arb::obj_write_symbol(v56, (uint64_t)v57, v58, v54, v55, v59);
    goto LABEL_67;
  }
  v48 = *(unsigned __int8 **)v10;
  v49 = (char *)*a5;
  v50 = *a1;
  while (1)
  {
    v51 = v47 >> 1;
    v92 = v48;
    v52 = arb::ascan(&v92, (const char **)v49, (unsigned __int8 *)(v50 + 88 * (v47 >> 1)), (const char *)1);
    if (!v52)
      break;
    if (v52 > 0)
      v53 = v51 + 1;
    else
      v53 = 0;
    v50 += 88 * v53;
    if (v52 <= 0)
      v47 >>= 1;
    else
      v47 -= v51 + 1;
    if (!v47)
      goto LABEL_61;
  }
  a7 = v89;
  v10 = v46;
  a6 = v88;
  if (!v50 || *(_UNKNOWN **)(v50 + 88 * v51 + 40) != &outputKind)
    goto LABEL_62;
  v67 = (unint64_t)a2[1];
  v66 = a2[2];
  v68 = v67 + 1;
  if (v66)
  {
    if (v68 >= *(_QWORD *)v66)
    {
      v69 = (const char *)malloc_type_realloc(*((void **)v66 + 2), (v67 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v70 = (char *)a2[2];
      *((_QWORD *)v70 + 2) = v69;
      *(_QWORD *)v70 = (v67 & 0xFFFFFFFFFFFFFF00) + 256;
      *a2 = v69;
    }
  }
  else
  {
    str_alloc(a2, v68);
  }
  v81 = *a2;
  ++a2[1];
  v81[v67] = 114;
  v82 = *((_DWORD *)a1 + 15);
  v84 = a2[1];
  v83 = a2[2];
  v85 = (unint64_t)(v84 + 20);
  if (v83)
  {
    if (v85 >= *(_QWORD *)v83)
    {
      v86 = (const char *)malloc_type_realloc(*((void **)v83 + 2), (unint64_t)(v84 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v87 = (char *)a2[2];
      *((_QWORD *)v87 + 2) = v86;
      *(_QWORD *)v87 = (unint64_t)(v84 + 275) & 0xFFFFFFFFFFFFFF00;
      *a2 = v86;
    }
  }
  else
  {
    str_alloc(a2, v85);
  }
  a2[1] += itoa((char *)&v84[(_QWORD)*a2], v82);
  if (v89)
    str_putm(a2, &(*v90)[*(_QWORD *)v10], v44 - (unsigned __int8 *)&(*v90)[*(_QWORD *)v10]);
LABEL_67:
  v60 = *v44;
  if (!*v44)
    return v44;
  v61 = (const char *)v44;
LABEL_69:
  if ((v60 - 33) >= 0xFFFFFFE0)
  {
    do
    {
      v62 = *(unsigned __int8 *)++v61;
      v60 = v62;
    }
    while ((v62 - 33) > 0xFFFFFFDF);
  }
  if (v60 == 35)
  {
    v63 = v61;
    while (1)
    {
      v64 = *(unsigned __int8 *)++v61;
      v60 = v64;
      if (!v64)
        return v44;
      v65 = *(unsigned __int8 *)v63;
      v63 = v61;
      if (v65 == 10)
        goto LABEL_69;
    }
  }
  if (v60 != 40)
    return v44;
  v71 = v61;
  while (2)
  {
    if (v60 != 35)
    {
      v74 = *(unsigned __int8 *)++v71;
      v60 = v74;
LABEL_93:
      if (v60 == 41 || v60 == 0)
        goto LABEL_98;
      continue;
    }
    break;
  }
LABEL_86:
  if (v60 != 35)
    goto LABEL_93;
  ++v71;
  while (1)
  {
    v60 = *(unsigned __int8 *)v71;
    if (!*v71)
      break;
    v73 = *((unsigned __int8 *)v71++ - 1);
    if (v73 == 10)
    {
      --v71;
      if ((v60 - 33) >= 0xFFFFFFE0)
      {
        do
        {
          v72 = *(unsigned __int8 *)++v71;
          v60 = v72;
        }
        while ((v72 - 33) > 0xFFFFFFDF);
      }
      goto LABEL_86;
    }
  }
LABEL_98:
  v77 = *((unsigned __int8 *)v71 + 1);
  v44 = (unsigned __int8 *)(v71 + 1);
  v76 = v77;
  if (v77)
  {
    if ((v76 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_100:
        v78 = *++v44;
        v76 = v78;
      }
      while ((v78 - 33) > 0xFFFFFFDF);
    }
LABEL_101:
    if (v76 == 35)
    {
      ++v44;
      while (1)
      {
        v76 = *v44;
        if (!*v44)
          break;
        v79 = *(v44++ - 1);
        if (v79 == 10)
        {
          --v44;
          if ((v76 - 33) >= 0xFFFFFFE0)
            goto LABEL_100;
          goto LABEL_101;
        }
      }
    }
  }
  if (a6)
    str_putm(a2, v61, v44 - (unsigned __int8 *)v61);
  return v44;
}

char *arb::obj_write_symbol(_QWORD *a1, uint64_t a2, const char *a3, const char *a4, char *a5, char *a6)
{
  unint64_t v11;
  uint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  size_t v21;
  void *v22;
  size_t *v23;
  unsigned int *v24;
  int v25;
  const char *v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  size_t v31;
  void *v32;
  size_t *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  size_t v37;
  void *v38;
  size_t *v39;
  uint64_t v40;
  _BYTE *v41;
  uint64_t v42;
  int v43;
  _BYTE *v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  _BYTE *v52;
  uint64_t v53;
  int v54;
  _BYTE *v55;
  int v56;
  int v57;
  int v58;
  void *v59;
  unint64_t *v60;
  string_t v61;
  signed int v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  void *v66;
  unint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  void *v72;
  _QWORD *v73;
  string_t v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  size_t v79;
  void *v80;
  size_t *v81;
  _BYTE *v82;
  uint64_t v83;
  int v84;
  _BYTE *v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  uint64_t v93;
  _BYTE *v94;
  uint64_t v95;
  int v96;
  _BYTE *v97;
  int v98;
  int v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  _QWORD *v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  void *v109;
  size_t *v110;
  uint64_t v111;
  _BYTE *v112;
  uint64_t v113;
  int v114;
  _BYTE *v115;
  int v116;
  int v117;
  int v118;
  uint64_t v119;
  signed int *v120;
  signed int v121;
  signed int v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  void *v129;
  unint64_t *v130;
  void *v131;
  unint64_t *v132;
  string_t v133;
  char *v134;
  void *v135;
  unint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  void *v141;
  _QWORD *v142;
  string_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  size_t v150;
  void *v151;
  size_t *v152;
  uint64_t v153;
  _BYTE *v154;
  uint64_t v155;
  int v156;
  _BYTE *v157;
  int v158;
  int v159;
  int v160;
  char *v161;
  int v162;
  int v163;
  int v164;
  int v165;
  arb *v166;
  int v167;
  int v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  void *v173;
  _QWORD *v174;
  string_t v175;
  unsigned __int8 *v176;
  size_t v177;
  void **v178;
  _QWORD *v179;
  char v180[4];
  char *v181;
  char v182[8];

  v181 = a5;
  v11 = a1[1];
  if (v11)
  {
    v13 = *a1;
    while (1)
    {
      v14 = v11 >> 1;
      *(_QWORD *)v182 = a4;
      v15 = arb::ascan((unsigned __int8 **)v182, (const char **)a5, (unsigned __int8 *)(v13 + 88 * (v11 >> 1)), (const char *)1);
      if (!v15)
        break;
      if (v15 > 0)
        v17 = v14 + 1;
      else
        v17 = 0;
      v13 += 88 * v17;
      if (v15 <= 0)
        v11 >>= 1;
      else
        v11 -= v14 + 1;
      if (!v11)
        goto LABEL_17;
    }
    *(_QWORD *)v182 = 0;
    if (v13)
    {
      v179 = a1;
      if (a3 == a4)
        goto LABEL_122;
      v19 = *(_QWORD *)(a2 + 8);
      v18 = *(_QWORD *)(a2 + 16);
      v20 = v19 + a4 - a3;
      if (v18)
      {
        if (v20 >= *(_QWORD *)v18)
        {
          v21 = (v20 + 255) & 0xFFFFFFFFFFFFFF00;
          v22 = malloc_type_realloc(*(void **)(v18 + 16), v21, 0xCCCD1039uLL);
          v23 = *(size_t **)(a2 + 16);
          v23[2] = (size_t)v22;
          *v23 = v21;
          *(_QWORD *)a2 = v22;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v20);
      }
      v93 = 0;
      v94 = 0;
      v95 = *(_QWORD *)a2 + v19;
      while (1)
      {
        v96 = v94[(_QWORD)a3];
        if ((v96 - 33) <= 0xFFFFFFDF)
        {
          *(_BYTE *)(v95 + v93++) = v96;
          v97 = &(++v94)[(_QWORD)a3];
          if (v94[(_QWORD)a3] == 35)
          {
LABEL_113:
            v98 = 35;
            while (v98 == 35)
            {
              ++v97;
              do
              {
                v98 = *v97;
                if (!*v97)
                  goto LABEL_107;
                v100 = *(v97++ - 1);
              }
              while (v100 != 10);
              --v97;
              if ((v98 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  v99 = *++v97;
                  v98 = v99;
                }
                while ((v99 - 33) > 0xFFFFFFDF);
              }
            }
LABEL_107:
            v94 = (_BYTE *)(v97 - a3);
          }
        }
        else
        {
          v97 = &(++v94)[(_QWORD)a3];
          if (v94[(_QWORD)a3] == 35)
            goto LABEL_113;
        }
        if ((unint64_t)v94 >= a4 - a3)
        {
          *(_QWORD *)(a2 + 8) += v93;
LABEL_122:
          v101 = v13 + 88 * v14;
          v102 = *(_QWORD *)(v101 + 40);
          v178 = (void **)(v101 + 40);
          v105 = *(_QWORD *)(v101 + 48);
          v104 = (_QWORD *)(v101 + 48);
          v103 = v105;
          if (!v105)
            goto LABEL_143;
          v107 = *(_QWORD *)(a2 + 8);
          v106 = *(_QWORD *)(a2 + 16);
          v108 = v107 + v103;
          if (v106)
          {
            if (v108 >= *(_QWORD *)v106)
            {
              v177 = (v108 + 255) & 0xFFFFFFFFFFFFFF00;
              v109 = malloc_type_realloc(*(void **)(v106 + 16), v177, 0xCCCD1039uLL);
              v110 = *(size_t **)(a2 + 16);
              v110[2] = (size_t)v109;
              *v110 = v177;
              *(_QWORD *)a2 = v109;
            }
          }
          else
          {
            str_alloc((string_t *)a2, v108);
          }
          v111 = 0;
          v112 = 0;
          v113 = *(_QWORD *)a2 + v107;
          while (2)
          {
            v114 = v112[v102];
            if ((v114 - 33) <= 0xFFFFFFDF)
            {
              *(_BYTE *)(v113 + v111++) = v114;
              ++v112;
              v115 = &v112[v102];
              if (v112[v102] == 35)
              {
LABEL_134:
                v116 = 35;
                while (v116 == 35)
                {
                  ++v115;
                  do
                  {
                    v116 = *v115;
                    if (!*v115)
                      goto LABEL_128;
                    v118 = *(v115++ - 1);
                  }
                  while (v118 != 10);
                  --v115;
                  if ((v116 - 33) >= 0xFFFFFFE0)
                  {
                    do
                    {
                      v117 = *++v115;
                      v116 = v117;
                    }
                    while ((v117 - 33) > 0xFFFFFFDF);
                  }
                }
LABEL_128:
                v112 = &v115[-v102];
              }
            }
            else
            {
              ++v112;
              v115 = &v112[v102];
              if (v112[v102] == 35)
                goto LABEL_134;
            }
            if ((unint64_t)v112 >= v103)
            {
              *(_QWORD *)(a2 + 8) += v111;
LABEL_143:
              v119 = v13 + 88 * v14;
              v122 = *(_DWORD *)(v119 + 56);
              v120 = (signed int *)(v119 + 56);
              v121 = v122;
              if (v122 != -1)
              {
                if ((*(_BYTE *)(v13 + 88 * v14 + 80) & 0x10) == 0)
                {
                  v124 = *(_QWORD *)(a2 + 8);
                  v123 = *(_QWORD *)(a2 + 16);
                  v125 = v124 + 20;
                  if (*((char *)*v178 + *v104 - 1) == 91)
                  {
                    if (!v123)
                      goto LABEL_147;
LABEL_156:
                    if (v125 >= *(_QWORD *)v123)
                    {
                      v135 = malloc_type_realloc(*(void **)(v123 + 16), (v124 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      v136 = *(unint64_t **)(a2 + 16);
                      v136[2] = (unint64_t)v135;
                      *v136 = (v124 + 275) & 0xFFFFFFFFFFFFFF00;
                      *(_QWORD *)a2 = v135;
                    }
                    goto LABEL_158;
                  }
                  if (v123)
                  {
                    if (v125 >= *(_QWORD *)v123)
                    {
                      v131 = malloc_type_realloc(*(void **)(v123 + 16), (v124 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                      v132 = *(unint64_t **)(a2 + 16);
                      v132[2] = (unint64_t)v131;
                      *v132 = (v124 + 275) & 0xFFFFFFFFFFFFFF00;
                      *(_QWORD *)a2 = v131;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)a2, v125);
                  }
                  *(_QWORD *)(a2 + 8) += itoa((char *)(*(_QWORD *)a2 + v124), v121);
                  if ((*(_BYTE *)(v13 + 88 * v14 + 80) & 0x20) == 0)
                  {
LABEL_185:
                    v161 = &a5[(_QWORD)a4];
                    if (v161 == a6)
                      goto LABEL_95;
                    if (*v178 == &arrayKind)
                    {
                      v162 = *v161;
                      if (*v161)
                      {
                        if ((v162 - 33) < 0xFFFFFFE0)
                          goto LABEL_190;
                        do
                        {
LABEL_189:
                          v163 = *++v161;
                          v162 = v163;
                        }
                        while ((v163 - 33) > 0xFFFFFFDF);
LABEL_190:
                        while (v162 == 35)
                        {
                          ++v161;
                          do
                          {
                            v162 = *v161;
                            if (!*v161)
                              goto LABEL_196;
                            v164 = *(v161++ - 1);
                          }
                          while (v164 != 10);
                          --v161;
                          if ((v162 - 33) >= 0xFFFFFFE0)
                            goto LABEL_189;
                        }
                      }
LABEL_196:
                      v167 = v161[1];
                      v166 = (arb *)(v161 + 1);
                      v165 = v167;
                      if (v167)
                      {
                        if ((v165 - 33) < 0xFFFFFFE0)
                          goto LABEL_199;
                        do
                        {
LABEL_198:
                          v168 = *((unsigned __int8 *)v166 + 1);
                          v166 = (arb *)((char *)v166 + 1);
                          v165 = v168;
                        }
                        while ((v168 - 33) > 0xFFFFFFDF);
LABEL_199:
                        while (v165 == 35)
                        {
                          v166 = (arb *)((char *)v166 + 1);
                          do
                          {
                            v165 = *(unsigned __int8 *)v166;
                            if (!*(_BYTE *)v166)
                              goto LABEL_205;
                            v169 = *((unsigned __int8 *)v166 - 1);
                            v166 = (arb *)((char *)v166 + 1);
                          }
                          while (v169 != 10);
                          v166 = (arb *)((char *)v166 - 1);
                          if ((v165 - 33) >= 0xFFFFFFE0)
                            goto LABEL_198;
                        }
                      }
LABEL_205:
                      v171 = *(_QWORD *)(a2 + 8);
                      v170 = *(_QWORD *)(a2 + 16);
                      v172 = v171 + 1;
                      if (v170)
                      {
                        if (v172 >= *(_QWORD *)v170)
                        {
                          v173 = malloc_type_realloc(*(void **)(v170 + 16), (v171 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                          v174 = *(_QWORD **)(a2 + 16);
                          v174[2] = v173;
                          *v174 = (v171 & 0xFFFFFFFFFFFFFF00) + 256;
                          *(_QWORD *)a2 = v173;
                        }
                      }
                      else
                      {
                        str_alloc((string_t *)a2, v172);
                      }
                      v175 = *(string_t *)a2;
                      ++*(_QWORD *)(a2 + 8);
                      v175[v171] = 91;
                      v176 = arb::asymbol(v166, v182, (const char **)&v181, v16);
                      v161 = (char *)arb::obj_write_symbol(v179, a2, v166, *(_QWORD *)v182, v181, v176);
                    }
                    str_putm((string_t *)a2, v161, a6 - v161);
                    goto LABEL_95;
                  }
LABEL_164:
                  v144 = v13 + 88 * v14;
                  v145 = *(_QWORD *)(v144 + 72);
                  if (!v145)
                    goto LABEL_185;
                  v146 = *(_QWORD *)(v144 + 64);
                  v148 = *(_QWORD *)(a2 + 8);
                  v147 = *(_QWORD *)(a2 + 16);
                  v149 = v148 + v145;
                  if (v147)
                  {
                    if (v149 >= *(_QWORD *)v147)
                    {
                      v150 = (v149 + 255) & 0xFFFFFFFFFFFFFF00;
                      v151 = malloc_type_realloc(*(void **)(v147 + 16), v150, 0xCCCD1039uLL);
                      v152 = *(size_t **)(a2 + 16);
                      v152[2] = (size_t)v151;
                      *v152 = v150;
                      *(_QWORD *)a2 = v151;
                    }
                  }
                  else
                  {
                    str_alloc((string_t *)a2, v149);
                  }
                  v153 = 0;
                  v154 = 0;
                  v155 = *(_QWORD *)a2 + v148;
                  while (2)
                  {
                    v156 = v154[v146];
                    if ((v156 - 33) <= 0xFFFFFFDF)
                    {
                      *(_BYTE *)(v155 + v153++) = v156;
                      ++v154;
                      v157 = &v154[v146];
                      if (v154[v146] == 35)
                      {
LABEL_176:
                        v158 = 35;
                        while (v158 == 35)
                        {
                          ++v157;
                          do
                          {
                            v158 = *v157;
                            if (!*v157)
                              goto LABEL_170;
                            v160 = *(v157++ - 1);
                          }
                          while (v160 != 10);
                          --v157;
                          if ((v158 - 33) >= 0xFFFFFFE0)
                          {
                            do
                            {
                              v159 = *++v157;
                              v158 = v159;
                            }
                            while ((v159 - 33) > 0xFFFFFFDF);
                          }
                        }
LABEL_170:
                        v154 = &v157[-v146];
                      }
                    }
                    else
                    {
                      ++v154;
                      v157 = &v154[v146];
                      if (v154[v146] == 35)
                        goto LABEL_176;
                    }
                    if ((unint64_t)v154 >= v145)
                    {
                      *(_QWORD *)(a2 + 8) += v153;
                      goto LABEL_185;
                    }
                    continue;
                  }
                }
                v127 = *(_QWORD *)(a2 + 8);
                v126 = *(_QWORD *)(a2 + 16);
                v128 = v127 + 5;
                if (v126)
                {
                  if (v128 >= *(_QWORD *)v126)
                  {
                    v129 = malloc_type_realloc(*(void **)(v126 + 16), (v127 + 260) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
                    v130 = *(unint64_t **)(a2 + 16);
                    v130[2] = (unint64_t)v129;
                    *v130 = (v127 + 260) & 0xFFFFFFFFFFFFFF00;
                    *(_QWORD *)a2 = v129;
                  }
                }
                else
                {
                  str_alloc((string_t *)a2, v128);
                }
                v133 = *(string_t *)a2;
                *(_QWORD *)(a2 + 8) += 5;
                v134 = (char *)&v133[v127];
                v134[4] = 91;
                *(_DWORD *)v134 = 2003792430;
                v121 = *v120;
                v124 = *(_QWORD *)(a2 + 8);
                v123 = *(_QWORD *)(a2 + 16);
                v125 = v124 + 20;
                if (v123)
                  goto LABEL_156;
LABEL_147:
                str_alloc((string_t *)a2, v125);
LABEL_158:
                v137 = itoa((char *)(*(_QWORD *)a2 + v124), v121);
                v138 = *(_QWORD *)(a2 + 16);
                v139 = *(_QWORD *)(a2 + 8) + v137;
                *(_QWORD *)(a2 + 8) = v139;
                v140 = v139 + 1;
                if (v138)
                {
                  if (v140 >= *(_QWORD *)v138)
                  {
                    v141 = malloc_type_realloc(*(void **)(v138 + 16), (v139 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
                    v142 = *(_QWORD **)(a2 + 16);
                    v142[2] = v141;
                    *v142 = (v139 & 0xFFFFFFFFFFFFFF00) + 256;
                    *(_QWORD *)a2 = v141;
                  }
                }
                else
                {
                  str_alloc((string_t *)a2, v140);
                }
                v143 = *(string_t *)a2;
                ++*(_QWORD *)(a2 + 8);
                v143[v139] = 93;
              }
              if ((*(_BYTE *)(v13 + 88 * v14 + 80) & 0x20) == 0)
                goto LABEL_185;
              goto LABEL_164;
            }
            continue;
          }
        }
      }
    }
  }
LABEL_17:
  v25 = strncmp(a4, "texture", 7uLL);
  if (v25)
    v26 = 0;
  else
    v26 = a4 + 7;
  *(_QWORD *)v182 = v26;
  if (!v25)
  {
    *(_DWORD *)v180 = 0;
    arb::aidx((arb *)(a4 + 7), v180, 0, v24);
    if (a3 != a4)
    {
      v35 = *(_QWORD *)(a2 + 8);
      v34 = *(_QWORD *)(a2 + 16);
      v36 = v35 + a4 - a3;
      if (v34)
      {
        if (v36 >= *(_QWORD *)v34)
        {
          v37 = (v36 + 255) & 0xFFFFFFFFFFFFFF00;
          v38 = malloc_type_realloc(*(void **)(v34 + 16), v37, 0xCCCD1039uLL);
          v39 = *(size_t **)(a2 + 16);
          v39[2] = (size_t)v38;
          *v39 = v37;
          *(_QWORD *)a2 = v38;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v36);
      }
      v51 = 0;
      v52 = 0;
      v53 = *(_QWORD *)a2 + v35;
      while (1)
      {
        v54 = v52[(_QWORD)a3];
        if ((v54 - 33) <= 0xFFFFFFDF)
        {
          *(_BYTE *)(v53 + v51++) = v54;
          v55 = &(++v52)[(_QWORD)a3];
          if (v52[(_QWORD)a3] == 35)
          {
LABEL_55:
            v56 = 35;
            while (v56 == 35)
            {
              ++v55;
              do
              {
                v56 = *v55;
                if (!*v55)
                  goto LABEL_49;
                v58 = *(v55++ - 1);
              }
              while (v58 != 10);
              --v55;
              if ((v56 - 33) >= 0xFFFFFFE0)
              {
                do
                {
                  v57 = *++v55;
                  v56 = v57;
                }
                while ((v57 - 33) > 0xFFFFFFDF);
              }
            }
LABEL_49:
            v52 = (_BYTE *)(v55 - a3);
          }
        }
        else
        {
          v55 = &(++v52)[(_QWORD)a3];
          if (v52[(_QWORD)a3] == 35)
            goto LABEL_55;
        }
        if ((unint64_t)v52 >= a4 - a3)
        {
          v49 = *(_QWORD *)(a2 + 8) + v51;
          *(_QWORD *)(a2 + 8) = v49;
          v50 = v49 + 8;
          v48 = *(_QWORD *)(a2 + 16);
          if (v48)
            goto LABEL_64;
LABEL_46:
          str_alloc((string_t *)a2, v50);
          goto LABEL_66;
        }
      }
    }
    v49 = *(_QWORD *)(a2 + 8);
    v48 = *(_QWORD *)(a2 + 16);
    v50 = v49 + 8;
    if (!v48)
      goto LABEL_46;
LABEL_64:
    if (v50 >= *(_QWORD *)v48)
    {
      v59 = malloc_type_realloc(*(void **)(v48 + 16), (v49 + 263) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v60 = *(unint64_t **)(a2 + 16);
      v60[2] = (unint64_t)v59;
      *v60 = (v49 + 263) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)a2 = v59;
    }
LABEL_66:
    v61 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 8;
    *(_QWORD *)&v61[v49] = 0x5B65727574786574;
    v62 = *(_DWORD *)v180;
    v64 = *(_QWORD *)(a2 + 8);
    v63 = *(_QWORD *)(a2 + 16);
    v65 = v64 + 20;
    if (v63)
    {
      if (v65 >= *(_QWORD *)v63)
      {
        v66 = malloc_type_realloc(*(void **)(v63 + 16), (v64 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v67 = *(unint64_t **)(a2 + 16);
        v67[2] = (unint64_t)v66;
        *v67 = (v64 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v66;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v65);
    }
    v68 = itoa((char *)(*(_QWORD *)a2 + v64), v62);
    v69 = *(_QWORD *)(a2 + 16);
    v70 = *(_QWORD *)(a2 + 8) + v68;
    *(_QWORD *)(a2 + 8) = v70;
    *(_DWORD *)v180 = v68 + 8;
    v71 = v70 + 1;
    if (v69)
    {
      if (v71 >= *(_QWORD *)v69)
      {
        v72 = malloc_type_realloc(*(void **)(v69 + 16), (v70 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
        v73 = *(_QWORD **)(a2 + 16);
        v73[2] = v72;
        *v73 = (v70 & 0xFFFFFFFFFFFFFF00) + 256;
        *(_QWORD *)a2 = v72;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v71);
    }
    v74 = *(string_t *)a2;
    ++*(_QWORD *)(a2 + 8);
    v74[v70] = 93;
    v75 = &a5[(_QWORD)a4];
    if (v75 == a6)
      goto LABEL_95;
    v77 = *(_QWORD *)(a2 + 8);
    v76 = *(_QWORD *)(a2 + 16);
    v78 = v77 + a6 - v75;
    if (v76)
    {
      if (v78 >= *(_QWORD *)v76)
      {
        v79 = (v78 + 255) & 0xFFFFFFFFFFFFFF00;
        v80 = malloc_type_realloc(*(void **)(v76 + 16), v79, 0xCCCD1039uLL);
        v81 = *(size_t **)(a2 + 16);
        v81[2] = (size_t)v80;
        *v81 = v79;
        *(_QWORD *)a2 = v80;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v78);
    }
    v40 = 0;
    v82 = 0;
    v83 = *(_QWORD *)a2 + v77;
    while (1)
    {
      v84 = v82[(_QWORD)v75];
      if ((v84 - 33) <= 0xFFFFFFDF)
      {
        *(_BYTE *)(v83 + v40++) = v84;
        v85 = &(++v82)[(_QWORD)v75];
        if (v82[(_QWORD)v75] == 35)
        {
LABEL_86:
          v86 = 35;
LABEL_88:
          if (v86 == 35)
          {
            ++v85;
            while (1)
            {
              v86 = *v85;
              if (!*v85)
                break;
              v88 = *(v85++ - 1);
              if (v88 == 10)
              {
                --v85;
                if ((v86 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v87 = *++v85;
                    v86 = v87;
                  }
                  while ((v87 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_88;
              }
            }
          }
          v82 = (_BYTE *)(v85 - v75);
        }
      }
      else
      {
        v85 = &(++v82)[(_QWORD)v75];
        if (v82[(_QWORD)v75] == 35)
          goto LABEL_86;
      }
      if ((unint64_t)v82 >= a6 - v75)
      {
LABEL_94:
        *(_QWORD *)(a2 + 8) += v40;
        goto LABEL_95;
      }
    }
  }
  v27 = (_BYTE *)(a6 - a3);
  if (a6 != a3)
  {
    v29 = *(_QWORD *)(a2 + 8);
    v28 = *(_QWORD *)(a2 + 16);
    v30 = (unint64_t)&v27[v29];
    if (v28)
    {
      if (v30 >= *(_QWORD *)v28)
      {
        v31 = (v30 + 255) & 0xFFFFFFFFFFFFFF00;
        v32 = malloc_type_realloc(*(void **)(v28 + 16), v31, 0xCCCD1039uLL);
        v33 = *(size_t **)(a2 + 16);
        v33[2] = (size_t)v32;
        *v33 = v31;
        *(_QWORD *)a2 = v32;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v30);
    }
    v40 = 0;
    v41 = 0;
    v42 = *(_QWORD *)a2 + v29;
    while (1)
    {
      v43 = v41[(_QWORD)a3];
      if ((v43 - 33) <= 0xFFFFFFDF)
      {
        *(_BYTE *)(v42 + v40++) = v43;
        v44 = &(++v41)[(_QWORD)a3];
        if (v41[(_QWORD)a3] == 35)
        {
LABEL_37:
          v45 = 35;
LABEL_39:
          if (v45 == 35)
          {
            ++v44;
            while (1)
            {
              v45 = *v44;
              if (!*v44)
                break;
              v47 = *(v44++ - 1);
              if (v47 == 10)
              {
                --v44;
                if ((v45 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v46 = *++v44;
                    v45 = v46;
                  }
                  while ((v46 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_39;
              }
            }
          }
          v41 = (_BYTE *)(v44 - a3);
        }
      }
      else
      {
        v44 = &(++v41)[(_QWORD)a3];
        if (v41[(_QWORD)a3] == 35)
          goto LABEL_37;
      }
      if (v41 >= v27)
        goto LABEL_94;
    }
  }
LABEL_95:
  v89 = *a6;
  if (*a6)
  {
    if ((v89 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_97:
        v90 = *++a6;
        v89 = v90;
      }
      while ((v90 - 33) > 0xFFFFFFDF);
    }
LABEL_98:
    if (v89 == 35)
    {
      ++a6;
      while (1)
      {
        v89 = *a6;
        if (!*a6)
          break;
        v91 = *(a6++ - 1);
        if (v91 == 10)
        {
          --a6;
          if ((v89 - 33) >= 0xFFFFFFE0)
            goto LABEL_97;
          goto LABEL_98;
        }
      }
    }
  }
  return a6;
}

void arb::obj_write_ssat(uint64_t a1, uint64_t a2, arb *this, unint64_t *a4)
{
  int v7;
  int v8;
  arb *v9;
  int v10;
  arb *v11;
  int v12;
  int v13;
  char *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  void *v25;
  unint64_t *v26;
  unint64_t v27;
  void *v28;
  unint64_t *v29;
  string_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  void *v35;
  _QWORD *v36;
  string_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  void *v41;
  unint64_t *v42;
  string_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  size_t v49;
  void *v50;
  size_t *v51;
  string_t v52;
  char *v53;
  signed int v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  void *v58;
  unint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  void *v64;
  unint64_t *v65;
  string_t v66;
  signed int v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  void *v71;
  unint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  void *v77;
  unint64_t *v78;
  string_t v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  size_t v85;
  void *v86;
  size_t *v87;
  string_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  void *v92;
  _QWORD *v93;
  string_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  void *v98;
  unint64_t *v99;
  string_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  void *v104;
  unint64_t *v105;
  string_t v106;
  signed int v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  void *v111;
  unint64_t *v112;
  uint64_t v113;
  string_t v114;
  int i;
  char *v116;
  char v117[8];
  unsigned __int8 *v118;

  v7 = *(unsigned __int8 *)this;
  v8 = v7;
  v9 = this;
  if ((ctype[2 * *(unsigned __int8 *)this] & 0x40) != 0)
  {
    v9 = this;
    do
    {
      v10 = *((unsigned __int8 *)v9 + 1);
      v9 = (arb *)((char *)v9 + 1);
      v8 = v10;
    }
    while ((ctype[2 * v10] & 0x40) != 0);
  }
  v116 = 0;
  *(_QWORD *)v117 = 0;
  v11 = v9;
  if (v8)
  {
    v11 = v9;
    if ((v8 - 33) >= 0xFFFFFFE0)
    {
      do
      {
LABEL_6:
        v12 = *((unsigned __int8 *)v11 + 1);
        v11 = (arb *)((char *)v11 + 1);
        v8 = v12;
      }
      while ((v12 - 33) > 0xFFFFFFDF);
    }
LABEL_7:
    if (v8 == 35)
    {
      v11 = (arb *)((char *)v11 + 1);
      while (1)
      {
        v8 = *(unsigned __int8 *)v11;
        if (!*(_BYTE *)v11)
          break;
        v13 = *((unsigned __int8 *)v11 - 1);
        v11 = (arb *)((char *)v11 + 1);
        if (v13 == 10)
        {
          v11 = (arb *)((char *)v11 - 1);
          if ((v8 - 33) >= 0xFFFFFFE0)
            goto LABEL_6;
          goto LABEL_7;
        }
      }
    }
  }
  *(_QWORD *)v117 = v11;
  arb::asymbol(v11, v117, (const char **)&v116, a4);
  v14 = v116;
  v15 = *(unsigned __int8 **)v117;
  v16 = *(_QWORD *)a1;
  v17 = *(_QWORD *)(a1 + 8);
  v18 = v17 >> 1;
  v118 = *(unsigned __int8 **)v117;
  v19 = arb::ascan(&v118, (const char **)v116, (unsigned __int8 *)(v16 + 88 * (v17 >> 1)), (const char *)1);
  for (i = v7;
        v19;
        v19 = arb::ascan(&v118, (const char **)v14, (unsigned __int8 *)(v16 + 88 * (v17 >> 1)), (const char *)1))
  {
    if (v19 > 0)
      v20 = v18 + 1;
    else
      v20 = 0;
    v16 += 88 * v20;
    if (v19 <= 0)
      v17 = v18;
    else
      v17 -= v18 + 1;
    v18 = v17 >> 1;
    v118 = v15;
  }
  v21 = *(void **)(v16 + 88 * v18 + 40);
  v23 = *(_QWORD *)(a2 + 8);
  v22 = *(_QWORD *)(a2 + 16);
  if (v21 == &outputKind)
  {
    v27 = v23 + 5;
    if (v22)
    {
      if (v27 >= *(_QWORD *)v22)
      {
        v28 = malloc_type_realloc(*(void **)(v22 + 16), (v23 + 260) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v29 = *(unint64_t **)(a2 + 16);
        v29[2] = (unint64_t)v28;
        *v29 = (v23 + 260) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v28;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v27);
    }
    v52 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 5;
    v53 = (char *)&v52[v23];
    v53[4] = 114;
    *(_DWORD *)v53 = 542001485;
    v54 = *(_DWORD *)(a1 + 60);
    v56 = *(_QWORD *)(a2 + 8);
    v55 = *(_QWORD *)(a2 + 16);
    v57 = v56 + 20;
    if (v55)
    {
      if (v57 >= *(_QWORD *)v55)
      {
        v58 = malloc_type_realloc(*(void **)(v55 + 16), (v56 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v59 = *(unint64_t **)(a2 + 16);
        v59[2] = (unint64_t)v58;
        *v59 = (v56 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v58;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v57);
    }
    v60 = itoa((char *)(*(_QWORD *)a2 + v56), v54);
    v61 = *(_QWORD *)(a2 + 16);
    v62 = *(_QWORD *)(a2 + 8) + v60;
    *(_QWORD *)(a2 + 8) = v62;
    v63 = v62 + 2;
    if (v61)
    {
      if (v63 >= *(_QWORD *)v61)
      {
        v64 = malloc_type_realloc(*(void **)(v61 + 16), (v62 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v65 = *(unint64_t **)(a2 + 16);
        v65[2] = (unint64_t)v64;
        *v65 = (v62 + 257) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v64;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v63);
    }
    v66 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 2;
    *(_WORD *)&v66[v62] = 29228;
    v67 = *(_DWORD *)(a1 + 60);
    v69 = *(_QWORD *)(a2 + 8);
    v68 = *(_QWORD *)(a2 + 16);
    v70 = v69 + 20;
    if (v68)
    {
      if (v70 >= *(_QWORD *)v68)
      {
        v71 = malloc_type_realloc(*(void **)(v68 + 16), (v69 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v72 = *(unint64_t **)(a2 + 16);
        v72[2] = (unint64_t)v71;
        *v72 = (v69 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v71;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v70);
    }
    v73 = itoa((char *)(*(_QWORD *)a2 + v69), v67);
    v74 = *(_QWORD *)(a2 + 16);
    v75 = *(_QWORD *)(a2 + 8) + v73;
    *(_QWORD *)(a2 + 8) = v75;
    v76 = v75 + 7;
    if (v74)
    {
      if (v76 >= *(_QWORD *)v74)
      {
        v77 = malloc_type_realloc(*(void **)(v74 + 16), (v75 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v78 = *(unint64_t **)(a2 + 16);
        v78[2] = (unint64_t)v77;
        *v78 = (v75 + 262) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v77;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v76);
    }
    v79 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 7;
    v80 = (char *)&v79[v75];
    *(_DWORD *)(v80 + 3) = 1480674570;
    *(_DWORD *)v80 = 171651372;
    if (i != 95)
    {
      v81 = v9 - this - 5;
      v83 = *(_QWORD *)(a2 + 8);
      v82 = *(_QWORD *)(a2 + 16);
      v84 = v83 + v81;
      if (v82)
      {
        if (v84 >= *(_QWORD *)v82)
        {
          v85 = (v84 + 255) & 0xFFFFFFFFFFFFFF00;
          v86 = malloc_type_realloc(*(void **)(v82 + 16), v85, 0xCCCD1039uLL);
          v87 = *(size_t **)(a2 + 16);
          v87[2] = (size_t)v86;
          *v87 = v85;
          *(_QWORD *)a2 = v86;
        }
      }
      else
      {
        str_alloc((string_t *)a2, v84);
      }
      v100 = *(string_t *)a2;
      *(_QWORD *)(a2 + 8) += v81;
      memcpy((void *)&v100[v83], this, v9 - this - 5);
    }
    arb::obj_write_dest((uint64_t *)a1, (string_t *)a2, v9, v117, (const char **)&v116, 1, 1);
    v102 = *(_QWORD *)(a2 + 8);
    v101 = *(_QWORD *)(a2 + 16);
    v103 = v102 + 2;
    if (v101)
    {
      if (v103 >= *(_QWORD *)v101)
      {
        v104 = malloc_type_realloc(*(void **)(v101 + 16), (v102 + 257) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v105 = *(unint64_t **)(a2 + 16);
        v105[2] = (unint64_t)v104;
        *v105 = (v102 + 257) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v104;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v103);
    }
    v106 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += 2;
    *(_WORD *)&v106[v102] = 29228;
    v107 = *(_DWORD *)(a1 + 60);
    v109 = *(_QWORD *)(a2 + 8);
    v108 = *(_QWORD *)(a2 + 16);
    v110 = v109 + 20;
    if (v108)
    {
      if (v110 >= *(_QWORD *)v108)
      {
        v111 = malloc_type_realloc(*(void **)(v108 + 16), (v109 + 275) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
        v112 = *(unint64_t **)(a2 + 16);
        v112[2] = (unint64_t)v111;
        *v112 = (v109 + 275) & 0xFFFFFFFFFFFFFF00;
        *(_QWORD *)a2 = v111;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v110);
    }
    v113 = itoa((char *)(*(_QWORD *)a2 + v109), v107);
    v95 = *(_QWORD *)(a2 + 16);
    v96 = *(_QWORD *)(a2 + 8) + v113;
    *(_QWORD *)(a2 + 8) = v96;
    v97 = v96 + 4;
    if (v95)
      goto LABEL_69;
LABEL_82:
    str_alloc((string_t *)a2, v97);
    goto LABEL_83;
  }
  v24 = v23 + 3;
  if (v22)
  {
    if (v24 >= *(_QWORD *)v22)
    {
      v25 = malloc_type_realloc(*(void **)(v22 + 16), (v23 + 258) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v26 = *(unint64_t **)(a2 + 16);
      v26[2] = (unint64_t)v25;
      *v26 = (v23 + 258) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)a2 = v25;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v24);
  }
  v30 = *(string_t *)a2;
  *(_QWORD *)(a2 + 8) += 3;
  v31 = (char *)&v30[v23];
  v31[2] = 78;
  *(_WORD *)v31 = 18765;
  arb::obj_write_dest((uint64_t *)a1, (string_t *)a2, v9, v117, (const char **)&v116, 1, 1);
  v33 = *(_QWORD *)(a2 + 8);
  v32 = *(_QWORD *)(a2 + 16);
  v34 = v33 + 1;
  if (v32)
  {
    if (v34 >= *(_QWORD *)v32)
    {
      v35 = malloc_type_realloc(*(void **)(v32 + 16), (v33 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v36 = *(_QWORD **)(a2 + 16);
      v36[2] = v35;
      *v36 = (v33 & 0xFFFFFFFFFFFFFF00) + 256;
      *(_QWORD *)a2 = v35;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v34);
  }
  v37 = *(string_t *)a2;
  ++*(_QWORD *)(a2 + 8);
  v37[v33] = 44;
  arb::obj_write_symbol((_QWORD *)a1, a2, *(const char **)v117, *(const char **)v117, v116, &v116[*(_QWORD *)v117]);
  v39 = *(_QWORD *)(a2 + 8);
  v38 = *(_QWORD *)(a2 + 16);
  v40 = v39 + 7;
  if (v38)
  {
    if (v40 >= *(_QWORD *)v38)
    {
      v41 = malloc_type_realloc(*(void **)(v38 + 16), (v39 + 262) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
      v42 = *(unint64_t **)(a2 + 16);
      v42[2] = (unint64_t)v41;
      *v42 = (v39 + 262) & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)a2 = v41;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v40);
  }
  v43 = *(string_t *)a2;
  *(_QWORD *)(a2 + 8) += 7;
  v44 = (char *)&v43[v39];
  *(_DWORD *)(v44 + 3) = 1480674570;
  *(_DWORD *)v44 = 171651372;
  if (i != 95)
  {
    v45 = v9 - this - 5;
    v47 = *(_QWORD *)(a2 + 8);
    v46 = *(_QWORD *)(a2 + 16);
    v48 = v47 + v45;
    if (v46)
    {
      if (v48 >= *(_QWORD *)v46)
      {
        v49 = (v48 + 255) & 0xFFFFFFFFFFFFFF00;
        v50 = malloc_type_realloc(*(void **)(v46 + 16), v49, 0xCCCD1039uLL);
        v51 = *(size_t **)(a2 + 16);
        v51[2] = (size_t)v50;
        *v51 = v49;
        *(_QWORD *)a2 = v50;
      }
    }
    else
    {
      str_alloc((string_t *)a2, v48);
    }
    v88 = *(string_t *)a2;
    *(_QWORD *)(a2 + 8) += v45;
    memcpy((void *)&v88[v47], this, v9 - this - 5);
  }
  arb::obj_write_dest((uint64_t *)a1, (string_t *)a2, v9, v117, (const char **)&v116, 1, 1);
  v90 = *(_QWORD *)(a2 + 8);
  v89 = *(_QWORD *)(a2 + 16);
  v91 = v90 + 1;
  if (v89)
  {
    if (v91 >= *(_QWORD *)v89)
    {
      v92 = malloc_type_realloc(*(void **)(v89 + 16), (v90 & 0xFFFFFFFFFFFFFF00) + 256, 0xCCCD1039uLL);
      v93 = *(_QWORD **)(a2 + 16);
      v93[2] = v92;
      *v93 = (v90 & 0xFFFFFFFFFFFFFF00) + 256;
      *(_QWORD *)a2 = v92;
    }
  }
  else
  {
    str_alloc((string_t *)a2, v91);
  }
  v94 = *(string_t *)a2;
  ++*(_QWORD *)(a2 + 8);
  v94[v90] = 44;
  arb::obj_write_symbol((_QWORD *)a1, a2, *(const char **)v117, *(const char **)v117, v116, &v116[*(_QWORD *)v117]);
  v96 = *(_QWORD *)(a2 + 8);
  v95 = *(_QWORD *)(a2 + 16);
  v97 = v96 + 4;
  if (!v95)
    goto LABEL_82;
LABEL_69:
  if (v97 >= *(_QWORD *)v95)
  {
    v98 = malloc_type_realloc(*(void **)(v95 + 16), (v96 + 259) & 0xFFFFFFFFFFFFFF00, 0xCCCD1039uLL);
    v99 = *(unint64_t **)(a2 + 16);
    v99[2] = (unint64_t)v98;
    *v99 = (v96 + 259) & 0xFFFFFFFFFFFFFF00;
    *(_QWORD *)a2 = v98;
  }
LABEL_83:
  v114 = *(string_t *)a2;
  *(_QWORD *)(a2 + 8) += 4;
  *(_DWORD *)&v114[v96] = 993078572;
}

void str_putm(string_t *a1, const char *a2, unint64_t a3)
{
  string_t v6;
  string_t v7;
  unint64_t v8;
  size_t v9;
  const char *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  const char *v14;
  const char *v15;
  char v16;
  int v17;
  int v18;
  int v19;

  if (a3)
  {
    v7 = a1[1];
    v6 = a1[2];
    v8 = (unint64_t)&v7[a3];
    if (v6)
    {
      if (v8 >= *(_QWORD *)v6)
      {
        v9 = (v8 + 255) & 0xFFFFFFFFFFFFFF00;
        v10 = (const char *)malloc_type_realloc(*((void **)v6 + 2), v9, 0xCCCD1039uLL);
        v11 = (char *)a1[2];
        *((_QWORD *)v11 + 2) = v10;
        *(_QWORD *)v11 = v9;
        *a1 = v10;
      }
    }
    else
    {
      str_alloc(a1, v8);
    }
    v12 = 0;
    v13 = 0;
    v14 = &v7[(_QWORD)*a1];
    while (1)
    {
      if ((a2[v13] - 33) <= 0xDFu)
      {
        v16 = 120;
        switch(a2[v13])
        {
          case 'a':
            v16 = 119;
            break;
          case 'b':
            v16 = 122;
            break;
          case 'g':
            v16 = 121;
            break;
          case 'r':
            break;
          default:
            v16 = a2[v13];
            break;
        }
        v14[v12++] = v16;
        v15 = &a2[++v13];
        if (a2[v13] == 35)
        {
LABEL_18:
          v17 = 35;
LABEL_20:
          if (v17 == 35)
          {
            ++v15;
            while (1)
            {
              v17 = *(unsigned __int8 *)v15;
              if (!*v15)
                break;
              v19 = *((unsigned __int8 *)v15++ - 1);
              if (v19 == 10)
              {
                --v15;
                if ((v17 - 33) >= 0xFFFFFFE0)
                {
                  do
                  {
                    v18 = *(unsigned __int8 *)++v15;
                    v17 = v18;
                  }
                  while ((v18 - 33) > 0xFFFFFFDF);
                }
                goto LABEL_20;
              }
            }
          }
          v13 = v15 - a2;
        }
      }
      else
      {
        v15 = &a2[++v13];
        if (a2[v13] == 35)
          goto LABEL_18;
      }
      if (v13 >= a3)
      {
        a1[1] += v12;
        return;
      }
    }
  }
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

_BYTE *glsl::glindex(glsl *this, char *a2, unsigned int *a3)
{
  glsl *v3;
  _BYTE *v4;
  int v5;
  int v6;
  glsl *v7;
  int v8;
  int v9;
  int v10;
  int v12;
  int v13;
  _BYTE *v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  _BYTE *v18;
  int v19;
  int v20;

  while (1)
  {
    do
    {
LABEL_3:
      v3 = this;
      v4 = (char *)this + 1;
      v5 = *(unsigned __int8 *)this;
      this = (glsl *)((char *)this + 1);
    }
    while ((v5 - 33) >= 0xFFFFFFE0);
    if (v5 != 47)
      break;
    v6 = *v4;
    if (v6 == 42)
    {
      this = (glsl *)((char *)v3 + 2);
      if (*((_BYTE *)v3 + 2))
      {
        do
        {
          if (*(v4 - 1) == 42 && *v4 == 47)
            break;
          v9 = v4[2];
          ++v4;
        }
        while (v9);
        this = (glsl *)(v4 + 1);
      }
    }
    else
    {
      if (v6 != 47)
        return 0;
      v7 = (glsl *)((char *)v3 + 2);
      while (*(_BYTE *)v7)
      {
        v8 = *((unsigned __int8 *)v7 - 1);
        this = v7;
        v7 = (glsl *)((char *)v7 + 1);
        if (v8 == 10)
          goto LABEL_3;
      }
      this = v7;
    }
  }
  if (v5 != 91)
    return 0;
  v10 = *v4;
  if ((v10 - 58) < 0xFFFFFFF6)
    return 0;
  v12 = 0;
  do
  {
    v12 = v10 + 10 * v12 - 48;
    v13 = *++v4;
    v10 = v13;
  }
  while ((v13 - 58) > 0xFFFFFFF5);
  *(_DWORD *)a2 = v12;
  while (1)
  {
    do
    {
LABEL_24:
      v14 = v4;
      v15 = v4 + 1;
      v16 = *v4++;
    }
    while ((v16 - 33) >= 0xFFFFFFE0);
    if (v16 != 47)
      break;
    v17 = *v15;
    if (v17 == 42)
    {
      v4 = v14 + 2;
      if (v14[2])
      {
        do
        {
          if (*(v15 - 1) == 42 && *v15 == 47)
            break;
          v20 = v15[2];
          ++v15;
        }
        while (v20);
        v4 = v15 + 1;
      }
    }
    else
    {
      if (v17 != 47)
        return 0;
      v18 = v14 + 2;
      while (*v18)
      {
        v19 = *(v18 - 1);
        v4 = v18++;
        if (v19 == 10)
          goto LABEL_24;
      }
      v4 = v18;
    }
  }
  if (v16 == 93)
    return v14;
  else
    return 0;
}

void string_t::~string_t(string_t *this)
{
  char *v2;

  v2 = (char *)this[3];
  if (v2)
  {
    this[4] = v2;
    operator delete(v2);
  }
}

void HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard(HGAutoReleasePoolScopeGuard *this)
{
  *(_QWORD *)this = objc_opt_new();
}

void HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(id *this)
{
  objc_msgSend(*this, "drain");
  *this = 0;
}

void HRasterizerTexture::HRasterizerTexture(HRasterizerTexture *this)
{
  uint64_t v1;
  char *v7;

  HgcRasterizerTexture::HgcRasterizerTexture(this);
  *(_QWORD *)v1 = off_1E651E530;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v1 + 420) = _Q0;
  HgcRasterizerTexture::SetParameter((HgcRasterizerTexture *)v1, 0, 1.0, 1.0, 1.0, 1.0, v7);
}

void sub_1B2A2213C(_Unwind_Exception *a1)
{
  HgcRasterizerTexture *v1;

  HgcRasterizerTexture::~HgcRasterizerTexture(v1);
  _Unwind_Resume(a1);
}

void HRasterizerTexture::~HRasterizerTexture(HRasterizerTexture *this)
{
  void *v1;

  HgcRasterizerTexture::~HgcRasterizerTexture(this);
  HGObject::operator delete(v1);
}

void HGSynchronizable::HGSynchronizable(HGSynchronizable *this)
{
  this->var0 = (void **)&off_1E651E7A8;
  this->var2 = 0;
  this->var3 = 0;
  pthread_mutex_init(&this->var1, 0);
  pthread_cond_init(&this->var4, 0);
}

void HGSynchronizable::~HGSynchronizable(HGSynchronizable *this)
{
  this->var0 = (void **)&off_1E651E7A8;
  pthread_cond_destroy(&this->var4);
  pthread_mutex_destroy(&this->var1);
}

{
  this->var0 = (void **)&off_1E651E7A8;
  pthread_cond_destroy(&this->var4);
  pthread_mutex_destroy(&this->var1);
  JUMPOUT(0x1B5E29170);
}

uint64_t HGSynchronizable::Notify(HGSynchronizable *this)
{
  return pthread_cond_signal(&this->var4);
}

uint64_t HGSynchronizable::NotifyAll(HGSynchronizable *this)
{
  return pthread_cond_broadcast(&this->var4);
}

_opaque_pthread_t *HGSynchronizable::Lock(HGSynchronizable *this)
{
  _opaque_pthread_t *var2;
  _opaque_pthread_t *result;

  var2 = this->var2;
  result = pthread_self();
  if (var2 == result)
  {
    ++this->var3;
  }
  else
  {
    pthread_mutex_lock(&this->var1);
    this->var3 = 0;
    result = pthread_self();
    this->var2 = result;
  }
  return result;
}

HGSynchronizable *HGSynchronizable::Unlock(HGSynchronizable *this)
{
  unint64_t var3;

  var3 = this->var3;
  if (var3)
  {
    this->var3 = var3 - 1;
  }
  else
  {
    this->var2 = 0;
    this->var3 = 0;
    return (HGSynchronizable *)pthread_mutex_unlock(&this->var1);
  }
  return this;
}

pthread_t HGSynchronizable::Wait(HGSynchronizable *this)
{
  unint64_t var3;
  _opaque_pthread_t **p_var2;
  pthread_t result;

  var3 = this->var3;
  this->var2 = 0;
  p_var2 = &this->var2;
  this->var3 = 0;
  pthread_cond_wait(&this->var4, &this->var1);
  this->var3 = var3;
  result = pthread_self();
  *p_var2 = result;
  return result;
}

void sub_1B2A2231C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGSynchronizable::NestingReleaser::~NestingReleaser((HGSynchronizable::NestingReleaser *)&a9);
  _Unwind_Resume(a1);
}

void HGSynchronizable::NestingReleaser::~NestingReleaser(HGSynchronizable::NestingReleaser *this)
{
  *(_QWORD *)(*(_QWORD *)this + 80) = *((_QWORD *)this + 1);
  *(_QWORD *)(*(_QWORD *)this + 72) = pthread_self();
}

void *HGMultiTexBlendBase::create(HGMultiTexBlendBase *this)
{
  void *v1;
  void *result;

  switch((int)this)
  {
    case 2:
      v1 = HGObject::operator new(0x1E0uLL);
      HGMultiTexBlend<2>::HGMultiTexBlend((uint64_t)v1);
      goto LABEL_3;
    case 3:
      v1 = HGObject::operator new(0x1E0uLL);
      HGMultiTexBlend<3>::HGMultiTexBlend((uint64_t)v1);
      goto LABEL_3;
    case 4:
      v1 = HGObject::operator new(0x1F0uLL);
      HGMultiTexBlend<4>::HGMultiTexBlend((uint64_t)v1);
      goto LABEL_3;
    case 5:
      v1 = HGObject::operator new(0x1F0uLL);
      HGMultiTexBlend<5>::HGMultiTexBlend((uint64_t)v1);
      goto LABEL_3;
    case 6:
      v1 = HGObject::operator new(0x200uLL);
      HGMultiTexBlend<6>::HGMultiTexBlend((uint64_t)v1);
      goto LABEL_3;
    case 7:
      v1 = HGObject::operator new(0x200uLL);
      HGMultiTexBlend<7>::HGMultiTexBlend((uint64_t)v1);
      goto LABEL_3;
    case 8:
      v1 = HGObject::operator new(0x210uLL);
      HGMultiTexBlend<8>::HGMultiTexBlend((uint64_t)v1);
LABEL_3:
      result = v1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void sub_1B2A22444(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A22458(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A2246C(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A22480(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A22494(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A224A8(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A224BC(_Unwind_Exception *a1)
{
  void *v1;

  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGMultiTexBlend<2>::HGMultiTexBlend(uint64_t a1)
{
  _QWORD *v2;
  HGNode *v3;
  HgcMultiTexBlend_2 *v4;
  HGXForm *v5;
  HGXForm *v6;

  HGNode::HGNode((HGNode *)a1);
  *v2 = off_1E651E7D8;
  v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)(a1 + 440) = v3;
  v4 = (HgcMultiTexBlend_2 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_2::HgcMultiTexBlend_2(v4);
  *(_QWORD *)(a1 + 464) = v4;
  v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  *(_QWORD *)(a1 + 448) = v5;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 464) + 120))(*(_QWORD *)(a1 + 464), 0, *(_QWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 408) = 1056964608;
  v6 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v6);
  *(_QWORD *)(a1 + 456) = v6;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v6 + 120))(v6, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 464) + 120))(*(_QWORD *)(a1 + 464), 1, *(_QWORD *)(a1 + 456));
  *(_DWORD *)(a1 + 412) = 1056964608;
  return a1;
}

void sub_1B2A225C4(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A225E8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A225FC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<2>::~HGMultiTexBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_1E651E7D8;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 58);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  *(_QWORD *)this = off_1E651E7D8;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 58);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  HGNode::~HGNode(this);
  HGObject::operator delete(v6);
}

uint64_t HGMultiTexBlend<2>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v5;

  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 448);
  if (result)
  {
    v5 = (_QWORD *)(v3 + 448);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 576))(result, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 160))(*v5, 1);
  }
  return result;
}

uint64_t HGMultiTexBlend<2>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<2>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;

  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**(_QWORD **)(a1 + 464) + 96))(*(_QWORD *)(a1 + 464), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**(_QWORD **)(a1 + 464) + 96))(*(_QWORD *)(a1 + 464), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  v4 = *(_QWORD *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  return *(_QWORD *)(a1 + 464);
}

uint64_t HGMultiTexBlend<3>::HGMultiTexBlend(uint64_t a1)
{
  _QWORD *v2;
  HGNode *v3;
  HgcMultiTexBlend_3 *v4;
  HGXForm *v5;
  HGXForm *v6;
  HGXForm *v7;

  HGNode::HGNode((HGNode *)a1);
  *v2 = off_1E651EA38;
  v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)(a1 + 440) = v3;
  v4 = (HgcMultiTexBlend_3 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_3::HgcMultiTexBlend_3(v4);
  *(_QWORD *)(a1 + 472) = v4;
  v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  *(_QWORD *)(a1 + 448) = v5;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 472) + 120))(*(_QWORD *)(a1 + 472), 0, *(_QWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 408) = 1051372203;
  v6 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v6);
  *(_QWORD *)(a1 + 456) = v6;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v6 + 120))(v6, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 472) + 120))(*(_QWORD *)(a1 + 472), 1, *(_QWORD *)(a1 + 456));
  *(_DWORD *)(a1 + 412) = 1051372203;
  v7 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v7);
  *(_QWORD *)(a1 + 464) = v7;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v7 + 120))(v7, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 472) + 120))(*(_QWORD *)(a1 + 472), 2, *(_QWORD *)(a1 + 464));
  *(_DWORD *)(a1 + 416) = 1051372203;
  return a1;
}

void sub_1B2A22968(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A229A0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<3>::~HGMultiTexBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = off_1E651EA38;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 59);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 58);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_1E651EA38;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 59);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 58);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  HGNode::~HGNode(this);
  HGObject::operator delete(v7);
}

uint64_t HGMultiTexBlend<3>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v5;

  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 448);
  if (result)
  {
    v5 = (_QWORD *)(v3 + 448);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 576))(result, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 160))(*v5, 1);
  }
  return result;
}

uint64_t HGMultiTexBlend<3>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<3>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;

  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**(_QWORD **)(a1 + 472) + 96))(*(_QWORD *)(a1 + 472), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**(_QWORD **)(a1 + 472) + 96))(*(_QWORD *)(a1 + 472), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  v4 = *(_QWORD *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  return *(_QWORD *)(a1 + 472);
}

uint64_t HGMultiTexBlend<4>::HGMultiTexBlend(uint64_t a1)
{
  _QWORD *v2;
  HGNode *v3;
  HgcMultiTexBlend_4 *v4;
  HGXForm *v5;
  HGXForm *v6;
  HGXForm *v7;
  HGXForm *v8;

  HGNode::HGNode((HGNode *)a1);
  *v2 = off_1E651EC98;
  v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)(a1 + 440) = v3;
  v4 = (HgcMultiTexBlend_4 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_4::HgcMultiTexBlend_4(v4);
  *(_QWORD *)(a1 + 480) = v4;
  v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  *(_QWORD *)(a1 + 448) = v5;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 480) + 120))(*(_QWORD *)(a1 + 480), 0, *(_QWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 408) = 1048576000;
  v6 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v6);
  *(_QWORD *)(a1 + 456) = v6;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v6 + 120))(v6, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 480) + 120))(*(_QWORD *)(a1 + 480), 1, *(_QWORD *)(a1 + 456));
  *(_DWORD *)(a1 + 412) = 1048576000;
  v7 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v7);
  *(_QWORD *)(a1 + 464) = v7;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v7 + 120))(v7, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 480) + 120))(*(_QWORD *)(a1 + 480), 2, *(_QWORD *)(a1 + 464));
  *(_DWORD *)(a1 + 416) = 1048576000;
  v8 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v8);
  *(_QWORD *)(a1 + 472) = v8;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v8 + 120))(v8, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 480) + 120))(*(_QWORD *)(a1 + 480), 3, *(_QWORD *)(a1 + 472));
  *(_DWORD *)(a1 + 420) = 1048576000;
  return a1;
}

void sub_1B2A22D74(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A22DAC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<4>::~HGMultiTexBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = off_1E651EC98;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 60);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 58);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  v7 = *((_QWORD *)this + 59);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  HGNode::~HGNode(this);
}

void HGMultiTexBlend<4>::~HGMultiTexBlend(HGNode *a1)
{
  void *v1;

  HGMultiTexBlend<4>::~HGMultiTexBlend(a1);
  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<4>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v5;

  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 448);
  if (result)
  {
    v5 = (_QWORD *)(v3 + 448);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 576))(result, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 160))(*v5, 1);
  }
  return result;
}

uint64_t HGMultiTexBlend<4>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<4>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;

  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**(_QWORD **)(a1 + 480) + 96))(*(_QWORD *)(a1 + 480), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**(_QWORD **)(a1 + 480) + 96))(*(_QWORD *)(a1 + 480), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  v4 = *(_QWORD *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  return *(_QWORD *)(a1 + 480);
}

uint64_t HGMultiTexBlend<5>::HGMultiTexBlend(uint64_t a1)
{
  _QWORD *v2;
  HGNode *v3;
  HgcMultiTexBlend_5 *v4;
  HGXForm *v5;
  HGXForm *v6;
  HGXForm *v7;
  HGXForm *v8;
  HGXForm *v9;

  HGNode::HGNode((HGNode *)a1);
  *v2 = off_1E651EEF8;
  v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)(a1 + 440) = v3;
  v4 = (HgcMultiTexBlend_5 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_5::HgcMultiTexBlend_5(v4);
  *(_QWORD *)(a1 + 488) = v4;
  v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  *(_QWORD *)(a1 + 448) = v5;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 488) + 120))(*(_QWORD *)(a1 + 488), 0, *(_QWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 408) = 1045220557;
  v6 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v6);
  *(_QWORD *)(a1 + 456) = v6;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v6 + 120))(v6, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 488) + 120))(*(_QWORD *)(a1 + 488), 1, *(_QWORD *)(a1 + 456));
  *(_DWORD *)(a1 + 412) = 1045220557;
  v7 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v7);
  *(_QWORD *)(a1 + 464) = v7;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v7 + 120))(v7, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 488) + 120))(*(_QWORD *)(a1 + 488), 2, *(_QWORD *)(a1 + 464));
  *(_DWORD *)(a1 + 416) = 1045220557;
  v8 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v8);
  *(_QWORD *)(a1 + 472) = v8;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v8 + 120))(v8, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 488) + 120))(*(_QWORD *)(a1 + 488), 3, *(_QWORD *)(a1 + 472));
  *(_DWORD *)(a1 + 420) = 1045220557;
  v9 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v9);
  *(_QWORD *)(a1 + 480) = v9;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v9 + 120))(v9, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 488) + 120))(*(_QWORD *)(a1 + 488), 4, *(_QWORD *)(a1 + 480));
  *(_DWORD *)(a1 + 424) = 1045220557;
  return a1;
}

void sub_1B2A23170(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A231A8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<5>::~HGMultiTexBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = off_1E651EEF8;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 61);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 58);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  v7 = *((_QWORD *)this + 59);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = *((_QWORD *)this + 60);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  HGNode::~HGNode(this);
}

void HGMultiTexBlend<5>::~HGMultiTexBlend(HGNode *a1)
{
  void *v1;

  HGMultiTexBlend<5>::~HGMultiTexBlend(a1);
  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<5>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v5;

  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 448);
  if (result)
  {
    v5 = (_QWORD *)(v3 + 448);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 576))(result, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 160))(*v5, 1);
  }
  return result;
}

uint64_t HGMultiTexBlend<5>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<5>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;

  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**(_QWORD **)(a1 + 488) + 96))(*(_QWORD *)(a1 + 488), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**(_QWORD **)(a1 + 488) + 96))(*(_QWORD *)(a1 + 488), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  v4 = *(_QWORD *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  return *(_QWORD *)(a1 + 488);
}

uint64_t HGMultiTexBlend<6>::HGMultiTexBlend(uint64_t a1)
{
  _QWORD *v2;
  HGNode *v3;
  HgcMultiTexBlend_6 *v4;
  HGXForm *v5;
  HGXForm *v6;
  HGXForm *v7;
  HGXForm *v8;
  HGXForm *v9;
  HGXForm *v10;

  HGNode::HGNode((HGNode *)a1);
  *v2 = off_1E651F158;
  v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)(a1 + 440) = v3;
  v4 = (HgcMultiTexBlend_6 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_6::HgcMultiTexBlend_6(v4);
  *(_QWORD *)(a1 + 496) = v4;
  v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  *(_QWORD *)(a1 + 448) = v5;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 496) + 120))(*(_QWORD *)(a1 + 496), 0, *(_QWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 408) = 1042983595;
  v6 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v6);
  *(_QWORD *)(a1 + 456) = v6;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v6 + 120))(v6, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 496) + 120))(*(_QWORD *)(a1 + 496), 1, *(_QWORD *)(a1 + 456));
  *(_DWORD *)(a1 + 412) = 1042983595;
  v7 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v7);
  *(_QWORD *)(a1 + 464) = v7;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v7 + 120))(v7, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 496) + 120))(*(_QWORD *)(a1 + 496), 2, *(_QWORD *)(a1 + 464));
  *(_DWORD *)(a1 + 416) = 1042983595;
  v8 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v8);
  *(_QWORD *)(a1 + 472) = v8;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v8 + 120))(v8, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 496) + 120))(*(_QWORD *)(a1 + 496), 3, *(_QWORD *)(a1 + 472));
  *(_DWORD *)(a1 + 420) = 1042983595;
  v9 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v9);
  *(_QWORD *)(a1 + 480) = v9;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v9 + 120))(v9, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 496) + 120))(*(_QWORD *)(a1 + 496), 4, *(_QWORD *)(a1 + 480));
  *(_DWORD *)(a1 + 424) = 1042983595;
  v10 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v10);
  *(_QWORD *)(a1 + 488) = v10;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v10 + 120))(v10, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 496) + 120))(*(_QWORD *)(a1 + 496), 5, *(_QWORD *)(a1 + 488));
  *(_DWORD *)(a1 + 428) = 1042983595;
  return a1;
}

void sub_1B2A235D0(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A23608(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<6>::~HGMultiTexBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)this = off_1E651F158;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 62);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 58);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  v7 = *((_QWORD *)this + 59);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = *((_QWORD *)this + 60);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  v9 = *((_QWORD *)this + 61);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  HGNode::~HGNode(this);
}

void HGMultiTexBlend<6>::~HGMultiTexBlend(HGNode *a1)
{
  void *v1;

  HGMultiTexBlend<6>::~HGMultiTexBlend(a1);
  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<6>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v5;

  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 448);
  if (result)
  {
    v5 = (_QWORD *)(v3 + 448);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 576))(result, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 160))(*v5, 1);
  }
  return result;
}

uint64_t HGMultiTexBlend<6>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<6>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;

  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**(_QWORD **)(a1 + 496) + 96))(*(_QWORD *)(a1 + 496), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**(_QWORD **)(a1 + 496) + 96))(*(_QWORD *)(a1 + 496), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  v4 = *(_QWORD *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  return *(_QWORD *)(a1 + 496);
}

uint64_t HGMultiTexBlend<7>::HGMultiTexBlend(uint64_t a1)
{
  _QWORD *v2;
  HGNode *v3;
  HgcMultiTexBlend_7 *v4;
  HGXForm *v5;
  HGXForm *v6;
  HGXForm *v7;
  HGXForm *v8;
  HGXForm *v9;
  HGXForm *v10;
  HGXForm *v11;

  HGNode::HGNode((HGNode *)a1);
  *v2 = off_1E651F3B8;
  v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)(a1 + 440) = v3;
  v4 = (HgcMultiTexBlend_7 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_7::HgcMultiTexBlend_7(v4);
  *(_QWORD *)(a1 + 504) = v4;
  v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  *(_QWORD *)(a1 + 448) = v5;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 504) + 120))(*(_QWORD *)(a1 + 504), 0, *(_QWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 408) = 1041385765;
  v6 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v6);
  *(_QWORD *)(a1 + 456) = v6;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v6 + 120))(v6, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 504) + 120))(*(_QWORD *)(a1 + 504), 1, *(_QWORD *)(a1 + 456));
  *(_DWORD *)(a1 + 412) = 1041385765;
  v7 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v7);
  *(_QWORD *)(a1 + 464) = v7;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v7 + 120))(v7, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 504) + 120))(*(_QWORD *)(a1 + 504), 2, *(_QWORD *)(a1 + 464));
  *(_DWORD *)(a1 + 416) = 1041385765;
  v8 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v8);
  *(_QWORD *)(a1 + 472) = v8;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v8 + 120))(v8, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 504) + 120))(*(_QWORD *)(a1 + 504), 3, *(_QWORD *)(a1 + 472));
  *(_DWORD *)(a1 + 420) = 1041385765;
  v9 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v9);
  *(_QWORD *)(a1 + 480) = v9;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v9 + 120))(v9, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 504) + 120))(*(_QWORD *)(a1 + 504), 4, *(_QWORD *)(a1 + 480));
  *(_DWORD *)(a1 + 424) = 1041385765;
  v10 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v10);
  *(_QWORD *)(a1 + 488) = v10;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v10 + 120))(v10, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 504) + 120))(*(_QWORD *)(a1 + 504), 5, *(_QWORD *)(a1 + 488));
  *(_DWORD *)(a1 + 428) = 1041385765;
  v11 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v11);
  *(_QWORD *)(a1 + 496) = v11;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v11 + 120))(v11, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 504) + 120))(*(_QWORD *)(a1 + 504), 6, *(_QWORD *)(a1 + 496));
  *(_DWORD *)(a1 + 432) = 1041385765;
  return a1;
}

void sub_1B2A23A94(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A23ACC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<7>::~HGMultiTexBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)this = off_1E651F3B8;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 63);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 58);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  v7 = *((_QWORD *)this + 59);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = *((_QWORD *)this + 60);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  v9 = *((_QWORD *)this + 61);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  v10 = *((_QWORD *)this + 62);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  HGNode::~HGNode(this);
}

void HGMultiTexBlend<7>::~HGMultiTexBlend(HGNode *a1)
{
  void *v1;

  HGMultiTexBlend<7>::~HGMultiTexBlend(a1);
  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<7>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v5;

  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 448);
  if (result)
  {
    v5 = (_QWORD *)(v3 + 448);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 576))(result, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 160))(*v5, 1);
  }
  return result;
}

uint64_t HGMultiTexBlend<7>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<7>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;

  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**(_QWORD **)(a1 + 504) + 96))(*(_QWORD *)(a1 + 504), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**(_QWORD **)(a1 + 504) + 96))(*(_QWORD *)(a1 + 504), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  v4 = *(_QWORD *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  return *(_QWORD *)(a1 + 504);
}

uint64_t HGMultiTexBlend<8>::HGMultiTexBlend(uint64_t a1)
{
  _QWORD *v2;
  HGNode *v3;
  HgcMultiTexBlend_8 *v4;
  HGXForm *v5;
  HGXForm *v6;
  HGXForm *v7;
  HGXForm *v8;
  HGXForm *v9;
  HGXForm *v10;
  HGXForm *v11;
  HGXForm *v12;

  HGNode::HGNode((HGNode *)a1);
  *v2 = off_1E651F618;
  v3 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v3);
  *(_QWORD *)(a1 + 440) = v3;
  v4 = (HgcMultiTexBlend_8 *)HGObject::operator new(0x1A0uLL);
  HgcMultiTexBlend_8::HgcMultiTexBlend_8(v4);
  *(_QWORD *)(a1 + 512) = v4;
  v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  *(_QWORD *)(a1 + 448) = v5;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v5 + 120))(v5, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 0, *(_QWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 408) = 1040187392;
  v6 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v6);
  *(_QWORD *)(a1 + 456) = v6;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v6 + 120))(v6, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 1, *(_QWORD *)(a1 + 456));
  *(_DWORD *)(a1 + 412) = 1040187392;
  v7 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v7);
  *(_QWORD *)(a1 + 464) = v7;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v7 + 120))(v7, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 2, *(_QWORD *)(a1 + 464));
  *(_DWORD *)(a1 + 416) = 1040187392;
  v8 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v8);
  *(_QWORD *)(a1 + 472) = v8;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v8 + 120))(v8, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 3, *(_QWORD *)(a1 + 472));
  *(_DWORD *)(a1 + 420) = 1040187392;
  v9 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v9);
  *(_QWORD *)(a1 + 480) = v9;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v9 + 120))(v9, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 4, *(_QWORD *)(a1 + 480));
  *(_DWORD *)(a1 + 424) = 1040187392;
  v10 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v10);
  *(_QWORD *)(a1 + 488) = v10;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v10 + 120))(v10, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 5, *(_QWORD *)(a1 + 488));
  *(_DWORD *)(a1 + 428) = 1040187392;
  v11 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v11);
  *(_QWORD *)(a1 + 496) = v11;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v11 + 120))(v11, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 6, *(_QWORD *)(a1 + 496));
  *(_DWORD *)(a1 + 432) = 1040187392;
  v12 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v12);
  *(_QWORD *)(a1 + 504) = v12;
  (*(void (**)(HGXForm *, _QWORD, _QWORD))(*(_QWORD *)v12 + 120))(v12, 0, *(_QWORD *)(a1 + 440));
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 512) + 120))(*(_QWORD *)(a1 + 512), 7, *(_QWORD *)(a1 + 504));
  *(_DWORD *)(a1 + 436) = 1040187392;
  return a1;
}

void sub_1B2A23F9C(_Unwind_Exception *a1)
{
  HGNode *v1;
  void *v2;

  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B2A23FD4(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGMultiTexBlend<8>::~HGMultiTexBlend(HGNode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)this = off_1E651F618;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = *((_QWORD *)this + 64);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  v4 = *((_QWORD *)this + 56);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *((_QWORD *)this + 57);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *((_QWORD *)this + 58);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  v7 = *((_QWORD *)this + 59);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = *((_QWORD *)this + 60);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  v9 = *((_QWORD *)this + 61);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  v10 = *((_QWORD *)this + 62);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  v11 = *((_QWORD *)this + 63);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  HGNode::~HGNode(this);
}

void HGMultiTexBlend<8>::~HGMultiTexBlend(HGNode *a1)
{
  void *v1;

  HGMultiTexBlend<8>::~HGMultiTexBlend(a1);
  HGObject::operator delete(v1);
}

uint64_t HGMultiTexBlend<8>::setTransform(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v5;

  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 448);
  if (result)
  {
    v5 = (_QWORD *)(v3 + 448);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 576))(result, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 160))(*v5, 1);
  }
  return result;
}

uint64_t HGMultiTexBlend<8>::setWeight(uint64_t result, int a2, float a3)
{
  *(float *)(result + 4 * a2 + 408) = a3;
  return result;
}

uint64_t HGMultiTexBlend<8>::GetOutput(uint64_t a1, HGRenderer *a2)
{
  uint64_t v4;
  HGNode *Input;

  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**(_QWORD **)(a1 + 512) + 96))(*(_QWORD *)(a1 + 512), 0, *(float *)(a1 + 408), *(float *)(a1 + 412), *(float *)(a1 + 416), *(float *)(a1 + 420));
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**(_QWORD **)(a1 + 512) + 96))(*(_QWORD *)(a1 + 512), 1, *(float *)(a1 + 424), *(float *)(a1 + 428), *(float *)(a1 + 432), *(float *)(a1 + 436));
  v4 = *(_QWORD *)(a1 + 440);
  Input = HGRenderer::GetInput(a2, (HGNode *)a1, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v4 + 120))(v4, 0, Input);
  return *(_QWORD *)(a1 + 512);
}

void HGGradientRadial::HGGradientRadial(HGGradientRadial *this)
{
  uint64_t v2;

  HGNode::HGNode((HGNode *)this);
  *(_QWORD *)v2 = off_1E651F938;
  *(_QWORD *)(v2 + 416) = 0;
  HGNode::SetFlags((HGNode *)v2, 0, 5);
  *((_DWORD *)this + 4) |= 0x601u;
  *((_DWORD *)this + 102) = 3;
}

void sub_1B2A24254(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 416);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGGradientRadial::~HGGradientRadial(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E651F938;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = off_1E651F938;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
  HGObject::operator delete(v3);
}

uint64_t HGGradientRadial::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  uint64_t DOD;
  uint64_t v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  _BOOL4 v10;
  int v11;
  uint64_t v13;
  uint64_t v14;
  HGTextureWrap *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  HGNode *v19;
  HGNode *v20;
  HgcGradientRadialIdentity *v21;
  HgcGradientRadialIdentity *v22;
  _QWORD *v23;
  uint64_t v24;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30[4];
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  HGRect v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  Input = HGRenderer::GetInput(a2, this, 0);
  if (!(*(unsigned int (**)(HGRenderer *))(*(_QWORD *)a2 + 304))(a2)
    || (DOD = HGRenderer::GetDOD(a2, Input), (HIDWORD(v6) - HIDWORD(DOD)) > 1))
  {
    (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 3, &v37);
    (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 4, &v34);
    (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 5, &v31);
    v10 = *(float *)&v37.var0 == 1.0;
    if (*(float *)&v37.var1 != 0.0)
      v10 = 0;
    v9.n128_f32[0] = v31;
    v8.n128_f32[0] = v32;
    v7.n128_f32[0] = v33;
    if (v10
      && *(float *)&v37.var3 == 0.0
      && v34 == 0.0
      && v35 == 1.0
      && v36 == 0.0
      && v31 == 0.0
      && v32 == 0.0
      && v33 == 1.0)
    {
      v11 = 0;
LABEL_33:
      *((_DWORD *)this + 102) = v11;
      (*(void (**)(HGNode *, uint64_t, float *, __n128, __n128, __n128))(*(_QWORD *)this + 104))(this, 2, v30, v7, v8, v9);
      v30[3] = 1.0 / v30[0];
      (*(void (**)(HGNode *, uint64_t))(*(_QWORD *)this + 96))(this, 2);
      switch(*((_DWORD *)this + 102))
      {
        case 0:
          v21 = (HgcGradientRadialIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientRadialIdentity::HgcGradientRadialIdentity(v21);
          v22 = (HgcGradientRadialIdentity *)*((_QWORD *)this + 52);
          if (v22 != v21)
          {
            if (!v22)
              goto LABEL_46;
            goto LABEL_45;
          }
          if (v21)
            goto LABEL_58;
          break;
        case 1:
          v21 = (HgcGradientRadialIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientRadialTranslate::HgcGradientRadialTranslate(v21);
          v22 = (HgcGradientRadialIdentity *)*((_QWORD *)this + 52);
          if (v22 != v21)
          {
            if (!v22)
              goto LABEL_46;
            goto LABEL_45;
          }
          if (v21)
            goto LABEL_58;
          break;
        case 2:
          v21 = (HgcGradientRadialIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientRadialAffine::HgcGradientRadialAffine(v21);
          v22 = (HgcGradientRadialIdentity *)*((_QWORD *)this + 52);
          if (v22 != v21)
          {
            if (!v22)
              goto LABEL_46;
            goto LABEL_45;
          }
          if (v21)
            goto LABEL_58;
          break;
        case 3:
          v21 = (HgcGradientRadialIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientRadialPerspective::HgcGradientRadialPerspective(v21);
          v22 = (HgcGradientRadialIdentity *)*((_QWORD *)this + 52);
          if (v22 == v21)
          {
            if (v21)
LABEL_58:
              (*(void (**)(HgcGradientRadialIdentity *))(*(_QWORD *)v21 + 24))(v21);
          }
          else
          {
            if (v22)
LABEL_45:
              (*(void (**)(HgcGradientRadialIdentity *))(*(_QWORD *)v22 + 24))(v22);
LABEL_46:
            *((_QWORD *)this + 52) = v21;
          }
          break;
        default:
          break;
      }
      (*(void (**)(_QWORD, _QWORD, HGNode *))(**((_QWORD **)this + 52) + 120))(*((_QWORD *)this + 52), 0, Input);
      (*(void (**)(HGNode *, _QWORD, float *))(*(_QWORD *)this + 104))(this, 0, &v26);
      v23 = (_QWORD *)((char *)this + 416);
      (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, v26, v27, v28, v29);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 1, &v26);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v23 + 96))(*v23, 1, v26, v27, v28, v29);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 2, &v26);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v23 + 96))(*v23, 2, v26, v27, v28, v29);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 3, &v26);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v23 + 96))(*v23, 3, v26, v27, v28, v29);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 4, &v26);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v23 + 96))(*v23, 4, v26, v27, v28, v29);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 5, &v26);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v23 + 96))(*v23, 5, v26, v27, v28, v29);
      (*(void (**)(HGNode *, uint64_t, float *))(*(_QWORD *)this + 104))(this, 6, &v26);
      (*(void (**)(_QWORD, uint64_t, float, float, float, float))(*(_QWORD *)*v23 + 96))(*v23, 6, v26, v27, v28, v29);
      return *((_QWORD *)this + 52);
    }
    if (v34 != 0.0)
      v10 = 0;
    if (v10 && v35 == 1.0)
    {
      if (v31 != 0.0)
        goto LABEL_32;
      if (v32 == 0.0 && v33 == 1.0)
      {
        v11 = 1;
        goto LABEL_33;
      }
    }
    if (v31 == 0.0 && v32 == 0.0)
    {
      v8.n128_u32[0] = 1.0;
      if (v33 == 1.0)
      {
        v11 = 2;
        goto LABEL_33;
      }
    }
LABEL_32:
    v11 = 3;
    goto LABEL_33;
  }
  v13 = DOD;
  v14 = v6;
  v15 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v15);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v15, (const char *)3, v16);
  v17 = HGRectMake4i(0, 0, 0, 1u);
  *(_QWORD *)&v37.var0 = HGRectGrow(v13, v14, v17);
  *(_QWORD *)&v37.var2 = v18;
  HGTextureWrap::SetCropRect(v15, &v37);
  (*(void (**)(HGTextureWrap *, _QWORD, HGNode *))(*(_QWORD *)v15 + 120))(v15, 0, Input);
  v19 = (HGNode *)HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v19);
  *(_QWORD *)v19 = off_1E651F938;
  *((_QWORD *)v19 + 52) = 0;
  HGNode::SetFlags(v19, 0, 5);
  *((_DWORD *)v19 + 4) |= 0x601u;
  *((_DWORD *)v19 + 102) = 3;
  v20 = (HGNode *)*((_QWORD *)this + 52);
  if (v20 == v19)
  {
    (*(void (**)(HGNode *))(*(_QWORD *)v19 + 24))(v19);
    v19 = (HGNode *)*((_QWORD *)this + 52);
  }
  else
  {
    if (v20)
      (*(void (**)(HGNode *))(*(_QWORD *)v20 + 24))(v20);
    *((_QWORD *)this + 52) = v19;
  }
  (*(void (**)(HGNode *, _QWORD, HGTextureWrap *))(*(_QWORD *)v19 + 120))(v19, 0, v15);
  (*(void (**)(HGNode *, _QWORD, HGRect *))(*(_QWORD *)this + 104))(this, 0, &v37);
  (*(void (**)(_QWORD, _QWORD, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 0, *(float *)&v37.var0, *(float *)&v37.var1, *(float *)&v37.var2, *(float *)&v37.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 1, &v37);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 1, *(float *)&v37.var0, *(float *)&v37.var1, *(float *)&v37.var2, *(float *)&v37.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 2, &v37);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 2, *(float *)&v37.var0, *(float *)&v37.var1, *(float *)&v37.var2, *(float *)&v37.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 3, &v37);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 3, *(float *)&v37.var0, *(float *)&v37.var1, *(float *)&v37.var2, *(float *)&v37.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 4, &v37);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 4, *(float *)&v37.var0, *(float *)&v37.var1, *(float *)&v37.var2, *(float *)&v37.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 5, &v37);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 5, *(float *)&v37.var0, *(float *)&v37.var1, *(float *)&v37.var2, *(float *)&v37.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(_QWORD *)this + 104))(this, 6, &v37);
  (*(void (**)(_QWORD, uint64_t, float, float, float, float))(**((_QWORD **)this + 52) + 96))(*((_QWORD *)this + 52), 6, *(float *)&v37.var0, *(float *)&v37.var1, *(float *)&v37.var2, *(float *)&v37.var3);
  v24 = *((_QWORD *)this + 52);
  (*(void (**)(HGTextureWrap *))(*(_QWORD *)v15 + 24))(v15);
  return v24;
}

void sub_1B2A24AC0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

const char *HGGradientRadial::label_B(HGGradientRadial *this)
{
  uint64_t v1;

  v1 = *((int *)this + 102);
  if (v1 > 2)
    return "kXFormPerspective";
  else
    return off_1E651FB90[v1];
}

void HGGradientRadial::info(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t HGColorConformLook3DLUT::HGColorConformLook3DLUT(uint64_t a1, int a2)
{
  _QWORD *v4;
  int v5;
  const __CFString *v6;
  void *v7;
  void *v8;
  const void *v9;
  uint64_t v10;
  unsigned __int8 md[20];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  HGObject::HGObject((HGObject *)a1);
  *v4 = off_1E652DBA8;
  v4[8] = 0;
  v4[2] = 0;
  v4[9] = 0;
  v4[10] = 0;
  v4[4] = 33;
  v5 = 0;
  v6 = CFSTR("CinemaGamut_CanonLog2-to-BT.709_WideDR_33_Ver1.0");
  switch(a2)
  {
    case 0:
      v5 = 0;
      *(_QWORD *)(a1 + 32) = 65;
      v6 = CFSTR("ARRI_LogC4-to-Gamma24_Rec709-D65_v1-65");
      goto LABEL_15;
    case 1:
      *(_QWORD *)(a1 + 32) = 65;
      v6 = CFSTR("ARRI_LogC4-to-Gamma24_Rec2020-D65_v1-65");
      v5 = 3;
      goto LABEL_15;
    case 2:
      goto LABEL_15;
    case 3:
      v6 = CFSTR("CinemaGamut_CanonLog2-to-BT.2020_WideDR_33_Ver1.0");
      v5 = 3;
      goto LABEL_15;
    case 4:
      v5 = 0;
      v6 = CFSTR("CinemaGamut_CanonLog3-to-BT.709_WideDR_33_Ver1.0");
      goto LABEL_15;
    case 5:
      v6 = CFSTR("CinemaGamut_CanonLog3-to-BT.2020_WideDR_33_Ver1.0");
      v5 = 3;
      goto LABEL_15;
    case 6:
      v5 = 0;
      v6 = CFSTR("VLog_to_V709_forV35_ver100");
      goto LABEL_15;
    case 7:
      v6 = CFSTR("VLog_to_V2020_forV35_20160707");
      v5 = 3;
      goto LABEL_15;
    case 8:
      v5 = 0;
      v6 = CFSTR("Z_6_N-Log-Full_to_REC709_Full_33_V01-00");
      goto LABEL_15;
    case 9:
      v5 = 0;
      *(_QWORD *)(a1 + 32) = 65;
      v6 = CFSTR("AppleLogToRec709_v1.0");
      goto LABEL_15;
    case 10:
      v5 = 0;
      v6 = CFSTR("DJI_Mavic_3_D-Log_to_Rec.709_V1");
      goto LABEL_15;
    case 11:
      v5 = 0;
      v6 = CFSTR("XH2S_FLog_FGamut_to_WDR_BT.709_33grid_V.1.00");
      goto LABEL_15;
    case 12:
      v5 = 0;
      v6 = CFSTR("XH2S_FLog2_FGamut_to_WDR_BT.709_33grid_V.1.00");
LABEL_15:
      *(_DWORD *)(a1 + 108) = v5;
      *(_DWORD *)(a1 + 112) = 1;
      break;
    default:
      v6 = 0;
      break;
  }
  v7 = (void *)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", CFSTR("com.apple.Helium"));
  if (v7
    && (v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithContentsOfFile:", objc_msgSend(v7, "pathForResource:ofType:", v6, CFSTR("3dlut"))), (v9 = v8) != 0))
  {
    CC_SHA1((const void *)objc_msgSend(v8, "bytes"), objc_msgSend(v8, "length"), md);
    HGColorConformLook3DLUT::SetChecksum((HGColorConformLook3DLUT *)a1, md, 20);
    HGColorConformLook3DLUT::SetBuffer((HGColorConformLook3DLUT *)a1, v9);
    *(_QWORD *)(a1 + 24) = 1065353216;
    v10 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 40) = 6 * v10;
    *(_QWORD *)(a1 + 48) = 6 * v10 * v10;
    *(_BYTE *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 60) = 1;
    *(_OWORD *)(a1 + 88) = xmmword_1B304FAB0;
    *(_BYTE *)(a1 + 104) = 0;
  }
  else
  {
    HGColorConformLook3DLUT::Clear((HGColorConformLook3DLUT *)a1);
  }
  return a1;
}

