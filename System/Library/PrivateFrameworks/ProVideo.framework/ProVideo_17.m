void PSHeliumNode::PointSpriteBatcher::flush(PSHeliumNode::PointSpriteBatcher *this)
{
  unsigned __int8 v2;
  __int128 *v3;
  HGHandler *v4;
  std::string *v5;
  __int128 v6;
  std::string v7;

  if (*((_QWORD *)this + 4) != *((_QWORD *)this + 5))
  {
    if ((v2 & 1) == 0
    {
      HGMetalUtils::stringForMetalHeader((uint64_t)&v7);
      v5 = std::string::append(&v7, "\n        struct Vertex\n        {\n            float4 position;\n"
             "            float4 color;\n"
             "            float4x4 mv;\n"
             "            float pointSize;\n"
             "        };\n"
             "    \n"
             "        struct VertexInOut\n"
             "        {\n"
             "            float4 _position  [[ position ]];\n"
             "            float  _pointSize [[ point_size ]];\n"
             "            float4 _color;\n"
             "        };\n"
             "    \n"
             "        struct FragmentOut\n"
             "        {\n"
             "            float4 color0     [[ color(0) ]];\n"
             "        };\n"
             "    \n"
             "        vertex VertexInOut vertexFunc(constant float4x4 *matrices [[ buffer(0) ]],\n"
             "                                      const device Vertex *vertices [[ buffer(1) ]],\n"
             "                                      uint vid [[ vertex_id ]])\n"
             "        {\n"
             "            constant float4x4 *projectionMatrix = matrices;\n"
             "            VertexInOut vert;\n"
             "            vert._position = *projectionMatrix * vertices[vid].mv * vertices[vid].position;\n"
             "            vert._pointSize = vertices[vid].pointSize;\n"
             "            vert._color = vertices[vid].color;\n"
             "            return vert;\n"
             "        }\n"
             "    \n"
             "        fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]])\n"
             "        {\n"
             "            FragmentOut out;\n"
             "            out.color0 = frag._color;\n"
             "            return out;\n"
             "        }\n"
             "    ");
      v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
      unk_1EF0767F0 = *((_QWORD *)&v5->__r_.__value_.__l + 2);
      PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText = v6;
      v5->__r_.__value_.__l.__size_ = 0;
      v5->__r_.__value_.__r.__words[2] = 0;
      v5->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v7.__r_.__value_.__l.__data_);
      __cxa_atexit(MEMORY[0x1E0DE44D0], &PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText, &dword_1B2737000);
    }
    if (*(_DWORD *)(*((_QWORD *)this + 3) + 896) != 7)
    {
      if (byte_1EF0767F7 >= 0)
        v3 = &PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText;
      else
        v3 = (__int128 *)PSHeliumNode::PointSpriteBatcher::flush(void)::shaderText;
      (*(void (**)(_QWORD, __int128 *))(***((_QWORD ***)this + 1) + 376))(**((_QWORD **)this + 1), v3);
      *(_DWORD *)(*((_QWORD *)this + 3) + 896) = 7;
    }
    v4 = (HGHandler *)*((_QWORD *)this + 2);
    if (v4)
    {
      HGHandler::LoadIdentityModelViewMatrix(v4);
      HGMetalHandler::DisableBlending(*((_QWORD *)this + 2));
      HGMetalHandler::SetVertices(*((HGMetalHandler **)this + 2), *((const void **)this + 4), 112, -1227133513 * ((*((_QWORD *)this + 5) - *((_QWORD *)this + 4)) >> 4));
      HGMetalHandler::PrimitivesStart(*((HGMetalHandler **)this + 2));
      HGMetalHandler::Primitives(*((_QWORD *)this + 2), 0);
      HGMetalHandler::PrimitivesEnd(*((HGMetalHandler **)this + 2));
    }
    *((_QWORD *)this + 5) = *((_QWORD *)this + 4);
  }
}

void sub_1B2FF500C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

PSHeliumNode::SpriteBatchController *PSHeliumNode::SpriteBatchController::SpriteBatchController(PSHeliumNode::SpriteBatchController *this, HGPage *a2, HGMetalHandler *a3, PSHeliumNode *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  int64x2_t v40;
  char *v41;
  uint64_t v43;
  int64x2_t v44;
  char *v45;
  char *v46;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v8 = (_QWORD *)operator new();
  v9 = v8;
  v8[2] = a3;
  v8[3] = a4;
  *v8 = &off_1E65E8F08;
  v8[1] = a2;
  v8[4] = 0;
  v8[7] = 0;
  v8[8] = 0;
  v8[6] = 0;
  v10 = *((_QWORD *)this + 2);
  v11 = (_QWORD *)*((_QWORD *)this + 1);
  if ((unint64_t)v11 >= v10)
  {
    v13 = ((uint64_t)v11 - *(_QWORD *)this) >> 3;
    if ((unint64_t)(v13 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v14 = v10 - *(_QWORD *)this;
    v15 = v14 >> 2;
    if (v14 >> 2 <= (unint64_t)(v13 + 1))
      v15 = v13 + 1;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
      v16 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v16 = v15;
    v46 = (char *)this + 16;
    if (v16)
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 16, v16);
    else
      v17 = 0;
    v18 = &v17[8 * v13];
    v19 = &v17[8 * v16];
    v45 = v19;
    *(_QWORD *)v18 = v9;
    v12 = v18 + 8;
    v44.i64[1] = (uint64_t)(v18 + 8);
    v21 = *(_QWORD **)this;
    v20 = (_QWORD *)*((_QWORD *)this + 1);
    if (v20 == *(_QWORD **)this)
    {
      v23 = vdupq_n_s64((unint64_t)v20);
    }
    else
    {
      do
      {
        v22 = *--v20;
        *v20 = 0;
        *((_QWORD *)v18 - 1) = v22;
        v18 -= 8;
      }
      while (v20 != v21);
      v23 = *(int64x2_t *)this;
      v12 = (_QWORD *)v44.i64[1];
      v19 = v45;
    }
    *(_QWORD *)this = v18;
    *((_QWORD *)this + 1) = v12;
    v44 = v23;
    v24 = (char *)*((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v19;
    v45 = v24;
    v43 = v23.i64[0];
    std::__split_buffer<std::unique_ptr<PSHeliumNode::BatcherBase>>::~__split_buffer((uint64_t)&v43);
  }
  else
  {
    *v11 = v8;
    v12 = v11 + 1;
  }
  *((_QWORD *)this + 1) = v12;
  v25 = (_QWORD *)operator new();
  v26 = v25;
  v25[2] = a3;
  v25[3] = a4;
  *v25 = &off_1E65E8F60;
  v25[1] = a2;
  v25[5] = 0;
  v25[6] = 0;
  v25[4] = 0;
  v28 = (_QWORD *)*((_QWORD *)this + 1);
  v27 = *((_QWORD *)this + 2);
  if ((unint64_t)v28 >= v27)
  {
    v30 = ((uint64_t)v28 - *(_QWORD *)this) >> 3;
    if ((unint64_t)(v30 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v31 = v27 - *(_QWORD *)this;
    v32 = v31 >> 2;
    if (v31 >> 2 <= (unint64_t)(v30 + 1))
      v32 = v30 + 1;
    if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8)
      v33 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v33 = v32;
    v46 = (char *)this + 16;
    if (v33)
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 16, v33);
    else
      v34 = 0;
    v35 = &v34[8 * v30];
    v36 = &v34[8 * v33];
    v45 = v36;
    *(_QWORD *)v35 = v26;
    v29 = v35 + 8;
    v44.i64[1] = (uint64_t)(v35 + 8);
    v38 = *(_QWORD **)this;
    v37 = (_QWORD *)*((_QWORD *)this + 1);
    if (v37 == *(_QWORD **)this)
    {
      v40 = vdupq_n_s64((unint64_t)v37);
    }
    else
    {
      do
      {
        v39 = *--v37;
        *v37 = 0;
        *((_QWORD *)v35 - 1) = v39;
        v35 -= 8;
      }
      while (v37 != v38);
      v40 = *(int64x2_t *)this;
      v29 = (_QWORD *)v44.i64[1];
      v36 = v45;
    }
    *(_QWORD *)this = v35;
    *((_QWORD *)this + 1) = v29;
    v44 = v40;
    v41 = (char *)*((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v36;
    v45 = v41;
    v43 = v40.i64[0];
    std::__split_buffer<std::unique_ptr<PSHeliumNode::BatcherBase>>::~__split_buffer((uint64_t)&v43);
  }
  else
  {
    *v28 = v25;
    v29 = v28 + 1;
  }
  *((_QWORD *)this + 1) = v29;
  return this;
}

void sub_1B2FF52BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  va_list va;

  va_start(va, a6);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  std::vector<std::unique_ptr<PSHeliumNode::BatcherBase>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void PSHeliumNode::TextureSpriteBatcher::~TextureSpriteBatcher(PSHeliumNode::TextureSpriteBatcher *this)
{
  void *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E65E8F08;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
}

{
  void *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E65E8F08;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  JUMPOUT(0x1B5E29170);
}

void PSHeliumNode::PointSpriteBatcher::~PointSpriteBatcher(PSHeliumNode::PointSpriteBatcher *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E65E8F60;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E65E8F60;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1B5E29170);
}

void `anonymous namespace'::HGNodeBuffer::~HGNodeBuffer(_anonymous_namespace_::HGNodeBuffer *this)
{
  void *v1;

  HGBuffer::~HGBuffer(this);
  HGObject::operator delete(v1);
}

void `anonymous namespace'::HGNodeBuffer::ReadTile(_anonymous_namespace_::HGNodeBuffer *this, char *a2, HGRect a3, uint64_t a4)
{
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;

  v5 = *((_QWORD *)this + 17);
  v6 = *(_DWORD *)(v5 + 36);
  v7 = *(_DWORD *)(v5 + 112);
  HGExecutionUnit::RenderTile(v5, a2, *(unint64_t *)&a3.var0, *(unint64_t *)&a3.var2, *((_QWORD *)this + 16), a4);
  v8 = *((_QWORD *)this + 17);
  *(_DWORD *)(v8 + 36) = v6;
  *(_DWORD *)(v8 + 112) = v7;
}

uint64_t *std::__tree<PSHeliumNode::Sprite *,PSHeliumNode::lessThanSprite,std::allocator<PSHeliumNode::Sprite *>>::__emplace_hint_unique_key_args<PSHeliumNode::Sprite *,PSHeliumNode::Sprite * const&>(uint64_t **a1, _QWORD *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<PSHeliumNode::Sprite *,PSHeliumNode::lessThanSprite,std::allocator<PSHeliumNode::Sprite *>>::__find_equal<PSHeliumNode::Sprite *>(a1, a2, &v11, &v10, a3);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v11, v8, v7);
  }
  return v7;
}

_QWORD *std::__tree<PSHeliumNode::Sprite *,PSHeliumNode::lessThanSprite,std::allocator<PSHeliumNode::Sprite *>>::__find_equal<PSHeliumNode::Sprite *>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  _QWORD *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unsigned int v15;
  _QWORD *v16;
  _QWORD *v17;
  unsigned int v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unsigned int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *(_DWORD *)(*(_QWORD *)a5 + 4), v7 = *(_DWORD *)(a2[4] + 4), v6 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *(_DWORD *)(*(_QWORD *)a5 + 4);
    if (*(_DWORD *)(v10[4] + 4) < v15)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = *(_DWORD *)(v16[4] + 4);
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *(_DWORD *)(a4[4] + 4))
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = *(_DWORD *)(v20[4] + 4);
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void std::vector<PSHeliumNode::Sprite>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<PSHeliumNode::Sprite>::__base_destruct_at_end[abi:ne180100](v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

_QWORD *std::vector<PSHeliumNode::Sprite>::__base_destruct_at_end[abi:ne180100](_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t i;

  v3 = result;
  for (i = result[1]; i != a2; i -= 312)
  {
    result = *(_QWORD **)(i - 104);
    if (result)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 24))(result);
  }
  v3[1] = a2;
  return result;
}

void std::__tree<std::shared_ptr<PCImage>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::shared_ptr<PCImage>>::destroy(a1, *a2);
    std::__tree<std::shared_ptr<PCImage>>::destroy(a1, a2[1]);
    std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::vector<std::unique_ptr<PSHeliumNode::BatcherBase>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<PSHeliumNode::Sprite>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xD20D20D20D20D3)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(312 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>,std::reverse_iterator<PSHeliumNode::Sprite*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 312;
      std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(a1, v7 - 312, v9);
      v7 = *((_QWORD *)&v16 + 1) - 312;
      *((_QWORD *)&v16 + 1) -= 312;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_1B2FF59AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

__n128 std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __n128 result;

  *(_OWORD *)a2 = *(_OWORD *)a3;
  v5 = *(_OWORD *)(a3 + 16);
  v6 = *(_OWORD *)(a3 + 32);
  v7 = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 64) = v7;
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 32) = v6;
  v8 = *(_OWORD *)(a3 + 80);
  v9 = *(_OWORD *)(a3 + 96);
  v10 = *(_OWORD *)(a3 + 128);
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(a3 + 112);
  *(_OWORD *)(a2 + 128) = v10;
  *(_OWORD *)(a2 + 80) = v8;
  *(_OWORD *)(a2 + 96) = v9;
  v11 = *(_OWORD *)(a3 + 144);
  v12 = *(_OWORD *)(a3 + 160);
  v13 = *(_OWORD *)(a3 + 176);
  *(_OWORD *)(a2 + 188) = *(_OWORD *)(a3 + 188);
  *(_OWORD *)(a2 + 160) = v12;
  *(_OWORD *)(a2 + 176) = v13;
  *(_OWORD *)(a2 + 144) = v11;
  v14 = *(_QWORD *)(a3 + 208);
  *(_QWORD *)(a2 + 208) = v14;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
  v15 = *(_OWORD *)(a3 + 216);
  v16 = *(_OWORD *)(a3 + 232);
  *(_QWORD *)(a2 + 248) = *(_QWORD *)(a3 + 248);
  *(_OWORD *)(a2 + 232) = v16;
  *(_OWORD *)(a2 + 216) = v15;
  *(_OWORD *)(a2 + 256) = *(_OWORD *)(a3 + 256);
  *(_OWORD *)(a2 + 272) = *(_OWORD *)(a3 + 272);
  result = *(__n128 *)(a3 + 288);
  *(__n128 *)(a2 + 288) = result;
  *(_BYTE *)(a2 + 304) = *(_BYTE *)(a3 + 304);
  return result;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<PSHeliumNode::Sprite*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<std::reverse_iterator<PSHeliumNode::Sprite*>>,std::reverse_iterator<std::reverse_iterator<PSHeliumNode::Sprite*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>,std::reverse_iterator<std::reverse_iterator<PSHeliumNode::Sprite*>>,std::reverse_iterator<std::reverse_iterator<PSHeliumNode::Sprite*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v6;

  for (i = *(_QWORD *)(a2 + 32); i != *(_QWORD *)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {
    v6 = *(_QWORD *)(i + 208);
    if (v6)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
      i = *(_QWORD *)(a2 + 32);
    }
    i += 312;
  }
}

void **std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer(void **a1)
{
  std::__split_buffer<PSHeliumNode::Sprite>::__destruct_at_end[abi:ne180100](a1, (uint64_t)a1[1]);
  if (*a1)
    operator delete(*a1);
  return a1;
}

_QWORD *std::__split_buffer<PSHeliumNode::Sprite>::__destruct_at_end[abi:ne180100](_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;

  v2 = result[2];
  if (v2 != a2)
  {
    v4 = result;
    do
    {
      v4[2] = v2 - 312;
      result = *(_QWORD **)(v2 - 104);
      if (result)
      {
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 24))(result);
        v2 = v4[2];
      }
      else
      {
        v2 -= 312;
      }
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t std::vector<PSHeliumNode::Sprite>::__push_back_slow_path<PSHeliumNode::Sprite const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0x6F96F96F96F96F97 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0xD20D20D20D20D2)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  if (0xDF2DF2DF2DF2DF2ELL * ((a1[2] - *a1) >> 3) > v4)
    v4 = 0xDF2DF2DF2DF2DF2ELL * ((a1[2] - *a1) >> 3);
  if ((unint64_t)(0x6F96F96F96F96F97 * ((a1[2] - *a1) >> 3)) >= 0x69069069069069)
    v6 = 0xD20D20D20D20D2;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::Sprite>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[312 * v3];
  v13 = &v7[312 * v6];
  std::allocator<PSHeliumNode::Sprite>::construct[abi:ne180100]<PSHeliumNode::Sprite,PSHeliumNode::Sprite const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 312;
  std::vector<PSHeliumNode::Sprite>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer(&v10);
  return v8;
}

void sub_1B2FF5D1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<PSHeliumNode::Sprite>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::shared_ptr<PCImage>>::__emplace_unique_key_args<std::shared_ptr<PCImage>,std::shared_ptr<PCImage>>(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD v13[2];
  char v14;

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    v9 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v10 = v5[4];
        if (v9 >= v10)
          break;
        v5 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_9;
      }
      if (v10 >= v9)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v11 = (uint64_t *)operator new(0x30uLL);
    v13[1] = v6;
    *((_OWORD *)v11 + 2) = *(_OWORD *)a3;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    v14 = 1;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v8, v7, v11);
    v13[0] = 0;
    std::unique_ptr<std::__tree_node<std::shared_ptr<PCImage>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<PCImage>,void *>>>>::reset[abi:ne180100]((uint64_t)v13, 0);
    return (uint64_t **)v11;
  }
  return v8;
}

void std::unique_ptr<std::__tree_node<std::shared_ptr<PCImage>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<PCImage>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE8__appendEmRKS1_(void **a1, unint64_t a2, _OWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _OWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _OWORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_OWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 4)
  {
    if (a2)
    {
      v16 = 16 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 16;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 4);
    if (v11 >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v12 = v10 >> 4;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 3 > v11)
      v11 = v13 >> 3;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
      v14 = 0xFFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v6, v14);
    else
      v15 = 0;
    v18 = &v15[16 * v12];
    v19 = &v18[16 * a2];
    v20 = 16 * a2;
    v21 = v18;
    do
    {
      *(_OWORD *)v21 = *a3;
      v21 += 16;
      v20 -= 16;
    }
    while (v20);
    v22 = &v15[16 * v14];
    v24 = (char *)*a1;
    v23 = (char *)a1[1];
    if (v23 != *a1)
    {
      do
      {
        v25 = *((_OWORD *)v23 - 1);
        v23 -= 16;
        *((_OWORD *)v18 - 1) = v25;
        v18 -= 16;
      }
      while (v23 != v24);
      v23 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(112 * a2);
}

uint64_t std::__split_buffer<std::unique_ptr<PSHeliumNode::BatcherBase>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t PSTextureCache::Instance(PSTextureCache *this)
{
  if (PSTextureCache::Instance(void)::once != -1)
    dispatch_once(&PSTextureCache::Instance(void)::once, &__block_literal_global_86);
  return PSTextureCache::_instance;
}

void ___ZN14PSTextureCache8InstanceEv_block_invoke()
{
  PSTextureCache *v0;

  v0 = (PSTextureCache *)operator new();
  PSTextureCache::PSTextureCache(v0);
  PSTextureCache::_instance = (uint64_t)v0;
}

void sub_1B2FF6094(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40A9FDA665);
  _Unwind_Resume(a1);
}

void PSTextureCache::addTexture(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  std::mutex *v8;
  uint64_t *v9;
  _DWORD *v10;
  unint64_t v11;
  unint64_t *v12;

  v8 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock((std::mutex *)(a1 + 8));
  v11 = *(_QWORD *)(*(_QWORD *)a3 + 96);
  v12 = &v11;
  v9 = std::__tree<std::__value_type<OZLocking *,std::set<OZLocking *>>,std::__map_value_compare<OZLocking *,std::__value_type<OZLocking *,std::set<OZLocking *>>,std::less<OZLocking *>,true>,std::allocator<std::__value_type<OZLocking *,std::set<OZLocking *>>>>::__emplace_unique_key_args<OZLocking *,std::piecewise_construct_t const&,std::tuple<OZLocking * const&>,std::tuple<>>((uint64_t **)(a1 + 112), &v11, (uint64_t)&std::piecewise_construct, (uint64_t **)&v12);
  v12 = (unint64_t *)a4;
  v10 = std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>((uint64_t **)v9 + 5, (const PCHash128 *)a4, (uint64_t)&std::piecewise_construct, (_DWORD **)&v12);
  std::shared_ptr<TXTextStyle>::operator=[abi:ne180100]((_QWORD *)v10 + 6, a2);
  PCSharedMutex::unlock(v8);
}

{
  std::mutex *v8;
  uint64_t *v9;
  _DWORD *v10;
  unint64_t v11;
  unint64_t *v12;

  v8 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock((std::mutex *)(a1 + 8));
  v11 = *(_QWORD *)(*(_QWORD *)a3 + 96);
  v12 = &v11;
  v9 = std::__tree<std::__value_type<OZLocking *,std::set<OZLocking *>>,std::__map_value_compare<OZLocking *,std::__value_type<OZLocking *,std::set<OZLocking *>>,std::less<OZLocking *>,true>,std::allocator<std::__value_type<OZLocking *,std::set<OZLocking *>>>>::__emplace_unique_key_args<OZLocking *,std::piecewise_construct_t const&,std::tuple<OZLocking * const&>,std::tuple<>>((uint64_t **)(a1 + 112), &v11, (uint64_t)&std::piecewise_construct, (uint64_t **)&v12);
  v12 = (unint64_t *)a4;
  v10 = std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>((uint64_t **)v9 + 5, (const PCHash128 *)a4, (uint64_t)&std::piecewise_construct, (_DWORD **)&v12);
  std::shared_ptr<TXTextStyle>::operator=[abi:ne180100]((_QWORD *)v10 + 8, a2);
  PCSharedMutex::unlock(v8);
}

void sub_1B2FF616C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  PCSharedMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B2FF623C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  PCSharedMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void PSTextureCache::getTextureForKey(uint64_t a1@<X0>, uint64_t a2@<X1>, const PCHash128 *a3@<X2>, uint64_t a4@<X8>)
{
  std::mutex *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;

  v8 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock_shared((std::mutex *)(a1 + 8));
  v17 = *(_QWORD *)(*(_QWORD *)a2 + 96);
  v18 = &v17;
  v9 = std::__tree<std::__value_type<OZLocking *,std::set<OZLocking *>>,std::__map_value_compare<OZLocking *,std::__value_type<OZLocking *,std::set<OZLocking *>>,std::less<OZLocking *>,true>,std::allocator<std::__value_type<OZLocking *,std::set<OZLocking *>>>>::__emplace_unique_key_args<OZLocking *,std::piecewise_construct_t const&,std::tuple<OZLocking * const&>,std::tuple<>>((uint64_t **)(a1 + 112), &v17, (uint64_t)&std::piecewise_construct, (uint64_t **)&v18);
  v10 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>((uint64_t)(v9 + 5), a3);
  if (v9 + 6 == v10)
  {
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
  }
  else
  {
    v11 = v10[7];
    *(_QWORD *)a4 = v10[6];
    *(_QWORD *)(a4 + 8) = v11;
    if (v11)
    {
      v12 = (unint64_t *)(v11 + 8);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    v14 = v10[9];
    *(_QWORD *)(a4 + 16) = v10[8];
    *(_QWORD *)(a4 + 24) = v14;
    if (v14)
    {
      v15 = (unint64_t *)(v14 + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
  }
  PCSharedMutex::unlock_shared(v8);
}

void sub_1B2FF6348(_Unwind_Exception *a1)
{
  std::mutex *v1;

  PCSharedMutex::unlock_shared(v1);
  _Unwind_Resume(a1);
}

uint64_t *PSTextureCache::removeTextureNoLock(uint64_t *result, _QWORD *a2)
{
  uint64_t **v2;
  uint64_t *v3;
  uint64_t *v5;
  uint64_t *v6;
  BOOL v7;
  uint64_t *v8;
  uint64_t *v9;

  v2 = (uint64_t **)result[14];
  v3 = result + 15;
  if (v2 != (uint64_t **)(result + 15))
  {
    do
    {
      v5 = v2[5];
      if (v5 != (uint64_t *)(v2 + 6))
      {
        do
        {
          if (v5[6] == *a2 || v5[8] == *a2)
          {
            result = std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::erase(v2 + 5, v5);
          }
          else
          {
            v6 = (uint64_t *)v5[1];
            if (v6)
            {
              do
              {
                result = v6;
                v6 = (uint64_t *)*v6;
              }
              while (v6);
            }
            else
            {
              do
              {
                result = (uint64_t *)v5[2];
                v7 = *result == (_QWORD)v5;
                v5 = result;
              }
              while (!v7);
            }
          }
          v5 = result;
        }
        while (result != (uint64_t *)(v2 + 6));
      }
      v8 = v2[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = v2[2];
          v7 = *v9 == (_QWORD)v2;
          v2 = (uint64_t **)v9;
        }
        while (!v7);
      }
      v2 = (uint64_t **)v9;
    }
    while (v9 != v3);
  }
  return result;
}

void PSTextureCache::removeTextures(uint64_t a1, _QWORD *a2)
{
  std::mutex *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;

  v4 = (std::mutex *)(a1 + 8);
  PCSharedMutex::lock((std::mutex *)(a1 + 8));
  v7 = (_QWORD *)*a2;
  v5 = a2 + 1;
  v6 = v7;
  if (v7 != v5)
  {
    do
    {
      PSTextureCache::removeTextureNoLock((uint64_t *)a1, v6 + 4);
      v8 = (_QWORD *)v6[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (_QWORD *)v6[2];
          v10 = *v9 == (_QWORD)v6;
          v6 = v9;
        }
        while (!v10);
      }
      v6 = v9;
    }
    while (v9 != v5);
  }
  PCSharedMutex::unlock(v4);
}

void sub_1B2FF64DC(_Unwind_Exception *a1)
{
  std::mutex *v1;

  PCSharedMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void PSTextureCache::PSTextureCache(PSTextureCache *this)
{
  _QWORD *v2;

  PCSingleton::PCSingleton(this, 0);
  *v2 = &unk_1E65E9070;
  PCSharedMutex::PCSharedMutex((PCSharedMutex *)(v2 + 1));
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 14) = (char *)this + 120;
}

void sub_1B2FF6540(_Unwind_Exception *a1)
{
  PCSingleton *v1;

  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

void PSTextureCache::~PSTextureCache(PSTextureCache *this)
{
  *(_QWORD *)this = &unk_1E65E9070;
  std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy((uint64_t)this + 112, *((_QWORD **)this + 15));
  PCSharedMutex::~PCSharedMutex((std::mutex *)((char *)this + 8));
  PCSingleton::~PCSingleton(this);
}

{
  *(_QWORD *)this = &unk_1E65E9070;
  std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy((uint64_t)this + 112, *((_QWORD **)this + 15));
  PCSharedMutex::~PCSharedMutex((std::mutex *)((char *)this + 8));
  PCSingleton::~PCSingleton(this);
  JUMPOUT(0x1B5E29170);
}

void std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::map<PCHash128,PSTextureCache::CacheEntry>>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy((uint64_t)(a2 + 5), (_QWORD *)a2[6]);
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::destroy(a1, a2[1]);
    std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 8));
    std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 6));
    operator delete(a2);
  }
}

_DWORD *std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>(uint64_t **a1, const PCHash128 *a2, uint64_t a3, _DWORD **a4)
{
  void **v6;
  _DWORD *v7;
  uint64_t **v8;
  _DWORD *v9;
  uint64_t v11;

  v6 = (void **)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::__find_equal<PCHash128>((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x50uLL);
    v9 = *a4;
    v7[8] = **a4;
    v7[9] = v9[1];
    v7[10] = v9[2];
    v7[11] = v9[3];
    *((_OWORD *)v7 + 3) = 0u;
    *((_OWORD *)v7 + 4) = 0u;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PSTextureCache::CacheEntry>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PSTextureCache::CacheEntry>>>::erase(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(a1, a2);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 8));
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 6));
  operator delete(a2);
  return v3;
}

double RetimingMath::reverse(RetimingMath *this, double result, double a3, double a4)
{
  double v5;

  if (result >= a3 && result < a4)
  {
    v5 = floor(result);
    return result - (v5 + v5) + -1.0 + a3 + a4;
  }
  return result;
}

Float64 RetimingMath::figToFrames(RetimingMath *this, const CMTime *a2, const CMTime *a3)
{
  CMTime time;

  operator/((__int128 *)this, (uint64_t)a2, (uint64_t)&time);
  return CMTimeGetSeconds(&time);
}

uint64_t OZChannelShape_Factory::getInstance(OZChannelShape_Factory *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZChannelShape_Factory::_instanceOnce);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZChannelShape_Factory::_instanceOnce, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZChannelShape_Factory::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZChannelShape_Factory::_instance;
}

void OZChannelShape::OZChannelShape(OZChannelShape *this, const PCString *a2, OZChannelFolder *a3, unsigned int a4, int a5)
{
  OZFactory *Instance;

  Instance = (OZFactory *)OZChannelShape_Factory::getInstance(this);
  OZChannelCurve::OZChannelCurve(this, Instance, a2, a3, a4, a5);
  *(_QWORD *)this = &off_1E65E90A8;
  *((_QWORD *)this + 2) = &unk_1E65E9458;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((_QWORD *)this + 107) = 0;
}

void OZChannelShape::OZChannelShape(OZChannelShape *this, OZShape *a2, const PCString *a3, OZChannelFolder *a4, unsigned int a5, int a6)
{
  OZFactory *Instance;

  Instance = (OZFactory *)OZChannelShape_Factory::getInstance(this);
  OZChannelCurve::OZChannelCurve(this, Instance, a3, a4, a5, a6);
  *(_QWORD *)this = &off_1E65E90A8;
  *((_QWORD *)this + 2) = &unk_1E65E9458;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((_QWORD *)this + 107) = a2;
}

void OZChannelShape::OZChannelShape(OZChannelShape *this, const OZChannelShape *a2, OZChannelFolder *a3, OZShape *a4)
{
  uint64_t v5;

  OZChannelCurve::OZChannelCurve(this, a2, a3);
  *(_QWORD *)v5 = &off_1E65E90A8;
  *(_QWORD *)(v5 + 16) = &unk_1E65E9458;
  *(_OWORD *)(v5 + 808) = 0u;
  *(_OWORD *)(v5 + 824) = 0u;
  *(_OWORD *)(v5 + 840) = 0u;
  *(_QWORD *)(v5 + 856) = a4;
}

void OZChannelShape::~OZChannelShape(OZChannel *this)
{
  __CFString *var9;
  OZChannelFolder *var6;

  this->var0 = (void **)&off_1E65E90A8;
  this->var2 = (void **)&unk_1E65E9458;
  var9 = (__CFString *)this[5].var9;
  if (var9)
  {
    this[5].var10 = var9;
    operator delete(var9);
  }
  var6 = this[5].var6;
  if (var6)
  {
    this[5].var7 = (unint64_t)var6;
    operator delete(var6);
  }
  OZChannelCurve::~OZChannelCurve(this);
}

{
  OZChannelShape::~OZChannelShape(this);
  JUMPOUT(0x1B5E29170);
}

void `non-virtual thunk to'OZChannelShape::~OZChannelShape(OZChannelShape *this)
{
  OZChannelShape::~OZChannelShape((OZChannel *)((char *)this - 16));
}

{
  OZChannelShape::~OZChannelShape((OZChannel *)((char *)this - 16));
  JUMPOUT(0x1B5E29170);
}

const __CFString *OZChannelShape::getObjCWrapperName(OZChannelShape *this)
{
  return CFSTR("CHChannelShape");
}

uint64_t OZChannelShape::clone(OZChannelShape *this)
{
  uint64_t v2;

  v2 = operator new();
  OZChannelCurve::OZChannelCurve((OZChannelCurve *)v2, this, 0);
  *(_QWORD *)v2 = &off_1E65E90A8;
  *(_QWORD *)(v2 + 16) = &unk_1E65E9458;
  *(_QWORD *)(v2 + 856) = 0;
  *(_OWORD *)(v2 + 808) = 0u;
  *(_OWORD *)(v2 + 824) = 0u;
  *(_OWORD *)(v2 + 840) = 0u;
  return v2;
}

void sub_1B2FF6AA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

__CFString *OZChannelShape::copy(OZChannel *this, const OZChannelBase *a2, char a3)
{
  __CFString *result;

  OZChannelCurve::copy(this, a2, a3);
  result = this[5].var12;
  if (result)
    return (__CFString *)(*((uint64_t (**)(__CFString *, uint64_t, uint64_t))result->isa + 18))(result, 1, 1);
  return result;
}

__CFString *OZChannelShape::assign(OZChannel *this, const OZChannelBase *a2)
{
  __CFString *result;

  OZChannelCurve::assign(this, a2);
  result = this[5].var12;
  if (result)
    return (__CFString *)(*((uint64_t (**)(__CFString *, uint64_t, uint64_t))result->isa + 18))(result, 1, 1);
  return result;
}

void *OZChannelShape::reset(OZChannelBase *this, uint64_t a2)
{
  void *result;

  OZChannelBase::reset(this, a2);
  result = this[7].var9;
  if (result)
    return (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(_QWORD *)result + 144))(result, 1, 1);
  return result;
}

uint64_t OZChannelShape::refreshAnimation(OZChannelShape *this)
{
  uint64_t result;

  OZChannelCurve::refreshAnimation(this);
  result = *((_QWORD *)this + 107);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 144))(result, 1, 1);
  return result;
}

uint64_t OZChannelShape::didBake(OZChannelShape *this, const PCTimeRange *a2, const CMTime *a3)
{
  OZChannelFolder *v6;
  uint64_t result;
  CMTime v8;
  CMTime v9;
  CMTime v10;
  CMTime time2;
  CMTime time1;

  v9 = *(CMTime *)a2;
  v6 = (OZChannelFolder *)((char *)this + 152);
  if (OZChannelFolder::hasKeypointAt((OZChannelFolder *)((char *)this + 152), &v9, 0))
    (*(void (**)(OZChannelShape *, CMTime *))(*(_QWORD *)this + 728))(this, &v9);
  result = OZChannelFolder::nextKeypoint(v6, &v9, 0);
  if ((_DWORD)result)
  {
    do
    {
      time1 = *(CMTime *)a2;
      time2 = *(CMTime *)((_BYTE *)a2 + 1);
      PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v10);
      time1 = v10;
      time2 = *a3;
      PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v8);
      time1 = v9;
      time2 = v8;
      result = CMTimeCompare(&time1, &time2);
      if ((result & 0x80000000) == 0)
        break;
      if (OZChannelFolder::hasKeypointAt(v6, &v9, 0))
        (*(void (**)(OZChannelShape *, CMTime *))(*(_QWORD *)this + 728))(this, &v9);
      result = OZChannelFolder::nextKeypoint(v6, &v9, 0);
    }
    while ((result & 1) != 0);
  }
  return result;
}

void std::__call_once_param<std::tuple<OZChannelShape_Factory::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelShape_Factory *v0;

  v0 = (OZChannelShape_Factory *)operator new();
  OZChannelShape_Factory::OZChannelShape_Factory(v0);
  OZChannelShape_Factory::_instance = (uint64_t)v0;
}

void sub_1B2FF6D80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40479D0EE9);
  _Unwind_Resume(a1);
}

void OZChannelShape_Factory::OZChannelShape_Factory(OZChannelShape_Factory *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;

  v3 = xmmword_1B3555AA0;
  v4 = xmmword_1B3565650;
  v2 = (_QWORD *)OZFactory::OZFactory((uint64_t)this, &v4, &v3, 1);
  *v2 = &unk_1E64F6DB8;
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 16), 0);
  *(_QWORD *)this = &unk_1E65E94C8;
  *((_QWORD *)this + 16) = &unk_1E65E9598;
}

void sub_1B2FF6E20(_Unwind_Exception *a1)
{
  OZFactory *v1;

  OZFactory::~OZFactory(v1);
  _Unwind_Resume(a1);
}

uint64_t OZChannelShape_Factory::create(OZFactory *this, const PCString *a2, unsigned int a3)
{
  uint64_t v6;

  v6 = operator new();
  OZChannelCurve::OZChannelCurve((OZChannelCurve *)v6, this, a2, a3);
  *(_QWORD *)v6 = &off_1E65E90A8;
  *(_QWORD *)(v6 + 16) = &unk_1E65E9458;
  *(_QWORD *)(v6 + 856) = 0;
  *(_OWORD *)(v6 + 808) = 0u;
  *(_OWORD *)(v6 + 824) = 0u;
  *(_OWORD *)(v6 + 840) = 0u;
  return v6;
}

void sub_1B2FF6EB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

uint64_t OZChannelShape_Factory::createCopy(OZChannelShape_Factory *this, OZFactoryBase *a2)
{
  uint64_t v3;
  const OZChannelCurve *v4;

  v3 = operator new();
  OZChannelCurve::OZChannelCurve((OZChannelCurve *)v3, v4, 0);
  *(_QWORD *)v3 = &off_1E65E90A8;
  *(_QWORD *)(v3 + 16) = &unk_1E65E9458;
  *(_QWORD *)(v3 + 856) = 0;
  *(_OWORD *)(v3 + 808) = 0u;
  *(_OWORD *)(v3 + 824) = 0u;
  *(_OWORD *)(v3 + 840) = 0u;
  return v3;
}

void sub_1B2FF6F6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

uint64_t OZChannelShape_Factory::createChannelCopy(OZChannelShape_Factory *this, OZChannelBase *a2)
{
  uint64_t v3;
  const OZChannelCurve *v4;

  v3 = operator new();
  OZChannelCurve::OZChannelCurve((OZChannelCurve *)v3, v4, 0);
  *(_QWORD *)v3 = &off_1E65E90A8;
  *(_QWORD *)(v3 + 16) = &unk_1E65E9458;
  *(_QWORD *)(v3 + 856) = 0;
  *(_OWORD *)(v3 + 808) = 0u;
  *(_OWORD *)(v3 + 824) = 0u;
  *(_OWORD *)(v3 + 840) = 0u;
  return v3;
}

void sub_1B2FF7020(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

void OZShape::OZShape(OZShape *this, OZChannelFolder *a2)
{
  PCString *v4;
  PCString *v5;
  OZShape::OZShape_interpolationModeImpl *v6;
  OZChannelImpl *Instance;
  PCString *v8;
  OZShape::OZShape_closedImpl *v9;
  OZChannelImpl *v10;
  PCString *v11;
  OZShape::OZShape_roundnessImpl *v12;
  OZShape::OZShape_roundnessInfo *v13;
  OZChannelInfo *v14;
  PCString *v15;
  PCString *v16;
  OZShape::OZShape_initialPositionImpl *v17;
  OZChannelImpl *v18;
  PCString *v19;
  OZShape::OZShape_pixelAspectRatioImpl *v20;
  OZChannelImpl *v21;
  PCString *v22;
  PCString *v23;
  PCString *v24;
  PCString *v25;
  PCString *v26;
  PCString *v27;
  PCString *v28;
  PCString *v29;
  PCString *v30;
  PCString *v31;
  OZShape::OZShape_strokeWidthImpl *v32;
  OZShape::OZShape_strokeWidthInfo *v33;
  OZChannelInfo *v34;
  PCString *v35;
  PCString *v36;
  OZShape::OZShape_strokeJointImpl *v37;
  OZChannelImpl *v38;
  PCString *v39;
  OZShape::OZShape_strokeLeftCapImpl *v40;
  OZChannelImpl *v41;
  PCString *v42;
  OZShape::OZShape_strokeRightCapImpl *v43;
  OZChannelImpl *v44;
  PCString *v45;
  OZShape::OZShape_strokeCapArrowLengthImpl *v46;
  OZShape::OZShape_strokeCapArrowLengthInfo *v47;
  OZChannelInfo *v48;
  PCString *v49;
  OZShape::OZShape_strokeCapArrowWidthImpl *v50;
  OZShape::OZShape_strokeCapArrowWidthInfo *v51;
  OZChannelInfo *v52;
  PCString *v53;
  PCString *v54;
  PCString *v55;
  PCString *v56;
  PCString *v57;
  PCString *v58;
  PCString *v59;
  PCString *v60;
  PCString *v61;
  PCString *v62;
  OZShape::OZShape_softEdgeRadiusImpl *v63;
  OZShape::OZShape_softEdgeRadiusInfo *v64;
  OZChannelInfo *v65;
  PCString *v66;
  OZShape::OZShape_softEdgeFalloffImpl *v67;
  OZShape::OZShape_softEdgeFalloffInfo *v68;
  OZChannelInfo *v69;
  PCString *v70;
  OZShape::OZShape_softEdgeKernelImpl *v71;
  OZChannelImpl *v72;
  PCString *v73;
  OZShape::OZShape_ellipseCurvatureImpl *v74;
  OZChannelImpl *v75;
  PCString *v76;
  OZShape::OZShape_shapeRadiusImpl *v77;
  OZShape::OZShape_shapeRadiusInfo *v78;
  OZChannelInfo *v79;
  PCString *v80;
  PCString *v81;
  PCString *v82;
  PCString *v83;
  PCString *v84;
  OZShape::OZShape_initialScaleXImpl *v85;
  OZChannelImpl *v86;
  PCString *v87;
  OZShape::OZShape_initialScaleYImpl *v88;
  OZChannelImpl *v89;
  PCString *v90;
  PCString *v91;
  PCString *v92;
  PCString *v93;
  PCString *v94;
  PCString *v95;
  OZShape::OZShape_disableAntialiasingiOSImpl *v96;
  OZChannelImpl *v97;
  PCString *v98;
  OZShape::OZShape_fixedFeatherWidthImpl *v99;
  OZChannelImpl *v100;
  PCString *v101;
  OZShape::OZShape_boxTopLeftImpl *v102;
  OZChannelImpl *v103;
  PCString *v104;
  OZShape::OZShape_boxTopRightImpl *v105;
  OZChannelImpl *v106;
  PCString *v107;
  OZShape::OZShape_boxBottomLeftImpl *v108;
  OZChannelImpl *v109;
  PCString *v110;
  OZShape::OZShape_boxBottomRightImpl *v111;
  OZChannelImpl *v112;
  PCString *v113;
  OZShape::OZShape_boxRotationImpl *v114;
  OZChannelImpl *v115;
  PCString *v116;
  OZShape::OZShape_boxPivotImpl *v117;
  OZChannelImpl *v118;
  OZShapeRenderParams *v119;
  OZShapeRenderParams *v120;
  PCString *v121;
  PCString *v122;
  uint64_t v123;
  PCString v124;
  PCString v125[2];
  int v126;
  uint64_t v127;

  v127 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E65E95F0;
  PCMutex::PCMutex((PCMutex *)((char *)this + 8), 1);
  *((_QWORD *)this + 1) = &unk_1E64E2000;
  PCString::PCString(v125, "Shape Root", "com.apple.proshapes.framework");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 80), v125, a2, 0x9Bu, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v4, "Shape Animation", "com.apple.proshapes.framework");
  OZChannelShape::OZChannelShape((OZShape *)((char *)this + 208), this, v125, (OZChannelFolder *)((char *)this + 80), 0x75u, 0);
  PCString::~PCString(v125);
  PCString::PCString(v5, "Shape Interpolation Mode Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Interpolation Mode", "com.apple.proshapes.framework");
  Instance = (OZChannelImpl *)OZShape::OZShape_interpolationModeImpl::getInstance(v6);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 1072), 1u, v125, &v124, (OZChannelFolder *)((char *)this + 80), 0x64u, 16, Instance, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v8, "Shape Closed", "com.apple.proshapes.framework");
  v10 = (OZChannelImpl *)OZShape::OZShape_closedImpl::getInstance(v9);
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1328), 0, v125, (OZChannelFolder *)((char *)this + 80), 0x74u, 0x10000u, v10, 0);
  PCString::~PCString(v125);
  PCString::PCString(v11, "Shape Roundness", "com.apple.proshapes.framework");
  v13 = (OZShape::OZShape_roundnessInfo *)OZShape::OZShape_roundnessImpl::getInstance(v12);
  v14 = (OZChannelInfo *)OZShape::OZShape_roundnessInfo::getInstance(v13);
  OZChannelUint32::OZChannelUint32((OZChannelUint32 *)((char *)this + 1480), 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x90u, 0, (OZChannelImpl *)v13, v14);
  PCString::~PCString(v125);
  PCString::PCString(v15, "Shape Preserve Scale", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1632), 1, v125, (OZChannelFolder *)((char *)this + 80), 0x98u, 0, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v16, "Shape Initial Position", "com.apple.proshapes.framework");
  v18 = (OZChannelImpl *)OZShape::OZShape_initialPositionImpl::getInstance(v17);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 1784), 0.0, 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x81u, 2u, 2u, v18, 0);
  PCString::~PCString(v125);
  PCString::PCString(v19, "Shape Pixel Aspect Ratio", "com.apple.proshapes.framework");
  v21 = (OZChannelImpl *)OZShape::OZShape_pixelAspectRatioImpl::getInstance(v20);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 2488), 1.0, v125, (OZChannelFolder *)((char *)this + 80), 0x99u, 2, v21, 0);
  PCString::~PCString(v125);
  *(_OWORD *)((char *)this + 2648) = 0u;
  *((_QWORD *)this + 335) = (char *)this + 2680;
  *((_QWORD *)this + 336) = (char *)this + 2680;
  *((_QWORD *)this + 337) = 0;
  *((_QWORD *)this + 338) = (char *)this + 2704;
  *((_QWORD *)this + 339) = (char *)this + 2704;
  *((_QWORD *)this + 340) = 0;
  *((_QWORD *)this + 341) = (char *)this + 2728;
  *((_QWORD *)this + 342) = (char *)this + 2728;
  *((_QWORD *)this + 343) = 0;
  *((_QWORD *)this + 345) = 0;
  *((_OWORD *)this + 173) = 0u;
  PCString::PCString(v22, "Shape Filled Shape", "com.apple.proshapes.framework");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 2784), v125, (OZChannelFolder *)((char *)this + 80), 0x71u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v23, "Shape Fill Mode Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Fill Mode", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 2912), 0, v125, &v124, (OZChannelFolder *)((char *)this + 2784), 0x72u, 0, 0, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v24, "Shape Fill Color", "com.apple.proshapes.framework");
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((OZShape *)((char *)this + 3168), 1.0, 1.0, 1.0, v125, (OZChannelFolder *)((char *)this + 2784), 0x6Fu, 0, 5u);
  PCString::~PCString(v125);
  PCString::PCString(v25, "Shape Fill Opacity", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 4176), 1.0, v125, (OZChannelFolder *)((char *)this + 2784), 0x8Du, 0, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v26, "Shape Gradient", "com.apple.proshapes.framework");
  OZChannelGradientPositioned::OZChannelGradientPositioned((OZShape *)((char *)this + 4328), v125, (OZChannelFolder *)((char *)this + 2784), 0x68u, 2u);
  PCString::~PCString(v125);
  PCString::PCString(v27, "Shape Stroked Shape", "com.apple.proshapes.framework");
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 6800), v125, (OZChannelFolder *)((char *)this + 80), 0x6Cu, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v28, "Shape Stroke Mode Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Stroke Mode", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 6928), 0, v125, &v124, (OZChannelFolder *)((char *)this + 6800), 0x8Bu, 0, 0, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v29, "Shape Stroke Color", "com.apple.proshapes.framework");
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((OZShape *)((char *)this + 7184), 1.0, 1.0, 1.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x6Bu, 0, 5u);
  PCString::~PCString(v125);
  PCString::PCString(v30, "Shape Stroke Opacity", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 0x2000), 1.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x8Eu, 0, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v31, "Shape Stroke Width", "com.apple.proshapes.framework");
  v33 = (OZShape::OZShape_strokeWidthInfo *)OZShape::OZShape_strokeWidthImpl::getInstance(v32);
  v34 = (OZChannelInfo *)OZShape::OZShape_strokeWidthInfo::getInstance(v33);
  OZChannelUint32::OZChannelUint32((OZChannelUint32 *)((char *)this + 8344), 2.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x69u, 0, (OZChannelImpl *)v33, v34);
  PCString::~PCString(v125);
  PCString::PCString(v35, "Shape Transform Stroke", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 8496), 0, v125, (OZChannelFolder *)((char *)this + 6800), 0x7Bu, 0, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v36, "Shape Stroke Joint Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Stroke Joint", "com.apple.proshapes.framework");
  v38 = (OZChannelImpl *)OZShape::OZShape_strokeJointImpl::getInstance(v37);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 8648), 1u, v125, &v124, (OZChannelFolder *)((char *)this + 6800), 0x70u, 0, v38, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v39, "Shape Stroke Cap Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Stroke Left Cap", "com.apple.proshapes.framework");
  v41 = (OZChannelImpl *)OZShape::OZShape_strokeLeftCapImpl::getInstance(v40);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 8904), 1u, v125, &v124, (OZChannelFolder *)((char *)this + 6800), 0x77u, 0, v41, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v42, "Shape Stroke Cap Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Stroke Right Cap", "com.apple.proshapes.framework");
  v44 = (OZChannelImpl *)OZShape::OZShape_strokeRightCapImpl::getInstance(v43);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 9160), 1u, v125, &v124, (OZChannelFolder *)((char *)this + 6800), 0x86u, 0, v44, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v45, "Shape Stroke Arrow Length", "com.apple.proshapes.framework");
  v47 = (OZShape::OZShape_strokeCapArrowLengthInfo *)OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(v46);
  v48 = (OZChannelInfo *)OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(v47);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 9416), 3.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x84u, 0, (OZChannelImpl *)v47, v48);
  PCString::~PCString(v125);
  PCString::PCString(v49, "Shape Stroke Arrow Width", "com.apple.proshapes.framework");
  v51 = (OZShape::OZShape_strokeCapArrowWidthInfo *)OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(v50);
  v52 = (OZChannelInfo *)OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(v51);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 9568), 3.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x85u, 0, (OZChannelImpl *)v51, v52);
  PCString::~PCString(v125);
  PCString::PCString(v53, "Shape Type Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Type", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 9720), v125, &v124, (OZChannelFolder *)((char *)this + 6800), 0x6Au, 0, 0, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v54, "Shape Stroke In", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 9976), 0.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x7Eu, 0, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v55, "Shape Stroke Out", "com.apple.proshapes.framework");
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 10128), 1.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x7Fu, 0, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v56, "Hidden Stroke Completion");
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 10280), 1.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x87u, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v57, "Shape Stroke Natural", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 10440), 0, v125, (OZChannelFolder *)((char *)this + 6800), 0x80u, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v58, "Shape Stroke Offset", "com.apple.proshapes.framework");
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 10592), 0.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x83u, 2, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v59, "Shape Pressure Over Stroke", "com.apple.proshapes.framework");
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 10744), 1.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x88u, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v60, "Shape Tilt Over Stroke", "com.apple.proshapes.framework");
  OZChannel2DOverRange::OZChannel2DOverRange((OZShape *)((char *)this + 10904), 0.0, 0.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x89u, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v61, "Shape Pen Speed Over Stroke", "com.apple.proshapes.framework");
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 11352), 1.0, v125, (OZChannelFolder *)((char *)this + 6800), 0x8Au, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v62, "Shape Soft Edge Radius", "com.apple.proshapes.framework");
  v64 = (OZShape::OZShape_softEdgeRadiusInfo *)OZShape::OZShape_softEdgeRadiusImpl::getInstance(v63);
  v65 = (OZChannelInfo *)OZShape::OZShape_softEdgeRadiusInfo::getInstance(v64);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 11512), 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x66u, 0, (OZChannelImpl *)v64, v65);
  PCString::~PCString(v125);
  PCString::PCString(v66, "Shape Soft Edge Falloff", "com.apple.proshapes.framework");
  v68 = (OZShape::OZShape_softEdgeFalloffInfo *)OZShape::OZShape_softEdgeFalloffImpl::getInstance(v67);
  v69 = (OZChannelInfo *)OZShape::OZShape_softEdgeFalloffInfo::getInstance(v68);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 11664), 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x9Eu, 0, (OZChannelImpl *)v68, v69);
  PCString::~PCString(v125);
  PCString::PCString(v70, "Shape Soft Edge Kernel Parameter", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Soft Edge Kernel", "com.apple.proshapes.framework");
  v72 = (OZChannelImpl *)OZShape::OZShape_softEdgeKernelImpl::getInstance(v71);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 11816), 3u, v125, &v124, (OZChannelFolder *)((char *)this + 80), 0xA2u, 2, v72, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v73, "Shape Ellipse Curvature", "com.apple.proshapes.framework");
  v75 = (OZChannelImpl *)OZShape::OZShape_ellipseCurvatureImpl::getInstance(v74);
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 12072), 0.35, v125, (OZChannelFolder *)((char *)this + 80), 0x9Fu, 2u, v75, 0);
  PCString::~PCString(v125);
  PCString::PCString(v76, "Shape Ellipse Radius", "com.apple.proshapes.framework");
  v78 = (OZShape::OZShape_shapeRadiusInfo *)OZShape::OZShape_shapeRadiusImpl::getInstance(v77);
  v79 = (OZChannelInfo *)OZShape::OZShape_shapeRadiusInfo::getInstance(v78);
  OZChannel2D::OZChannel2D((OZShape *)((char *)this + 12224), 400.0, 250.0, v125, (OZChannelFolder *)((char *)this + 80), 0xA0u, 2u, 2u, (OZChannelImpl *)v78, v79);
  PCString::~PCString(v125);
  PCString::PCString(v80, "Shape Convert To Bezier", "com.apple.proshapes.framework");
  OZChannelButton::OZChannelButton((OZChannelButton *)((char *)this + 12664), v125, (OZChannelFolder *)((char *)this + 80), 0xA1u, 0xAu);
  PCString::~PCString(v125);
  PCString::PCString(v81, "Shape Is Mask", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 12856), 0, v125, (OZChannelFolder *)((char *)this + 80), 0x9Au, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v82, "Shape Mask Blend Mode Enum", "com.apple.proshapes.framework");
  PCString::PCString(&v124, "Shape Blending Mode", "com.apple.proshapes.framework");
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 13008), 0, v125, &v124, (OZChannelFolder *)((char *)this + 80), 0x67u, 18, 0, 0);
  PCString::~PCString(&v124);
  PCString::~PCString(v125);
  PCString::PCString(v83, "Shape Invert Mask", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13264), 0, v125, (OZChannelFolder *)((char *)this + 80), 0x73u, 0x12u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v84, "Shape Initial Scale X", "com.apple.proshapes.framework");
  v86 = (OZChannelImpl *)OZShape::OZShape_initialScaleXImpl::getInstance(v85);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 13416), 1.0, v125, (OZChannelFolder *)((char *)this + 80), 0x78u, 2, v86, 0);
  PCString::~PCString(v125);
  PCString::PCString(v87, "Shape Initial Scale Y", "com.apple.proshapes.framework");
  v89 = (OZChannelImpl *)OZShape::OZShape_initialScaleYImpl::getInstance(v88);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 13568), 1.0, v125, (OZChannelFolder *)((char *)this + 80), 0x79u, 2, v89, 0);
  PCString::~PCString(v125);
  PCString::PCString(v90, "Shape Use OldBSpline Model", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13720), 0, v125, (OZChannelFolder *)((char *)this + 80), 0x82u, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v91, "Shape Use Old Antialiasing Method", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13872), 0, v125, (OZChannelFolder *)((char *)this + 80), 0x91u, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v92, "Shape Mask Color", "com.apple.proshapes.framework");
  OZChannelDiscreteColor::OZChannelDiscreteColor((OZShape *)((char *)this + 14024), 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x8Fu, 0x12u);
  PCString::~PCString(v125);
  PCString::PCString(v93, "Shape Drawing Completed", "com.apple.proshapes.framework");
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14280), 0, v125, (OZChannelFolder *)((char *)this + 80), 0x9Du, 2u, 0, 0);
  PCString::~PCString(v125);
  PCString::PCString(v94, "Shape Identifier String", "com.apple.proshapes.framework");
  OZChannelText::OZChannelText((OZChannelText *)((char *)this + 14432), v125, (OZChannelFolder *)((char *)this + 80), 0xA3u, 0x1000Au);
  PCString::~PCString(v125);
  PCString::PCString(v95, "Shape Disable Antialiasing iOS", "com.apple.proshapes.framework");
  v97 = (OZChannelImpl *)OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(v96);
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14600), 0, v125, (OZChannelFolder *)((char *)this + 80), 0xA4u, 2u, v97, 0);
  PCString::~PCString(v125);
  PCString::PCString(v98, "Shape Fixed Feather Width", "com.apple.proshapes.framework");
  v100 = (OZChannelImpl *)OZShape::OZShape_fixedFeatherWidthImpl::getInstance(v99);
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14752), 0, v125, (OZChannelFolder *)((char *)this + 80), 0xA5u, 0x10000u, v100, 0);
  PCString::~PCString(v125);
  PCString::PCString(v101, "Shape Box Transform Top Left", "com.apple.proshapes.framework");
  v103 = (OZChannelImpl *)OZShape::OZShape_boxTopLeftImpl::getInstance(v102);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 14904), 0.0, 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x92u, 0x1000Au, 2u, v103, 0);
  PCString::~PCString(v125);
  PCString::PCString(v104, "Shape Box Transform Top Right", "com.apple.proshapes.framework");
  v106 = (OZChannelImpl *)OZShape::OZShape_boxTopRightImpl::getInstance(v105);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 15608), 0.0, 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x93u, 0x1000Au, 2u, v106, 0);
  PCString::~PCString(v125);
  PCString::PCString(v107, "Shape Box Transform Bottom Left", "com.apple.proshapes.framework");
  v109 = (OZChannelImpl *)OZShape::OZShape_boxBottomLeftImpl::getInstance(v108);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 16312), 0.0, 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x94u, 0x1000Au, 2u, v109, 0);
  PCString::~PCString(v125);
  PCString::PCString(v110, "Shape Box Transform Bottom Right", "com.apple.proshapes.framework");
  v112 = (OZChannelImpl *)OZShape::OZShape_boxBottomRightImpl::getInstance(v111);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 17016), 0.0, 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x95u, 0x1000Au, 2u, v112, 0);
  PCString::~PCString(v125);
  PCString::PCString(v113, "Shape Box Transform Rotation", "com.apple.proshapes.framework");
  v115 = (OZChannelImpl *)OZShape::OZShape_boxRotationImpl::getInstance(v114);
  OZChannelDouble::OZChannelDouble((OZShape *)((char *)this + 17720), 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x96u, 65546, v115, 0);
  PCString::~PCString(v125);
  PCString::PCString(v116, "Shape Box Transform Pivot", "com.apple.proshapes.framework");
  v118 = (OZChannelImpl *)OZShape::OZShape_boxPivotImpl::getInstance(v117);
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 17872), 0.0, 0.0, v125, (OZChannelFolder *)((char *)this + 80), 0x97u, 0x1000Au, 2u, v118, 0);
  PCString::~PCString(v125);
  *((_QWORD *)this + 2330) = 0;
  *((_OWORD *)this + 1164) = 0u;
  *((_BYTE *)this + 2640) = 0;
  *((_DWORD *)this + 661) = 2;
  OZChannelBase::enable((OZChannelBase *)((char *)this + 6800), 0, 0);
  OZChannelFolder::setFoldFlag((OZChannelFolder *)((char *)this + 6800), 0x20000);
  v126 = 3;
  *(_OWORD *)&v125[0].var0 = xmmword_1B35656A4;
  OZChannelEnum::setTags((OZShape *)((char *)this + 8904), (char *)v125, 5);
  OZChannelEnum::setTags((OZShape *)((char *)this + 9160), (char *)v125, 5);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 2784), 1, 0);
  OZChannelFolder::setFoldFlag((OZChannelFolder *)((char *)this + 2784), 0x20000);
  *((_QWORD *)this + 2340) = 0;
  v119 = (OZShapeRenderParams *)operator new();
  OZShapeRenderParams::OZShapeRenderParams(v119);
  *((_QWORD *)this + 333) = v119;
  v120 = (OZShapeRenderParams *)operator new();
  OZShapeRenderParams::OZShapeRenderParams(v120);
  *((_QWORD *)this + 334) = v120;
  PCString::PCString(&v124, "Shape Stroke Range", "com.apple.proshapes.framework");
  PCString::set((PCString *)this + 1362, &v124);
  PCString::~PCString(&v124);
  PCString::PCString(v121, "Shape Stroke Range", "com.apple.proshapes.framework");
  PCString::set((PCString *)this + 1418, &v124);
  PCString::~PCString(&v124);
  PCString::PCString(v122, "Shape Stroke Range", "com.apple.proshapes.framework");
  PCString::set((PCString *)this + 1438, &v124);
  PCString::~PCString(&v124);
  OZChannel::setKeyframable((OZChannel *)((char *)this + 10744), 1);
  OZChannelFolder::setKeyframable((OZChannelFolder *)((char *)this + 10904), 1, 0);
  OZChannel::setKeyframable((OZChannel *)((char *)this + 11352), 1);
  OZChannel::setKeyframable((OZChannel *)((char *)this + 14024), 0);
  OZChannel::removeAllValues((OZChannel *)((char *)this + 10280), MEMORY[0x1E0CA2E68], 1);
  v123 = MEMORY[0x1E0CA2E28];
  *((_OWORD *)this + 1161) = *MEMORY[0x1E0CA2E28];
  *((_QWORD *)this + 2324) = *(_QWORD *)(v123 + 16);
  OZChannelFolder::setFoldFlag((OZChannelFolder *)((char *)this + 12224), 0x800000);
  PCString::PCString(&v124, "Shape Convert To Bezier Button", "com.apple.proshapes.framework");
  PCString::set((PCString *)this + 1605, &v124);
  PCString::~PCString(&v124);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12664), 0x3000000000, 1);
  OZChannel::setKeyframable((OZChannel *)((char *)this + 12664), 0);
  *((_QWORD *)this + 344) = 0;
}

void sub_1B2FF8538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, OZChannelPosition *a11, OZChannelBool *a12, OZChannelBool *a13, OZChannelText *a14, OZChannelBool *a15, OZChannelBool *a16, OZChannelBool *a17, OZChannel *a18, OZChannel *a19, OZChannelBool *a20,OZChannelEnum *a21,OZChannelBool *a22,OZChannelPercent *a23,OZChannelEnum *a24,OZChannel *a25,OZChannel *a26,OZChannel *a27,OZChannelBool *a28,OZChannelPercent *a29,OZChannelPercent *a30,OZChannelEnum *a31,OZChannel *a32,OZChannel *a33,OZChannelShape *a34,PCMutex *a35,OZChannelEnum *a36,OZChannelBool *a37,OZChannel *a38,OZChannelPercent *a39,OZChannelColorNoAlpha *a40,OZChannelEnum *a41,OZChannelGradientPositioned *a42,OZChannelPercent *a43,OZChannelColorNoAlpha *a44,OZChannelEnum *a45,_QWORD *a46,_QWORD *a47,_QWORD *a48)
{
  PCString *v48;
  OZChannelFolder *v49;
  OZChannelPosition *v50;
  _QWORD *v51;
  OZChannelPosition *v52;
  OZChannelFolder *v53;
  OZChannel *v54;
  OZChannelPosition *v55;
  OZChannelPosition *v56;
  uint64_t v57;
  void *v58;
  void *v59;

  PCString::~PCString((PCString *)(v57 - 136));
  v58 = (void *)v51[2328];
  if (v58)
  {
    v51[2329] = v58;
    operator delete(v58);
  }
  OZChannelPosition::~OZChannelPosition(v55);
  OZChannel::~OZChannel(v54);
  OZChannelPosition::~OZChannelPosition(v52);
  OZChannelPosition::~OZChannelPosition(v56);
  OZChannelPosition::~OZChannelPosition(v50);
  OZChannelPosition::~OZChannelPosition(a11);
  OZChannelBool::~OZChannelBool(a12);
  OZChannelBool::~OZChannelBool(a13);
  OZChannelText::~OZChannelText(a14);
  OZChannelBool::~OZChannelBool(a15);
  OZChannelEnum::~OZChannelEnum(v48);
  OZChannelBool::~OZChannelBool(a16);
  OZChannelBool::~OZChannelBool(a17);
  OZChannel::~OZChannel(a18);
  OZChannel::~OZChannel(a19);
  OZChannelBool::~OZChannelBool(a20);
  OZChannelEnum::~OZChannelEnum(a21);
  OZChannelBool::~OZChannelBool(a22);
  OZChannelButton::~OZChannelButton(*(OZChannelButton **)(v57 - 152));
  OZChannel2D::~OZChannel2D(*(OZChannel2D **)(v57 - 208));
  OZChannelPercent::~OZChannelPercent(a23);
  OZChannelEnum::~OZChannelEnum(a24);
  OZChannel::~OZChannel(a25);
  OZChannel::~OZChannel(a26);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(*(PCString **)(v57 - 200));
  OZChannel2DOverRange::~OZChannel2DOverRange(*(PCString **)(v57 - 192));
  OZChannelPercentOverRange::~OZChannelPercentOverRange(*(PCString **)(v57 - 184));
  OZChannel::~OZChannel(a27);
  OZChannelBool::~OZChannelBool(a28);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(*(PCString **)(v57 - 176));
  OZChannelPercent::~OZChannelPercent(a29);
  OZChannelPercent::~OZChannelPercent(a30);
  OZChannelEnum::~OZChannelEnum(a31);
  OZChannel::~OZChannel(a32);
  OZChannel::~OZChannel(a33);
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v57 - 168));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v57 - 160));
  OZChannelEnum::~OZChannelEnum(a36);
  OZChannelBool::~OZChannelBool(a37);
  OZChannel::~OZChannel(a38);
  OZChannelPercent::~OZChannelPercent(a39);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a40);
  OZChannelEnum::~OZChannelEnum(a41);
  OZChannelFolder::~OZChannelFolder(v53);
  OZChannelGradientPositioned::~OZChannelGradientPositioned(a42);
  OZChannelPercent::~OZChannelPercent(a43);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a44);
  OZChannelEnum::~OZChannelEnum(a45);
  OZChannelFolder::~OZChannelFolder(*(OZChannelFolder **)(v57 - 144));
  v59 = (void *)v51[345];
  if (v59)
  {
    v51[346] = v59;
    operator delete(v59);
  }
  std::__list_imp<unsigned int>::clear(a46);
  std::__list_imp<unsigned int>::clear(a47);
  std::__list_imp<unsigned int>::clear(a48);
  OZChannel::~OZChannel(*(OZChannel **)(v57 - 256));
  OZChannelPosition::~OZChannelPosition(*(OZChannelPosition **)(v57 - 248));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v57 - 240));
  OZChannel::~OZChannel(*(OZChannel **)(v57 - 232));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v57 - 224));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v57 - 216));
  OZChannelShape::~OZChannelShape(a34);
  OZChannelFolder::~OZChannelFolder(v49);
  PCMutex::~PCMutex(a35);
  _Unwind_Resume(a1);
}

void OZShape::OZShape(OZShape *this, const OZShape *a2, OZChannelFolder *a3)
{
  __int128 v6;
  OZShapeRenderParams *v7;
  OZShapeRenderParams *v8;
  PCString *v9;
  PCString *v10;
  PCMutex *v11;
  PCString v12;
  PCMutex *v13;
  char v14;

  *(_QWORD *)this = &off_1E65E95F0;
  v11 = (PCMutex *)((char *)this + 8);
  PCMutex::PCMutex((PCMutex *)((char *)this + 8), 1);
  *((_QWORD *)this + 1) = &unk_1E64E2000;
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 80), (const OZChannelFolder *)((char *)a2 + 80), a3);
  OZChannelShape::OZChannelShape((OZShape *)((char *)this + 208), (const OZShape *)((char *)a2 + 208), (OZChannelFolder *)((char *)this + 80), this);
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 1072), (const OZShape *)((char *)a2 + 1072), (OZChannelFolder *)((char *)this + 80));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1328), (const OZChannelBase *)((char *)a2 + 1328), (OZChannelFolder *)((char *)this + 80));
  OZChannel::OZChannel((OZChannel *)((char *)this + 1480), (const OZChannelBase *)((char *)a2 + 1480), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 185) = &off_1E6551AF8;
  *((_QWORD *)this + 187) = &unk_1E6551E58;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 1632), (const OZChannelBase *)((char *)a2 + 1632), (OZChannelFolder *)((char *)this + 80));
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 1784), (const OZShape *)((char *)a2 + 1784), (OZChannelFolder *)((char *)this + 80));
  OZChannel::OZChannel((OZChannel *)((char *)this + 2488), (const OZChannelBase *)((char *)a2 + 2488), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 311) = &off_1E6551358;
  *((_QWORD *)this + 313) = &unk_1E65516B8;
  *(_OWORD *)((char *)this + 2648) = 0u;
  *((_QWORD *)this + 335) = (char *)this + 2680;
  *((_QWORD *)this + 336) = (char *)this + 2680;
  *((_QWORD *)this + 337) = 0;
  *((_QWORD *)this + 338) = (char *)this + 2704;
  *((_QWORD *)this + 339) = (char *)this + 2704;
  *((_QWORD *)this + 340) = 0;
  *((_QWORD *)this + 341) = (char *)this + 2728;
  *((_QWORD *)this + 342) = (char *)this + 2728;
  *((_QWORD *)this + 343) = 0;
  *((_QWORD *)this + 345) = 0;
  *((_QWORD *)this + 347) = 0;
  *((_QWORD *)this + 346) = 0;
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 2784), (const OZChannelFolder *)((char *)a2 + 2784), (OZChannelFolder *)((char *)this + 80));
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 2912), (const OZShape *)((char *)a2 + 2912), (OZChannelFolder *)((char *)this + 2784));
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((OZShape *)((char *)this + 3168), (const OZShape *)((char *)a2 + 3168), (OZChannelFolder *)((char *)this + 2784));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 4176), (const OZChannelBase *)((char *)a2 + 4176), (OZChannelFolder *)((char *)this + 2784));
  OZChannelGradientPositioned::OZChannelGradientPositioned((OZShape *)((char *)this + 4328), (const OZShape *)((char *)a2 + 4328), (OZChannelFolder *)((char *)this + 2784));
  OZChannelFolder::OZChannelFolder((OZChannelFolder *)((char *)this + 6800), (const OZChannelFolder *)((char *)a2 + 6800), (OZChannelFolder *)((char *)this + 80));
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 6928), (const OZShape *)((char *)a2 + 6928), (OZChannelFolder *)((char *)this + 6800));
  OZChannelColorNoAlpha::OZChannelColorNoAlpha((OZShape *)((char *)this + 7184), (const OZShape *)((char *)a2 + 7184), (OZChannelFolder *)((char *)this + 6800));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 0x2000), (const OZChannelBase *)((char *)a2 + 0x2000), (OZChannelFolder *)((char *)this + 6800));
  OZChannel::OZChannel((OZChannel *)((char *)this + 8344), (const OZChannelBase *)((char *)a2 + 8344), (OZChannelFolder *)((char *)this + 6800));
  *((_QWORD *)this + 1043) = &off_1E6551AF8;
  *((_QWORD *)this + 1045) = &unk_1E6551E58;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 8496), (const OZChannelBase *)((char *)a2 + 8496), (OZChannelFolder *)((char *)this + 6800));
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 8648), (const OZShape *)((char *)a2 + 8648), (OZChannelFolder *)((char *)this + 6800));
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 8904), (const OZShape *)((char *)a2 + 8904), (OZChannelFolder *)((char *)this + 6800));
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 9160), (const OZShape *)((char *)a2 + 9160), (OZChannelFolder *)((char *)this + 6800));
  OZChannel::OZChannel((OZChannel *)((char *)this + 9416), (const OZChannelBase *)((char *)a2 + 9416), (OZChannelFolder *)((char *)this + 6800));
  *((_QWORD *)this + 1177) = &off_1E6551358;
  *((_QWORD *)this + 1179) = &unk_1E65516B8;
  OZChannel::OZChannel((OZChannel *)((char *)this + 9568), (const OZChannelBase *)((char *)a2 + 9568), (OZChannelFolder *)((char *)this + 6800));
  *((_QWORD *)this + 1196) = &off_1E6551358;
  *((_QWORD *)this + 1198) = &unk_1E65516B8;
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 9720), (const OZShape *)((char *)a2 + 9720), (OZChannelFolder *)((char *)this + 6800));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 9976), (const OZChannelBase *)((char *)a2 + 9976), (OZChannelFolder *)((char *)this + 6800));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 10128), (const OZChannelBase *)((char *)a2 + 10128), (OZChannelFolder *)((char *)this + 6800));
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 10280), (const OZShape *)((char *)a2 + 10280), (OZChannelFolder *)((char *)this + 6800));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 10440), (const OZChannelBase *)((char *)a2 + 10440), (OZChannelFolder *)((char *)this + 6800));
  OZChannel::OZChannel((OZChannel *)((char *)this + 10592), (const OZChannelBase *)((char *)a2 + 10592), (OZChannelFolder *)((char *)this + 6800));
  *((_QWORD *)this + 1324) = &off_1E6551358;
  *((_QWORD *)this + 1326) = &unk_1E65516B8;
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 10744), (const OZShape *)((char *)a2 + 10744), (OZChannelFolder *)((char *)this + 6800));
  OZChannel2DOverRange::OZChannel2DOverRange((OZShape *)((char *)this + 10904), (const OZShape *)((char *)a2 + 10904), (OZChannelFolder *)((char *)this + 6800));
  OZChannelPercentOverRange::OZChannelPercentOverRange((OZShape *)((char *)this + 11352), (const OZShape *)((char *)a2 + 11352), (OZChannelFolder *)((char *)this + 6800));
  OZChannel::OZChannel((OZChannel *)((char *)this + 11512), (const OZChannelBase *)((char *)a2 + 11512), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 1439) = &off_1E6551358;
  *((_QWORD *)this + 1441) = &unk_1E65516B8;
  OZChannel::OZChannel((OZChannel *)((char *)this + 11664), (const OZChannelBase *)((char *)a2 + 11664), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 1458) = &off_1E6551358;
  *((_QWORD *)this + 1460) = &unk_1E65516B8;
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 11816), (const OZShape *)((char *)a2 + 11816), (OZChannelFolder *)((char *)this + 80));
  OZChannelPercent::OZChannelPercent((OZChannelPercent *)((char *)this + 12072), (const OZChannelBase *)((char *)a2 + 12072), (OZChannelFolder *)((char *)this + 80));
  OZChannel2D::OZChannel2D((OZShape *)((char *)this + 12224), (const OZShape *)((char *)a2 + 12224), (OZChannelFolder *)((char *)this + 80));
  OZChannelButton::OZChannelButton((OZChannelButton *)((char *)this + 12664), (const OZChannelButton *)((char *)a2 + 12664), (OZChannelFolder *)((char *)this + 80));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 12856), (const OZChannelBase *)((char *)a2 + 12856), (OZChannelFolder *)((char *)this + 80));
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 13008), (const OZShape *)((char *)a2 + 13008), (OZChannelFolder *)((char *)this + 80));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13264), (const OZChannelBase *)((char *)a2 + 13264), (OZChannelFolder *)((char *)this + 80));
  OZChannel::OZChannel((OZChannel *)((char *)this + 13416), (const OZChannelBase *)((char *)a2 + 13416), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 1677) = &off_1E6551358;
  *((_QWORD *)this + 1679) = &unk_1E65516B8;
  OZChannel::OZChannel((OZChannel *)((char *)this + 13568), (const OZChannelBase *)((char *)a2 + 13568), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 1696) = &off_1E6551358;
  *((_QWORD *)this + 1698) = &unk_1E65516B8;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13720), (const OZChannelBase *)((char *)a2 + 13720), (OZChannelFolder *)((char *)this + 80));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 13872), (const OZChannelBase *)((char *)a2 + 13872), (OZChannelFolder *)((char *)this + 80));
  OZChannelEnum::OZChannelEnum((OZShape *)((char *)this + 14024), (const OZShape *)((char *)a2 + 14024), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 1753) = &off_1E6559510;
  *((_QWORD *)this + 1755) = &unk_1E6559880;
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14280), (const OZChannelBase *)((char *)a2 + 14280), (OZChannelFolder *)((char *)this + 80));
  OZChannelText::OZChannelText((OZChannelText *)((char *)this + 14432), (const OZChannelText *)((char *)a2 + 14432), (OZChannelFolder *)((char *)this + 80));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14600), (const OZChannelBase *)((char *)a2 + 14600), (OZChannelFolder *)((char *)this + 80));
  OZChannelBool::OZChannelBool((OZChannelBool *)((char *)this + 14752), (const OZChannelBase *)((char *)a2 + 14752), (OZChannelFolder *)((char *)this + 80));
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 14904), (const OZShape *)((char *)a2 + 14904), (OZChannelFolder *)((char *)this + 80));
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 15608), (const OZShape *)((char *)a2 + 15608), (OZChannelFolder *)((char *)this + 80));
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 16312), (const OZShape *)((char *)a2 + 16312), (OZChannelFolder *)((char *)this + 80));
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 17016), (const OZShape *)((char *)a2 + 17016), (OZChannelFolder *)((char *)this + 80));
  OZChannel::OZChannel((OZChannel *)((char *)this + 17720), (const OZChannelBase *)((char *)a2 + 17720), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 2215) = &off_1E6551358;
  *((_QWORD *)this + 2217) = &unk_1E65516B8;
  OZChannelPosition::OZChannelPosition((OZShape *)((char *)this + 17872), (const OZShape *)((char *)a2 + 17872), (OZChannelFolder *)((char *)this + 80));
  *((_QWORD *)this + 2330) = 0;
  *((_OWORD *)this + 1164) = 0u;
  *((_BYTE *)this + 2640) = *((_BYTE *)a2 + 2640);
  *(_OWORD *)((char *)this + 2648) = *(_OWORD *)((char *)a2 + 2648);
  *((_DWORD *)this + 661) = *((_DWORD *)a2 + 661);
  v6 = *((_OWORD *)a2 + 1161);
  *((_QWORD *)this + 2324) = *((_QWORD *)a2 + 2324);
  *((_OWORD *)this + 1161) = v6;
  v13 = v11;
  PCMutex::lock(v11);
  v14 = 1;
  v7 = (OZShapeRenderParams *)operator new();
  OZShapeRenderParams::OZShapeRenderParams(v7, *((OZShapeRenderParams **)a2 + 333), 1);
  *((_QWORD *)this + 333) = v7;
  v8 = (OZShapeRenderParams *)operator new();
  OZShapeRenderParams::OZShapeRenderParams(v8, *((OZShapeRenderParams **)a2 + 333), 1);
  *((_QWORD *)this + 334) = v8;
  if (v13 && v14)
  {
    PCMutex::unlock(v13);
    v14 = 0;
  }
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 12856), MEMORY[0x1E0CA2E68], 0.0))
    (*(void (**)(OZShape *))(*(_QWORD *)this + 344))(this);
  *((_QWORD *)this + 2340) = 0;
  PCString::PCString(&v12, "Shape Stroke Range", "com.apple.proshapes.framework");
  PCString::set((PCString *)this + 1362, &v12);
  PCString::~PCString(&v12);
  PCString::PCString(v9, "Shape Stroke Range", "com.apple.proshapes.framework");
  PCString::set((PCString *)this + 1418, &v12);
  PCString::~PCString(&v12);
  PCString::PCString(v10, "Shape Stroke Range", "com.apple.proshapes.framework");
  PCString::set((PCString *)this + 1438, &v12);
  PCString::~PCString(&v12);
  *((_QWORD *)this + 2340) = 0;
  *((_QWORD *)this + 344) = 0;
  (*(void (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
  if (v13)
  {
    if (v14)
      PCMutex::unlock(v13);
  }
}

void sub_1B2FF9628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, OZChannelPosition *a9, OZChannelBool *a10, OZChannelBool *a11, OZChannelText *a12, OZChannelBool *a13, PCString *a14, OZChannelBool *a15, OZChannelBool *a16, OZChannel *a17, OZChannel *a18, OZChannelBool *a19, OZChannelEnum *a20,OZChannelButton *a21,OZChannel2D *a22,OZChannelPercent *a23,OZChannelEnum *a24,OZChannel *a25,OZChannel *a26,PCString *a27,PCString *a28,PCString *a29,OZChannel *a30,OZChannelBool *a31,PCString *a32,OZChannelPercent *a33,OZChannelPercent *a34,OZChannelEnum *a35,OZChannel *a36,OZChannel *a37,OZChannelEnum *a38,OZChannelEnum *a39,OZChannelEnum *a40,OZChannelBool *a41,OZChannel *a42,OZChannelPercent *a43,OZChannelColorNoAlpha *a44)
{
  OZChannelFolder *v44;
  OZChannelPosition *v45;
  OZChannelPosition *v46;
  OZChannelPosition *v47;
  _QWORD *v48;
  OZChannel *v49;
  OZChannelPosition *v50;
  OZChannelFolder *v51;
  uint64_t v52;
  void *v54;
  void *v55;

  PCString::~PCString((PCString *)(v52 - 112));
  PCLockSentry<PCMutex>::~PCLockSentry(v52 - 104);
  v54 = (void *)v48[2328];
  if (v54)
  {
    v48[2329] = v54;
    operator delete(v54);
  }
  OZChannelPosition::~OZChannelPosition(v47);
  OZChannel::~OZChannel(v49);
  OZChannelPosition::~OZChannelPosition(v50);
  OZChannelPosition::~OZChannelPosition(v46);
  OZChannelPosition::~OZChannelPosition(v45);
  OZChannelPosition::~OZChannelPosition(a9);
  OZChannelBool::~OZChannelBool(a10);
  OZChannelBool::~OZChannelBool(a11);
  OZChannelText::~OZChannelText(a12);
  OZChannelBool::~OZChannelBool(a13);
  OZChannelEnum::~OZChannelEnum(a14);
  OZChannelBool::~OZChannelBool(a15);
  OZChannelBool::~OZChannelBool(a16);
  OZChannel::~OZChannel(a17);
  OZChannel::~OZChannel(a18);
  OZChannelBool::~OZChannelBool(a19);
  OZChannelEnum::~OZChannelEnum(a20);
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v52 - 128));
  OZChannelButton::~OZChannelButton(a21);
  OZChannel2D::~OZChannel2D(a22);
  OZChannelPercent::~OZChannelPercent(a23);
  OZChannelEnum::~OZChannelEnum(a24);
  OZChannel::~OZChannel(a25);
  OZChannel::~OZChannel(a26);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a27);
  OZChannel2DOverRange::~OZChannel2DOverRange(a28);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a29);
  OZChannel::~OZChannel(a30);
  OZChannelBool::~OZChannelBool(a31);
  OZChannelPercentOverRange::~OZChannelPercentOverRange(a32);
  OZChannelPercent::~OZChannelPercent(a33);
  OZChannelPercent::~OZChannelPercent(a34);
  OZChannelEnum::~OZChannelEnum(a35);
  OZChannel::~OZChannel(a36);
  OZChannel::~OZChannel(a37);
  OZChannelEnum::~OZChannelEnum(a38);
  OZChannelEnum::~OZChannelEnum(a39);
  OZChannelEnum::~OZChannelEnum(a40);
  OZChannelBool::~OZChannelBool(a41);
  OZChannel::~OZChannel(a42);
  OZChannelPercent::~OZChannelPercent(a43);
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(a44);
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v52 - 256));
  OZChannelFolder::~OZChannelFolder(v51);
  OZChannelGradientPositioned::~OZChannelGradientPositioned(*(OZChannelGradientPositioned **)(v52 - 248));
  OZChannelPercent::~OZChannelPercent(*(OZChannelPercent **)(v52 - 240));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha(*(OZChannelColorNoAlpha **)(v52 - 232));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v52 - 224));
  OZChannelFolder::~OZChannelFolder(*(OZChannelFolder **)(v52 - 216));
  v55 = (void *)v48[345];
  if (v55)
  {
    v48[346] = v55;
    operator delete(v55);
  }
  std::__list_imp<unsigned int>::clear(*(_QWORD **)(v52 - 208));
  std::__list_imp<unsigned int>::clear(*(_QWORD **)(v52 - 200));
  std::__list_imp<unsigned int>::clear(*(_QWORD **)(v52 - 192));
  OZChannel::~OZChannel(*(OZChannel **)(v52 - 184));
  OZChannelPosition::~OZChannelPosition(*(OZChannelPosition **)(v52 - 176));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v52 - 168));
  OZChannel::~OZChannel(*(OZChannel **)(v52 - 160));
  OZChannelBool::~OZChannelBool(*(OZChannelBool **)(v52 - 152));
  OZChannelEnum::~OZChannelEnum(*(OZChannelEnum **)(v52 - 144));
  OZChannelShape::~OZChannelShape(*(OZChannelShape **)(v52 - 136));
  OZChannelFolder::~OZChannelFolder(v44);
  PCMutex::~PCMutex(*(PCMutex **)(v52 - 120));
  _Unwind_Resume(a1);
}

void OZShape::~OZShape(OZShape *this)
{
  PCMutex *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  OZGradientGroupShader *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  OZShapeReparametrizedContour *v10;
  uint64_t *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  OZShapeContour *v16;
  uint64_t *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  OZShapeContour *v22;
  uint64_t *v23;
  uint64_t v24;
  void *v25;
  void *v26;

  *(_QWORD *)this = &off_1E65E95F0;
  v2 = (PCMutex *)((char *)this + 8);
  PCMutex::lock((PCMutex *)((char *)this + 8));
  v3 = *((_QWORD *)this + 333);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    *((_QWORD *)this + 333) = 0;
  }
  v4 = *((_QWORD *)this + 334);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    *((_QWORD *)this + 334) = 0;
  }
  v5 = *((_QWORD *)this + 344);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    *((_QWORD *)this + 344) = 0;
  }
  *((_QWORD *)this + 346) = *((_QWORD *)this + 345);
  v6 = (OZGradientGroupShader *)*((_QWORD *)this + 2340);
  if (v6)
  {
    OZGradientGroupShader::~OZGradientGroupShader(v6);
    MEMORY[0x1B5E29170]();
    *((_QWORD *)this + 2340) = 0;
  }
  v7 = (char *)this + 2728;
  while (1)
  {
    v8 = *((_QWORD *)this + 343);
    if (!v8)
      break;
    v9 = *(_QWORD *)v7;
    v10 = *(OZShapeReparametrizedContour **)(*(_QWORD *)v7 + 16);
    if (v10)
    {
      OZShapeReparametrizedContour::~OZShapeReparametrizedContour(v10);
      MEMORY[0x1B5E29170]();
      v9 = *((_QWORD *)this + 341);
      v8 = *((_QWORD *)this + 343);
    }
    *(_QWORD *)(v9 + 16) = 0;
    v11 = (uint64_t *)*((_QWORD *)this + 341);
    v12 = *v11;
    *(_QWORD *)(v12 + 8) = v11[1];
    *(_QWORD *)v11[1] = v12;
    *((_QWORD *)this + 343) = v8 - 1;
    operator delete(v11);
  }
  v13 = (char *)this + 2704;
  while (1)
  {
    v14 = *((_QWORD *)this + 340);
    if (!v14)
      break;
    v15 = *(_QWORD *)v13;
    v16 = *(OZShapeContour **)(*(_QWORD *)v13 + 16);
    if (v16)
    {
      OZShapeContour::~OZShapeContour(v16);
      MEMORY[0x1B5E29170]();
      v15 = *((_QWORD *)this + 338);
      v14 = *((_QWORD *)this + 340);
    }
    *(_QWORD *)(v15 + 16) = 0;
    v17 = (uint64_t *)*((_QWORD *)this + 338);
    v18 = *v17;
    *(_QWORD *)(v18 + 8) = v17[1];
    *(_QWORD *)v17[1] = v18;
    *((_QWORD *)this + 340) = v14 - 1;
    operator delete(v17);
  }
  v19 = (char *)this + 2680;
  while (1)
  {
    v20 = *((_QWORD *)this + 337);
    if (!v20)
      break;
    v21 = *(_QWORD *)v19;
    v22 = *(OZShapeContour **)(*(_QWORD *)v19 + 16);
    if (v22)
    {
      OZShapeContour::~OZShapeContour(v22);
      MEMORY[0x1B5E29170]();
      v21 = *((_QWORD *)this + 335);
      v20 = *((_QWORD *)this + 337);
    }
    *(_QWORD *)(v21 + 16) = 0;
    v23 = (uint64_t *)*((_QWORD *)this + 335);
    v24 = *v23;
    *(_QWORD *)(v24 + 8) = v23[1];
    *(_QWORD *)v23[1] = v24;
    *((_QWORD *)this + 337) = v20 - 1;
    operator delete(v23);
  }
  PCMutex::unlock(v2);
  v25 = (void *)*((_QWORD *)this + 2328);
  if (v25)
  {
    *((_QWORD *)this + 2329) = v25;
    operator delete(v25);
  }
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 17872));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 17720));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 17016));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 16312));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 15608));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 14904));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14752));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14600));
  OZChannelText::~OZChannelText((OZChannelText *)((char *)this + 14432));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 14280));
  OZChannelEnum::~OZChannelEnum((PCString *)this + 1753);
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 13872));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 13720));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 13568));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 13416));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 13264));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 13008));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 12856));
  OZChannelButton::~OZChannelButton((OZChannelButton *)((char *)this + 12664));
  OZChannel2D::~OZChannel2D((OZShape *)((char *)this + 12224));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 12072));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 11816));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 11664));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 11512));
  *((_QWORD *)this + 1419) = &off_1E655E0A8;
  *((_QWORD *)this + 1421) = &unk_1E655E458;
  PCString::~PCString((PCString *)this + 1438);
  OZChanObjectRef::~OZChanObjectRef((OZShape *)((char *)this + 11352));
  *((_QWORD *)this + 1363) = &off_1E655E4B0;
  *((_QWORD *)this + 1365) = &unk_1E655E828;
  PCString::~PCString((PCString *)this + 1418);
  OZChannel2D::~OZChannel2D((OZShape *)((char *)this + 10904));
  *((_QWORD *)this + 1343) = &off_1E655E0A8;
  *((_QWORD *)this + 1345) = &unk_1E655E458;
  PCString::~PCString((PCString *)this + 1362);
  OZChanObjectRef::~OZChanObjectRef((OZShape *)((char *)this + 10744));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 10592));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 10440));
  *((_QWORD *)this + 1285) = &off_1E655E0A8;
  *((_QWORD *)this + 1287) = &unk_1E655E458;
  PCString::~PCString((PCString *)this + 1304);
  OZChanObjectRef::~OZChanObjectRef((OZShape *)((char *)this + 10280));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 10128));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 9976));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 9720));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 9568));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 9416));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 9160));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 8904));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 8648));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 8496));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 8344));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 0x2000));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha((OZShape *)((char *)this + 7184));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 6928));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 6800));
  OZChannelGradientPositioned::~OZChannelGradientPositioned((OZShape *)((char *)this + 4328));
  OZChannelPercent::~OZChannelPercent((OZChannelPercent *)((char *)this + 4176));
  OZChannelColorNoAlpha::~OZChannelColorNoAlpha((OZShape *)((char *)this + 3168));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 2912));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 2784));
  v26 = (void *)*((_QWORD *)this + 345);
  if (v26)
  {
    *((_QWORD *)this + 346) = v26;
    operator delete(v26);
  }
  std::__list_imp<unsigned int>::clear((_QWORD *)this + 341);
  std::__list_imp<unsigned int>::clear((_QWORD *)this + 338);
  std::__list_imp<unsigned int>::clear((_QWORD *)this + 335);
  OZChannel::~OZChannel((OZChannel *)((char *)this + 2488));
  OZChannelPosition::~OZChannelPosition((OZShape *)((char *)this + 1784));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 1632));
  OZChannel::~OZChannel((OZChannel *)((char *)this + 1480));
  OZChannelBool::~OZChannelBool((OZChannelBool *)((char *)this + 1328));
  OZChannelEnum::~OZChannelEnum((OZShape *)((char *)this + 1072));
  OZChannelShape::~OZChannelShape((OZShape *)((char *)this + 208));
  OZChannelFolder::~OZChannelFolder((OZChannelFolder *)((char *)this + 80));
  PCMutex::~PCMutex(v2);
}

{
  OZShape::~OZShape(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t OZShape::operator=(uint64_t a1, uint64_t a2)
{
  OZGradientGroupShader *v4;
  uint64_t v5;
  uint64_t v6;
  OZShapeReparametrizedContour *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  OZShapeContour *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  OZShapeContour *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int ValueAsInt;
  uint64_t v23;
  uint64_t result;

  v4 = *(OZGradientGroupShader **)(a1 + 18720);
  if (v4)
  {
    OZGradientGroupShader::~OZGradientGroupShader(v4);
    MEMORY[0x1B5E29170]();
    *(_QWORD *)(a1 + 18720) = 0;
  }
  while (1)
  {
    v5 = *(_QWORD *)(a1 + 2744);
    if (!v5)
      break;
    v6 = *(_QWORD *)(a1 + 2728);
    v7 = *(OZShapeReparametrizedContour **)(v6 + 16);
    if (v7)
    {
      OZShapeReparametrizedContour::~OZShapeReparametrizedContour(v7);
      MEMORY[0x1B5E29170]();
      v6 = *(_QWORD *)(a1 + 2728);
      v5 = *(_QWORD *)(a1 + 2744);
    }
    *(_QWORD *)(v6 + 16) = 0;
    v8 = *(uint64_t **)(a1 + 2728);
    v9 = *v8;
    *(_QWORD *)(v9 + 8) = v8[1];
    *(_QWORD *)v8[1] = v9;
    *(_QWORD *)(a1 + 2744) = v5 - 1;
    operator delete(v8);
  }
  while (1)
  {
    v12 = *(_QWORD *)(a1 + 2696);
    if (!v12)
      break;
    v10 = *(_QWORD *)(a1 + 2680);
    v11 = *(OZShapeContour **)(v10 + 16);
    if (v11)
    {
      OZShapeContour::~OZShapeContour(v11);
      MEMORY[0x1B5E29170]();
      v10 = *(_QWORD *)(a1 + 2680);
      v12 = *(_QWORD *)(a1 + 2696);
    }
    *(_QWORD *)(v10 + 16) = 0;
    v13 = *(uint64_t **)(a1 + 2680);
    v14 = *v13;
    *(_QWORD *)(v14 + 8) = v13[1];
    *(_QWORD *)v13[1] = v14;
    *(_QWORD *)(a1 + 2696) = v12 - 1;
    operator delete(v13);
  }
  while (1)
  {
    v15 = *(_QWORD *)(a1 + 2720);
    if (!v15)
      break;
    v16 = *(_QWORD *)(a1 + 2704);
    v17 = *(OZShapeContour **)(v16 + 16);
    if (v17)
    {
      OZShapeContour::~OZShapeContour(v17);
      MEMORY[0x1B5E29170]();
      v16 = *(_QWORD *)(a1 + 2704);
      v15 = *(_QWORD *)(a1 + 2720);
    }
    *(_QWORD *)(v16 + 16) = 0;
    v18 = *(uint64_t **)(a1 + 2704);
    v19 = *v18;
    *(_QWORD *)(v19 + 8) = v18[1];
    *(_QWORD *)v18[1] = v19;
    *(_QWORD *)(a1 + 2720) = v15 - 1;
    operator delete(v18);
  }
  v20 = *(_QWORD *)(a1 + 2752);
  if (v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    *(_QWORD *)(a1 + 2752) = 0;
  }
  *(_QWORD *)(a1 + 2768) = *(_QWORD *)(a1 + 2760);
  OZChannelBase::operator=(a1 + 14280, a2 + 14280);
  OZChannelBase::operator=(a1 + 14432, a2 + 14432);
  PCString::set((PCString *)(a1 + 14584), (const PCString *)(a2 + 14584));
  *(_BYTE *)(a1 + 14592) = *(_BYTE *)(a2 + 14592);
  OZChannelBase::operator=(a1 + 11512, a2 + 11512);
  OZChannelBase::operator=(a1 + 11664, a2 + 11664);
  OZChannelBase::operator=(a1 + 11816, a2 + 11816);
  OZChannelBase::operator=(a1 + 12072, a2 + 12072);
  OZChannelFolder::operator=(a1 + 12224);
  OZChannelBase::operator=(a1 + 12360, a2 + 12360);
  OZChannelBase::operator=(a1 + 12512, a2 + 12512);
  OZChannelBase::operator=(a1 + 13008, a2 + 13008);
  OZChannelBase::operator=(a1 + 13264, a2 + 13264);
  OZChannelBase::operator=(a1 + 9720, a2 + 9720);
  OZChannelBase::operator=(a1 + 8496, a2 + 8496);
  OZChannelFolder::operator=(a1 + 6800);
  OZChannelBase::operator=(a1 + 8344, a2 + 8344);
  OZChannelBase::operator=(a1 + 8648, a2 + 8648);
  OZChannelBase::operator=(a1 + 8904, a2 + 8904);
  OZChannelBase::operator=(a1 + 9160, a2 + 9160);
  OZChannelBase::operator=(a1 + 9416, a2 + 9416);
  OZChannelBase::operator=(a1 + 9568, a2 + 9568);
  OZChannelBase::operator=(a1 + 9976, a2 + 9976);
  OZChannelBase::operator=(a1 + 10128, a2 + 10128);
  OZChannelBase::operator=(a1 + 10280, a2 + 10280);
  PCString::set((PCString *)(a1 + 10432), (const PCString *)(a2 + 10432));
  OZChannelBase::operator=(a1 + 10440, a2 + 10440);
  OZChannelBase::operator=(a1 + 10592, a2 + 10592);
  OZChannelFolder::operator=(a1 + 7184);
  OZChannelBase::operator=(a1 + 7320, a2 + 7320);
  OZChannelBase::operator=(a1 + 7472, a2 + 7472);
  OZChannelBase::operator=(a1 + 7624, a2 + 7624);
  OZChannelBase::operator=(a1 + 7776, a2 + 7776);
  OZChannelBase::operator=(a1 + 7928, a2 + 7928);
  *(_BYTE *)(a1 + 8184) = *(_BYTE *)(a2 + 8184);
  OZChannelBase::operator=(a1 + 0x2000, a2 + 0x2000);
  OZChannelFolder::operator=(a1 + 2784);
  OZChannelBase::operator=(a1 + 2912, a2 + 2912);
  OZChannelFolder::operator=(a1 + 3168);
  OZChannelBase::operator=(a1 + 3304, a2 + 3304);
  OZChannelBase::operator=(a1 + 3456, a2 + 3456);
  OZChannelBase::operator=(a1 + 3608, a2 + 3608);
  OZChannelBase::operator=(a1 + 3760, a2 + 3760);
  OZChannelBase::operator=(a1 + 3912, a2 + 3912);
  *(_BYTE *)(a1 + 4168) = *(_BYTE *)(a2 + 4168);
  OZChannelBase::operator=(a1 + 4176, a2 + 4176);
  OZChannelBase::operator=(a1 + 1072, a2 + 1072);
  OZChannelGradientPositioned::operator=(a1 + 4328, a2 + 4328);
  *(_BYTE *)(a1 + 2640) = *(_BYTE *)(a2 + 2640);
  *(_DWORD *)(a1 + 2644) = *(_DWORD *)(a2 + 2644);
  OZChannelBase::operator=(a1 + 1328, a2 + 1328);
  OZChannelPosition::operator=(a1 + 1784, a2 + 1784);
  OZChannelBase::operator=(a1 + 208, a2 + 208);
  OZChannelBase::operator=(a1 + 13416, a2 + 13416);
  OZChannelBase::operator=(a1 + 13568, a2 + 13568);
  OZChannelBase::operator=(a1 + 1480, a2 + 1480);
  OZChannelBase::operator=(a1 + 1632, a2 + 1632);
  OZChannelBase::operator=(a1 + 12664, a2 + 12664);
  *(_QWORD *)(a1 + 12816) = *(_QWORD *)(a2 + 12816);
  PCString::set((PCString *)(a1 + 12824), (const PCString *)(a2 + 12824));
  *(_QWORD *)(a1 + 12832) = *(_QWORD *)(a2 + 12832);
  PCString::set((PCString *)(a1 + 12840), (const PCString *)(a2 + 12840));
  *(_BYTE *)(a1 + 12848) = *(_BYTE *)(a2 + 12848);
  OZChannelBase::operator=(a1 + 14752, a2 + 14752);
  OZChannelPosition::operator=(a1 + 14904, a2 + 14904);
  OZChannelPosition::operator=(a1 + 15608, a2 + 15608);
  OZChannelPosition::operator=(a1 + 16312, a2 + 16312);
  OZChannelPosition::operator=(a1 + 17016, a2 + 17016);
  OZChannelBase::operator=(a1 + 17720, a2 + 17720);
  OZChannelPosition::operator=(a1 + 17872, a2 + 17872);
  v21 = *(_QWORD *)(a2 + 18592);
  *(_OWORD *)(a1 + 18576) = *(_OWORD *)(a2 + 18576);
  *(_QWORD *)(a1 + 18592) = v21;
  OZChannelBase::operator=(a1 + 12856, a2 + 12856);
  PCMutex::lock((PCMutex *)(a1 + 8));
  OZShapeRenderParams::operator=(*(_QWORD *)(a1 + 2664), *(_QWORD *)(a2 + 2664));
  OZShapeRenderParams::operator=(*(_QWORD *)(a1 + 2672), *(_QWORD *)(a2 + 2672));
  PCMutex::unlock((PCMutex *)(a1 + 8));
  OZChannelBase::operator=(a1 + 14024, a2 + 14024);
  OZChannelBase::operator=(a1 + 13720, a2 + 13720);
  OZChannelBase::operator=(a1 + 13872, a2 + 13872);
  OZChannelBase::operator=(a1 + 14600, a2 + 14600);
  *(_OWORD *)(a1 + 2648) = *(_OWORD *)(a2 + 2648);
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 12856), MEMORY[0x1E0CA2E68], 0.0);
  v23 = 344;
  if (!ValueAsInt)
    v23 = 352;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + v23))(a1);
  *(_QWORD *)(a1 + 18720) = 0;
  return result;
}

void sub_1B2FFA634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t OZShape::setIsMask(OZShape *this)
{
  OZChannelBase *v2;

  v2 = (OZChannelBase *)((char *)this + 2784);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 2784), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 6800), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 13008), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 13264), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 14024), 2, 0);
  OZChannelBase::enable(v2, 1, 0);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 6800), 0, 0);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 11512), 1, 0);
  OZChannelBase::enable((OZChannelBase *)((char *)this + 11664), 1, 0);
  OZChannel::setValue((OZChannel *)((char *)this + 12856), MEMORY[0x1E0CA2E68], 1.0, 0);
  return (*(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
}

uint64_t OZShape::clearIsMask(OZShape *this)
{
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 2784), 2, 0);
  OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 6800), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 13008), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 13264), 2, 0);
  OZChannelBase::setFlag((OZChannelBase *)((char *)this + 14024), 2, 0);
  OZChannel::setValue((OZChannel *)((char *)this + 12856), MEMORY[0x1E0CA2E68], 0.0, 0);
  return (*(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
}

BOOL OZShape::isMask(OZShape *this)
{
  return OZChannel::getValueAsInt((OZChannel *)((char *)this + 12856), MEMORY[0x1E0CA2E68], 0.0) != 0;
}

void OZShape::validateChannels(OZShape *this, const OZShapeRenderState *a2, OZShapeRenderParams *a3)
{
  uint64_t v3;
  __int128 *v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  double v11;
  double v12;
  int32x4_t *Hash;
  int32x4_t v14;
  int ValueAsInt;
  double v16;
  double v18;
  double v19;
  double v20;
  double v21;
  int v22;
  int v23;
  double v24;
  double v25;
  double v26;
  int isEnabled;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  double v54;
  double v55;
  double v56;
  _DWORD *v58;
  int isGeometricShape;
  double v60;
  uint64_t v61;
  double v62;
  uint64_t v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int isRect;
  int v69;
  __int128 v74;
  float v75;
  PCColor time1;
  __int128 v77;
  double v78;
  double v79;
  double v80;
  CMTime time2;
  int8x8_t v82[521];

  v3 = MEMORY[0x1E0C80A78](this);
  v6 = v5;
  v8 = v7;
  v9 = v4;
  v10 = v3;
  v82[520] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  v79 = 0.0;
  v80 = 0.0;
  if (!*((_BYTE *)v4 + 24))
  {
    (*(void (**)(uint64_t, double *, double *, __int128 *))(*(_QWORD *)v3 + 368))(v3, &v80, &v79, v4);
    if (vabdd_f64(v80, *(double *)(v8 + 248)) >= 0.0000001 || vabdd_f64(v79, *(double *)(v8 + 256)) >= 0.0000001)
    {
      if (v6)
      {
        v11 = v79;
        *(double *)(v8 + 248) = v80;
        *(double *)(v8 + 256) = v11;
      }
      *(_WORD *)(v8 + 1193) = 257;
      *(_BYTE *)(v8 + 1195) = 1;
    }
    (*(void (**)(uint64_t, double *, double *, __int128 *))(*(_QWORD *)v10 + 376))(v10, &v80, &v79, v9);
    if (vabdd_f64(v80, *(double *)(v8 + 264)) >= 0.0000001 || vabdd_f64(v79, *(double *)(v8 + 272)) >= 0.0000001)
    {
      if (v6)
      {
        v12 = v79;
        *(double *)(v8 + 264) = v80;
        *(double *)(v8 + 272) = v12;
      }
      *(_WORD *)(v8 + 1193) = 257;
      *(_BYTE *)(v8 + 1195) = 1;
    }
  }
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v82);
  OZChannelCurve::calcHashForAnimationOnly((OZChannel *)(v10 + 208), (PCSerializerWriteStream *)v82, (const CMTime *)v9);
  Hash = (int32x4_t *)PCHashWriteStream::getHash(v82);
  v14 = *Hash;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(v8 + 280), *Hash)))) & 1) != 0)
  {
    *(_BYTE *)(v8 + 1192) = 1;
    *(int32x4_t *)(v8 + 280) = v14;
  }
  OZChannelBase::getTimeOffset((OZChannelBase *)(v10 + 80), (uint64_t)&v77);
  *(_OWORD *)&time1.var0.var0 = v77;
  time1.var0.var1[1] = v78;
  time2 = *(CMTime *)(v8 + 1168);
  if (CMTimeCompare((CMTime *)&time1, &time2)
    && (OZChannel::hasMoreThanOneKeypoint((OZChannel *)(v10 + 208))
     || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 152))(v10) & 1) != 0))
  {
    *(_BYTE *)(v8 + 1192) = 1;
  }
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(v10 + 10440), MEMORY[0x1E0CA2E68], 0.0);
  if (ValueAsInt != *(unsigned __int8 *)(v8 + 112))
  {
    *(_BYTE *)(v8 + 112) = ValueAsInt != 0;
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
  }
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 11664), (const CMTime *)v9, 0.0);
  _ZF = vabdd_f64(v16, *(double *)(v8 + 232)) < 0.0000001 || v6 == 0;
  if (!_ZF)
    *(double *)(v8 + 232) = v16;
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 12072), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v18, *(double *)(v8 + 192)) >= 0.0000001)
  {
    if (v6)
      *(double *)(v8 + 192) = v18;
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
  }
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 12360), (const CMTime *)v9, 0.0);
  v20 = v19;
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 12512), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v20, *(double *)(v8 + 200)) >= 0.0000001 || vabdd_f64(v21, *(double *)(v8 + 208)) >= 0.0000001)
  {
    if (v6)
    {
      *(double *)(v8 + 200) = v20;
      *(double *)(v8 + 208) = v21;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
  }
  v22 = OZChannel::getValueAsInt((OZChannel *)(v10 + 14752), MEMORY[0x1E0CA2E68], 0.0) != 0;
  if (*(unsigned __int8 *)(v8 + 242) != v22)
  {
    if (v6)
      *(_BYTE *)(v8 + 242) = v22;
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
  }
  v23 = OZChannel::getValueAsInt((OZChannel *)(v10 + 1072), (const CMTime *)v9, 0.0);
  if (*(_DWORD *)(v8 + 172) != v23)
  {
    switch(v23)
    {
      case 0:
      case 1:
      case 2:
      case 4:
        if ((v6 & 1) != 0)
          goto LABEL_41;
        break;
      case 5:
        if (v6)
LABEL_41:
          *(_DWORD *)(v8 + 172) = v23;
        break;
      default:
        break;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
  }
  v24 = *((double *)v9 + 4);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 11512), (const CMTime *)v9, 0.0);
  v26 = v25;
  isEnabled = OZChannelBase::isEnabled((OZChannelBase *)(v10 + 2784), 0, 1);
  if (vabdd_f64(*(double *)(v8 + 224), v24 * v26) >= 0.0000001
    || *(_DWORD *)(v8 + 120) != isEnabled
    || *(_BYTE *)(v8 + 1192))
  {
    if (v6)
    {
      *(_DWORD *)(v8 + 120) = isEnabled;
      *(double *)(v8 + 224) = v24 * v26;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
  }
  v28 = OZChannel::getValueAsInt((OZChannel *)(v10 + 6928), (const CMTime *)v9, 0.0);
  v29 = OZChannelBase::isEnabled((OZChannelBase *)(v10 + 6800), 0, 1);
  if (v28)
    v30 = 0;
  else
    v30 = v29;
  if ((v28 - 1) < 2)
    v31 = v29;
  else
    v31 = 0;
  v32 = *(unsigned __int8 *)(v8 + 12);
  if (v32 == v31 && *(_DWORD *)(v8 + 36) == v28)
  {
    v33 = v30;
    _ZF = *(_DWORD *)(v8 + 8) == v30;
    v30 = *(_DWORD *)(v8 + 8);
    if (!_ZF)
    {
LABEL_77:
      v30 = v33;
      if (!v6)
        goto LABEL_79;
      goto LABEL_78;
    }
  }
  else
  {
    if (v6)
      *(_DWORD *)(v8 + 36) = v28;
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
    if (v32 != v31)
      goto LABEL_76;
    v33 = v30;
    if (*(_DWORD *)(v8 + 8) != v30)
      goto LABEL_77;
  }
  v34 = *(double *)(v8 + 72);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 9976), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v34, v35) >= 0.0000001)
    goto LABEL_76;
  v36 = *(double *)(v8 + 80);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 10128), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v36, v37) >= 0.0000001)
    goto LABEL_76;
  v38 = *(double *)(v8 + 88);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 10592), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v38, v39) >= 0.0000001)
    goto LABEL_76;
  v40 = *(double *)(v8 + 104);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 9568), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v40, v41) >= 0.0000001
    || (v42 = *(double *)(v8 + 96),
        OZChannel::getValueAsDouble((OZChannel *)(v10 + 9416), (const CMTime *)v9, 0.0),
        vabdd_f64(v42, v43) >= 0.0000001)
    || (v44 = *(_DWORD *)(v8 + 24),
        v44 != OZChannel::getValueAsInt((OZChannel *)(v10 + 8648), (const CMTime *)v9, 0.0))
    || (v45 = *(_DWORD *)(v8 + 28),
        v45 != OZChannel::getValueAsInt((OZChannel *)(v10 + 8904), (const CMTime *)v9, 0.0))
    || (v46 = *(_DWORD *)(v8 + 32),
        v46 != OZChannel::getValueAsInt((OZChannel *)(v10 + 9160), (const CMTime *)v9, 0.0))
    || (v47 = *(_DWORD *)(v8 + 116),
        v47 != OZChannel::getValueAsInt((OZChannel *)(v10 + 9720), (const CMTime *)v9, 0.0))
    || (v48 = *(unsigned __int8 *)(v8 + 13),
        OZChannel::getValueAsInt((OZChannel *)(v10 + 8496), (const CMTime *)v9, 0.0) != v48))
  {
LABEL_76:
    v33 = v30;
    goto LABEL_77;
  }
  if (*(_BYTE *)(v8 + 1192) && (v6 & 1) != 0)
  {
LABEL_78:
    *(_DWORD *)(v8 + 8) = v30;
    *(_BYTE *)(v8 + 12) = v31;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 9976), (const CMTime *)v9, 0.0);
    *(_QWORD *)(v8 + 72) = v49;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 10128), (const CMTime *)v9, 0.0);
    *(_QWORD *)(v8 + 80) = v50;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 10592), (const CMTime *)v9, 0.0);
    *(_QWORD *)(v8 + 88) = v51;
    *(_DWORD *)(v8 + 24) = OZChannel::getValueAsInt((OZChannel *)(v10 + 8648), (const CMTime *)v9, 0.0);
    *(_DWORD *)(v8 + 28) = OZChannel::getValueAsInt((OZChannel *)(v10 + 8904), (const CMTime *)v9, 0.0);
    *(_DWORD *)(v8 + 32) = OZChannel::getValueAsInt((OZChannel *)(v10 + 9160), (const CMTime *)v9, 0.0);
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 9416), (const CMTime *)v9, 0.0);
    *(_QWORD *)(v8 + 96) = v52;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 9568), (const CMTime *)v9, 0.0);
    *(_QWORD *)(v8 + 104) = v53;
    *(_DWORD *)(v8 + 116) = OZChannel::getValueAsInt((OZChannel *)(v10 + 9720), (const CMTime *)v9, 0.0);
    *(_BYTE *)(v8 + 13) = OZChannel::getValueAsInt((OZChannel *)(v10 + 8496), (const CMTime *)v9, 0.0) != 0;
    *(_BYTE *)(v8 + 1195) = 1;
  }
LABEL_79:
  v54 = *(double *)(v8 + 16);
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 8344), (const CMTime *)v9, 0.0);
  if (vabdd_f64(v54, v55) >= 0.0000001)
  {
    if (!v6)
      goto LABEL_90;
  }
  else if (!*(_BYTE *)(v8 + 1192) || (v6 & 1) == 0)
  {
    goto LABEL_90;
  }
  OZChannel::getValueAsDouble((OZChannel *)(v10 + 8344), (const CMTime *)v9, 0.0);
  if (v56 < 1.0 && v56 > 0.0)
    v56 = 1.0;
  *(double *)(v8 + 16) = v56;
  *(_WORD *)(v8 + 1192) = 257;
  *(_BYTE *)(v8 + 1194) = 1;
LABEL_90:
  if (!OZChannel::getValueAsInt((OZChannel *)(v10 + 1328), (const CMTime *)v9, 0.0))
  {
    isGeometricShape = OZShape::isGeometricShape((OZShape *)v10);
    v58 = (_DWORD *)(v8 + 168);
    if (*(_DWORD *)(v8 + 168) == isGeometricShape)
      goto LABEL_98;
    if (!isGeometricShape)
    {
      if (v6)
      {
        *v58 = 0;
        OZChannelCurve::openCurve((OZChannelCurve *)(v10 + 208));
      }
      goto LABEL_97;
    }
LABEL_95:
    if (v6)
    {
      *v58 = 1;
      OZChannelCurve::closeCurve((OZChannelCurve *)(v10 + 208));
    }
LABEL_97:
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
    goto LABEL_98;
  }
  v58 = (_DWORD *)(v8 + 168);
  if (*(_DWORD *)(v8 + 168) != 1)
    goto LABEL_95;
LABEL_98:
  if (v6)
  {
    PCColor::PCColor(&time1);
    OZChannelColorNoAlpha::getColor((OZChannelColorNoAlpha *)(v10 + 3168), (const CMTime *)v9, &time1);
    LODWORD(time2.value) = 0;
    LODWORD(v77) = 0;
    v75 = 0.0;
    PCColor::getRGB(&time1, (float *)&time2, (float *)&v77, &v75, (const PCColorSpaceHandle *)(v9 + 5));
    v60 = *(float *)&v77;
    *(double *)(v8 + 128) = *(float *)&time2.value;
    *(double *)(v8 + 136) = v60;
    *(double *)(v8 + 144) = v75;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 4176), (const CMTime *)v9, 0.0);
    *(_QWORD *)(v8 + 152) = v61;
    OZChannelColorNoAlpha::getColor((OZChannelColorNoAlpha *)(v10 + 7184), (const CMTime *)v9, &time1);
    PCColor::getRGB(&time1, (float *)&time2, (float *)&v77, &v75, (const PCColorSpaceHandle *)(v9 + 5));
    v62 = *(float *)&v77;
    *(double *)(v8 + 40) = *(float *)&time2.value;
    *(double *)(v8 + 48) = v62;
    *(double *)(v8 + 56) = v75;
    OZChannel::getValueAsDouble((OZChannel *)(v10 + 0x2000), (const CMTime *)v9, 0.0);
    *(_QWORD *)(v8 + 64) = v63;
    PCCFRef<CGColorSpace *>::~PCCFRef(&time1.var1._obj);
  }
  v64 = OZChannel::getValueAsInt((OZChannel *)(v10 + 2912), (const CMTime *)v9, 0.0);
  if (*(_DWORD *)(v8 + 124) != v64 && v6)
    *(_DWORD *)(v8 + 124) = v64;
  if (OZChannel::getValueAsInt((OZChannel *)(v10 + 1480), (const CMTime *)v9, 0.0))
    v65 = *((_DWORD *)v9 + 12);
  else
    v65 = 2;
  v66 = *(_DWORD *)(v8 + 180);
  if (v66 != OZChannel::getValueAsInt((OZChannel *)(v10 + 1480), (const CMTime *)v9, 0.0)
    || *(_DWORD *)(v8 + 184) != v65
    || (v67 = *(unsigned __int8 *)(v8 + 216),
        OZChannel::getValueAsInt((OZChannel *)(v10 + 1632), (const CMTime *)v9, 0.0) != v67))
  {
    if (v6)
    {
      *(_DWORD *)(v8 + 180) = OZChannel::getValueAsInt((OZChannel *)(v10 + 1480), (const CMTime *)v9, 0.0);
      *(_DWORD *)(v8 + 184) = v65;
      *(_BYTE *)(v8 + 216) = OZChannel::getValueAsInt((OZChannel *)(v10 + 1632), (const CMTime *)v9, 0.0) != 0;
    }
    *(_WORD *)(v8 + 1192) = 257;
    *(_BYTE *)(v8 + 1194) = 1;
  }
  isRect = OZShape::isRect(v10, (CMTime *)v9);
  v69 = *(unsigned __int8 *)(v8 + 241);
  if (v69 != isRect && v6)
    *(_BYTE *)(v8 + 241) = v69 ^ 1;
  if (OZChannel::getValueAsInt((OZChannel *)(v10 + 12856), MEMORY[0x1E0CA2E68], 0.0))
  {
    *(_DWORD *)(v8 + 8) = 0;
    *(_QWORD *)(v8 + 120) = 1;
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)(v8 + 128) = _Q0;
    *(_OWORD *)(v8 + 144) = _Q0;
  }
  v74 = *v9;
  *(_QWORD *)(v8 + 1160) = *((_QWORD *)v9 + 2);
  *(_OWORD *)(v8 + 1144) = v74;
  OZChannelBase::getTimeOffset((OZChannelBase *)(v10 + 80), (uint64_t)&time1);
  *(_OWORD *)(v8 + 1168) = *(_OWORD *)&time1.var0.var0;
  *(double *)(v8 + 1184) = time1.var0.var1[1];
  if (*(_BYTE *)(v8 + 1192) || *(_BYTE *)(v8 + 1193) || *(_BYTE *)(v8 + 1194))
    *(_BYTE *)(v8 + 1195) = 1;
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v82);
}

void sub_1B2FFB2FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CGColorSpace *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(&a17);
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)&a26);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_interpolationModeImpl::getInstance(OZShape::OZShape_interpolationModeImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_interpolationModeImpl::getInstance(void)::OZShape_interpolationModeImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_interpolationModeImpl::getInstance(void)::OZShape_interpolationModeImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_interpolationModeImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_interpolationModeImpl::_OZShape_interpolationMode;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_interpolationModeImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_interpolationModeImpl *v0;

  if (!OZShape::OZShape_interpolationModeImpl::_OZShape_interpolationMode)
  {
    v0 = (OZShape::OZShape_interpolationModeImpl *)operator new();
    OZShape::OZShape_interpolationModeImpl::OZShape_interpolationModeImpl(v0);
    OZShape::OZShape_interpolationModeImpl::_OZShape_interpolationMode = (uint64_t)v0;
  }
}

void sub_1B2FFB424(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_interpolationModeImpl *OZShape::OZShape_interpolationModeImpl::OZShape_interpolationModeImpl(OZShape::OZShape_interpolationModeImpl *this)
{
  OZCurve *OZChannelEnumCurve;

  OZChannelEnumCurve = (OZCurve *)OZChannelEnum::createOZChannelEnumCurve(this, 1.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelEnumCurve, 1.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_interpolationModeImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E97A0;
  *((_QWORD *)this + 5) = &unk_1E65E97C0;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 4294967300.0);
  return this;
}

void sub_1B2FFB4D4(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCurveEnumSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  uint64_t v0;

  v0 = operator new();
  OZSplineState::OZSplineState((OZSplineState *)(v0 + 8));
  PCSingleton::PCSingleton((PCSingleton *)v0, 200);
  *(_QWORD *)v0 = &unk_1E6507728;
  OZCurveEnumSplineState::_instance = v0;
}

void sub_1B2FFB55C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_closedImpl::getInstance(OZShape::OZShape_closedImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_closedImpl::getInstance(void)::OZShape_closedImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_closedImpl::getInstance(void)::OZShape_closedImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_closedImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_closedImpl::_OZShape_closed;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_closedImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelBool *v0;

  if (!OZShape::OZShape_closedImpl::_OZShape_closed)
  {
    v0 = (OZChannelBool *)operator new();
    OZShape::OZShape_closedImpl::OZShape_closedImpl(v0);
    OZShape::OZShape_closedImpl::_OZShape_closed = (uint64_t)v0;
  }
}

void sub_1B2FFB628(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZChannelBool *OZShape::OZShape_closedImpl::OZShape_closedImpl(OZChannelBool *this)
{
  OZCurve *OZChannelBoolCurve;

  OZChannelBoolCurve = (OZCurve *)OZChannelBool::createOZChannelBoolCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelBoolCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((PCSingleton *)&this->var5, 50);
  this->var0 = (void **)&unk_1E65E9818;
  this->var5 = (PCString *)&unk_1E65E9838;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.0);
  return this;
}

void sub_1B2FFB6D4(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCurveBoolSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  uint64_t v0;

  v0 = operator new();
  OZSplineState::OZSplineState((OZSplineState *)(v0 + 8));
  PCSingleton::PCSingleton((PCSingleton *)v0, 200);
  *(_QWORD *)v0 = &unk_1E64FC040;
  OZCurveBoolSplineState::_instance = v0;
}

void sub_1B2FFB75C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_roundnessImpl::getInstance(OZShape::OZShape_roundnessImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_roundnessImpl::getInstance(void)::OZShape_roundnessImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_roundnessImpl::getInstance(void)::OZShape_roundnessImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_roundnessImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_roundnessImpl::_OZShape_roundness;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_roundnessImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_roundnessImpl *v0;

  if (!OZShape::OZShape_roundnessImpl::_OZShape_roundness)
  {
    v0 = (OZShape::OZShape_roundnessImpl *)operator new();
    OZShape::OZShape_roundnessImpl::OZShape_roundnessImpl(v0);
    OZShape::OZShape_roundnessImpl::_OZShape_roundness = (uint64_t)v0;
  }
}

void sub_1B2FFB828(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_roundnessImpl *OZShape::OZShape_roundnessImpl::OZShape_roundnessImpl(OZShape::OZShape_roundnessImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 1, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_roundnessImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9890;
  *((_QWORD *)this + 5) = &unk_1E65E98B0;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1000.0);
  return this;
}

void sub_1B2FFB8D8(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_roundnessInfo::getInstance(OZShape::OZShape_roundnessInfo *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_roundnessInfo::getInstance(void)::OZShape_roundnessInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_roundnessInfo::getInstance(void)::OZShape_roundnessInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_roundnessInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_roundnessInfo::_OZShape_roundnessInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_roundnessInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_roundnessInfo *v0;

  if (!OZShape::OZShape_roundnessInfo::_OZShape_roundnessInfo)
  {
    v0 = (OZShape::OZShape_roundnessInfo *)operator new();
    OZShape::OZShape_roundnessInfo::OZShape_roundnessInfo(v0);
    OZShape::OZShape_roundnessInfo::_OZShape_roundnessInfo = (uint64_t)v0;
  }
}

void sub_1B2FFB9A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_roundnessInfo *OZShape::OZShape_roundnessInfo::OZShape_roundnessInfo(OZShape::OZShape_roundnessInfo *this)
{
  PCString v3;

  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 50.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_roundnessInfo *)((char *)this + 80), 100);
  *(_QWORD *)this = &unk_1E65E9908;
  *((_QWORD *)this + 10) = &unk_1E65E9928;
  return this;
}

void sub_1B2FFBA50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo *v10;

  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZChannelUint32::createOZChannelUint32Info(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelUint32Info *v0;

  if (!OZChannelUint32::_OZChannelUint32Info)
  {
    v0 = (OZChannelUint32Info *)operator new();
    OZChannelUint32Info::OZChannelUint32Info(v0);
    OZChannelUint32::_OZChannelUint32Info = (uint64_t)v0;
  }
}

void sub_1B2FFBAC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

void OZChannelUint32Info::OZChannelUint32Info(OZChannelUint32Info *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 4294967300.0, 1.0, 1.0, 1.0, "");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &off_1E65E9980;
  *((_QWORD *)this + 10) = &unk_1E65E99A0;
}

void sub_1B2FFBB48(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

void OZChannelUint32Info::~OZChannelUint32Info(OZChannelUint32Info *this)
{
  PCSingleton::~PCSingleton((OZChannelUint32Info *)((char *)this + 80));
  OZChannelInfo::~OZChannelInfo((OZChannelInfo *)this);
}

{
  PCSingleton::~PCSingleton((OZChannelUint32Info *)((char *)this + 80));
  OZChannelInfo::~OZChannelInfo((OZChannelInfo *)this);
  JUMPOUT(0x1B5E29170);
}

void `non-virtual thunk to'OZChannelUint32Info::~OZChannelUint32Info(OZChannelUint32Info *this)
{
  OZChannelInfo *v1;

  v1 = (OZChannelInfo *)((char *)this - 80);
  PCSingleton::~PCSingleton(this);
  OZChannelInfo::~OZChannelInfo(v1);
}

{
  OZChannelInfo *v1;

  v1 = (OZChannelInfo *)((char *)this - 80);
  PCSingleton::~PCSingleton(this);
  OZChannelInfo::~OZChannelInfo(v1);
  JUMPOUT(0x1B5E29170);
}

void OZChannelUint32Impl::~OZChannelUint32Impl(OZChannelUint32Impl *this)
{
  PCSingleton::~PCSingleton((OZChannelUint32Impl *)((char *)this + 40));
  OZChannelImpl::~OZChannelImpl((OZChannelImpl *)this);
}

{
  PCSingleton::~PCSingleton((OZChannelUint32Impl *)((char *)this + 40));
  OZChannelImpl::~OZChannelImpl((OZChannelImpl *)this);
  JUMPOUT(0x1B5E29170);
}

void `non-virtual thunk to'OZChannelUint32Impl::~OZChannelUint32Impl(OZChannelUint32Impl *this)
{
  OZChannelImpl *v1;

  v1 = (OZChannelImpl *)((char *)this - 40);
  PCSingleton::~PCSingleton(this);
  OZChannelImpl::~OZChannelImpl(v1);
}

{
  OZChannelImpl *v1;

  v1 = (OZChannelImpl *)((char *)this - 40);
  PCSingleton::~PCSingleton(this);
  OZChannelImpl::~OZChannelImpl(v1);
  JUMPOUT(0x1B5E29170);
}

void std::__call_once_param<std::tuple<OZCurveIntSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  uint64_t v0;

  v0 = operator new();
  OZSplineState::OZSplineState((OZSplineState *)(v0 + 8));
  PCSingleton::PCSingleton((PCSingleton *)v0, 200);
  *(_QWORD *)v0 = &unk_1E64F9A80;
  OZCurveIntSplineState::_instance = v0;
}

void sub_1B2FFBD40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_initialPositionImpl::getInstance(OZShape::OZShape_initialPositionImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_initialPositionImpl::getInstance(void)::OZShape_initialPositionImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_initialPositionImpl::getInstance(void)::OZShape_initialPositionImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_initialPositionImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_initialPositionImpl::_OZShape_initialPosition;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_initialPositionImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_initialPositionImpl *v0;

  if (!OZShape::OZShape_initialPositionImpl::_OZShape_initialPosition)
  {
    v0 = (OZShape::OZShape_initialPositionImpl *)operator new();
    OZShape::OZShape_initialPositionImpl::OZShape_initialPositionImpl(v0);
    OZShape::OZShape_initialPositionImpl::_OZShape_initialPosition = (uint64_t)v0;
  }
}

void sub_1B2FFBE0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_initialPositionImpl *OZShape::OZShape_initialPositionImpl::OZShape_initialPositionImpl(OZShape::OZShape_initialPositionImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_initialPositionImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9A00;
  *((_QWORD *)this + 5) = &unk_1E65E9A20;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFBEC0(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_pixelAspectRatioImpl::getInstance(OZShape::OZShape_pixelAspectRatioImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::OZShape_pixelAspectRatioImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::OZShape_pixelAspectRatioImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_pixelAspectRatioImpl::_OZShape_pixelAspectRatio;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_pixelAspectRatioImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_pixelAspectRatioImpl *v0;

  if (!OZShape::OZShape_pixelAspectRatioImpl::_OZShape_pixelAspectRatio)
  {
    v0 = (OZShape::OZShape_pixelAspectRatioImpl *)operator new();
    OZShape::OZShape_pixelAspectRatioImpl::OZShape_pixelAspectRatioImpl(v0);
    OZShape::OZShape_pixelAspectRatioImpl::_OZShape_pixelAspectRatio = (uint64_t)v0;
  }
}

void sub_1B2FFBF8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_pixelAspectRatioImpl *OZShape::OZShape_pixelAspectRatioImpl::OZShape_pixelAspectRatioImpl(OZShape::OZShape_pixelAspectRatioImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 1.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 1.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_pixelAspectRatioImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9A78;
  *((_QWORD *)this + 5) = &unk_1E65E9A98;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFC040(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeWidthImpl::getInstance(OZShape::OZShape_strokeWidthImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeWidthImpl::getInstance(void)::OZShape_strokeWidthImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeWidthImpl::getInstance(void)::OZShape_strokeWidthImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeWidthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeWidthImpl::_OZShape_strokeWidth;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeWidthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelUint32 *v0;

  if (!OZShape::OZShape_strokeWidthImpl::_OZShape_strokeWidth)
  {
    v0 = (OZChannelUint32 *)operator new();
    OZShape::OZShape_strokeWidthImpl::OZShape_strokeWidthImpl(v0);
    OZShape::OZShape_strokeWidthImpl::_OZShape_strokeWidth = (uint64_t)v0;
  }
}

void sub_1B2FFC10C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZChannelUint32 *OZShape::OZShape_strokeWidthImpl::OZShape_strokeWidthImpl(OZChannelUint32 *this)
{
  OZCurve *OZChannelUint32Curve;

  OZChannelUint32Curve = (OZCurve *)OZChannelUint32::createOZChannelUint32Curve(this, 2.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelUint32Curve, 2.0, 1, 1);
  PCSingleton::PCSingleton((PCSingleton *)&this->var5, 50);
  this->var0 = (void **)&unk_1E65E9AF0;
  this->var5 = (PCString *)&unk_1E65E9B10;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 4294967300.0);
  return this;
}

void sub_1B2FFC1BC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeWidthInfo::getInstance(OZShape::OZShape_strokeWidthInfo *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeWidthInfo::getInstance(void)::OZShape_strokeWidthInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeWidthInfo::getInstance(void)::OZShape_strokeWidthInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeWidthInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeWidthInfo::_OZShape_strokeWidthInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeWidthInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_strokeWidthInfo *v0;

  if (!OZShape::OZShape_strokeWidthInfo::_OZShape_strokeWidthInfo)
  {
    v0 = (OZShape::OZShape_strokeWidthInfo *)operator new();
    OZShape::OZShape_strokeWidthInfo::OZShape_strokeWidthInfo(v0);
    OZShape::OZShape_strokeWidthInfo::_OZShape_strokeWidthInfo = (uint64_t)v0;
  }
}

void sub_1B2FFC288(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_strokeWidthInfo *OZShape::OZShape_strokeWidthInfo::OZShape_strokeWidthInfo(OZShape::OZShape_strokeWidthInfo *this)
{
  PCString v3;

  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 1.0, 100.0, 1.0, 1.0, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_strokeWidthInfo *)((char *)this + 80), 100);
  *(_QWORD *)this = &unk_1E65E9B68;
  *((_QWORD *)this + 10) = &unk_1E65E9B88;
  return this;
}

void sub_1B2FFC334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo *v10;

  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeJointImpl::getInstance(OZShape::OZShape_strokeJointImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeJointImpl::getInstance(void)::OZShape_strokeJointImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeJointImpl::getInstance(void)::OZShape_strokeJointImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeJointImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeJointImpl::_OZShape_strokeJoint;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeJointImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_strokeJointImpl *v0;

  if (!OZShape::OZShape_strokeJointImpl::_OZShape_strokeJoint)
  {
    v0 = (OZShape::OZShape_strokeJointImpl *)operator new();
    OZShape::OZShape_strokeJointImpl::OZShape_strokeJointImpl(v0);
    OZShape::OZShape_strokeJointImpl::_OZShape_strokeJoint = (uint64_t)v0;
  }
}

void sub_1B2FFC400(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_strokeJointImpl *OZShape::OZShape_strokeJointImpl::OZShape_strokeJointImpl(OZShape::OZShape_strokeJointImpl *this)
{
  OZCurve *OZChannelEnumCurve;

  OZChannelEnumCurve = (OZCurve *)OZChannelEnum::createOZChannelEnumCurve(this, 1.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelEnumCurve, 1.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_strokeJointImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9BE0;
  *((_QWORD *)this + 5) = &unk_1E65E9C00;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 4294967300.0);
  return this;
}

void sub_1B2FFC4B0(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeLeftCapImpl::getInstance(OZShape::OZShape_strokeLeftCapImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::OZShape_strokeLeftCapImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::OZShape_strokeLeftCapImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeLeftCapImpl::_OZShape_strokeLeftCap;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeLeftCapImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_strokeLeftCapImpl *v0;

  if (!OZShape::OZShape_strokeLeftCapImpl::_OZShape_strokeLeftCap)
  {
    v0 = (OZShape::OZShape_strokeLeftCapImpl *)operator new();
    OZShape::OZShape_strokeLeftCapImpl::OZShape_strokeLeftCapImpl(v0);
    OZShape::OZShape_strokeLeftCapImpl::_OZShape_strokeLeftCap = (uint64_t)v0;
  }
}

void sub_1B2FFC57C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_strokeLeftCapImpl *OZShape::OZShape_strokeLeftCapImpl::OZShape_strokeLeftCapImpl(OZShape::OZShape_strokeLeftCapImpl *this)
{
  OZCurve *OZChannelEnumCurve;

  OZChannelEnumCurve = (OZCurve *)OZChannelEnum::createOZChannelEnumCurve(this, 1.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelEnumCurve, 1.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_strokeLeftCapImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9C58;
  *((_QWORD *)this + 5) = &unk_1E65E9C78;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 4294967300.0);
  return this;
}

void sub_1B2FFC62C(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeRightCapImpl::getInstance(OZShape::OZShape_strokeRightCapImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeRightCapImpl::getInstance(void)::OZShape_strokeRightCapImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeRightCapImpl::getInstance(void)::OZShape_strokeRightCapImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeRightCapImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeRightCapImpl::_OZShape_strokeRightCap;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeRightCapImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_strokeRightCapImpl *v0;

  if (!OZShape::OZShape_strokeRightCapImpl::_OZShape_strokeRightCap)
  {
    v0 = (OZShape::OZShape_strokeRightCapImpl *)operator new();
    OZShape::OZShape_strokeRightCapImpl::OZShape_strokeRightCapImpl(v0);
    OZShape::OZShape_strokeRightCapImpl::_OZShape_strokeRightCap = (uint64_t)v0;
  }
}

void sub_1B2FFC6F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_strokeRightCapImpl *OZShape::OZShape_strokeRightCapImpl::OZShape_strokeRightCapImpl(OZShape::OZShape_strokeRightCapImpl *this)
{
  OZCurve *OZChannelEnumCurve;

  OZChannelEnumCurve = (OZCurve *)OZChannelEnum::createOZChannelEnumCurve(this, 1.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelEnumCurve, 1.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_strokeRightCapImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9CD0;
  *((_QWORD *)this + 5) = &unk_1E65E9CF0;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 4294967300.0);
  return this;
}

void sub_1B2FFC7A8(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(OZShape::OZShape_strokeCapArrowLengthImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::OZShape_strokeCapArrowLengthImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::OZShape_strokeCapArrowLengthImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowLengthImpl::_OZShape_strokeCapArrowLength;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowLengthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_strokeCapArrowLengthImpl *v0;

  if (!OZShape::OZShape_strokeCapArrowLengthImpl::_OZShape_strokeCapArrowLength)
  {
    v0 = (OZShape::OZShape_strokeCapArrowLengthImpl *)operator new();
    OZShape::OZShape_strokeCapArrowLengthImpl::OZShape_strokeCapArrowLengthImpl(v0);
    OZShape::OZShape_strokeCapArrowLengthImpl::_OZShape_strokeCapArrowLength = (uint64_t)v0;
  }
}

void sub_1B2FFC874(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_strokeCapArrowLengthImpl *OZShape::OZShape_strokeCapArrowLengthImpl::OZShape_strokeCapArrowLengthImpl(OZShape::OZShape_strokeCapArrowLengthImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 3.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 3.0, 1, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_strokeCapArrowLengthImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9D48;
  *((_QWORD *)this + 5) = &unk_1E65E9D68;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFC924(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(OZShape::OZShape_strokeCapArrowLengthInfo *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::OZShape_strokeCapArrowLengthInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::OZShape_strokeCapArrowLengthInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowLengthInfo::_OZShape_strokeCapArrowLengthInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowLengthInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelInfo *v0;

  if (!OZShape::OZShape_strokeCapArrowLengthInfo::_OZShape_strokeCapArrowLengthInfo)
  {
    v0 = (OZChannelInfo *)operator new();
    OZShape::OZShape_strokeCapArrowLengthInfo::OZShape_strokeCapArrowLengthInfo(v0);
    OZShape::OZShape_strokeCapArrowLengthInfo::_OZShape_strokeCapArrowLengthInfo = (uint64_t)v0;
  }
}

void sub_1B2FFC9F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZChannelInfo *OZShape::OZShape_strokeCapArrowLengthInfo::OZShape_strokeCapArrowLengthInfo(OZChannelInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo(this, 0.0, 3.0, 0.01, 0.0001, 100.0, "%");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E65E9DC0;
  *((_QWORD *)this + 10) = &unk_1E65E9DE0;
  return this;
}

void sub_1B2FFCA84(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(OZShape::OZShape_strokeCapArrowWidthImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::OZShape_strokeCapArrowWidthImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::OZShape_strokeCapArrowWidthImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowWidthImpl::_OZShape_strokeCapArrowWidth;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowWidthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_strokeCapArrowWidthImpl *v0;

  if (!OZShape::OZShape_strokeCapArrowWidthImpl::_OZShape_strokeCapArrowWidth)
  {
    v0 = (OZShape::OZShape_strokeCapArrowWidthImpl *)operator new();
    OZShape::OZShape_strokeCapArrowWidthImpl::OZShape_strokeCapArrowWidthImpl(v0);
    OZShape::OZShape_strokeCapArrowWidthImpl::_OZShape_strokeCapArrowWidth = (uint64_t)v0;
  }
}

void sub_1B2FFCB40(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_strokeCapArrowWidthImpl *OZShape::OZShape_strokeCapArrowWidthImpl::OZShape_strokeCapArrowWidthImpl(OZShape::OZShape_strokeCapArrowWidthImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 3.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 3.0, 1, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_strokeCapArrowWidthImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9E38;
  *((_QWORD *)this + 5) = &unk_1E65E9E58;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFCBF0(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(OZShape::OZShape_strokeCapArrowWidthInfo *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::OZShape_strokeCapArrowWidthInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::OZShape_strokeCapArrowWidthInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_strokeCapArrowWidthInfo::_OZShape_strokeCapArrowWidthInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_strokeCapArrowWidthInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelInfo *v0;

  if (!OZShape::OZShape_strokeCapArrowWidthInfo::_OZShape_strokeCapArrowWidthInfo)
  {
    v0 = (OZChannelInfo *)operator new();
    OZShape::OZShape_strokeCapArrowWidthInfo::OZShape_strokeCapArrowWidthInfo(v0);
    OZShape::OZShape_strokeCapArrowWidthInfo::_OZShape_strokeCapArrowWidthInfo = (uint64_t)v0;
  }
}

void sub_1B2FFCCBC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZChannelInfo *OZShape::OZShape_strokeCapArrowWidthInfo::OZShape_strokeCapArrowWidthInfo(OZChannelInfo *this)
{
  uint64_t v2;

  OZChannelInfo::OZChannelInfo(this, 0.0, 3.0, 0.01, 0.0001, 100.0, "%");
  PCSingleton::PCSingleton((PCSingleton *)(v2 + 80), 100);
  *(_QWORD *)this = &unk_1E65E9EB0;
  *((_QWORD *)this + 10) = &unk_1E65E9ED0;
  return this;
}

void sub_1B2FFCD50(_Unwind_Exception *a1)
{
  OZChannelInfo *v1;

  OZChannelInfo::~OZChannelInfo(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeRadiusImpl::getInstance(OZShape::OZShape_softEdgeRadiusImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::OZShape_softEdgeRadiusImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::OZShape_softEdgeRadiusImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeRadiusImpl::_OZShape_softEdgeRadius;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_softEdgeRadiusImpl *v0;

  if (!OZShape::OZShape_softEdgeRadiusImpl::_OZShape_softEdgeRadius)
  {
    v0 = (OZShape::OZShape_softEdgeRadiusImpl *)operator new();
    OZShape::OZShape_softEdgeRadiusImpl::OZShape_softEdgeRadiusImpl(v0);
    OZShape::OZShape_softEdgeRadiusImpl::_OZShape_softEdgeRadius = (uint64_t)v0;
  }
}

void sub_1B2FFCE0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_softEdgeRadiusImpl *OZShape::OZShape_softEdgeRadiusImpl::OZShape_softEdgeRadiusImpl(OZShape::OZShape_softEdgeRadiusImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 1, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_softEdgeRadiusImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65E9F28;
  *((_QWORD *)this + 5) = &unk_1E65E9F48;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFCEC0(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeRadiusInfo::getInstance(OZShape::OZShape_softEdgeRadiusInfo *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::OZShape_softEdgeRadiusInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::OZShape_softEdgeRadiusInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeRadiusInfo::_OZShape_softEdgeRadiusInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_softEdgeRadiusInfo *v0;

  if (!OZShape::OZShape_softEdgeRadiusInfo::_OZShape_softEdgeRadiusInfo)
  {
    v0 = (OZShape::OZShape_softEdgeRadiusInfo *)operator new();
    OZShape::OZShape_softEdgeRadiusInfo::OZShape_softEdgeRadiusInfo(v0);
    OZShape::OZShape_softEdgeRadiusInfo::_OZShape_softEdgeRadiusInfo = (uint64_t)v0;
  }
}

void sub_1B2FFCF8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_softEdgeRadiusInfo *OZShape::OZShape_softEdgeRadiusInfo::OZShape_softEdgeRadiusInfo(OZShape::OZShape_softEdgeRadiusInfo *this)
{
  PCString v3;

  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -100.0, 100.0, 1.0, 0.001, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_softEdgeRadiusInfo *)((char *)this + 80), 100);
  *(_QWORD *)this = &unk_1E65E9FA0;
  *((_QWORD *)this + 10) = &unk_1E65E9FC0;
  return this;
}

void sub_1B2FFD040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo *v10;

  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeFalloffImpl::getInstance(OZShape::OZShape_softEdgeFalloffImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::OZShape_softEdgeFalloffImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::OZShape_softEdgeFalloffImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeFalloffImpl::_OZShape_softEdgeFalloff;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeFalloffImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_softEdgeFalloffImpl *v0;

  if (!OZShape::OZShape_softEdgeFalloffImpl::_OZShape_softEdgeFalloff)
  {
    v0 = (OZShape::OZShape_softEdgeFalloffImpl *)operator new();
    OZShape::OZShape_softEdgeFalloffImpl::OZShape_softEdgeFalloffImpl(v0);
    OZShape::OZShape_softEdgeFalloffImpl::_OZShape_softEdgeFalloff = (uint64_t)v0;
  }
}

void sub_1B2FFD10C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_softEdgeFalloffImpl *OZShape::OZShape_softEdgeFalloffImpl::OZShape_softEdgeFalloffImpl(OZShape::OZShape_softEdgeFalloffImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 1, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_softEdgeFalloffImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA018;
  *((_QWORD *)this + 5) = &unk_1E65EA038;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFD1C0(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeFalloffInfo::getInstance(OZShape::OZShape_softEdgeFalloffInfo *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::OZShape_softEdgeFalloffInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::OZShape_softEdgeFalloffInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeFalloffInfo::_OZShape_softEdgeFalloffInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeFalloffInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_softEdgeFalloffInfo *v0;

  if (!OZShape::OZShape_softEdgeFalloffInfo::_OZShape_softEdgeFalloffInfo)
  {
    v0 = (OZShape::OZShape_softEdgeFalloffInfo *)operator new();
    OZShape::OZShape_softEdgeFalloffInfo::OZShape_softEdgeFalloffInfo(v0);
    OZShape::OZShape_softEdgeFalloffInfo::_OZShape_softEdgeFalloffInfo = (uint64_t)v0;
  }
}

void sub_1B2FFD28C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_softEdgeFalloffInfo *OZShape::OZShape_softEdgeFalloffInfo::OZShape_softEdgeFalloffInfo(OZShape::OZShape_softEdgeFalloffInfo *this)
{
  PCString v3;

  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, -100.0, 100.0, 1.0, 0.001, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_softEdgeFalloffInfo *)((char *)this + 80), 100);
  *(_QWORD *)this = &unk_1E65EA090;
  *((_QWORD *)this + 10) = &unk_1E65EA0B0;
  return this;
}

void sub_1B2FFD340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo *v10;

  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_softEdgeKernelImpl::getInstance(OZShape::OZShape_softEdgeKernelImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::OZShape_softEdgeKernelImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::OZShape_softEdgeKernelImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_softEdgeKernelImpl::_OZShape_softEdgeKernel;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_softEdgeKernelImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_softEdgeKernelImpl *v0;

  if (!OZShape::OZShape_softEdgeKernelImpl::_OZShape_softEdgeKernel)
  {
    v0 = (OZShape::OZShape_softEdgeKernelImpl *)operator new();
    OZShape::OZShape_softEdgeKernelImpl::OZShape_softEdgeKernelImpl(v0);
    OZShape::OZShape_softEdgeKernelImpl::_OZShape_softEdgeKernel = (uint64_t)v0;
  }
}

void sub_1B2FFD40C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_softEdgeKernelImpl *OZShape::OZShape_softEdgeKernelImpl::OZShape_softEdgeKernelImpl(OZShape::OZShape_softEdgeKernelImpl *this)
{
  OZCurve *OZChannelEnumCurve;

  OZChannelEnumCurve = (OZCurve *)OZChannelEnum::createOZChannelEnumCurve(this, 3.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelEnumCurve, 3.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_softEdgeKernelImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA108;
  *((_QWORD *)this + 5) = &unk_1E65EA128;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 4294967300.0);
  return this;
}

void sub_1B2FFD4BC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_ellipseCurvatureImpl::getInstance(OZShape::OZShape_ellipseCurvatureImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::OZShape_ellipseCurvatureImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::OZShape_ellipseCurvatureImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_ellipseCurvatureImpl::_OZShape_ellipseCurvature;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_ellipseCurvatureImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelPercent *v0;

  if (!OZShape::OZShape_ellipseCurvatureImpl::_OZShape_ellipseCurvature)
  {
    v0 = (OZChannelPercent *)operator new();
    OZShape::OZShape_ellipseCurvatureImpl::OZShape_ellipseCurvatureImpl(v0);
    OZShape::OZShape_ellipseCurvatureImpl::_OZShape_ellipseCurvature = (uint64_t)v0;
  }
}

void sub_1B2FFD588(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZChannelPercent *OZShape::OZShape_ellipseCurvatureImpl::OZShape_ellipseCurvatureImpl(OZChannelPercent *this)
{
  OZCurve *OZChannelPercentCurve;

  OZChannelPercentCurve = (OZCurve *)OZChannelPercent::createOZChannelPercentCurve(this, 0.5);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelPercentCurve, 0.5, 1, 1);
  PCSingleton::PCSingleton((PCSingleton *)&this->var5, 50);
  this->var0 = (void **)&unk_1E65EA180;
  this->var5 = (PCString *)&unk_1E65EA1A0;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.0);
  return this;
}

void sub_1B2FFD634(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void std::__call_once_param<std::tuple<OZCurvePercentSplineState::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  uint64_t v0;

  v0 = operator new();
  OZSplineState::OZSplineState((OZSplineState *)(v0 + 8));
  PCSingleton::PCSingleton((PCSingleton *)v0, 200);
  *(_QWORD *)v0 = &unk_1E64F8D18;
  OZCurvePercentSplineState::_instance = v0;
}

void sub_1B2FFD6BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1081C401D9FA3FDLL);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_shapeRadiusImpl::getInstance(OZShape::OZShape_shapeRadiusImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_shapeRadiusImpl::getInstance(void)::OZShape_shapeRadiusImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_shapeRadiusImpl::getInstance(void)::OZShape_shapeRadiusImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_shapeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_shapeRadiusImpl::_OZShape_shapeRadius;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_shapeRadiusImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_shapeRadiusImpl *v0;

  if (!OZShape::OZShape_shapeRadiusImpl::_OZShape_shapeRadius)
  {
    v0 = (OZShape::OZShape_shapeRadiusImpl *)operator new();
    OZShape::OZShape_shapeRadiusImpl::OZShape_shapeRadiusImpl(v0);
    OZShape::OZShape_shapeRadiusImpl::_OZShape_shapeRadius = (uint64_t)v0;
  }
}

void sub_1B2FFD788(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_shapeRadiusImpl *OZShape::OZShape_shapeRadiusImpl::OZShape_shapeRadiusImpl(OZShape::OZShape_shapeRadiusImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 1, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_shapeRadiusImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA1F8;
  *((_QWORD *)this + 5) = &unk_1E65EA218;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFD838(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_shapeRadiusInfo::getInstance(OZShape::OZShape_shapeRadiusInfo *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_shapeRadiusInfo::getInstance(void)::OZShape_shapeRadiusInfo_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_shapeRadiusInfo::getInstance(void)::OZShape_shapeRadiusInfo_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_shapeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_shapeRadiusInfo::_OZShape_shapeRadiusInfo;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_shapeRadiusInfo::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_shapeRadiusInfo *v0;

  if (!OZShape::OZShape_shapeRadiusInfo::_OZShape_shapeRadiusInfo)
  {
    v0 = (OZShape::OZShape_shapeRadiusInfo *)operator new();
    OZShape::OZShape_shapeRadiusInfo::OZShape_shapeRadiusInfo(v0);
    OZShape::OZShape_shapeRadiusInfo::_OZShape_shapeRadiusInfo = (uint64_t)v0;
  }
}

void sub_1B2FFD904(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10E1C406F995C74);
  _Unwind_Resume(a1);
}

OZShape::OZShape_shapeRadiusInfo *OZShape::OZShape_shapeRadiusInfo::OZShape_shapeRadiusInfo(OZShape::OZShape_shapeRadiusInfo *this)
{
  PCString v3;

  PCString::PCString(&v3, "");
  OZChannelInfo::OZChannelInfo((OZChannelInfo *)this, 0.0, 1000.0, 1.0, 0.01, 1.0, &v3);
  PCString::~PCString(&v3);
  PCSingleton::PCSingleton((OZShape::OZShape_shapeRadiusInfo *)((char *)this + 80), 100);
  *(_QWORD *)this = &unk_1E65EA270;
  *((_QWORD *)this + 10) = &unk_1E65EA290;
  return this;
}

void sub_1B2FFD9B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  OZChannelInfo *v10;

  OZChannelInfo::~OZChannelInfo(v10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_initialScaleXImpl::getInstance(OZShape::OZShape_initialScaleXImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_initialScaleXImpl::getInstance(void)::OZShape_initialScaleXImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_initialScaleXImpl::getInstance(void)::OZShape_initialScaleXImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_initialScaleXImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_initialScaleXImpl::_OZShape_initialScaleX;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_initialScaleXImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_initialScaleXImpl *v0;

  if (!OZShape::OZShape_initialScaleXImpl::_OZShape_initialScaleX)
  {
    v0 = (OZShape::OZShape_initialScaleXImpl *)operator new();
    OZShape::OZShape_initialScaleXImpl::OZShape_initialScaleXImpl(v0);
    OZShape::OZShape_initialScaleXImpl::_OZShape_initialScaleX = (uint64_t)v0;
  }
}

void sub_1B2FFDA80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_initialScaleXImpl *OZShape::OZShape_initialScaleXImpl::OZShape_initialScaleXImpl(OZShape::OZShape_initialScaleXImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 1.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 1.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_initialScaleXImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA2E8;
  *((_QWORD *)this + 5) = &unk_1E65EA308;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFDB34(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_initialScaleYImpl::getInstance(OZShape::OZShape_initialScaleYImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_initialScaleYImpl::getInstance(void)::OZShape_initialScaleYImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_initialScaleYImpl::getInstance(void)::OZShape_initialScaleYImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_initialScaleYImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_initialScaleYImpl::_OZShape_initialScaleY;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_initialScaleYImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_initialScaleYImpl *v0;

  if (!OZShape::OZShape_initialScaleYImpl::_OZShape_initialScaleY)
  {
    v0 = (OZShape::OZShape_initialScaleYImpl *)operator new();
    OZShape::OZShape_initialScaleYImpl::OZShape_initialScaleYImpl(v0);
    OZShape::OZShape_initialScaleYImpl::_OZShape_initialScaleY = (uint64_t)v0;
  }
}

void sub_1B2FFDC00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_initialScaleYImpl *OZShape::OZShape_initialScaleYImpl::OZShape_initialScaleYImpl(OZShape::OZShape_initialScaleYImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 1.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 1.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_initialScaleYImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA360;
  *((_QWORD *)this + 5) = &unk_1E65EA380;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFDCB4(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(OZShape::OZShape_disableAntialiasingiOSImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::OZShape_disableAntialiasingiOSImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::OZShape_disableAntialiasingiOSImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_disableAntialiasingiOSImpl::_OZShape_disableAntialiasingiOS;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_disableAntialiasingiOSImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelBool *v0;

  if (!OZShape::OZShape_disableAntialiasingiOSImpl::_OZShape_disableAntialiasingiOS)
  {
    v0 = (OZChannelBool *)operator new();
    OZShape::OZShape_disableAntialiasingiOSImpl::OZShape_disableAntialiasingiOSImpl(v0);
    OZShape::OZShape_disableAntialiasingiOSImpl::_OZShape_disableAntialiasingiOS = (uint64_t)v0;
  }
}

void sub_1B2FFDD80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZChannelBool *OZShape::OZShape_disableAntialiasingiOSImpl::OZShape_disableAntialiasingiOSImpl(OZChannelBool *this)
{
  OZCurve *OZChannelBoolCurve;

  OZChannelBoolCurve = (OZCurve *)OZChannelBool::createOZChannelBoolCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelBoolCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((PCSingleton *)&this->var5, 50);
  this->var0 = (void **)&unk_1E65EA3D8;
  this->var5 = (PCString *)&unk_1E65EA3F8;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFDE30(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_fixedFeatherWidthImpl::getInstance(OZShape::OZShape_fixedFeatherWidthImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::OZShape_fixedFeatherWidthImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::OZShape_fixedFeatherWidthImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_fixedFeatherWidthImpl::_OZShape_fixedFeatherWidth;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_fixedFeatherWidthImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZChannelBool *v0;

  if (!OZShape::OZShape_fixedFeatherWidthImpl::_OZShape_fixedFeatherWidth)
  {
    v0 = (OZChannelBool *)operator new();
    OZShape::OZShape_fixedFeatherWidthImpl::OZShape_fixedFeatherWidthImpl(v0);
    OZShape::OZShape_fixedFeatherWidthImpl::_OZShape_fixedFeatherWidth = (uint64_t)v0;
  }
}

void sub_1B2FFDEFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZChannelBool *OZShape::OZShape_fixedFeatherWidthImpl::OZShape_fixedFeatherWidthImpl(OZChannelBool *this)
{
  OZCurve *OZChannelBoolCurve;

  OZChannelBoolCurve = (OZCurve *)OZChannelBool::createOZChannelBoolCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelBoolCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((PCSingleton *)&this->var5, 50);
  this->var0 = (void **)&unk_1E65EA450;
  this->var5 = (PCString *)&unk_1E65EA470;
  OZChannelImpl::setMin((OZChannelImpl *)this, 0.0);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFDFAC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxTopLeftImpl::getInstance(OZShape::OZShape_boxTopLeftImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_boxTopLeftImpl::getInstance(void)::OZShape_boxTopLeftImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_boxTopLeftImpl::getInstance(void)::OZShape_boxTopLeftImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxTopLeftImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxTopLeftImpl::_OZShape_boxTopLeft;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxTopLeftImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_boxTopLeftImpl *v0;

  if (!OZShape::OZShape_boxTopLeftImpl::_OZShape_boxTopLeft)
  {
    v0 = (OZShape::OZShape_boxTopLeftImpl *)operator new();
    OZShape::OZShape_boxTopLeftImpl::OZShape_boxTopLeftImpl(v0);
    OZShape::OZShape_boxTopLeftImpl::_OZShape_boxTopLeft = (uint64_t)v0;
  }
}

void sub_1B2FFE078(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_boxTopLeftImpl *OZShape::OZShape_boxTopLeftImpl::OZShape_boxTopLeftImpl(OZShape::OZShape_boxTopLeftImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_boxTopLeftImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA4C8;
  *((_QWORD *)this + 5) = &unk_1E65EA4E8;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFE12C(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxTopRightImpl::getInstance(OZShape::OZShape_boxTopRightImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_boxTopRightImpl::getInstance(void)::OZShape_boxTopRightImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_boxTopRightImpl::getInstance(void)::OZShape_boxTopRightImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxTopRightImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxTopRightImpl::_OZShape_boxTopRight;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxTopRightImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_boxTopRightImpl *v0;

  if (!OZShape::OZShape_boxTopRightImpl::_OZShape_boxTopRight)
  {
    v0 = (OZShape::OZShape_boxTopRightImpl *)operator new();
    OZShape::OZShape_boxTopRightImpl::OZShape_boxTopRightImpl(v0);
    OZShape::OZShape_boxTopRightImpl::_OZShape_boxTopRight = (uint64_t)v0;
  }
}

void sub_1B2FFE1F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_boxTopRightImpl *OZShape::OZShape_boxTopRightImpl::OZShape_boxTopRightImpl(OZShape::OZShape_boxTopRightImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_boxTopRightImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA540;
  *((_QWORD *)this + 5) = &unk_1E65EA560;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFE2AC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxBottomLeftImpl::getInstance(OZShape::OZShape_boxBottomLeftImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::OZShape_boxBottomLeftImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::OZShape_boxBottomLeftImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxBottomLeftImpl::_OZShape_boxBottomLeft;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxBottomLeftImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_boxBottomLeftImpl *v0;

  if (!OZShape::OZShape_boxBottomLeftImpl::_OZShape_boxBottomLeft)
  {
    v0 = (OZShape::OZShape_boxBottomLeftImpl *)operator new();
    OZShape::OZShape_boxBottomLeftImpl::OZShape_boxBottomLeftImpl(v0);
    OZShape::OZShape_boxBottomLeftImpl::_OZShape_boxBottomLeft = (uint64_t)v0;
  }
}

void sub_1B2FFE378(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_boxBottomLeftImpl *OZShape::OZShape_boxBottomLeftImpl::OZShape_boxBottomLeftImpl(OZShape::OZShape_boxBottomLeftImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_boxBottomLeftImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA5B8;
  *((_QWORD *)this + 5) = &unk_1E65EA5D8;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFE42C(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxBottomRightImpl::getInstance(OZShape::OZShape_boxBottomRightImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_boxBottomRightImpl::getInstance(void)::OZShape_boxBottomRightImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_boxBottomRightImpl::getInstance(void)::OZShape_boxBottomRightImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxBottomRightImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxBottomRightImpl::_OZShape_boxBottomRight;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxBottomRightImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_boxBottomRightImpl *v0;

  if (!OZShape::OZShape_boxBottomRightImpl::_OZShape_boxBottomRight)
  {
    v0 = (OZShape::OZShape_boxBottomRightImpl *)operator new();
    OZShape::OZShape_boxBottomRightImpl::OZShape_boxBottomRightImpl(v0);
    OZShape::OZShape_boxBottomRightImpl::_OZShape_boxBottomRight = (uint64_t)v0;
  }
}

void sub_1B2FFE4F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_boxBottomRightImpl *OZShape::OZShape_boxBottomRightImpl::OZShape_boxBottomRightImpl(OZShape::OZShape_boxBottomRightImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_boxBottomRightImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA630;
  *((_QWORD *)this + 5) = &unk_1E65EA650;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFE5AC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxRotationImpl::getInstance(OZShape::OZShape_boxRotationImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_boxRotationImpl::getInstance(void)::OZShape_boxRotationImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_boxRotationImpl::getInstance(void)::OZShape_boxRotationImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxRotationImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxRotationImpl::_OZShape_boxRotation;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxRotationImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_boxRotationImpl *v0;

  if (!OZShape::OZShape_boxRotationImpl::_OZShape_boxRotation)
  {
    v0 = (OZShape::OZShape_boxRotationImpl *)operator new();
    OZShape::OZShape_boxRotationImpl::OZShape_boxRotationImpl(v0);
    OZShape::OZShape_boxRotationImpl::_OZShape_boxRotation = (uint64_t)v0;
  }
}

void sub_1B2FFE678(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_boxRotationImpl *OZShape::OZShape_boxRotationImpl::OZShape_boxRotationImpl(OZShape::OZShape_boxRotationImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_boxRotationImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA6A8;
  *((_QWORD *)this + 5) = &unk_1E65EA6C8;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFE72C(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t OZShape::OZShape_boxPivotImpl::getInstance(OZShape::OZShape_boxPivotImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  v1 = atomic_load(&OZShape::OZShape_boxPivotImpl::getInstance(void)::OZShape_boxPivotImpl_once);
  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
    std::__call_once(&OZShape::OZShape_boxPivotImpl::getInstance(void)::OZShape_boxPivotImpl_once, &v4, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<OZShape::OZShape_boxPivotImpl::getInstance(void)::{lambda(void)#1} &&>>);
  }
  return OZShape::OZShape_boxPivotImpl::_OZShape_boxPivot;
}

void std::__call_once_param<std::tuple<OZShape::OZShape_boxPivotImpl::getInstance(void)::{lambda(void)#1} &&>>::__execute[abi:ne180100]<>()
{
  OZShape::OZShape_boxPivotImpl *v0;

  if (!OZShape::OZShape_boxPivotImpl::_OZShape_boxPivot)
  {
    v0 = (OZShape::OZShape_boxPivotImpl *)operator new();
    OZShape::OZShape_boxPivotImpl::OZShape_boxPivotImpl(v0);
    OZShape::OZShape_boxPivotImpl::_OZShape_boxPivot = (uint64_t)v0;
  }
}

void sub_1B2FFE7F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShape::OZShape_boxPivotImpl *OZShape::OZShape_boxPivotImpl::OZShape_boxPivotImpl(OZShape::OZShape_boxPivotImpl *this)
{
  OZCurve *OZChannelDoubleCurve;

  OZChannelDoubleCurve = (OZCurve *)OZChannelDouble::createOZChannelDoubleCurve(this, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, OZChannelDoubleCurve, 0.0, 0, 1);
  PCSingleton::PCSingleton((OZShape::OZShape_boxPivotImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA720;
  *((_QWORD *)this + 5) = &unk_1E65EA740;
  OZChannelImpl::setMin((OZChannelImpl *)this, -1.79769313e308);
  OZChannelImpl::setMax((OZChannelImpl *)this, 1.79769313e308);
  return this;
}

void sub_1B2FFE8AC(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

void OZShapeReparametrizedContour::~OZShapeReparametrizedContour(OZShapeReparametrizedContour *this)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = *((_QWORD *)this + 48);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 48) = 0;
  }
  v3 = (void *)*((_QWORD *)this + 56);
  if (v3)
  {
    *((_QWORD *)this + 57) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 53);
  if (v4)
  {
    *((_QWORD *)this + 54) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 50);
  if (v5)
  {
    *((_QWORD *)this + 51) = v5;
    operator delete(v5);
  }
  OZShapeContour::~OZShapeContour(this);
}

void OZShapeContour::~OZShapeContour(OZShapeContour *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v2 = (void *)*((_QWORD *)this + 45);
  if (v2)
  {
    *((_QWORD *)this + 46) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 42);
  if (v3)
  {
    *((_QWORD *)this + 43) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 39);
  if (v4)
  {
    *((_QWORD *)this + 40) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 36);
  if (v5)
  {
    *((_QWORD *)this + 37) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 33);
  if (v6)
  {
    *((_QWORD *)this + 34) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 30);
  if (v7)
  {
    *((_QWORD *)this + 31) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 27);
  if (v8)
  {
    *((_QWORD *)this + 28) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 24);
  if (v9)
  {
    *((_QWORD *)this + 25) = v9;
    operator delete(v9);
  }
}

uint64_t OZShape::didAddVertex(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
}

void *OZShape::addVertex(OZShape *this, CMTime *a2, double a3, double a4)
{
  void *v5;
  uint64_t v6;

  v5 = OZChannelCurve::addVertex((OZShape *)((char *)this + 208), a2, a3, a4);
  (*(void (**)(OZShape *, void *, uint64_t))(*(_QWORD *)this + 88))(this, v5, v6);
  (*(void (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
  return v5;
}

uint64_t OZShape::addVertices(uint64_t a1, const CMTime *a2, double **a3)
{
  OZChannelCurve::addVertices(a1 + 208, a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 144))(a1, 1, 1);
}

uint64_t OZShape::openCurve(uint64_t a1, void **a2)
{
  OZChannelShape *v3;

  v3 = (OZChannelShape *)(a1 + 208);
  if (a2)
  {
    OZChannelCurve::openCurve(a1 + 208, *a2, a2[1]);
    OZChannelShape::refreshAnimation(v3);
  }
  else
  {
    OZChannelCurve::openCurve((OZChannelCurve *)(a1 + 208));
  }
  OZChannel::setValue((OZChannel *)(a1 + 1328), MEMORY[0x1E0CA2E68], 0.0, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 144))(a1, 1, 1);
}

uint64_t OZShape::deleteAll(OZShape *this)
{
  (*(void (**)(OZShape *))(*(_QWORD *)this + 104))(this);
  OZChannelCurve::deleteAllVertices((OZShape *)((char *)this + 208));
  OZShape::openCurve((uint64_t)this, 0);
  OZChannel::setValue((OZChannel *)((char *)this + 14280), MEMORY[0x1E0CA2E68], 0.0, 0);
  return (*(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
}

CGColorSpace **OZShape::closeCurve(OZShape *this, const CMTime *a2)
{
  _QWORD *v4;
  uint64_t CurrentRenderParams;
  double v6;
  _OWORD v8[5];
  CGColorSpaceRef v9;
  int v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CGColorSpaceRef space;
  int v17;

  OZShapeRenderState::OZShapeRenderState((OZShapeRenderState *)&v11);
  v11 = *(_OWORD *)&a2->value;
  *(_QWORD *)&v12 = a2->epoch;
  OZChannelCurve::closeCurve((OZShape *)((char *)this + 208));
  v4 = (_QWORD *)*((_QWORD *)this + 59);
  if (v4 && (int)((v4[1] - *v4) >> 3) >= 6)
  {
    v8[2] = v13;
    v8[3] = v14;
    v8[4] = v15;
    v8[0] = v11;
    v8[1] = v12;
    v9 = space;
    if (space)
      PCCFRefTraits<CGColorSpace *>::retain(space);
    v10 = v17;
    CurrentRenderParams = OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v8);
    v6 = OZShape::calculatePolygonArea((uint64_t)this, (CMTime *)&v11, CurrentRenderParams, 0);
    PCCFRef<CGColorSpace *>::~PCCFRef(&v9);
    if (v6 > 0.0)
      OZChannelCurve::reverseWindingOrder((OZShape *)((char *)this + 208));
  }
  OZChannel::setValue((OZChannel *)((char *)this + 1328), MEMORY[0x1E0CA2E68], 1.0, 0);
  (*(void (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&space);
}

void sub_1B2FFEC9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,CGColorSpace *a31)
{
  CGColorSpace **v31;

  PCCFRef<CGColorSpace *>::~PCCFRef(v31);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a31);
  _Unwind_Resume(a1);
}

CGColorSpace **OZShape::finishCurve(OZShape *this, const CMTime *a2, int a3)
{
  uint64_t CurrentRenderParams;
  OZShapeRenderParams *v7;
  uint64_t Contour;
  float64x2_t v14;
  _QWORD *v15;
  uint64_t v16;
  double v17;
  _OWORD v19[5];
  CGColorSpace *v20;
  int v21;
  __int128 v22;
  CMTimeEpoch epoch;
  _OWORD v24[5];
  CGColorSpace *v25;
  int v26;
  _OWORD v27[5];
  CGColorSpace *v28;
  int v29;
  char *v30;
  char v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  CGColorSpace *v37;
  int v38;

  OZShapeRenderState::OZShapeRenderState((OZShapeRenderState *)&v32);
  v32 = *(_OWORD *)&a2->value;
  *(_QWORD *)&v33 = a2->epoch;
  OZChannel::setValue((OZChannel *)((char *)this + 14280), MEMORY[0x1E0CA2E68], 1.0, 0);
  v30 = (char *)this + 8;
  PCMutex::lock((PCMutex *)((char *)this + 8));
  v31 = 1;
  v27[2] = v34;
  v27[3] = v35;
  v27[4] = v36;
  v27[0] = v32;
  v27[1] = v33;
  v28 = v37;
  if (v37)
    PCCFRefTraits<CGColorSpace *>::retain(v37);
  v29 = v38;
  CurrentRenderParams = OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v27);
  (*(void (**)(OZShape *, __int128 *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)this + 64))(this, &v32, CurrentRenderParams, 0, 1);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v28);
  OZShape::calculateBounds(this, (const OZShapeRenderState *)&v32);
  if (a3)
  {
    if (!OZShape::isGeometricShape(this))
    {
      v24[2] = v34;
      v24[3] = v35;
      v24[4] = v36;
      v24[0] = v32;
      v24[1] = v33;
      v25 = v37;
      if (v37)
        PCCFRefTraits<CGColorSpace *>::retain(v37);
      v26 = v38;
      v7 = (OZShapeRenderParams *)OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v24);
      Contour = OZShape::getContour(this, (const CMTime *)&v32, v7);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v25);
      __asm { FMOV            V2.2D, #0.5 }
      v14 = vaddq_f64(*(float64x2_t *)(Contour + 24), vmulq_f64(*(float64x2_t *)(Contour + 40), _Q2));
      *(float64x2_t *)((char *)this + 2648) = v14;
      OZChannelCurve::offsetCurve((OZShape *)((char *)this + 208), a2, -v14.f64[0], -v14.f64[1]);
    }
    *((_BYTE *)this + 2640) = 1;
    if (((*(uint64_t (**)(OZShape *))(*(_QWORD *)this + 312))(this) & 1) != 0)
    {
      v22 = *(_OWORD *)&a2->value;
      epoch = a2->epoch;
      (*(void (**)(OZShape *, __int128 *, double, double))(*(_QWORD *)this + 232))(this, &v22, *((double *)this + 331), *((double *)this + 332));
    }
    else
    {
      (*(void (**)(OZShape *, const CMTime *, double, double))(*(_QWORD *)this + 384))(this, a2, *((double *)this + 331), *((double *)this + 332));
    }
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1328), a2, 0.0))
    {
      v15 = (_QWORD *)*((_QWORD *)this + 59);
      if (v15)
      {
        if ((int)((v15[1] - *v15) >> 3) >= 6)
        {
          v19[2] = v34;
          v19[3] = v35;
          v19[4] = v36;
          v19[0] = v32;
          v19[1] = v33;
          v20 = v37;
          if (v37)
            PCCFRefTraits<CGColorSpace *>::retain(v37);
          v21 = v38;
          v16 = OZShape::getCurrentRenderParams((uint64_t)this, (uint64_t)v19);
          v17 = OZShape::calculatePolygonArea((uint64_t)this, (CMTime *)&v32, v16, 0);
          PCCFRef<CGColorSpace *>::~PCCFRef(&v20);
          if (v17 > 0.0)
            OZChannelCurve::reverseWindingOrder((OZShape *)((char *)this + 208));
        }
      }
    }
    if (!OZChannel::getValueAsInt((OZChannel *)((char *)this + 1328), a2, 0.0))
    {
      OZChannelBase::enable((OZChannelBase *)((char *)this + 2784), 0, 0);
      OZChannelBase::enable((OZChannelBase *)((char *)this + 6800), 1, 0);
    }
  }
  if (OZChannelCurve::isCurveFlattened((OZShape *)((char *)this + 208))
    && OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E0CA2E68], 0.0) == 1)
  {
    OZChannel::setInitialValue((OZChannel *)((char *)this + 1072), 0.0, 1);
  }
  OZChannelCurve::setDefaultAtCurrentTime((OZShape *)((char *)this + 208), a2);
  (*(void (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
  PCMutex::unlock((PCMutex *)((char *)this + 8));
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v37);
}

void sub_1B2FFF030(_Unwind_Exception *a1)
{
  CGColorSpace **v1;
  uint64_t v2;

  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  PCLockSentry<PCMutex>::~PCLockSentry(v2 - 176);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v2 - 80));
  _Unwind_Resume(a1);
}

uint64_t OZShape::completeCurve(OZShape *this)
{
  return OZChannel::setValue((OZChannel *)((char *)this + 14280), MEMORY[0x1E0CA2E68], 1.0, 0);
}

void OZShape::didSetInterpolation(OZShape *this)
{
  OZChannelBase *v2;
  int ValueAsInt;
  OZChannelCurve *v4;
  uint64_t v5;
  int v6;
  int v7;
  OZChannelBase *v8;
  PCString v9;

  v2 = (OZChannelBase *)((char *)this + 1072);
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E0CA2E68], 0.0);
  if (ValueAsInt == 2)
  {
    v6 = OZChannel::getValueAsInt((OZChannel *)((char *)this + 13720), MEMORY[0x1E0CA2E68], 0.0);
    v4 = (OZShape *)((char *)this + 208);
    if (v6)
      v5 = 10;
    else
      v5 = 12;
  }
  else if (ValueAsInt == 1)
  {
    v4 = (OZShape *)((char *)this + 208);
    v5 = 4;
  }
  else
  {
    if (ValueAsInt)
      goto LABEL_10;
    v4 = (OZShape *)((char *)this + 208);
    v5 = 1;
  }
  OZChannelCurve::setCurveInterpolation(v4, v5);
LABEL_10:
  if (OZChannel::getValueAsInt((OZChannel *)v2, MEMORY[0x1E0CA2E68], 0.0) == 4)
  {
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1328), 2, 0);
    OZChannelBase::setFlag(v2, 2, 0);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1480), 2, 0);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 1632), 2, 0);
    OZChannelBase::setFlag((OZChannelBase *)((char *)this + 208), 2, 0);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12072), 2, 0);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12224), 2, 0);
    OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12664), 2, 0);
  }
  else
  {
    v7 = OZChannel::getValueAsInt((OZChannel *)v2, MEMORY[0x1E0CA2E68], 0.0);
    v8 = (OZChannelBase *)((char *)this + 1328);
    if (v7 == 5)
    {
      OZChannelBase::setFlag(v8, 2, 0);
      OZChannelBase::setFlag(v2, 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1480), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1632), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 208), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12072), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12224), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 12664), 2, 0);
      PCString::PCString(&v9, "Shape Size", "com.apple.proshapes.framework");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 12224), &v9, 0);
      PCString::~PCString(&v9);
      PCString::PCString(&v9, "Shape Size Width", "com.apple.proshapes.framework");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 12360), &v9, 0);
      PCString::~PCString(&v9);
      PCString::PCString(&v9, "Shape Size Height", "com.apple.proshapes.framework");
      OZChannelBase::setName((OZChannelBase *)((char *)this + 12512), &v9, 0);
      PCString::~PCString(&v9);
    }
    else
    {
      OZChannelBase::resetFlag(v8, 2, 0);
      OZChannelBase::resetFlag(v2, 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1480), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 1632), 2, 0);
      OZChannelBase::resetFlag((OZChannelBase *)((char *)this + 208), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12072), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12224), 2, 0);
      OZChannelBase::setFlag((OZChannelBase *)((char *)this + 12664), 2, 0);
    }
  }
}

void sub_1B2FFF408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::setInterpolation(OZShape *this, unsigned int a2)
{
  OZChannel::setValue((OZChannel *)((char *)this + 1072), MEMORY[0x1E0CA2E68], (double)a2, 0);
  if (a2 == 1)
    OZChannelCurve::flattenCurve((OZShape *)((char *)this + 208));
  return (*(uint64_t (**)(OZShape *))(*(_QWORD *)this + 120))(this);
}

void OZShapeRenderState::OZShapeRenderState(OZShapeRenderState *this)
{
  __int128 v2;
  PCRenderModel *v8;

  v2 = *MEMORY[0x1E0CA2E68];
  *((_QWORD *)this + 2) = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  *(_OWORD *)this = v2;
  *((_WORD *)this + 12) = 0;
  *((_BYTE *)this + 26) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *((_OWORD *)this + 2) = _Q0;
  *((_DWORD *)this + 12) = 2;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = 0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)this + 10);
  *((float *)this + 22) = PCRenderModel::getDefaultBlendingGamma(v8);
}

void sub_1B2FFF4E4(_Unwind_Exception *a1)
{
  CGColorSpace **v1;

  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

long double OZShapeEdgeTexture::smoothStep(OZShapeEdgeTexture *this, double a2, double a3)
{
  long double result;
  long double v5;
  long double v6;

  result = 1.0;
  if (a2 >= 0.0)
  {
    result = 0.0;
    if (a2 <= 2.0)
    {
      v5 = (2.0 - a2) * 0.5;
      v6 = v5 + (pow(v5, 1.5) - v5) * ((1.0 - v5) * 0.5 + -0.5 + 1.0);
      return (v5 * 0.5 + -0.5 + 1.0) * (1.0 - pow(1.0 - v5, 1.5) - v5) + v6;
    }
  }
  return result;
}

double OZShapeEdgeTexture::eval(LiEdgeTexture *a1, double a2, double a3)
{
  double result;
  double v5;
  float v6;
  PCIllegalArgumentException *exception;

  result = 1.0;
  if (a2 > 0.0)
  {
    if (a2 >= a3)
    {
      return 0.0;
    }
    else
    {
      switch((int)a1)
      {
        case 0:
          if (a2 >= 0.5)
          {
            result = 0.0;
            if (a2 <= 1.5)
              result = 1.5 - a2;
          }
          break;
        case 1:
          v5 = exp(a3 * a3 * -1.5);
          result = (exp(fabs(a2 * a2) * -1.5) - v5) / (1.0 - v5);
          break;
        case 2:
          result = 0.0;
          if (a2 < 2.0)
            result = (cos(a2 * 3.14159265 * 0.5) + 1.0) * 0.5;
          break;
        case 3:
          result = LiEdgeTexture::erfc_filter(a1, a2, a3);
          break;
        case 4:
          result = 0.0;
          if (a2 < 2.0)
            result = sin(a2 * -0.96875 * 3.14159265 * 0.25) + 1.0;
          break;
        case 5:
          result = 0.0;
          if (a2 < 2.0)
          {
            v6 = 2.0 - a2;
            result = sin(v6 * 0.96875 * 3.14159265 * 0.25);
          }
          break;
        case 6:
          result = OZShapeEdgeTexture::smoothStep(a1, a2, a3);
          break;
        default:
          exception = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
          PCIllegalArgumentException::PCIllegalArgumentException(exception);
      }
    }
  }
  return result;
}

void sub_1B2FFF77C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void OZShapeEdgeTexture::createHeliumBitmap(int a1@<W0>, LiEdgeTexture *a2@<X1>, uint64_t a3@<X2>, int32x4_t ***a4@<X8>, double a5@<D0>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int32x4_t **v14;
  int32x4_t *v15;

  if (a1)
    v10 = 28;
  else
    v10 = 24;
  v11 = HGRectMake4i(0, 0, a3, a3);
  v13 = v12;
  v14 = (int32x4_t **)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v14, v11, v13, v10);
  *a4 = v14;
  v15 = v14[10];
  if (a1)
    evalBitmap<float>(v15, a5, a3, a2);
  else
    evalBitmap<unsigned char>(v15, a5, a3, a2);
}

void sub_1B2FFF850(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void evalBitmap<float>(int32x4_t *a1, double a2, uint64_t a3, LiEdgeTexture *a4)
{
  int32x4_t *v6;
  int v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  double v16;
  uint64_t v17;
  double v18;
  _QWORD v20[2];

  v6 = a1;
  v20[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (char *)v20 - v8;
  v10 = (v7 - 1);
  if (v7 >= 1)
  {
    v11 = a2 / (double)(v7 - 3);
    v12 = 8 * (v7 - 1);
    v13 = v7 - 2;
    do
    {
      *(double *)&v9[v12] = OZShapeEdgeTexture::eval(a4, v11 * (double)v13, a2);
      v12 -= 8;
      --v13;
    }
    while (v12 != -8);
    v14 = v10;
    do
    {
      v15 = v14--;
      v16 = OZShapeEdgeTexture::eval(a4, v11 * (double)v14, a2);
      v17 = v10;
      do
      {
        v18 = v16 * *(double *)&v9[8 * v17];
        *(float *)&v18 = v18;
        *(float *)&v18 = fminf(fmaxf(*(float *)&v18, 0.0), 1.0);
        *v6++ = vdupq_lane_s32(*(int32x2_t *)&v18, 0);
      }
      while (v17-- > 0);
    }
    while (v15 >= 1);
  }
}

void evalBitmap<unsigned char>(_DWORD *a1, double a2, uint64_t a3, LiEdgeTexture *a4)
{
  _DWORD *v6;
  int v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  double v16;
  uint64_t v17;
  int v18;
  int v19;
  _QWORD v21[2];

  v6 = a1;
  v21[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (char *)v21 - v8;
  v10 = (v7 - 1);
  if (v7 >= 1)
  {
    v11 = a2 / (double)(v7 - 3);
    v12 = 8 * (v7 - 1);
    v13 = v7 - 2;
    do
    {
      *(double *)&v9[v12] = OZShapeEdgeTexture::eval(a4, v11 * (double)v13, a2);
      v12 -= 8;
      --v13;
    }
    while (v12 != -8);
    v14 = v10;
    do
    {
      v15 = v14--;
      v16 = OZShapeEdgeTexture::eval(a4, v11 * (double)v14, a2);
      v17 = v10;
      do
      {
        v18 = vcvtmd_s64_f64(v16 * *(double *)&v9[8 * v17] * 255.0 + 0.5 + 0.0000001);
        v19 = v18 & ~(v18 >> 31);
        if (v19 >= 255)
          v19 = 255;
        *v6++ = 16843009 * v19;
      }
      while (v17-- > 0);
    }
    while (v15 >= 1);
  }
}

HGBitmapLoader *OZShapeEdgeTexture::createBitmapNode@<X0>(uint64_t *a1@<X0>, HGBitmapLoader **a2@<X8>)
{
  uint64_t v3;
  HGTexture *v4;
  HGBitmapLoader *v5;
  HGBitmapLoader *result;

  v3 = *a1;
  v4 = (HGTexture *)HGObject::operator new(0x80uLL);
  HGTexture::HGTexture(v4, *(HGRect *)(v3 + 20), (HGBitmap *)v3);
  v5 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  result = HGBitmapLoader::HGBitmapLoader(v5, (HGBitmap *)v4);
  *a2 = v5;
  if (v4)
    return (HGBitmapLoader *)(*(uint64_t (**)(HGTexture *))(*(_QWORD *)v4 + 24))(v4);
  return result;
}

void sub_1B2FFFBAC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

int32x4_t **OZShapeEdgeTexture::createHeliumNode@<X0>(LiEdgeTexture *a1@<X1>, HGBitmapLoader **a2@<X8>)
{
  int32x4_t **result;
  int32x4_t **v4;

  OZShapeEdgeTexture::createHeliumBitmap(1, a1, 64, &v4, 2.0);
  OZShapeEdgeTexture::createBitmapNode((uint64_t *)&v4, a2);
  result = v4;
  if (v4)
    return (int32x4_t **)((uint64_t (*)(int32x4_t **))(*v4)[1].i64[1])(v4);
  return result;
}

void sub_1B2FFFC4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t *HGArray<float,(HGFormat)7>::resize(uint64_t *result, int a2)
{
  uint64_t v3;

  v3 = *result;
  if (*result)
  {
    if (*(_DWORD *)(v3 + 12) < a2)
      result = (uint64_t *)HGArrayData::allocate(*result, a2);
    *(_DWORD *)(v3 + 8) = a2;
  }
  else if (a2 > 0)
  {
    return (uint64_t *)HGArrayDataRef::allocate((HGArrayDataRef *)result, 4, a2, a2);
  }
  return result;
}

void getOZShapeEdgeTextureLock(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      PCMutex::PCMutex(&getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock, 1);
      getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock._vptr$PCMutex = (void **)&unk_1E64E2000;
      __cxa_atexit((void (*)(void *))PCRecursiveMutex::~PCRecursiveMutex, &getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock, &dword_1B2737000);
    }
  }
}

void sub_1B2FFFD58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t OZShapeEdgeTexture::getHeliumNode@<X0>(LiEdgeTexture *a1@<X1>, HGBitmapLoader **a2@<X8>)
{
  getOZShapeEdgeTextureLock();
  PCMutex::lock(&getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock);
  OZShapeEdgeTexture::createHeliumNode(a1, a2);
  return PCMutex::unlock(&getOZShapeEdgeTextureLock(void)::sOZShapeEdgeTextureLock);
}

void sub_1B2FFFDD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const void **PCCFRef<__CFArray const*>::~PCCFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t HGArray<float,(HGFormat)7>::HGArray(uint64_t a1)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 7;
  HGArrayDataRef::allocate((HGArrayDataRef *)a1, 4, 0, 0);
  return a1;
}

void sub_1B2FFFE50(_Unwind_Exception *exception_object)
{
  uint64_t *v1;

  if (*v1)
    HGArrayData::Release(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t OZShape::hitCheck(uint64_t a1, const CMTime *a2)
{
  if (OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1))
    OZChannel::getValueAsInt((OZChannel *)(a1 + 1328), a2, 0.0);
  return 0;
}

unint64_t OZShape::getCurveSamplesForOSC@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  PCMutex *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  CGColorSpace *v19;
  uint64_t CurrentRenderParams;
  _QWORD *OSCContour;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  unint64_t result;
  int i;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  double v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  _OWORD v44[5];
  CGColorSpace *v45;
  int v46;
  _OWORD v47[8];
  uint64_t v48;
  char v49;

  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  v10 = (PCMutex *)(a1 + 8);
  v48 = a1 + 8;
  PCMutex::lock((PCMutex *)(a1 + 8));
  v49 = 1;
  v11 = *(_OWORD *)(a3 + 80);
  v47[4] = *(_OWORD *)(a3 + 64);
  v47[5] = v11;
  v12 = *(_OWORD *)(a3 + 112);
  v47[6] = *(_OWORD *)(a3 + 96);
  v47[7] = v12;
  v13 = *(_OWORD *)(a3 + 16);
  v47[0] = *(_OWORD *)a3;
  v47[1] = v13;
  v14 = *(_OWORD *)(a3 + 48);
  v47[2] = *(_OWORD *)(a3 + 32);
  v47[3] = v14;
  v15 = *a2;
  v16 = a2[1];
  v17 = a2[4];
  v44[3] = a2[3];
  v44[4] = v17;
  v18 = a2[2];
  v44[1] = v16;
  v44[2] = v18;
  v44[0] = v15;
  v19 = (CGColorSpace *)*((_QWORD *)a2 + 10);
  v45 = v19;
  if (v19)
    PCCFRefTraits<CGColorSpace *>::retain(v19);
  v46 = *((_DWORD *)a2 + 22);
  CurrentRenderParams = OZShape::getCurrentRenderParams(a1, (uint64_t)v44);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v45);
  (*(void (**)(uint64_t, __int128 *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, CurrentRenderParams, 0, 1);
  OSCContour = (_QWORD *)OZShape::getOSCContour(a1, (const CMTime *)a2, CurrentRenderParams, (double *)v47);
  v22 = OSCContour;
  v23 = OSCContour[27];
  v24 = OSCContour[28];
  if (v23 == v24 || OSCContour[30] == OSCContour[31] || OSCContour[24] == OSCContour[25])
    return PCMutex::unlock(v10);
  v25 = (unint64_t)(v24 - v23) >> 3;
  v26 = *(_DWORD *)(CurrentRenderParams + 168) ? v25 + 1 : (unint64_t)(v24 - v23) >> 3;
  if (v26 < 1)
    return PCMutex::unlock(v10);
  result = 0;
  for (i = 0; i != v26; ++i)
  {
    v39 = 0.0;
    v40 = 0.0;
    v42 = 0u;
    v43 = 0u;
    v29 = *(double *)(v22[27] + 8 * (i % (int)v25));
    v30 = *(double *)(v22[30] + 8 * (i % (int)v25));
    v31 = *(double *)(a3 + 120) + v29 * *(double *)(a3 + 96) + v30 * *(double *)(a3 + 104);
    v32 = (*(double *)(a3 + 24) + v29 * *(double *)a3 + v30 * *(double *)(a3 + 8)) / v31;
    v33 = (*(double *)(a3 + 56) + v29 * *(double *)(a3 + 32) + v30 * *(double *)(a3 + 40)) / v31;
    v39 = v32;
    v40 = v33;
    v34 = *(_QWORD *)(v22[24] + 8 * (i % (int)v25));
    v35 = *a4;
    v36 = a4[1];
    v37 = a4[2];
    v38 = a4[3];
    v41 = v34;
    *(_QWORD *)&v42 = v35;
    *((_QWORD *)&v42 + 1) = v36;
    *(_QWORD *)&v43 = v37;
    *((_QWORD *)&v43 + 1) = v38;
    if (result >= a5[2])
    {
      result = std::vector<OZShapeOSCCurveSample>::__push_back_slow_path<OZShapeOSCCurveSample const&>(a5, (uint64_t)&v39);
    }
    else
    {
      *(double *)result = v32;
      *(double *)(result + 8) = v33;
      *(_QWORD *)(result + 16) = v34;
      *(_QWORD *)(result + 24) = v35;
      *(_QWORD *)(result + 32) = v36;
      *(_QWORD *)(result + 40) = v37;
      *(_QWORD *)(result + 48) = v38;
      result += 56;
    }
    a5[1] = result;
  }
  if (v49)
    return PCMutex::unlock(v10);
  return result;
}

void sub_1B300010C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v4;

  PCLockSentry<PCMutex>::~PCLockSentry(v2 - 96);
  v4 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t std::vector<OZShapeOSCCurveSample>::__push_back_slow_path<OZShapeOSCCurveSample const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  void *__p;
  char *v16;
  char *v17;
  char *v18;
  uint64_t *v19;

  v3 = *a1;
  v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x249249249249249)
    v9 = 0x492492492492492;
  else
    v9 = v5;
  v19 = a1 + 2;
  v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSParticleType::SourceBoundsCacheEntry>>(v7, v9);
  v11 = &v10[56 * v4];
  __p = v10;
  v16 = v11;
  v18 = &v10[56 * v12];
  *(_OWORD *)v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((_QWORD *)v11 + 6) = *(_QWORD *)(a2 + 48);
  v17 = v11 + 56;
  std::vector<OZShapeOSCCurveSample>::__swap_out_circular_buffer(a1, &__p);
  v13 = a1[1];
  if (v17 != v16)
    v17 = &v16[(v17 - v16 - 56) % 0x38uLL];
  if (__p)
    operator delete(__p);
  return v13;
}

void sub_1B3000294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::vector<OZShapeOSCCurveSample>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *(_OWORD *)(v2 - 56);
    v2 -= 56;
    *(_OWORD *)(v4 - 56) = v5;
    v4 -= 56;
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(v2 + 16);
    *(_OWORD *)(v4 + 32) = *(_OWORD *)(v2 + 32);
    *(_QWORD *)(v4 + 48) = *(_QWORD *)(v2 + 48);
  }
  a2[1] = v4;
  v6 = *result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

BOOL OZShape::checkWindingOrder(OZShape *this, CMTime *a2, uint64_t a3, double *a4, int a5)
{
  _QWORD *v10;
  int v11;
  double v12;
  _BOOL8 v13;

  v10 = (_QWORD *)*((_QWORD *)this + 59);
  v11 = *(_DWORD *)(a3 + 168);
  if (!v10)
  {
    if (v11)
      goto LABEL_6;
    return 0;
  }
  if (!v11)
    return 0;
  if (((int)((v10[1] - *v10) >> 3) / 2) > 2)
    goto LABEL_7;
LABEL_6:
  if (!OZShape::isGeometricShape(this))
    return 0;
LABEL_7:
  v12 = OZShape::calculatePolygonArea((uint64_t)this, a2, a3, a4);
  v13 = v12 > 0.0;
  if (v12 > 0.0 && a5)
  {
    OZChannelCurve::reverseWindingOrder((OZShape *)((char *)this + 208));
    v13 = 1;
    (*(void (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
  }
  return v13;
}

double OZShape::calculatePolygonArea(uint64_t a1, CMTime *a2, uint64_t a3, double *a4)
{
  OZChannel *v7;
  double v8;
  double v9;
  float64x2_t v10;
  double v11;
  os_unfair_lock_s *v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  double v18;
  double v19;
  _BOOL4 v20;
  double *v21;
  double *v22;
  double *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  double *v29;
  uint64_t v30;
  float64_t v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  double *v43;
  double *v44;
  double *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  double v53;
  double v54;
  _BOOL4 v55;
  double *v56;
  double *v57;
  double *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  double *v64;
  uint64_t v65;
  float64_t v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  double *v78;
  double *v79;
  double *v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  unint64_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  float64_t v88;
  double *v89;
  double *v90;
  double *v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  char *v96;
  double *v97;
  uint64_t v98;
  float64_t v99;
  char *v100;
  char *v101;
  char *v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  char *v107;
  char *v108;
  uint64_t v109;
  uint64_t v110;
  double *v111;
  double *v112;
  double *v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  char *v119;
  uint64_t v120;
  double *v121;
  double *v122;
  double *v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  char *v128;
  double *v129;
  double *v130;
  double *v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  char *v136;
  double *v137;
  char *v138;
  uint64_t v139;
  float64_t v140;
  char *v141;
  char *v142;
  char *v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  unint64_t v147;
  char *v148;
  char *v149;
  char *v150;
  uint64_t v151;
  uint64_t v152;
  double *v153;
  double *v154;
  double *v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  char *v160;
  char *v161;
  char *v162;
  uint64_t v163;
  float64_t v164;
  double v165;
  float64_t v166;
  _BOOL4 v167;
  double *v168;
  double *v169;
  double *v170;
  uint64_t v171;
  unint64_t v172;
  uint64_t v173;
  unint64_t v174;
  char *v175;
  double *v176;
  char *v177;
  uint64_t v178;
  float64_t v179;
  char *v180;
  char *v181;
  char *v182;
  uint64_t v183;
  unint64_t v184;
  uint64_t v185;
  unint64_t v186;
  char *v187;
  char *v188;
  char *v189;
  uint64_t v190;
  uint64_t v191;
  double *v192;
  double *v193;
  double *v194;
  uint64_t v195;
  unint64_t v196;
  uint64_t v197;
  unint64_t v198;
  char *v199;
  char *v200;
  char *v201;
  uint64_t v202;
  float64_t v203;
  double *v204;
  double *v205;
  double *v206;
  uint64_t v207;
  unint64_t v208;
  uint64_t v209;
  unint64_t v210;
  char *v211;
  double *v212;
  char *v213;
  uint64_t v214;
  float64_t v215;
  char *v216;
  char *v217;
  char *v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t v221;
  unint64_t v222;
  char *v223;
  char *v224;
  char *v225;
  uint64_t v226;
  uint64_t v227;
  double *v228;
  double *v229;
  double *v230;
  uint64_t v231;
  unint64_t v232;
  uint64_t v233;
  unint64_t v234;
  char *v235;
  char *v236;
  char *v237;
  uint64_t v238;
  double v239;
  double v240;
  float64_t v241;
  double *v242;
  double *v243;
  double *v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  unint64_t v248;
  char *v249;
  double *v250;
  char *v251;
  uint64_t v252;
  float64_t v253;
  char *v254;
  char *v255;
  char *v256;
  uint64_t v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  char *v261;
  char *v262;
  char *v263;
  uint64_t v264;
  uint64_t v265;
  char *v266;
  uint64_t v267;
  unint64_t v268;
  uint64_t v269;
  unint64_t v270;
  char *v271;
  char *v272;
  char *v273;
  double *v274;
  uint64_t v275;
  double *v276;
  char *v277;
  uint64_t v278;
  float64_t v279;
  char *v280;
  char *v281;
  char *v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t v285;
  unint64_t v286;
  char *v287;
  char *v288;
  char *v289;
  uint64_t v290;
  uint64_t v291;
  double *v292;
  double *v293;
  double *v294;
  uint64_t v295;
  unint64_t v296;
  uint64_t v297;
  unint64_t v298;
  char *v299;
  char *v300;
  char *v301;
  uint64_t v302;
  float64x2_t v307;
  double v308;
  _BOOL4 v309;
  double *v310;
  double *v311;
  double *v312;
  uint64_t v313;
  unint64_t v314;
  uint64_t v315;
  unint64_t v316;
  char *v317;
  double *v318;
  char *v319;
  uint64_t v320;
  float64_t v321;
  char *v322;
  char *v323;
  char *v324;
  uint64_t v325;
  unint64_t v326;
  uint64_t v327;
  unint64_t v328;
  char *v329;
  char *v330;
  char *v331;
  uint64_t v332;
  uint64_t v333;
  double *v334;
  double *v335;
  double *v336;
  uint64_t v337;
  unint64_t v338;
  uint64_t v339;
  unint64_t v340;
  char *v341;
  char *v342;
  char *v343;
  uint64_t v344;
  float64_t v345;
  double *v346;
  double *v347;
  double *v348;
  uint64_t v349;
  unint64_t v350;
  uint64_t v351;
  unint64_t v352;
  char *v353;
  double *v354;
  char *v355;
  uint64_t v356;
  float64_t v357;
  char *v358;
  char *v359;
  char *v360;
  uint64_t v361;
  unint64_t v362;
  uint64_t v363;
  unint64_t v364;
  char *v365;
  char *v366;
  char *v367;
  uint64_t v368;
  uint64_t v369;
  double *v370;
  double *v371;
  double *v372;
  uint64_t v373;
  unint64_t v374;
  uint64_t v375;
  unint64_t v376;
  char *v377;
  char *v378;
  char *v379;
  uint64_t v380;
  float64x2_t v382;
  double v383;
  double *v384;
  double *v385;
  double *v386;
  uint64_t v387;
  unint64_t v388;
  uint64_t v389;
  unint64_t v390;
  char *v391;
  double *v392;
  char *v393;
  uint64_t v394;
  float64_t v395;
  char *v396;
  char *v397;
  char *v398;
  uint64_t v399;
  unint64_t v400;
  uint64_t v401;
  unint64_t v402;
  char *v403;
  char *v404;
  char *v405;
  uint64_t v406;
  uint64_t v407;
  unint64_t v408;
  uint64_t v409;
  unint64_t v410;
  char *v411;
  uint64_t v412;
  double *v413;
  uint64_t v414;
  double v415;
  double *v416;
  uint64_t v418;
  double *v419;
  uint64_t v420;
  double *v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  float64_t v426;
  float64_t v427;
  float64_t v429;
  char *v430;
  char *v431;
  float64x2_t v432;
  __int128 v433;
  void *v434;
  double *v435;
  char *v436;
  void *__p;
  char *v438;
  char *v439;
  double *v440;
  double *v441;
  char *v442;
  double v443;
  double v444;
  double v445;
  double v446[2];

  v445 = 0.0;
  v446[0] = 0.0;
  v443 = 0.0;
  v444 = 0.0;
  v440 = 0;
  v441 = 0;
  v442 = 0;
  __p = 0;
  v438 = 0;
  v439 = 0;
  v434 = 0;
  v435 = 0;
  v436 = 0;
  v7 = (OZChannel *)(a1 + 1072);
  v432 = 0u;
  v433 = 0u;
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4)
  {
    std::vector<double>::reserve((void **)&v440, 5uLL);
    std::vector<double>::reserve(&__p, 5uLL);
    std::vector<double>::reserve(&v434, 5uLL);
    v8 = -*(double *)(a3 + 200);
    v432.f64[0] = v8;
    v432.f64[1] = 0.0;
    *(_QWORD *)&v433 = 0;
    *((_QWORD *)&v433 + 1) = 0x3FF0000000000000;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      v9 = *((double *)&v433 + 1);
      v8 = v432.f64[0];
    }
    else
    {
      v9 = 1.0;
    }
    v121 = v441;
    if (v441 >= (double *)v442)
    {
      v123 = v440;
      v124 = v441 - v440;
      v125 = v124 + 1;
      if ((unint64_t)(v124 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v126 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v125)
        v125 = v126 >> 2;
      if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFF8)
        v127 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v127 = v125;
      if (v127)
      {
        v128 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v127);
        v123 = v440;
        v121 = v441;
      }
      else
      {
        v128 = 0;
      }
      v137 = (double *)&v128[8 * v124];
      v138 = &v128[8 * v127];
      *v137 = v8;
      v122 = v137 + 1;
      while (v121 != v123)
      {
        v139 = *((_QWORD *)v121-- - 1);
        *((_QWORD *)v137-- - 1) = v139;
      }
      v440 = v137;
      v441 = v122;
      v442 = v138;
      if (v123)
        operator delete(v123);
    }
    else
    {
      *v441 = v8;
      v122 = v121 + 1;
    }
    v441 = v122;
    v140 = v432.f64[1];
    v141 = v438;
    if (v438 >= v439)
    {
      v143 = (char *)__p;
      v144 = (v438 - (_BYTE *)__p) >> 3;
      v145 = v144 + 1;
      if ((unint64_t)(v144 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v146 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v145)
        v145 = v146 >> 2;
      if ((unint64_t)v146 >= 0x7FFFFFFFFFFFFFF8)
        v147 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v147 = v145;
      if (v147)
      {
        v148 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v147);
        v143 = (char *)__p;
        v141 = v438;
      }
      else
      {
        v148 = 0;
      }
      v149 = &v148[8 * v144];
      v150 = &v148[8 * v147];
      *(float64_t *)v149 = v140;
      v142 = v149 + 8;
      while (v141 != v143)
      {
        v151 = *((_QWORD *)v141 - 1);
        v141 -= 8;
        *((_QWORD *)v149 - 1) = v151;
        v149 -= 8;
      }
      __p = v149;
      v438 = v142;
      v439 = v150;
      if (v143)
        operator delete(v143);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v142 = v141 + 8;
    }
    v438 = v142;
    v152 = *((_QWORD *)&v433 + 1);
    v153 = v435;
    if (v435 >= (double *)v436)
    {
      v155 = (double *)v434;
      v156 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v157 = v156 + 1;
      if ((unint64_t)(v156 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v158 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v157)
        v157 = v158 >> 2;
      if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFF8)
        v159 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v159 = v157;
      if (v159)
      {
        v160 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v159);
        v155 = (double *)v434;
        v153 = v435;
      }
      else
      {
        v160 = 0;
      }
      v161 = &v160[8 * v156];
      v162 = &v160[8 * v159];
      *(_QWORD *)v161 = v152;
      v154 = (double *)(v161 + 8);
      while (v153 != v155)
      {
        v163 = *((_QWORD *)v153-- - 1);
        *((_QWORD *)v161 - 1) = v163;
        v161 -= 8;
      }
      v434 = v161;
      v435 = v154;
      v436 = v162;
      if (v155)
        operator delete(v155);
    }
    else
    {
      *v435 = *((double *)&v433 + 1);
      v154 = v153 + 1;
    }
    v435 = v154;
    v164 = *(double *)(a3 + 208);
    v432.f64[0] = 0.0;
    v432.f64[1] = v164;
    v433 = xmmword_1B304EEE0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      v165 = *((double *)&v433 + 1);
      v166 = v432.f64[0];
    }
    else
    {
      v165 = 1.0;
      v166 = 0.0;
    }
    v167 = v165 > 0.0 && v9 > 0.0;
    v168 = v441;
    if (v441 >= (double *)v442)
    {
      v170 = v440;
      v171 = v441 - v440;
      v172 = v171 + 1;
      if ((unint64_t)(v171 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v173 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v172)
        v172 = v173 >> 2;
      if ((unint64_t)v173 >= 0x7FFFFFFFFFFFFFF8)
        v174 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v174 = v172;
      if (v174)
      {
        v175 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v174);
        v170 = v440;
        v168 = v441;
      }
      else
      {
        v175 = 0;
      }
      v176 = (double *)&v175[8 * v171];
      v177 = &v175[8 * v174];
      *v176 = v166;
      v169 = v176 + 1;
      while (v168 != v170)
      {
        v178 = *((_QWORD *)v168-- - 1);
        *((_QWORD *)v176-- - 1) = v178;
      }
      v440 = v176;
      v441 = v169;
      v442 = v177;
      if (v170)
        operator delete(v170);
    }
    else
    {
      *v441 = v166;
      v169 = v168 + 1;
    }
    v441 = v169;
    v179 = v432.f64[1];
    v180 = v438;
    if (v438 >= v439)
    {
      v182 = (char *)__p;
      v183 = (v438 - (_BYTE *)__p) >> 3;
      v184 = v183 + 1;
      if ((unint64_t)(v183 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v185 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v184)
        v184 = v185 >> 2;
      if ((unint64_t)v185 >= 0x7FFFFFFFFFFFFFF8)
        v186 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v186 = v184;
      if (v186)
      {
        v187 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v186);
        v182 = (char *)__p;
        v180 = v438;
      }
      else
      {
        v187 = 0;
      }
      v188 = &v187[8 * v183];
      v189 = &v187[8 * v186];
      *(float64_t *)v188 = v179;
      v181 = v188 + 8;
      while (v180 != v182)
      {
        v190 = *((_QWORD *)v180 - 1);
        v180 -= 8;
        *((_QWORD *)v188 - 1) = v190;
        v188 -= 8;
      }
      __p = v188;
      v438 = v181;
      v439 = v189;
      if (v182)
        operator delete(v182);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v181 = v180 + 8;
    }
    v438 = v181;
    v191 = *((_QWORD *)&v433 + 1);
    v192 = v435;
    if (v435 >= (double *)v436)
    {
      v194 = (double *)v434;
      v195 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v196 = v195 + 1;
      if ((unint64_t)(v195 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v197 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v196)
        v196 = v197 >> 2;
      if ((unint64_t)v197 >= 0x7FFFFFFFFFFFFFF8)
        v198 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v198 = v196;
      if (v198)
      {
        v199 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v198);
        v194 = (double *)v434;
        v192 = v435;
      }
      else
      {
        v199 = 0;
      }
      v200 = &v199[8 * v195];
      v201 = &v199[8 * v198];
      *(_QWORD *)v200 = v191;
      v193 = (double *)(v200 + 8);
      while (v192 != v194)
      {
        v202 = *((_QWORD *)v192-- - 1);
        *((_QWORD *)v200 - 1) = v202;
        v200 -= 8;
      }
      v434 = v200;
      v435 = v193;
      v436 = v201;
      if (v194)
        operator delete(v194);
    }
    else
    {
      *v435 = *((double *)&v433 + 1);
      v193 = v192 + 1;
    }
    v435 = v193;
    v432 = (float64x2_t)*(unint64_t *)(a3 + 200);
    *(_QWORD *)&v433 = 0;
    *((_QWORD *)&v433 + 1) = 0x3FF0000000000000;
    if (a4)
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
    if (v167)
      v167 = *((double *)&v433 + 1) > 0.0;
    v203 = v432.f64[0];
    v204 = v441;
    if (v441 >= (double *)v442)
    {
      v206 = v440;
      v207 = v441 - v440;
      v208 = v207 + 1;
      if ((unint64_t)(v207 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v209 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v208)
        v208 = v209 >> 2;
      if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFF8)
        v210 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v210 = v208;
      if (v210)
      {
        v211 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v210);
        v206 = v440;
        v204 = v441;
      }
      else
      {
        v211 = 0;
      }
      v212 = (double *)&v211[8 * v207];
      v213 = &v211[8 * v210];
      *v212 = v203;
      v205 = v212 + 1;
      while (v204 != v206)
      {
        v214 = *((_QWORD *)v204-- - 1);
        *((_QWORD *)v212-- - 1) = v214;
      }
      v440 = v212;
      v441 = v205;
      v442 = v213;
      if (v206)
        operator delete(v206);
    }
    else
    {
      *v441 = v432.f64[0];
      v205 = v204 + 1;
    }
    v441 = v205;
    v215 = v432.f64[1];
    v216 = v438;
    if (v438 >= v439)
    {
      v218 = (char *)__p;
      v219 = (v438 - (_BYTE *)__p) >> 3;
      v220 = v219 + 1;
      if ((unint64_t)(v219 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v221 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v220)
        v220 = v221 >> 2;
      if ((unint64_t)v221 >= 0x7FFFFFFFFFFFFFF8)
        v222 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v222 = v220;
      if (v222)
      {
        v223 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v222);
        v218 = (char *)__p;
        v216 = v438;
      }
      else
      {
        v223 = 0;
      }
      v224 = &v223[8 * v219];
      v225 = &v223[8 * v222];
      *(float64_t *)v224 = v215;
      v217 = v224 + 8;
      while (v216 != v218)
      {
        v226 = *((_QWORD *)v216 - 1);
        v216 -= 8;
        *((_QWORD *)v224 - 1) = v226;
        v224 -= 8;
      }
      __p = v224;
      v438 = v217;
      v439 = v225;
      if (v218)
        operator delete(v218);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v217 = v216 + 8;
    }
    v438 = v217;
    v227 = *((_QWORD *)&v433 + 1);
    v228 = v435;
    if (v435 >= (double *)v436)
    {
      v230 = (double *)v434;
      v231 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v232 = v231 + 1;
      if ((unint64_t)(v231 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v233 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v232)
        v232 = v233 >> 2;
      if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFF8)
        v234 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v234 = v232;
      if (v234)
      {
        v235 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v234);
        v230 = (double *)v434;
        v228 = v435;
      }
      else
      {
        v235 = 0;
      }
      v236 = &v235[8 * v231];
      v237 = &v235[8 * v234];
      *(_QWORD *)v236 = v227;
      v229 = (double *)(v236 + 8);
      while (v228 != v230)
      {
        v238 = *((_QWORD *)v228-- - 1);
        *((_QWORD *)v236 - 1) = v238;
        v236 -= 8;
      }
      v434 = v236;
      v435 = v229;
      v436 = v237;
      if (v230)
        operator delete(v230);
    }
    else
    {
      *v435 = *((double *)&v433 + 1);
      v229 = v228 + 1;
    }
    v435 = v229;
    v239 = -*(double *)(a3 + 208);
    v432.f64[0] = 0.0;
    v432.f64[1] = v239;
    v433 = xmmword_1B304EEE0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      v240 = *((double *)&v433 + 1);
      v241 = v432.f64[0];
    }
    else
    {
      v240 = 1.0;
      v241 = 0.0;
    }
    v17 = v240 > 0.0 && v167;
    v242 = v441;
    if (v441 >= (double *)v442)
    {
      v244 = v440;
      v245 = v441 - v440;
      v246 = v245 + 1;
      if ((unint64_t)(v245 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v247 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v246)
        v246 = v247 >> 2;
      if ((unint64_t)v247 >= 0x7FFFFFFFFFFFFFF8)
        v248 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v248 = v246;
      if (v248)
      {
        v249 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v248);
        v244 = v440;
        v242 = v441;
      }
      else
      {
        v249 = 0;
      }
      v250 = (double *)&v249[8 * v245];
      v251 = &v249[8 * v248];
      *v250 = v241;
      v243 = v250 + 1;
      while (v242 != v244)
      {
        v252 = *((_QWORD *)v242-- - 1);
        *((_QWORD *)v250-- - 1) = v252;
      }
      v440 = v250;
      v441 = v243;
      v442 = v251;
      if (v244)
        operator delete(v244);
    }
    else
    {
      *v441 = v241;
      v243 = v242 + 1;
    }
    v441 = v243;
    v253 = v432.f64[1];
    v254 = v438;
    if (v438 >= v439)
    {
      v256 = (char *)__p;
      v257 = (v438 - (_BYTE *)__p) >> 3;
      v258 = v257 + 1;
      if ((unint64_t)(v257 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v259 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v258)
        v258 = v259 >> 2;
      if ((unint64_t)v259 >= 0x7FFFFFFFFFFFFFF8)
        v260 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v260 = v258;
      if (v260)
      {
        v261 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v260);
        v256 = (char *)__p;
        v254 = v438;
      }
      else
      {
        v261 = 0;
      }
      v262 = &v261[8 * v257];
      v263 = &v261[8 * v260];
      *(float64_t *)v262 = v253;
      v255 = v262 + 8;
      while (v254 != v256)
      {
        v264 = *((_QWORD *)v254 - 1);
        v254 -= 8;
        *((_QWORD *)v262 - 1) = v264;
        v262 -= 8;
      }
      __p = v262;
      v438 = v255;
      v439 = v263;
      if (v256)
        operator delete(v256);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v255 = v254 + 8;
    }
    v438 = v255;
    v265 = *((_QWORD *)&v433 + 1);
    v266 = (char *)v435;
    if (v435 >= (double *)v436)
    {
      v14 = (char *)v434;
      v267 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v268 = v267 + 1;
      if ((unint64_t)(v267 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v269 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v268)
        v268 = v269 >> 2;
      if ((unint64_t)v269 >= 0x7FFFFFFFFFFFFFF8)
        v270 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v270 = v268;
      if (v270)
      {
        v271 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v270);
        v14 = (char *)v434;
        v266 = (char *)v435;
      }
      else
      {
        v271 = 0;
      }
      v272 = &v271[8 * v267];
      v273 = &v271[8 * v270];
      *(_QWORD *)v272 = v265;
      v274 = (double *)(v272 + 8);
      while (v266 != v14)
      {
        v275 = *((_QWORD *)v266 - 1);
        v266 -= 8;
        *((_QWORD *)v272 - 1) = v275;
        v272 -= 8;
      }
      goto LABEL_589;
    }
    goto LABEL_576;
  }
  if (OZChannel::getValueAsInt(v7, MEMORY[0x1E0CA2E68], 0.0) == 5)
  {
    std::vector<double>::reserve((void **)&v440, 5uLL);
    std::vector<double>::reserve(&__p, 5uLL);
    std::vector<double>::reserve(&v434, 5uLL);
    v10 = vmulq_f64(*(float64x2_t *)(a3 + 200), (float64x2_t)xmmword_1B3560580);
    v432 = v10;
    v433 = xmmword_1B304EEE0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      v11 = *((double *)&v433 + 1);
      v426 = v432.f64[0];
    }
    else
    {
      v426 = v10.f64[0];
      v11 = 1.0;
    }
    v129 = v441;
    if (v441 >= (double *)v442)
    {
      v131 = v440;
      v132 = v441 - v440;
      v133 = v132 + 1;
      if ((unint64_t)(v132 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v134 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v133)
        v133 = v134 >> 2;
      if ((unint64_t)v134 >= 0x7FFFFFFFFFFFFFF8)
        v135 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v135 = v133;
      if (v135)
      {
        v136 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v135);
        v131 = v440;
        v129 = v441;
      }
      else
      {
        v136 = 0;
      }
      v276 = (double *)&v136[8 * v132];
      v277 = &v136[8 * v135];
      *v276 = v426;
      v130 = v276 + 1;
      while (v129 != v131)
      {
        v278 = *((_QWORD *)v129-- - 1);
        *((_QWORD *)v276-- - 1) = v278;
      }
      v440 = v276;
      v441 = v130;
      v442 = v277;
      if (v131)
        operator delete(v131);
    }
    else
    {
      *v441 = v426;
      v130 = v129 + 1;
    }
    v441 = v130;
    v279 = v432.f64[1];
    v280 = v438;
    if (v438 >= v439)
    {
      v282 = (char *)__p;
      v283 = (v438 - (_BYTE *)__p) >> 3;
      v284 = v283 + 1;
      if ((unint64_t)(v283 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v285 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v284)
        v284 = v285 >> 2;
      if ((unint64_t)v285 >= 0x7FFFFFFFFFFFFFF8)
        v286 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v286 = v284;
      if (v286)
      {
        v287 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v286);
        v282 = (char *)__p;
        v280 = v438;
      }
      else
      {
        v287 = 0;
      }
      v288 = &v287[8 * v283];
      v289 = &v287[8 * v286];
      *(float64_t *)v288 = v279;
      v281 = v288 + 8;
      while (v280 != v282)
      {
        v290 = *((_QWORD *)v280 - 1);
        v280 -= 8;
        *((_QWORD *)v288 - 1) = v290;
        v288 -= 8;
      }
      __p = v288;
      v438 = v281;
      v439 = v289;
      if (v282)
        operator delete(v282);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v281 = v280 + 8;
    }
    v438 = v281;
    v291 = *((_QWORD *)&v433 + 1);
    v292 = v435;
    if (v435 >= (double *)v436)
    {
      v294 = (double *)v434;
      v295 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v296 = v295 + 1;
      if ((unint64_t)(v295 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v297 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v296)
        v296 = v297 >> 2;
      if ((unint64_t)v297 >= 0x7FFFFFFFFFFFFFF8)
        v298 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v298 = v296;
      if (v298)
      {
        v299 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v298);
        v294 = (double *)v434;
        v292 = v435;
      }
      else
      {
        v299 = 0;
      }
      v300 = &v299[8 * v295];
      v301 = &v299[8 * v298];
      *(_QWORD *)v300 = v291;
      v293 = (double *)(v300 + 8);
      while (v292 != v294)
      {
        v302 = *((_QWORD *)v292-- - 1);
        *((_QWORD *)v300 - 1) = v302;
        v300 -= 8;
      }
      v434 = v300;
      v435 = v293;
      v436 = v301;
      if (v294)
        operator delete(v294);
    }
    else
    {
      *v435 = *((double *)&v433 + 1);
      v293 = v292 + 1;
    }
    v435 = v293;
    __asm { FMOV            V1.2D, #0.5 }
    v307 = vmulq_f64(*(float64x2_t *)(a3 + 200), _Q1);
    v432 = v307;
    v433 = xmmword_1B304EEE0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      v308 = *((double *)&v433 + 1);
      v427 = v432.f64[0];
    }
    else
    {
      v427 = v307.f64[0];
      v308 = 1.0;
    }
    v309 = v308 > 0.0 && v11 > 0.0;
    v310 = v441;
    if (v441 >= (double *)v442)
    {
      v312 = v440;
      v313 = v441 - v440;
      v314 = v313 + 1;
      if ((unint64_t)(v313 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v315 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v314)
        v314 = v315 >> 2;
      if ((unint64_t)v315 >= 0x7FFFFFFFFFFFFFF8)
        v316 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v316 = v314;
      if (v316)
      {
        v317 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v316);
        v312 = v440;
        v310 = v441;
      }
      else
      {
        v317 = 0;
      }
      v318 = (double *)&v317[8 * v313];
      v319 = &v317[8 * v316];
      *v318 = v427;
      v311 = v318 + 1;
      while (v310 != v312)
      {
        v320 = *((_QWORD *)v310-- - 1);
        *((_QWORD *)v318-- - 1) = v320;
      }
      v440 = v318;
      v441 = v311;
      v442 = v319;
      if (v312)
        operator delete(v312);
    }
    else
    {
      *v441 = v427;
      v311 = v310 + 1;
    }
    v441 = v311;
    v321 = v432.f64[1];
    v322 = v438;
    if (v438 >= v439)
    {
      v324 = (char *)__p;
      v325 = (v438 - (_BYTE *)__p) >> 3;
      v326 = v325 + 1;
      if ((unint64_t)(v325 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v327 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v326)
        v326 = v327 >> 2;
      if ((unint64_t)v327 >= 0x7FFFFFFFFFFFFFF8)
        v328 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v328 = v326;
      if (v328)
      {
        v329 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v328);
        v324 = (char *)__p;
        v322 = v438;
      }
      else
      {
        v329 = 0;
      }
      v330 = &v329[8 * v325];
      v331 = &v329[8 * v328];
      *(float64_t *)v330 = v321;
      v323 = v330 + 8;
      while (v322 != v324)
      {
        v332 = *((_QWORD *)v322 - 1);
        v322 -= 8;
        *((_QWORD *)v330 - 1) = v332;
        v330 -= 8;
      }
      __p = v330;
      v438 = v323;
      v439 = v331;
      if (v324)
        operator delete(v324);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v323 = v322 + 8;
    }
    v438 = v323;
    v333 = *((_QWORD *)&v433 + 1);
    v334 = v435;
    if (v435 >= (double *)v436)
    {
      v336 = (double *)v434;
      v337 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v338 = v337 + 1;
      if ((unint64_t)(v337 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v339 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v338)
        v338 = v339 >> 2;
      if ((unint64_t)v339 >= 0x7FFFFFFFFFFFFFF8)
        v340 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v340 = v338;
      if (v340)
      {
        v341 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v340);
        v336 = (double *)v434;
        v334 = v435;
      }
      else
      {
        v341 = 0;
      }
      v342 = &v341[8 * v337];
      v343 = &v341[8 * v340];
      *(_QWORD *)v342 = v333;
      v335 = (double *)(v342 + 8);
      while (v334 != v336)
      {
        v344 = *((_QWORD *)v334-- - 1);
        *((_QWORD *)v342 - 1) = v344;
        v342 -= 8;
      }
      v434 = v342;
      v435 = v335;
      v436 = v343;
      if (v336)
        operator delete(v336);
    }
    else
    {
      *v435 = *((double *)&v433 + 1);
      v335 = v334 + 1;
    }
    v435 = v335;
    v432 = vmulq_f64(*(float64x2_t *)(a3 + 200), (float64x2_t)xmmword_1B3565C20);
    v433 = xmmword_1B304EEE0;
    if (a4)
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
    if (v309)
      v309 = *((double *)&v433 + 1) > 0.0;
    v345 = v432.f64[0];
    v346 = v441;
    if (v441 >= (double *)v442)
    {
      v348 = v440;
      v349 = v441 - v440;
      v350 = v349 + 1;
      if ((unint64_t)(v349 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v351 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v350)
        v350 = v351 >> 2;
      if ((unint64_t)v351 >= 0x7FFFFFFFFFFFFFF8)
        v352 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v352 = v350;
      if (v352)
      {
        v353 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v352);
        v348 = v440;
        v346 = v441;
      }
      else
      {
        v353 = 0;
      }
      v354 = (double *)&v353[8 * v349];
      v355 = &v353[8 * v352];
      *v354 = v345;
      v347 = v354 + 1;
      while (v346 != v348)
      {
        v356 = *((_QWORD *)v346-- - 1);
        *((_QWORD *)v354-- - 1) = v356;
      }
      v440 = v354;
      v441 = v347;
      v442 = v355;
      if (v348)
        operator delete(v348);
    }
    else
    {
      *v441 = v432.f64[0];
      v347 = v346 + 1;
    }
    v441 = v347;
    v357 = v432.f64[1];
    v358 = v438;
    if (v438 >= v439)
    {
      v360 = (char *)__p;
      v361 = (v438 - (_BYTE *)__p) >> 3;
      v362 = v361 + 1;
      if ((unint64_t)(v361 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v363 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v362)
        v362 = v363 >> 2;
      if ((unint64_t)v363 >= 0x7FFFFFFFFFFFFFF8)
        v364 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v364 = v362;
      if (v364)
      {
        v365 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v364);
        v360 = (char *)__p;
        v358 = v438;
      }
      else
      {
        v365 = 0;
      }
      v366 = &v365[8 * v361];
      v367 = &v365[8 * v364];
      *(float64_t *)v366 = v357;
      v359 = v366 + 8;
      while (v358 != v360)
      {
        v368 = *((_QWORD *)v358 - 1);
        v358 -= 8;
        *((_QWORD *)v366 - 1) = v368;
        v366 -= 8;
      }
      __p = v366;
      v438 = v359;
      v439 = v367;
      if (v360)
        operator delete(v360);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v359 = v358 + 8;
    }
    v438 = v359;
    v369 = *((_QWORD *)&v433 + 1);
    v370 = v435;
    if (v435 >= (double *)v436)
    {
      v372 = (double *)v434;
      v373 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v374 = v373 + 1;
      if ((unint64_t)(v373 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v375 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v374)
        v374 = v375 >> 2;
      if ((unint64_t)v375 >= 0x7FFFFFFFFFFFFFF8)
        v376 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v376 = v374;
      if (v376)
      {
        v377 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v376);
        v372 = (double *)v434;
        v370 = v435;
      }
      else
      {
        v377 = 0;
      }
      v378 = &v377[8 * v373];
      v379 = &v377[8 * v376];
      *(_QWORD *)v378 = v369;
      v371 = (double *)(v378 + 8);
      while (v370 != v372)
      {
        v380 = *((_QWORD *)v370-- - 1);
        *((_QWORD *)v378 - 1) = v380;
        v378 -= 8;
      }
      v434 = v378;
      v435 = v371;
      v436 = v379;
      if (v372)
        operator delete(v372);
    }
    else
    {
      *v435 = *((double *)&v433 + 1);
      v371 = v370 + 1;
    }
    v435 = v371;
    __asm { FMOV            V1.2D, #-0.5 }
    v382 = vmulq_f64(*(float64x2_t *)(a3 + 200), _Q1);
    v432 = v382;
    v433 = xmmword_1B304EEE0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      v383 = *((double *)&v433 + 1);
      v429 = v432.f64[0];
    }
    else
    {
      v429 = v382.f64[0];
      v383 = 1.0;
    }
    v17 = v383 > 0.0 && v309;
    v384 = v441;
    if (v441 >= (double *)v442)
    {
      v386 = v440;
      v387 = v441 - v440;
      v388 = v387 + 1;
      if ((unint64_t)(v387 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v389 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v388)
        v388 = v389 >> 2;
      if ((unint64_t)v389 >= 0x7FFFFFFFFFFFFFF8)
        v390 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v390 = v388;
      if (v390)
      {
        v391 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v390);
        v386 = v440;
        v384 = v441;
      }
      else
      {
        v391 = 0;
      }
      v392 = (double *)&v391[8 * v387];
      v393 = &v391[8 * v390];
      *v392 = v429;
      v385 = v392 + 1;
      while (v384 != v386)
      {
        v394 = *((_QWORD *)v384-- - 1);
        *((_QWORD *)v392-- - 1) = v394;
      }
      v440 = v392;
      v441 = v385;
      v442 = v393;
      if (v386)
        operator delete(v386);
    }
    else
    {
      *v441 = v429;
      v385 = v384 + 1;
    }
    v441 = v385;
    v395 = v432.f64[1];
    v396 = v438;
    if (v438 >= v439)
    {
      v398 = (char *)__p;
      v399 = (v438 - (_BYTE *)__p) >> 3;
      v400 = v399 + 1;
      if ((unint64_t)(v399 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v401 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v400)
        v400 = v401 >> 2;
      if ((unint64_t)v401 >= 0x7FFFFFFFFFFFFFF8)
        v402 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v402 = v400;
      if (v402)
      {
        v403 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v402);
        v398 = (char *)__p;
        v396 = v438;
      }
      else
      {
        v403 = 0;
      }
      v404 = &v403[8 * v399];
      v405 = &v403[8 * v402];
      *(float64_t *)v404 = v395;
      v397 = v404 + 8;
      while (v396 != v398)
      {
        v406 = *((_QWORD *)v396 - 1);
        v396 -= 8;
        *((_QWORD *)v404 - 1) = v406;
        v404 -= 8;
      }
      __p = v404;
      v438 = v397;
      v439 = v405;
      if (v398)
        operator delete(v398);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v397 = v396 + 8;
    }
    v438 = v397;
    v265 = *((_QWORD *)&v433 + 1);
    v266 = (char *)v435;
    if (v435 >= (double *)v436)
    {
      v14 = (char *)v434;
      v407 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v408 = v407 + 1;
      if ((unint64_t)(v407 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v409 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v408)
        v408 = v409 >> 2;
      if ((unint64_t)v409 >= 0x7FFFFFFFFFFFFFF8)
        v410 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v410 = v408;
      if (v410)
      {
        v411 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v410);
        v14 = (char *)v434;
        v266 = (char *)v435;
      }
      else
      {
        v411 = 0;
      }
      v272 = &v411[8 * v407];
      v273 = &v411[8 * v410];
      *(_QWORD *)v272 = v265;
      v274 = (double *)(v272 + 8);
      while (v266 != v14)
      {
        v412 = *((_QWORD *)v266 - 1);
        v266 -= 8;
        *((_QWORD *)v272 - 1) = v412;
        v272 -= 8;
      }
LABEL_589:
      v434 = v272;
      v435 = v274;
      v436 = v273;
      if (!v14)
        goto LABEL_591;
      goto LABEL_590;
    }
LABEL_576:
    *(_QWORD *)v266 = v265;
    goto LABEL_591;
  }
  v12 = (os_unfair_lock_s *)(a1 + 208);
  OZChannelCurve::getEnabledVerticesList(v12, a2, &v430);
  v13 = ((unint64_t)(v431 - v430) >> 4);
  std::vector<double>::reserve((void **)&v440, v13);
  std::vector<double>::reserve(&__p, v13);
  std::vector<double>::reserve(&v434, v13);
  v14 = v431;
  if (v431 == v430)
  {
    v17 = 1;
    if (!v431)
      goto LABEL_591;
    goto LABEL_213;
  }
  v15 = 0;
  v16 = 0;
  v17 = 1;
  v14 = v430;
  do
  {
    OZChannelCurve::getVertexValue((uint64_t)v12, *(char **)&v14[16 * v15], *(char **)&v14[16 * v15 + 8], a2, &v444, &v443);
    if (*(_DWORD *)(a3 + 172) != 2)
    {
      OZChannelCurve::getInputTangents((uint64_t)v12, *(char **)&v430[16 * v15], *(char **)&v430[16 * v15 + 8], a2, v446, &v445);
      if (fabs(v446[0]) >= 0.0000001 || fabs(v445) >= 0.0000001)
      {
        v18 = v446[0] + v444;
        v432.f64[0] = v446[0] + v444;
        v432.f64[1] = v443 + v445;
        v433 = xmmword_1B304EEE0;
        if (a4)
        {
          PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
          v19 = *((double *)&v433 + 1);
          v18 = v432.f64[0];
        }
        else
        {
          v19 = 1.0;
        }
        v20 = v19 > 0.0;
        v21 = v441;
        if (v441 >= (double *)v442)
        {
          v23 = v440;
          v24 = v441 - v440;
          v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v26 = v442 - (char *)v440;
          if ((v442 - (char *)v440) >> 2 > v25)
            v25 = v26 >> 2;
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
            v27 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v27 = v25;
          if (v27)
          {
            v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v27);
            v23 = v440;
            v21 = v441;
          }
          else
          {
            v28 = 0;
          }
          v29 = (double *)&v28[8 * v24];
          *v29 = v18;
          v22 = v29 + 1;
          while (v21 != v23)
          {
            v30 = *((_QWORD *)v21-- - 1);
            *((_QWORD *)v29-- - 1) = v30;
          }
          v440 = v29;
          v441 = v22;
          v442 = &v28[8 * v27];
          if (v23)
            operator delete(v23);
        }
        else
        {
          *v441 = v18;
          v22 = v21 + 1;
        }
        v441 = v22;
        v31 = v432.f64[1];
        v32 = v438;
        if (v438 >= v439)
        {
          v34 = (char *)__p;
          v35 = (v438 - (_BYTE *)__p) >> 3;
          v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v37 = v439 - (_BYTE *)__p;
          if ((v439 - (_BYTE *)__p) >> 2 > v36)
            v36 = v37 >> 2;
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
            v38 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v38 = v36;
          if (v38)
          {
            v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v38);
            v34 = (char *)__p;
            v32 = v438;
          }
          else
          {
            v39 = 0;
          }
          v40 = &v39[8 * v35];
          *(float64_t *)v40 = v31;
          v33 = v40 + 8;
          while (v32 != v34)
          {
            v41 = *((_QWORD *)v32 - 1);
            v32 -= 8;
            *((_QWORD *)v40 - 1) = v41;
            v40 -= 8;
          }
          __p = v40;
          v438 = v33;
          v439 = &v39[8 * v38];
          if (v34)
            operator delete(v34);
        }
        else
        {
          *(float64_t *)v438 = v432.f64[1];
          v33 = v32 + 8;
        }
        v438 = v33;
        v42 = *((_QWORD *)&v433 + 1);
        v43 = v435;
        if (v435 >= (double *)v436)
        {
          v45 = (double *)v434;
          v46 = ((char *)v435 - (_BYTE *)v434) >> 3;
          v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v48 = v436 - (_BYTE *)v434;
          if ((v436 - (_BYTE *)v434) >> 2 > v47)
            v47 = v48 >> 2;
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
            v49 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v49 = v47;
          if (v49)
          {
            v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v49);
            v45 = (double *)v434;
            v43 = v435;
          }
          else
          {
            v50 = 0;
          }
          v51 = &v50[8 * v46];
          *(_QWORD *)v51 = v42;
          v44 = (double *)(v51 + 8);
          while (v43 != v45)
          {
            v52 = *((_QWORD *)v43-- - 1);
            *((_QWORD *)v51 - 1) = v52;
            v51 -= 8;
          }
          v434 = v51;
          v435 = v44;
          v436 = &v50[8 * v49];
          if (v45)
            operator delete(v45);
        }
        else
        {
          *v435 = *((double *)&v433 + 1);
          v44 = v43 + 1;
        }
        v17 &= v20;
        v435 = v44;
      }
    }
    v53 = v444;
    v432.f64[0] = v444;
    v432.f64[1] = v443;
    v433 = xmmword_1B304EEE0;
    if (a4)
    {
      PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
      v54 = *((double *)&v433 + 1);
      v53 = v432.f64[0];
    }
    else
    {
      v54 = 1.0;
    }
    v55 = v54 > 0.0;
    v56 = v441;
    if (v441 >= (double *)v442)
    {
      v58 = v440;
      v59 = v441 - v440;
      v60 = v59 + 1;
      if ((unint64_t)(v59 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v61 = v442 - (char *)v440;
      if ((v442 - (char *)v440) >> 2 > v60)
        v60 = v61 >> 2;
      if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8)
        v62 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v62 = v60;
      if (v62)
      {
        v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v62);
        v58 = v440;
        v56 = v441;
      }
      else
      {
        v63 = 0;
      }
      v64 = (double *)&v63[8 * v59];
      *v64 = v53;
      v57 = v64 + 1;
      while (v56 != v58)
      {
        v65 = *((_QWORD *)v56-- - 1);
        *((_QWORD *)v64-- - 1) = v65;
      }
      v440 = v64;
      v441 = v57;
      v442 = &v63[8 * v62];
      if (v58)
        operator delete(v58);
    }
    else
    {
      *v441 = v53;
      v57 = v56 + 1;
    }
    v441 = v57;
    v66 = v432.f64[1];
    v67 = v438;
    if (v438 >= v439)
    {
      v69 = (char *)__p;
      v70 = (v438 - (_BYTE *)__p) >> 3;
      v71 = v70 + 1;
      if ((unint64_t)(v70 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v72 = v439 - (_BYTE *)__p;
      if ((v439 - (_BYTE *)__p) >> 2 > v71)
        v71 = v72 >> 2;
      if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8)
        v73 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v73 = v71;
      if (v73)
      {
        v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v73);
        v69 = (char *)__p;
        v67 = v438;
      }
      else
      {
        v74 = 0;
      }
      v75 = &v74[8 * v70];
      *(float64_t *)v75 = v66;
      v68 = v75 + 8;
      while (v67 != v69)
      {
        v76 = *((_QWORD *)v67 - 1);
        v67 -= 8;
        *((_QWORD *)v75 - 1) = v76;
        v75 -= 8;
      }
      __p = v75;
      v438 = v68;
      v439 = &v74[8 * v73];
      if (v69)
        operator delete(v69);
    }
    else
    {
      *(float64_t *)v438 = v432.f64[1];
      v68 = v67 + 8;
    }
    v438 = v68;
    v77 = *((_QWORD *)&v433 + 1);
    v78 = v435;
    if (v435 >= (double *)v436)
    {
      v80 = (double *)v434;
      v81 = ((char *)v435 - (_BYTE *)v434) >> 3;
      v82 = v81 + 1;
      if ((unint64_t)(v81 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v83 = v436 - (_BYTE *)v434;
      if ((v436 - (_BYTE *)v434) >> 2 > v82)
        v82 = v83 >> 2;
      if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8)
        v84 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v84 = v82;
      if (v84)
      {
        v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v84);
        v80 = (double *)v434;
        v78 = v435;
      }
      else
      {
        v85 = 0;
      }
      v86 = &v85[8 * v81];
      *(_QWORD *)v86 = v77;
      v79 = (double *)(v86 + 8);
      while (v78 != v80)
      {
        v87 = *((_QWORD *)v78-- - 1);
        *((_QWORD *)v86 - 1) = v87;
        v86 -= 8;
      }
      v434 = v86;
      v435 = v79;
      v436 = &v85[8 * v84];
      if (v80)
        operator delete(v80);
    }
    else
    {
      *v435 = *((double *)&v433 + 1);
      v79 = v78 + 1;
    }
    v17 &= v55;
    v435 = v79;
    if (*(_DWORD *)(a3 + 172) != 2)
    {
      OZChannelCurve::getOutputTangents((uint64_t)v12, *(char **)&v430[16 * v15], *(char **)&v430[16 * v15 + 8], a2, v446, &v445);
      if (fabs(v446[0]) >= 0.0000001 || fabs(v445) >= 0.0000001)
      {
        v432.f64[0] = v446[0] + v444;
        v432.f64[1] = v443 + v445;
        v433 = xmmword_1B304EEE0;
        if (a4)
          PCMatrix44Tmpl<double>::transform<double>(a4, v432.f64, v432.f64);
        if (v17)
          v17 = *((double *)&v433 + 1) > 0.0;
        v88 = v432.f64[0];
        v89 = v441;
        if (v441 >= (double *)v442)
        {
          v91 = v440;
          v92 = v441 - v440;
          v93 = v92 + 1;
          if ((unint64_t)(v92 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v94 = v442 - (char *)v440;
          if ((v442 - (char *)v440) >> 2 > v93)
            v93 = v94 >> 2;
          if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8)
            v95 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v95 = v93;
          if (v95)
          {
            v96 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v442, v95);
            v91 = v440;
            v89 = v441;
          }
          else
          {
            v96 = 0;
          }
          v97 = (double *)&v96[8 * v92];
          *v97 = v88;
          v90 = v97 + 1;
          while (v89 != v91)
          {
            v98 = *((_QWORD *)v89-- - 1);
            *((_QWORD *)v97-- - 1) = v98;
          }
          v440 = v97;
          v441 = v90;
          v442 = &v96[8 * v95];
          if (v91)
            operator delete(v91);
        }
        else
        {
          *v441 = v432.f64[0];
          v90 = v89 + 1;
        }
        v441 = v90;
        v99 = v432.f64[1];
        v100 = v438;
        if (v438 >= v439)
        {
          v102 = (char *)__p;
          v103 = (v438 - (_BYTE *)__p) >> 3;
          v104 = v103 + 1;
          if ((unint64_t)(v103 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v105 = v439 - (_BYTE *)__p;
          if ((v439 - (_BYTE *)__p) >> 2 > v104)
            v104 = v105 >> 2;
          if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8)
            v106 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v106 = v104;
          if (v106)
          {
            v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v439, v106);
            v102 = (char *)__p;
            v100 = v438;
          }
          else
          {
            v107 = 0;
          }
          v108 = &v107[8 * v103];
          *(float64_t *)v108 = v99;
          v101 = v108 + 8;
          while (v100 != v102)
          {
            v109 = *((_QWORD *)v100 - 1);
            v100 -= 8;
            *((_QWORD *)v108 - 1) = v109;
            v108 -= 8;
          }
          __p = v108;
          v438 = v101;
          v439 = &v107[8 * v106];
          if (v102)
            operator delete(v102);
        }
        else
        {
          *(float64_t *)v438 = v432.f64[1];
          v101 = v100 + 8;
        }
        v438 = v101;
        v110 = *((_QWORD *)&v433 + 1);
        v111 = v435;
        if (v435 >= (double *)v436)
        {
          v113 = (double *)v434;
          v114 = ((char *)v435 - (_BYTE *)v434) >> 3;
          v115 = v114 + 1;
          if ((unint64_t)(v114 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v116 = v436 - (_BYTE *)v434;
          if ((v436 - (_BYTE *)v434) >> 2 > v115)
            v115 = v116 >> 2;
          if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8)
            v117 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v117 = v115;
          if (v117)
          {
            v118 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v436, v117);
            v113 = (double *)v434;
            v111 = v435;
          }
          else
          {
            v118 = 0;
          }
          v119 = &v118[8 * v114];
          *(_QWORD *)v119 = v110;
          v112 = (double *)(v119 + 8);
          while (v111 != v113)
          {
            v120 = *((_QWORD *)v111-- - 1);
            *((_QWORD *)v119 - 1) = v120;
            v119 -= 8;
          }
          v434 = v119;
          v435 = v112;
          v436 = &v118[8 * v117];
          if (v113)
            operator delete(v113);
        }
        else
        {
          *v435 = *((double *)&v433 + 1);
          v112 = v111 + 1;
        }
        v435 = v112;
      }
    }
    v14 = v430;
    v15 = ++v16;
  }
  while (v16 < (unint64_t)((v431 - v430) >> 4));
  if (v430)
  {
LABEL_213:
    v431 = v14;
LABEL_590:
    operator delete(v14);
  }
LABEL_591:
  v413 = v440;
  v414 = (char *)v441 - (char *)v440;
  if ((unint64_t)((char *)v441 - (char *)v440) <= 0x17)
    v415 = 0.0;
  else
    v415 = 1.0;
  v416 = (double *)v434;
  if ((unint64_t)v414 >= 0x18 && v17 != 0)
  {
    v418 = v414 >> 3;
    v419 = (double *)__p;
    _CF = v414 >> 3 != 0;
    v420 = (v414 >> 3) - 1;
    if (v420 == 0 || !_CF)
      v418 = 1;
    v421 = v440;
    v422 = v418;
    do
    {
      if (vabdd_f64(0.0, *v416) >= 0.0000001)
      {
        *v421 = *v421 / *v416;
        *v419 = *v419 / *v416;
      }
      ++v416;
      ++v421;
      ++v419;
      --v422;
    }
    while (v422);
    v423 = 0;
    v415 = 0.0;
    do
    {
      if (v420 == v423)
        v424 = 0;
      else
        v424 = v423 + 1;
      v415 = v415 + (v413[v423] * *((double *)__p + v424) - v413[v424] * *((double *)__p + v423)) * 0.5;
      ++v423;
    }
    while (v418 != v423);
    v416 = (double *)v434;
  }
  if (v416)
  {
    v435 = v416;
    operator delete(v416);
  }
  if (__p)
  {
    v438 = (char *)__p;
    operator delete(__p);
  }
  if (v440)
  {
    v441 = v440;
    operator delete(v440);
  }
  return v415;
}

void sub_1B30021C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,void *a28,uint64_t a29)
{
  uint64_t v29;
  void *v31;

  if (__p)
    operator delete(__p);
  if (a28)
    operator delete(a28);
  v31 = *(void **)(v29 - 160);
  if (v31)
  {
    *(_QWORD *)(v29 - 152) = v31;
    operator delete(v31);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OZShape::setDirty(uint64_t this, char a2, int a3)
{
  uint64_t v5;
  PCMutex *v6;
  _BYTE *v7;
  _BYTE *v8;

  v5 = this;
  v6 = (PCMutex *)(this + 8);
  if (a3)
    this = PCMutex::lock((PCMutex *)(this + 8));
  v7 = *(_BYTE **)(v5 + 2672);
  v7[1192] = a2;
  v7[1193] = a2;
  v7[1194] = a2;
  v8 = *(_BYTE **)(v5 + 2664);
  v8[1192] = a2;
  v8[1193] = a2;
  v8[1194] = a2;
  if (a3)
    return PCMutex::unlock(v6);
  return this;
}

BOOL OZShape::checkConvexity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  float64x2_t v14;
  float64x2_t v15;
  int8x16_t v16;
  float64x2_t v17;

  v7 = 1;
  *(_BYTE *)(a4 + 185) = 1;
  if (!OZShape::isGeometricShape((OZShape *)a1))
  {
    if (*(_DWORD *)(a3 + 168)
      && OZChannel::getValueAsInt((OZChannel *)(a1 + 14280), MEMORY[0x1E0CA2E68], 0.0)
      && (v8 = *(_QWORD *)(a4 + 264), v9 = *(_QWORD *)(a4 + 272) - v8, (unint64_t)v9 >= 0x30))
    {
      v10 = 0;
      v11 = v9 >> 4;
      while (v11 != v10)
      {
        v12 = (v10 + 2) % v11;
        if (v11 - 1 == v10)
          v13 = 0;
        else
          v13 = v10 + 1;
        v14 = *(float64x2_t *)(v8 + 16 * v10++);
        v15 = *(float64x2_t *)(v8 + 16 * v13);
        v16 = (int8x16_t)vsubq_f64(v14, v15);
        v17 = vmulq_f64(vsubq_f64(*(float64x2_t *)(v8 + 16 * v12), v15), (float64x2_t)vextq_s8(v16, v16, 8uLL));
        if (vsubq_f64(v17, (float64x2_t)vdupq_laneq_s64((int64x2_t)v17, 1)).f64[0] >= 0.0)
          goto LABEL_11;
      }
      return *(_BYTE *)(a4 + 185) != 0;
    }
    else
    {
LABEL_11:
      v7 = 0;
      *(_BYTE *)(a4 + 185) = 0;
    }
  }
  return v7;
}

uint64_t OZShape::checkSelfIntersection(OZShape *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = 0;
  *(_BYTE *)(a4 + 186) = 0;
  if (*(_QWORD *)(a4 + 272) - *(_QWORD *)(a4 + 264) >= 0x31uLL)
  {
    if (OZShape::isGeometricShape(this))
    {
      return *(_BYTE *)(a4 + 186) != 0;
    }
    else
    {
      result = isSimplePolygon((uint64_t *)(a4 + 264)) ^ 1;
      *(_BYTE *)(a4 + 186) = result;
    }
  }
  return result;
}

uint64_t OZShape::transformShape(uint64_t a1, const CMTime *a2, double *a3, double *a4)
{
  OZChannelCurve::transformCurve(a1 + 208, a2, a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 144))(a1, 1, 1);
}

uint64_t OZShape::offsetShape(OZShape *this, CMTime *a2, double a3, double a4)
{
  OZChannelCurve::offsetCurve((OZShape *)((char *)this + 208), a2, a3, a4);
  return (*(uint64_t (**)(OZShape *, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 1, 1);
}

uint64_t OZShape::getRenderContourWithRoundness(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  char isShapeContourAnimated;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  OZShapeContour *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  char v16;
  uint64_t v17;
  CMTimeEpoch v18;
  char v19;
  double *v20;
  unint64_t v21;
  BOOL v22;
  double *v23;
  uint64_t v24;
  uint64_t ReparametrizedContour;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t i;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  double *v38;
  double *v39;
  uint64_t v40;
  uint64_t v41;
  double *v42;
  uint64_t v43;
  double v44;
  double v45;
  double v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  double v57;
  double v58;
  double *v59;
  uint64_t v60;
  unint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  _QWORD *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  char *v85;
  _QWORD *v86;
  uint64_t v87;
  double *v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  _QWORD *v92;
  _QWORD *v93;
  _QWORD *v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  char *v99;
  char *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t j;
  _OWORD *v108;
  __int128 v109;
  uint64_t v110;
  _QWORD *v111;
  _QWORD *v112;
  int v113;
  int v114;
  double v115;
  _BOOL4 v116;
  _QWORD *v117;
  _QWORD *v118;
  uint64_t v119;
  uint64_t v120;
  OZShapeContour *v121;
  uint64_t *v122;
  uint64_t v123;
  double *v125;
  uint64_t v126;
  double *v127;
  CMTime *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  void **v132;
  CMTime v133;
  PCMutex *v134;
  char v135;
  CMTime time2;
  CMTime time1;

  v134 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  v135 = 1;
  isShapeContourAnimated = OZShape::isShapeContourAnimated((OZShape *)a1);
  v9 = (uint64_t *)(a1 + 2704);
  if (*(_BYTE *)(a3 + 1194))
  {
    while (1)
    {
      v10 = *(_QWORD *)(a1 + 2720);
      if (!v10)
        break;
      v11 = *v9;
      v12 = *(OZShapeContour **)(*v9 + 16);
      if (v12)
      {
        OZShapeContour::~OZShapeContour(v12);
        MEMORY[0x1B5E29170]();
        v11 = *(_QWORD *)(a1 + 2704);
        v10 = *(_QWORD *)(a1 + 2720);
      }
      *(_QWORD *)(v11 + 16) = 0;
      v13 = *(uint64_t **)(a1 + 2704);
      v14 = *v13;
      *(_QWORD *)(v14 + 8) = v13[1];
      *(_QWORD *)v13[1] = v14;
      *(_QWORD *)(a1 + 2720) = v10 - 1;
      operator delete(v13);
    }
  }
  else
  {
    v15 = *(uint64_t **)(a1 + 2712);
    if (v15 != v9)
    {
      v16 = isShapeContourAnimated;
      do
      {
        v17 = v15[2];
        time1 = *(CMTime *)a2;
        v18 = *(_QWORD *)(v17 + 16);
        *(_OWORD *)&time2.value = *(_OWORD *)v17;
        time2.epoch = v18;
        if (CMTimeCompare(&time1, &time2))
          v19 = v16;
        else
          v19 = 0;
        if ((v19 & 1) == 0 && *(unsigned __int8 *)(a2 + 24) == *(unsigned __int8 *)(v17 + 184))
        {
          v20 = (double *)(v17 + 56);
          if (a4)
          {
            v21 = 0;
            v22 = 0;
            v23 = a4;
LABEL_15:
            v24 = 0;
            while (vabdd_f64(v23[v24], v20[v24]) < 0.0000001)
            {
              if (++v24 == 4)
              {
                v22 = v21 > 2;
                v20 += 4;
                v23 += 4;
                if (++v21 == 4)
                  goto LABEL_152;
                goto LABEL_15;
              }
            }
            if (v22)
            {
LABEL_152:
              v110 = *v15;
              *(_QWORD *)(v110 + 8) = v15[1];
              *(_QWORD *)v15[1] = v110;
              --*(_QWORD *)(a1 + 2720);
              operator delete(v15);
              v111 = operator new(0x18uLL);
              v112 = *(_QWORD **)(a1 + 2712);
              *v111 = v9;
              v111[1] = v112;
              v111[2] = v17;
              *v112 = v111;
              *(_QWORD *)(a1 + 2712) = v111;
              ++*(_QWORD *)(a1 + 2720);
              goto LABEL_170;
            }
          }
          else if (PCMatrix44Tmpl<double>::isIdentity(v20))
          {
            goto LABEL_152;
          }
        }
        v15 = (uint64_t *)v15[1];
      }
      while (v15 != v9);
    }
  }
  ReparametrizedContour = OZShape::getReparametrizedContour(a1, a2, a3, 0);
  v17 = operator new();
  v127 = a4;
  v128 = (CMTime *)a2;
  v129 = a3;
  v133 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  OZShapeContour::OZShapeContour((OZShapeContour *)v17, &v133);
  v126 = a1 + 2704;
  v26 = *(_OWORD *)ReparametrizedContour;
  *(_QWORD *)(v17 + 16) = *(_QWORD *)(ReparametrizedContour + 16);
  *(_OWORD *)v17 = v26;
  v27 = *(_OWORD *)(ReparametrizedContour + 24);
  *(_OWORD *)(v17 + 40) = *(_OWORD *)(ReparametrizedContour + 40);
  *(_OWORD *)(v17 + 24) = v27;
  if (ReparametrizedContour != v17)
  {
    v28 = 0;
    v29 = ReparametrizedContour + 56;
    v30 = v17 + 56;
    do
    {
      for (i = 0; i != 32; i += 8)
        *(_QWORD *)(v30 + i) = *(_QWORD *)(v29 + i);
      ++v28;
      v30 += 32;
      v29 += 32;
    }
    while (v28 != 4);
  }
  v125 = (double *)(v17 + 56);
  *(_WORD *)(v17 + 184) = *(_WORD *)(ReparametrizedContour + 184);
  *(_BYTE *)(v17 + 186) = *(_BYTE *)(ReparametrizedContour + 186);
  v32 = *(_QWORD *)(ReparametrizedContour + 200) - *(_QWORD *)(ReparametrizedContour + 192);
  if (v32)
  {
    v33 = 0;
    v34 = v32 >> 3;
    v35 = (_QWORD *)(v17 + 240);
    v36 = (_QWORD *)(v17 + 232);
    v131 = v17 + 256;
    v132 = (void **)(v17 + 192);
    v130 = v17 + 208;
    if (v34 <= 1)
      v37 = 1;
    else
      v37 = v34;
    while (1)
    {
      v38 = *(double **)(v17 + 216);
      v39 = *(double **)(v17 + 224);
      v40 = v39 - v38;
      if ((unint64_t)((char *)v39 - (char *)v38) <= 0xF)
        break;
      v43 = v40 - 1;
      v44 = v38[v40 - 1];
      v45 = v38[v40 - 2];
      if (vabdd_f64(v44, v45) >= 0.0000001)
        v46 = (*(double *)(*v35 + 8 * v43) - *(double *)(*v35 + 8 * (v40 - 2))) / (v44 - v45);
      else
        v46 = 1.79769313e308;
      v56 = *(_QWORD *)(ReparametrizedContour + 216);
      v57 = *(double *)(v56 + 8 * v33);
      if (vabdd_f64(v57, v44) >= 0.0000001)
        v58 = (*(double *)(*(_QWORD *)(ReparametrizedContour + 240) + 8 * v33) - *(double *)(*v35 + 8 * v43))
            / (v57 - v44);
      else
        v58 = 1.79769313e308;
      if (vabdd_f64(v46, v58) >= 0.0000001)
      {
        if ((unint64_t)v39 >= *v36)
        {
          v70 = v40 + 1;
          if ((unint64_t)(v40 + 1) >> 61)
            goto LABEL_175;
          v71 = *v36 - (_QWORD)v38;
          if (v71 >> 2 > v70)
            v70 = v71 >> 2;
          if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8)
            v72 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v72 = v70;
          if (v72)
          {
            v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v17 + 232, v72);
            v38 = *(double **)(v17 + 216);
            v39 = *(double **)(v17 + 224);
            v57 = *(double *)(v56 + 8 * v33);
          }
          else
          {
            v73 = 0;
          }
          v88 = (double *)&v73[8 * v40];
          *v88 = v57;
          v59 = v88 + 1;
          while (v39 != v38)
          {
            v89 = *((_QWORD *)v39-- - 1);
            *((_QWORD *)v88-- - 1) = v89;
          }
          *(_QWORD *)(v17 + 216) = v88;
          *(_QWORD *)(v17 + 224) = v59;
          *(_QWORD *)(v17 + 232) = &v73[8 * v72];
          if (v38)
            operator delete(v38);
        }
        else
        {
          *v39 = v57;
          v59 = v39 + 1;
        }
        *(_QWORD *)(v17 + 224) = v59;
        v90 = *(_QWORD *)(ReparametrizedContour + 240);
        v92 = *(_QWORD **)(v17 + 248);
        v91 = *(_QWORD *)(v17 + 256);
        if ((unint64_t)v92 >= v91)
        {
          v94 = (_QWORD *)*v35;
          v95 = ((uint64_t)v92 - *v35) >> 3;
          v96 = v95 + 1;
          if ((unint64_t)(v95 + 1) >> 61)
            goto LABEL_175;
          v97 = v91 - (_QWORD)v94;
          if (v97 >> 2 > v96)
            v96 = v97 >> 2;
          if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF8)
            v98 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v98 = v96;
          if (v98)
          {
            v99 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v131, v98);
            v94 = *(_QWORD **)(v17 + 240);
            v92 = *(_QWORD **)(v17 + 248);
          }
          else
          {
            v99 = 0;
          }
          v100 = &v99[8 * v95];
          *(_QWORD *)v100 = *(_QWORD *)(v90 + 8 * v33);
          v93 = v100 + 8;
          while (v92 != v94)
          {
            v101 = *--v92;
            *((_QWORD *)v100 - 1) = v101;
            v100 -= 8;
          }
          *(_QWORD *)(v17 + 240) = v100;
          *(_QWORD *)(v17 + 248) = v93;
          *(_QWORD *)(v17 + 256) = &v99[8 * v98];
          if (v94)
            operator delete(v94);
        }
        else
        {
          *v92 = *(_QWORD *)(v90 + 8 * v33);
          v93 = v92 + 1;
        }
        *(_QWORD *)(v17 + 248) = v93;
        v76 = *(_QWORD *)(ReparametrizedContour + 192);
        v78 = *(char **)(v17 + 200);
        v102 = *(_QWORD *)(v17 + 208);
        if ((unint64_t)v78 < v102)
        {
LABEL_117:
          *(_QWORD *)v78 = *(_QWORD *)(v76 + 8 * v33);
          v86 = v78 + 8;
LABEL_132:
          *(_QWORD *)(v17 + 200) = v86;
          goto LABEL_133;
        }
        v79 = (char *)*v132;
        v103 = (v78 - (_BYTE *)*v132) >> 3;
        v104 = v103 + 1;
        if ((unint64_t)(v103 + 1) >> 61)
LABEL_175:
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v105 = v102 - (_QWORD)v79;
        if (v105 >> 2 > v104)
          v104 = v105 >> 2;
        if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8)
          v83 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v83 = v104;
        if (v83)
        {
          v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v130, v83);
          v79 = *(char **)(v17 + 192);
          v78 = *(char **)(v17 + 200);
        }
        else
        {
          v84 = 0;
        }
        v85 = &v84[8 * v103];
        *(_QWORD *)v85 = *(_QWORD *)(v76 + 8 * v33);
        v86 = v85 + 8;
        while (v78 != v79)
        {
          v106 = *((_QWORD *)v78 - 1);
          v78 -= 8;
          *((_QWORD *)v85 - 1) = v106;
          v85 -= 8;
        }
LABEL_130:
        *(_QWORD *)(v17 + 192) = v85;
        *(_QWORD *)(v17 + 200) = v86;
        *(_QWORD *)(v17 + 208) = &v84[8 * v83];
        if (v79)
          operator delete(v79);
        goto LABEL_132;
      }
      v38[v43] = v57;
      *(_QWORD *)(*v35 + 8 * v43) = *(_QWORD *)(*(_QWORD *)(ReparametrizedContour + 240) + 8 * v33);
      *((_QWORD *)*v132 + v43) = *(_QWORD *)(*(_QWORD *)(ReparametrizedContour + 192) + 8 * v33);
LABEL_133:
      if (++v33 == v37)
        goto LABEL_134;
    }
    v41 = *(_QWORD *)(ReparametrizedContour + 216);
    if ((unint64_t)v39 >= *v36)
    {
      v47 = *v36 - (_QWORD)v38;
      if (v47 >> 2 <= (unint64_t)(v40 + 1))
        v48 = v40 + 1;
      else
        v48 = v47 >> 2;
      if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8)
        v49 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v49 = v48;
      v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v17 + 232, v49);
      v52 = *(char **)(v17 + 216);
      v53 = *(char **)(v17 + 224);
      v54 = &v51[8 * v40];
      *(_QWORD *)v54 = *(_QWORD *)(v41 + 8 * v33);
      v42 = (double *)(v54 + 8);
      while (v53 != v52)
      {
        v55 = *((_QWORD *)v53 - 1);
        v53 -= 8;
        *((_QWORD *)v54 - 1) = v55;
        v54 -= 8;
      }
      *(_QWORD *)(v17 + 216) = v54;
      *(_QWORD *)(v17 + 224) = v42;
      *(_QWORD *)(v17 + 232) = &v51[8 * v50];
      if (v52)
        operator delete(v52);
    }
    else
    {
      *v39 = *(double *)(v41 + 8 * v33);
      v42 = v39 + 1;
    }
    *(_QWORD *)(v17 + 224) = v42;
    v60 = *(_QWORD *)(ReparametrizedContour + 240);
    v62 = *(_QWORD **)(v17 + 248);
    v61 = *(_QWORD *)(v17 + 256);
    if ((unint64_t)v62 >= v61)
    {
      v64 = (_QWORD *)*v35;
      v65 = ((uint64_t)v62 - *v35) >> 3;
      v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61)
        goto LABEL_174;
      v67 = v61 - (_QWORD)v64;
      if (v67 >> 2 > v66)
        v66 = v67 >> 2;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      if (v68)
      {
        v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v131, v68);
        v64 = *(_QWORD **)(v17 + 240);
        v62 = *(_QWORD **)(v17 + 248);
      }
      else
      {
        v69 = 0;
      }
      v74 = &v69[8 * v65];
      *(_QWORD *)v74 = *(_QWORD *)(v60 + 8 * v33);
      v63 = v74 + 8;
      while (v62 != v64)
      {
        v75 = *--v62;
        *((_QWORD *)v74 - 1) = v75;
        v74 -= 8;
      }
      *(_QWORD *)(v17 + 240) = v74;
      *(_QWORD *)(v17 + 248) = v63;
      *(_QWORD *)(v17 + 256) = &v69[8 * v68];
      if (v64)
        operator delete(v64);
    }
    else
    {
      *v62 = *(_QWORD *)(v60 + 8 * v33);
      v63 = v62 + 1;
    }
    *(_QWORD *)(v17 + 248) = v63;
    v76 = *(_QWORD *)(ReparametrizedContour + 192);
    v78 = *(char **)(v17 + 200);
    v77 = *(_QWORD *)(v17 + 208);
    if ((unint64_t)v78 < v77)
      goto LABEL_117;
    v79 = (char *)*v132;
    v80 = (v78 - (_BYTE *)*v132) >> 3;
    v81 = v80 + 1;
    if ((unint64_t)(v80 + 1) >> 61)
LABEL_174:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v82 = v77 - (_QWORD)v79;
    if (v82 >> 2 > v81)
      v81 = v82 >> 2;
    if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8)
      v83 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v83 = v81;
    if (v83)
    {
      v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v130, v83);
      v79 = *(char **)(v17 + 192);
      v78 = *(char **)(v17 + 200);
    }
    else
    {
      v84 = 0;
    }
    v85 = &v84[8 * v80];
    *(_QWORD *)v85 = *(_QWORD *)(v76 + 8 * v33);
    v86 = v85 + 8;
    while (v78 != v79)
    {
      v87 = *((_QWORD *)v78 - 1);
      v78 -= 8;
      *((_QWORD *)v85 - 1) = v87;
      v85 -= 8;
    }
    goto LABEL_130;
  }
LABEL_134:
  *(_BYTE *)(v17 + 187) = !OZShape::checkWindingOrder((OZShape *)a1, v128, v129, v127, 0);
  if (v127)
  {
    if (v125 != v127)
    {
      for (j = 0; j != 16; j += 4)
      {
        v108 = (_OWORD *)(v17 + 56 + j * 8);
        v109 = *(_OWORD *)&v127[j + 2];
        *v108 = *(_OWORD *)&v127[j];
        v108[1] = v109;
      }
    }
  }
  else
  {
    *(_QWORD *)(v17 + 176) = 0x3FF0000000000000;
    *(_QWORD *)(v17 + 136) = 0x3FF0000000000000;
    *(_QWORD *)(v17 + 96) = 0x3FF0000000000000;
    *(_QWORD *)(v17 + 56) = 0x3FF0000000000000;
    *(_OWORD *)(v17 + 64) = 0u;
    *(_OWORD *)(v17 + 80) = 0u;
    *(_OWORD *)(v17 + 104) = 0u;
    *(_OWORD *)(v17 + 120) = 0u;
    *(_OWORD *)(v17 + 144) = 0u;
    *(_OWORD *)(v17 + 160) = 0u;
  }
  if (*(_DWORD *)(v129 + 120)
    && *(int *)(v129 + 180) >= 1
    && OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) != 4
    && *(_QWORD *)(v17 + 216) != *(_QWORD *)(v17 + 224)
    && *(_QWORD *)(v17 + 240) != *(_QWORD *)(v17 + 248)
    && *(_QWORD *)(v17 + 192) != *(_QWORD *)(v17 + 200)
    && OZShape::shouldDrawSoftEdges((OZShape *)a1, (const OZShapeRenderParams *)v129))
  {
    if (OZShape::shouldDrawAntialiasingOnFill((OZShape *)a1, (const OZShapeRenderParams *)v129))
    {
      OZShape::computeAntialiasedBorders(a1, v128, v129, v17, v125, 1, 1, 1, 0.0);
      if (!*(_BYTE *)(v17 + 185) || *(_BYTE *)(v17 + 186) || !*(_BYTE *)(v17 + 187))
        OZShape::computeAntialiasedBorders(a1, v128, v129, v17, v125, 1, 0, -1, 0.0);
    }
    else
    {
      OZShape::computeSoftEdges(a1, v128, v129, v17, 0, 1, 1, *(double *)(v129 + 224));
      if (!*(_BYTE *)(v17 + 185) || *(_BYTE *)(v17 + 186) || !*(_BYTE *)(v17 + 187))
        OZShape::computeSoftEdges(a1, v128, v129, v17, 0, 0, -1, *(double *)(v129 + 224));
    }
  }
  if (*(double *)(v129 + 16) > 0.0
    && *(_DWORD *)(v129 + 8)
    && *(int *)(v129 + 180) >= 1
    && OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) != 4
    && (OZShape::isWriteOnEffectEnabled(a1, v129) & 1) == 0)
  {
    v113 = *(_DWORD *)(v129 + 168);
    v114 = *(_DWORD *)(v129 + 24);
    v115 = *(double *)(v129 + 16);
    v116 = !PCMatrix44Tmpl<double>::isIdentity(v125);
    if (v113)
      OZShape::computeOutline(a1, v128, v129, (uint64_t *)v17, v125, v114, v116, v115);
    else
      OZShape::computeOpenStroke(a1, v128, v129, (_QWORD *)v17, v125, v114, v116, v115);
  }
  v117 = operator new(0x18uLL);
  v118 = *(_QWORD **)(a1 + 2712);
  *v117 = v126;
  v117[1] = v118;
  v117[2] = v17;
  *v118 = v117;
  *(_QWORD *)(a1 + 2712) = v117;
  v119 = *(_QWORD *)(a1 + 2720);
  *(_QWORD *)(a1 + 2720) = v119 + 1;
  if ((unint64_t)(v119 + 1) >= 0xB)
  {
    v120 = *(_QWORD *)v126;
    v121 = *(OZShapeContour **)(*(_QWORD *)v126 + 16);
    if (v121)
    {
      OZShapeContour::~OZShapeContour(v121);
      MEMORY[0x1B5E29170]();
      v120 = *(_QWORD *)(a1 + 2704);
      v119 = *(_QWORD *)(a1 + 2720) - 1;
    }
    *(_QWORD *)(v120 + 16) = 0;
    v122 = *(uint64_t **)(a1 + 2704);
    v123 = *v122;
    *(_QWORD *)(v123 + 8) = v122[1];
    *(_QWORD *)v122[1] = v123;
    *(_QWORD *)(a1 + 2720) = v119;
    operator delete(v122);
  }
  *(_BYTE *)(v129 + 1194) = 0;
LABEL_170:
  if (v134 && v135)
    PCMutex::unlock(v134);
  return v17;
}

void sub_1B3002FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t OZShape::isShapeContourAnimated(OZShape *this)
{
  OZChannel *v2;
  OZChannel *v3;

  v2 = (OZChannel *)((char *)this + 1072);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4)
  {
    v3 = (OZChannel *)((char *)this + 12072);
    goto LABEL_5;
  }
  if (OZChannel::getValueAsInt(v2, MEMORY[0x1E0CA2E68], 0.0) == 5)
  {
    v3 = (OZChannel *)((char *)this + 1480);
LABEL_5:
    if (!OZChannel::hasMoreThanOneKeypoint(v3))
      return OZChannelFolder::hasMoreThanOneKeypoint((OZChannelFolder *)((char *)this + 12224));
    return 1;
  }
  if (OZChannel::hasMoreThanOneKeypoint((OZChannel *)((char *)this + 208)))
    return 1;
  return (*(uint64_t (**)(OZShape *))(*(_QWORD *)this + 152))(this);
}

BOOL PCMatrix44Tmpl<double>::isIdentity(double *a1)
{
  double v1;

  v1 = a1[15];
  return fabs(v1) >= 0.0000001
      && vabdd_f64(*a1, v1) < 0.0000001
      && vabdd_f64(a1[5], v1) < 0.0000001
      && vabdd_f64(a1[10], v1) < 0.0000001
      && fabs(a1[1]) < 0.0000001
      && fabs(a1[2]) < 0.0000001
      && fabs(a1[3]) < 0.0000001
      && fabs(a1[4]) < 0.0000001
      && fabs(a1[6]) < 0.0000001
      && fabs(a1[7]) < 0.0000001
      && fabs(a1[8]) < 0.0000001
      && fabs(a1[9]) < 0.0000001
      && fabs(a1[11]) < 0.0000001
      && fabs(a1[12]) < 0.0000001
      && fabs(a1[13]) < 0.0000001
      && fabs(a1[14]) < 0.0000001;
}

uint64_t OZShape::getReparametrizedContour(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  char isShapeContourAnimated;
  uint64_t v9;
  uint64_t *v11;
  uint64_t *v12;
  char v13;
  CMTimeEpoch v14;
  char v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  PCMutex *v19;
  CMTime time2;
  CMTime time1;

  v19 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  isShapeContourAnimated = OZShape::isShapeContourAnimated((OZShape *)a1);
  if (*(_BYTE *)(a3 + 1193)
    || (v11 = (uint64_t *)(a1 + 2728), v12 = *(uint64_t **)(a1 + 2736), v12 == (uint64_t *)(a1 + 2728)))
  {
LABEL_2:
    OZShape::updateReparametrizedContour((OZShape *)a1, a2, a3, a4);
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 2736) + 16);
  }
  else
  {
    v13 = isShapeContourAnimated;
    while (1)
    {
      v9 = v12[2];
      time1 = *(CMTime *)a2;
      v14 = *(_QWORD *)(v9 + 16);
      *(_OWORD *)&time2.value = *(_OWORD *)v9;
      time2.epoch = v14;
      v15 = CMTimeCompare(&time1, &time2) ? v13 : 0;
      if ((v15 & 1) == 0 && *(unsigned __int8 *)(a2 + 24) == *(unsigned __int8 *)(v9 + 184))
        break;
      v12 = (uint64_t *)v12[1];
      if (v12 == v11)
        goto LABEL_2;
    }
    v16 = *v12;
    *(_QWORD *)(v16 + 8) = v12[1];
    *(_QWORD *)v12[1] = v16;
    --*(_QWORD *)(a1 + 2744);
    operator delete(v12);
    v17 = operator new(0x18uLL);
    v18 = *(_QWORD **)(a1 + 2736);
    *v17 = v11;
    v17[1] = v18;
    v17[2] = v9;
    *v18 = v17;
    *(_QWORD *)(a1 + 2736) = v17;
    ++*(_QWORD *)(a1 + 2744);
  }
  if (v19)
    PCMutex::unlock(v19);
  return v9;
}

void sub_1B3003368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void OZShape::updateReparametrizedContour(OZShape *a1, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;
  OZShapeReparametrizedContour *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t i;
  _OWORD *v14;
  __int128 v15;
  double v16;
  double v17;
  uint64_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  BOOL v22;
  float64x2_t v23;
  int8x16_t v24;
  double v25;
  BOOL v26;
  double v27;
  double v28;
  double v29;
  double v30;
  uint64_t v31;
  double v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  double v36;
  double v37;
  unint64_t v38;
  double *v39;
  double *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  double *v47;
  char *v48;
  char *v49;
  double *v50;
  __int128 v51;
  void *v52;
  void *v53;
  unint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  char *v66;
  __int128 v67;
  double v68;
  double v69;
  unint64_t v70;
  double *v71;
  double *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  char *v78;
  double *v79;
  char *v80;
  char *v81;
  double *v82;
  __int128 v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _QWORD *Contour;
  OZChannelShape *v88;
  char *v89;
  double v90;
  double v91;
  char *v92;
  char *v93;
  char *v94;
  double v95;
  double v96;
  char *v97;
  char *v98;
  char *v99;
  double v100;
  double v101;
  char *v102;
  char *v103;
  char *v104;
  char *v105;
  char *v106;
  char *v107;
  uint64_t v108;
  __int128 *v109;
  uint64_t v110;
  unsigned int v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  char *v118;
  char *v119;
  char *v120;
  char *v121;
  __int128 v122;
  __int128 *v123;
  uint64_t Instance;
  double *v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  double Length;
  BOOL v134;
  uint64_t v135;
  void **v136;
  uint64_t v142;
  unsigned int v143;
  uint64_t v144;
  uint64_t v145;
  void *v146;
  uint64_t v147;
  unsigned int v148;
  unint64_t v149;
  double *v150;
  double *v151;
  double *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  double v157;
  double v158;
  double *v159;
  double *v160;
  double *v161;
  int v162;
  int v163;
  double v164;
  uint64_t v165;
  uint64_t v166;
  double v167;
  double v168;
  double v169;
  unint64_t v170;
  float64x2_t v171;
  float64x2_t v172;
  float64x2_t v173;
  int8x16_t v174;
  float64x2_t v175;
  double v176;
  int v177;
  double v178;
  double v179;
  double v180;
  double v181;
  int v182;
  int v183;
  double *v184;
  double *v185;
  double *v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  char *v191;
  double *v192;
  uint64_t v193;
  double *v194;
  double *v195;
  double *v196;
  uint64_t v197;
  unint64_t v198;
  uint64_t v199;
  unint64_t v200;
  char *v201;
  double *v202;
  uint64_t v203;
  double *v204;
  double *v205;
  double *v206;
  uint64_t v207;
  unint64_t v208;
  uint64_t v209;
  unint64_t v210;
  char *v211;
  double *v212;
  double *v213;
  char *v214;
  uint64_t v215;
  double *v216;
  double *v217;
  double *v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t v221;
  unint64_t v222;
  char *v223;
  double *v224;
  double *v225;
  char *v226;
  uint64_t v227;
  double *v228;
  double *v229;
  double *v230;
  uint64_t v231;
  unint64_t v232;
  uint64_t v233;
  unint64_t v234;
  char *v235;
  double *v236;
  char *v237;
  uint64_t v238;
  double *v239;
  unint64_t v240;
  double v241;
  double v242;
  double v243;
  double *v244;
  double *v245;
  uint64_t v246;
  unint64_t v247;
  uint64_t v248;
  unint64_t v249;
  char *v250;
  double *v251;
  uint64_t v252;
  double v253;
  uint64_t v254;
  void **v255;
  uint64_t v256;
  double v257;
  uint64_t v258;
  uint64_t v259;
  double v260;
  char *v261;
  unint64_t v262;
  char *v263;
  _QWORD *v264;
  uint64_t v265;
  double v266;
  double v267;
  double v268;
  double v269;
  unint64_t v270;
  double *v271;
  double *v272;
  char *v273;
  uint64_t v274;
  unint64_t v275;
  uint64_t v276;
  unint64_t v277;
  char *v278;
  double *v279;
  uint64_t v280;
  unint64_t v281;
  uint64_t v282;
  unint64_t v283;
  char *v284;
  char *v285;
  uint64_t v286;
  char *v287;
  unint64_t v288;
  char *v289;
  _QWORD *v290;
  char *v291;
  uint64_t v292;
  unint64_t v293;
  uint64_t v294;
  unint64_t v295;
  char *v296;
  double *v297;
  uint64_t v298;
  double v299;
  unint64_t v300;
  double *v301;
  double *v302;
  double *v303;
  uint64_t v304;
  unint64_t v305;
  uint64_t v306;
  unint64_t v307;
  char *v308;
  char *v309;
  uint64_t v310;
  double *v311;
  unint64_t v312;
  char *v313;
  double *v314;
  double *v315;
  uint64_t v316;
  unint64_t v317;
  uint64_t v318;
  unint64_t v319;
  char *v320;
  double *v321;
  uint64_t v322;
  unint64_t v323;
  double *v324;
  double *v325;
  uint64_t v326;
  unint64_t v327;
  uint64_t v328;
  double *v329;
  uint64_t v330;
  uint64_t v331;
  void **v332;
  _QWORD *v333;
  unint64_t v334;
  char *v335;
  _QWORD *v336;
  char *v337;
  uint64_t v338;
  unint64_t v339;
  uint64_t v340;
  unint64_t v341;
  char *v342;
  char *v343;
  char *v344;
  uint64_t v345;
  void **v346;
  _QWORD *v347;
  unint64_t v348;
  char *v349;
  _QWORD *v350;
  char *v351;
  uint64_t v352;
  unint64_t v353;
  uint64_t v354;
  unint64_t v355;
  char *v356;
  char *v357;
  char *v358;
  uint64_t v359;
  void **v360;
  _QWORD *v361;
  unint64_t v362;
  char *v363;
  _QWORD *v364;
  char *v365;
  uint64_t v366;
  unint64_t v367;
  uint64_t v368;
  unint64_t v369;
  char *v370;
  char *v371;
  char *v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  double v376;
  unint64_t v377;
  double v378;
  double v379;
  double v380;
  uint64_t v381;
  unint64_t v382;
  double *v383;
  double *v384;
  uint64_t v385;
  double v386;
  double v387;
  double v388;
  uint64_t v389;
  double v390;
  double v391;
  unint64_t v392;
  double *v393;
  double *v394;
  double *v395;
  uint64_t v396;
  unint64_t v397;
  uint64_t v398;
  unint64_t v399;
  char *v400;
  double *v401;
  uint64_t v402;
  unint64_t v403;
  uint64_t v404;
  unint64_t v405;
  char *v406;
  double *v407;
  uint64_t v408;
  uint64_t v409;
  unint64_t v410;
  char *v411;
  _QWORD *v412;
  char *v413;
  uint64_t v414;
  unint64_t v415;
  uint64_t v416;
  unint64_t v417;
  char *v418;
  char *v419;
  uint64_t v420;
  uint64_t v421;
  unint64_t v422;
  char *v423;
  double *v424;
  double *v425;
  uint64_t v426;
  unint64_t v427;
  uint64_t v428;
  unint64_t v429;
  char *v430;
  double *v431;
  uint64_t v432;
  double *v433;
  uint64_t v434;
  double v435;
  double v436;
  unint64_t v437;
  double *v438;
  double *v439;
  double *v440;
  uint64_t v441;
  unint64_t v442;
  uint64_t v443;
  unint64_t v444;
  char *v445;
  double *v446;
  uint64_t v447;
  double v448;
  unint64_t v449;
  double *v450;
  uint64_t v451;
  unint64_t v452;
  uint64_t v453;
  uint64_t v454;
  _QWORD *v455;
  _QWORD *v456;
  uint64_t v457;
  uint64_t v458;
  OZShapeReparametrizedContour *v459;
  uint64_t *v460;
  uint64_t v461;
  OZShape *v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  double v468;
  double v469;
  uint64_t v470;
  uint64_t v471;
  double v472;
  double *v473;
  double *v474;
  void **v475;
  _BYTE __p[48];
  float64x2_t v477;
  __int128 v478;
  uint64_t v479;
  float64x2_t v480[2];
  uint64_t v481;
  void *v482;
  char *v483;
  char *v484;
  void *v485;
  double *v486;
  double *v487;
  void *v488;
  double *v489;
  double *v490;
  double v491;
  _BYTE v492[48];
  float64x2_t v493;
  __int128 v494;
  uint64_t v495;
  __int128 v496;
  __int128 v497;
  double v498;
  CMTime v499;
  _BYTE v500[48];
  float64x2_t v501;
  __int128 v502;
  uint64_t v503;
  __int128 v504;
  __int128 v505;
  uint64_t v506;

  v5 = a3;
  if (*(_BYTE *)(a3 + 1193))
  {
    while (1)
    {
      v8 = *((_QWORD *)a1 + 343);
      if (!v8)
        break;
      v9 = *((_QWORD *)a1 + 341);
      v10 = *(OZShapeReparametrizedContour **)(v9 + 16);
      if (v10)
      {
        OZShapeReparametrizedContour::~OZShapeReparametrizedContour(v10);
        MEMORY[0x1B5E29170]();
        v9 = *((_QWORD *)a1 + 341);
        v8 = *((_QWORD *)a1 + 343);
      }
      *(_QWORD *)(v9 + 16) = 0;
      v11 = (uint64_t *)*((_QWORD *)a1 + 341);
      v12 = *v11;
      *(_QWORD *)(v12 + 8) = v11[1];
      *(_QWORD *)v11[1] = v12;
      *((_QWORD *)a1 + 343) = v8 - 1;
      operator delete(v11);
    }
  }
  v506 = 0x3FF0000000000000;
  v503 = 0x3FF0000000000000;
  *(_QWORD *)&v500[40] = 0x3FF0000000000000;
  *(_QWORD *)v500 = 0x3FF0000000000000;
  memset(&v500[8], 0, 32);
  v501 = 0u;
  v502 = 0u;
  v504 = 0u;
  v505 = 0u;
  if (*(_BYTE *)(v5 + 216))
  {
    if (a4 && v500 != (_BYTE *)a4)
    {
      for (i = 0; i != 16; i += 4)
      {
        v14 = &v500[i * 8];
        v15 = *(_OWORD *)&a4[i + 2];
        *v14 = *(_OWORD *)&a4[i];
        v14[1] = v15;
      }
    }
  }
  else
  {
    PCMatrix44Tmpl<double>::leftShear((double *)v500, *(double *)(v5 + 264), *(long double *)(v5 + 272));
    v17 = *(double *)(v5 + 248);
    v16 = *(double *)(v5 + 256);
    if (v17 != 1.0)
    {
      *(float64x2_t *)v500 = vmulq_n_f64(*(float64x2_t *)v500, v17);
      *(float64x2_t *)&v500[16] = vmulq_n_f64(*(float64x2_t *)&v500[16], v17);
    }
    if (v16 != 1.0)
    {
      *(float64x2_t *)&v500[32] = vmulq_n_f64(*(float64x2_t *)&v500[32], v16);
      v501 = vmulq_n_f64(v501, v16);
    }
    if (a4)
      PCMatrix44Tmpl<double>::rightMult((uint64_t)v500, a4);
  }
  v18 = operator new();
  v499 = *(CMTime *)a2;
  OZShapeReparametrizedContour::OZShapeReparametrizedContour((OZShapeReparametrizedContour *)v18, &v499);
  v20.i64[1] = 0;
  memset(&v492[8], 0, 32);
  v493 = 0u;
  v494 = 0u;
  v496 = 0u;
  v497 = 0u;
  v19.i64[0] = 0x3E7AD7F29ABCAF48;
  v20.i64[0] = *(_QWORD *)(v5 + 248);
  v21.i64[0] = *(_QWORD *)(v5 + 256);
  v22 = *(double *)v20.i64 >= 0.0000001 || *(double *)v20.i64 <= -0.0000001;
  v23.f64[0] = NAN;
  v23.f64[1] = NAN;
  v24 = (int8x16_t)vnegq_f64(v23);
  *(_QWORD *)&v25 = vbslq_s8(v24, v19, v20).u64[0];
  if (!v22)
    *(double *)v20.i64 = v25;
  v468 = *(double *)v20.i64;
  v498 = 1.0;
  v495 = 0x3FF0000000000000;
  *(_QWORD *)&v492[40] = 0x3FF0000000000000;
  *(_QWORD *)v492 = 0x3FF0000000000000;
  v26 = *(double *)v21.i64 >= 0.0000001 || *(double *)v21.i64 <= -0.0000001;
  *(_QWORD *)&v27 = vbslq_s8(v24, v19, v21).u64[0];
  if (v26)
    v27 = *(double *)v21.i64;
  v472 = v27;
  PCMatrix44Tmpl<double>::leftShear((double *)v492, *(double *)(v5 + 264), *(long double *)(v5 + 272));
  if (v468 != 1.0)
  {
    *(float64x2_t *)v492 = vmulq_n_f64(*(float64x2_t *)v492, v468);
    *(float64x2_t *)&v492[16] = vmulq_n_f64(*(float64x2_t *)&v492[16], v468);
  }
  if (v472 != 1.0)
  {
    *(float64x2_t *)&v492[32] = vmulq_n_f64(*(float64x2_t *)&v492[32], v472);
    v493 = vmulq_n_f64(v493, v472);
  }
  PCMatrix44Tmpl<double>::invert((double *)v492, (double *)v492, 0.0);
  v28 = fabs((*(double *)&v492[24] + *(double *)v492 + *(double *)v492 + *(double *)&v492[8] * 0.0)/ (v498 + *((double *)&v496 + 1) + *((double *)&v496 + 1) + *(double *)&v497 * 0.0));
  v29 = fabs((v493.f64[1] + *(double *)&v492[32] * 0.0 + *(double *)&v492[40] + *(double *)&v492[40])/ (v498 + *((double *)&v496 + 1) * 0.0 + *(double *)&v497 + *(double *)&v497));
  if (v28 < v29)
    v29 = v28;
  if (v29 <= 2.0)
    v30 = v29;
  else
    v30 = 2.0;
  v462 = a1;
  v463 = v5;
  if (OZShape::isGeometricShape(a1))
  {
    if (OZChannel::getValueAsInt((OZChannel *)((char *)a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4)
    {
      if (*(double *)(v5 + 192) >= 0.01)
      {
        Contour = (_QWORD *)OZShape::getContour(a1, (const CMTime *)a2, (OZShapeRenderParams *)v5);
        v88 = (OZChannelShape *)operator new();
        PCString::PCString((PCString *)__p, "");
        OZChannelShape::OZChannelShape(v88, (const PCString *)__p, 0, 1u, 0);
        PCString::~PCString((PCString *)__p);
        v89 = (char *)OZChannelCurve::setCurveInterpolation(v88, 4);
        if (*(double *)(v5 + 192) <= 0.99)
        {
          v474 = a4;
          memset(__p, 0, 24);
          v108 = Contour[27];
          if (Contour[28] == v108)
          {
            v123 = 0;
            v109 = 0;
          }
          else
          {
            v109 = 0;
            v110 = 0;
            v111 = 0;
            do
            {
              v112 = *(_QWORD *)(v108 + 8 * v110);
              v113 = *(_QWORD *)(Contour[30] + 8 * v110);
              if ((unint64_t)v109 >= *(_QWORD *)&__p[16])
              {
                v114 = ((uint64_t)v109 - *(_QWORD *)__p) >> 4;
                if ((unint64_t)(v114 + 1) >> 60)
                  std::vector<double>::__throw_length_error[abi:ne180100]();
                v115 = (uint64_t)(*(_QWORD *)&__p[16] - *(_QWORD *)__p) >> 3;
                if (v115 <= v114 + 1)
                  v115 = v114 + 1;
                if (*(_QWORD *)&__p[16] - *(_QWORD *)__p >= 0x7FFFFFFFFFFFFFF0uLL)
                  v116 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v116 = v115;
                v118 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&__p[16], v116);
                v119 = &v118[16 * v114];
                *(_QWORD *)v119 = v112;
                *((_QWORD *)v119 + 1) = v113;
                v89 = *(char **)__p;
                v120 = *(char **)&__p[8];
                v121 = v119;
                while (v120 != v89)
                {
                  v122 = *((_OWORD *)v120 - 1);
                  v120 -= 16;
                  *((_OWORD *)v121 - 1) = v122;
                  v121 -= 16;
                }
                v109 = (__int128 *)(v119 + 16);
                *(_QWORD *)__p = v121;
                *(_QWORD *)&__p[8] = v119 + 16;
                *(_QWORD *)&__p[16] = &v118[16 * v117];
                if (v89)
                  operator delete(v89);
              }
              else
              {
                *(_QWORD *)v109 = v112;
                *((_QWORD *)v109++ + 1) = v113;
              }
              *(_QWORD *)&__p[8] = v109;
              v108 = Contour[27];
              v110 = ++v111;
            }
            while (v111 < (unint64_t)((Contour[28] - v108) >> 3));
            v123 = *(__int128 **)__p;
            v5 = v463;
          }
          *(double *)&v488 = 0.0;
          v489 = 0;
          v490 = 0;
          if ((unint64_t)((char *)v109 - (char *)v123) <= 0x40)
          {
            std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>(&v488, v123, v109, (unint64_t)((char *)v109 - (char *)v123) >> 4);
            a4 = v474;
          }
          else
          {
            Instance = PCCurveFit::getInstance((PCCurveFit *)v89);
            a4 = v474;
            PCCurveFit::FitCurve(Instance, (float64x2_t **)__p, (uint64_t)&v488, 0.1);
          }
          v125 = (double *)v488;
          v126 = (unint64_t)((char *)v489 - (_BYTE *)v488) >> 4;
          if ((int)v126 >= 1)
          {
            v127 = 0;
            v128 = 0;
            v129 = ((((char *)v489 - (_BYTE *)v488) << 28) - 0x100000000) >> 32;
            do
            {
              v131 = (char *)OZChannelCurve::addVertex(v88, (const CMTime *)a2, *(double *)((char *)v488 + v127), *(double *)((char *)v488 + v127 + 8));
              v132 = v130;
              if (v128)
                OZChannelCurve::setInputTangents((uint64_t)v88, v131, v130, (const CMTime *)a2, *((double *)v488 + 2 * (v128 - 1)) - *(double *)((char *)v488 + v127), *((double *)v488 + 2 * (v128 - 1) + 1) - *(double *)((char *)v488 + v127 + 8));
              if (v128 < v129)
                OZChannelCurve::setOutputTangents((uint64_t)v88, v131, v132, (const CMTime *)a2, *(double *)((char *)v488 + v127 + 16) - *(double *)((char *)v488 + v127), *(double *)((char *)v488 + v127 + 24) - *(double *)((char *)v488 + v127 + 8));
              v128 += 3;
              v127 += 48;
            }
            while ((int)v128 < (int)v126);
            v125 = (double *)v488;
            a1 = v462;
            v5 = v463;
            a4 = v474;
          }
          if (v125)
          {
            v489 = v125;
            operator delete(v125);
          }
          if (*(_QWORD *)__p)
          {
            *(_QWORD *)&__p[8] = *(_QWORD *)__p;
            operator delete(*(void **)__p);
          }
        }
        else
        {
          v90 = *(double *)(v5 + 200);
          v91 = *(double *)(v5 + 208);
          v92 = (char *)OZChannelCurve::addVertex(v88, (const CMTime *)a2, -v90, 0.0);
          v94 = v93;
          v95 = v91 * -0.55228475;
          OZChannelCurve::setInputTangents((uint64_t)v88, v92, v93, (const CMTime *)a2, 0.0, v91 * -0.55228475);
          v96 = v91 * 0.55228475;
          OZChannelCurve::setOutputTangents((uint64_t)v88, v92, v94, (const CMTime *)a2, 0.0, v96);
          v97 = (char *)OZChannelCurve::addVertex(v88, (const CMTime *)a2, 0.0, *(double *)(v5 + 208));
          v99 = v98;
          v100 = v90 * -0.55228475;
          OZChannelCurve::setInputTangents((uint64_t)v88, v97, v98, (const CMTime *)a2, v90 * -0.55228475, 0.0);
          v101 = v90 * 0.55228475;
          OZChannelCurve::setOutputTangents((uint64_t)v88, v97, v99, (const CMTime *)a2, v101, 0.0);
          v102 = (char *)OZChannelCurve::addVertex(v88, (const CMTime *)a2, *(double *)(v5 + 200), 0.0);
          v104 = v103;
          OZChannelCurve::setInputTangents((uint64_t)v88, v102, v103, (const CMTime *)a2, 0.0, v96);
          OZChannelCurve::setOutputTangents((uint64_t)v88, v102, v104, (const CMTime *)a2, 0.0, v95);
          v105 = (char *)OZChannelCurve::addVertex(v88, (const CMTime *)a2, 0.0, -*(double *)(v5 + 208));
          v107 = v106;
          OZChannelCurve::setInputTangents((uint64_t)v88, v105, v106, (const CMTime *)a2, v101, 0.0);
          OZChannelCurve::setOutputTangents((uint64_t)v88, v105, v107, (const CMTime *)a2, v100, 0.0);
        }
        OZChannelCurve::closeCurve(v88);
        OZChannelPosition::generatePathFromShape(*(OZChannelPosition **)(v18 + 384), (const CMTime *)a2, v88);
        (*(void (**)(OZChannelShape *))(*(_QWORD *)v88 + 8))(v88);
        Length = OZChannelPosition::getLength(*(_QWORD *)(v18 + 384), a2, (double *)v500);
        *(double *)(v18 + 392) = Length;
        OZChannelPosition::getPositionsReparametrizedWithRange(*(os_unfair_lock_s **)(v18 + 384), (double)(int)vcvtmd_s64_f64(Length * 0.5 + 0.5 + 0.0000001), a2, v18 + 216, v18 + 240, v18 + 192, (double *)v500);
        v134 = 1;
        *(_WORD *)(v18 + 185) = 1;
        if (a4)
          v134 = PCMatrix44Tmpl<double>::isIdentity(a4) || !OZShape::checkWindingOrder(a1, (CMTime *)a2, v5, a4, 0);
        *(_BYTE *)(v18 + 187) = v134;
      }
      else
      {
        OZShape::getRectangleFromCircleReparametrizedContour(a1, (CMTime *)a2, v5, v18, (double *)v500, a4, v30);
      }
    }
    else if (OZChannel::getValueAsInt((OZChannel *)((char *)a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 5)
    {
      OZShape::getRectangleReparametrizedContour(a1, (CMTime *)a2, v5, v18, (double *)v500, a4, v30);
    }
  }
  else
  {
    v31 = (uint64_t)a1 + 208;
    OZChannelPosition::generatePathFromShape(*(OZChannelPosition **)(v18 + 384), (const CMTime *)a2, (OZShape *)((char *)a1 + 208));
    v32 = OZChannelPosition::getLength(*(_QWORD *)(v18 + 384), a2, (double *)v500);
    *(double *)(v18 + 392) = v32;
    OZChannelPosition::getPositionsReparametrizedWithRange(*(os_unfair_lock_s **)(v18 + 384), (double)(int)vcvtmd_s64_f64(v32 / v30 + 0.5 + 0.0000001), a2, v18 + 216, v18 + 240, v18 + 192, (double *)v500);
    v473 = a4;
    OZChannelCurve::getEnabledVerticesList((os_unfair_lock_s *)a1 + 52, (const CMTime *)a2, (char **)__p);
    *(_QWORD *)(v18 + 272) = *(_QWORD *)(v18 + 264);
    *(double *)&v488 = 0.0;
    *(double *)&v485 = 0.0;
    *(double *)&v482 = 0.0;
    v491 = 0.0;
    if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
    {
      v33 = 0;
      v34 = (_QWORD *)(v18 + 264);
      if ((unint64_t)((uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4) <= 1)
        v35 = 1;
      else
        v35 = (uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4;
      do
      {
        OZChannelCurve::getVertexValue(v31, *(char **)(*(_QWORD *)__p + 16 * v33), *(char **)(*(_QWORD *)__p + 16 * v33 + 8), (CMTime *)a2, (double *)&v488, (double *)&v485);
        if (*(_DWORD *)(v5 + 172) != 2)
        {
          OZChannelCurve::getInputTangents(v31, *(char **)(*(_QWORD *)__p + 16 * v33), *(char **)(*(_QWORD *)__p + 16 * v33 + 8), (CMTime *)a2, (double *)&v482, &v491);
          if (fabs(*(double *)&v482) >= 0.0000001 || fabs(v491) >= 0.0000001)
          {
            v36 = *(double *)&v482 + *(double *)&v488;
            v37 = *(double *)&v485 + v491;
            v39 = *(double **)(v18 + 272);
            v38 = *(_QWORD *)(v18 + 280);
            if ((unint64_t)v39 >= v38)
            {
              v41 = ((uint64_t)v39 - *v34) >> 4;
              v42 = v41 + 1;
              if ((unint64_t)(v41 + 1) >> 60)
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v43 = v38 - *v34;
              if (v43 >> 3 > v42)
                v42 = v43 >> 3;
              if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF0)
                v44 = 0xFFFFFFFFFFFFFFFLL;
              else
                v44 = v42;
              v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v18 + 280, v44);
              v47 = (double *)&v46[16 * v41];
              *v47 = v36;
              v47[1] = v37;
              v48 = *(char **)(v18 + 264);
              v49 = *(char **)(v18 + 272);
              v50 = v47;
              while (v49 != v48)
              {
                v51 = *((_OWORD *)v49 - 1);
                v49 -= 16;
                *((_OWORD *)v50 - 1) = v51;
                v50 -= 2;
              }
              v40 = v47 + 2;
              *(_QWORD *)(v18 + 264) = v50;
              *(_QWORD *)(v18 + 272) = v47 + 2;
              *(_QWORD *)(v18 + 280) = &v46[16 * v45];
              if (v48)
                operator delete(v48);
            }
            else
            {
              *v39 = v36;
              v39[1] = v37;
              v40 = v39 + 2;
            }
            *(_QWORD *)(v18 + 272) = v40;
          }
        }
        v52 = v488;
        v53 = v485;
        v55 = *(_QWORD *)(v18 + 272);
        v54 = *(_QWORD *)(v18 + 280);
        if (v55 >= v54)
        {
          v57 = (uint64_t)(v55 - *v34) >> 4;
          v58 = v57 + 1;
          if ((unint64_t)(v57 + 1) >> 60)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v59 = v54 - *v34;
          if (v59 >> 3 > v58)
            v58 = v59 >> 3;
          if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0)
            v60 = 0xFFFFFFFFFFFFFFFLL;
          else
            v60 = v58;
          v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v18 + 280, v60);
          v63 = &v62[16 * v57];
          *(_QWORD *)v63 = v52;
          *((_QWORD *)v63 + 1) = v53;
          v64 = *(char **)(v18 + 264);
          v65 = *(char **)(v18 + 272);
          v66 = v63;
          while (v65 != v64)
          {
            v67 = *((_OWORD *)v65 - 1);
            v65 -= 16;
            *((_OWORD *)v66 - 1) = v67;
            v66 -= 16;
          }
          v56 = v63 + 16;
          *(_QWORD *)(v18 + 264) = v66;
          *(_QWORD *)(v18 + 272) = v63 + 16;
          *(_QWORD *)(v18 + 280) = &v62[16 * v61];
          if (v64)
            operator delete(v64);
        }
        else
        {
          *(double *)v55 = *(double *)&v488;
          *(_QWORD *)(v55 + 8) = v53;
          v56 = (_QWORD *)(v55 + 16);
        }
        *(_QWORD *)(v18 + 272) = v56;
        if (*(_DWORD *)(v5 + 172) != 2)
        {
          OZChannelCurve::getOutputTangents(v31, *(char **)(*(_QWORD *)__p + 16 * v33), *(char **)(*(_QWORD *)__p + 16 * v33 + 8), (CMTime *)a2, (double *)&v482, &v491);
          if (fabs(*(double *)&v482) >= 0.0000001 || fabs(v491) >= 0.0000001)
          {
            v68 = *(double *)&v482 + *(double *)&v488;
            v69 = *(double *)&v485 + v491;
            v71 = *(double **)(v18 + 272);
            v70 = *(_QWORD *)(v18 + 280);
            if ((unint64_t)v71 >= v70)
            {
              v73 = ((uint64_t)v71 - *v34) >> 4;
              v74 = v73 + 1;
              if ((unint64_t)(v73 + 1) >> 60)
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v75 = v70 - *v34;
              if (v75 >> 3 > v74)
                v74 = v75 >> 3;
              if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF0)
                v76 = 0xFFFFFFFFFFFFFFFLL;
              else
                v76 = v74;
              v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v18 + 280, v76);
              v79 = (double *)&v78[16 * v73];
              *v79 = v68;
              v79[1] = v69;
              v80 = *(char **)(v18 + 264);
              v81 = *(char **)(v18 + 272);
              v82 = v79;
              while (v81 != v80)
              {
                v83 = *((_OWORD *)v81 - 1);
                v81 -= 16;
                *((_OWORD *)v82 - 1) = v83;
                v82 -= 2;
              }
              v72 = v79 + 2;
              *(_QWORD *)(v18 + 264) = v82;
              *(_QWORD *)(v18 + 272) = v79 + 2;
              *(_QWORD *)(v18 + 280) = &v78[16 * v77];
              if (v80)
                operator delete(v80);
            }
            else
            {
              *v71 = v68;
              v71[1] = v69;
              v72 = v71 + 2;
            }
            *(_QWORD *)(v18 + 272) = v72;
          }
        }
        ++v33;
      }
      while (v33 != v35);
    }
    a1 = v462;
    *(_BYTE *)(v18 + 187) = !OZShape::checkWindingOrder(v462, (CMTime *)a2, v5, v473, 0);
    OZShape::checkConvexity((uint64_t)v462, v84, v5, v18);
    OZShape::checkSelfIntersection(v462, v85, v86, v18);
    if (*(_QWORD *)__p)
    {
      *(_QWORD *)&__p[8] = *(_QWORD *)__p;
      operator delete(*(void **)__p);
    }
  }
  v136 = (void **)(v18 + 216);
  v135 = *(_QWORD *)(v18 + 216);
  *(_BYTE *)(v18 + 184) = *(_BYTE *)(a2 + 24);
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(v18 + 40) = _Q0;
  if (*(_QWORD *)(v18 + 224) != v135)
  {
    v142 = 0;
    v143 = 1;
    do
    {
      v144 = *(_QWORD *)(*(_QWORD *)(v18 + 240) + 8 * v142);
      *(_QWORD *)__p = *(_QWORD *)(v135 + 8 * v142);
      *(_QWORD *)&__p[8] = v144;
      PCRect<double>::operator|=((float64x2_t *)(v18 + 24), (float64x2_t *)__p);
      v142 = v143;
      v135 = *(_QWORD *)(v18 + 216);
      ++v143;
    }
    while (v142 != (*(_QWORD *)(v18 + 224) - v135) >> 3);
  }
  if (OZChannelBase::isEnabled((OZChannelBase *)((char *)a1 + 6800), 0, 1)
    && !OZChannel::getValueAsInt((OZChannel *)((char *)a1 + 6928), (const CMTime *)a2, 0.0)
    && !OZShape::isGeometricShape(a1))
  {
    *(double *)&v488 = 0.0;
    *(double *)&v485 = 0.0;
    v145 = (uint64_t)a1 + 208;
    *(double *)&v482 = 0.0;
    OZChannelCurve::getEnabledVerticesList((os_unfair_lock_s *)a1 + 52, (const CMTime *)a2, (char **)__p);
    v146 = *(void **)__p;
    if (*(_QWORD *)&__p[8] == *(_QWORD *)__p)
    {
LABEL_164:
      if (v146)
      {
        *(_QWORD *)&__p[8] = v146;
        operator delete(v146);
      }
      v5 = v463;
      goto LABEL_167;
    }
    if (OZChannel::getValueAsInt((OZChannel *)((char *)a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) != 3
      && OZChannel::getValueAsInt((OZChannel *)((char *)a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) != 2
      && fabs((double)*(int *)(v463 + 180)) < 0.0000001)
    {
      v146 = *(void **)__p;
      if (*(_QWORD *)&__p[8] == *(_QWORD *)__p)
      {
LABEL_163:
        a1 = v462;
        goto LABEL_164;
      }
      v147 = 0;
      v148 = 0;
      LODWORD(v149) = 0;
      v150 = *(double **)(v18 + 192);
      v151 = *(double **)(v18 + 240);
      v152 = *(double **)(v18 + 216);
      do
      {
        OZChannelCurve::getVertexValue(v145, *((char **)v146 + 2 * v147), *((char **)v146 + 2 * v147 + 1), (CMTime *)a2, (double *)&v488, (double *)&v485);
        OZChannelCurve::getVertexParametricValue(v145, *(char **)(*(_QWORD *)__p + 16 * v147), *(_QWORD *)(*(_QWORD *)__p + 16 * v147 + 8), (CMTime *)a2, (double *)&v482);
        v153 = *(_QWORD *)(v18 + 192);
        v154 = (*(_QWORD *)(v18 + 200) - v153) >> 3;
        if (v154 > v149)
        {
          v155 = 0;
          v156 = v149;
          while (1)
          {
            v157 = *(double *)(v153 + 8 * v156);
            if (*(double *)&v482 <= v157)
              break;
            v149 = (v149 + 1);
            ++v155;
            v156 = v149;
            if (v154 <= v149)
            {
              v150 = (double *)((char *)v150 + v155 * 8);
              v151 = (double *)((char *)v151 + v155 * 8);
              v152 = (double *)((char *)v152 + v155 * 8);
              goto LABEL_161;
            }
          }
          v158 = vabdd_f64(*(double *)&v482, v157);
          v159 = &v150[v155];
          v160 = &v151[v155];
          v161 = &v152[v155];
          if (v158 >= 0.0000001)
          {
            if ((_DWORD)v149 && vabdd_f64(*(double *)&v482, *(double *)(v153 + 8 * (v149 - 1))) < v158)
            {
              v161 = &v152[v155 - 1];
              v160 = &v151[v155 - 1];
              v159 = &v150[v155 - 1];
              LODWORD(v149) = v149 - 1;
            }
            *v161 = *(double *)&v488;
            *v160 = *(double *)&v485;
            *v159 = *(double *)&v482;
          }
          v152 = v161;
          v151 = v160;
          v150 = v159;
        }
LABEL_161:
        v146 = *(void **)__p;
        v147 = ++v148;
      }
      while (v148 < (unint64_t)((uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4));
    }
    v146 = *(void **)__p;
    goto LABEL_163;
  }
LABEL_167:
  if (*(int *)(v5 + 180) < 1
    || OZChannel::getValueAsInt((OZChannel *)((char *)a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4)
  {
    goto LABEL_405;
  }
  v162 = *(_DWORD *)(v5 + 180);
  *(double *)&v488 = 0.0;
  v489 = 0;
  v490 = 0;
  *(double *)&v485 = 0.0;
  v486 = 0;
  v487 = 0;
  *(double *)&v482 = 0.0;
  v483 = 0;
  v484 = 0;
  v475 = (void **)(v18 + 192);
  std::vector<double>::reserve(&v488, (uint64_t)(*(_QWORD *)(v18 + 200) - *(_QWORD *)(v18 + 192)) >> 3);
  std::vector<double>::reserve(&v485, (uint64_t)(*(_QWORD *)(v18 + 200) - *(_QWORD *)(v18 + 192)) >> 3);
  v163 = vcvtmd_s64_f64(((double)v162 + (double)v162) / v30 + 0.5 + 0.0000001);
  v164 = (double)v163;
  v166 = *(_QWORD *)(v18 + 192);
  v165 = *(_QWORD *)(v18 + 200);
  v167 = (double)*(int *)(v5 + 184);
  v481 = 0x3FF0000000000000;
  v479 = 0x3FF0000000000000;
  *(_QWORD *)&__p[40] = 0x3FF0000000000000;
  *(_QWORD *)__p = 0x3FF0000000000000;
  if ((double)v163 * 0.5 < v167)
    v167 = (double)v163 * 0.5;
  v469 = v167;
  memset(&__p[8], 0, 32);
  v477 = 0u;
  v478 = 0u;
  memset(v480, 0, sizeof(v480));
  PCMatrix44Tmpl<double>::leftShear((double *)__p, *(double *)(v5 + 264), *(long double *)(v5 + 272));
  v169 = *(double *)(v5 + 248);
  v168 = *(double *)(v5 + 256);
  if (v169 != 1.0)
  {
    *(float64x2_t *)__p = vmulq_n_f64(*(float64x2_t *)__p, v169);
    *(float64x2_t *)&__p[16] = vmulq_n_f64(*(float64x2_t *)&__p[16], v169);
  }
  if (v168 != 1.0)
  {
    *(float64x2_t *)&__p[32] = vmulq_n_f64(*(float64x2_t *)&__p[32], v168);
    v477 = vmulq_n_f64(v477, v168);
  }
  PCMatrix44Tmpl<double>::invert((double *)__p, (double *)__p, 0.0);
  v170 = (unint64_t)(v165 - v166) >> 3;
  v171.f64[0] = *(float64_t *)__p;
  v172.f64[0] = *(float64_t *)&__p[8];
  v173.f64[0] = *(float64_t *)&__p[24];
  v174 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)v480 + 8), (float64x2_t)0);
  v172.f64[1] = *(float64_t *)&__p[32];
  v171.f64[1] = *(float64_t *)&__p[40];
  v173.f64[1] = v477.f64[1];
  v175 = vabsq_f64(vdivq_f64(vaddq_f64(v173, vaddq_f64(vmulq_f64(v172, (float64x2_t)0), vmulq_n_f64(v171, v469))), vaddq_f64((float64x2_t)vdupq_lane_s64(v481, 0), vaddq_f64((float64x2_t)vextq_s8(v174, v174, 8uLL), vmulq_n_f64(*(float64x2_t *)((char *)v480 + 8), v469)))));
  if (v175.f64[0] >= v175.f64[1])
    v175.f64[0] = v175.f64[1];
  if (v175.f64[0] <= v469)
    v176 = v175.f64[0];
  else
    v176 = v469;
  if ((int)v170 >= 1)
  {
    v177 = 0;
    v178 = v164 + v164;
    v179 = 0.0;
    do
    {
      if (v179 >= v176 + -1.0)
      {
        v180 = 0.0;
        v181 = 0.0;
        if ((double)(int)-v164 < v164)
        {
          v182 = (int)-v164;
          do
          {
            if (*(_DWORD *)(v463 + 168))
            {
              v183 = (v163 + v177 + v182) % (int)v170;
            }
            else
            {
              v183 = v177 + v182;
              if (v177 + v182 < 0)
              {
                v183 = 0;
              }
              else if (v183 >= (int)v170)
              {
                v183 = v170 - 1;
              }
            }
            v180 = v180 + *(double *)(*(_QWORD *)(v18 + 216) + 8 * v183) / v178;
            v181 = v181 + *(double *)(*(_QWORD *)(v18 + 240) + 8 * v183) / v178;
            ++v182;
          }
          while ((double)v182 < v164);
        }
        v184 = v489;
        if (v489 >= v490)
        {
          v186 = (double *)v488;
          v187 = ((char *)v489 - (_BYTE *)v488) >> 3;
          v188 = v187 + 1;
          if ((unint64_t)(v187 + 1) >> 61)
            goto LABEL_569;
          v189 = (char *)v490 - (_BYTE *)v488;
          if (((char *)v490 - (_BYTE *)v488) >> 2 > v188)
            v188 = v189 >> 2;
          if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8)
            v190 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v190 = v188;
          if (v190)
          {
            v191 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v490, v190);
            v186 = (double *)v488;
            v184 = v489;
          }
          else
          {
            v191 = 0;
          }
          v192 = (double *)&v191[8 * v187];
          *v192 = v180;
          v185 = v192 + 1;
          while (v184 != v186)
          {
            v193 = *((_QWORD *)v184-- - 1);
            *((_QWORD *)v192-- - 1) = v193;
          }
          v488 = v192;
          v489 = v185;
          v490 = (double *)&v191[8 * v190];
          if (v186)
            operator delete(v186);
        }
        else
        {
          *v489 = v180;
          v185 = v184 + 1;
        }
        v489 = v185;
        v194 = v486;
        if (v486 >= v487)
        {
          v196 = (double *)v485;
          v197 = ((char *)v486 - (_BYTE *)v485) >> 3;
          v198 = v197 + 1;
          if ((unint64_t)(v197 + 1) >> 61)
LABEL_569:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v199 = (char *)v487 - (_BYTE *)v485;
          if (((char *)v487 - (_BYTE *)v485) >> 2 > v198)
            v198 = v199 >> 2;
          if ((unint64_t)v199 >= 0x7FFFFFFFFFFFFFF8)
            v200 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v200 = v198;
          if (v200)
          {
            v201 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v487, v200);
            v196 = (double *)v485;
            v194 = v486;
          }
          else
          {
            v201 = 0;
          }
          v202 = (double *)&v201[8 * v197];
          *v202 = v181;
          v195 = v202 + 1;
          while (v194 != v196)
          {
            v203 = *((_QWORD *)v194-- - 1);
            *((_QWORD *)v202-- - 1) = v203;
          }
          v485 = v202;
          v486 = v195;
          v487 = (double *)&v201[8 * v200];
          if (v196)
            operator delete(v196);
        }
        else
        {
          *v486 = v181;
          v195 = v194 + 1;
        }
        v486 = v195;
        v179 = 0.0;
      }
      else
      {
        v179 = v179 + 1.0;
      }
      ++v177;
    }
    while (v177 != (_DWORD)v170);
  }
  if (*(_DWORD *)(v463 + 168))
  {
    v205 = (double *)v488;
    v204 = v489;
    if (v489 >= v490)
    {
      v207 = ((char *)v489 - (_BYTE *)v488) >> 3;
      v208 = v207 + 1;
      if ((unint64_t)(v207 + 1) >> 61)
        goto LABEL_578;
      v209 = (char *)v490 - (_BYTE *)v488;
      if (((char *)v490 - (_BYTE *)v488) >> 2 > v208)
        v208 = v209 >> 2;
      if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFF8)
        v210 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v210 = v208;
      if (v210)
      {
        v211 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v490, v210);
        v212 = (double *)v488;
        v204 = v489;
      }
      else
      {
        v211 = 0;
        v212 = (double *)v488;
      }
      v213 = (double *)&v211[8 * v207];
      v214 = &v211[8 * v210];
      *v213 = *v205;
      v206 = v213 + 1;
      while (v204 != v212)
      {
        v215 = *((_QWORD *)v204-- - 1);
        *((_QWORD *)v213-- - 1) = v215;
      }
      v488 = v213;
      v489 = v206;
      v490 = (double *)v214;
      if (v212)
        operator delete(v212);
    }
    else
    {
      *v489 = *(double *)v488;
      v206 = v204 + 1;
    }
    v489 = v206;
    v217 = (double *)v485;
    v216 = v486;
    if (v486 < v487)
    {
      *v486 = *(double *)v485;
      v218 = v216 + 1;
LABEL_260:
      v486 = v218;
      goto LABEL_261;
    }
    v219 = ((char *)v486 - (_BYTE *)v485) >> 3;
    v220 = v219 + 1;
    if (!((unint64_t)(v219 + 1) >> 61))
    {
      v221 = (char *)v487 - (_BYTE *)v485;
      if (((char *)v487 - (_BYTE *)v485) >> 2 > v220)
        v220 = v221 >> 2;
      if ((unint64_t)v221 >= 0x7FFFFFFFFFFFFFF8)
        v222 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v222 = v220;
      if (v222)
      {
        v223 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v487, v222);
        v224 = (double *)v485;
        v216 = v486;
      }
      else
      {
        v223 = 0;
        v224 = (double *)v485;
      }
      v225 = (double *)&v223[8 * v219];
      v226 = &v223[8 * v222];
      *v225 = *v217;
      v218 = v225 + 1;
      while (v216 != v224)
      {
        v227 = *((_QWORD *)v216-- - 1);
        *((_QWORD *)v225-- - 1) = v227;
      }
      v485 = v225;
      v486 = v218;
      v487 = (double *)v226;
      if (v224)
        operator delete(v224);
      goto LABEL_260;
    }
LABEL_578:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_261:
  *(_QWORD *)(v18 + 392) = 0;
  v228 = (double *)v483;
  if (v483 >= v484)
  {
    v230 = (double *)v482;
    v231 = (v483 - (_BYTE *)v482) >> 3;
    v232 = v231 + 1;
    if ((unint64_t)(v231 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v233 = v484 - (_BYTE *)v482;
    if ((v484 - (_BYTE *)v482) >> 2 > v232)
      v232 = v233 >> 2;
    if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFF8)
      v234 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v234 = v232;
    if (v234)
    {
      v235 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v484, v234);
      v230 = (double *)v482;
      v228 = (double *)v483;
    }
    else
    {
      v235 = 0;
    }
    v236 = (double *)&v235[8 * v231];
    v237 = &v235[8 * v234];
    *v236 = 0.0;
    v229 = v236 + 1;
    while (v228 != v230)
    {
      v238 = *((_QWORD *)v228-- - 1);
      *((_QWORD *)v236-- - 1) = v238;
    }
    v482 = v236;
    v483 = (char *)v229;
    v484 = v237;
    if (v230)
      operator delete(v230);
  }
  else
  {
    *(_QWORD *)v483 = 0;
    v229 = v228 + 1;
  }
  v483 = (char *)v229;
  v239 = (double *)v488;
  if ((unint64_t)((char *)v489 - (_BYTE *)v488) < 9)
  {
    v253 = *(double *)(v18 + 392);
  }
  else
  {
    v240 = 1;
    do
    {
      v241 = v239[v240] - v239[(v240 - 1)];
      v242 = sqrt(v241 * v241+ (*((double *)v485 + v240) - *((double *)v485 + (v240 - 1)))* (*((double *)v485 + v240) - *((double *)v485 + (v240 - 1))));
      v243 = *(v229 - 1) + v242;
      if (v229 >= (double *)v484)
      {
        v245 = (double *)v482;
        v246 = ((char *)v229 - (_BYTE *)v482) >> 3;
        v247 = v246 + 1;
        if ((unint64_t)(v246 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v248 = v484 - (_BYTE *)v482;
        if ((v484 - (_BYTE *)v482) >> 2 > v247)
          v247 = v248 >> 2;
        if ((unint64_t)v248 >= 0x7FFFFFFFFFFFFFF8)
          v249 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v249 = v247;
        if (v249)
        {
          v250 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v484, v249);
          v245 = (double *)v482;
          v229 = (double *)v483;
        }
        else
        {
          v250 = 0;
        }
        v251 = (double *)&v250[8 * v246];
        *v251 = v243;
        v244 = v251 + 1;
        while (v229 != v245)
        {
          v252 = *((_QWORD *)v229-- - 1);
          *((_QWORD *)v251-- - 1) = v252;
        }
        v482 = v251;
        v483 = (char *)v244;
        v484 = &v250[8 * v249];
        if (v245)
          operator delete(v245);
      }
      else
      {
        *v229 = v243;
        v244 = v229 + 1;
      }
      v483 = (char *)v244;
      v253 = v242 + *(double *)(v18 + 392);
      *(double *)(v18 + 392) = v253;
      v240 = (v240 + 1);
      v239 = (double *)v488;
      v229 = v244;
    }
    while (v240 < ((char *)v489 - (_BYTE *)v488) >> 3);
  }
  v255 = (void **)(v18 + 240);
  v254 = *(_QWORD *)(v18 + 240);
  *(_QWORD *)(v18 + 224) = *(_QWORD *)(v18 + 216);
  *(_QWORD *)(v18 + 248) = v254;
  *(_QWORD *)(v18 + 200) = *(_QWORD *)(v18 + 192);
  if (v253 > 0.0)
  {
    v256 = 0;
    v466 = v18 + 256;
    v470 = v18 + 232;
    v464 = v18 + 208;
    v257 = 0.0;
    do
    {
      v258 = (int)v256;
      v259 = (v256 << 32) - 0x200000000;
      do
      {
        v260 = *((double *)v482 + v258++);
        v259 += 0x100000000;
      }
      while (v260 < v257);
      if (vabdd_f64(v257, v260) >= 0.0000001)
      {
        v265 = v259 >> 29;
        v266 = (v257 - *(double *)((char *)v482 + v265)) / (v260 - *(double *)((char *)v482 + v265));
        v267 = *(double *)((char *)v485 + v265);
        v268 = *(double *)((char *)v488 + v265)
             + v266 * (*((double *)v488 + v258 - 1) - *(double *)((char *)v488 + v265));
        v269 = *((double *)v485 + v258 - 1);
        v271 = *(double **)(v18 + 224);
        v270 = *(_QWORD *)(v18 + 232);
        if ((unint64_t)v271 >= v270)
        {
          v279 = (double *)*v136;
          v280 = ((char *)v271 - (_BYTE *)*v136) >> 3;
          v281 = v280 + 1;
          if ((unint64_t)(v280 + 1) >> 61)
            goto LABEL_573;
          v282 = v270 - (_QWORD)v279;
          if (v282 >> 2 > v281)
            v281 = v282 >> 2;
          if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFF8)
            v283 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v283 = v281;
          if (v283)
          {
            v284 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v470, v283);
            v279 = *(double **)(v18 + 216);
            v271 = *(double **)(v18 + 224);
          }
          else
          {
            v284 = 0;
          }
          v297 = (double *)&v284[8 * v280];
          *v297 = v268;
          v272 = v297 + 1;
          while (v271 != v279)
          {
            v298 = *((_QWORD *)v271-- - 1);
            *((_QWORD *)v297-- - 1) = v298;
          }
          *(_QWORD *)(v18 + 216) = v297;
          *(_QWORD *)(v18 + 224) = v272;
          *(_QWORD *)(v18 + 232) = &v284[8 * v283];
          if (v279)
            operator delete(v279);
        }
        else
        {
          *v271 = v268;
          v272 = v271 + 1;
        }
        v299 = v267 + v266 * (v269 - v267);
        *(_QWORD *)(v18 + 224) = v272;
        v301 = *(double **)(v18 + 248);
        v300 = *(_QWORD *)(v18 + 256);
        if ((unint64_t)v301 >= v300)
        {
          v303 = (double *)*v255;
          v304 = ((char *)v301 - (_BYTE *)*v255) >> 3;
          v305 = v304 + 1;
          if ((unint64_t)(v304 + 1) >> 61)
            goto LABEL_573;
          v306 = v300 - (_QWORD)v303;
          if (v306 >> 2 > v305)
            v305 = v306 >> 2;
          if ((unint64_t)v306 >= 0x7FFFFFFFFFFFFFF8)
            v307 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v307 = v305;
          if (v307)
          {
            v308 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v466, v307);
            v303 = *(double **)(v18 + 240);
            v301 = *(double **)(v18 + 248);
          }
          else
          {
            v308 = 0;
          }
          v321 = (double *)&v308[8 * v304];
          *v321 = v299;
          v302 = v321 + 1;
          while (v301 != v303)
          {
            v322 = *((_QWORD *)v301-- - 1);
            *((_QWORD *)v321-- - 1) = v322;
          }
          *(_QWORD *)(v18 + 240) = v321;
          *(_QWORD *)(v18 + 248) = v302;
          *(_QWORD *)(v18 + 256) = &v308[8 * v307];
          if (v303)
            operator delete(v303);
        }
        else
        {
          *v301 = v299;
          v302 = v301 + 1;
        }
        *(_QWORD *)(v18 + 248) = v302;
        v324 = *(double **)(v18 + 200);
        v323 = *(_QWORD *)(v18 + 208);
        if ((unint64_t)v324 >= v323)
        {
          v315 = (double *)*v475;
          v326 = ((char *)v324 - (_BYTE *)*v475) >> 3;
          v327 = v326 + 1;
          if ((unint64_t)(v326 + 1) >> 61)
LABEL_573:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v328 = v323 - (_QWORD)v315;
          if (v328 >> 2 > v327)
            v327 = v328 >> 2;
          if ((unint64_t)v328 >= 0x7FFFFFFFFFFFFFF8)
            v319 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v319 = v327;
          if (v319)
          {
            v320 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v464, v319);
            v315 = *(double **)(v18 + 192);
            v324 = *(double **)(v18 + 200);
          }
          else
          {
            v320 = 0;
          }
          v329 = (double *)&v320[8 * v326];
          *v329 = v257;
          v325 = v329 + 1;
          while (v324 != v315)
          {
            v331 = *((_QWORD *)v324-- - 1);
            *((_QWORD *)v329-- - 1) = v331;
          }
          goto LABEL_396;
        }
        *v324 = v257;
        v314 = v324 + 1;
      }
      else
      {
        v261 = (char *)v488 + 8 * v258;
        v263 = *(char **)(v18 + 224);
        v262 = *(_QWORD *)(v18 + 232);
        if ((unint64_t)v263 >= v262)
        {
          v273 = (char *)*v136;
          v274 = (v263 - (_BYTE *)*v136) >> 3;
          v275 = v274 + 1;
          if ((unint64_t)(v274 + 1) >> 61)
            goto LABEL_574;
          v276 = v262 - (_QWORD)v273;
          if (v276 >> 2 > v275)
            v275 = v276 >> 2;
          if ((unint64_t)v276 >= 0x7FFFFFFFFFFFFFF8)
            v277 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v277 = v275;
          if (v277)
          {
            v278 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v470, v277);
            v273 = *(char **)(v18 + 216);
            v263 = *(char **)(v18 + 224);
          }
          else
          {
            v278 = 0;
          }
          v285 = &v278[8 * v274];
          *(_QWORD *)v285 = *((_QWORD *)v261 - 1);
          v264 = v285 + 8;
          while (v263 != v273)
          {
            v286 = *((_QWORD *)v263 - 1);
            v263 -= 8;
            *((_QWORD *)v285 - 1) = v286;
            v285 -= 8;
          }
          *(_QWORD *)(v18 + 216) = v285;
          *(_QWORD *)(v18 + 224) = v264;
          *(_QWORD *)(v18 + 232) = &v278[8 * v277];
          if (v273)
            operator delete(v273);
        }
        else
        {
          *(_QWORD *)v263 = *((_QWORD *)v261 - 1);
          v264 = v263 + 8;
        }
        *(_QWORD *)(v18 + 224) = v264;
        v287 = (char *)v485 + 8 * v258;
        v289 = *(char **)(v18 + 248);
        v288 = *(_QWORD *)(v18 + 256);
        if ((unint64_t)v289 >= v288)
        {
          v291 = (char *)*v255;
          v292 = (v289 - (_BYTE *)*v255) >> 3;
          v293 = v292 + 1;
          if ((unint64_t)(v292 + 1) >> 61)
            goto LABEL_574;
          v294 = v288 - (_QWORD)v291;
          if (v294 >> 2 > v293)
            v293 = v294 >> 2;
          if ((unint64_t)v294 >= 0x7FFFFFFFFFFFFFF8)
            v295 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v295 = v293;
          if (v295)
          {
            v296 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v466, v295);
            v291 = *(char **)(v18 + 240);
            v289 = *(char **)(v18 + 248);
          }
          else
          {
            v296 = 0;
          }
          v309 = &v296[8 * v292];
          *(_QWORD *)v309 = *((_QWORD *)v287 - 1);
          v290 = v309 + 8;
          while (v289 != v291)
          {
            v310 = *((_QWORD *)v289 - 1);
            v289 -= 8;
            *((_QWORD *)v309 - 1) = v310;
            v309 -= 8;
          }
          *(_QWORD *)(v18 + 240) = v309;
          *(_QWORD *)(v18 + 248) = v290;
          *(_QWORD *)(v18 + 256) = &v296[8 * v295];
          if (v291)
            operator delete(v291);
        }
        else
        {
          *(_QWORD *)v289 = *((_QWORD *)v287 - 1);
          v290 = v289 + 8;
        }
        *(_QWORD *)(v18 + 248) = v290;
        v311 = (double *)((char *)v482 + 8 * v258);
        v313 = *(char **)(v18 + 200);
        v312 = *(_QWORD *)(v18 + 208);
        if ((unint64_t)v313 >= v312)
        {
          v315 = (double *)*v475;
          v316 = (v313 - (_BYTE *)*v475) >> 3;
          v317 = v316 + 1;
          if ((unint64_t)(v316 + 1) >> 61)
LABEL_574:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v318 = v312 - (_QWORD)v315;
          if (v318 >> 2 > v317)
            v317 = v318 >> 2;
          if ((unint64_t)v318 >= 0x7FFFFFFFFFFFFFF8)
            v319 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v319 = v317;
          if (v319)
          {
            v320 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v464, v319);
            v315 = *(double **)(v18 + 192);
            v313 = *(char **)(v18 + 200);
          }
          else
          {
            v320 = 0;
          }
          v329 = (double *)&v320[8 * v316];
          *v329 = *(v311 - 1);
          v325 = v329 + 1;
          while (v313 != (char *)v315)
          {
            v330 = *((_QWORD *)v313 - 1);
            v313 -= 8;
            *((_QWORD *)v329-- - 1) = v330;
          }
LABEL_396:
          *(_QWORD *)(v18 + 192) = v329;
          *(_QWORD *)(v18 + 200) = v325;
          *(_QWORD *)(v18 + 208) = &v320[8 * v319];
          if (v315)
            operator delete(v315);
          goto LABEL_398;
        }
        *(double *)v313 = *(v311 - 1);
        v314 = (double *)(v313 + 8);
      }
      v325 = v314;
LABEL_398:
      v256 = v258 - 1;
      *(_QWORD *)(v18 + 200) = v325;
      v257 = v176 + v257;
    }
    while (v257 < *(double *)(v18 + 392));
  }
  if (*(double *)&v482 != 0.0)
  {
    v483 = (char *)v482;
    operator delete(v482);
  }
  v5 = v463;
  if (*(double *)&v485 != 0.0)
  {
    v486 = (double *)v485;
    operator delete(v485);
  }
  if (*(double *)&v488 != 0.0)
  {
    v489 = (double *)v488;
    operator delete(v488);
  }
LABEL_405:
  if (!*(_BYTE *)(v5 + 112))
    goto LABEL_558;
  v332 = (void **)(v18 + 424);
  v333 = *(_QWORD **)(v18 + 216);
  v467 = v18 + 440;
  v335 = *(char **)(v18 + 432);
  v334 = *(_QWORD *)(v18 + 440);
  if ((unint64_t)v335 >= v334)
  {
    v337 = (char *)*v332;
    v338 = (v335 - (_BYTE *)*v332) >> 3;
    v339 = v338 + 1;
    if ((unint64_t)(v338 + 1) >> 61)
      goto LABEL_576;
    v340 = v334 - (_QWORD)v337;
    if (v340 >> 2 > v339)
      v339 = v340 >> 2;
    if ((unint64_t)v340 >= 0x7FFFFFFFFFFFFFF8)
      v341 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v341 = v339;
    if (v341)
    {
      v342 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v467, v341);
      v337 = *(char **)(v18 + 424);
      v335 = *(char **)(v18 + 432);
    }
    else
    {
      v342 = 0;
    }
    v343 = &v342[8 * v338];
    v344 = &v342[8 * v341];
    *(_QWORD *)v343 = *v333;
    v336 = v343 + 8;
    while (v335 != v337)
    {
      v345 = *((_QWORD *)v335 - 1);
      v335 -= 8;
      *((_QWORD *)v343 - 1) = v345;
      v343 -= 8;
    }
    *(_QWORD *)(v18 + 424) = v343;
    *(_QWORD *)(v18 + 432) = v336;
    *(_QWORD *)(v18 + 440) = v344;
    if (v337)
      operator delete(v337);
  }
  else
  {
    *(_QWORD *)v335 = *v333;
    v336 = v335 + 8;
  }
  *(_QWORD *)(v18 + 432) = v336;
  v346 = (void **)(v18 + 448);
  v347 = *(_QWORD **)(v18 + 240);
  v465 = v18 + 464;
  v349 = *(char **)(v18 + 456);
  v348 = *(_QWORD *)(v18 + 464);
  if ((unint64_t)v349 >= v348)
  {
    v351 = (char *)*v346;
    v352 = (v349 - (_BYTE *)*v346) >> 3;
    v353 = v352 + 1;
    if ((unint64_t)(v352 + 1) >> 61)
      goto LABEL_576;
    v354 = v348 - (_QWORD)v351;
    if (v354 >> 2 > v353)
      v353 = v354 >> 2;
    if ((unint64_t)v354 >= 0x7FFFFFFFFFFFFFF8)
      v355 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v355 = v353;
    if (v355)
    {
      v356 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v465, v355);
      v351 = *(char **)(v18 + 448);
      v349 = *(char **)(v18 + 456);
    }
    else
    {
      v356 = 0;
    }
    v357 = &v356[8 * v352];
    v358 = &v356[8 * v355];
    *(_QWORD *)v357 = *v347;
    v350 = v357 + 8;
    while (v349 != v351)
    {
      v359 = *((_QWORD *)v349 - 1);
      v349 -= 8;
      *((_QWORD *)v357 - 1) = v359;
      v357 -= 8;
    }
    *(_QWORD *)(v18 + 448) = v357;
    *(_QWORD *)(v18 + 456) = v350;
    *(_QWORD *)(v18 + 464) = v358;
    if (v351)
      operator delete(v351);
  }
  else
  {
    *(_QWORD *)v349 = *v347;
    v350 = v349 + 8;
  }
  *(_QWORD *)(v18 + 456) = v350;
  v360 = (void **)(v18 + 400);
  v361 = *(_QWORD **)(v18 + 192);
  v471 = v18 + 416;
  v363 = *(char **)(v18 + 408);
  v362 = *(_QWORD *)(v18 + 416);
  if ((unint64_t)v363 >= v362)
  {
    v365 = (char *)*v360;
    v366 = (v363 - (_BYTE *)*v360) >> 3;
    v367 = v366 + 1;
    if (!((unint64_t)(v366 + 1) >> 61))
    {
      v368 = v362 - (_QWORD)v365;
      if (v368 >> 2 > v367)
        v367 = v368 >> 2;
      if ((unint64_t)v368 >= 0x7FFFFFFFFFFFFFF8)
        v369 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v369 = v367;
      if (v369)
      {
        v370 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v471, v369);
        v365 = *(char **)(v18 + 400);
        v363 = *(char **)(v18 + 408);
      }
      else
      {
        v370 = 0;
      }
      v371 = &v370[8 * v366];
      v372 = &v370[8 * v369];
      *(_QWORD *)v371 = *v361;
      v364 = v371 + 8;
      while (v363 != v365)
      {
        v373 = *((_QWORD *)v363 - 1);
        v363 -= 8;
        *((_QWORD *)v371 - 1) = v373;
        v371 -= 8;
      }
      *(_QWORD *)(v18 + 400) = v371;
      *(_QWORD *)(v18 + 408) = v364;
      *(_QWORD *)(v18 + 416) = v372;
      if (v365)
        operator delete(v365);
      goto LABEL_454;
    }
LABEL_576:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  *(_QWORD *)v363 = *v361;
  v364 = v363 + 8;
LABEL_454:
  *(_QWORD *)(v18 + 408) = v364;
  v374 = *(_QWORD *)(v18 + 192);
  v375 = *(_QWORD *)(v18 + 200);
  if ((unint64_t)(v375 - v374) < 9)
    goto LABEL_558;
  v376 = 1.0;
  v377 = 1;
  v378 = 1.0;
  do
  {
    v379 = v378 * 0.05;
    v380 = *(double *)(v374 + 8 * v377);
    if (v380 < v378 * 0.05)
      goto LABEL_557;
    v381 = (v377 - 1);
    do
    {
      if (vabdd_f64(v380, v379) >= 0.0000001)
      {
        if (v380 <= v379)
          goto LABEL_543;
        v385 = *(_QWORD *)(v18 + 216);
        v386 = *(double *)(v385 + 8 * v377);
        v387 = *(double *)(v385 + 8 * v381);
        v388 = *(double *)(v374 + 8 * v381);
        v389 = *(_QWORD *)(v18 + 240);
        v390 = *(double *)(v389 + 8 * v377);
        v391 = *(double *)(v389 + 8 * v381);
        v393 = *(double **)(v18 + 408);
        v392 = *(_QWORD *)(v18 + 416);
        if ((unint64_t)v393 >= v392)
        {
          v401 = (double *)*v360;
          v402 = ((char *)v393 - (_BYTE *)*v360) >> 3;
          v403 = v402 + 1;
          if ((unint64_t)(v402 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v404 = v392 - (_QWORD)v401;
          if (v404 >> 2 > v403)
            v403 = v404 >> 2;
          if ((unint64_t)v404 >= 0x7FFFFFFFFFFFFFF8)
            v405 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v405 = v403;
          if (v405)
          {
            v406 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v471, v405);
            v401 = *(double **)(v18 + 400);
            v393 = *(double **)(v18 + 408);
          }
          else
          {
            v406 = 0;
          }
          v433 = (double *)&v406[8 * v402];
          *v433 = v379;
          v394 = v433 + 1;
          while (v393 != v401)
          {
            v434 = *((_QWORD *)v393-- - 1);
            *((_QWORD *)v433-- - 1) = v434;
          }
          *(_QWORD *)(v18 + 400) = v433;
          *(_QWORD *)(v18 + 408) = v394;
          *(_QWORD *)(v18 + 416) = &v406[8 * v405];
          if (v401)
            operator delete(v401);
        }
        else
        {
          *v393 = v379;
          v394 = v393 + 1;
        }
        v435 = v380 - v388;
        *(_QWORD *)(v18 + 408) = v394;
        v436 = *(double *)(*(_QWORD *)(v18 + 216) + 8 * v381)
             + (v386 - v387) / v435 * (v379 - *(double *)(*(_QWORD *)(v18 + 192) + 8 * v381));
        v438 = *(double **)(v18 + 432);
        v437 = *(_QWORD *)(v18 + 440);
        if ((unint64_t)v438 >= v437)
        {
          v440 = (double *)*v332;
          v441 = ((char *)v438 - (_BYTE *)*v332) >> 3;
          v442 = v441 + 1;
          if ((unint64_t)(v441 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v443 = v437 - (_QWORD)v440;
          if (v443 >> 2 > v442)
            v442 = v443 >> 2;
          if ((unint64_t)v443 >= 0x7FFFFFFFFFFFFFF8)
            v444 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v444 = v442;
          if (v444)
          {
            v445 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v467, v444);
            v440 = *(double **)(v18 + 424);
            v438 = *(double **)(v18 + 432);
          }
          else
          {
            v445 = 0;
          }
          v446 = (double *)&v445[8 * v441];
          *v446 = v436;
          v439 = v446 + 1;
          while (v438 != v440)
          {
            v447 = *((_QWORD *)v438-- - 1);
            *((_QWORD *)v446-- - 1) = v447;
          }
          *(_QWORD *)(v18 + 424) = v446;
          *(_QWORD *)(v18 + 432) = v439;
          *(_QWORD *)(v18 + 440) = &v445[8 * v444];
          if (v440)
            operator delete(v440);
        }
        else
        {
          *v438 = v436;
          v439 = v438 + 1;
        }
        *(_QWORD *)(v18 + 432) = v439;
        v448 = *(double *)(*(_QWORD *)(v18 + 240) + 8 * v381)
             + (v390 - v391) / v435 * (v379 - *(double *)(*(_QWORD *)(v18 + 192) + 8 * v381));
        v450 = *(double **)(v18 + 456);
        v449 = *(_QWORD *)(v18 + 464);
        if ((unint64_t)v450 >= v449)
        {
          v425 = (double *)*v346;
          v451 = ((char *)v450 - (_BYTE *)*v346) >> 3;
          v452 = v451 + 1;
          if ((unint64_t)(v451 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v453 = v449 - (_QWORD)v425;
          if (v453 >> 2 > v452)
            v452 = v453 >> 2;
          if ((unint64_t)v453 >= 0x7FFFFFFFFFFFFFF8)
            v429 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v429 = v452;
          if (v429)
          {
            v430 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v465, v429);
            v425 = *(double **)(v18 + 448);
            v450 = *(double **)(v18 + 456);
          }
          else
          {
            v430 = 0;
          }
          v431 = (double *)&v430[8 * v451];
          *v431 = v448;
          v424 = v431 + 1;
          v376 = 1.0;
          while (v450 != v425)
          {
            v454 = *((_QWORD *)v450-- - 1);
            *((_QWORD *)v431-- - 1) = v454;
          }
LABEL_516:
          *(_QWORD *)(v18 + 448) = v431;
          *(_QWORD *)(v18 + 456) = v424;
          *(_QWORD *)(v18 + 464) = &v430[8 * v429];
          if (v425)
            operator delete(v425);
          goto LABEL_542;
        }
        *v450 = v448;
        v424 = v450 + 1;
        v376 = 1.0;
      }
      else
      {
        v383 = *(double **)(v18 + 408);
        v382 = *(_QWORD *)(v18 + 416);
        if ((unint64_t)v383 >= v382)
        {
          v395 = (double *)*v360;
          v396 = ((char *)v383 - (_BYTE *)*v360) >> 3;
          v397 = v396 + 1;
          if ((unint64_t)(v396 + 1) >> 61)
            goto LABEL_563;
          v398 = v382 - (_QWORD)v395;
          if (v398 >> 2 > v397)
            v397 = v398 >> 2;
          if ((unint64_t)v398 >= 0x7FFFFFFFFFFFFFF8)
            v399 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v399 = v397;
          if (v399)
          {
            v400 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v471, v399);
            v395 = *(double **)(v18 + 400);
            v383 = *(double **)(v18 + 408);
          }
          else
          {
            v400 = 0;
          }
          v407 = (double *)&v400[8 * v396];
          *v407 = v379;
          v384 = v407 + 1;
          while (v383 != v395)
          {
            v408 = *((_QWORD *)v383-- - 1);
            *((_QWORD *)v407-- - 1) = v408;
          }
          *(_QWORD *)(v18 + 400) = v407;
          *(_QWORD *)(v18 + 408) = v384;
          *(_QWORD *)(v18 + 416) = &v400[8 * v399];
          if (v395)
            operator delete(v395);
        }
        else
        {
          *v383 = v379;
          v384 = v383 + 1;
        }
        *(_QWORD *)(v18 + 408) = v384;
        v409 = *(_QWORD *)(v18 + 216);
        v411 = *(char **)(v18 + 432);
        v410 = *(_QWORD *)(v18 + 440);
        if ((unint64_t)v411 >= v410)
        {
          v413 = (char *)*v332;
          v414 = (v411 - (_BYTE *)*v332) >> 3;
          v415 = v414 + 1;
          if ((unint64_t)(v414 + 1) >> 61)
            goto LABEL_563;
          v416 = v410 - (_QWORD)v413;
          if (v416 >> 2 > v415)
            v415 = v416 >> 2;
          if ((unint64_t)v416 >= 0x7FFFFFFFFFFFFFF8)
            v417 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v417 = v415;
          if (v417)
          {
            v418 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v467, v417);
            v413 = *(char **)(v18 + 424);
            v411 = *(char **)(v18 + 432);
          }
          else
          {
            v418 = 0;
          }
          v419 = &v418[8 * v414];
          *(_QWORD *)v419 = *(_QWORD *)(v409 + 8 * v377);
          v412 = v419 + 8;
          while (v411 != v413)
          {
            v420 = *((_QWORD *)v411 - 1);
            v411 -= 8;
            *((_QWORD *)v419 - 1) = v420;
            v419 -= 8;
          }
          *(_QWORD *)(v18 + 424) = v419;
          *(_QWORD *)(v18 + 432) = v412;
          *(_QWORD *)(v18 + 440) = &v418[8 * v417];
          if (v413)
            operator delete(v413);
        }
        else
        {
          *(_QWORD *)v411 = *(_QWORD *)(v409 + 8 * v377);
          v412 = v411 + 8;
        }
        *(_QWORD *)(v18 + 432) = v412;
        v421 = *(_QWORD *)(v18 + 240);
        v423 = *(char **)(v18 + 456);
        v422 = *(_QWORD *)(v18 + 464);
        if ((unint64_t)v423 >= v422)
        {
          v425 = (double *)*v346;
          v426 = (v423 - (_BYTE *)*v346) >> 3;
          v427 = v426 + 1;
          if ((unint64_t)(v426 + 1) >> 61)
LABEL_563:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v428 = v422 - (_QWORD)v425;
          if (v428 >> 2 > v427)
            v427 = v428 >> 2;
          if ((unint64_t)v428 >= 0x7FFFFFFFFFFFFFF8)
            v429 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v429 = v427;
          if (v429)
          {
            v430 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v465, v429);
            v425 = *(double **)(v18 + 448);
            v423 = *(char **)(v18 + 456);
          }
          else
          {
            v430 = 0;
          }
          v431 = (double *)&v430[8 * v426];
          *v431 = *(double *)(v421 + 8 * v377);
          v424 = v431 + 1;
          while (v423 != (char *)v425)
          {
            v432 = *((_QWORD *)v423 - 1);
            v423 -= 8;
            *((_QWORD *)v431-- - 1) = v432;
          }
          goto LABEL_516;
        }
        *(_QWORD *)v423 = *(_QWORD *)(v421 + 8 * v377);
        v424 = (double *)(v423 + 8);
      }
LABEL_542:
      *(_QWORD *)(v18 + 456) = v424;
      v378 = v378 + v376;
      v379 = v378 * 0.05;
LABEL_543:
      v374 = *(_QWORD *)(v18 + 192);
      v380 = *(double *)(v374 + 8 * v377);
    }
    while (v380 >= v379);
    v375 = *(_QWORD *)(v18 + 200);
LABEL_557:
    v377 = (v377 + 1);
  }
  while (v377 < (v375 - v374) >> 3);
LABEL_558:
  v455 = operator new(0x18uLL);
  v456 = (_QWORD *)*((_QWORD *)v462 + 342);
  *v455 = (char *)v462 + 2728;
  v455[1] = v456;
  v455[2] = v18;
  *v456 = v455;
  *((_QWORD *)v462 + 342) = v455;
  v457 = *((_QWORD *)v462 + 343);
  *((_QWORD *)v462 + 343) = v457 + 1;
  if ((unint64_t)(v457 + 1) >= 0x15)
  {
    v458 = *((_QWORD *)v462 + 341);
    v459 = *(OZShapeReparametrizedContour **)(v458 + 16);
    if (v459)
    {
      OZShapeReparametrizedContour::~OZShapeReparametrizedContour(v459);
      MEMORY[0x1B5E29170]();
      v458 = *((_QWORD *)v462 + 341);
      v457 = *((_QWORD *)v462 + 343) - 1;
    }
    *(_QWORD *)(v458 + 16) = 0;
    v460 = (uint64_t *)*((_QWORD *)v462 + 341);
    v461 = *v460;
    *(_QWORD *)(v461 + 8) = v460[1];
    *(_QWORD *)v460[1] = v461;
    *((_QWORD *)v462 + 343) = v457;
    operator delete(v460);
  }
  *(_BYTE *)(v463 + 1193) = 0;
}

void sub_1B30056E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42)
{
  _Unwind_Resume(exception_object);
}

uint64_t OZShape::getOSCContour(uint64_t a1, const CMTime *a2, uint64_t a3, double *a4)
{
  PCMutex *v8;
  uint64_t CachedContour;

  v8 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  CachedContour = OZShape::getCachedContour((OZShape *)a1, (uint64_t)a2, a3, a4);
  if (!CachedContour)
    CachedContour = OZShape::updateContour(a1, a2, a3, a4);
  PCMutex::unlock(v8);
  return CachedContour;
}

void sub_1B30058E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t OZShape::getCachedContour(OZShape *this, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  char isShapeContourAnimated;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  OZShapeContour *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  char v26;
  uint64_t v27;
  CMTimeEpoch v28;
  char v29;
  unint64_t v30;
  BOOL v31;
  uint64_t v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  _BYTE v39[48];
  __int128 v40;
  __int128 v41;
  _BYTE v42[48];
  CMTime time2;
  CMTime time1;

  if (a4)
  {
    v7 = a4[5];
    v41 = a4[4];
    *(_OWORD *)v42 = v7;
    v8 = a4[7];
    *(_OWORD *)&v42[16] = a4[6];
    *(_OWORD *)&v42[32] = v8;
    v9 = a4[1];
    *(_OWORD *)v39 = *a4;
    *(_OWORD *)&v39[16] = v9;
    v10 = a4[3];
    *(_OWORD *)&v39[32] = a4[2];
    v40 = v10;
  }
  else
  {
    *(_QWORD *)&v42[40] = 0x3FF0000000000000;
    *(_QWORD *)v42 = 0x3FF0000000000000;
    *(_QWORD *)&v39[40] = 0x3FF0000000000000;
    *(_QWORD *)v39 = 0x3FF0000000000000;
    memset(&v39[8], 0, 32);
    v40 = 0u;
    v41 = 0u;
    memset(&v42[8], 0, 32);
  }
  isShapeContourAnimated = OZShape::isShapeContourAnimated(this);
  v12 = (char *)this + 2680;
  if (*(_BYTE *)(a3 + 1192))
  {
    while (1)
    {
      v13 = *((_QWORD *)this + 337);
      if (!v13)
        break;
      v14 = *(_QWORD *)v12;
      v15 = *(OZShapeContour **)(*(_QWORD *)v12 + 16);
      if (v15)
      {
        OZShapeContour::~OZShapeContour(v15);
        MEMORY[0x1B5E29170](v16, 0x10A0C409674A9C3, v17, v18, v19, v20, v21, v22, *(_QWORD *)v39, *(_QWORD *)&v39[8], *(_QWORD *)&v39[16], *(_QWORD *)&v39[24], *(_QWORD *)&v39[32], *(_QWORD *)&v39[40], v40, *((_QWORD *)&v40 + 1));
        v14 = *((_QWORD *)this + 335);
        v13 = *((_QWORD *)this + 337);
      }
      *(_QWORD *)(v14 + 16) = 0;
      v23 = (uint64_t *)*((_QWORD *)this + 335);
      v24 = *v23;
      *(_QWORD *)(v24 + 8) = v23[1];
      *(_QWORD *)v23[1] = v24;
      *((_QWORD *)this + 337) = v13 - 1;
      operator delete(v23);
    }
    return 0;
  }
  v25 = (uint64_t *)*((_QWORD *)this + 336);
  if (v25 == (uint64_t *)v12)
    return 0;
  v26 = isShapeContourAnimated;
  while (1)
  {
    v27 = v25[2];
    time1 = *(CMTime *)a2;
    v28 = *(_QWORD *)(v27 + 16);
    *(_OWORD *)&time2.value = *(_OWORD *)v27;
    time2.epoch = v28;
    v29 = CMTimeCompare(&time1, &time2) ? v26 : 0;
    if ((v29 & 1) == 0)
    {
      v30 = 0;
      v31 = 0;
      v32 = v27 + 56;
      v33 = v39;
LABEL_16:
      v34 = 0;
      while (vabdd_f64(*(double *)(v32 + v34), *(double *)&v33[v34]) < 0.0000001)
      {
        v34 += 8;
        if (v34 == 32)
        {
          v31 = v30 > 2;
          v33 += 32;
          v32 += 32;
          if (++v30 != 4)
            goto LABEL_16;
          goto LABEL_22;
        }
      }
      if (!v31)
        goto LABEL_23;
LABEL_22:
      if (*(unsigned __int8 *)(a2 + 24) == *(unsigned __int8 *)(v27 + 184))
        break;
    }
LABEL_23:
    v25 = (uint64_t *)v25[1];
    if (v25 == (uint64_t *)v12)
      return 0;
  }
  v36 = *v25;
  *(_QWORD *)(v36 + 8) = v25[1];
  *(_QWORD *)v25[1] = v36;
  --*((_QWORD *)this + 337);
  operator delete(v25);
  v37 = operator new(0x18uLL);
  v38 = (_QWORD *)*((_QWORD *)this + 336);
  *v37 = v12;
  v37[1] = v38;
  v37[2] = v27;
  *v38 = v37;
  *((_QWORD *)this + 336) = v37;
  ++*((_QWORD *)this + 337);
  return v27;
}

uint64_t OZShape::updateContour(uint64_t a1, const CMTime *a2, uint64_t a3, double *a4)
{
  uint64_t v8;
  int ValueAsInt;
  int v10;
  os_unfair_lock_s *v11;
  os_unfair_lock_s *v12;
  CMTime *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  double v17;
  double v18;
  unint64_t v19;
  double *v20;
  double *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  double *v28;
  char *v29;
  char *v30;
  double *v31;
  __int128 v32;
  double v33;
  double v34;
  unint64_t v35;
  double *v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  char *v43;
  double *v44;
  char *v45;
  char *v46;
  double *v47;
  __int128 v48;
  double v49;
  double v50;
  unint64_t v51;
  double *v52;
  double *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  double *v60;
  char *v61;
  char *v62;
  double *v63;
  __int128 v64;
  double *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  double v69;
  unint64_t v70;
  void **v71;
  double v72;
  double *v73;
  double *v74;
  unint64_t v75;
  void **v76;
  double v77;
  double *v78;
  double *v79;
  double v80;
  double v81;
  uint64_t v82;
  double *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  double *v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  char *v94;
  double v95;
  double v96;
  double v97;
  double *v98;
  int v99;
  double v100;
  double v101;
  double v102;
  _QWORD *v103;
  void **v104;
  double v105;
  double v106;
  double *v107;
  double *v108;
  double v109;
  unint64_t v110;
  double *v111;
  double *v112;
  double *v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  double *v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  char *v124;
  double *v125;
  uint64_t v126;
  unint64_t v127;
  char *v128;
  _QWORD *v129;
  char *v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  char *v135;
  char *v136;
  uint64_t v137;
  unint64_t v138;
  double *v139;
  double *v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  char *v145;
  double *v146;
  double *v147;
  uint64_t v148;
  double *v149;
  uint64_t v150;
  unint64_t v151;
  double *v152;
  double *v153;
  double *v154;
  uint64_t v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  char *v159;
  double *v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  unint64_t v164;
  uint64_t v165;
  uint64_t v166;
  double v167;
  double v168;
  double *v169;
  double *v170;
  double *v171;
  uint64_t v172;
  unint64_t v173;
  uint64_t v174;
  unint64_t v175;
  char *v176;
  double *v177;
  uint64_t v178;
  unint64_t v179;
  double *v180;
  double *v181;
  double *v182;
  uint64_t v183;
  unint64_t v184;
  uint64_t v185;
  unint64_t v186;
  char *v187;
  double *v188;
  uint64_t v189;
  unint64_t v190;
  double *v191;
  double *v192;
  double *v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  unint64_t v197;
  char *v198;
  double *v199;
  uint64_t v200;
  double *v201;
  char *v202;
  uint64_t v203;
  void **v204;
  double v205;
  unint64_t v206;
  double *v207;
  double *v208;
  double *v209;
  uint64_t v210;
  unint64_t v211;
  uint64_t v212;
  unint64_t v213;
  char *v214;
  double *v215;
  char *v216;
  uint64_t v217;
  unint64_t v218;
  void **v219;
  char *v220;
  _QWORD *v221;
  char *v222;
  uint64_t v223;
  unint64_t v224;
  uint64_t v225;
  unint64_t v226;
  char *v227;
  char *v228;
  char *v229;
  uint64_t v230;
  double v231;
  unint64_t v232;
  double *v233;
  double *v234;
  double *v235;
  uint64_t v236;
  unint64_t v237;
  uint64_t v238;
  unint64_t v239;
  char *v240;
  double *v241;
  char *v242;
  uint64_t v243;
  double v244;
  unint64_t v245;
  double *v246;
  double *v247;
  double *v248;
  uint64_t v249;
  unint64_t v250;
  uint64_t v251;
  unint64_t v252;
  char *v253;
  double *v254;
  char *v255;
  uint64_t v256;
  unint64_t v257;
  char *v258;
  _QWORD *v259;
  char *v260;
  uint64_t v261;
  unint64_t v262;
  uint64_t v263;
  unint64_t v264;
  char *v265;
  char *v266;
  char *v267;
  uint64_t v268;
  double v269;
  unint64_t v270;
  double *v271;
  double *v272;
  double *v273;
  uint64_t v274;
  unint64_t v275;
  uint64_t v276;
  unint64_t v277;
  char *v278;
  double *v279;
  char *v280;
  uint64_t v281;
  double v282;
  unint64_t v283;
  double *v284;
  double *v285;
  double *v286;
  uint64_t v287;
  unint64_t v288;
  uint64_t v289;
  unint64_t v290;
  char *v291;
  double *v292;
  char *v293;
  uint64_t v294;
  unint64_t v295;
  char *v296;
  _QWORD *v297;
  char *v298;
  uint64_t v299;
  unint64_t v300;
  uint64_t v301;
  unint64_t v302;
  char *v303;
  char *v304;
  char *v305;
  uint64_t v306;
  double v307;
  unint64_t v308;
  double *v309;
  double *v310;
  double *v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  unint64_t v315;
  char *v316;
  double *v317;
  char *v318;
  uint64_t v319;
  double v320;
  unint64_t v321;
  double *v322;
  double *v323;
  double *v324;
  uint64_t v325;
  unint64_t v326;
  uint64_t v327;
  unint64_t v328;
  char *v329;
  double *v330;
  char *v331;
  uint64_t v332;
  unint64_t v333;
  uint64_t *v334;
  uint64_t v335;
  uint64_t *v336;
  uint64_t v337;
  unint64_t v338;
  uint64_t v339;
  unint64_t v340;
  char *v341;
  char *v342;
  char *v343;
  _QWORD *v344;
  uint64_t v345;
  OZChannelShape *v346;
  uint64_t v347;
  double v348;
  double v349;
  uint64_t v350;
  double v351;
  double v352;
  uint64_t v353;
  uint64_t v354;
  os_unfair_lock_s *v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  const CMTime *v359;
  double *v360;
  double *v361;
  char *v362;
  uint64_t v363;
  void **v364;
  unint64_t v365;
  char *v366;
  _QWORD *v367;
  char *v368;
  uint64_t v369;
  unint64_t v370;
  uint64_t v371;
  unint64_t v372;
  char *v373;
  char *v374;
  char *v375;
  uint64_t v376;
  unint64_t v377;
  void **v378;
  char *v379;
  _QWORD *v380;
  char *v381;
  uint64_t v382;
  unint64_t v383;
  uint64_t v384;
  unint64_t v385;
  char *v386;
  char *v387;
  char *v388;
  uint64_t v389;
  double v390;
  unint64_t v391;
  double *v392;
  double *v393;
  double *v394;
  uint64_t v395;
  unint64_t v396;
  uint64_t v397;
  unint64_t v398;
  char *v399;
  double *v400;
  char *v401;
  uint64_t v402;
  uint64_t v403;
  unint64_t v404;
  char *v405;
  _QWORD *v406;
  char *v407;
  uint64_t v408;
  unint64_t v409;
  uint64_t v410;
  unint64_t v411;
  char *v412;
  char *v413;
  char *v414;
  uint64_t v415;
  unint64_t v416;
  char *v417;
  _QWORD *v418;
  char *v419;
  uint64_t v420;
  unint64_t v421;
  uint64_t v422;
  unint64_t v423;
  char *v424;
  char *v425;
  char *v426;
  uint64_t v427;
  uint64_t v428;
  unint64_t v429;
  char *v430;
  _QWORD *v431;
  char *v432;
  uint64_t v433;
  unint64_t v434;
  uint64_t v435;
  unint64_t v436;
  char *v437;
  char *v438;
  char *v439;
  uint64_t v440;
  uint64_t v441;
  unint64_t v442;
  char *v443;
  _QWORD *v444;
  char *v445;
  uint64_t v446;
  unint64_t v447;
  uint64_t v448;
  unint64_t v449;
  char *v450;
  char *v451;
  char *v452;
  uint64_t v453;
  unint64_t v454;
  char *v455;
  _QWORD *v456;
  char *v457;
  uint64_t v458;
  unint64_t v459;
  uint64_t v460;
  unint64_t v461;
  char *v462;
  char *v463;
  char *v464;
  uint64_t v465;
  uint64_t v466;
  unint64_t v467;
  char *v468;
  _QWORD *v469;
  char *v470;
  uint64_t v471;
  unint64_t v472;
  uint64_t v473;
  unint64_t v474;
  char *v475;
  char *v476;
  char *v477;
  uint64_t v478;
  double v479;
  unint64_t v480;
  double *v481;
  double *v482;
  double *v483;
  uint64_t v484;
  unint64_t v485;
  uint64_t v486;
  unint64_t v487;
  char *v488;
  double *v489;
  char *v490;
  uint64_t v491;
  unint64_t v492;
  char *v493;
  _QWORD *v494;
  char *v495;
  uint64_t v496;
  unint64_t v497;
  uint64_t v498;
  unint64_t v499;
  char *v500;
  char *v501;
  char *v502;
  uint64_t v503;
  double v504;
  unint64_t v505;
  double *v506;
  double *v507;
  double *v508;
  uint64_t v509;
  unint64_t v510;
  uint64_t v511;
  unint64_t v512;
  char *v513;
  double *v514;
  char *v515;
  uint64_t v516;
  double v517;
  unint64_t v518;
  double *v519;
  double *v520;
  double *v521;
  uint64_t v522;
  unint64_t v523;
  uint64_t v524;
  unint64_t v525;
  char *v526;
  double *v527;
  char *v528;
  uint64_t v529;
  unint64_t v530;
  uint64_t v531;
  unint64_t v532;
  uint64_t v533;
  unint64_t v534;
  char *v535;
  uint64_t v536;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  unsigned int v545;
  uint64_t v546;
  uint64_t i;
  _OWORD *v548;
  __int128 v549;
  int v550;
  int v551;
  double v552;
  _BOOL4 v553;
  uint64_t v554;
  _QWORD *v555;
  _QWORD *v556;
  uint64_t v557;
  uint64_t v558;
  OZShapeContour *v559;
  uint64_t *v560;
  uint64_t v561;
  uint64_t v563;
  uint64_t v564;
  unsigned int v565;
  void **v566;
  OZShape *v567;
  void **v568;
  double *v569;
  uint64_t v570;
  uint64_t v571;
  OZChannel *v572;
  CMTime *v573;
  double v574;
  double v575;
  _BYTE __p[48];
  float64x2_t v577;
  __int128 v578;
  uint64_t v579;
  __int128 v580;
  __int128 v581;
  double v582;
  double v583;
  double v584;
  CMTime v585;

  v8 = operator new();
  v585 = *a2;
  v573 = (CMTime *)a2;
  OZShapeContour::OZShapeContour((OZShapeContour *)v8, &v585);
  v572 = (OZChannel *)(a1 + 1072);
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0);
  v10 = 1;
  switch(ValueAsInt)
  {
    case 0:
      goto LABEL_7;
    case 1:
      v10 = 4;
      goto LABEL_7;
    case 2:
      if (OZChannel::getValueAsInt((OZChannel *)(a1 + 13720), MEMORY[0x1E0CA2E68], 0.0))
        v10 = 10;
      else
        v10 = 12;
      goto LABEL_7;
    case 4:
      v69 = *(double *)(a3 + 192);
      if (v69 < 0.01)
      {
        v70 = *(_QWORD *)(v8 + 232);
        v71 = (void **)(v8 + 216);
        v72 = -*(double *)(a3 + 200);
        v73 = *(double **)(v8 + 224);
        if ((unint64_t)v73 >= v70)
        {
          v89 = (double *)*v71;
          v90 = ((char *)v73 - (_BYTE *)*v71) >> 3;
          v91 = v90 + 1;
          if ((unint64_t)(v90 + 1) >> 61)
            goto LABEL_721;
          v92 = v70 - (_QWORD)v89;
          if (v92 >> 2 > v91)
            v91 = v92 >> 2;
          if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8)
            v93 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v93 = v91;
          if (v93)
          {
            v94 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v93);
            v89 = *(double **)(v8 + 216);
            v73 = *(double **)(v8 + 224);
          }
          else
          {
            v94 = 0;
          }
          v361 = (double *)&v94[8 * v90];
          v362 = &v94[8 * v93];
          *v361 = v72;
          v74 = v361 + 1;
          while (v73 != v89)
          {
            v363 = *((_QWORD *)v73-- - 1);
            *((_QWORD *)v361-- - 1) = v363;
          }
          *(_QWORD *)(v8 + 216) = v361;
          *(_QWORD *)(v8 + 224) = v74;
          *(_QWORD *)(v8 + 232) = v362;
          if (v89)
            operator delete(v89);
        }
        else
        {
          *v73 = v72;
          v74 = v73 + 1;
        }
        *(_QWORD *)(v8 + 224) = v74;
        v364 = (void **)(v8 + 240);
        v571 = v8 + 256;
        v366 = *(char **)(v8 + 248);
        v365 = *(_QWORD *)(v8 + 256);
        if ((unint64_t)v366 >= v365)
        {
          v368 = (char *)*v364;
          v369 = (v366 - (_BYTE *)*v364) >> 3;
          v370 = v369 + 1;
          if ((unint64_t)(v369 + 1) >> 61)
            goto LABEL_720;
          v371 = v365 - (_QWORD)v368;
          if (v371 >> 2 > v370)
            v370 = v371 >> 2;
          if ((unint64_t)v371 >= 0x7FFFFFFFFFFFFFF8)
            v372 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v372 = v370;
          if (v372)
          {
            v373 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v571, v372);
            v368 = *(char **)(v8 + 240);
            v366 = *(char **)(v8 + 248);
          }
          else
          {
            v373 = 0;
          }
          v374 = &v373[8 * v369];
          v375 = &v373[8 * v372];
          *(_QWORD *)v374 = 0;
          v367 = v374 + 8;
          while (v366 != v368)
          {
            v376 = *((_QWORD *)v366 - 1);
            v366 -= 8;
            *((_QWORD *)v374 - 1) = v376;
            v374 -= 8;
          }
          *(_QWORD *)(v8 + 240) = v374;
          *(_QWORD *)(v8 + 248) = v367;
          *(_QWORD *)(v8 + 256) = v375;
          if (v368)
            operator delete(v368);
        }
        else
        {
          *(_QWORD *)v366 = 0;
          v367 = v366 + 8;
        }
        v377 = *(_QWORD *)(v8 + 208);
        *(_QWORD *)(v8 + 248) = v367;
        v378 = (void **)(v8 + 192);
        v379 = *(char **)(v8 + 200);
        if ((unint64_t)v379 >= v377)
        {
          v381 = (char *)*v378;
          v382 = (v379 - (_BYTE *)*v378) >> 3;
          v383 = v382 + 1;
          if ((unint64_t)(v382 + 1) >> 61)
            goto LABEL_719;
          v384 = v377 - (_QWORD)v381;
          if (v384 >> 2 > v383)
            v383 = v384 >> 2;
          if ((unint64_t)v384 >= 0x7FFFFFFFFFFFFFF8)
            v385 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v385 = v383;
          if (v385)
          {
            v386 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v385);
            v381 = *(char **)(v8 + 192);
            v379 = *(char **)(v8 + 200);
          }
          else
          {
            v386 = 0;
          }
          v387 = &v386[8 * v382];
          v388 = &v386[8 * v385];
          *(_QWORD *)v387 = 0;
          v380 = v387 + 8;
          while (v379 != v381)
          {
            v389 = *((_QWORD *)v379 - 1);
            v379 -= 8;
            *((_QWORD *)v387 - 1) = v389;
            v387 -= 8;
          }
          *(_QWORD *)(v8 + 192) = v387;
          *(_QWORD *)(v8 + 200) = v380;
          *(_QWORD *)(v8 + 208) = v388;
          if (v381)
            operator delete(v381);
        }
        else
        {
          *(_QWORD *)v379 = 0;
          v380 = v379 + 8;
        }
        *(_QWORD *)(v8 + 200) = v380;
        v390 = -*(double *)(a3 + 200);
        v392 = *(double **)(v8 + 224);
        v391 = *(_QWORD *)(v8 + 232);
        if ((unint64_t)v392 >= v391)
        {
          v394 = (double *)*v71;
          v395 = ((char *)v392 - (_BYTE *)*v71) >> 3;
          v396 = v395 + 1;
          if ((unint64_t)(v395 + 1) >> 61)
            goto LABEL_721;
          v397 = v391 - (_QWORD)v394;
          if (v397 >> 2 > v396)
            v396 = v397 >> 2;
          if ((unint64_t)v397 >= 0x7FFFFFFFFFFFFFF8)
            v398 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v398 = v396;
          if (v398)
          {
            v399 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v398);
            v394 = *(double **)(v8 + 216);
            v392 = *(double **)(v8 + 224);
          }
          else
          {
            v399 = 0;
          }
          v400 = (double *)&v399[8 * v395];
          v401 = &v399[8 * v398];
          *v400 = v390;
          v393 = v400 + 1;
          while (v392 != v394)
          {
            v402 = *((_QWORD *)v392-- - 1);
            *((_QWORD *)v400-- - 1) = v402;
          }
          *(_QWORD *)(v8 + 216) = v400;
          *(_QWORD *)(v8 + 224) = v393;
          *(_QWORD *)(v8 + 232) = v401;
          if (v394)
            operator delete(v394);
        }
        else
        {
          *v392 = v390;
          v393 = v392 + 1;
        }
        *(_QWORD *)(v8 + 224) = v393;
        v403 = *(_QWORD *)(a3 + 208);
        v405 = *(char **)(v8 + 248);
        v404 = *(_QWORD *)(v8 + 256);
        if ((unint64_t)v405 >= v404)
        {
          v407 = (char *)*v364;
          v408 = (v405 - (_BYTE *)*v364) >> 3;
          v409 = v408 + 1;
          if ((unint64_t)(v408 + 1) >> 61)
            goto LABEL_720;
          v410 = v404 - (_QWORD)v407;
          if (v410 >> 2 > v409)
            v409 = v410 >> 2;
          if ((unint64_t)v410 >= 0x7FFFFFFFFFFFFFF8)
            v411 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v411 = v409;
          if (v411)
          {
            v412 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v571, v411);
            v407 = *(char **)(v8 + 240);
            v405 = *(char **)(v8 + 248);
          }
          else
          {
            v412 = 0;
          }
          v413 = &v412[8 * v408];
          v414 = &v412[8 * v411];
          *(_QWORD *)v413 = v403;
          v406 = v413 + 8;
          while (v405 != v407)
          {
            v415 = *((_QWORD *)v405 - 1);
            v405 -= 8;
            *((_QWORD *)v413 - 1) = v415;
            v413 -= 8;
          }
          *(_QWORD *)(v8 + 240) = v413;
          *(_QWORD *)(v8 + 248) = v406;
          *(_QWORD *)(v8 + 256) = v414;
          if (v407)
            operator delete(v407);
        }
        else
        {
          *(_QWORD *)v405 = v403;
          v406 = v405 + 8;
        }
        *(_QWORD *)(v8 + 248) = v406;
        v417 = *(char **)(v8 + 200);
        v416 = *(_QWORD *)(v8 + 208);
        if ((unint64_t)v417 >= v416)
        {
          v419 = (char *)*v378;
          v420 = (v417 - (_BYTE *)*v378) >> 3;
          v421 = v420 + 1;
          if ((unint64_t)(v420 + 1) >> 61)
            goto LABEL_719;
          v422 = v416 - (_QWORD)v419;
          if (v422 >> 2 > v421)
            v421 = v422 >> 2;
          if ((unint64_t)v422 >= 0x7FFFFFFFFFFFFFF8)
            v423 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v423 = v421;
          if (v423)
          {
            v424 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v423);
            v419 = *(char **)(v8 + 192);
            v417 = *(char **)(v8 + 200);
          }
          else
          {
            v424 = 0;
          }
          v425 = &v424[8 * v420];
          v426 = &v424[8 * v423];
          *(_QWORD *)v425 = 0x3FF0000000000000;
          v418 = v425 + 8;
          while (v417 != v419)
          {
            v427 = *((_QWORD *)v417 - 1);
            v417 -= 8;
            *((_QWORD *)v425 - 1) = v427;
            v425 -= 8;
          }
          *(_QWORD *)(v8 + 192) = v425;
          *(_QWORD *)(v8 + 200) = v418;
          *(_QWORD *)(v8 + 208) = v426;
          if (v419)
            operator delete(v419);
        }
        else
        {
          *(_QWORD *)v417 = 0x3FF0000000000000;
          v418 = v417 + 8;
        }
        *(_QWORD *)(v8 + 200) = v418;
        v428 = *(_QWORD *)(a3 + 200);
        v430 = *(char **)(v8 + 224);
        v429 = *(_QWORD *)(v8 + 232);
        if ((unint64_t)v430 >= v429)
        {
          v432 = (char *)*v71;
          v433 = (v430 - (_BYTE *)*v71) >> 3;
          v434 = v433 + 1;
          if ((unint64_t)(v433 + 1) >> 61)
            goto LABEL_721;
          v435 = v429 - (_QWORD)v432;
          if (v435 >> 2 > v434)
            v434 = v435 >> 2;
          if ((unint64_t)v435 >= 0x7FFFFFFFFFFFFFF8)
            v436 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v436 = v434;
          if (v436)
          {
            v437 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v436);
            v432 = *(char **)(v8 + 216);
            v430 = *(char **)(v8 + 224);
          }
          else
          {
            v437 = 0;
          }
          v438 = &v437[8 * v433];
          v439 = &v437[8 * v436];
          *(_QWORD *)v438 = v428;
          v431 = v438 + 8;
          while (v430 != v432)
          {
            v440 = *((_QWORD *)v430 - 1);
            v430 -= 8;
            *((_QWORD *)v438 - 1) = v440;
            v438 -= 8;
          }
          *(_QWORD *)(v8 + 216) = v438;
          *(_QWORD *)(v8 + 224) = v431;
          *(_QWORD *)(v8 + 232) = v439;
          if (v432)
            operator delete(v432);
        }
        else
        {
          *(_QWORD *)v430 = v428;
          v431 = v430 + 8;
        }
        *(_QWORD *)(v8 + 224) = v431;
        v441 = *(_QWORD *)(a3 + 208);
        v443 = *(char **)(v8 + 248);
        v442 = *(_QWORD *)(v8 + 256);
        if ((unint64_t)v443 >= v442)
        {
          v445 = (char *)*v364;
          v446 = (v443 - (_BYTE *)*v364) >> 3;
          v447 = v446 + 1;
          if ((unint64_t)(v446 + 1) >> 61)
            goto LABEL_720;
          v448 = v442 - (_QWORD)v445;
          if (v448 >> 2 > v447)
            v447 = v448 >> 2;
          if ((unint64_t)v448 >= 0x7FFFFFFFFFFFFFF8)
            v449 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v449 = v447;
          if (v449)
          {
            v450 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v571, v449);
            v445 = *(char **)(v8 + 240);
            v443 = *(char **)(v8 + 248);
          }
          else
          {
            v450 = 0;
          }
          v451 = &v450[8 * v446];
          v452 = &v450[8 * v449];
          *(_QWORD *)v451 = v441;
          v444 = v451 + 8;
          while (v443 != v445)
          {
            v453 = *((_QWORD *)v443 - 1);
            v443 -= 8;
            *((_QWORD *)v451 - 1) = v453;
            v451 -= 8;
          }
          *(_QWORD *)(v8 + 240) = v451;
          *(_QWORD *)(v8 + 248) = v444;
          *(_QWORD *)(v8 + 256) = v452;
          if (v445)
            operator delete(v445);
        }
        else
        {
          *(_QWORD *)v443 = v441;
          v444 = v443 + 8;
        }
        *(_QWORD *)(v8 + 248) = v444;
        v455 = *(char **)(v8 + 200);
        v454 = *(_QWORD *)(v8 + 208);
        if ((unint64_t)v455 >= v454)
        {
          v457 = (char *)*v378;
          v458 = (v455 - (_BYTE *)*v378) >> 3;
          v459 = v458 + 1;
          if ((unint64_t)(v458 + 1) >> 61)
            goto LABEL_719;
          v460 = v454 - (_QWORD)v457;
          if (v460 >> 2 > v459)
            v459 = v460 >> 2;
          if ((unint64_t)v460 >= 0x7FFFFFFFFFFFFFF8)
            v461 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v461 = v459;
          if (v461)
          {
            v462 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v461);
            v457 = *(char **)(v8 + 192);
            v455 = *(char **)(v8 + 200);
          }
          else
          {
            v462 = 0;
          }
          v463 = &v462[8 * v458];
          v464 = &v462[8 * v461];
          *(_QWORD *)v463 = 0x4000000000000000;
          v456 = v463 + 8;
          while (v455 != v457)
          {
            v465 = *((_QWORD *)v455 - 1);
            v455 -= 8;
            *((_QWORD *)v463 - 1) = v465;
            v463 -= 8;
          }
          *(_QWORD *)(v8 + 192) = v463;
          *(_QWORD *)(v8 + 200) = v456;
          *(_QWORD *)(v8 + 208) = v464;
          if (v457)
            operator delete(v457);
        }
        else
        {
          *(_QWORD *)v455 = 0x4000000000000000;
          v456 = v455 + 8;
        }
        *(_QWORD *)(v8 + 200) = v456;
        v466 = *(_QWORD *)(a3 + 200);
        v468 = *(char **)(v8 + 224);
        v467 = *(_QWORD *)(v8 + 232);
        if ((unint64_t)v468 >= v467)
        {
          v470 = (char *)*v71;
          v471 = (v468 - (_BYTE *)*v71) >> 3;
          v472 = v471 + 1;
          if ((unint64_t)(v471 + 1) >> 61)
            goto LABEL_721;
          v473 = v467 - (_QWORD)v470;
          if (v473 >> 2 > v472)
            v472 = v473 >> 2;
          if ((unint64_t)v473 >= 0x7FFFFFFFFFFFFFF8)
            v474 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v474 = v472;
          if (v474)
          {
            v475 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v474);
            v470 = *(char **)(v8 + 216);
            v468 = *(char **)(v8 + 224);
          }
          else
          {
            v475 = 0;
          }
          v476 = &v475[8 * v471];
          v477 = &v475[8 * v474];
          *(_QWORD *)v476 = v466;
          v469 = v476 + 8;
          while (v468 != v470)
          {
            v478 = *((_QWORD *)v468 - 1);
            v468 -= 8;
            *((_QWORD *)v476 - 1) = v478;
            v476 -= 8;
          }
          *(_QWORD *)(v8 + 216) = v476;
          *(_QWORD *)(v8 + 224) = v469;
          *(_QWORD *)(v8 + 232) = v477;
          if (v470)
            operator delete(v470);
        }
        else
        {
          *(_QWORD *)v468 = v466;
          v469 = v468 + 8;
        }
        *(_QWORD *)(v8 + 224) = v469;
        v479 = -*(double *)(a3 + 208);
        v481 = *(double **)(v8 + 248);
        v480 = *(_QWORD *)(v8 + 256);
        if ((unint64_t)v481 >= v480)
        {
          v483 = (double *)*v364;
          v484 = ((char *)v481 - (_BYTE *)*v364) >> 3;
          v485 = v484 + 1;
          if ((unint64_t)(v484 + 1) >> 61)
            goto LABEL_720;
          v486 = v480 - (_QWORD)v483;
          if (v486 >> 2 > v485)
            v485 = v486 >> 2;
          if ((unint64_t)v486 >= 0x7FFFFFFFFFFFFFF8)
            v487 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v487 = v485;
          if (v487)
          {
            v488 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v571, v487);
            v483 = *(double **)(v8 + 240);
            v481 = *(double **)(v8 + 248);
          }
          else
          {
            v488 = 0;
          }
          v489 = (double *)&v488[8 * v484];
          v490 = &v488[8 * v487];
          *v489 = v479;
          v482 = v489 + 1;
          while (v481 != v483)
          {
            v491 = *((_QWORD *)v481-- - 1);
            *((_QWORD *)v489-- - 1) = v491;
          }
          *(_QWORD *)(v8 + 240) = v489;
          *(_QWORD *)(v8 + 248) = v482;
          *(_QWORD *)(v8 + 256) = v490;
          if (v483)
            operator delete(v483);
        }
        else
        {
          *v481 = v479;
          v482 = v481 + 1;
        }
        *(_QWORD *)(v8 + 248) = v482;
        v493 = *(char **)(v8 + 200);
        v492 = *(_QWORD *)(v8 + 208);
        if ((unint64_t)v493 >= v492)
        {
          v495 = (char *)*v378;
          v496 = (v493 - (_BYTE *)*v378) >> 3;
          v497 = v496 + 1;
          if ((unint64_t)(v496 + 1) >> 61)
            goto LABEL_719;
          v498 = v492 - (_QWORD)v495;
          if (v498 >> 2 > v497)
            v497 = v498 >> 2;
          if ((unint64_t)v498 >= 0x7FFFFFFFFFFFFFF8)
            v499 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v499 = v497;
          if (v499)
          {
            v500 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v499);
            v495 = *(char **)(v8 + 192);
            v493 = *(char **)(v8 + 200);
          }
          else
          {
            v500 = 0;
          }
          v501 = &v500[8 * v496];
          v502 = &v500[8 * v499];
          *(_QWORD *)v501 = 0x4008000000000000;
          v494 = v501 + 8;
          while (v493 != v495)
          {
            v503 = *((_QWORD *)v493 - 1);
            v493 -= 8;
            *((_QWORD *)v501 - 1) = v503;
            v501 -= 8;
          }
          *(_QWORD *)(v8 + 192) = v501;
          *(_QWORD *)(v8 + 200) = v494;
          *(_QWORD *)(v8 + 208) = v502;
          if (v495)
            operator delete(v495);
        }
        else
        {
          *(_QWORD *)v493 = 0x4008000000000000;
          v494 = v493 + 8;
        }
        *(_QWORD *)(v8 + 200) = v494;
        v504 = -*(double *)(a3 + 200);
        v506 = *(double **)(v8 + 224);
        v505 = *(_QWORD *)(v8 + 232);
        if ((unint64_t)v506 < v505)
        {
          *v506 = v504;
          v507 = v506 + 1;
LABEL_640:
          *(_QWORD *)(v8 + 224) = v507;
          v517 = -*(double *)(a3 + 208);
          v519 = *(double **)(v8 + 248);
          v518 = *(_QWORD *)(v8 + 256);
          if ((unint64_t)v519 < v518)
          {
            *v519 = v517;
            v520 = v519 + 1;
            goto LABEL_656;
          }
          v521 = (double *)*v364;
          v522 = ((char *)v519 - (_BYTE *)*v364) >> 3;
          v523 = v522 + 1;
          if (!((unint64_t)(v522 + 1) >> 61))
          {
            v524 = v518 - (_QWORD)v521;
            if (v524 >> 2 > v523)
              v523 = v524 >> 2;
            if ((unint64_t)v524 >= 0x7FFFFFFFFFFFFFF8)
              v525 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v525 = v523;
            if (v525)
            {
              v526 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v571, v525);
              v521 = *(double **)(v8 + 240);
              v519 = *(double **)(v8 + 248);
            }
            else
            {
              v526 = 0;
            }
            v527 = (double *)&v526[8 * v522];
            v528 = &v526[8 * v525];
            *v527 = v517;
            v520 = v527 + 1;
            while (v519 != v521)
            {
              v529 = *((_QWORD *)v519-- - 1);
              *((_QWORD *)v527-- - 1) = v529;
            }
            *(_QWORD *)(v8 + 240) = v527;
            *(_QWORD *)(v8 + 248) = v520;
            *(_QWORD *)(v8 + 256) = v528;
            if (v521)
              operator delete(v521);
LABEL_656:
            *(_QWORD *)(v8 + 248) = v520;
            v334 = *(uint64_t **)(v8 + 200);
            v530 = *(_QWORD *)(v8 + 208);
            if ((unint64_t)v334 < v530)
            {
              v335 = 0x4010000000000000;
              goto LABEL_658;
            }
            v336 = (uint64_t *)*v378;
            v531 = ((char *)v334 - (_BYTE *)*v378) >> 3;
            v532 = v531 + 1;
            if (!((unint64_t)(v531 + 1) >> 61))
            {
              v533 = v530 - (_QWORD)v336;
              if (v533 >> 2 > v532)
                v532 = v533 >> 2;
              if ((unint64_t)v533 >= 0x7FFFFFFFFFFFFFF8)
                v534 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v534 = v532;
              if (v534)
              {
                v535 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v534);
                v336 = *(uint64_t **)(v8 + 192);
                v334 = *(uint64_t **)(v8 + 200);
              }
              else
              {
                v535 = 0;
              }
              v342 = &v535[8 * v531];
              v343 = &v535[8 * v534];
              *(_QWORD *)v342 = 0x4010000000000000;
              v344 = v342 + 8;
              while (v334 != v336)
              {
                v536 = *--v334;
                *((_QWORD *)v342 - 1) = v536;
                v342 -= 8;
              }
LABEL_671:
              *(_QWORD *)(v8 + 192) = v342;
              *(_QWORD *)(v8 + 200) = v344;
              *(_QWORD *)(v8 + 208) = v343;
              if (v336)
                operator delete(v336);
              goto LABEL_673;
            }
LABEL_719:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
LABEL_720:
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        v508 = (double *)*v71;
        v509 = ((char *)v506 - (_BYTE *)*v71) >> 3;
        v510 = v509 + 1;
        if (!((unint64_t)(v509 + 1) >> 61))
        {
          v511 = v505 - (_QWORD)v508;
          if (v511 >> 2 > v510)
            v510 = v511 >> 2;
          if ((unint64_t)v511 >= 0x7FFFFFFFFFFFFFF8)
            v512 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v512 = v510;
          if (v512)
          {
            v513 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v512);
            v508 = *(double **)(v8 + 216);
            v506 = *(double **)(v8 + 224);
          }
          else
          {
            v513 = 0;
          }
          v514 = (double *)&v513[8 * v509];
          v515 = &v513[8 * v512];
          *v514 = v504;
          v507 = v514 + 1;
          while (v506 != v508)
          {
            v516 = *((_QWORD *)v506-- - 1);
            *((_QWORD *)v514-- - 1) = v516;
          }
          *(_QWORD *)(v8 + 216) = v514;
          *(_QWORD *)(v8 + 224) = v507;
          *(_QWORD *)(v8 + 232) = v515;
          if (v508)
            operator delete(v508);
          goto LABEL_640;
        }
LABEL_721:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      if (v69 > 0.99)
      {
        v81 = *(double *)(a3 + 200);
        v80 = *(double *)(a3 + 208);
        v82 = *(_QWORD *)(a1 + 2752);
        if (v82)
        {
          OZChannelCurve::setVertexValue(*(_QWORD *)(a1 + 2752), **(char ***)(a1 + 2760), *(char **)(*(_QWORD *)(a1 + 2760) + 8), a2, -v81, 0.0);
        }
        else
        {
          v346 = (OZChannelShape *)operator new();
          PCString::PCString((PCString *)__p, "");
          OZChannelShape::OZChannelShape(v346, (const PCString *)__p, 0, 1u, 0);
          *(_QWORD *)(a1 + 2752) = v346;
          PCString::~PCString((PCString *)__p);
          OZChannelCurve::setCurveInterpolation(*(OZChannelCurve **)(a1 + 2752), 4);
          *(_QWORD *)__p = OZChannelCurve::addVertex(*(OZChannelCurve **)(a1 + 2752), a2, -*(double *)(a3 + 200), 0.0);
          *(_QWORD *)&__p[8] = v347;
          std::vector<OZVertex2D>::push_back[abi:ne180100]((void **)(a1 + 2760), __p);
        }
        v348 = v80 * -0.55228475;
        OZChannelCurve::setInputTangents(*(_QWORD *)(a1 + 2752), **(char ***)(a1 + 2760), *(char **)(*(_QWORD *)(a1 + 2760) + 8), a2, 0.0, v80 * -0.55228475);
        v349 = v80 * 0.55228475;
        OZChannelCurve::setOutputTangents(*(_QWORD *)(a1 + 2752), **(char ***)(a1 + 2760), *(char **)(*(_QWORD *)(a1 + 2760) + 8), a2, 0.0, v80 * 0.55228475);
        if (v82)
        {
          OZChannelCurve::setVertexValue(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 16), *(char **)(*(_QWORD *)(a1 + 2760) + 24), a2, 0.0, *(double *)(a3 + 208));
        }
        else
        {
          *(_QWORD *)__p = OZChannelCurve::addVertex(*(OZChannelCurve **)(a1 + 2752), a2, 0.0, *(double *)(a3 + 208));
          *(_QWORD *)&__p[8] = v350;
          std::vector<OZVertex2D>::push_back[abi:ne180100]((void **)(a1 + 2760), __p);
        }
        v351 = v81 * -0.55228475;
        OZChannelCurve::setInputTangents(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 16), *(char **)(*(_QWORD *)(a1 + 2760) + 24), a2, v81 * -0.55228475, 0.0);
        v352 = v81 * 0.55228475;
        OZChannelCurve::setOutputTangents(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 16), *(char **)(*(_QWORD *)(a1 + 2760) + 24), a2, v352, 0.0);
        if (v82)
        {
          OZChannelCurve::setVertexValue(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 32), *(char **)(*(_QWORD *)(a1 + 2760) + 40), a2, *(double *)(a3 + 200), 0.0);
        }
        else
        {
          *(_QWORD *)__p = OZChannelCurve::addVertex(*(OZChannelCurve **)(a1 + 2752), a2, *(double *)(a3 + 200), 0.0);
          *(_QWORD *)&__p[8] = v353;
          std::vector<OZVertex2D>::push_back[abi:ne180100]((void **)(a1 + 2760), __p);
        }
        OZChannelCurve::setInputTangents(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 32), *(char **)(*(_QWORD *)(a1 + 2760) + 40), a2, 0.0, v349);
        OZChannelCurve::setOutputTangents(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 32), *(char **)(*(_QWORD *)(a1 + 2760) + 40), a2, 0.0, v348);
        if (v82)
        {
          OZChannelCurve::setVertexValue(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 48), *(char **)(*(_QWORD *)(a1 + 2760) + 56), a2, 0.0, -*(double *)(a3 + 208));
        }
        else
        {
          *(_QWORD *)__p = OZChannelCurve::addVertex(*(OZChannelCurve **)(a1 + 2752), a2, 0.0, -*(double *)(a3 + 208));
          *(_QWORD *)&__p[8] = v354;
          std::vector<OZVertex2D>::push_back[abi:ne180100]((void **)(a1 + 2760), __p);
        }
        OZChannelCurve::setInputTangents(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 48), *(char **)(*(_QWORD *)(a1 + 2760) + 56), a2, v352, 0.0);
        OZChannelCurve::setOutputTangents(*(_QWORD *)(a1 + 2752), *(char **)(*(_QWORD *)(a1 + 2760) + 48), *(char **)(*(_QWORD *)(a1 + 2760) + 56), a2, v351, 0.0);
        OZChannelCurve::closeCurve(*(OZChannelCurve **)(a1 + 2752));
        if (a4 && PCMatrix44Tmpl<double>::isIdentity(a4))
        {
          v355 = *(os_unfair_lock_s **)(a1 + 2752);
          v356 = v8 + 192;
          v357 = v8 + 216;
          v358 = v8 + 240;
          v359 = a2;
          v360 = 0;
        }
        else
        {
          v355 = *(os_unfair_lock_s **)(a1 + 2752);
          v356 = v8 + 192;
          v357 = v8 + 216;
          v358 = v8 + 240;
          v359 = a2;
          v360 = a4;
        }
        OZChannelCurve::getCurve(v355, v359, 4, v356, v357, v358, v360);
        goto LABEL_674;
      }
      v583 = 0.0;
      v584 = 0.0;
      v582 = 1.0;
      v579 = 0x3FF0000000000000;
      *(_QWORD *)&__p[40] = 0x3FF0000000000000;
      *(_QWORD *)__p = 0x3FF0000000000000;
      memset(&__p[8], 0, 32);
      v577 = 0u;
      v578 = 0u;
      v580 = 0u;
      v581 = 0u;
      PCMatrix44Tmpl<double>::leftShear((double *)__p, *(double *)(a3 + 264), *(long double *)(a3 + 272));
      v96 = *(double *)(a3 + 248);
      v95 = *(double *)(a3 + 256);
      if (v96 != 1.0)
      {
        *(float64x2_t *)__p = vmulq_n_f64(*(float64x2_t *)__p, v96);
        *(float64x2_t *)&__p[16] = vmulq_n_f64(*(float64x2_t *)&__p[16], v96);
      }
      if (v95 != 1.0)
      {
        *(float64x2_t *)&__p[32] = vmulq_n_f64(*(float64x2_t *)&__p[32], v95);
        v577 = vmulq_n_f64(v577, v95);
      }
      v97 = 0.0;
      PCMatrix44Tmpl<double>::invert((double *)__p, (double *)__p, 0.0);
      v569 = a4;
      v99 = 0;
      v100 = fabs((*(double *)&__p[24] + *(double *)__p + *(double *)__p + *(double *)&__p[8] * 0.0)/ (v582 + *((double *)&v580 + 1) + *((double *)&v580 + 1) + *(double *)&v581 * 0.0));
      v101 = fabs((v577.f64[1] + *(double *)&__p[32] * 0.0 + *(double *)&__p[40] + *(double *)&__p[40])/ (v582 + *((double *)&v580 + 1) * 0.0 + *(double *)&v581 + *(double *)&v581));
      if (v100 >= v101)
        v102 = v101;
      else
        v102 = v100;
      v566 = (void **)(v8 + 240);
      v568 = (void **)(v8 + 216);
      v103 = (_QWORD *)(v8 + 232);
      v104 = (void **)(v8 + 192);
      v563 = v8 + 208;
      v564 = v8 + 256;
      v105 = 3.14159265;
      break;
    case 5:
      v75 = *(_QWORD *)(v8 + 232);
      v76 = (void **)(v8 + 216);
      v77 = *(double *)(a3 + 200) * -0.5;
      v78 = *(double **)(v8 + 224);
      if ((unint64_t)v78 >= v75)
      {
        v83 = (double *)*v76;
        v84 = ((char *)v78 - (_BYTE *)*v76) >> 3;
        v85 = v84 + 1;
        if ((unint64_t)(v84 + 1) >> 61)
          goto LABEL_719;
        v86 = v75 - (_QWORD)v83;
        if (v86 >> 2 > v85)
          v85 = v86 >> 2;
        if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF8)
          v87 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v87 = v85;
        if (v87)
        {
          v88 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v87);
          v83 = *(double **)(v8 + 216);
          v78 = *(double **)(v8 + 224);
        }
        else
        {
          v88 = 0;
        }
        v201 = (double *)&v88[8 * v84];
        v202 = &v88[8 * v87];
        *v201 = v77;
        v79 = v201 + 1;
        while (v78 != v83)
        {
          v203 = *((_QWORD *)v78-- - 1);
          *((_QWORD *)v201-- - 1) = v203;
        }
        *(_QWORD *)(v8 + 216) = v201;
        *(_QWORD *)(v8 + 224) = v79;
        *(_QWORD *)(v8 + 232) = v202;
        if (v83)
          operator delete(v83);
      }
      else
      {
        *v78 = v77;
        v79 = v78 + 1;
      }
      *(_QWORD *)(v8 + 224) = v79;
      v204 = (void **)(v8 + 240);
      v205 = *(double *)(a3 + 208) * 0.5;
      v570 = v8 + 256;
      v207 = *(double **)(v8 + 248);
      v206 = *(_QWORD *)(v8 + 256);
      if ((unint64_t)v207 >= v206)
      {
        v209 = (double *)*v204;
        v210 = ((char *)v207 - (_BYTE *)*v204) >> 3;
        v211 = v210 + 1;
        if ((unint64_t)(v210 + 1) >> 61)
          goto LABEL_720;
        v212 = v206 - (_QWORD)v209;
        if (v212 >> 2 > v211)
          v211 = v212 >> 2;
        if ((unint64_t)v212 >= 0x7FFFFFFFFFFFFFF8)
          v213 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v213 = v211;
        if (v213)
        {
          v214 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v570, v213);
          v209 = *(double **)(v8 + 240);
          v207 = *(double **)(v8 + 248);
        }
        else
        {
          v214 = 0;
        }
        v215 = (double *)&v214[8 * v210];
        v216 = &v214[8 * v213];
        *v215 = v205;
        v208 = v215 + 1;
        while (v207 != v209)
        {
          v217 = *((_QWORD *)v207-- - 1);
          *((_QWORD *)v215-- - 1) = v217;
        }
        *(_QWORD *)(v8 + 240) = v215;
        *(_QWORD *)(v8 + 248) = v208;
        *(_QWORD *)(v8 + 256) = v216;
        if (v209)
          operator delete(v209);
      }
      else
      {
        *v207 = v205;
        v208 = v207 + 1;
      }
      v218 = *(_QWORD *)(v8 + 208);
      *(_QWORD *)(v8 + 248) = v208;
      v219 = (void **)(v8 + 192);
      v220 = *(char **)(v8 + 200);
      if ((unint64_t)v220 >= v218)
      {
        v222 = (char *)*v219;
        v223 = (v220 - (_BYTE *)*v219) >> 3;
        v224 = v223 + 1;
        if ((unint64_t)(v223 + 1) >> 61)
          goto LABEL_721;
        v225 = v218 - (_QWORD)v222;
        if (v225 >> 2 > v224)
          v224 = v225 >> 2;
        if ((unint64_t)v225 >= 0x7FFFFFFFFFFFFFF8)
          v226 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v226 = v224;
        if (v226)
        {
          v227 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v226);
          v222 = *(char **)(v8 + 192);
          v220 = *(char **)(v8 + 200);
        }
        else
        {
          v227 = 0;
        }
        v228 = &v227[8 * v223];
        v229 = &v227[8 * v226];
        *(_QWORD *)v228 = 0;
        v221 = v228 + 8;
        while (v220 != v222)
        {
          v230 = *((_QWORD *)v220 - 1);
          v220 -= 8;
          *((_QWORD *)v228 - 1) = v230;
          v228 -= 8;
        }
        *(_QWORD *)(v8 + 192) = v228;
        *(_QWORD *)(v8 + 200) = v221;
        *(_QWORD *)(v8 + 208) = v229;
        if (v222)
          operator delete(v222);
      }
      else
      {
        *(_QWORD *)v220 = 0;
        v221 = v220 + 8;
      }
      *(_QWORD *)(v8 + 200) = v221;
      v231 = *(double *)(a3 + 200) * 0.5;
      v233 = *(double **)(v8 + 224);
      v232 = *(_QWORD *)(v8 + 232);
      if ((unint64_t)v233 >= v232)
      {
        v235 = (double *)*v76;
        v236 = ((char *)v233 - (_BYTE *)*v76) >> 3;
        v237 = v236 + 1;
        if ((unint64_t)(v236 + 1) >> 61)
          goto LABEL_719;
        v238 = v232 - (_QWORD)v235;
        if (v238 >> 2 > v237)
          v237 = v238 >> 2;
        if ((unint64_t)v238 >= 0x7FFFFFFFFFFFFFF8)
          v239 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v239 = v237;
        if (v239)
        {
          v240 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v239);
          v235 = *(double **)(v8 + 216);
          v233 = *(double **)(v8 + 224);
        }
        else
        {
          v240 = 0;
        }
        v241 = (double *)&v240[8 * v236];
        v242 = &v240[8 * v239];
        *v241 = v231;
        v234 = v241 + 1;
        while (v233 != v235)
        {
          v243 = *((_QWORD *)v233-- - 1);
          *((_QWORD *)v241-- - 1) = v243;
        }
        *(_QWORD *)(v8 + 216) = v241;
        *(_QWORD *)(v8 + 224) = v234;
        *(_QWORD *)(v8 + 232) = v242;
        if (v235)
          operator delete(v235);
      }
      else
      {
        *v233 = v231;
        v234 = v233 + 1;
      }
      *(_QWORD *)(v8 + 224) = v234;
      v244 = *(double *)(a3 + 208) * 0.5;
      v246 = *(double **)(v8 + 248);
      v245 = *(_QWORD *)(v8 + 256);
      if ((unint64_t)v246 >= v245)
      {
        v248 = (double *)*v204;
        v249 = ((char *)v246 - (_BYTE *)*v204) >> 3;
        v250 = v249 + 1;
        if ((unint64_t)(v249 + 1) >> 61)
          goto LABEL_720;
        v251 = v245 - (_QWORD)v248;
        if (v251 >> 2 > v250)
          v250 = v251 >> 2;
        if ((unint64_t)v251 >= 0x7FFFFFFFFFFFFFF8)
          v252 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v252 = v250;
        if (v252)
        {
          v253 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v570, v252);
          v248 = *(double **)(v8 + 240);
          v246 = *(double **)(v8 + 248);
        }
        else
        {
          v253 = 0;
        }
        v254 = (double *)&v253[8 * v249];
        v255 = &v253[8 * v252];
        *v254 = v244;
        v247 = v254 + 1;
        while (v246 != v248)
        {
          v256 = *((_QWORD *)v246-- - 1);
          *((_QWORD *)v254-- - 1) = v256;
        }
        *(_QWORD *)(v8 + 240) = v254;
        *(_QWORD *)(v8 + 248) = v247;
        *(_QWORD *)(v8 + 256) = v255;
        if (v248)
          operator delete(v248);
      }
      else
      {
        *v246 = v244;
        v247 = v246 + 1;
      }
      *(_QWORD *)(v8 + 248) = v247;
      v258 = *(char **)(v8 + 200);
      v257 = *(_QWORD *)(v8 + 208);
      if ((unint64_t)v258 >= v257)
      {
        v260 = (char *)*v219;
        v261 = (v258 - (_BYTE *)*v219) >> 3;
        v262 = v261 + 1;
        if ((unint64_t)(v261 + 1) >> 61)
          goto LABEL_721;
        v263 = v257 - (_QWORD)v260;
        if (v263 >> 2 > v262)
          v262 = v263 >> 2;
        if ((unint64_t)v263 >= 0x7FFFFFFFFFFFFFF8)
          v264 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v264 = v262;
        if (v264)
        {
          v265 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v264);
          v260 = *(char **)(v8 + 192);
          v258 = *(char **)(v8 + 200);
        }
        else
        {
          v265 = 0;
        }
        v266 = &v265[8 * v261];
        v267 = &v265[8 * v264];
        *(_QWORD *)v266 = 0x3FF0000000000000;
        v259 = v266 + 8;
        while (v258 != v260)
        {
          v268 = *((_QWORD *)v258 - 1);
          v258 -= 8;
          *((_QWORD *)v266 - 1) = v268;
          v266 -= 8;
        }
        *(_QWORD *)(v8 + 192) = v266;
        *(_QWORD *)(v8 + 200) = v259;
        *(_QWORD *)(v8 + 208) = v267;
        if (v260)
          operator delete(v260);
      }
      else
      {
        *(_QWORD *)v258 = 0x3FF0000000000000;
        v259 = v258 + 8;
      }
      *(_QWORD *)(v8 + 200) = v259;
      v269 = *(double *)(a3 + 200) * 0.5;
      v271 = *(double **)(v8 + 224);
      v270 = *(_QWORD *)(v8 + 232);
      if ((unint64_t)v271 >= v270)
      {
        v273 = (double *)*v76;
        v274 = ((char *)v271 - (_BYTE *)*v76) >> 3;
        v275 = v274 + 1;
        if ((unint64_t)(v274 + 1) >> 61)
          goto LABEL_719;
        v276 = v270 - (_QWORD)v273;
        if (v276 >> 2 > v275)
          v275 = v276 >> 2;
        if ((unint64_t)v276 >= 0x7FFFFFFFFFFFFFF8)
          v277 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v277 = v275;
        if (v277)
        {
          v278 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v277);
          v273 = *(double **)(v8 + 216);
          v271 = *(double **)(v8 + 224);
        }
        else
        {
          v278 = 0;
        }
        v279 = (double *)&v278[8 * v274];
        v280 = &v278[8 * v277];
        *v279 = v269;
        v272 = v279 + 1;
        while (v271 != v273)
        {
          v281 = *((_QWORD *)v271-- - 1);
          *((_QWORD *)v279-- - 1) = v281;
        }
        *(_QWORD *)(v8 + 216) = v279;
        *(_QWORD *)(v8 + 224) = v272;
        *(_QWORD *)(v8 + 232) = v280;
        if (v273)
          operator delete(v273);
      }
      else
      {
        *v271 = v269;
        v272 = v271 + 1;
      }
      *(_QWORD *)(v8 + 224) = v272;
      v282 = *(double *)(a3 + 208) * -0.5;
      v284 = *(double **)(v8 + 248);
      v283 = *(_QWORD *)(v8 + 256);
      if ((unint64_t)v284 >= v283)
      {
        v286 = (double *)*v204;
        v287 = ((char *)v284 - (_BYTE *)*v204) >> 3;
        v288 = v287 + 1;
        if ((unint64_t)(v287 + 1) >> 61)
          goto LABEL_720;
        v289 = v283 - (_QWORD)v286;
        if (v289 >> 2 > v288)
          v288 = v289 >> 2;
        if ((unint64_t)v289 >= 0x7FFFFFFFFFFFFFF8)
          v290 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v290 = v288;
        if (v290)
        {
          v291 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v570, v290);
          v286 = *(double **)(v8 + 240);
          v284 = *(double **)(v8 + 248);
        }
        else
        {
          v291 = 0;
        }
        v292 = (double *)&v291[8 * v287];
        v293 = &v291[8 * v290];
        *v292 = v282;
        v285 = v292 + 1;
        while (v284 != v286)
        {
          v294 = *((_QWORD *)v284-- - 1);
          *((_QWORD *)v292-- - 1) = v294;
        }
        *(_QWORD *)(v8 + 240) = v292;
        *(_QWORD *)(v8 + 248) = v285;
        *(_QWORD *)(v8 + 256) = v293;
        if (v286)
          operator delete(v286);
      }
      else
      {
        *v284 = v282;
        v285 = v284 + 1;
      }
      *(_QWORD *)(v8 + 248) = v285;
      v296 = *(char **)(v8 + 200);
      v295 = *(_QWORD *)(v8 + 208);
      if ((unint64_t)v296 >= v295)
      {
        v298 = (char *)*v219;
        v299 = (v296 - (_BYTE *)*v219) >> 3;
        v300 = v299 + 1;
        if ((unint64_t)(v299 + 1) >> 61)
          goto LABEL_721;
        v301 = v295 - (_QWORD)v298;
        if (v301 >> 2 > v300)
          v300 = v301 >> 2;
        if ((unint64_t)v301 >= 0x7FFFFFFFFFFFFFF8)
          v302 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v302 = v300;
        if (v302)
        {
          v303 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v302);
          v298 = *(char **)(v8 + 192);
          v296 = *(char **)(v8 + 200);
        }
        else
        {
          v303 = 0;
        }
        v304 = &v303[8 * v299];
        v305 = &v303[8 * v302];
        *(_QWORD *)v304 = 0x4000000000000000;
        v297 = v304 + 8;
        while (v296 != v298)
        {
          v306 = *((_QWORD *)v296 - 1);
          v296 -= 8;
          *((_QWORD *)v304 - 1) = v306;
          v304 -= 8;
        }
        *(_QWORD *)(v8 + 192) = v304;
        *(_QWORD *)(v8 + 200) = v297;
        *(_QWORD *)(v8 + 208) = v305;
        if (v298)
          operator delete(v298);
      }
      else
      {
        *(_QWORD *)v296 = 0x4000000000000000;
        v297 = v296 + 8;
      }
      *(_QWORD *)(v8 + 200) = v297;
      v307 = *(double *)(a3 + 200) * -0.5;
      v309 = *(double **)(v8 + 224);
      v308 = *(_QWORD *)(v8 + 232);
      if ((unint64_t)v309 >= v308)
      {
        v311 = (double *)*v76;
        v312 = ((char *)v309 - (_BYTE *)*v76) >> 3;
        v313 = v312 + 1;
        if ((unint64_t)(v312 + 1) >> 61)
          goto LABEL_719;
        v314 = v308 - (_QWORD)v311;
        if (v314 >> 2 > v313)
          v313 = v314 >> 2;
        if ((unint64_t)v314 >= 0x7FFFFFFFFFFFFFF8)
          v315 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v315 = v313;
        if (v315)
        {
          v316 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v315);
          v311 = *(double **)(v8 + 216);
          v309 = *(double **)(v8 + 224);
        }
        else
        {
          v316 = 0;
        }
        v317 = (double *)&v316[8 * v312];
        v318 = &v316[8 * v315];
        *v317 = v307;
        v310 = v317 + 1;
        while (v309 != v311)
        {
          v319 = *((_QWORD *)v309-- - 1);
          *((_QWORD *)v317-- - 1) = v319;
        }
        *(_QWORD *)(v8 + 216) = v317;
        *(_QWORD *)(v8 + 224) = v310;
        *(_QWORD *)(v8 + 232) = v318;
        if (v311)
          operator delete(v311);
      }
      else
      {
        *v309 = v307;
        v310 = v309 + 1;
      }
      *(_QWORD *)(v8 + 224) = v310;
      v320 = *(double *)(a3 + 208) * -0.5;
      v322 = *(double **)(v8 + 248);
      v321 = *(_QWORD *)(v8 + 256);
      if ((unint64_t)v322 >= v321)
      {
        v324 = (double *)*v204;
        v325 = ((char *)v322 - (_BYTE *)*v204) >> 3;
        v326 = v325 + 1;
        if ((unint64_t)(v325 + 1) >> 61)
          goto LABEL_720;
        v327 = v321 - (_QWORD)v324;
        if (v327 >> 2 > v326)
          v326 = v327 >> 2;
        if ((unint64_t)v327 >= 0x7FFFFFFFFFFFFFF8)
          v328 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v328 = v326;
        if (v328)
        {
          v329 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v570, v328);
          v324 = *(double **)(v8 + 240);
          v322 = *(double **)(v8 + 248);
        }
        else
        {
          v329 = 0;
        }
        v330 = (double *)&v329[8 * v325];
        v331 = &v329[8 * v328];
        *v330 = v320;
        v323 = v330 + 1;
        while (v322 != v324)
        {
          v332 = *((_QWORD *)v322-- - 1);
          *((_QWORD *)v330-- - 1) = v332;
        }
        *(_QWORD *)(v8 + 240) = v330;
        *(_QWORD *)(v8 + 248) = v323;
        *(_QWORD *)(v8 + 256) = v331;
        if (v324)
          operator delete(v324);
      }
      else
      {
        *v322 = v320;
        v323 = v322 + 1;
      }
      *(_QWORD *)(v8 + 248) = v323;
      v334 = *(uint64_t **)(v8 + 200);
      v333 = *(_QWORD *)(v8 + 208);
      if ((unint64_t)v334 < v333)
      {
        v335 = 0x4008000000000000;
LABEL_658:
        *v334 = v335;
        v344 = v334 + 1;
LABEL_673:
        *(_QWORD *)(v8 + 200) = v344;
        goto LABEL_674;
      }
      v336 = (uint64_t *)*v219;
      v337 = ((char *)v334 - (_BYTE *)*v219) >> 3;
      v338 = v337 + 1;
      if (!((unint64_t)(v337 + 1) >> 61))
      {
        v339 = v333 - (_QWORD)v336;
        if (v339 >> 2 > v338)
          v338 = v339 >> 2;
        if ((unint64_t)v339 >= 0x7FFFFFFFFFFFFFF8)
          v340 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v340 = v338;
        if (v340)
        {
          v341 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 208, v340);
          v336 = *(uint64_t **)(v8 + 192);
          v334 = *(uint64_t **)(v8 + 200);
        }
        else
        {
          v341 = 0;
        }
        v342 = &v341[8 * v337];
        v343 = &v341[8 * v340];
        *(_QWORD *)v342 = 0x4008000000000000;
        v344 = v342 + 8;
        while (v334 != v336)
        {
          v345 = *--v334;
          *((_QWORD *)v342 - 1) = v345;
          v342 -= 8;
        }
        goto LABEL_671;
      }
      goto LABEL_721;
    default:
      v10 = ValueAsInt;
LABEL_7:
      v565 = v10;
      v567 = (OZShape *)a1;
      v11 = (os_unfair_lock_s *)(a1 + 208);
      v12 = (os_unfair_lock_s *)(a1 + 208);
      v13 = (CMTime *)a2;
      OZChannelCurve::getEnabledVerticesList(v12, a2, (char **)__p);
      *(_QWORD *)(v8 + 272) = *(_QWORD *)(v8 + 264);
      v583 = 0.0;
      v584 = 0.0;
      v574 = 0.0;
      v575 = 0.0;
      if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
      {
        v14 = 0;
        v15 = (_QWORD *)(v8 + 264);
        if ((unint64_t)((uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4) <= 1)
          v16 = 1;
        else
          v16 = (uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4;
        do
        {
          OZChannelCurve::getVertexValue((uint64_t)v11, *(char **)(*(_QWORD *)__p + 16 * v14), *(char **)(*(_QWORD *)__p + 16 * v14 + 8), v13, &v584, &v583);
          if (*(_DWORD *)(a3 + 172) != 2)
          {
            OZChannelCurve::getInputTangents((uint64_t)v11, *(char **)(*(_QWORD *)__p + 16 * v14), *(char **)(*(_QWORD *)__p + 16 * v14 + 8), v13, &v575, &v574);
            if (fabs(v575) >= 0.0000001 || fabs(v574) >= 0.0000001)
            {
              v17 = v575 + v584;
              v18 = v583 + v574;
              v20 = *(double **)(v8 + 272);
              v19 = *(_QWORD *)(v8 + 280);
              if ((unint64_t)v20 >= v19)
              {
                v22 = ((uint64_t)v20 - *v15) >> 4;
                v23 = v22 + 1;
                if ((unint64_t)(v22 + 1) >> 60)
                  std::vector<double>::__throw_length_error[abi:ne180100]();
                v24 = v19 - *v15;
                if (v24 >> 3 > v23)
                  v23 = v24 >> 3;
                if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0)
                  v25 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v25 = v23;
                v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v8 + 280, v25);
                v28 = (double *)&v27[16 * v22];
                *v28 = v17;
                v28[1] = v18;
                v29 = *(char **)(v8 + 264);
                v30 = *(char **)(v8 + 272);
                v31 = v28;
                while (v30 != v29)
                {
                  v32 = *((_OWORD *)v30 - 1);
                  v30 -= 16;
                  *((_OWORD *)v31 - 1) = v32;
                  v31 -= 2;
                }
                v21 = v28 + 2;
                *(_QWORD *)(v8 + 264) = v31;
                *(_QWORD *)(v8 + 272) = v28 + 2;
                *(_QWORD *)(v8 + 280) = &v27[16 * v26];
                if (v29)
                  operator delete(v29);
              }
              else
              {
                *v20 = v17;
                v20[1] = v18;
                v21 = v20 + 2;
              }
              *(_QWORD *)(v8 + 272) = v21;
            }
          }
          v33 = v583;
          v34 = v584;
          v36 = *(double **)(v8 + 272);
          v35 = *(_QWORD *)(v8 + 280);
          if ((unint64_t)v36 >= v35)
          {
            v38 = ((uint64_t)v36 - *v15) >> 4;
            v39 = v38 + 1;
            if ((unint64_t)(v38 + 1) >> 60)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v40 = v35 - *v15;
            if (v40 >> 3 > v39)
              v39 = v40 >> 3;
            if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0)
              v41 = 0xFFFFFFFFFFFFFFFLL;
            else
              v41 = v39;
            v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v8 + 280, v41);
            v44 = (double *)&v43[16 * v38];
            *v44 = v34;
            v44[1] = v33;
            v45 = *(char **)(v8 + 264);
            v46 = *(char **)(v8 + 272);
            v47 = v44;
            while (v46 != v45)
            {
              v48 = *((_OWORD *)v46 - 1);
              v46 -= 16;
              *((_OWORD *)v47 - 1) = v48;
              v47 -= 2;
            }
            v37 = v44 + 2;
            *(_QWORD *)(v8 + 264) = v47;
            *(_QWORD *)(v8 + 272) = v44 + 2;
            *(_QWORD *)(v8 + 280) = &v43[16 * v42];
            if (v45)
              operator delete(v45);
          }
          else
          {
            *v36 = v584;
            v36[1] = v33;
            v37 = v36 + 2;
          }
          *(_QWORD *)(v8 + 272) = v37;
          v13 = v573;
          if (*(_DWORD *)(a3 + 172) != 2)
          {
            OZChannelCurve::getOutputTangents((uint64_t)v11, *(char **)(*(_QWORD *)__p + 16 * v14), *(char **)(*(_QWORD *)__p + 16 * v14 + 8), v573, &v575, &v574);
            if (fabs(v575) >= 0.0000001 || fabs(v574) >= 0.0000001)
            {
              v49 = v575 + v584;
              v50 = v583 + v574;
              v52 = *(double **)(v8 + 272);
              v51 = *(_QWORD *)(v8 + 280);
              if ((unint64_t)v52 >= v51)
              {
                v54 = ((uint64_t)v52 - *v15) >> 4;
                v55 = v54 + 1;
                if ((unint64_t)(v54 + 1) >> 60)
                  std::vector<double>::__throw_length_error[abi:ne180100]();
                v56 = v51 - *v15;
                if (v56 >> 3 > v55)
                  v55 = v56 >> 3;
                if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0)
                  v57 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v57 = v55;
                v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v8 + 280, v57);
                v60 = (double *)&v59[16 * v54];
                *v60 = v49;
                v60[1] = v50;
                v61 = *(char **)(v8 + 264);
                v62 = *(char **)(v8 + 272);
                v63 = v60;
                while (v62 != v61)
                {
                  v64 = *((_OWORD *)v62 - 1);
                  v62 -= 16;
                  *((_OWORD *)v63 - 1) = v64;
                  v63 -= 2;
                }
                v53 = v60 + 2;
                *(_QWORD *)(v8 + 264) = v63;
                *(_QWORD *)(v8 + 272) = v60 + 2;
                *(_QWORD *)(v8 + 280) = &v59[16 * v58];
                if (v61)
                  operator delete(v61);
              }
              else
              {
                *v52 = v49;
                v52[1] = v50;
                v53 = v52 + 2;
              }
              *(_QWORD *)(v8 + 272) = v53;
              v13 = v573;
            }
          }
          ++v14;
        }
        while (v14 != v16);
      }
      if (a4 && PCMatrix44Tmpl<double>::isIdentity(a4))
        v65 = 0;
      else
        v65 = a4;
      OZChannelCurve::getCurve(v11, v13, v565, v8 + 192, v8 + 216, v8 + 240, v65);
      a1 = (uint64_t)v567;
      OZShape::checkConvexity((uint64_t)v567, v66, a3, v8);
      OZShape::checkSelfIntersection(v567, v67, v68, v8);
      *(_BYTE *)(v8 + 187) = !OZShape::checkWindingOrder(v567, v573, a3, a4, 0);
      if (*(_QWORD *)__p)
      {
        *(_QWORD *)&__p[8] = *(_QWORD *)__p;
        operator delete(*(void **)__p);
      }
      goto LABEL_675;
  }
  do
  {
    PCAlgorithm::superEllipse((PCAlgorithm *)&v584, v105, *(double *)(a3 + 200), *(double *)(a3 + 208), *(double *)(a3 + 192), &v583, v98);
    if (v99)
    {
      v106 = v584;
      v107 = *(double **)(v8 + 224);
      if (sqrt((v106 - *(v107 - 1)) * (v106 - *(v107 - 1))+ (v583 - *(double *)(*(_QWORD *)(v8 + 248) - 8)) * (v583 - *(double *)(*(_QWORD *)(v8 + 248) - 8))) <= v102)goto LABEL_193;
      if ((unint64_t)v107 >= *v103)
      {
        v119 = (double *)*v568;
        v120 = ((char *)v107 - (_BYTE *)*v568) >> 3;
        v121 = v120 + 1;
        if ((unint64_t)(v120 + 1) >> 61)
          goto LABEL_726;
        v122 = *v103 - (_QWORD)v119;
        if (v122 >> 2 > v121)
          v121 = v122 >> 2;
        if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8)
          v123 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v123 = v121;
        if (v123)
        {
          v124 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v123);
          v119 = *(double **)(v8 + 216);
          v107 = *(double **)(v8 + 224);
          v106 = v584;
        }
        else
        {
          v124 = 0;
        }
        v149 = (double *)&v124[8 * v120];
        *v149 = v106;
        v108 = v149 + 1;
        while (v107 != v119)
        {
          v150 = *((_QWORD *)v107-- - 1);
          *((_QWORD *)v149-- - 1) = v150;
        }
        *(_QWORD *)(v8 + 216) = v149;
        *(_QWORD *)(v8 + 224) = v108;
        *(_QWORD *)(v8 + 232) = &v124[8 * v123];
        if (v119)
          operator delete(v119);
      }
      else
      {
        *v107 = v584;
        v108 = v107 + 1;
      }
      *(_QWORD *)(v8 + 224) = v108;
      v152 = *(double **)(v8 + 248);
      v151 = *(_QWORD *)(v8 + 256);
      if ((unint64_t)v152 >= v151)
      {
        v154 = (double *)*v566;
        v155 = ((char *)v152 - (_BYTE *)*v566) >> 3;
        v156 = v155 + 1;
        if ((unint64_t)(v155 + 1) >> 61)
          goto LABEL_726;
        v157 = v151 - (_QWORD)v154;
        if (v157 >> 2 > v156)
          v156 = v157 >> 2;
        if ((unint64_t)v157 >= 0x7FFFFFFFFFFFFFF8)
          v158 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v158 = v156;
        if (v158)
        {
          v159 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v564, v158);
          v154 = *(double **)(v8 + 240);
          v152 = *(double **)(v8 + 248);
        }
        else
        {
          v159 = 0;
        }
        v160 = (double *)&v159[8 * v155];
        *v160 = v583;
        v153 = v160 + 1;
        while (v152 != v154)
        {
          v161 = *((_QWORD *)v152-- - 1);
          *((_QWORD *)v160-- - 1) = v161;
        }
        *(_QWORD *)(v8 + 240) = v160;
        *(_QWORD *)(v8 + 248) = v153;
        *(_QWORD *)(v8 + 256) = &v159[8 * v158];
        if (v154)
          operator delete(v154);
      }
      else
      {
        *v152 = v583;
        v153 = v152 + 1;
      }
      *(_QWORD *)(v8 + 248) = v153;
      v139 = *(double **)(v8 + 200);
      v162 = *(_QWORD *)(v8 + 208);
      if ((unint64_t)v139 < v162)
        goto LABEL_177;
      v140 = (double *)*v104;
      v163 = ((char *)v139 - (_BYTE *)*v104) >> 3;
      v164 = v163 + 1;
      if ((unint64_t)(v163 + 1) >> 61)
LABEL_726:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v165 = v162 - (_QWORD)v140;
      if (v165 >> 2 > v164)
        v164 = v165 >> 2;
      if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8)
        v144 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v144 = v164;
      if (v144)
      {
        v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v563, v144);
        v140 = *(double **)(v8 + 192);
        v139 = *(double **)(v8 + 200);
      }
      else
      {
        v145 = 0;
      }
      v146 = (double *)&v145[8 * v163];
      *v146 = v97;
      v147 = v146 + 1;
      while (v139 != v140)
      {
        v166 = *((_QWORD *)v139-- - 1);
        *((_QWORD *)v146-- - 1) = v166;
      }
LABEL_190:
      *(_QWORD *)(v8 + 192) = v146;
      *(_QWORD *)(v8 + 200) = v147;
      *(_QWORD *)(v8 + 208) = &v145[8 * v144];
      if (v140)
        operator delete(v140);
      goto LABEL_192;
    }
    v109 = -*(double *)(a3 + 200);
    v111 = *(double **)(v8 + 224);
    v110 = *(_QWORD *)(v8 + 232);
    if ((unint64_t)v111 >= v110)
    {
      v113 = (double *)*v568;
      v114 = ((char *)v111 - (_BYTE *)*v568) >> 3;
      v115 = v114 + 1;
      if ((unint64_t)(v114 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v116 = v110 - (_QWORD)v113;
      if (v116 >> 2 > v115)
        v115 = v116 >> 2;
      if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8)
        v117 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v117 = v115;
      if (v117)
      {
        v118 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v117);
        v113 = *(double **)(v8 + 216);
        v111 = *(double **)(v8 + 224);
      }
      else
      {
        v118 = 0;
      }
      v125 = (double *)&v118[8 * v114];
      *v125 = v109;
      v112 = v125 + 1;
      while (v111 != v113)
      {
        v126 = *((_QWORD *)v111-- - 1);
        *((_QWORD *)v125-- - 1) = v126;
      }
      *(_QWORD *)(v8 + 216) = v125;
      *(_QWORD *)(v8 + 224) = v112;
      *(_QWORD *)(v8 + 232) = &v118[8 * v117];
      if (v113)
        operator delete(v113);
    }
    else
    {
      *v111 = v109;
      v112 = v111 + 1;
    }
    *(_QWORD *)(v8 + 224) = v112;
    v128 = *(char **)(v8 + 248);
    v127 = *(_QWORD *)(v8 + 256);
    if ((unint64_t)v128 >= v127)
    {
      v130 = (char *)*v566;
      v131 = (v128 - (_BYTE *)*v566) >> 3;
      v132 = v131 + 1;
      if ((unint64_t)(v131 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v133 = v127 - (_QWORD)v130;
      if (v133 >> 2 > v132)
        v132 = v133 >> 2;
      if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFF8)
        v134 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v134 = v132;
      if (v134)
      {
        v135 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v564, v134);
        v130 = *(char **)(v8 + 240);
        v128 = *(char **)(v8 + 248);
      }
      else
      {
        v135 = 0;
      }
      v136 = &v135[8 * v131];
      *(_QWORD *)v136 = 0;
      v129 = v136 + 8;
      while (v128 != v130)
      {
        v137 = *((_QWORD *)v128 - 1);
        v128 -= 8;
        *((_QWORD *)v136 - 1) = v137;
        v136 -= 8;
      }
      *(_QWORD *)(v8 + 240) = v136;
      *(_QWORD *)(v8 + 248) = v129;
      *(_QWORD *)(v8 + 256) = &v135[8 * v134];
      if (v130)
        operator delete(v130);
    }
    else
    {
      *(_QWORD *)v128 = 0;
      v129 = v128 + 8;
    }
    *(_QWORD *)(v8 + 248) = v129;
    v139 = *(double **)(v8 + 200);
    v138 = *(_QWORD *)(v8 + 208);
    if ((unint64_t)v139 >= v138)
    {
      v140 = (double *)*v104;
      v141 = ((char *)v139 - (_BYTE *)*v104) >> 3;
      v142 = v141 + 1;
      if ((unint64_t)(v141 + 1) >> 61)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v143 = v138 - (_QWORD)v140;
      if (v143 >> 2 > v142)
        v142 = v143 >> 2;
      if ((unint64_t)v143 >= 0x7FFFFFFFFFFFFFF8)
        v144 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v144 = v142;
      if (v144)
      {
        v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v563, v144);
        v140 = *(double **)(v8 + 192);
        v139 = *(double **)(v8 + 200);
      }
      else
      {
        v145 = 0;
      }
      v146 = (double *)&v145[8 * v141];
      *v146 = v97;
      v147 = v146 + 1;
      while (v139 != v140)
      {
        v148 = *((_QWORD *)v139-- - 1);
        *((_QWORD *)v146-- - 1) = v148;
      }
      goto LABEL_190;
    }
LABEL_177:
    *v139 = v97;
    v147 = v139 + 1;
LABEL_192:
    *(_QWORD *)(v8 + 200) = v147;
LABEL_193:
    v97 = v97 + 0.0222222222;
    ++v99;
    v105 = v105 + -0.034906585;
  }
  while (v99 != 90);
  v167 = 6.28318531;
  do
  {
    PCAlgorithm::superEllipse((PCAlgorithm *)&v584, v167, *(double *)(a3 + 200), *(double *)(a3 + 208), *(double *)(a3 + 192), &v583, v98);
    v168 = v584;
    v169 = *(double **)(v8 + 224);
    if (sqrt((v168 - *(v169 - 1)) * (v168 - *(v169 - 1))+ (v583 - *(double *)(*(_QWORD *)(v8 + 248) - 8)) * (v583 - *(double *)(*(_QWORD *)(v8 + 248) - 8))) > v102)
    {
      if ((unint64_t)v169 >= *v103)
      {
        v171 = (double *)*v568;
        v172 = ((char *)v169 - (_BYTE *)*v568) >> 3;
        v173 = v172 + 1;
        if ((unint64_t)(v172 + 1) >> 61)
          goto LABEL_722;
        v174 = *v103 - (_QWORD)v171;
        if (v174 >> 2 > v173)
          v173 = v174 >> 2;
        if ((unint64_t)v174 >= 0x7FFFFFFFFFFFFFF8)
          v175 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v175 = v173;
        if (v175)
        {
          v176 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8 + 232, v175);
          v171 = *(double **)(v8 + 216);
          v169 = *(double **)(v8 + 224);
          v168 = v584;
        }
        else
        {
          v176 = 0;
        }
        v177 = (double *)&v176[8 * v172];
        *v177 = v168;
        v170 = v177 + 1;
        while (v169 != v171)
        {
          v178 = *((_QWORD *)v169-- - 1);
          *((_QWORD *)v177-- - 1) = v178;
        }
        *(_QWORD *)(v8 + 216) = v177;
        *(_QWORD *)(v8 + 224) = v170;
        *(_QWORD *)(v8 + 232) = &v176[8 * v175];
        if (v171)
          operator delete(v171);
      }
      else
      {
        *v169 = v584;
        v170 = v169 + 1;
      }
      *(_QWORD *)(v8 + 224) = v170;
      v180 = *(double **)(v8 + 248);
      v179 = *(_QWORD *)(v8 + 256);
      if ((unint64_t)v180 >= v179)
      {
        v182 = (double *)*v566;
        v183 = ((char *)v180 - (_BYTE *)*v566) >> 3;
        v184 = v183 + 1;
        if ((unint64_t)(v183 + 1) >> 61)
          goto LABEL_722;
        v185 = v179 - (_QWORD)v182;
        if (v185 >> 2 > v184)
          v184 = v185 >> 2;
        if ((unint64_t)v185 >= 0x7FFFFFFFFFFFFFF8)
          v186 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v186 = v184;
        if (v186)
        {
          v187 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v564, v186);
          v182 = *(double **)(v8 + 240);
          v180 = *(double **)(v8 + 248);
        }
        else
        {
          v187 = 0;
        }
        v188 = (double *)&v187[8 * v183];
        *v188 = v583;
        v181 = v188 + 1;
        while (v180 != v182)
        {
          v189 = *((_QWORD *)v180-- - 1);
          *((_QWORD *)v188-- - 1) = v189;
        }
        *(_QWORD *)(v8 + 240) = v188;
        *(_QWORD *)(v8 + 248) = v181;
        *(_QWORD *)(v8 + 256) = &v187[8 * v186];
        if (v182)
          operator delete(v182);
      }
      else
      {
        *v180 = v583;
        v181 = v180 + 1;
      }
      *(_QWORD *)(v8 + 248) = v181;
      v191 = *(double **)(v8 + 200);
      v190 = *(_QWORD *)(v8 + 208);
      if ((unint64_t)v191 >= v190)
      {
        v193 = (double *)*v104;
        v194 = ((char *)v191 - (_BYTE *)*v104) >> 3;
        v195 = v194 + 1;
        if ((unint64_t)(v194 + 1) >> 61)
LABEL_722:
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v196 = v190 - (_QWORD)v193;
        if (v196 >> 2 > v195)
          v195 = v196 >> 2;
        if ((unint64_t)v196 >= 0x7FFFFFFFFFFFFFF8)
          v197 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v197 = v195;
        if (v197)
        {
          v198 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v563, v197);
          v193 = *(double **)(v8 + 192);
          v191 = *(double **)(v8 + 200);
        }
        else
        {
          v198 = 0;
        }
        v199 = (double *)&v198[8 * v194];
        *v199 = v97;
        v192 = v199 + 1;
        while (v191 != v193)
        {
          v200 = *((_QWORD *)v191-- - 1);
          *((_QWORD *)v199-- - 1) = v200;
        }
        *(_QWORD *)(v8 + 192) = v199;
        *(_QWORD *)(v8 + 200) = v192;
        *(_QWORD *)(v8 + 208) = &v198[8 * v197];
        if (v193)
          operator delete(v193);
      }
      else
      {
        *v191 = v97;
        v192 = v191 + 1;
      }
      *(_QWORD *)(v8 + 200) = v192;
    }
    v97 = v97 + 0.0222222222;
    v167 = v167 + -0.034906585;
  }
  while (v167 >= 3.14159265);
  a4 = v569;
LABEL_674:
  *(_WORD *)(v8 + 185) = 1;
  *(_BYTE *)(v8 + 187) = !OZShape::checkWindingOrder((OZShape *)a1, v573, a3, a4, 0);
LABEL_675:
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(v8 + 40) = _Q0;
  v542 = *(_QWORD *)(v8 + 216);
  v543 = *(_QWORD *)(v8 + 224);
  if (v543 == v542)
  {
    v542 = *(_QWORD *)(v8 + 224);
  }
  else
  {
    v544 = 0;
    v545 = 1;
    do
    {
      v546 = *(_QWORD *)(*(_QWORD *)(v8 + 240) + 8 * v544);
      *(_QWORD *)__p = *(_QWORD *)(v542 + 8 * v544);
      *(_QWORD *)&__p[8] = v546;
      PCRect<double>::operator|=((float64x2_t *)(v8 + 24), (float64x2_t *)__p);
      v544 = v545;
      v542 = *(_QWORD *)(v8 + 216);
      v543 = *(_QWORD *)(v8 + 224);
      ++v545;
    }
    while (v544 != (v543 - v542) >> 3);
  }
  if (a4)
  {
    if ((double *)(v8 + 56) != a4)
    {
      for (i = 0; i != 16; i += 4)
      {
        v548 = (_OWORD *)(v8 + 56 + i * 8);
        v549 = *(_OWORD *)&a4[i + 2];
        *v548 = *(_OWORD *)&a4[i];
        v548[1] = v549;
      }
    }
  }
  else
  {
    *(_QWORD *)(v8 + 176) = 0x3FF0000000000000;
    *(_QWORD *)(v8 + 136) = 0x3FF0000000000000;
    *(_QWORD *)(v8 + 96) = 0x3FF0000000000000;
    *(_QWORD *)(v8 + 56) = 0x3FF0000000000000;
    *(_OWORD *)(v8 + 64) = 0u;
    *(_OWORD *)(v8 + 80) = 0u;
    *(_OWORD *)(v8 + 104) = 0u;
    *(_OWORD *)(v8 + 120) = 0u;
    *(_OWORD *)(v8 + 144) = 0u;
    *(_OWORD *)(v8 + 160) = 0u;
  }
  *(_BYTE *)(v8 + 184) = v573[1].value;
  if (*(_DWORD *)(a3 + 120))
  {
    if (!*(_DWORD *)(a3 + 180))
      goto LABEL_690;
    if (OZChannel::getValueAsInt(v572, MEMORY[0x1E0CA2E68], 0.0) == 4)
    {
      v542 = *(_QWORD *)(v8 + 216);
      v543 = *(_QWORD *)(v8 + 224);
LABEL_690:
      if (v542 != v543
        && *(_QWORD *)(v8 + 240) != *(_QWORD *)(v8 + 248)
        && *(_QWORD *)(v8 + 192) != *(_QWORD *)(v8 + 200)
        && OZShape::shouldDrawSoftEdges((OZShape *)a1, (const OZShapeRenderParams *)a3))
      {
        if (OZShape::shouldDrawAntialiasingOnFill((OZShape *)a1, (const OZShapeRenderParams *)a3))
        {
          OZShape::computeAntialiasedBorders(a1, v573, a3, v8, (double *)(v8 + 56), 1, 1, 1, 0.0);
          if (!*(_BYTE *)(v8 + 185) || *(_BYTE *)(v8 + 186) || !*(_BYTE *)(v8 + 187))
            OZShape::computeAntialiasedBorders(a1, v573, a3, v8, (double *)(v8 + 56), 1, 0, -1, 0.0);
        }
        else
        {
          OZShape::computeSoftEdges(a1, v573, a3, v8, 0, 1, 1, *(double *)(a3 + 224));
          if (!*(_BYTE *)(v8 + 185) || *(_BYTE *)(v8 + 186) || !*(_BYTE *)(v8 + 187))
            OZShape::computeSoftEdges(a1, v573, a3, v8, 0, 0, -1, *(double *)(a3 + 224));
        }
      }
    }
  }
  if (*(double *)(a3 + 16) > 0.0
    && *(_DWORD *)(a3 + 8)
    && (!*(_DWORD *)(a3 + 180) || OZChannel::getValueAsInt(v572, MEMORY[0x1E0CA2E68], 0.0) == 4)
    && (OZShape::isWriteOnEffectEnabled(a1, a3) & 1) == 0)
  {
    v550 = *(_DWORD *)(a3 + 168);
    v551 = *(_DWORD *)(a3 + 24);
    v552 = *(double *)(a3 + 16);
    v553 = !PCMatrix44Tmpl<double>::isIdentity((double *)(v8 + 56));
    if (v550)
      OZShape::computeOutline(a1, v573, a3, (uint64_t *)v8, (double *)(v8 + 56), v551, v553, v552);
    else
      OZShape::computeOpenStroke(a1, v573, a3, (_QWORD *)v8, (double *)(v8 + 56), v551, v553, v552);
  }
  v554 = a1 + 2680;
  v555 = operator new(0x18uLL);
  v556 = *(_QWORD **)(a1 + 2688);
  *v555 = a1 + 2680;
  v555[1] = v556;
  v555[2] = v8;
  *v556 = v555;
  *(_QWORD *)(a1 + 2688) = v555;
  v557 = *(_QWORD *)(a1 + 2696);
  *(_QWORD *)(a1 + 2696) = v557 + 1;
  if ((unint64_t)(v557 + 1) >= 0x65)
  {
    v558 = *(_QWORD *)v554;
    v559 = *(OZShapeContour **)(*(_QWORD *)v554 + 16);
    if (v559)
    {
      OZShapeContour::~OZShapeContour(v559);
      MEMORY[0x1B5E29170]();
      v558 = *(_QWORD *)(a1 + 2680);
      v557 = *(_QWORD *)(a1 + 2696) - 1;
    }
    *(_QWORD *)(v558 + 16) = 0;
    v560 = *(uint64_t **)(a1 + 2680);
    v561 = *v560;
    *(_QWORD *)(v561 + 8) = v560[1];
    *(_QWORD *)v560[1] = v561;
    *(_QWORD *)(a1 + 2696) = v557;
    operator delete(v560);
  }
  *(_BYTE *)(a3 + 1192) = 0;
  return v8;
}

void sub_1B30080E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  uint64_t v20;

  PCString::~PCString((PCString *)&__p);
  MEMORY[0x1B5E29170](v20, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

uint64_t OZShape::getContour(OZShape *this, const CMTime *a2, OZShapeRenderParams *a3)
{
  PCMutex *v6;
  uint64_t CachedContour;

  v6 = (PCMutex *)((char *)this + 8);
  PCMutex::lock((PCMutex *)((char *)this + 8));
  CachedContour = OZShape::getCachedContour(this, (uint64_t)a2, (uint64_t)a3, 0);
  if (!CachedContour)
    CachedContour = OZShape::updateContour((uint64_t)this, a2, (uint64_t)a3, 0);
  PCMutex::unlock(v6);
  return CachedContour;
}

void sub_1B300822C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t OZShape::getRenderContour(uint64_t a1, const CMTime *a2, uint64_t a3, double *a4)
{
  PCMutex *v8;
  uint64_t CachedContour;

  v8 = (PCMutex *)(a1 + 8);
  PCMutex::lock((PCMutex *)(a1 + 8));
  CachedContour = OZShape::getCachedContour((OZShape *)a1, (uint64_t)a2, a3, a4);
  if (!CachedContour)
    CachedContour = OZShape::updateContour(a1, a2, a3, a4);
  PCMutex::unlock(v8);
  return CachedContour;
}

void sub_1B30082DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

double OZShape::getReparametrizedContourLength(uint64_t a1, uint64_t a2, int a3, double *a4)
{
  PCMutex *v8;
  __int128 v9;
  __int128 v10;
  CGColorSpace *v11;
  uint64_t CurrentRenderParams;
  uint64_t ReparametrizedContour;
  double v14;
  _OWORD v16[5];
  CGColorSpace *v17;
  int v18;
  uint64_t v19;
  char v20;

  v8 = (PCMutex *)(a1 + 8);
  v19 = a1 + 8;
  v20 = 0;
  if (a3)
  {
    PCMutex::lock((PCMutex *)(a1 + 8));
    v20 = 1;
  }
  v9 = *(_OWORD *)(a2 + 48);
  v16[2] = *(_OWORD *)(a2 + 32);
  v16[3] = v9;
  v16[4] = *(_OWORD *)(a2 + 64);
  v10 = *(_OWORD *)(a2 + 16);
  v16[0] = *(_OWORD *)a2;
  v16[1] = v10;
  v11 = *(CGColorSpace **)(a2 + 80);
  v17 = v11;
  if (v11)
    PCCFRefTraits<CGColorSpace *>::retain(v11);
  v18 = *(_DWORD *)(a2 + 88);
  CurrentRenderParams = OZShape::getCurrentRenderParams(a1, (uint64_t)v16);
  ReparametrizedContour = OZShape::getReparametrizedContour(a1, a2, CurrentRenderParams, a4);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
  if (ReparametrizedContour)
  {
    v14 = *(double *)(ReparametrizedContour + 392);
    if (!a3)
      return v14;
    goto LABEL_9;
  }
  v14 = 0.0;
  if (a3)
LABEL_9:
    PCMutex::unlock(v8);
  return v14;
}

void sub_1B30083E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  PCLockSentry<PCMutex>::~PCLockSentry(v1 - 80);
  _Unwind_Resume(a1);
}

void OZShape::getReparametrizedPointOnContour(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, double *a6, int a7, double *a8, long double a9, char a10)
{
  PCMutex *v19;
  __int128 v20;
  __int128 v21;
  CGColorSpace *v22;
  uint64_t CurrentRenderParams;
  uint64_t ReparametrizedContour;
  uint64_t v25;
  double v26;
  uint64_t v27;
  double *v28;
  unint64_t v29;
  double v30;
  double v31;
  unint64_t v32;
  double v33;
  uint64_t v34;
  double v35;
  unint64_t v36;
  double v37;
  double v38;
  double *v39;
  double *v40;
  uint64_t RenderContour;
  double *v42;
  double v43;
  unint64_t v44;
  uint64_t v45;
  double v46;
  double v47;
  long double v48;
  double v49;
  double v50;
  long double v51;
  double v52;
  double v53;
  double v54;
  double *v55;
  double v56;
  double v57;
  double v58;
  long double v59;
  double v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  long double v66;
  double *v67;
  double *v68;
  double *v69;
  _OWORD v70[5];
  CGColorSpace *v71;
  int v72;
  uint64_t v73;
  char v74;

  v19 = (PCMutex *)(a1 + 8);
  v73 = a1 + 8;
  v74 = 0;
  if (a7)
  {
    PCMutex::lock((PCMutex *)(a1 + 8));
    v74 = 1;
  }
  v69 = a3;
  v20 = *(_OWORD *)(a2 + 48);
  v70[2] = *(_OWORD *)(a2 + 32);
  v70[3] = v20;
  v70[4] = *(_OWORD *)(a2 + 64);
  v21 = *(_OWORD *)(a2 + 16);
  v70[0] = *(_OWORD *)a2;
  v70[1] = v21;
  v22 = *(CGColorSpace **)(a2 + 80);
  v71 = v22;
  if (v22)
    PCCFRefTraits<CGColorSpace *>::retain(v22);
  v72 = *(_DWORD *)(a2 + 88);
  CurrentRenderParams = OZShape::getCurrentRenderParams(a1, (uint64_t)v70);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v71);
  ReparametrizedContour = OZShape::getReparametrizedContour(a1, a2, CurrentRenderParams, a8);
  v25 = ReparametrizedContour;
  if (!ReparametrizedContour)
    goto LABEL_43;
  v67 = a4;
  v68 = a5;
  v26 = *(double *)(ReparametrizedContour + 392);
  if (v26 <= 0.0
    || (v28 = *(double **)(ReparametrizedContour + 216),
        v27 = *(_QWORD *)(ReparametrizedContour + 224),
        (unint64_t)(v27 - (_QWORD)v28) < 9))
  {
    RenderContour = OZShape::getRenderContour(a1, (const CMTime *)a2, CurrentRenderParams, a8);
    v42 = *(double **)(RenderContour + 216);
    if (*(double **)(RenderContour + 224) != v42)
    {
      v39 = a6;
      if (v69)
        *v69 = *v42;
      if (v67)
        *v67 = **(double **)(RenderContour + 240);
      if (v68)
        *v68 = 0.0;
      v43 = 0.0;
      if (a6)
        goto LABEL_42;
    }
    goto LABEL_43;
  }
  v29 = (v27 - (uint64_t)v28) >> 3;
  if (!*(_DWORD *)(CurrentRenderParams + 168))
  {
    v44 = v29 - 1;
    if (a9 <= 1.0)
    {
      v39 = a6;
      if (a9 >= 0.0)
      {
        v60 = (double)v44 * a9;
        v61 = (int)v60;
        if (v44 == v61)
        {
          v62 = v61 - 1;
          v33 = v28[v62];
          v63 = *(_QWORD *)(ReparametrizedContour + 240);
          v35 = *(double *)(v63 + 8 * v62);
          v49 = v28[v44];
          v50 = *(double *)(v63 + 8 * v44);
          v37 = v49;
          v46 = v50;
        }
        else
        {
          v33 = v28[v61];
          v64 = *(_QWORD *)(ReparametrizedContour + 240);
          v35 = *(double *)(v64 + 8 * v61);
          v65 = v61 + 1;
          v37 = v28[v65];
          v46 = *(double *)(v64 + 8 * v65);
          v66 = fmod(v60, 1.0);
          v49 = v33 + v66 * (v37 - v33);
          v50 = v35 + v66 * (v46 - v35);
        }
      }
      else
      {
        v55 = *(double **)(ReparametrizedContour + 240);
        v33 = *v28;
        v37 = v28[1];
        v35 = *v55;
        v46 = v55[1];
        v56 = v37 - *v28;
        v57 = v46 - *v55;
        v58 = sqrt(v56 * v56 + v57 * v57);
        v59 = v26 * a9;
        v49 = v37 + v59 * (v56 / v58);
        v50 = v46 + v59 * (v57 / v58);
      }
      goto LABEL_30;
    }
    v37 = v28[v44];
    v45 = *(_QWORD *)(ReparametrizedContour + 248);
    v33 = *(double *)((char *)v28 + v45 - *(_QWORD *)(ReparametrizedContour + 240) - 16);
    v35 = *(double *)(v45 - 16);
    v46 = *(double *)(v45 - 8);
    v47 = sqrt((v37 - v33) * (v37 - v33) + (v46 - v35) * (v46 - v35));
    v48 = (a9 + -1.0) * v26;
    v49 = v37 + v48 * ((v37 - v33) / v47);
    v50 = v46 + v48 * ((v46 - v35) / v47);
LABEL_29:
    v39 = a6;
LABEL_30:
    v40 = v69;
    goto LABEL_33;
  }
  v30 = fmod(a9, 1.0);
  if (v30 < 0.0)
    v30 = v30 + 1.0;
  if ((a10 & 1) == 0)
    v29 = (__PAIR128__(v29, COERCE_UNSIGNED_INT64(fabs(sqrt((*v28 - *(double *)(v27 - 8)) * (*v28 - *(double *)(v27 - 8))+ (**(double **)(v25 + 240) - *(double *)(*(_QWORD *)(v25 + 248) - 8))* (**(double **)(v25 + 240) - *(double *)(*(_QWORD *)(v25 + 248) - 8))))))- COERCE_UNSIGNED_INT64(0.001)) >> 64;
  if (!v29)
  {
    v33 = 0.0;
    v35 = 0.0;
    v49 = 0.0;
    v50 = 0.0;
    v37 = 0.0;
    v46 = 0.0;
    goto LABEL_29;
  }
  v31 = v30 * (double)v29;
  v32 = (int)v31;
  v33 = v28[v32 % v29];
  v34 = *(_QWORD *)(v25 + 240);
  v35 = *(double *)(v34 + 8 * (v32 % v29));
  v36 = (v32 + 1) % v29;
  v37 = v28[v36];
  v38 = v37 - v33;
  v39 = a6;
  if (vabdd_f64(v37, v33) >= 0.0000001)
  {
    v40 = v69;
  }
  else
  {
    v40 = v69;
    if (vabdd_f64(*(double *)(v34 + 8 * v36), v35) < 0.0000001)
    {
      v36 = (v32 + 2) % v29;
      v37 = v28[v36];
      v38 = v37 - v33;
    }
  }
  v46 = *(double *)(v34 + 8 * v36);
  v51 = fmod(v31, 1.0);
  v49 = v33 + v51 * v38;
  v50 = v35 + v51 * (v46 - v35);
LABEL_33:
  v52 = v37 - v33;
  v53 = v46 - v35;
  if (v40)
    *v40 = v49;
  v54 = sqrt(v52 * v52 + v53 * v53);
  if (v67)
    *v67 = v50;
  if (fabs(v54) >= 0.0000001)
  {
    if (v68)
      *v68 = -v53 / v54;
    if (v39)
    {
      v43 = v52 / v54;
LABEL_42:
      *v39 = v43;
    }
  }
LABEL_43:
  if (a7)
    PCMutex::unlock(v19);
}

void sub_1B3008858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a26);
  _Unwind_Resume(a1);
}

double PCMatrix44Tmpl<double>::rightMult(uint64_t a1, double *a2)
{
  uint64_t i;
  double *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double result;

  for (i = 0; i != 128; i += 32)
  {
    v3 = (double *)(a1 + i);
    v4 = *(double *)(a1 + i);
    v5 = *(double *)(a1 + i + 8);
    v6 = *(double *)(a1 + i + 16);
    v7 = *(double *)(a1 + i + 24);
    *v3 = v4 * *a2 + v5 * a2[4] + v6 * a2[8] + v7 * a2[12];
    v3[1] = v4 * a2[1] + v5 * a2[5] + v6 * a2[9] + v7 * a2[13];
    v3[2] = v4 * a2[2] + v5 * a2[6] + v6 * a2[10] + v7 * a2[14];
    result = v4 * a2[3] + v5 * a2[7] + v6 * a2[11] + v7 * a2[15];
    v3[3] = result;
  }
  return result;
}

uint64_t OZShape::getRectangleFromCircleReparametrizedContour(OZShape *a1, CMTime *a2, uint64_t a3, uint64_t a4, double *a5, double *a6, double a7)
{
  double v14;
  double v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  unint64_t v49;
  void **v50;
  double v51;
  double *v52;
  double *v53;
  double *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  double *v60;
  char *v61;
  uint64_t v62;
  void **v63;
  double v64;
  unint64_t v65;
  double *v66;
  double *v67;
  double *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  double *v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  void **v78;
  char *v79;
  _QWORD *v80;
  char *v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double i;
  unint64_t v96;
  double *v97;
  double v98;
  double *v99;
  double *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  char *v105;
  double *v106;
  uint64_t v107;
  unint64_t v108;
  double *v109;
  double v110;
  double *v111;
  double *v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  char *v117;
  double *v118;
  uint64_t v119;
  unint64_t v120;
  double *v121;
  double v122;
  double *v123;
  double *v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  char *v129;
  double *v130;
  uint64_t v131;
  double v132;
  double v133;
  double v134;
  double v135;
  double v136;
  unint64_t v137;
  double *v138;
  double *v139;
  double *v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  char *v145;
  double *v146;
  char *v147;
  uint64_t v148;
  double v149;
  unint64_t v150;
  double *v151;
  double *v152;
  double *v153;
  uint64_t v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  char *v158;
  double *v159;
  char *v160;
  uint64_t v161;
  double v162;
  unint64_t v163;
  double *v164;
  double *v165;
  double *v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  char *v171;
  double *v172;
  char *v173;
  uint64_t v174;
  unint64_t v175;
  double *v176;
  double v177;
  double *v178;
  double *v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  unint64_t v183;
  char *v184;
  double *v185;
  uint64_t v186;
  unint64_t v187;
  double *v188;
  double v189;
  double *v190;
  double *v191;
  uint64_t v192;
  unint64_t v193;
  uint64_t v194;
  unint64_t v195;
  char *v196;
  double *v197;
  uint64_t v198;
  unint64_t v199;
  double *v200;
  double v201;
  double *v202;
  double *v203;
  uint64_t v204;
  unint64_t v205;
  uint64_t v206;
  unint64_t v207;
  char *v208;
  double *v209;
  uint64_t v210;
  double v211;
  double v212;
  double v213;
  double v214;
  double v215;
  double v216;
  unint64_t v217;
  double *v218;
  double *v219;
  double *v220;
  uint64_t v221;
  unint64_t v222;
  uint64_t v223;
  unint64_t v224;
  char *v225;
  double *v226;
  char *v227;
  uint64_t v228;
  double v229;
  unint64_t v230;
  double *v231;
  double *v232;
  double *v233;
  uint64_t v234;
  unint64_t v235;
  uint64_t v236;
  unint64_t v237;
  char *v238;
  double *v239;
  char *v240;
  uint64_t v241;
  double v242;
  unint64_t v243;
  double *v244;
  double *v245;
  double *v246;
  uint64_t v247;
  unint64_t v248;
  uint64_t v249;
  unint64_t v250;
  char *v251;
  double *v252;
  char *v253;
  uint64_t v254;
  unint64_t v255;
  double *v256;
  double v257;
  double *v258;
  double *v259;
  uint64_t v260;
  unint64_t v261;
  uint64_t v262;
  unint64_t v263;
  char *v264;
  double *v265;
  uint64_t v266;
  unint64_t v267;
  double *v268;
  double v269;
  double *v270;
  double *v271;
  uint64_t v272;
  unint64_t v273;
  uint64_t v274;
  unint64_t v275;
  char *v276;
  double *v277;
  uint64_t v278;
  unint64_t v279;
  double *v280;
  double v281;
  double *v282;
  double *v283;
  uint64_t v284;
  unint64_t v285;
  uint64_t v286;
  unint64_t v287;
  char *v288;
  double *v289;
  uint64_t v290;
  double v291;
  double v292;
  double v293;
  double v294;
  double v295;
  double v296;
  double v297;
  unint64_t v298;
  double *v299;
  double *v300;
  double *v301;
  uint64_t v302;
  unint64_t v303;
  uint64_t v304;
  unint64_t v305;
  char *v306;
  double *v307;
  char *v308;
  uint64_t v309;
  double v310;
  unint64_t v311;
  double *v312;
  double *v313;
  double *v314;
  uint64_t v315;
  unint64_t v316;
  uint64_t v317;
  unint64_t v318;
  char *v319;
  double *v320;
  char *v321;
  uint64_t v322;
  double v323;
  unint64_t v324;
  double *v325;
  double *v326;
  double *v327;
  uint64_t v328;
  unint64_t v329;
  uint64_t v330;
  unint64_t v331;
  char *v332;
  double *v333;
  char *v334;
  uint64_t v335;
  unint64_t v336;
  double *v337;
  double v338;
  double *v339;
  double *v340;
  uint64_t v341;
  unint64_t v342;
  uint64_t v343;
  unint64_t v344;
  char *v345;
  double *v346;
  uint64_t v347;
  unint64_t v348;
  double *v349;
  double v350;
  double *v351;
  double *v352;
  uint64_t v353;
  unint64_t v354;
  uint64_t v355;
  unint64_t v356;
  char *v357;
  double *v358;
  uint64_t v359;
  unint64_t v360;
  double *v361;
  double v362;
  double *v363;
  double *v364;
  uint64_t v365;
  unint64_t v366;
  uint64_t v367;
  unint64_t v368;
  char *v369;
  double *v370;
  uint64_t v371;
  double v372;
  double v373;
  double v374;
  double v375;
  double v376;
  unint64_t v377;
  double *v378;
  double *v379;
  double *v380;
  uint64_t v381;
  unint64_t v382;
  uint64_t v383;
  unint64_t v384;
  char *v385;
  double *v386;
  char *v387;
  uint64_t v388;
  double v389;
  unint64_t v390;
  double *v391;
  double *v392;
  double *v393;
  uint64_t v394;
  unint64_t v395;
  uint64_t v396;
  unint64_t v397;
  char *v398;
  double *v399;
  char *v400;
  uint64_t v401;
  double v402;
  unint64_t v403;
  double *v404;
  double *v405;
  double *v406;
  uint64_t v407;
  unint64_t v408;
  uint64_t v409;
  unint64_t v410;
  char *v411;
  double *v412;
  char *v413;
  uint64_t v414;
  unint64_t v415;
  double *v416;
  double v417;
  double *v418;
  double *v419;
  uint64_t v420;
  unint64_t v421;
  uint64_t v422;
  unint64_t v423;
  char *v424;
  double *v425;
  uint64_t v426;
  unint64_t v427;
  double *v428;
  double v429;
  double *v430;
  double *v431;
  uint64_t v432;
  unint64_t v433;
  uint64_t v434;
  unint64_t v435;
  char *v436;
  double *v437;
  uint64_t v438;
  unint64_t v439;
  double *v440;
  double v441;
  double *v442;
  double *v443;
  uint64_t v444;
  unint64_t v445;
  uint64_t v446;
  unint64_t v447;
  char *v448;
  double *v449;
  uint64_t v450;
  _QWORD *v451;
  _QWORD *v452;
  unint64_t v453;
  _QWORD *v454;
  uint64_t v455;
  unint64_t v456;
  uint64_t v457;
  unint64_t v458;
  char *v459;
  _QWORD *v460;
  char *v461;
  char *v462;
  uint64_t v463;
  _QWORD *v464;
  _QWORD *v465;
  unint64_t v466;
  _QWORD *v467;
  uint64_t v468;
  unint64_t v469;
  uint64_t v470;
  unint64_t v471;
  char *v472;
  _QWORD *v473;
  char *v474;
  char *v475;
  uint64_t v476;
  unint64_t v477;
  char *v478;
  _QWORD *v479;
  char *v480;
  uint64_t v481;
  unint64_t v482;
  uint64_t v483;
  unint64_t v484;
  char *v485;
  char *v486;
  char *v487;
  uint64_t v488;
  double *v489;
  uint64_t v490;
  unint64_t v491;
  double *v492;
  double v493;
  double v494;
  BOOL v495;
  OZShape *v497;
  double v498;
  double v499;
  double v500;
  double v501;
  double v502;
  double v503;
  double v504;
  double v505;
  double *v506;
  double *v507;
  double v508;
  double v509;
  double v510;
  double v511;
  double v512;
  double v513;
  double v514;
  double v515;
  double v516;
  double v517;
  double v518;
  double v519;
  __int128 v520;
  __int128 v521;
  __int128 v522;
  __int128 v523;
  __int128 v524;
  __int128 v525;
  __int128 v526;
  __int128 v527;

  v15 = *(double *)(a3 + 200);
  v14 = *(double *)(a3 + 208);
  v16 = *((_OWORD *)a5 + 5);
  v524 = *((_OWORD *)a5 + 4);
  v525 = v16;
  v17 = *((_OWORD *)a5 + 7);
  v526 = *((_OWORD *)a5 + 6);
  v527 = v17;
  v18 = *((_OWORD *)a5 + 1);
  v520 = *(_OWORD *)a5;
  v521 = v18;
  v19 = *((_OWORD *)a5 + 3);
  v522 = *((_OWORD *)a5 + 2);
  v523 = v19;
  PCMatrix44Tmpl<double>::invert((double *)&v520, (double *)&v520, 0.0);
  v20 = a5[12];
  v21 = a5[13];
  v22 = -(v15 * v20);
  v23 = a5[15];
  v24 = v23 + v14 * v21 - v15 * v20;
  v25 = a5[1];
  v26 = a5[3];
  v27 = a5[4];
  v28 = (v26 + v14 * v25 - v15 * *a5) / v24;
  v29 = v14 * a5[5];
  v30 = a5[7];
  v31 = (v30 + v29 - v15 * v27) / v24;
  v32 = v15 * v20;
  v33 = v23 + v32 + v14 * v21;
  v34 = v15 * *a5;
  v35 = (v26 + v34 + v14 * v25) / v33;
  v36 = (v30 + v15 * v27 + v29) / v33;
  v37 = -(v14 * v21);
  v38 = v23 + v32 + v37;
  v39 = -(v14 * v25);
  v40 = (v26 + v34 - v14 * v25) / v38;
  v41 = (v30 + v15 * v27 - v29) / v38;
  v42 = v23 + v22 + v37;
  v43 = (v26 + v39 - v34) / v42;
  v44 = (v30 + -(v15 * v27) - v29) / v42;
  v517 = v35 - v28;
  v518 = v36 - v31;
  v45 = sqrt(v517 * v517 + v518 * v518);
  v502 = v36;
  v503 = v35;
  v514 = v40 - v35;
  v515 = v41 - v36;
  v500 = v41;
  v501 = v40;
  v512 = v43 - v40;
  v513 = v44 - v41;
  v504 = v31;
  v505 = v28;
  v46 = v28 - v43;
  v47 = v31 - v44;
  v516 = sqrt(v514 * v514 + v515 * v515);
  v519 = sqrt(v512 * v512 + v513 * v513);
  v48 = sqrt(v46 * v46 + v47 * v47);
  v49 = *(_QWORD *)(a4 + 232);
  *(double *)(a4 + 392) = v48 + v519 + v45 + v516;
  v50 = (void **)(a4 + 216);
  v51 = v43 + (v28 - v43) * 0.5;
  v52 = *(double **)(a4 + 224);
  v497 = a1;
  if ((unint64_t)v52 >= v49)
  {
    v54 = (double *)*v50;
    v55 = ((char *)v52 - (_BYTE *)*v50) >> 3;
    v56 = v55 + 1;
    if ((unint64_t)(v55 + 1) >> 61)
      goto LABEL_562;
    v57 = v49 - (_QWORD)v54;
    if (v57 >> 2 > v56)
      v56 = v57 >> 2;
    if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8)
      v58 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v58 = v56;
    if (v58)
    {
      v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v58);
      v54 = *(double **)(a4 + 216);
      v52 = *(double **)(a4 + 224);
    }
    else
    {
      v59 = 0;
    }
    v60 = (double *)&v59[8 * v55];
    v61 = &v59[8 * v58];
    *v60 = v51;
    v53 = v60 + 1;
    while (v52 != v54)
    {
      v62 = *((_QWORD *)v52-- - 1);
      *((_QWORD *)v60-- - 1) = v62;
    }
    *(_QWORD *)(a4 + 216) = v60;
    *(_QWORD *)(a4 + 224) = v53;
    *(_QWORD *)(a4 + 232) = v61;
    if (v54)
      operator delete(v54);
  }
  else
  {
    *v52 = v51;
    v53 = v52 + 1;
  }
  *(_QWORD *)(a4 + 224) = v53;
  v63 = (void **)(a4 + 240);
  v64 = v44 + v47 * 0.5;
  v66 = *(double **)(a4 + 248);
  v65 = *(_QWORD *)(a4 + 256);
  v506 = a5;
  v507 = a6;
  if ((unint64_t)v66 >= v65)
  {
    v68 = (double *)*v63;
    v69 = ((char *)v66 - (_BYTE *)*v63) >> 3;
    v70 = v69 + 1;
    if ((unint64_t)(v69 + 1) >> 61)
      goto LABEL_563;
    v71 = v65 - (_QWORD)v68;
    if (v71 >> 2 > v70)
      v70 = v71 >> 2;
    if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8)
      v72 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v72 = v70;
    if (v72)
    {
      v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v72);
      v68 = *(double **)(a4 + 240);
      v66 = *(double **)(a4 + 248);
    }
    else
    {
      v73 = 0;
    }
    v74 = (double *)&v73[8 * v69];
    v75 = &v73[8 * v72];
    *v74 = v64;
    v67 = v74 + 1;
    while (v66 != v68)
    {
      v76 = *((_QWORD *)v66-- - 1);
      *((_QWORD *)v74-- - 1) = v76;
    }
    *(_QWORD *)(a4 + 240) = v74;
    *(_QWORD *)(a4 + 248) = v67;
    *(_QWORD *)(a4 + 256) = v75;
    if (v68)
      operator delete(v68);
  }
  else
  {
    *v66 = v64;
    v67 = v66 + 1;
  }
  v77 = *(_QWORD *)(a4 + 208);
  *(_QWORD *)(a4 + 248) = v67;
  v78 = (void **)(a4 + 192);
  v79 = *(char **)(a4 + 200);
  v498 = v44;
  v499 = v43;
  if ((unint64_t)v79 >= v77)
  {
    v81 = (char *)*v78;
    v82 = (v79 - (_BYTE *)*v78) >> 3;
    v83 = v82 + 1;
    if ((unint64_t)(v82 + 1) >> 61)
      goto LABEL_564;
    v84 = v77 - (_QWORD)v81;
    if (v84 >> 2 > v83)
      v83 = v84 >> 2;
    if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8)
      v85 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v85 = v83;
    if (v85)
    {
      v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v85);
      v81 = *(char **)(a4 + 192);
      v79 = *(char **)(a4 + 200);
    }
    else
    {
      v86 = 0;
    }
    v87 = &v86[8 * v82];
    v88 = &v86[8 * v85];
    *(_QWORD *)v87 = 0;
    v80 = v87 + 8;
    while (v79 != v81)
    {
      v89 = *((_QWORD *)v79 - 1);
      v79 -= 8;
      *((_QWORD *)v87 - 1) = v89;
      v87 -= 8;
    }
    *(_QWORD *)(a4 + 192) = v87;
    *(_QWORD *)(a4 + 200) = v80;
    *(_QWORD *)(a4 + 208) = v88;
    if (v81)
      operator delete(v81);
  }
  else
  {
    *(_QWORD *)v79 = 0;
    v80 = v79 + 8;
  }
  v90 = v46 / v48 * a7;
  v91 = v47 / v48 * a7;
  v92 = 2.0 / v48 * a7;
  *(_QWORD *)(a4 + 200) = v80;
  v93 = v48;
  v94 = a7 + 0.0;
  v511 = v93;
  for (i = v93 * 0.5; v94 <= i; v94 = v94 + a7)
  {
    v97 = *(double **)(a4 + 224);
    v96 = *(_QWORD *)(a4 + 232);
    v98 = v90 + *(v97 - 1);
    if ((unint64_t)v97 >= v96)
    {
      v100 = (double *)*v50;
      v101 = ((char *)v97 - (_BYTE *)*v50) >> 3;
      v102 = v101 + 1;
      if ((unint64_t)(v101 + 1) >> 61)
        goto LABEL_562;
      v103 = v96 - (_QWORD)v100;
      if (v103 >> 2 > v102)
        v102 = v103 >> 2;
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8)
        v104 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v104 = v102;
      if (v104)
      {
        v105 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v104);
        v100 = *(double **)(a4 + 216);
        v97 = *(double **)(a4 + 224);
      }
      else
      {
        v105 = 0;
      }
      v106 = (double *)&v105[8 * v101];
      *v106 = v98;
      v99 = v106 + 1;
      while (v97 != v100)
      {
        v107 = *((_QWORD *)v97-- - 1);
        *((_QWORD *)v106-- - 1) = v107;
      }
      *(_QWORD *)(a4 + 216) = v106;
      *(_QWORD *)(a4 + 224) = v99;
      *(_QWORD *)(a4 + 232) = &v105[8 * v104];
      if (v100)
        operator delete(v100);
    }
    else
    {
      *v97 = v98;
      v99 = v97 + 1;
    }
    *(_QWORD *)(a4 + 224) = v99;
    v109 = *(double **)(a4 + 248);
    v108 = *(_QWORD *)(a4 + 256);
    v110 = v91 + *(v109 - 1);
    if ((unint64_t)v109 >= v108)
    {
      v112 = (double *)*v63;
      v113 = ((char *)v109 - (_BYTE *)*v63) >> 3;
      v114 = v113 + 1;
      if ((unint64_t)(v113 + 1) >> 61)
        goto LABEL_563;
      v115 = v108 - (_QWORD)v112;
      if (v115 >> 2 > v114)
        v114 = v115 >> 2;
      if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFF8)
        v116 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v116 = v114;
      if (v116)
      {
        v117 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v116);
        v112 = *(double **)(a4 + 240);
        v109 = *(double **)(a4 + 248);
      }
      else
      {
        v117 = 0;
      }
      v118 = (double *)&v117[8 * v113];
      *v118 = v110;
      v111 = v118 + 1;
      while (v109 != v112)
      {
        v119 = *((_QWORD *)v109-- - 1);
        *((_QWORD *)v118-- - 1) = v119;
      }
      *(_QWORD *)(a4 + 240) = v118;
      *(_QWORD *)(a4 + 248) = v111;
      *(_QWORD *)(a4 + 256) = &v117[8 * v116];
      if (v112)
        operator delete(v112);
    }
    else
    {
      *v109 = v110;
      v111 = v109 + 1;
    }
    *(_QWORD *)(a4 + 248) = v111;
    v121 = *(double **)(a4 + 200);
    v120 = *(_QWORD *)(a4 + 208);
    v122 = v92 + *(v121 - 1);
    if ((unint64_t)v121 >= v120)
    {
      v124 = (double *)*v78;
      v125 = ((char *)v121 - (_BYTE *)*v78) >> 3;
      v126 = v125 + 1;
      if ((unint64_t)(v125 + 1) >> 61)
        goto LABEL_564;
      v127 = v120 - (_QWORD)v124;
      if (v127 >> 2 > v126)
        v126 = v127 >> 2;
      if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFF8)
        v128 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v128 = v126;
      if (v128)
      {
        v129 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v128);
        v124 = *(double **)(a4 + 192);
        v121 = *(double **)(a4 + 200);
      }
      else
      {
        v129 = 0;
      }
      v130 = (double *)&v129[8 * v125];
      *v130 = v122;
      v123 = v130 + 1;
      while (v121 != v124)
      {
        v131 = *((_QWORD *)v121-- - 1);
        *((_QWORD *)v130-- - 1) = v131;
      }
      *(_QWORD *)(a4 + 192) = v130;
      *(_QWORD *)(a4 + 200) = v123;
      *(_QWORD *)(a4 + 208) = &v129[8 * v128];
      if (v124)
        operator delete(v124);
    }
    else
    {
      *v121 = v122;
      v123 = v121 + 1;
    }
    *(_QWORD *)(a4 + 200) = v123;
  }
  v508 = v92;
  v509 = v91;
  v510 = v90;
  v132 = v94 - i;
  v133 = v517 / v45 * a7;
  v134 = v518 / v45 * a7;
  v135 = 1.0 / v45 * a7;
  if (vabdd_f64(v94, i) >= 0.0000001)
  {
    v136 = v505 + v133 * v132 / v45;
    v138 = *(double **)(a4 + 224);
    v137 = *(_QWORD *)(a4 + 232);
    if ((unint64_t)v138 >= v137)
    {
      v140 = (double *)*v50;
      v141 = ((char *)v138 - (_BYTE *)*v50) >> 3;
      v142 = v141 + 1;
      if ((unint64_t)(v141 + 1) >> 61)
        goto LABEL_562;
      v143 = v137 - (_QWORD)v140;
      if (v143 >> 2 > v142)
        v142 = v143 >> 2;
      if ((unint64_t)v143 >= 0x7FFFFFFFFFFFFFF8)
        v144 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v144 = v142;
      if (v144)
      {
        v145 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v144);
        v140 = *(double **)(a4 + 216);
        v138 = *(double **)(a4 + 224);
      }
      else
      {
        v145 = 0;
      }
      v146 = (double *)&v145[8 * v141];
      v147 = &v145[8 * v144];
      *v146 = v136;
      v139 = v146 + 1;
      while (v138 != v140)
      {
        v148 = *((_QWORD *)v138-- - 1);
        *((_QWORD *)v146-- - 1) = v148;
      }
      *(_QWORD *)(a4 + 216) = v146;
      *(_QWORD *)(a4 + 224) = v139;
      *(_QWORD *)(a4 + 232) = v147;
      if (v140)
        operator delete(v140);
    }
    else
    {
      *v138 = v136;
      v139 = v138 + 1;
    }
    *(_QWORD *)(a4 + 224) = v139;
    v149 = v504 + v134 * v132 / v45;
    v151 = *(double **)(a4 + 248);
    v150 = *(_QWORD *)(a4 + 256);
    if ((unint64_t)v151 >= v150)
    {
      v153 = (double *)*v63;
      v154 = ((char *)v151 - (_BYTE *)*v63) >> 3;
      v155 = v154 + 1;
      if ((unint64_t)(v154 + 1) >> 61)
        goto LABEL_563;
      v156 = v150 - (_QWORD)v153;
      if (v156 >> 2 > v155)
        v155 = v156 >> 2;
      if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFF8)
        v157 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v157 = v155;
      if (v157)
      {
        v158 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v157);
        v153 = *(double **)(a4 + 240);
        v151 = *(double **)(a4 + 248);
      }
      else
      {
        v158 = 0;
      }
      v159 = (double *)&v158[8 * v154];
      v160 = &v158[8 * v157];
      *v159 = v149;
      v152 = v159 + 1;
      while (v151 != v153)
      {
        v161 = *((_QWORD *)v151-- - 1);
        *((_QWORD *)v159-- - 1) = v161;
      }
      *(_QWORD *)(a4 + 240) = v159;
      *(_QWORD *)(a4 + 248) = v152;
      *(_QWORD *)(a4 + 256) = v160;
      if (v153)
        operator delete(v153);
    }
    else
    {
      *v151 = v149;
      v152 = v151 + 1;
    }
    *(_QWORD *)(a4 + 248) = v152;
    v162 = v135 * v132 / v45 + 1.0;
    v164 = *(double **)(a4 + 200);
    v163 = *(_QWORD *)(a4 + 208);
    if ((unint64_t)v164 >= v163)
    {
      v166 = (double *)*v78;
      v167 = ((char *)v164 - (_BYTE *)*v78) >> 3;
      v168 = v167 + 1;
      if ((unint64_t)(v167 + 1) >> 61)
        goto LABEL_564;
      v169 = v163 - (_QWORD)v166;
      if (v169 >> 2 > v168)
        v168 = v169 >> 2;
      if ((unint64_t)v169 >= 0x7FFFFFFFFFFFFFF8)
        v170 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v170 = v168;
      if (v170)
      {
        v171 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v170);
        v166 = *(double **)(a4 + 192);
        v164 = *(double **)(a4 + 200);
      }
      else
      {
        v171 = 0;
      }
      v172 = (double *)&v171[8 * v167];
      v173 = &v171[8 * v170];
      *v172 = v162;
      v165 = v172 + 1;
      while (v164 != v166)
      {
        v174 = *((_QWORD *)v164-- - 1);
        *((_QWORD *)v172-- - 1) = v174;
      }
      *(_QWORD *)(a4 + 192) = v172;
      *(_QWORD *)(a4 + 200) = v165;
      *(_QWORD *)(a4 + 208) = v173;
      if (v166)
        operator delete(v166);
    }
    else
    {
      *v164 = v162;
      v165 = v164 + 1;
    }
    *(_QWORD *)(a4 + 200) = v165;
    v132 = v132 + a7;
  }
  for (; v132 <= v45; v132 = v132 + a7)
  {
    v176 = *(double **)(a4 + 224);
    v175 = *(_QWORD *)(a4 + 232);
    v177 = v133 + *(v176 - 1);
    if ((unint64_t)v176 >= v175)
    {
      v179 = (double *)*v50;
      v180 = ((char *)v176 - (_BYTE *)*v50) >> 3;
      v181 = v180 + 1;
      if ((unint64_t)(v180 + 1) >> 61)
        goto LABEL_562;
      v182 = v175 - (_QWORD)v179;
      if (v182 >> 2 > v181)
        v181 = v182 >> 2;
      if ((unint64_t)v182 >= 0x7FFFFFFFFFFFFFF8)
        v183 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v183 = v181;
      if (v183)
      {
        v184 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v183);
        v179 = *(double **)(a4 + 216);
        v176 = *(double **)(a4 + 224);
      }
      else
      {
        v184 = 0;
      }
      v185 = (double *)&v184[8 * v180];
      *v185 = v177;
      v178 = v185 + 1;
      while (v176 != v179)
      {
        v186 = *((_QWORD *)v176-- - 1);
        *((_QWORD *)v185-- - 1) = v186;
      }
      *(_QWORD *)(a4 + 216) = v185;
      *(_QWORD *)(a4 + 224) = v178;
      *(_QWORD *)(a4 + 232) = &v184[8 * v183];
      if (v179)
        operator delete(v179);
    }
    else
    {
      *v176 = v177;
      v178 = v176 + 1;
    }
    *(_QWORD *)(a4 + 224) = v178;
    v188 = *(double **)(a4 + 248);
    v187 = *(_QWORD *)(a4 + 256);
    v189 = v134 + *(v188 - 1);
    if ((unint64_t)v188 >= v187)
    {
      v191 = (double *)*v63;
      v192 = ((char *)v188 - (_BYTE *)*v63) >> 3;
      v193 = v192 + 1;
      if ((unint64_t)(v192 + 1) >> 61)
        goto LABEL_563;
      v194 = v187 - (_QWORD)v191;
      if (v194 >> 2 > v193)
        v193 = v194 >> 2;
      if ((unint64_t)v194 >= 0x7FFFFFFFFFFFFFF8)
        v195 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v195 = v193;
      if (v195)
      {
        v196 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v195);
        v191 = *(double **)(a4 + 240);
        v188 = *(double **)(a4 + 248);
      }
      else
      {
        v196 = 0;
      }
      v197 = (double *)&v196[8 * v192];
      *v197 = v189;
      v190 = v197 + 1;
      while (v188 != v191)
      {
        v198 = *((_QWORD *)v188-- - 1);
        *((_QWORD *)v197-- - 1) = v198;
      }
      *(_QWORD *)(a4 + 240) = v197;
      *(_QWORD *)(a4 + 248) = v190;
      *(_QWORD *)(a4 + 256) = &v196[8 * v195];
      if (v191)
        operator delete(v191);
    }
    else
    {
      *v188 = v189;
      v190 = v188 + 1;
    }
    *(_QWORD *)(a4 + 248) = v190;
    v200 = *(double **)(a4 + 200);
    v199 = *(_QWORD *)(a4 + 208);
    v201 = v135 + *(v200 - 1);
    if ((unint64_t)v200 >= v199)
    {
      v203 = (double *)*v78;
      v204 = ((char *)v200 - (_BYTE *)*v78) >> 3;
      v205 = v204 + 1;
      if ((unint64_t)(v204 + 1) >> 61)
        goto LABEL_564;
      v206 = v199 - (_QWORD)v203;
      if (v206 >> 2 > v205)
        v205 = v206 >> 2;
      if ((unint64_t)v206 >= 0x7FFFFFFFFFFFFFF8)
        v207 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v207 = v205;
      if (v207)
      {
        v208 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v207);
        v203 = *(double **)(a4 + 192);
        v200 = *(double **)(a4 + 200);
      }
      else
      {
        v208 = 0;
      }
      v209 = (double *)&v208[8 * v204];
      *v209 = v201;
      v202 = v209 + 1;
      while (v200 != v203)
      {
        v210 = *((_QWORD *)v200-- - 1);
        *((_QWORD *)v209-- - 1) = v210;
      }
      *(_QWORD *)(a4 + 192) = v209;
      *(_QWORD *)(a4 + 200) = v202;
      *(_QWORD *)(a4 + 208) = &v208[8 * v207];
      if (v203)
        operator delete(v203);
    }
    else
    {
      *v200 = v201;
      v202 = v200 + 1;
    }
    *(_QWORD *)(a4 + 200) = v202;
  }
  v211 = v132 - v45;
  v212 = v514 / v516 * a7;
  v213 = v515 / v516 * a7;
  v214 = 1.0 / v516 * a7;
  if (vabdd_f64(v132, v45) >= 0.0000001)
  {
    v216 = v503 + v212 * v211 / v516;
    v218 = *(double **)(a4 + 224);
    v217 = *(_QWORD *)(a4 + 232);
    v215 = v516;
    if ((unint64_t)v218 >= v217)
    {
      v220 = (double *)*v50;
      v221 = ((char *)v218 - (_BYTE *)*v50) >> 3;
      v222 = v221 + 1;
      if ((unint64_t)(v221 + 1) >> 61)
        goto LABEL_562;
      v223 = v217 - (_QWORD)v220;
      if (v223 >> 2 > v222)
        v222 = v223 >> 2;
      if ((unint64_t)v223 >= 0x7FFFFFFFFFFFFFF8)
        v224 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v224 = v222;
      if (v224)
      {
        v225 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v224);
        v220 = *(double **)(a4 + 216);
        v218 = *(double **)(a4 + 224);
      }
      else
      {
        v225 = 0;
      }
      v226 = (double *)&v225[8 * v221];
      v227 = &v225[8 * v224];
      *v226 = v216;
      v219 = v226 + 1;
      while (v218 != v220)
      {
        v228 = *((_QWORD *)v218-- - 1);
        *((_QWORD *)v226-- - 1) = v228;
      }
      *(_QWORD *)(a4 + 216) = v226;
      *(_QWORD *)(a4 + 224) = v219;
      *(_QWORD *)(a4 + 232) = v227;
      if (v220)
        operator delete(v220);
    }
    else
    {
      *v218 = v216;
      v219 = v218 + 1;
    }
    *(_QWORD *)(a4 + 224) = v219;
    v229 = v502 + v213 * v211 / v516;
    v231 = *(double **)(a4 + 248);
    v230 = *(_QWORD *)(a4 + 256);
    if ((unint64_t)v231 >= v230)
    {
      v233 = (double *)*v63;
      v234 = ((char *)v231 - (_BYTE *)*v63) >> 3;
      v235 = v234 + 1;
      if ((unint64_t)(v234 + 1) >> 61)
        goto LABEL_563;
      v236 = v230 - (_QWORD)v233;
      if (v236 >> 2 > v235)
        v235 = v236 >> 2;
      if ((unint64_t)v236 >= 0x7FFFFFFFFFFFFFF8)
        v237 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v237 = v235;
      if (v237)
      {
        v238 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v237);
        v233 = *(double **)(a4 + 240);
        v231 = *(double **)(a4 + 248);
      }
      else
      {
        v238 = 0;
      }
      v239 = (double *)&v238[8 * v234];
      v240 = &v238[8 * v237];
      *v239 = v229;
      v232 = v239 + 1;
      while (v231 != v233)
      {
        v241 = *((_QWORD *)v231-- - 1);
        *((_QWORD *)v239-- - 1) = v241;
      }
      *(_QWORD *)(a4 + 240) = v239;
      *(_QWORD *)(a4 + 248) = v232;
      *(_QWORD *)(a4 + 256) = v240;
      if (v233)
        operator delete(v233);
    }
    else
    {
      *v231 = v229;
      v232 = v231 + 1;
    }
    *(_QWORD *)(a4 + 248) = v232;
    v242 = v214 * v211 / v516 + 2.0;
    v244 = *(double **)(a4 + 200);
    v243 = *(_QWORD *)(a4 + 208);
    if ((unint64_t)v244 >= v243)
    {
      v246 = (double *)*v78;
      v247 = ((char *)v244 - (_BYTE *)*v78) >> 3;
      v248 = v247 + 1;
      if ((unint64_t)(v247 + 1) >> 61)
        goto LABEL_564;
      v249 = v243 - (_QWORD)v246;
      if (v249 >> 2 > v248)
        v248 = v249 >> 2;
      if ((unint64_t)v249 >= 0x7FFFFFFFFFFFFFF8)
        v250 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v250 = v248;
      if (v250)
      {
        v251 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v250);
        v246 = *(double **)(a4 + 192);
        v244 = *(double **)(a4 + 200);
      }
      else
      {
        v251 = 0;
      }
      v252 = (double *)&v251[8 * v247];
      v253 = &v251[8 * v250];
      *v252 = v242;
      v245 = v252 + 1;
      while (v244 != v246)
      {
        v254 = *((_QWORD *)v244-- - 1);
        *((_QWORD *)v252-- - 1) = v254;
      }
      *(_QWORD *)(a4 + 192) = v252;
      *(_QWORD *)(a4 + 200) = v245;
      *(_QWORD *)(a4 + 208) = v253;
      if (v246)
        operator delete(v246);
    }
    else
    {
      *v244 = v242;
      v245 = v244 + 1;
    }
    *(_QWORD *)(a4 + 200) = v245;
    v211 = v211 + a7;
  }
  else
  {
    v215 = v516;
  }
  for (; v211 <= v215; v211 = v211 + a7)
  {
    v256 = *(double **)(a4 + 224);
    v255 = *(_QWORD *)(a4 + 232);
    v257 = v212 + *(v256 - 1);
    if ((unint64_t)v256 >= v255)
    {
      v259 = (double *)*v50;
      v260 = ((char *)v256 - (_BYTE *)*v50) >> 3;
      v261 = v260 + 1;
      if ((unint64_t)(v260 + 1) >> 61)
        goto LABEL_562;
      v262 = v255 - (_QWORD)v259;
      if (v262 >> 2 > v261)
        v261 = v262 >> 2;
      if ((unint64_t)v262 >= 0x7FFFFFFFFFFFFFF8)
        v263 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v263 = v261;
      if (v263)
      {
        v264 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v263);
        v259 = *(double **)(a4 + 216);
        v256 = *(double **)(a4 + 224);
      }
      else
      {
        v264 = 0;
      }
      v265 = (double *)&v264[8 * v260];
      *v265 = v257;
      v258 = v265 + 1;
      while (v256 != v259)
      {
        v266 = *((_QWORD *)v256-- - 1);
        *((_QWORD *)v265-- - 1) = v266;
      }
      *(_QWORD *)(a4 + 216) = v265;
      *(_QWORD *)(a4 + 224) = v258;
      *(_QWORD *)(a4 + 232) = &v264[8 * v263];
      if (v259)
        operator delete(v259);
    }
    else
    {
      *v256 = v257;
      v258 = v256 + 1;
    }
    *(_QWORD *)(a4 + 224) = v258;
    v268 = *(double **)(a4 + 248);
    v267 = *(_QWORD *)(a4 + 256);
    v269 = v213 + *(v268 - 1);
    if ((unint64_t)v268 >= v267)
    {
      v271 = (double *)*v63;
      v272 = ((char *)v268 - (_BYTE *)*v63) >> 3;
      v273 = v272 + 1;
      if ((unint64_t)(v272 + 1) >> 61)
        goto LABEL_563;
      v274 = v267 - (_QWORD)v271;
      if (v274 >> 2 > v273)
        v273 = v274 >> 2;
      if ((unint64_t)v274 >= 0x7FFFFFFFFFFFFFF8)
        v275 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v275 = v273;
      if (v275)
      {
        v276 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v275);
        v271 = *(double **)(a4 + 240);
        v268 = *(double **)(a4 + 248);
      }
      else
      {
        v276 = 0;
      }
      v277 = (double *)&v276[8 * v272];
      *v277 = v269;
      v270 = v277 + 1;
      while (v268 != v271)
      {
        v278 = *((_QWORD *)v268-- - 1);
        *((_QWORD *)v277-- - 1) = v278;
      }
      *(_QWORD *)(a4 + 240) = v277;
      *(_QWORD *)(a4 + 248) = v270;
      *(_QWORD *)(a4 + 256) = &v276[8 * v275];
      if (v271)
        operator delete(v271);
    }
    else
    {
      *v268 = v269;
      v270 = v268 + 1;
    }
    *(_QWORD *)(a4 + 248) = v270;
    v280 = *(double **)(a4 + 200);
    v279 = *(_QWORD *)(a4 + 208);
    v281 = v214 + *(v280 - 1);
    if ((unint64_t)v280 >= v279)
    {
      v283 = (double *)*v78;
      v284 = ((char *)v280 - (_BYTE *)*v78) >> 3;
      v285 = v284 + 1;
      if ((unint64_t)(v284 + 1) >> 61)
        goto LABEL_564;
      v286 = v279 - (_QWORD)v283;
      if (v286 >> 2 > v285)
        v285 = v286 >> 2;
      if ((unint64_t)v286 >= 0x7FFFFFFFFFFFFFF8)
        v287 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v287 = v285;
      if (v287)
      {
        v288 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v287);
        v283 = *(double **)(a4 + 192);
        v280 = *(double **)(a4 + 200);
      }
      else
      {
        v288 = 0;
      }
      v289 = (double *)&v288[8 * v284];
      *v289 = v281;
      v282 = v289 + 1;
      while (v280 != v283)
      {
        v290 = *((_QWORD *)v280-- - 1);
        *((_QWORD *)v289-- - 1) = v290;
      }
      *(_QWORD *)(a4 + 192) = v289;
      *(_QWORD *)(a4 + 200) = v282;
      *(_QWORD *)(a4 + 208) = &v288[8 * v287];
      if (v283)
        operator delete(v283);
    }
    else
    {
      *v280 = v281;
      v282 = v280 + 1;
    }
    *(_QWORD *)(a4 + 200) = v282;
  }
  v291 = v211 - v215;
  v292 = v512 / v519 * a7;
  v293 = v513 / v519 * a7;
  v294 = v215;
  v295 = 1.0 / v519 * a7;
  if (vabdd_f64(v211, v294) >= 0.0000001)
  {
    v297 = v501 + v292 * v291 / v519;
    v299 = *(double **)(a4 + 224);
    v298 = *(_QWORD *)(a4 + 232);
    v296 = v511;
    if ((unint64_t)v299 >= v298)
    {
      v301 = (double *)*v50;
      v302 = ((char *)v299 - (_BYTE *)*v50) >> 3;
      v303 = v302 + 1;
      if ((unint64_t)(v302 + 1) >> 61)
        goto LABEL_562;
      v304 = v298 - (_QWORD)v301;
      if (v304 >> 2 > v303)
        v303 = v304 >> 2;
      if ((unint64_t)v304 >= 0x7FFFFFFFFFFFFFF8)
        v305 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v305 = v303;
      if (v305)
      {
        v306 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v305);
        v301 = *(double **)(a4 + 216);
        v299 = *(double **)(a4 + 224);
      }
      else
      {
        v306 = 0;
      }
      v307 = (double *)&v306[8 * v302];
      v308 = &v306[8 * v305];
      *v307 = v297;
      v300 = v307 + 1;
      while (v299 != v301)
      {
        v309 = *((_QWORD *)v299-- - 1);
        *((_QWORD *)v307-- - 1) = v309;
      }
      *(_QWORD *)(a4 + 216) = v307;
      *(_QWORD *)(a4 + 224) = v300;
      *(_QWORD *)(a4 + 232) = v308;
      if (v301)
        operator delete(v301);
    }
    else
    {
      *v299 = v297;
      v300 = v299 + 1;
    }
    *(_QWORD *)(a4 + 224) = v300;
    v310 = v500 + v293 * v291 / v519;
    v312 = *(double **)(a4 + 248);
    v311 = *(_QWORD *)(a4 + 256);
    if ((unint64_t)v312 >= v311)
    {
      v314 = (double *)*v63;
      v315 = ((char *)v312 - (_BYTE *)*v63) >> 3;
      v316 = v315 + 1;
      if ((unint64_t)(v315 + 1) >> 61)
        goto LABEL_563;
      v317 = v311 - (_QWORD)v314;
      if (v317 >> 2 > v316)
        v316 = v317 >> 2;
      if ((unint64_t)v317 >= 0x7FFFFFFFFFFFFFF8)
        v318 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v318 = v316;
      if (v318)
      {
        v319 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v318);
        v314 = *(double **)(a4 + 240);
        v312 = *(double **)(a4 + 248);
      }
      else
      {
        v319 = 0;
      }
      v320 = (double *)&v319[8 * v315];
      v321 = &v319[8 * v318];
      *v320 = v310;
      v313 = v320 + 1;
      while (v312 != v314)
      {
        v322 = *((_QWORD *)v312-- - 1);
        *((_QWORD *)v320-- - 1) = v322;
      }
      *(_QWORD *)(a4 + 240) = v320;
      *(_QWORD *)(a4 + 248) = v313;
      *(_QWORD *)(a4 + 256) = v321;
      if (v314)
        operator delete(v314);
    }
    else
    {
      *v312 = v310;
      v313 = v312 + 1;
    }
    *(_QWORD *)(a4 + 248) = v313;
    v323 = v295 * v291 / v519 + 3.0;
    v325 = *(double **)(a4 + 200);
    v324 = *(_QWORD *)(a4 + 208);
    if ((unint64_t)v325 >= v324)
    {
      v327 = (double *)*v78;
      v328 = ((char *)v325 - (_BYTE *)*v78) >> 3;
      v329 = v328 + 1;
      if ((unint64_t)(v328 + 1) >> 61)
        goto LABEL_564;
      v330 = v324 - (_QWORD)v327;
      if (v330 >> 2 > v329)
        v329 = v330 >> 2;
      if ((unint64_t)v330 >= 0x7FFFFFFFFFFFFFF8)
        v331 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v331 = v329;
      if (v331)
      {
        v332 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v331);
        v327 = *(double **)(a4 + 192);
        v325 = *(double **)(a4 + 200);
      }
      else
      {
        v332 = 0;
      }
      v333 = (double *)&v332[8 * v328];
      v334 = &v332[8 * v331];
      *v333 = v323;
      v326 = v333 + 1;
      while (v325 != v327)
      {
        v335 = *((_QWORD *)v325-- - 1);
        *((_QWORD *)v333-- - 1) = v335;
      }
      *(_QWORD *)(a4 + 192) = v333;
      *(_QWORD *)(a4 + 200) = v326;
      *(_QWORD *)(a4 + 208) = v334;
      if (v327)
        operator delete(v327);
    }
    else
    {
      *v325 = v323;
      v326 = v325 + 1;
    }
    *(_QWORD *)(a4 + 200) = v326;
    v291 = v291 + a7;
  }
  else
  {
    v296 = v511;
  }
  for (; v291 <= v519; v291 = v291 + a7)
  {
    v337 = *(double **)(a4 + 224);
    v336 = *(_QWORD *)(a4 + 232);
    v338 = v292 + *(v337 - 1);
    if ((unint64_t)v337 >= v336)
    {
      v340 = (double *)*v50;
      v341 = ((char *)v337 - (_BYTE *)*v50) >> 3;
      v342 = v341 + 1;
      if ((unint64_t)(v341 + 1) >> 61)
        goto LABEL_562;
      v343 = v336 - (_QWORD)v340;
      if (v343 >> 2 > v342)
        v342 = v343 >> 2;
      if ((unint64_t)v343 >= 0x7FFFFFFFFFFFFFF8)
        v344 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v344 = v342;
      if (v344)
      {
        v345 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v344);
        v340 = *(double **)(a4 + 216);
        v337 = *(double **)(a4 + 224);
      }
      else
      {
        v345 = 0;
      }
      v346 = (double *)&v345[8 * v341];
      *v346 = v338;
      v339 = v346 + 1;
      while (v337 != v340)
      {
        v347 = *((_QWORD *)v337-- - 1);
        *((_QWORD *)v346-- - 1) = v347;
      }
      *(_QWORD *)(a4 + 216) = v346;
      *(_QWORD *)(a4 + 224) = v339;
      *(_QWORD *)(a4 + 232) = &v345[8 * v344];
      if (v340)
        operator delete(v340);
    }
    else
    {
      *v337 = v338;
      v339 = v337 + 1;
    }
    *(_QWORD *)(a4 + 224) = v339;
    v349 = *(double **)(a4 + 248);
    v348 = *(_QWORD *)(a4 + 256);
    v350 = v293 + *(v349 - 1);
    if ((unint64_t)v349 >= v348)
    {
      v352 = (double *)*v63;
      v353 = ((char *)v349 - (_BYTE *)*v63) >> 3;
      v354 = v353 + 1;
      if ((unint64_t)(v353 + 1) >> 61)
        goto LABEL_563;
      v355 = v348 - (_QWORD)v352;
      if (v355 >> 2 > v354)
        v354 = v355 >> 2;
      if ((unint64_t)v355 >= 0x7FFFFFFFFFFFFFF8)
        v356 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v356 = v354;
      if (v356)
      {
        v357 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v356);
        v352 = *(double **)(a4 + 240);
        v349 = *(double **)(a4 + 248);
      }
      else
      {
        v357 = 0;
      }
      v358 = (double *)&v357[8 * v353];
      *v358 = v350;
      v351 = v358 + 1;
      while (v349 != v352)
      {
        v359 = *((_QWORD *)v349-- - 1);
        *((_QWORD *)v358-- - 1) = v359;
      }
      *(_QWORD *)(a4 + 240) = v358;
      *(_QWORD *)(a4 + 248) = v351;
      *(_QWORD *)(a4 + 256) = &v357[8 * v356];
      if (v352)
        operator delete(v352);
    }
    else
    {
      *v349 = v350;
      v351 = v349 + 1;
    }
    *(_QWORD *)(a4 + 248) = v351;
    v361 = *(double **)(a4 + 200);
    v360 = *(_QWORD *)(a4 + 208);
    v362 = v295 + *(v361 - 1);
    if ((unint64_t)v361 >= v360)
    {
      v364 = (double *)*v78;
      v365 = ((char *)v361 - (_BYTE *)*v78) >> 3;
      v366 = v365 + 1;
      if ((unint64_t)(v365 + 1) >> 61)
        goto LABEL_564;
      v367 = v360 - (_QWORD)v364;
      if (v367 >> 2 > v366)
        v366 = v367 >> 2;
      if ((unint64_t)v367 >= 0x7FFFFFFFFFFFFFF8)
        v368 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v368 = v366;
      if (v368)
      {
        v369 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v368);
        v364 = *(double **)(a4 + 192);
        v361 = *(double **)(a4 + 200);
      }
      else
      {
        v369 = 0;
      }
      v370 = (double *)&v369[8 * v365];
      *v370 = v362;
      v363 = v370 + 1;
      while (v361 != v364)
      {
        v371 = *((_QWORD *)v361-- - 1);
        *((_QWORD *)v370-- - 1) = v371;
      }
      *(_QWORD *)(a4 + 192) = v370;
      *(_QWORD *)(a4 + 200) = v363;
      *(_QWORD *)(a4 + 208) = &v369[8 * v368];
      if (v364)
        operator delete(v364);
    }
    else
    {
      *v361 = v362;
      v363 = v361 + 1;
    }
    *(_QWORD *)(a4 + 200) = v363;
  }
  v372 = v291 - v519;
  if (vabdd_f64(v291, v519) >= 0.0000001)
  {
    v374 = v509;
    v373 = v510;
    v376 = v499 + v510 * v372 / v296;
    v378 = *(double **)(a4 + 224);
    v377 = *(_QWORD *)(a4 + 232);
    v375 = v508;
    if ((unint64_t)v378 >= v377)
    {
      v380 = (double *)*v50;
      v381 = ((char *)v378 - (_BYTE *)*v50) >> 3;
      v382 = v381 + 1;
      if ((unint64_t)(v381 + 1) >> 61)
        goto LABEL_562;
      v383 = v377 - (_QWORD)v380;
      if (v383 >> 2 > v382)
        v382 = v383 >> 2;
      if ((unint64_t)v383 >= 0x7FFFFFFFFFFFFFF8)
        v384 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v384 = v382;
      if (v384)
      {
        v385 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v384);
        v380 = *(double **)(a4 + 216);
        v378 = *(double **)(a4 + 224);
      }
      else
      {
        v385 = 0;
      }
      v386 = (double *)&v385[8 * v381];
      v387 = &v385[8 * v384];
      *v386 = v376;
      v379 = v386 + 1;
      while (v378 != v380)
      {
        v388 = *((_QWORD *)v378-- - 1);
        *((_QWORD *)v386-- - 1) = v388;
      }
      *(_QWORD *)(a4 + 216) = v386;
      *(_QWORD *)(a4 + 224) = v379;
      *(_QWORD *)(a4 + 232) = v387;
      if (v380)
        operator delete(v380);
    }
    else
    {
      *v378 = v376;
      v379 = v378 + 1;
    }
    *(_QWORD *)(a4 + 224) = v379;
    v389 = v498 + v509 * v372 / v296;
    v391 = *(double **)(a4 + 248);
    v390 = *(_QWORD *)(a4 + 256);
    if ((unint64_t)v391 >= v390)
    {
      v393 = (double *)*v63;
      v394 = ((char *)v391 - (_BYTE *)*v63) >> 3;
      v395 = v394 + 1;
      if ((unint64_t)(v394 + 1) >> 61)
        goto LABEL_563;
      v396 = v390 - (_QWORD)v393;
      if (v396 >> 2 > v395)
        v395 = v396 >> 2;
      if ((unint64_t)v396 >= 0x7FFFFFFFFFFFFFF8)
        v397 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v397 = v395;
      if (v397)
      {
        v398 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v397);
        v393 = *(double **)(a4 + 240);
        v391 = *(double **)(a4 + 248);
      }
      else
      {
        v398 = 0;
      }
      v399 = (double *)&v398[8 * v394];
      v400 = &v398[8 * v397];
      *v399 = v389;
      v392 = v399 + 1;
      while (v391 != v393)
      {
        v401 = *((_QWORD *)v391-- - 1);
        *((_QWORD *)v399-- - 1) = v401;
      }
      *(_QWORD *)(a4 + 240) = v399;
      *(_QWORD *)(a4 + 248) = v392;
      *(_QWORD *)(a4 + 256) = v400;
      if (v393)
        operator delete(v393);
    }
    else
    {
      *v391 = v389;
      v392 = v391 + 1;
    }
    *(_QWORD *)(a4 + 248) = v392;
    v402 = v508 * v372 / v296 + 4.0;
    v404 = *(double **)(a4 + 200);
    v403 = *(_QWORD *)(a4 + 208);
    if ((unint64_t)v404 >= v403)
    {
      v406 = (double *)*v78;
      v407 = ((char *)v404 - (_BYTE *)*v78) >> 3;
      v408 = v407 + 1;
      if ((unint64_t)(v407 + 1) >> 61)
        goto LABEL_564;
      v409 = v403 - (_QWORD)v406;
      if (v409 >> 2 > v408)
        v408 = v409 >> 2;
      if ((unint64_t)v409 >= 0x7FFFFFFFFFFFFFF8)
        v410 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v410 = v408;
      if (v410)
      {
        v411 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v410);
        v406 = *(double **)(a4 + 192);
        v404 = *(double **)(a4 + 200);
      }
      else
      {
        v411 = 0;
      }
      v412 = (double *)&v411[8 * v407];
      v413 = &v411[8 * v410];
      *v412 = v402;
      v405 = v412 + 1;
      while (v404 != v406)
      {
        v414 = *((_QWORD *)v404-- - 1);
        *((_QWORD *)v412-- - 1) = v414;
      }
      *(_QWORD *)(a4 + 192) = v412;
      *(_QWORD *)(a4 + 200) = v405;
      *(_QWORD *)(a4 + 208) = v413;
      if (v406)
        operator delete(v406);
    }
    else
    {
      *v404 = v402;
      v405 = v404 + 1;
    }
    *(_QWORD *)(a4 + 200) = v405;
    v372 = v372 + a7;
  }
  else
  {
    v374 = v509;
    v373 = v510;
    v375 = v508;
  }
  for (; v372 <= i; v372 = v372 + a7)
  {
    v416 = *(double **)(a4 + 224);
    v415 = *(_QWORD *)(a4 + 232);
    v417 = v373 + *(v416 - 1);
    if ((unint64_t)v416 >= v415)
    {
      v419 = (double *)*v50;
      v420 = ((char *)v416 - (_BYTE *)*v50) >> 3;
      v421 = v420 + 1;
      if ((unint64_t)(v420 + 1) >> 61)
        goto LABEL_562;
      v422 = v415 - (_QWORD)v419;
      if (v422 >> 2 > v421)
        v421 = v422 >> 2;
      if ((unint64_t)v422 >= 0x7FFFFFFFFFFFFFF8)
        v423 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v423 = v421;
      if (v423)
      {
        v424 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v423);
        v419 = *(double **)(a4 + 216);
        v416 = *(double **)(a4 + 224);
      }
      else
      {
        v424 = 0;
      }
      v425 = (double *)&v424[8 * v420];
      *v425 = v417;
      v418 = v425 + 1;
      while (v416 != v419)
      {
        v426 = *((_QWORD *)v416-- - 1);
        *((_QWORD *)v425-- - 1) = v426;
      }
      *(_QWORD *)(a4 + 216) = v425;
      *(_QWORD *)(a4 + 224) = v418;
      *(_QWORD *)(a4 + 232) = &v424[8 * v423];
      if (v419)
        operator delete(v419);
    }
    else
    {
      *v416 = v417;
      v418 = v416 + 1;
    }
    *(_QWORD *)(a4 + 224) = v418;
    v428 = *(double **)(a4 + 248);
    v427 = *(_QWORD *)(a4 + 256);
    v429 = v374 + *(v428 - 1);
    if ((unint64_t)v428 >= v427)
    {
      v431 = (double *)*v63;
      v432 = ((char *)v428 - (_BYTE *)*v63) >> 3;
      v433 = v432 + 1;
      if ((unint64_t)(v432 + 1) >> 61)
        goto LABEL_563;
      v434 = v427 - (_QWORD)v431;
      if (v434 >> 2 > v433)
        v433 = v434 >> 2;
      if ((unint64_t)v434 >= 0x7FFFFFFFFFFFFFF8)
        v435 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v435 = v433;
      if (v435)
      {
        v436 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v435);
        v431 = *(double **)(a4 + 240);
        v428 = *(double **)(a4 + 248);
      }
      else
      {
        v436 = 0;
      }
      v437 = (double *)&v436[8 * v432];
      *v437 = v429;
      v430 = v437 + 1;
      while (v428 != v431)
      {
        v438 = *((_QWORD *)v428-- - 1);
        *((_QWORD *)v437-- - 1) = v438;
      }
      *(_QWORD *)(a4 + 240) = v437;
      *(_QWORD *)(a4 + 248) = v430;
      *(_QWORD *)(a4 + 256) = &v436[8 * v435];
      if (v431)
        operator delete(v431);
    }
    else
    {
      *v428 = v429;
      v430 = v428 + 1;
    }
    *(_QWORD *)(a4 + 248) = v430;
    v440 = *(double **)(a4 + 200);
    v439 = *(_QWORD *)(a4 + 208);
    v441 = v375 + *(v440 - 1);
    if ((unint64_t)v440 >= v439)
    {
      v443 = (double *)*v78;
      v444 = ((char *)v440 - (_BYTE *)*v78) >> 3;
      v445 = v444 + 1;
      if ((unint64_t)(v444 + 1) >> 61)
        goto LABEL_564;
      v446 = v439 - (_QWORD)v443;
      if (v446 >> 2 > v445)
        v445 = v446 >> 2;
      if ((unint64_t)v446 >= 0x7FFFFFFFFFFFFFF8)
        v447 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v447 = v445;
      if (v447)
      {
        v448 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v447);
        v443 = *(double **)(a4 + 192);
        v440 = *(double **)(a4 + 200);
      }
      else
      {
        v448 = 0;
      }
      v449 = (double *)&v448[8 * v444];
      *v449 = v441;
      v442 = v449 + 1;
      while (v440 != v443)
      {
        v450 = *((_QWORD *)v440-- - 1);
        *((_QWORD *)v449-- - 1) = v450;
      }
      *(_QWORD *)(a4 + 192) = v449;
      *(_QWORD *)(a4 + 200) = v442;
      *(_QWORD *)(a4 + 208) = &v448[8 * v447];
      if (v443)
        operator delete(v443);
    }
    else
    {
      *v440 = v441;
      v442 = v440 + 1;
    }
    *(_QWORD *)(a4 + 200) = v442;
  }
  if (vabdd_f64(v372, i) >= 0.0000001)
  {
    v452 = *(_QWORD **)(a4 + 216);
    v451 = *(_QWORD **)(a4 + 224);
    v453 = *(_QWORD *)(a4 + 232);
    if ((unint64_t)v451 < v453)
    {
      *v451 = *v452;
      v454 = v451 + 1;
LABEL_519:
      *(_QWORD *)(a4 + 224) = v454;
      v465 = *(_QWORD **)(a4 + 240);
      v464 = *(_QWORD **)(a4 + 248);
      v466 = *(_QWORD *)(a4 + 256);
      if ((unint64_t)v464 < v466)
      {
        *v464 = *v465;
        v467 = v464 + 1;
LABEL_535:
        *(_QWORD *)(a4 + 248) = v467;
        v478 = *(char **)(a4 + 200);
        v477 = *(_QWORD *)(a4 + 208);
        if ((unint64_t)v478 < v477)
        {
          *(_QWORD *)v478 = 0x4014000000000000;
          v479 = v478 + 8;
LABEL_551:
          *(_QWORD *)(a4 + 200) = v479;
          goto LABEL_552;
        }
        v480 = (char *)*v78;
        v481 = (v478 - (_BYTE *)*v78) >> 3;
        v482 = v481 + 1;
        if (!((unint64_t)(v481 + 1) >> 61))
        {
          v483 = v477 - (_QWORD)v480;
          if (v483 >> 2 > v482)
            v482 = v483 >> 2;
          if ((unint64_t)v483 >= 0x7FFFFFFFFFFFFFF8)
            v484 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v484 = v482;
          if (v484)
          {
            v485 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v484);
            v480 = *(char **)(a4 + 192);
            v478 = *(char **)(a4 + 200);
          }
          else
          {
            v485 = 0;
          }
          v486 = &v485[8 * v481];
          v487 = &v485[8 * v484];
          *(_QWORD *)v486 = 0x4014000000000000;
          v479 = v486 + 8;
          while (v478 != v480)
          {
            v488 = *((_QWORD *)v478 - 1);
            v478 -= 8;
            *((_QWORD *)v486 - 1) = v488;
            v486 -= 8;
          }
          *(_QWORD *)(a4 + 192) = v486;
          *(_QWORD *)(a4 + 200) = v479;
          *(_QWORD *)(a4 + 208) = v487;
          if (v480)
            operator delete(v480);
          goto LABEL_551;
        }
LABEL_564:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      v468 = v464 - v465;
      v469 = v468 + 1;
      if (!((unint64_t)(v468 + 1) >> 61))
      {
        v470 = v466 - (_QWORD)v465;
        if (v470 >> 2 > v469)
          v469 = v470 >> 2;
        if ((unint64_t)v470 >= 0x7FFFFFFFFFFFFFF8)
          v471 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v471 = v469;
        if (v471)
        {
          v472 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v471);
          v473 = *(_QWORD **)(a4 + 240);
          v464 = *(_QWORD **)(a4 + 248);
        }
        else
        {
          v472 = 0;
          v473 = *(_QWORD **)(a4 + 240);
        }
        v474 = &v472[8 * v468];
        v475 = &v472[8 * v471];
        *(_QWORD *)v474 = *v465;
        v467 = v474 + 8;
        while (v464 != v473)
        {
          v476 = *--v464;
          *((_QWORD *)v474 - 1) = v476;
          v474 -= 8;
        }
        *(_QWORD *)(a4 + 240) = v474;
        *(_QWORD *)(a4 + 248) = v467;
        *(_QWORD *)(a4 + 256) = v475;
        if (v473)
          operator delete(v473);
        goto LABEL_535;
      }
LABEL_563:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    v455 = v451 - v452;
    v456 = v455 + 1;
    if (!((unint64_t)(v455 + 1) >> 61))
    {
      v457 = v453 - (_QWORD)v452;
      if (v457 >> 2 > v456)
        v456 = v457 >> 2;
      if ((unint64_t)v457 >= 0x7FFFFFFFFFFFFFF8)
        v458 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v458 = v456;
      if (v458)
      {
        v459 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v458);
        v460 = *(_QWORD **)(a4 + 216);
        v451 = *(_QWORD **)(a4 + 224);
      }
      else
      {
        v459 = 0;
        v460 = *(_QWORD **)(a4 + 216);
      }
      v461 = &v459[8 * v455];
      v462 = &v459[8 * v458];
      *(_QWORD *)v461 = *v452;
      v454 = v461 + 8;
      while (v451 != v460)
      {
        v463 = *--v451;
        *((_QWORD *)v461 - 1) = v463;
        v461 -= 8;
      }
      *(_QWORD *)(a4 + 216) = v461;
      *(_QWORD *)(a4 + 224) = v454;
      *(_QWORD *)(a4 + 232) = v462;
      if (v460)
        operator delete(v460);
      goto LABEL_519;
    }
LABEL_562:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_552:
  if (!PCMatrix44Tmpl<double>::isIdentity(v506))
  {
    v489 = *(double **)(a4 + 216);
    v490 = *(_QWORD *)(a4 + 224) - (_QWORD)v489;
    if (v490)
    {
      v491 = v490 >> 3;
      v492 = (double *)*v63;
      if (v491 <= 1)
        v491 = 1;
      do
      {
        v493 = *((double *)&v527 + 1) + *v489 * *(double *)&v526 + *v492 * *((double *)&v526 + 1);
        v494 = (*((double *)&v523 + 1) + *v489 * *(double *)&v522 + *v492 * *((double *)&v522 + 1)) / v493;
        *v489 = (*((double *)&v521 + 1) + *v489 * *(double *)&v520 + *v492 * *((double *)&v520 + 1)) / v493;
        ++v489;
        *v492++ = v494;
        --v491;
      }
      while (v491);
    }
  }
  v495 = 1;
  *(_WORD *)(a4 + 185) = 1;
  if (v507)
    v495 = PCMatrix44Tmpl<double>::isIdentity(v507) || !OZShape::checkWindingOrder(v497, a2, a3, v507, 0);
  *(_BYTE *)(a4 + 187) = v495;
  return a4;
}

uint64_t OZShape::getRectangleReparametrizedContour(OZShape *a1, CMTime *a2, uint64_t a3, uint64_t a4, double *a5, double *a6, double a7)
{
  double v14;
  double v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  unint64_t v49;
  void **v50;
  double *v51;
  double *v52;
  double *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  double *v59;
  char *v60;
  uint64_t v61;
  void **v62;
  unint64_t v63;
  double *v64;
  double *v65;
  double *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  double *v72;
  char *v73;
  uint64_t v74;
  unint64_t v75;
  void **v76;
  char *v77;
  _QWORD *v78;
  char *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  char *v85;
  char *v86;
  uint64_t v87;
  double v88;
  double v89;
  double v90;
  unint64_t v91;
  double *v92;
  double v93;
  double *v94;
  double *v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  char *v100;
  double *v101;
  uint64_t v102;
  unint64_t v103;
  double *v104;
  double v105;
  double *v106;
  double *v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  char *v112;
  double *v113;
  uint64_t v114;
  unint64_t v115;
  double *v116;
  double v117;
  double *v118;
  double *v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  char *v124;
  double *v125;
  uint64_t v126;
  double v127;
  double v128;
  double v129;
  double v130;
  double v131;
  unint64_t v132;
  double *v133;
  double *v134;
  double v135;
  double *v136;
  uint64_t v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  char *v141;
  double *v142;
  char *v143;
  uint64_t v144;
  double v145;
  unint64_t v146;
  double *v147;
  double *v148;
  double *v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  char *v154;
  double *v155;
  char *v156;
  uint64_t v157;
  double v158;
  unint64_t v159;
  double *v160;
  double *v161;
  double *v162;
  uint64_t v163;
  unint64_t v164;
  uint64_t v165;
  unint64_t v166;
  char *v167;
  double *v168;
  char *v169;
  uint64_t v170;
  unint64_t v171;
  double *v172;
  double v173;
  double *v174;
  double *v175;
  uint64_t v176;
  unint64_t v177;
  uint64_t v178;
  unint64_t v179;
  char *v180;
  double *v181;
  uint64_t v182;
  unint64_t v183;
  double *v184;
  double v185;
  double *v186;
  double *v187;
  uint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  char *v192;
  double *v193;
  uint64_t v194;
  unint64_t v195;
  double *v196;
  double v197;
  double *v198;
  double *v199;
  uint64_t v200;
  unint64_t v201;
  uint64_t v202;
  unint64_t v203;
  char *v204;
  double *v205;
  uint64_t v206;
  double v207;
  double v208;
  double v209;
  double v210;
  double v211;
  unint64_t v212;
  double *v213;
  double *v214;
  double v215;
  double *v216;
  uint64_t v217;
  unint64_t v218;
  uint64_t v219;
  unint64_t v220;
  char *v221;
  double *v222;
  char *v223;
  uint64_t v224;
  double v225;
  unint64_t v226;
  double *v227;
  double *v228;
  double *v229;
  uint64_t v230;
  unint64_t v231;
  uint64_t v232;
  unint64_t v233;
  char *v234;
  double *v235;
  char *v236;
  uint64_t v237;
  double v238;
  unint64_t v239;
  double *v240;
  double *v241;
  double *v242;
  uint64_t v243;
  unint64_t v244;
  uint64_t v245;
  unint64_t v246;
  char *v247;
  double *v248;
  char *v249;
  uint64_t v250;
  unint64_t v251;
  double *v252;
  double v253;
  double *v254;
  double *v255;
  uint64_t v256;
  unint64_t v257;
  uint64_t v258;
  unint64_t v259;
  char *v260;
  double *v261;
  uint64_t v262;
  unint64_t v263;
  double *v264;
  double v265;
  double *v266;
  double *v267;
  uint64_t v268;
  unint64_t v269;
  uint64_t v270;
  unint64_t v271;
  char *v272;
  double *v273;
  uint64_t v274;
  unint64_t v275;
  double *v276;
  double v277;
  double *v278;
  double *v279;
  uint64_t v280;
  unint64_t v281;
  uint64_t v282;
  unint64_t v283;
  char *v284;
  double *v285;
  uint64_t v286;
  double v287;
  double v288;
  double v289;
  double v290;
  double v291;
  unint64_t v292;
  double *v293;
  double *v294;
  double v295;
  double *v296;
  uint64_t v297;
  unint64_t v298;
  uint64_t v299;
  unint64_t v300;
  char *v301;
  double *v302;
  char *v303;
  uint64_t v304;
  double v305;
  unint64_t v306;
  double *v307;
  double *v308;
  double *v309;
  uint64_t v310;
  unint64_t v311;
  uint64_t v312;
  unint64_t v313;
  char *v314;
  double *v315;
  char *v316;
  uint64_t v317;
  double v318;
  unint64_t v319;
  double *v320;
  double *v321;
  double *v322;
  uint64_t v323;
  unint64_t v324;
  uint64_t v325;
  unint64_t v326;
  char *v327;
  double *v328;
  char *v329;
  uint64_t v330;
  unint64_t v331;
  double *v332;
  double v333;
  double *v334;
  double *v335;
  uint64_t v336;
  unint64_t v337;
  uint64_t v338;
  unint64_t v339;
  char *v340;
  double *v341;
  uint64_t v342;
  unint64_t v343;
  double *v344;
  double v345;
  double *v346;
  double *v347;
  uint64_t v348;
  unint64_t v349;
  uint64_t v350;
  unint64_t v351;
  char *v352;
  double *v353;
  uint64_t v354;
  unint64_t v355;
  double *v356;
  double v357;
  double *v358;
  double *v359;
  uint64_t v360;
  unint64_t v361;
  uint64_t v362;
  unint64_t v363;
  char *v364;
  double *v365;
  uint64_t v366;
  _QWORD *v367;
  _QWORD *v368;
  unint64_t v369;
  _QWORD *v370;
  uint64_t v371;
  unint64_t v372;
  uint64_t v373;
  unint64_t v374;
  char *v375;
  _QWORD *v376;
  char *v377;
  char *v378;
  uint64_t v379;
  _QWORD *v380;
  _QWORD *v381;
  unint64_t v382;
  _QWORD *v383;
  uint64_t v384;
  unint64_t v385;
  uint64_t v386;
  unint64_t v387;
  char *v388;
  _QWORD *v389;
  char *v390;
  char *v391;
  uint64_t v392;
  unint64_t v393;
  char *v394;
  _QWORD *v395;
  char *v396;
  uint64_t v397;
  unint64_t v398;
  uint64_t v399;
  unint64_t v400;
  char *v401;
  char *v402;
  char *v403;
  uint64_t v404;
  double *v405;
  uint64_t v406;
  unint64_t v407;
  double *v408;
  double v409;
  double v410;
  BOOL v411;
  OZShape *v413;
  double v414;
  double v415;
  double v416;
  double v417;
  double v418;
  double v419;
  double *v420;
  double *v421;
  double v422;
  double v423;
  double v424;
  double v425;
  double v426;
  double v427;
  double v428;
  double v429;
  __int128 v430;
  __int128 v431;
  __int128 v432;
  __int128 v433;
  __int128 v434;
  __int128 v435;
  __int128 v436;
  __int128 v437;

  v14 = *(double *)(a3 + 200) * 0.5;
  v15 = *(double *)(a3 + 208) * 0.5;
  v16 = *((_OWORD *)a5 + 5);
  v434 = *((_OWORD *)a5 + 4);
  v435 = v16;
  v17 = *((_OWORD *)a5 + 7);
  v436 = *((_OWORD *)a5 + 6);
  v437 = v17;
  v18 = *((_OWORD *)a5 + 1);
  v430 = *(_OWORD *)a5;
  v431 = v18;
  v19 = *((_OWORD *)a5 + 3);
  v432 = *((_OWORD *)a5 + 2);
  v433 = v19;
  PCMatrix44Tmpl<double>::invert((double *)&v430, (double *)&v430, 0.0);
  v20 = a5[12];
  v21 = a5[13];
  v22 = -(v14 * v20);
  v23 = a5[15];
  v24 = v23 + v15 * v21 - v14 * v20;
  v25 = a5[1];
  v26 = a5[3];
  v27 = a5[4];
  v28 = (v26 + v15 * v25 - v14 * *a5) / v24;
  v29 = v15 * a5[5];
  v30 = a5[7];
  v31 = (v30 + v29 - v14 * v27) / v24;
  v32 = v14 * v20;
  v33 = v23 + v32 + v15 * v21;
  v34 = v14 * *a5;
  v35 = (v26 + v34 + v15 * v25) / v33;
  v36 = (v30 + v14 * v27 + v29) / v33;
  v37 = -(v15 * v21);
  v38 = v23 + v32 + v37;
  v39 = -(v15 * v25);
  v40 = (v26 + v34 - v15 * v25) / v38;
  v41 = (v30 + v14 * v27 - v29) / v38;
  v42 = v23 + v22 + v37;
  v43 = (v26 + v39 - v34) / v42;
  v44 = (v30 + -(v14 * v27) - v29) / v42;
  v45 = v35 - v28;
  v46 = v36 - v31;
  v47 = sqrt(v45 * v45 + v46 * v46);
  v418 = v36;
  v419 = v35;
  v428 = v40 - v35;
  v429 = v41 - v36;
  v48 = sqrt(v428 * v428 + v429 * v429);
  v416 = v41;
  v417 = v40;
  v425 = v43 - v40;
  v426 = v44 - v41;
  v414 = v44;
  v415 = v43;
  v422 = v28 - v43;
  v423 = v31 - v44;
  v427 = sqrt(v425 * v425 + v426 * v426);
  v424 = sqrt(v422 * v422 + v423 * v423);
  v49 = *(_QWORD *)(a4 + 232);
  *(double *)(a4 + 392) = v424 + v427 + v47 + v48;
  v50 = (void **)(a4 + 216);
  v51 = *(double **)(a4 + 224);
  v413 = a1;
  if ((unint64_t)v51 >= v49)
  {
    v53 = (double *)*v50;
    v54 = ((char *)v51 - (_BYTE *)*v50) >> 3;
    v55 = v54 + 1;
    if ((unint64_t)(v54 + 1) >> 61)
      goto LABEL_469;
    v56 = v49 - (_QWORD)v53;
    if (v56 >> 2 > v55)
      v55 = v56 >> 2;
    if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8)
      v57 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v57 = v55;
    if (v57)
    {
      v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v57);
      v53 = *(double **)(a4 + 216);
      v51 = *(double **)(a4 + 224);
    }
    else
    {
      v58 = 0;
    }
    v59 = (double *)&v58[8 * v54];
    v60 = &v58[8 * v57];
    *v59 = v28;
    v52 = v59 + 1;
    while (v51 != v53)
    {
      v61 = *((_QWORD *)v51-- - 1);
      *((_QWORD *)v59-- - 1) = v61;
    }
    *(_QWORD *)(a4 + 216) = v59;
    *(_QWORD *)(a4 + 224) = v52;
    *(_QWORD *)(a4 + 232) = v60;
    if (v53)
      operator delete(v53);
  }
  else
  {
    *v51 = v28;
    v52 = v51 + 1;
  }
  *(_QWORD *)(a4 + 224) = v52;
  v62 = (void **)(a4 + 240);
  v64 = *(double **)(a4 + 248);
  v63 = *(_QWORD *)(a4 + 256);
  v420 = a5;
  v421 = a6;
  if ((unint64_t)v64 >= v63)
  {
    v66 = (double *)*v62;
    v67 = ((char *)v64 - (_BYTE *)*v62) >> 3;
    v68 = v67 + 1;
    if ((unint64_t)(v67 + 1) >> 61)
      goto LABEL_470;
    v69 = v63 - (_QWORD)v66;
    if (v69 >> 2 > v68)
      v68 = v69 >> 2;
    if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
      v70 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v70 = v68;
    if (v70)
    {
      v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v70);
      v66 = *(double **)(a4 + 240);
      v64 = *(double **)(a4 + 248);
    }
    else
    {
      v71 = 0;
    }
    v72 = (double *)&v71[8 * v67];
    v73 = &v71[8 * v70];
    *v72 = v31;
    v65 = v72 + 1;
    while (v64 != v66)
    {
      v74 = *((_QWORD *)v64-- - 1);
      *((_QWORD *)v72-- - 1) = v74;
    }
    *(_QWORD *)(a4 + 240) = v72;
    *(_QWORD *)(a4 + 248) = v65;
    *(_QWORD *)(a4 + 256) = v73;
    if (v66)
      operator delete(v66);
  }
  else
  {
    *v64 = v31;
    v65 = v64 + 1;
  }
  v75 = *(_QWORD *)(a4 + 208);
  *(_QWORD *)(a4 + 248) = v65;
  v76 = (void **)(a4 + 192);
  v77 = *(char **)(a4 + 200);
  if ((unint64_t)v77 >= v75)
  {
    v79 = (char *)*v76;
    v80 = (v77 - (_BYTE *)*v76) >> 3;
    v81 = v80 + 1;
    if ((unint64_t)(v80 + 1) >> 61)
      goto LABEL_471;
    v82 = v75 - (_QWORD)v79;
    if (v82 >> 2 > v81)
      v81 = v82 >> 2;
    if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8)
      v83 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v83 = v81;
    if (v83)
    {
      v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v83);
      v79 = *(char **)(a4 + 192);
      v77 = *(char **)(a4 + 200);
    }
    else
    {
      v84 = 0;
    }
    v85 = &v84[8 * v80];
    v86 = &v84[8 * v83];
    *(_QWORD *)v85 = 0;
    v78 = v85 + 8;
    while (v77 != v79)
    {
      v87 = *((_QWORD *)v77 - 1);
      v77 -= 8;
      *((_QWORD *)v85 - 1) = v87;
      v85 -= 8;
    }
    *(_QWORD *)(a4 + 192) = v85;
    *(_QWORD *)(a4 + 200) = v78;
    *(_QWORD *)(a4 + 208) = v86;
    if (v79)
      operator delete(v79);
  }
  else
  {
    *(_QWORD *)v77 = 0;
    v78 = v77 + 8;
  }
  *(_QWORD *)(a4 + 200) = v78;
  v88 = a7 + 0.0;
  if (a7 + 0.0 <= v47)
  {
    v89 = v45 / v47 * a7;
    v90 = v46 / v47 * a7;
    do
    {
      v92 = *(double **)(a4 + 224);
      v91 = *(_QWORD *)(a4 + 232);
      v93 = v89 + *(v92 - 1);
      if ((unint64_t)v92 >= v91)
      {
        v95 = (double *)*v50;
        v96 = ((char *)v92 - (_BYTE *)*v50) >> 3;
        v97 = v96 + 1;
        if ((unint64_t)(v96 + 1) >> 61)
          goto LABEL_469;
        v98 = v91 - (_QWORD)v95;
        if (v98 >> 2 > v97)
          v97 = v98 >> 2;
        if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8)
          v99 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v99 = v97;
        if (v99)
        {
          v100 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v99);
          v95 = *(double **)(a4 + 216);
          v92 = *(double **)(a4 + 224);
        }
        else
        {
          v100 = 0;
        }
        v101 = (double *)&v100[8 * v96];
        *v101 = v93;
        v94 = v101 + 1;
        while (v92 != v95)
        {
          v102 = *((_QWORD *)v92-- - 1);
          *((_QWORD *)v101-- - 1) = v102;
        }
        *(_QWORD *)(a4 + 216) = v101;
        *(_QWORD *)(a4 + 224) = v94;
        *(_QWORD *)(a4 + 232) = &v100[8 * v99];
        if (v95)
          operator delete(v95);
      }
      else
      {
        *v92 = v93;
        v94 = v92 + 1;
      }
      *(_QWORD *)(a4 + 224) = v94;
      v104 = *(double **)(a4 + 248);
      v103 = *(_QWORD *)(a4 + 256);
      v105 = v90 + *(v104 - 1);
      if ((unint64_t)v104 >= v103)
      {
        v107 = (double *)*v62;
        v108 = ((char *)v104 - (_BYTE *)*v62) >> 3;
        v109 = v108 + 1;
        if ((unint64_t)(v108 + 1) >> 61)
          goto LABEL_470;
        v110 = v103 - (_QWORD)v107;
        if (v110 >> 2 > v109)
          v109 = v110 >> 2;
        if ((unint64_t)v110 >= 0x7FFFFFFFFFFFFFF8)
          v111 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v111 = v109;
        if (v111)
        {
          v112 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v111);
          v107 = *(double **)(a4 + 240);
          v104 = *(double **)(a4 + 248);
        }
        else
        {
          v112 = 0;
        }
        v113 = (double *)&v112[8 * v108];
        *v113 = v105;
        v106 = v113 + 1;
        while (v104 != v107)
        {
          v114 = *((_QWORD *)v104-- - 1);
          *((_QWORD *)v113-- - 1) = v114;
        }
        *(_QWORD *)(a4 + 240) = v113;
        *(_QWORD *)(a4 + 248) = v106;
        *(_QWORD *)(a4 + 256) = &v112[8 * v111];
        if (v107)
          operator delete(v107);
      }
      else
      {
        *v104 = v105;
        v106 = v104 + 1;
      }
      *(_QWORD *)(a4 + 248) = v106;
      v116 = *(double **)(a4 + 200);
      v115 = *(_QWORD *)(a4 + 208);
      v117 = 1.0 / v47 * a7 + *(v116 - 1);
      if ((unint64_t)v116 >= v115)
      {
        v119 = (double *)*v76;
        v120 = ((char *)v116 - (_BYTE *)*v76) >> 3;
        v121 = v120 + 1;
        if ((unint64_t)(v120 + 1) >> 61)
          goto LABEL_471;
        v122 = v115 - (_QWORD)v119;
        if (v122 >> 2 > v121)
          v121 = v122 >> 2;
        if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8)
          v123 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v123 = v121;
        if (v123)
        {
          v124 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v123);
          v119 = *(double **)(a4 + 192);
          v116 = *(double **)(a4 + 200);
        }
        else
        {
          v124 = 0;
        }
        v125 = (double *)&v124[8 * v120];
        *v125 = v117;
        v118 = v125 + 1;
        while (v116 != v119)
        {
          v126 = *((_QWORD *)v116-- - 1);
          *((_QWORD *)v125-- - 1) = v126;
        }
        *(_QWORD *)(a4 + 192) = v125;
        *(_QWORD *)(a4 + 200) = v118;
        *(_QWORD *)(a4 + 208) = &v124[8 * v123];
        if (v119)
          operator delete(v119);
      }
      else
      {
        *v116 = v117;
        v118 = v116 + 1;
      }
      *(_QWORD *)(a4 + 200) = v118;
      v88 = v88 + a7;
    }
    while (v88 <= v47);
  }
  v127 = v88 - v47;
  v128 = v428 / v48 * a7;
  v129 = v429 / v48 * a7;
  v130 = 1.0 / v48 * a7;
  if (v127 != 0.0 && v127 < v48)
  {
    v131 = v419 + v128 * v127 / v48;
    v133 = *(double **)(a4 + 224);
    v132 = *(_QWORD *)(a4 + 232);
    if ((unint64_t)v133 >= v132)
    {
      v136 = (double *)*v50;
      v137 = ((char *)v133 - (_BYTE *)*v50) >> 3;
      v138 = v137 + 1;
      if ((unint64_t)(v137 + 1) >> 61)
        goto LABEL_469;
      v139 = v132 - (_QWORD)v136;
      if (v139 >> 2 > v138)
        v138 = v139 >> 2;
      if ((unint64_t)v139 >= 0x7FFFFFFFFFFFFFF8)
        v140 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v140 = v138;
      if (v140)
      {
        v141 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v140);
        v136 = *(double **)(a4 + 216);
        v133 = *(double **)(a4 + 224);
      }
      else
      {
        v141 = 0;
      }
      v142 = (double *)&v141[8 * v137];
      v143 = &v141[8 * v140];
      *v142 = v131;
      v134 = v142 + 1;
      if (v133 == v136)
      {
        v135 = v418;
      }
      else
      {
        v135 = v418;
        do
        {
          v144 = *((_QWORD *)v133-- - 1);
          *((_QWORD *)v142-- - 1) = v144;
        }
        while (v133 != v136);
      }
      *(_QWORD *)(a4 + 216) = v142;
      *(_QWORD *)(a4 + 224) = v134;
      *(_QWORD *)(a4 + 232) = v143;
      if (v136)
        operator delete(v136);
    }
    else
    {
      *v133 = v131;
      v134 = v133 + 1;
      v135 = v418;
    }
    *(_QWORD *)(a4 + 224) = v134;
    v145 = v135 + v129 * v127 / v48;
    v147 = *(double **)(a4 + 248);
    v146 = *(_QWORD *)(a4 + 256);
    if ((unint64_t)v147 >= v146)
    {
      v149 = (double *)*v62;
      v150 = ((char *)v147 - (_BYTE *)*v62) >> 3;
      v151 = v150 + 1;
      if ((unint64_t)(v150 + 1) >> 61)
        goto LABEL_470;
      v152 = v146 - (_QWORD)v149;
      if (v152 >> 2 > v151)
        v151 = v152 >> 2;
      if ((unint64_t)v152 >= 0x7FFFFFFFFFFFFFF8)
        v153 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v153 = v151;
      if (v153)
      {
        v154 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v153);
        v149 = *(double **)(a4 + 240);
        v147 = *(double **)(a4 + 248);
      }
      else
      {
        v154 = 0;
      }
      v155 = (double *)&v154[8 * v150];
      v156 = &v154[8 * v153];
      *v155 = v145;
      v148 = v155 + 1;
      while (v147 != v149)
      {
        v157 = *((_QWORD *)v147-- - 1);
        *((_QWORD *)v155-- - 1) = v157;
      }
      *(_QWORD *)(a4 + 240) = v155;
      *(_QWORD *)(a4 + 248) = v148;
      *(_QWORD *)(a4 + 256) = v156;
      if (v149)
        operator delete(v149);
    }
    else
    {
      *v147 = v145;
      v148 = v147 + 1;
    }
    *(_QWORD *)(a4 + 248) = v148;
    v158 = v130 * v127 / v48 + 1.0;
    v160 = *(double **)(a4 + 200);
    v159 = *(_QWORD *)(a4 + 208);
    if ((unint64_t)v160 >= v159)
    {
      v162 = (double *)*v76;
      v163 = ((char *)v160 - (_BYTE *)*v76) >> 3;
      v164 = v163 + 1;
      if ((unint64_t)(v163 + 1) >> 61)
        goto LABEL_471;
      v165 = v159 - (_QWORD)v162;
      if (v165 >> 2 > v164)
        v164 = v165 >> 2;
      if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8)
        v166 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v166 = v164;
      if (v166)
      {
        v167 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v166);
        v162 = *(double **)(a4 + 192);
        v160 = *(double **)(a4 + 200);
      }
      else
      {
        v167 = 0;
      }
      v168 = (double *)&v167[8 * v163];
      v169 = &v167[8 * v166];
      *v168 = v158;
      v161 = v168 + 1;
      while (v160 != v162)
      {
        v170 = *((_QWORD *)v160-- - 1);
        *((_QWORD *)v168-- - 1) = v170;
      }
      *(_QWORD *)(a4 + 192) = v168;
      *(_QWORD *)(a4 + 200) = v161;
      *(_QWORD *)(a4 + 208) = v169;
      if (v162)
        operator delete(v162);
    }
    else
    {
      *v160 = v158;
      v161 = v160 + 1;
    }
    *(_QWORD *)(a4 + 200) = v161;
    v127 = v127 + a7;
  }
  for (; v127 <= v48; v127 = v127 + a7)
  {
    v172 = *(double **)(a4 + 224);
    v171 = *(_QWORD *)(a4 + 232);
    v173 = v128 + *(v172 - 1);
    if ((unint64_t)v172 >= v171)
    {
      v175 = (double *)*v50;
      v176 = ((char *)v172 - (_BYTE *)*v50) >> 3;
      v177 = v176 + 1;
      if ((unint64_t)(v176 + 1) >> 61)
        goto LABEL_469;
      v178 = v171 - (_QWORD)v175;
      if (v178 >> 2 > v177)
        v177 = v178 >> 2;
      if ((unint64_t)v178 >= 0x7FFFFFFFFFFFFFF8)
        v179 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v179 = v177;
      if (v179)
      {
        v180 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v179);
        v175 = *(double **)(a4 + 216);
        v172 = *(double **)(a4 + 224);
      }
      else
      {
        v180 = 0;
      }
      v181 = (double *)&v180[8 * v176];
      *v181 = v173;
      v174 = v181 + 1;
      while (v172 != v175)
      {
        v182 = *((_QWORD *)v172-- - 1);
        *((_QWORD *)v181-- - 1) = v182;
      }
      *(_QWORD *)(a4 + 216) = v181;
      *(_QWORD *)(a4 + 224) = v174;
      *(_QWORD *)(a4 + 232) = &v180[8 * v179];
      if (v175)
        operator delete(v175);
    }
    else
    {
      *v172 = v173;
      v174 = v172 + 1;
    }
    *(_QWORD *)(a4 + 224) = v174;
    v184 = *(double **)(a4 + 248);
    v183 = *(_QWORD *)(a4 + 256);
    v185 = v129 + *(v184 - 1);
    if ((unint64_t)v184 >= v183)
    {
      v187 = (double *)*v62;
      v188 = ((char *)v184 - (_BYTE *)*v62) >> 3;
      v189 = v188 + 1;
      if ((unint64_t)(v188 + 1) >> 61)
        goto LABEL_470;
      v190 = v183 - (_QWORD)v187;
      if (v190 >> 2 > v189)
        v189 = v190 >> 2;
      if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8)
        v191 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v191 = v189;
      if (v191)
      {
        v192 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v191);
        v187 = *(double **)(a4 + 240);
        v184 = *(double **)(a4 + 248);
      }
      else
      {
        v192 = 0;
      }
      v193 = (double *)&v192[8 * v188];
      *v193 = v185;
      v186 = v193 + 1;
      while (v184 != v187)
      {
        v194 = *((_QWORD *)v184-- - 1);
        *((_QWORD *)v193-- - 1) = v194;
      }
      *(_QWORD *)(a4 + 240) = v193;
      *(_QWORD *)(a4 + 248) = v186;
      *(_QWORD *)(a4 + 256) = &v192[8 * v191];
      if (v187)
        operator delete(v187);
    }
    else
    {
      *v184 = v185;
      v186 = v184 + 1;
    }
    *(_QWORD *)(a4 + 248) = v186;
    v196 = *(double **)(a4 + 200);
    v195 = *(_QWORD *)(a4 + 208);
    v197 = v130 + *(v196 - 1);
    if ((unint64_t)v196 >= v195)
    {
      v199 = (double *)*v76;
      v200 = ((char *)v196 - (_BYTE *)*v76) >> 3;
      v201 = v200 + 1;
      if ((unint64_t)(v200 + 1) >> 61)
        goto LABEL_471;
      v202 = v195 - (_QWORD)v199;
      if (v202 >> 2 > v201)
        v201 = v202 >> 2;
      if ((unint64_t)v202 >= 0x7FFFFFFFFFFFFFF8)
        v203 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v203 = v201;
      if (v203)
      {
        v204 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v203);
        v199 = *(double **)(a4 + 192);
        v196 = *(double **)(a4 + 200);
      }
      else
      {
        v204 = 0;
      }
      v205 = (double *)&v204[8 * v200];
      *v205 = v197;
      v198 = v205 + 1;
      while (v196 != v199)
      {
        v206 = *((_QWORD *)v196-- - 1);
        *((_QWORD *)v205-- - 1) = v206;
      }
      *(_QWORD *)(a4 + 192) = v205;
      *(_QWORD *)(a4 + 200) = v198;
      *(_QWORD *)(a4 + 208) = &v204[8 * v203];
      if (v199)
        operator delete(v199);
    }
    else
    {
      *v196 = v197;
      v198 = v196 + 1;
    }
    *(_QWORD *)(a4 + 200) = v198;
  }
  v207 = v127 - v48;
  v208 = v425 / v427 * a7;
  v209 = v426 / v427 * a7;
  v210 = 1.0 / v427 * a7;
  if (v207 != 0.0 && v207 < v427)
  {
    v211 = v417 + v208 * v207 / v427;
    v213 = *(double **)(a4 + 224);
    v212 = *(_QWORD *)(a4 + 232);
    if ((unint64_t)v213 >= v212)
    {
      v216 = (double *)*v50;
      v217 = ((char *)v213 - (_BYTE *)*v50) >> 3;
      v218 = v217 + 1;
      if ((unint64_t)(v217 + 1) >> 61)
        goto LABEL_469;
      v219 = v212 - (_QWORD)v216;
      if (v219 >> 2 > v218)
        v218 = v219 >> 2;
      if ((unint64_t)v219 >= 0x7FFFFFFFFFFFFFF8)
        v220 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v220 = v218;
      if (v220)
      {
        v221 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v220);
        v216 = *(double **)(a4 + 216);
        v213 = *(double **)(a4 + 224);
      }
      else
      {
        v221 = 0;
      }
      v222 = (double *)&v221[8 * v217];
      v223 = &v221[8 * v220];
      *v222 = v211;
      v214 = v222 + 1;
      if (v213 == v216)
      {
        v215 = v416;
      }
      else
      {
        v215 = v416;
        do
        {
          v224 = *((_QWORD *)v213-- - 1);
          *((_QWORD *)v222-- - 1) = v224;
        }
        while (v213 != v216);
      }
      *(_QWORD *)(a4 + 216) = v222;
      *(_QWORD *)(a4 + 224) = v214;
      *(_QWORD *)(a4 + 232) = v223;
      if (v216)
        operator delete(v216);
    }
    else
    {
      *v213 = v211;
      v214 = v213 + 1;
      v215 = v416;
    }
    *(_QWORD *)(a4 + 224) = v214;
    v225 = v215 + v209 * v207 / v427;
    v227 = *(double **)(a4 + 248);
    v226 = *(_QWORD *)(a4 + 256);
    if ((unint64_t)v227 >= v226)
    {
      v229 = (double *)*v62;
      v230 = ((char *)v227 - (_BYTE *)*v62) >> 3;
      v231 = v230 + 1;
      if ((unint64_t)(v230 + 1) >> 61)
        goto LABEL_470;
      v232 = v226 - (_QWORD)v229;
      if (v232 >> 2 > v231)
        v231 = v232 >> 2;
      if ((unint64_t)v232 >= 0x7FFFFFFFFFFFFFF8)
        v233 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v233 = v231;
      if (v233)
      {
        v234 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v233);
        v229 = *(double **)(a4 + 240);
        v227 = *(double **)(a4 + 248);
      }
      else
      {
        v234 = 0;
      }
      v235 = (double *)&v234[8 * v230];
      v236 = &v234[8 * v233];
      *v235 = v225;
      v228 = v235 + 1;
      while (v227 != v229)
      {
        v237 = *((_QWORD *)v227-- - 1);
        *((_QWORD *)v235-- - 1) = v237;
      }
      *(_QWORD *)(a4 + 240) = v235;
      *(_QWORD *)(a4 + 248) = v228;
      *(_QWORD *)(a4 + 256) = v236;
      if (v229)
        operator delete(v229);
    }
    else
    {
      *v227 = v225;
      v228 = v227 + 1;
    }
    *(_QWORD *)(a4 + 248) = v228;
    v238 = v210 * v207 / v427 + 2.0;
    v240 = *(double **)(a4 + 200);
    v239 = *(_QWORD *)(a4 + 208);
    if ((unint64_t)v240 >= v239)
    {
      v242 = (double *)*v76;
      v243 = ((char *)v240 - (_BYTE *)*v76) >> 3;
      v244 = v243 + 1;
      if ((unint64_t)(v243 + 1) >> 61)
        goto LABEL_471;
      v245 = v239 - (_QWORD)v242;
      if (v245 >> 2 > v244)
        v244 = v245 >> 2;
      if ((unint64_t)v245 >= 0x7FFFFFFFFFFFFFF8)
        v246 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v246 = v244;
      if (v246)
      {
        v247 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v246);
        v242 = *(double **)(a4 + 192);
        v240 = *(double **)(a4 + 200);
      }
      else
      {
        v247 = 0;
      }
      v248 = (double *)&v247[8 * v243];
      v249 = &v247[8 * v246];
      *v248 = v238;
      v241 = v248 + 1;
      while (v240 != v242)
      {
        v250 = *((_QWORD *)v240-- - 1);
        *((_QWORD *)v248-- - 1) = v250;
      }
      *(_QWORD *)(a4 + 192) = v248;
      *(_QWORD *)(a4 + 200) = v241;
      *(_QWORD *)(a4 + 208) = v249;
      if (v242)
        operator delete(v242);
    }
    else
    {
      *v240 = v238;
      v241 = v240 + 1;
    }
    *(_QWORD *)(a4 + 200) = v241;
    v207 = v207 + a7;
  }
  for (; v207 <= v427; v207 = v207 + a7)
  {
    v252 = *(double **)(a4 + 224);
    v251 = *(_QWORD *)(a4 + 232);
    v253 = v208 + *(v252 - 1);
    if ((unint64_t)v252 >= v251)
    {
      v255 = (double *)*v50;
      v256 = ((char *)v252 - (_BYTE *)*v50) >> 3;
      v257 = v256 + 1;
      if ((unint64_t)(v256 + 1) >> 61)
        goto LABEL_469;
      v258 = v251 - (_QWORD)v255;
      if (v258 >> 2 > v257)
        v257 = v258 >> 2;
      if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFF8)
        v259 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v259 = v257;
      if (v259)
      {
        v260 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v259);
        v255 = *(double **)(a4 + 216);
        v252 = *(double **)(a4 + 224);
      }
      else
      {
        v260 = 0;
      }
      v261 = (double *)&v260[8 * v256];
      *v261 = v253;
      v254 = v261 + 1;
      while (v252 != v255)
      {
        v262 = *((_QWORD *)v252-- - 1);
        *((_QWORD *)v261-- - 1) = v262;
      }
      *(_QWORD *)(a4 + 216) = v261;
      *(_QWORD *)(a4 + 224) = v254;
      *(_QWORD *)(a4 + 232) = &v260[8 * v259];
      if (v255)
        operator delete(v255);
    }
    else
    {
      *v252 = v253;
      v254 = v252 + 1;
    }
    *(_QWORD *)(a4 + 224) = v254;
    v264 = *(double **)(a4 + 248);
    v263 = *(_QWORD *)(a4 + 256);
    v265 = v209 + *(v264 - 1);
    if ((unint64_t)v264 >= v263)
    {
      v267 = (double *)*v62;
      v268 = ((char *)v264 - (_BYTE *)*v62) >> 3;
      v269 = v268 + 1;
      if ((unint64_t)(v268 + 1) >> 61)
        goto LABEL_470;
      v270 = v263 - (_QWORD)v267;
      if (v270 >> 2 > v269)
        v269 = v270 >> 2;
      if ((unint64_t)v270 >= 0x7FFFFFFFFFFFFFF8)
        v271 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v271 = v269;
      if (v271)
      {
        v272 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v271);
        v267 = *(double **)(a4 + 240);
        v264 = *(double **)(a4 + 248);
      }
      else
      {
        v272 = 0;
      }
      v273 = (double *)&v272[8 * v268];
      *v273 = v265;
      v266 = v273 + 1;
      while (v264 != v267)
      {
        v274 = *((_QWORD *)v264-- - 1);
        *((_QWORD *)v273-- - 1) = v274;
      }
      *(_QWORD *)(a4 + 240) = v273;
      *(_QWORD *)(a4 + 248) = v266;
      *(_QWORD *)(a4 + 256) = &v272[8 * v271];
      if (v267)
        operator delete(v267);
    }
    else
    {
      *v264 = v265;
      v266 = v264 + 1;
    }
    *(_QWORD *)(a4 + 248) = v266;
    v276 = *(double **)(a4 + 200);
    v275 = *(_QWORD *)(a4 + 208);
    v277 = v210 + *(v276 - 1);
    if ((unint64_t)v276 >= v275)
    {
      v279 = (double *)*v76;
      v280 = ((char *)v276 - (_BYTE *)*v76) >> 3;
      v281 = v280 + 1;
      if ((unint64_t)(v280 + 1) >> 61)
        goto LABEL_471;
      v282 = v275 - (_QWORD)v279;
      if (v282 >> 2 > v281)
        v281 = v282 >> 2;
      if ((unint64_t)v282 >= 0x7FFFFFFFFFFFFFF8)
        v283 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v283 = v281;
      if (v283)
      {
        v284 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v283);
        v279 = *(double **)(a4 + 192);
        v276 = *(double **)(a4 + 200);
      }
      else
      {
        v284 = 0;
      }
      v285 = (double *)&v284[8 * v280];
      *v285 = v277;
      v278 = v285 + 1;
      while (v276 != v279)
      {
        v286 = *((_QWORD *)v276-- - 1);
        *((_QWORD *)v285-- - 1) = v286;
      }
      *(_QWORD *)(a4 + 192) = v285;
      *(_QWORD *)(a4 + 200) = v278;
      *(_QWORD *)(a4 + 208) = &v284[8 * v283];
      if (v279)
        operator delete(v279);
    }
    else
    {
      *v276 = v277;
      v278 = v276 + 1;
    }
    *(_QWORD *)(a4 + 200) = v278;
  }
  v287 = v207 - v427;
  v288 = v422 / v424 * a7;
  v289 = v423 / v424 * a7;
  v290 = 1.0 / v424 * a7;
  if (v287 != 0.0 && v287 < v424)
  {
    v291 = v415 + v288 * v287 / v424;
    v293 = *(double **)(a4 + 224);
    v292 = *(_QWORD *)(a4 + 232);
    if ((unint64_t)v293 >= v292)
    {
      v296 = (double *)*v50;
      v297 = ((char *)v293 - (_BYTE *)*v50) >> 3;
      v298 = v297 + 1;
      if ((unint64_t)(v297 + 1) >> 61)
        goto LABEL_469;
      v299 = v292 - (_QWORD)v296;
      if (v299 >> 2 > v298)
        v298 = v299 >> 2;
      if ((unint64_t)v299 >= 0x7FFFFFFFFFFFFFF8)
        v300 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v300 = v298;
      if (v300)
      {
        v301 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v300);
        v296 = *(double **)(a4 + 216);
        v293 = *(double **)(a4 + 224);
      }
      else
      {
        v301 = 0;
      }
      v302 = (double *)&v301[8 * v297];
      v303 = &v301[8 * v300];
      *v302 = v291;
      v294 = v302 + 1;
      if (v293 == v296)
      {
        v295 = v414;
      }
      else
      {
        v295 = v414;
        do
        {
          v304 = *((_QWORD *)v293-- - 1);
          *((_QWORD *)v302-- - 1) = v304;
        }
        while (v293 != v296);
      }
      *(_QWORD *)(a4 + 216) = v302;
      *(_QWORD *)(a4 + 224) = v294;
      *(_QWORD *)(a4 + 232) = v303;
      if (v296)
        operator delete(v296);
    }
    else
    {
      *v293 = v291;
      v294 = v293 + 1;
      v295 = v414;
    }
    *(_QWORD *)(a4 + 224) = v294;
    v305 = v295 + v289 * v287 / v424;
    v307 = *(double **)(a4 + 248);
    v306 = *(_QWORD *)(a4 + 256);
    if ((unint64_t)v307 >= v306)
    {
      v309 = (double *)*v62;
      v310 = ((char *)v307 - (_BYTE *)*v62) >> 3;
      v311 = v310 + 1;
      if ((unint64_t)(v310 + 1) >> 61)
        goto LABEL_470;
      v312 = v306 - (_QWORD)v309;
      if (v312 >> 2 > v311)
        v311 = v312 >> 2;
      if ((unint64_t)v312 >= 0x7FFFFFFFFFFFFFF8)
        v313 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v313 = v311;
      if (v313)
      {
        v314 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v313);
        v309 = *(double **)(a4 + 240);
        v307 = *(double **)(a4 + 248);
      }
      else
      {
        v314 = 0;
      }
      v315 = (double *)&v314[8 * v310];
      v316 = &v314[8 * v313];
      *v315 = v305;
      v308 = v315 + 1;
      while (v307 != v309)
      {
        v317 = *((_QWORD *)v307-- - 1);
        *((_QWORD *)v315-- - 1) = v317;
      }
      *(_QWORD *)(a4 + 240) = v315;
      *(_QWORD *)(a4 + 248) = v308;
      *(_QWORD *)(a4 + 256) = v316;
      if (v309)
        operator delete(v309);
    }
    else
    {
      *v307 = v305;
      v308 = v307 + 1;
    }
    *(_QWORD *)(a4 + 248) = v308;
    v318 = v290 * v287 / v424 + 3.0;
    v320 = *(double **)(a4 + 200);
    v319 = *(_QWORD *)(a4 + 208);
    if ((unint64_t)v320 >= v319)
    {
      v322 = (double *)*v76;
      v323 = ((char *)v320 - (_BYTE *)*v76) >> 3;
      v324 = v323 + 1;
      if ((unint64_t)(v323 + 1) >> 61)
        goto LABEL_471;
      v325 = v319 - (_QWORD)v322;
      if (v325 >> 2 > v324)
        v324 = v325 >> 2;
      if ((unint64_t)v325 >= 0x7FFFFFFFFFFFFFF8)
        v326 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v326 = v324;
      if (v326)
      {
        v327 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v326);
        v322 = *(double **)(a4 + 192);
        v320 = *(double **)(a4 + 200);
      }
      else
      {
        v327 = 0;
      }
      v328 = (double *)&v327[8 * v323];
      v329 = &v327[8 * v326];
      *v328 = v318;
      v321 = v328 + 1;
      while (v320 != v322)
      {
        v330 = *((_QWORD *)v320-- - 1);
        *((_QWORD *)v328-- - 1) = v330;
      }
      *(_QWORD *)(a4 + 192) = v328;
      *(_QWORD *)(a4 + 200) = v321;
      *(_QWORD *)(a4 + 208) = v329;
      if (v322)
        operator delete(v322);
    }
    else
    {
      *v320 = v318;
      v321 = v320 + 1;
    }
    *(_QWORD *)(a4 + 200) = v321;
    v287 = v287 + a7;
  }
  for (; v287 <= v424; v287 = v287 + a7)
  {
    v332 = *(double **)(a4 + 224);
    v331 = *(_QWORD *)(a4 + 232);
    v333 = v288 + *(v332 - 1);
    if ((unint64_t)v332 >= v331)
    {
      v335 = (double *)*v50;
      v336 = ((char *)v332 - (_BYTE *)*v50) >> 3;
      v337 = v336 + 1;
      if ((unint64_t)(v336 + 1) >> 61)
        goto LABEL_469;
      v338 = v331 - (_QWORD)v335;
      if (v338 >> 2 > v337)
        v337 = v338 >> 2;
      if ((unint64_t)v338 >= 0x7FFFFFFFFFFFFFF8)
        v339 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v339 = v337;
      if (v339)
      {
        v340 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v339);
        v335 = *(double **)(a4 + 216);
        v332 = *(double **)(a4 + 224);
      }
      else
      {
        v340 = 0;
      }
      v341 = (double *)&v340[8 * v336];
      *v341 = v333;
      v334 = v341 + 1;
      while (v332 != v335)
      {
        v342 = *((_QWORD *)v332-- - 1);
        *((_QWORD *)v341-- - 1) = v342;
      }
      *(_QWORD *)(a4 + 216) = v341;
      *(_QWORD *)(a4 + 224) = v334;
      *(_QWORD *)(a4 + 232) = &v340[8 * v339];
      if (v335)
        operator delete(v335);
    }
    else
    {
      *v332 = v333;
      v334 = v332 + 1;
    }
    *(_QWORD *)(a4 + 224) = v334;
    v344 = *(double **)(a4 + 248);
    v343 = *(_QWORD *)(a4 + 256);
    v345 = v289 + *(v344 - 1);
    if ((unint64_t)v344 >= v343)
    {
      v347 = (double *)*v62;
      v348 = ((char *)v344 - (_BYTE *)*v62) >> 3;
      v349 = v348 + 1;
      if ((unint64_t)(v348 + 1) >> 61)
        goto LABEL_470;
      v350 = v343 - (_QWORD)v347;
      if (v350 >> 2 > v349)
        v349 = v350 >> 2;
      if ((unint64_t)v350 >= 0x7FFFFFFFFFFFFFF8)
        v351 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v351 = v349;
      if (v351)
      {
        v352 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v351);
        v347 = *(double **)(a4 + 240);
        v344 = *(double **)(a4 + 248);
      }
      else
      {
        v352 = 0;
      }
      v353 = (double *)&v352[8 * v348];
      *v353 = v345;
      v346 = v353 + 1;
      while (v344 != v347)
      {
        v354 = *((_QWORD *)v344-- - 1);
        *((_QWORD *)v353-- - 1) = v354;
      }
      *(_QWORD *)(a4 + 240) = v353;
      *(_QWORD *)(a4 + 248) = v346;
      *(_QWORD *)(a4 + 256) = &v352[8 * v351];
      if (v347)
        operator delete(v347);
    }
    else
    {
      *v344 = v345;
      v346 = v344 + 1;
    }
    *(_QWORD *)(a4 + 248) = v346;
    v356 = *(double **)(a4 + 200);
    v355 = *(_QWORD *)(a4 + 208);
    v357 = v290 + *(v356 - 1);
    if ((unint64_t)v356 >= v355)
    {
      v359 = (double *)*v76;
      v360 = ((char *)v356 - (_BYTE *)*v76) >> 3;
      v361 = v360 + 1;
      if ((unint64_t)(v360 + 1) >> 61)
        goto LABEL_471;
      v362 = v355 - (_QWORD)v359;
      if (v362 >> 2 > v361)
        v361 = v362 >> 2;
      if ((unint64_t)v362 >= 0x7FFFFFFFFFFFFFF8)
        v363 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v363 = v361;
      if (v363)
      {
        v364 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v363);
        v359 = *(double **)(a4 + 192);
        v356 = *(double **)(a4 + 200);
      }
      else
      {
        v364 = 0;
      }
      v365 = (double *)&v364[8 * v360];
      *v365 = v357;
      v358 = v365 + 1;
      while (v356 != v359)
      {
        v366 = *((_QWORD *)v356-- - 1);
        *((_QWORD *)v365-- - 1) = v366;
      }
      *(_QWORD *)(a4 + 192) = v365;
      *(_QWORD *)(a4 + 200) = v358;
      *(_QWORD *)(a4 + 208) = &v364[8 * v363];
      if (v359)
        operator delete(v359);
    }
    else
    {
      *v356 = v357;
      v358 = v356 + 1;
    }
    *(_QWORD *)(a4 + 200) = v358;
  }
  if (vabdd_f64(v287, v424) >= 0.0000001)
  {
    v368 = *(_QWORD **)(a4 + 216);
    v367 = *(_QWORD **)(a4 + 224);
    v369 = *(_QWORD *)(a4 + 232);
    if ((unint64_t)v367 < v369)
    {
      *v367 = *v368;
      v370 = v367 + 1;
LABEL_426:
      *(_QWORD *)(a4 + 224) = v370;
      v381 = *(_QWORD **)(a4 + 240);
      v380 = *(_QWORD **)(a4 + 248);
      v382 = *(_QWORD *)(a4 + 256);
      if ((unint64_t)v380 < v382)
      {
        *v380 = *v381;
        v383 = v380 + 1;
LABEL_442:
        *(_QWORD *)(a4 + 248) = v383;
        v394 = *(char **)(a4 + 200);
        v393 = *(_QWORD *)(a4 + 208);
        if ((unint64_t)v394 < v393)
        {
          *(_QWORD *)v394 = 0x4010000000000000;
          v395 = v394 + 8;
LABEL_458:
          *(_QWORD *)(a4 + 200) = v395;
          goto LABEL_459;
        }
        v396 = (char *)*v76;
        v397 = (v394 - (_BYTE *)*v76) >> 3;
        v398 = v397 + 1;
        if (!((unint64_t)(v397 + 1) >> 61))
        {
          v399 = v393 - (_QWORD)v396;
          if (v399 >> 2 > v398)
            v398 = v399 >> 2;
          if ((unint64_t)v399 >= 0x7FFFFFFFFFFFFFF8)
            v400 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v400 = v398;
          if (v400)
          {
            v401 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 208, v400);
            v396 = *(char **)(a4 + 192);
            v394 = *(char **)(a4 + 200);
          }
          else
          {
            v401 = 0;
          }
          v402 = &v401[8 * v397];
          v403 = &v401[8 * v400];
          *(_QWORD *)v402 = 0x4010000000000000;
          v395 = v402 + 8;
          while (v394 != v396)
          {
            v404 = *((_QWORD *)v394 - 1);
            v394 -= 8;
            *((_QWORD *)v402 - 1) = v404;
            v402 -= 8;
          }
          *(_QWORD *)(a4 + 192) = v402;
          *(_QWORD *)(a4 + 200) = v395;
          *(_QWORD *)(a4 + 208) = v403;
          if (v396)
            operator delete(v396);
          goto LABEL_458;
        }
LABEL_471:
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      v384 = v380 - v381;
      v385 = v384 + 1;
      if (!((unint64_t)(v384 + 1) >> 61))
      {
        v386 = v382 - (_QWORD)v381;
        if (v386 >> 2 > v385)
          v385 = v386 >> 2;
        if ((unint64_t)v386 >= 0x7FFFFFFFFFFFFFF8)
          v387 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v387 = v385;
        if (v387)
        {
          v388 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 256, v387);
          v389 = *(_QWORD **)(a4 + 240);
          v380 = *(_QWORD **)(a4 + 248);
        }
        else
        {
          v388 = 0;
          v389 = *(_QWORD **)(a4 + 240);
        }
        v390 = &v388[8 * v384];
        v391 = &v388[8 * v387];
        *(_QWORD *)v390 = *v381;
        v383 = v390 + 8;
        while (v380 != v389)
        {
          v392 = *--v380;
          *((_QWORD *)v390 - 1) = v392;
          v390 -= 8;
        }
        *(_QWORD *)(a4 + 240) = v390;
        *(_QWORD *)(a4 + 248) = v383;
        *(_QWORD *)(a4 + 256) = v391;
        if (v389)
          operator delete(v389);
        goto LABEL_442;
      }
LABEL_470:
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    v371 = v367 - v368;
    v372 = v371 + 1;
    if (!((unint64_t)(v371 + 1) >> 61))
    {
      v373 = v369 - (_QWORD)v368;
      if (v373 >> 2 > v372)
        v372 = v373 >> 2;
      if ((unint64_t)v373 >= 0x7FFFFFFFFFFFFFF8)
        v374 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v374 = v372;
      if (v374)
      {
        v375 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a4 + 232, v374);
        v376 = *(_QWORD **)(a4 + 216);
        v367 = *(_QWORD **)(a4 + 224);
      }
      else
      {
        v375 = 0;
        v376 = *(_QWORD **)(a4 + 216);
      }
      v377 = &v375[8 * v371];
      v378 = &v375[8 * v374];
      *(_QWORD *)v377 = *v368;
      v370 = v377 + 8;
      while (v367 != v376)
      {
        v379 = *--v367;
        *((_QWORD *)v377 - 1) = v379;
        v377 -= 8;
      }
      *(_QWORD *)(a4 + 216) = v377;
      *(_QWORD *)(a4 + 224) = v370;
      *(_QWORD *)(a4 + 232) = v378;
      if (v376)
        operator delete(v376);
      goto LABEL_426;
    }
LABEL_469:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_459:
  if (!PCMatrix44Tmpl<double>::isIdentity(v420))
  {
    v405 = *(double **)(a4 + 216);
    v406 = *(_QWORD *)(a4 + 224) - (_QWORD)v405;
    if (v406)
    {
      v407 = v406 >> 3;
      v408 = (double *)*v62;
      if (v407 <= 1)
        v407 = 1;
      do
      {
        v409 = *((double *)&v437 + 1) + *v405 * *(double *)&v436 + *v408 * *((double *)&v436 + 1);
        v410 = (*((double *)&v433 + 1) + *v405 * *(double *)&v432 + *v408 * *((double *)&v432 + 1)) / v409;
        *v405 = (*((double *)&v431 + 1) + *v405 * *(double *)&v430 + *v408 * *((double *)&v430 + 1)) / v409;
        ++v405;
        *v408++ = v410;
        --v407;
      }
      while (v407);
    }
  }
  v411 = 1;
  *(_WORD *)(a4 + 185) = 1;
  if (v421)
    v411 = PCMatrix44Tmpl<double>::isIdentity(v421) || !OZShape::checkWindingOrder(v413, a2, a3, v421, 0);
  *(_BYTE *)(a4 + 187) = v411;
  return a4;
}

uint64_t OZShape::isRect(uint64_t a1, CMTime *a2)
{
  _QWORD *v2;
  OZChannelCurve *v4;
  char *v5;
  unint64_t v6;
  unsigned int v7;
  double v8;
  double v9;
  uint64_t v10;
  double v12;
  char *v13;
  char *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  double v18[3];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD **)(a1 + 472);
  if (!v2)
    return 0;
  if (((v2[1] - *v2) & 0x7FFFFFFF0) != 0x40)
    return 0;
  v4 = (OZChannelCurve *)(a1 + 208);
  if (!OZChannelCurve::isCurveFlattened((OZChannelCurve *)(a1 + 208)))
    return 0;
  v17 = 0u;
  *(_OWORD *)v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  OZChannelCurve::getVerticesList(v4, &v13);
  v5 = v14;
  if (v14 == v13)
  {
    v8 = 0.0;
    v9 = 0.0;
  }
  else
  {
    v6 = 0;
    v7 = 1;
    v5 = v13;
    do
    {
      OZChannelCurve::getVertexValue((uint64_t)v4, *(char **)&v5[16 * v6], *(char **)&v5[16 * v6 + 8], a2, &v18[v6 - 2], (double *)&v15 + v6);
      v6 = v7;
      v5 = v13;
      ++v7;
    }
    while (v6 < (v14 - v13) >> 4);
    v8 = *((double *)&v17 + 1);
    v9 = *(double *)&v17;
  }
  if (vabdd_f64(v9, v8) >= 0.0000001)
  {
    if (vabdd_f64(v9, v18[1]) >= 0.0000001
      || vabdd_f64(v8, v18[0]) >= 0.0000001
      || vabdd_f64(*(double *)&v15, *((double *)&v15 + 1)) >= 0.0000001)
    {
      goto LABEL_21;
    }
    v12 = *(double *)&v16;
  }
  else
  {
    if (vabdd_f64(v18[0], v18[1]) >= 0.0000001 || vabdd_f64(*((double *)&v15 + 1), *(double *)&v16) >= 0.0000001)
      goto LABEL_21;
    v12 = *(double *)&v15;
  }
  if (vabdd_f64(v12, *((double *)&v16 + 1)) < 0.0000001)
  {
    v10 = 1;
    goto LABEL_22;
  }
LABEL_21:
  v10 = 0;
LABEL_22:
  if (v5)
  {
    v14 = v5;
    operator delete(v5);
  }
  return v10;
}

void sub_1B300BD00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t OZShape::getSamples(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  PCMutex *v8;
  __int128 v9;
  __int128 v10;
  CGColorSpace *v11;
  int *CurrentRenderParams;
  uint64_t Contour;
  uint64_t v14;
  _OWORD v16[5];
  CGColorSpace *v17;
  int v18;
  uint64_t v19;
  char v20;

  v8 = (PCMutex *)(a1 + 8);
  v19 = a1 + 8;
  PCMutex::lock((PCMutex *)(a1 + 8));
  v20 = 1;
  v9 = *(_OWORD *)(a2 + 48);
  v16[2] = *(_OWORD *)(a2 + 32);
  v16[3] = v9;
  v16[4] = *(_OWORD *)(a2 + 64);
  v10 = *(_OWORD *)(a2 + 16);
  v16[0] = *(_OWORD *)a2;
  v16[1] = v10;
  v11 = *(CGColorSpace **)(a2 + 80);
  v17 = v11;
  if (v11)
    PCCFRefTraits<CGColorSpace *>::retain(v11);
  v18 = *(_DWORD *)(a2 + 88);
  CurrentRenderParams = (int *)OZShape::getCurrentRenderParams(a1, (uint64_t)v16);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
  if (OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4
    || fabs((double)CurrentRenderParams[45]) < 0.0000001)
  {
    Contour = OZShape::getContour((OZShape *)a1, (const CMTime *)a2, (OZShapeRenderParams *)CurrentRenderParams);
  }
  else
  {
    Contour = OZShape::getRenderContourWithRoundness(a1, a2, (uint64_t)CurrentRenderParams, 0);
  }
  v14 = Contour;
  if ((char *)(Contour + 216) != a3)
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(a3, *(char **)(Contour + 216), *(_QWORD *)(Contour + 224), (uint64_t)(*(_QWORD *)(Contour + 224) - *(_QWORD *)(Contour + 216)) >> 3);
  if ((char *)(v14 + 240) != a4)
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(a4, *(char **)(v14 + 240), *(_QWORD *)(v14 + 248), (uint64_t)(*(_QWORD *)(v14 + 248) - *(_QWORD *)(v14 + 240)) >> 3);
  return PCMutex::unlock(v8);
}

void sub_1B300BE84(_Unwind_Exception *a1)
{
  CGColorSpace **v1;
  uint64_t v2;

  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  PCLockSentry<PCMutex>::~PCLockSentry(v2 - 80);
  _Unwind_Resume(a1);
}

void std::vector<OZVertex2D>::push_back[abi:ne180100](void **a1, _OWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _OWORD *v7;
  _OWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;

  v6 = (unint64_t)a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = ((char *)v7 - (_BYTE *)*a1) >> 4;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)*a1;
    if (v11 >> 3 > v10)
      v10 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v9];
    v15 = &v13[16 * v12];
    *(_OWORD *)v14 = *a2;
    v8 = v14 + 16;
    v17 = (char *)*a1;
    v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v7 = *a2;
    v8 = v7 + 1;
  }
  a1[1] = v8;
}

void OZShapeContour::OZShapeContour(OZShapeContour *this, CMTime *a2)
{
  __int128 v7;

  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 40) = _Q0;
  *((_QWORD *)this + 22) = 0x3FF0000000000000;
  *((_QWORD *)this + 17) = 0x3FF0000000000000;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  *((_QWORD *)this + 7) = 0x3FF0000000000000;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  v7 = *(_OWORD *)&a2->value;
  *((_QWORD *)this + 2) = a2->epoch;
  *(_OWORD *)this = v7;
  *((_QWORD *)this + 22) = 0x3FF0000000000000;
  *((_QWORD *)this + 17) = 0x3FF0000000000000;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  *((_QWORD *)this + 7) = 0x3FF0000000000000;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 46) = 0x1000000;
}

void OZShapeReparametrizedContour::OZShapeReparametrizedContour(OZShapeReparametrizedContour *this, CMTime *a2)
{
  uint64_t v3;
  OZChannelPosition *v4;
  OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *v5;
  OZChannelImpl *Instance;
  PCString v7;
  CMTime v8;

  v8 = *a2;
  OZShapeContour::OZShapeContour(this, &v8);
  *(_QWORD *)(v3 + 464) = 0;
  *(_OWORD *)(v3 + 432) = 0u;
  *(_OWORD *)(v3 + 448) = 0u;
  *(_OWORD *)(v3 + 400) = 0u;
  *(_OWORD *)(v3 + 416) = 0u;
  v4 = (OZChannelPosition *)operator new();
  v5 = (OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *)PCString::PCString(&v7, "");
  Instance = (OZChannelImpl *)OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::getInstance(v5);
  OZChannelPosition::OZChannelPosition(v4, &v7, 0, 1u, 0x823000Au, 2u, Instance, 0);
  *((_QWORD *)this + 48) = v4;
  PCString::~PCString(&v7);
  *((_QWORD *)this + 49) = 0;
}

void sub_1B300C0DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  void **v10;
  uint64_t v11;
  void *v13;
  void **v14;
  void *v15;
  void *v16;

  MEMORY[0x1B5E29170](v11, 0x10E1C4011F1C4E7);
  v13 = v10[56];
  if (v13)
  {
    v10[57] = v13;
    operator delete(v13);
  }
  v14 = v10 + 50;
  v15 = v10[53];
  if (v15)
  {
    v10[54] = v15;
    operator delete(v15);
  }
  v16 = *v14;
  if (*v14)
  {
    v10[51] = v16;
    operator delete(v16);
  }
  OZShapeContour::~OZShapeContour((OZShapeContour *)v10);
  _Unwind_Resume(a1);
}

OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::getInstance(OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *this)
{
  OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *v1;

  v1 = (OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *)OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::_OZShapeReparametrizedContour_contour;
  if (!OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::_OZShapeReparametrizedContour_contour)
  {
    v1 = (OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *)operator new();
    OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::OZShapeReparametrizedContour_contourImpl(v1);
    OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::_OZShapeReparametrizedContour_contour = (uint64_t)v1;
  }
  return v1;
}

void sub_1B300C1A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40941221CDLL);
  _Unwind_Resume(a1);
}

OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl::OZShapeReparametrizedContour_contourImpl(OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *this)
{
  OZCurveDouble *v2;

  v2 = (OZCurveDouble *)operator new();
  OZCurveDouble::OZCurveDouble(v2, 0.0);
  OZChannelImpl::OZChannelImpl((OZChannelImpl *)this, (OZCurve *)v2, 0.0, 1, 1);
  PCSingleton::PCSingleton((OZShapeReparametrizedContour::OZShapeReparametrizedContour_contourImpl *)((char *)this + 40), 50);
  *(_QWORD *)this = &unk_1E65EA7D8;
  *((_QWORD *)this + 5) = &unk_1E65EA7F8;
  OZChannelImpl::setDiscrete((OZChannelImpl *)this);
  OZChannelImpl::setParametric((OZChannelImpl *)this);
  return this;
}

void sub_1B300C26C(_Unwind_Exception *a1)
{
  OZChannelImpl *v1;

  OZChannelImpl::~OZChannelImpl(v1);
  _Unwind_Resume(a1);
}

_OWORD *std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>(_QWORD *a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  __int128 *v6;
  uint64_t v8;
  _OWORD *result;
  uint64_t v10;
  unint64_t v11;
  _OWORD **v12;
  _OWORD *v13;
  char *v14;
  __int128 v15;
  _OWORD *v16;
  _OWORD *v17;
  unint64_t v18;
  __int128 *v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  _OWORD *v23;
  __int128 v24;
  int64_t v25;
  _OWORD *v26;
  __int128 v27;

  v6 = a2;
  v8 = a1[2];
  result = (_OWORD *)*a1;
  if (a4 > (v8 - (uint64_t)result) >> 4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__vallocate[abi:ne180100](a1, v11);
    v13 = (_OWORD *)a1[1];
    v12 = (_OWORD **)(a1 + 1);
    result = v13;
    v14 = (char *)v13;
    if (v6 != a3)
    {
      v14 = (char *)result;
      do
      {
        v15 = *v6++;
        *(_OWORD *)v14 = v15;
        v14 += 16;
      }
      while (v6 != a3);
    }
LABEL_26:
    v25 = v14 - (char *)result;
    goto LABEL_27;
  }
  v17 = (_OWORD *)a1[1];
  v12 = (_OWORD **)(a1 + 1);
  v16 = v17;
  v18 = v17 - result;
  if (v18 >= a4)
  {
    v14 = (char *)result;
    if (a2 != a3)
    {
      v26 = result;
      do
      {
        v27 = *v6++;
        *v26++ = v27;
        v14 += 16;
      }
      while (v6 != a3);
    }
    goto LABEL_26;
  }
  v19 = &a2[v18];
  if (v16 != result)
  {
    v20 = 16 * v18;
    do
    {
      v21 = *v6++;
      *result++ = v21;
      v20 -= 16;
    }
    while (v20);
    result = *v12;
  }
  v22 = (char *)result;
  if (v19 != a3)
  {
    v22 = (char *)result;
    v23 = result;
    do
    {
      v24 = *v19++;
      *v23++ = v24;
      v22 += 16;
    }
    while (v19 != a3);
  }
  v25 = v22 - (char *)result;
LABEL_27:
  *v12 = (_OWORD *)((char *)result + v25);
  return result;
}

long double PCMatrix44Tmpl<double>::leftShear(double *a1, double a2, long double a3)
{
  double v4;
  double v6;
  double v8;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  long double result;

  v4 = a2;
  if (a2 != 0.0)
  {
    if (a2 < 0.0)
    {
      do
        v4 = v4 + 3.14159265;
      while (v4 < 0.0);
    }
    for (; v4 > 3.14159265; v4 = v4 + -3.14159265)
      ;
    v6 = 1.56556034;
    if (v4 >= 1.57603231 || v4 <= 1.56556034)
      v6 = v4;
    v4 = tan(v6);
  }
  if (a3 != 0.0)
  {
    for (; a3 < 0.0; a3 = a3 + 3.14159265)
      ;
    for (; a3 > 3.14159265; a3 = a3 + -3.14159265)
      ;
    v8 = 1.56556034;
    if (a3 >= 1.57603231 || a3 <= 1.56556034)
      v8 = a3;
    a3 = tan(v8);
  }
  v10 = a1[4];
  v11 = a1[5];
  v12 = a1[1];
  v13 = *a1 + v4 * v10;
  v14 = a1[6];
  v15 = a1[7];
  v16 = a1[2];
  v17 = a1[3];
  a1[4] = v10 + a3 * *a1;
  a1[5] = v11 + a3 * v12;
  result = v14 + a3 * v16;
  a1[6] = result;
  a1[7] = v15 + a3 * v17;
  *a1 = v13;
  a1[1] = v12 + v4 * v11;
  a1[2] = v16 + v4 * v14;
  a1[3] = v17 + v4 * v15;
  return result;
}

BOOL PCMatrix44Tmpl<double>::invert(double *a1, double *a2, double a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  _BOOL8 v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v45;

  v3 = a2[14];
  v4 = a2[15];
  v5 = a2[10];
  v6 = a2[11];
  v7 = v5 * v4 - v3 * v6;
  v9 = a2[8];
  v8 = a2[9];
  v10 = a2[12];
  v11 = a2[13];
  v12 = v4 * v8 - v6 * v11;
  v13 = v3 * v8 - v5 * v11;
  v14 = v4 * v9 - v6 * v10;
  v15 = v3 * v9 - v5 * v10;
  v16 = v11 * v9 - v8 * v10;
  v17 = a2[4];
  v18 = a2[5];
  v19 = a2[6];
  v20 = a2[7];
  v21 = v7 * v18 - v12 * v19 + v13 * v20;
  v22 = v15 * v20 + v7 * v17 - v19 * v14;
  v23 = v16 * v20 + v12 * v17 - v18 * v14;
  v24 = v19 * v16 + v13 * v17 - v18 * v15;
  v25 = *a2;
  v26 = a2[1];
  v27 = a2[2];
  v28 = a2[3];
  v29 = v23 * v27 + v21 * *a2 - v26 * v22;
  v30 = v29 - v24 * v28;
  v31 = vabdd_f64(v29, v24 * v28) >= a3 && v30 != 0.0;
  if (v31)
  {
    v32 = v4 * v19 - v3 * v20;
    v33 = v4 * v18 - v11 * v20;
    v45 = v3 * v18 - v11 * v19;
    v34 = v4 * v17 - v10 * v20;
    v35 = v3 * v17 - v10 * v19;
    v36 = v11 * v17 - v10 * v18;
    v37 = v6 * v19 - v5 * v20;
    v38 = v6 * v18 - v8 * v20;
    v39 = v5 * v18 - v8 * v19;
    v40 = v6 * v17 - v9 * v20;
    v41 = v5 * v17 - v9 * v19;
    v42 = v8 * v17 - v9 * v18;
    v43 = 1.0 / v30;
    *a1 = v21 * v43;
    a1[1] = -((v7 * v26 - v12 * v27 + v13 * v28) * v43);
    a1[2] = (v32 * v26 - v33 * v27 + v45 * v28) * v43;
    a1[3] = -((v37 * v26 - v38 * v27 + v39 * v28) * v43);
    a1[4] = -(v22 * v43);
    a1[5] = (v7 * v25 - v14 * v27 + v15 * v28) * v43;
    a1[6] = -((v25 * v32 - v34 * v27 + v35 * v28) * v43);
    a1[7] = (v25 * v37 - v40 * v27 + v41 * v28) * v43;
    a1[8] = v23 * v43;
    a1[9] = -((v12 * v25 - v14 * v26 + v16 * v28) * v43);
    a1[10] = (v25 * v33 - v26 * v34 + v36 * v28) * v43;
    a1[11] = -((v25 * v38 - v26 * v40 + v42 * v28) * v43);
    a1[12] = -(v24 * v43);
    a1[13] = (v13 * v25 - v15 * v26 + v16 * v27) * v43;
    a1[14] = -((v45 * v25 - v26 * v35 + v36 * v27) * v43);
    a1[15] = (v39 * v25 - v26 * v41 + v42 * v27) * v43;
  }
  return v31;
}

void OZShape::calcIntersectionForOutlineAtPoint(uint64_t a1, CMTime *a2, _DWORD *a3, float64x2_t *a4, double a5, double a6)
{
  double v11;
  OZChannelCurve *v12;
  double MaxParametricValue;
  double v14;
  double v15;
  double v16;
  Float64 v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  float64x2_t v47;
  double v48;
  float64x2_t v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  float64x2_t *v68;
  double v69;
  double v70;
  float64x2_t v71;
  double v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  float64x2_t v78;
  double v79;
  double v80;
  double v81;
  double v82;
  float64x2_t v83;
  double v84;
  double v85;
  float64x2_t v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  double v101;
  double v102;
  float64x2_t v103;
  double v104;
  double v105;
  double v106[2];
  double v107;
  double v108;
  float64x2_t v109;
  float64x2_t v110;
  double v111;
  double v112;
  double v113[2];
  double v114;
  double v115;
  float64x2_t v116;
  CMTime v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  double v123;

  v11 = a5 + -0.025;
  v122 = 0.0;
  v123 = 0.0;
  v120 = 0.0;
  v121 = 0.0;
  v118 = 0.0;
  v119 = 0.0;
  v117 = *a2;
  v12 = (OZChannelCurve *)(a1 + 208);
  MaxParametricValue = OZChannelCurve::getMaxParametricValue((OZChannelCurve *)(a1 + 208), &v117);
  v14 = vabdd_f64(a5, OZChannelCurve::getMinParametricValue(v12, &v117));
  if (v14 < 0.0000001 && a3[42])
    v11 = MaxParametricValue + 0.975;
  v15 = vabdd_f64(a5, MaxParametricValue);
  v16 = a5;
  if (v15 < 0.0000001)
  {
    if (a3[42])
      v16 = MaxParametricValue;
    else
      v16 = a5;
  }
  v17 = v16 + 0.025;
  OZChannelCurve::getCurveValueWithParameter(v12, &v117, v11, &v123, &v122);
  OZChannelCurve::getCurveValueWithParameter(v12, &v117, a5, &v121, &v120);
  OZChannelCurve::getCurveValueWithParameter(v12, &v117, v17, &v119, &v118);
  v18 = v121 - v123;
  v19 = v18 * (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  v20 = v120 - v122;
  v21 = v119 - v121;
  v22 = v21 * (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  v23 = sqrt(v19 * v19 + v20 * v20);
  v24 = -v20 / v23;
  v94 = v23;
  v95 = v20;
  v25 = v19 / v23;
  v26 = sqrt(v22 * v22 + (v118 - v120) * (v118 - v120));
  v99 = v25;
  v101 = -(v118 - v120) / v26;
  v97 = v26;
  v102 = v22 / v26;
  if ((a3[6] | 2) == 2)
  {
    v91 = v15;
    v92 = v14;
    v93 = v22;
    v27 = v123;
    v98 = v24;
    v28 = v24 * a6;
    v29 = v27 + v24 * a6 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
    v30 = v121;
    v31 = v99 * a6;
    v32 = v99 * a6 + v122;
    v116.f64[0] = v29;
    v116.f64[1] = v32;
    v33 = v30 + v28 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1) - v29;
    v34 = v99 * a6 + v120 - v32;
    v114 = v33;
    v115 = v34;
    v35 = sqrt(v33 * v33 + v34 * v34);
    if (v35 <= -0.000000100000001 || v35 >= 0.000000100000001)
    {
      v114 = v33 / v35;
      v115 = v34 / v35;
    }
    v36 = v121;
    v37 = v101 * a6;
    v38 = v36 + v101 * a6 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
    v39 = v119;
    v90 = a6;
    v40 = v102 * a6;
    v41 = v40 + v120;
    v113[0] = v38;
    v113[1] = v40 + v120;
    v88 = v40;
    v89 = v37;
    v42 = v39 + v37 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1) - v38;
    v43 = v40 + v118 - v41;
    v111 = v42;
    v112 = v43;
    v44 = sqrt(v42 * v42 + v43 * v43);
    if (v44 <= -0.000000100000001 || v44 >= 0.000000100000001)
    {
      v111 = v42 / v44;
      v112 = v43 / v44;
    }
    v110 = 0uLL;
    if (a3[6] || !PCAlgorithm::findIntersection(v116.f64, &v114, v113, &v111, v110.f64))
    {
      a6 = v90;
      v45 = v20 / v94 * v90;
      v46 = v121;
      v109.f64[0] = v46 + v31 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
      v109.f64[1] = v45 + v120;
      v47 = PCRect<double>::operator|=(a4, &v109);
      v48 = v121;
      v109.f64[0] = v48
                  + (v28 + v31) / (*(double (**)(uint64_t, float64x2_t))(*(_QWORD *)a1 + 176))(a1, v47);
      v109.f64[1] = v45 + v31 + v120;
      v49 = PCRect<double>::operator|=(a4, &v109);
      v50 = v121;
      v109.f64[0] = v50
                  + (v31 - v28) / (*(double (**)(uint64_t, float64x2_t))(*(_QWORD *)a1 + 176))(a1, v49);
      v109.f64[1] = v45 + v120 - v31;
      PCRect<double>::operator|=(a4, &v109);
    }
    else
    {
      PCRect<double>::operator|=(a4, &v110);
      a6 = v90;
    }
    v51 = -a6;
    v52 = v123;
    v53 = -(a6 * v98);
    v54 = v52 + v53 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
    v55 = v121;
    v56 = v122 - a6 * v99;
    v109.f64[0] = v54;
    v109.f64[1] = v56;
    v57 = v55 + v53 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1) - v54;
    v58 = v120 - a6 * v99 - v56;
    v107 = v57;
    v108 = v58;
    v59 = sqrt(v57 * v57 + v58 * v58);
    if (v59 <= -0.000000100000001 || v59 >= 0.000000100000001)
    {
      v107 = v57 / v59;
      v108 = v58 / v59;
    }
    v60 = v121;
    v61 = v101 * v51;
    v62 = v60 + v101 * v51 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
    v63 = v119;
    v64 = v102 * v51 + v120;
    v106[0] = v62;
    v106[1] = v64;
    v65 = v63 + v101 * v51 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1) - v62;
    v66 = v102 * v51 + v118 - v64;
    v104 = v65;
    v105 = v66;
    v67 = sqrt(v65 * v65 + v66 * v66);
    if (v67 <= -0.000000100000001 || v67 >= 0.000000100000001)
    {
      v104 = v65 / v67;
      v105 = v66 / v67;
    }
    v22 = v93;
    if (a3[6] || !PCAlgorithm::findIntersection(v109.f64, &v107, v106, &v104, v110.f64))
    {
      v69 = -v93 / v97 * v51;
      v70 = v121;
      v103.f64[0] = v70 + v69 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
      v103.f64[1] = v61 + v120;
      v71 = PCRect<double>::operator|=(a4, &v103);
      v72 = v121;
      v103.f64[0] = v72
                  + (v61 + v69) / (*(double (**)(uint64_t, float64x2_t))(*(_QWORD *)a1 + 176))(a1, v71);
      v103.f64[1] = v61 + v102 * v51 + v120;
      PCRect<double>::operator|=(a4, &v103);
      v73 = v121;
      v103.f64[0] = v73 + (v89 + v69) / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
      v103.f64[1] = v61 + v88 + v120;
      v68 = &v103;
    }
    else
    {
      v68 = &v110;
    }
    PCRect<double>::operator|=(a4, v68);
    v14 = v92;
    v15 = v91;
    v24 = v98;
  }
  if ((a3[7] | 2) == 2 || (a3[8] | 2) == 2)
  {
    v74 = fabs(a6);
    if (v15 < 0.0000001 && !a3[42])
    {
      v75 = v74 * v99;
      v76 = v121;
      v100 = v74 * (v95 / v94);
      v116.f64[0] = v76 + v75 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
      v116.f64[1] = v100 + v120;
      PCRect<double>::operator|=(a4, &v116);
      v96 = v121;
      v77 = v74 * v24;
      v116.f64[0] = v96 + (v74 * v24 + v75) / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
      v116.f64[1] = v100 + v75 + v120;
      v78 = PCRect<double>::operator|=(a4, &v116);
      v79 = v121;
      v116.f64[0] = v79
                  + (v75 - v77) / (*(double (**)(uint64_t, float64x2_t))(*(_QWORD *)a1 + 176))(a1, v78);
      v116.f64[1] = v100 + v120 - v75;
      PCRect<double>::operator|=(a4, &v116);
    }
    if (v14 < 0.0000001 && !a3[42])
    {
      v80 = v74 * (-v22 / v97);
      v81 = v74 * v101;
      v82 = v121;
      v116.f64[0] = v82 + v80 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
      v116.f64[1] = v74 * v101 + v120;
      v83 = PCRect<double>::operator|=(a4, &v116);
      v84 = v121;
      v85 = v74 * v102;
      v116.f64[0] = v84
                  + (v81 + v80) / (*(double (**)(uint64_t, float64x2_t))(*(_QWORD *)a1 + 176))(a1, v83);
      v116.f64[1] = v81 + v85 + v120;
      v86 = PCRect<double>::operator|=(a4, &v116);
      v87 = v121;
      v116.f64[0] = v87
                  + (v80 - v81) / (*(double (**)(uint64_t, float64x2_t))(*(_QWORD *)a1 + 176))(a1, v86);
      v116.f64[1] = v81 + v120 - v85;
      PCRect<double>::operator|=(a4, &v116);
    }
  }
}

void OZShape::drawOutlinePolygonsToHeliumNode(OZShape *this@<X0>, OZShapeRenderParams *a2@<X3>, uint64_t *a3@<X1>, uint64_t a4@<X2>, uint64_t a5@<X4>, int a6@<W5>, int a7@<W6>, int a8@<W7>, HGGLNode **a9@<X8>, double a10@<D0>, HGGLNode **a11, _QWORD *a12, double *a13, uint64_t *a14)
{
  HGGLNode *v22;
  double *v23;
  HGGLNode *v24;
  double v25;
  float v26;
  float v27;
  float v28;
  _BOOL4 v29;
  int v30;
  HgcShapeSoftEdgeClr *v31;
  _BOOL4 shouldDrawSecondPassGradientInHelium;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  __n128 v36;
  HgcShapeSoftEdgeSubtractAlpha *v37;
  HGHWMultiBlend *v38;
  void *__p;
  void *v42;
  uint64_t v43;
  HGArrayData *v44;
  HGArrayData *v45;

  v22 = *a11;
  *a9 = *a11;
  if (v22)
    (*(void (**)(HGGLNode *))(*(_QWORD *)v22 + 16))(v22);
  if (OZShape::shouldRenderInPlace(this, a2))
  {
    HGGLNode::enableInplaceBlending(*a11);
  }
  else
  {
    if ((a6 & 1) == 0 && *((_DWORD *)a2 + 30))
    {
      if (a10 >= 0.0 && a8)
        HGGLNode::hglEnableBlending((uint64_t)*a11, 3, 1);
      goto LABEL_13;
    }
    HGGLNode::hglEnableBlending((uint64_t)*a11, 3, 1);
  }
  if (a6)
  {
    v23 = 0;
    a3 = (uint64_t *)(a5 + 360);
    a7 = 1;
LABEL_33:
    return;
  }
LABEL_13:
  v23 = a13;
  if (a10 >= 0.0)
    goto LABEL_33;
  v24 = (HGGLNode *)HGObject::operator new(0x1B0uLL);
  HGGLNode::HGGLNode(v24, 0);
  (*(void (**)(HGGLNode *, _QWORD, _QWORD))(*(_QWORD *)v24 + 120))(v24, 0, *a12);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)*a12 + 136))(*a12, 0xFFFFFFFFLL, 4);
  HGGLNode::hglTexParameteri((const char **)v24, (const char *)0xDE1, (char *)0x2801, 9729.0);
  HGGLNode::hglTexParameteri((const char **)v24, (const char *)0xDE1, (char *)0x2800, 9729.0);
  HGGLNode::hglTexParameteri((const char **)v24, (const char *)0xDE1, (char *)0x2802, 33071.0);
  HGGLNode::hglTexParameteri((const char **)v24, (const char *)0xDE1, (char *)0x2803, 33071.0);
  HGGLNode::hglActiveTexture(v24, 192);
  v25 = *((double *)a2 + 19);
  v26 = *((double *)a2 + 16) * v25;
  v27 = v25 * *((double *)a2 + 17);
  v28 = v25 * *((double *)a2 + 18);
  v29 = v26 < 0.0;
  if (v27 < 0.0)
    v29 = 1;
  if (v28 < 0.0)
    v29 = 1;
  if (v26 > 1.0)
    v29 = 1;
  if (v27 > 1.0)
    v29 = 1;
  v30 = v28 > 1.0 || v29;
  v31 = (HgcShapeSoftEdgeClr *)HGObject::operator new(0x1B0uLL);
  HgcShapeSoftEdgeClr::HgcShapeSoftEdgeClr(v31);
  HGGLNode::addFragmentShader((HGRasterizer **)v24, v31);
  shouldDrawSecondPassGradientInHelium = OZShape::shouldDrawSecondPassGradientInHelium(this, a4, a2);
  v33.n128_u32[0] = 1.0;
  v34.n128_u32[0] = 1.0;
  v35.n128_u32[0] = 1.0;
  v36.n128_u32[0] = 1.0;
  if (((shouldDrawSecondPassGradientInHelium | v30) & 1) == 0)
  {
    v36.n128_f32[0] = v25;
    v33.n128_f32[0] = v26;
    v34.n128_f32[0] = v27;
    v35.n128_f32[0] = v28;
  }
  (*(void (**)(HgcShapeSoftEdgeClr *, _QWORD, __n128, __n128, __n128, __n128))(*(_QWORD *)v31 + 96))(v31, 0, v33, v34, v35, v36);
  HGGLNode::hglClearToBlack(v24);
  HGGLNode::hglEnableBlending((uint64_t)v24, 3, 1);
  __p = 0;
  v42 = 0;
  v43 = 0;
  HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v44);
  HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v45);
  OZShape::drawVertexArrayList(this, (const char **)v24, (OZShapeVertexArrayData *)&__p);
  if (v30)
  {
    v37 = (HgcShapeSoftEdgeSubtractAlpha *)HGObject::operator new(0x1A0uLL);
    HgcShapeSoftEdgeSubtractAlpha::HgcShapeSoftEdgeSubtractAlpha(v37);
    (*(void (**)(HgcShapeSoftEdgeSubtractAlpha *, _QWORD, HGGLNode *))(*(_QWORD *)v37 + 120))(v37, 0, v24);
    (*(void (**)(HgcShapeSoftEdgeSubtractAlpha *, uint64_t, HGGLNode *))(*(_QWORD *)v37 + 120))(v37, 1, *a11);
    if (v22 != v37)
    {
      if (v22)
        (*(void (**)(HGGLNode *))(*(_QWORD *)v22 + 24))(v22);
      *a9 = v37;
      (*(void (**)(HgcShapeSoftEdgeSubtractAlpha *))(*(_QWORD *)v37 + 16))(v37);
    }
    (*(void (**)(HgcShapeSoftEdgeSubtractAlpha *))(*(_QWORD *)v37 + 24))(v37);
  }
  else
  {
    v38 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
    HGHWMultiBlend::HGHWMultiBlend(v38);
    (*(void (**)(HGHWMultiBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v38 + 96))(v38, 2, 0.0, 0.0, 0.0, 0.0);
    (*(void (**)(HGHWMultiBlend *, uint64_t, float, float, float, float))(*(_QWORD *)v38 + 96))(v38, 5, *(float *)(a4 + 88), 0.0, 0.0, 0.0);
    (*(void (**)(HGHWMultiBlend *, _QWORD, HGGLNode *, uint64_t, float))(*(_QWORD *)v38 + 624))(v38, 0, *a11, 9, 1.0);
    (*(void (**)(HGHWMultiBlend *, uint64_t, HGGLNode *, uint64_t, float))(*(_QWORD *)v38 + 624))(v38, 1, v24, 40, 1.0);
    if (v22 != v38)
    {
      if (v22)
        (*(void (**)(HGGLNode *))(*(_QWORD *)v22 + 24))(v22);
      *a9 = v38;
      (*(void (**)(HGHWMultiBlend *))(*(_QWORD *)v38 + 16))(v38);
    }
    (*(void (**)(HGHWMultiBlend *))(*(_QWORD *)v38 + 24))(v38);
  }
  if (v45)
    HGArrayData::Release((uint64_t)v45);
  if (v44)
    HGArrayData::Release((uint64_t)v44);
  if (__p)
  {
    v42 = __p;
    operator delete(__p);
  }
  (*(void (**)(HgcShapeSoftEdgeClr *))(*(_QWORD *)v31 + 24))(v31);
  (*(void (**)(HGGLNode *))(*(_QWORD *)v24 + 24))(v24);
}

void sub_1B300D6E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, HGArrayData *a15)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;

  HGObject::operator delete(v18);
  OZShapeVertexArrayData::~OZShapeVertexArrayData((OZShapeVertexArrayData *)&__p);
  (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::fillEdgeVertexArray(uint64_t *a1, double *a2, uint64_t *a3, int a4, int a5)
{
  uint64_t v10;
  HGArrayDataRef *v11;
  uint64_t *v12;
  uint64_t v13;
  int32x2_t v14;
  __int128 v15;
  OZShapeVertexArrayData *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  __int128 v21;
  float v22;
  float v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  unsigned int v46;
  float v47;
  float v48;
  unsigned int v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  uint64_t v63;
  __int128 *v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  float v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  int v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  _OWORD v86[2];

  v11 = (HGArrayDataRef *)(a3 + 3);
  v10 = a3[3];
  v12 = a3 + 5;
  if (v10)
    LODWORD(v10) = *(_DWORD *)(v10 + 8);
  HGArray<__simd128_float32_t,(HGFormat)28>::reserve(a3 + 3, v10 - 1010580540 * ((unint64_t)(a1[1] - *a1) >> 3));
  v13 = *v12;
  if (*v12)
    LODWORD(v13) = *(_DWORD *)(v13 + 8);
  HGArray<__simd128_float32_t,(HGFormat)28>::reserve(v12, v13 - 1010580540 * ((unint64_t)(a1[1] - *a1) >> 3));
  if (*(_QWORD *)v11)
    v16 = (OZShapeVertexArrayData *)*(unsigned int *)(*(_QWORD *)v11 + 8);
  else
    v16 = 0;
  v18 = *a1;
  v17 = a1[1];
  if ((int)(-252645135 * ((unint64_t)(v17 - *a1) >> 3)) >= 1)
  {
    v82 = a5;
    v19 = 0;
    v14.i32[0] = 1115422720;
    v20 = 0.0;
    LODWORD(v15) = vdup_lane_s32(v14, 0).u32[0];
    if (a4)
      v20 = 63.0;
    LODWORD(v21) = 1115422720;
    *((float *)&v21 + 1) = v20;
    DWORD2(v21) = 0;
    HIDWORD(v21) = 1.0;
    *((float *)&v15 + 1) = v20;
    v22 = 0.0;
    v23 = 0.0;
    v24 = 120;
    v25 = 0.0;
    v26 = 0.0;
    v27 = 0.0;
    v28 = 0.0;
    v29 = 0.0;
    v30 = 0.0;
    while (1)
    {
      if ((*(_QWORD *)(v18 + v24 - 120) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v31 = *(double *)(v18 + v24 - 112);
        if ((*(_QWORD *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v32 = *(double *)(v18 + v24 - 104);
          if ((*(_QWORD *)&v32 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v33 = *(double *)(v18 + v24 - 96);
            if ((*(_QWORD *)&v33 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v34 = *(double *)(v18 + v24 - 88);
              if ((*(_QWORD *)&v34 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                v35 = *(double *)(v18 + v24 - 80);
                if ((*(_QWORD *)&v35 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                {
                  v36 = *(double *)(v18 + v24 - 72);
                  if ((*(_QWORD *)&v36 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    v37 = *(double *)(v18 + v24 - 64);
                    if ((*(_QWORD *)&v37 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                    {
                      v38 = *(double *)(v18 + v24 - 56);
                      if ((*(_QWORD *)&v38 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                      {
                        v39 = *(double *)(v18 + v24 - 48);
                        if ((*(_QWORD *)&v39 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                        {
                          v40 = *(double *)(v18 + v24 - 40);
                          if ((*(_QWORD *)&v40 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                          {
                            v41 = *(double *)(v18 + v24 - 32);
                            if ((*(_QWORD *)&v41 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                            {
                              v42 = *(double *)(v18 + v24 - 24);
                              if ((*(_QWORD *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                              {
                                v43 = *(double *)(v18 + v24 - 16);
                                if ((*(_QWORD *)&v43 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                                  break;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v54 = v30;
      v55 = v29;
      v56 = v28;
      v57 = v27;
      v50 = v26;
      v51 = v25;
      v52 = v23;
      v53 = v22;
LABEL_41:
      ++v19;
      v24 += 136;
      v22 = v53;
      v23 = v52;
      v25 = v51;
      v26 = v50;
      v27 = v57;
      v28 = v56;
      v29 = v55;
      v30 = v54;
      if (v19 >= (int)(-252645135 * ((unint64_t)(v17 - v18) >> 3)))
        goto LABEL_59;
    }
    v81 = v21;
    v44 = *(double *)(v18 + v24 - 8);
    if ((*(_QWORD *)&v44 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      v54 = v30;
      v55 = v29;
      v56 = v28;
      v57 = v27;
      v50 = v26;
      v51 = v25;
      v52 = v23;
      v53 = v22;
LABEL_58:
      v21 = v81;
      goto LABEL_41;
    }
    v80 = v15;
    v45 = *(double *)(v18 + v24);
    if ((*(_QWORD *)&v45 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      v54 = v30;
      v55 = v29;
      v56 = v28;
      v57 = v27;
      v50 = v26;
      v51 = v25;
      v52 = v23;
      v53 = v22;
LABEL_57:
      v15 = v80;
      goto LABEL_58;
    }
    *(float *)&v46 = *(double *)(v18 + v24 - 120);
    v47 = v31;
    *(_QWORD *)&v86[0] = __PAIR64__(LODWORD(v47), v46);
    v48 = v32;
    *(float *)&v49 = v33;
    *((_QWORD *)&v86[0] + 1) = __PAIR64__(v49, LODWORD(v48));
    v74 = *(float *)&v49;
    v50 = v34;
    v51 = v35;
    *(_QWORD *)&v85 = __PAIR64__(LODWORD(v51), LODWORD(v50));
    v52 = v36;
    v53 = v37;
    *((_QWORD *)&v85 + 1) = __PAIR64__(LODWORD(v53), LODWORD(v52));
    v54 = v38;
    v55 = v39;
    *(_QWORD *)&v84 = __PAIR64__(LODWORD(v55), LODWORD(v54));
    v56 = v40;
    v57 = v41;
    *((_QWORD *)&v84 + 1) = __PAIR64__(LODWORD(v57), LODWORD(v56));
    v58 = v42;
    v59 = v43;
    *(_QWORD *)&v83 = __PAIR64__(LODWORD(v59), LODWORD(v58));
    v60 = v44;
    v61 = v45;
    *((_QWORD *)&v83 + 1) = __PAIR64__(LODWORD(v61), LODWORD(v60));
    if (v26 == *(float *)&v46
      && v25 == v47
      && v23 == v48
      && v22 == v74
      && v30 == v58
      && v29 == v59
      && v28 == v60
      && v27 == v61)
    {
      if (a2)
      {
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v85, (uint64_t)&v85);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v84, (uint64_t)&v84);
      }
      v75 = v85;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v75;
      if (v82)
      {
        v62 = *((float *)&v85 + 3);
LABEL_53:
        *(float *)&v68 = v62 * 63.0;
        *((float *)&v68 + 1) = v62 * 63.0;
        *((float *)&v68 + 2) = v62 * 0.0;
        *((float *)&v68 + 3) = v62;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v68;
        v77 = v84;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v77;
        *(float32x2_t *)&v69 = vmul_n_f32(*(float32x2_t *)&v80, *((float *)&v84 + 3));
        *((float *)&v69 + 2) = *((float *)&v84 + 3) * 0.0;
        HIDWORD(v69) = HIDWORD(v84);
        v78 = v69;
LABEL_56:
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v78;
        v18 = *a1;
        v17 = a1[1];
        goto LABEL_57;
      }
      v64 = (__int128 *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12);
      v65 = xmmword_1B3565CA0;
    }
    else
    {
      v63 = a3[3];
      if (v63)
        v16 = (OZShapeVertexArrayData *)*(unsigned int *)(v63 + 8);
      else
        v16 = 0;
      if (a2)
      {
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)v86, (uint64_t)v86);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v85, (uint64_t)&v85);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v84, (uint64_t)&v84);
        PCMatrix44Tmpl<double>::transform<float>(a2, (float *)&v83, (uint64_t)&v83);
      }
      v76 = v86[0];
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v76;
      if (v82)
      {
        *(float *)&v66 = *((float *)v86 + 3) * 63.0;
        *((float *)&v66 + 1) = *((float *)v86 + 3) * 63.0;
        *((float *)&v66 + 2) = *((float *)v86 + 3) * 0.0;
        HIDWORD(v66) = HIDWORD(v86[0]);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v66;
        v70 = v83;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v70;
        *(float32x2_t *)&v67 = vmul_n_f32(*(float32x2_t *)&v80, *((float *)&v83 + 3));
        *((float *)&v67 + 2) = *((float *)&v83 + 3) * 0.0;
        HIDWORD(v67) = HIDWORD(v83);
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v67;
        v71 = v85;
        *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v71;
        v62 = *((float *)&v85 + 3);
        goto LABEL_53;
      }
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = xmmword_1B3565CA0;
      v72 = v83;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v72;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12) = v81;
      v73 = v85;
      *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v73;
      v64 = (__int128 *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)v12);
      v65 = xmmword_1B3565CA0;
    }
    *v64 = v65;
    v79 = v84;
    *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append(v11) = v79;
    v78 = v81;
    goto LABEL_56;
  }
LABEL_59:
}

void OZShapeVertexArrayData::~OZShapeVertexArrayData(OZShapeVertexArrayData *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v2 = *((_QWORD *)this + 5);
  if (v2)
    HGArrayData::Release(v2);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    HGArrayData::Release(v3);
  v4 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
}

void OZShape::computeOpenStroke(uint64_t a1, const CMTime *a2, uint64_t a3, _QWORD *a4, double *a5, int a6, int a7, double a8)
{
  double v9;
  BOOL v10;
  BOOL v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v22;
  double v23;
  uint64_t i;
  _OWORD *v25;
  __int128 v26;
  uint64_t j;
  _OWORD *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  unint64_t k;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _OWORD *v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _OWORD *v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 *v50;
  uint64_t v51;
  char *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  _OWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unsigned int v62;
  double v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  _BOOL4 v73;
  double v74;
  double v75;
  double v76;
  double v77;
  uint64_t v78;
  uint64_t v79;
  __int128 v80;
  double v81;
  double v82;
  double v83;
  __int128 v84;
  double v85;
  unint64_t v86;
  __int128 v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  __int128 *v92;
  char *v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t *v106;
  unsigned int v107;
  __int128 *v108;
  __int128 v109;
  __int128 v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  __int128 v118;
  double v119;
  double v120;
  __int128 v121;
  uint64_t v122;
  __int128 v123;
  double v124;
  double v125;
  __int128 v126;
  double v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t *v131;
  unsigned int v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  double v136;
  double v137;
  double v138;
  double v139;
  double v140;
  double v141;
  double v142;
  __int128 v143;
  double v144;
  __int128 v145;
  uint64_t v146;
  __int128 v147;
  double v148;
  double v149;
  __int128 v150;
  double v151;
  uint64_t v152;
  unsigned int v153;
  unint64_t *v154;
  uint64_t *v155;
  uint64_t *v156;
  uint64_t v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  _BYTE v165[19];
  char v166;
  int v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  _BYTE v175[19];
  char v176;
  int v177;
  _BYTE v178[128];
  uint64_t v179;
  __int128 v180[8];
  uint64_t v181;
  _BYTE v182[128];
  uint64_t v183;
  _OWORD v184[8];
  uint64_t v185;
  void *__p;
  _QWORD *v187;
  uint64_t v188;
  _BYTE v189[48];
  float64x2_t v190;
  __int128 v191;
  _BYTE v192[48];
  double v193;
  __int128 v194;
  __int128 v195;
  uint64_t v196;
  __int128 v197;
  __int128 v198;
  uint64_t v199;
  __int128 v200;
  __int128 v201;
  uint64_t v202;

  v202 = 0x3FF0000000000000;
  v199 = 0x3FF0000000000000;
  v196 = 0x3FF0000000000000;
  v193 = 1.0;
  v194 = 0u;
  v195 = 0u;
  v197 = 0u;
  v198 = 0u;
  v200 = 0u;
  v201 = 0u;
  *(_QWORD *)&v192[40] = 0x3FF0000000000000;
  *(_QWORD *)v192 = 0x3FF0000000000000;
  *(_QWORD *)&v189[40] = 0x3FF0000000000000;
  *(_QWORD *)v189 = 0x3FF0000000000000;
  memset(&v189[8], 0, 32);
  v190 = 0u;
  v191 = 0u;
  memset(&v192[8], 0, 32);
  v9 = a8 * 0.5;
  v10 = a8 * 0.5 < 4.0;
  v11 = a8 * 0.5 <= 4.0;
  v12 = a8 * 0.5 * 0.25 + 1.0;
  v13 = a8 * 0.5 * 0.4375 + 0.25;
  if (v10 || v9 == 4.0)
    v14 = v12;
  else
    v14 = 2.0;
  if (v11)
    v15 = v13;
  else
    v15 = v9 + -2.0;
  if (a4[28] == a4[27])
  {
    a4[43] = a4[42];
  }
  else
  {
    if (*(_BYTE *)(a3 + 1195))
    {
      a4[43] = a4[42];
      a4[46] = a4[45];
    }
    if (*(_BYTE *)(a3 + 13))
    {
      PCMatrix44Tmpl<double>::leftShear((double *)v189, *(double *)(a3 + 264), *(long double *)(a3 + 272));
      v23 = *(double *)(a3 + 248);
      v22 = *(double *)(a3 + 256);
      if (v23 != 1.0)
      {
        *(float64x2_t *)v189 = vmulq_n_f64(*(float64x2_t *)v189, v23);
        *(float64x2_t *)&v189[16] = vmulq_n_f64(*(float64x2_t *)&v189[16], v23);
      }
      if (v22 != 1.0)
      {
        *(float64x2_t *)&v189[32] = vmulq_n_f64(*(float64x2_t *)&v189[32], v22);
        v190 = vmulq_n_f64(v190, v22);
      }
      v184[4] = v191;
      v184[5] = *(_OWORD *)v192;
      v184[6] = *(_OWORD *)&v192[16];
      v184[7] = *(_OWORD *)&v192[32];
      v184[0] = *(_OWORD *)v189;
      v184[1] = *(_OWORD *)&v189[16];
      v184[2] = *(_OWORD *)&v189[32];
      v184[3] = v190;
      PCMatrix44Tmpl<double>::invert((double *)v184, (double *)v184, 0.0);
      if (&v193 != a5)
      {
        for (i = 0; i != 16; i += 4)
        {
          v25 = (_OWORD *)((char *)&v193 + i * 8);
          v26 = *(_OWORD *)&a5[i + 2];
          *v25 = *(_OWORD *)&a5[i];
          v25[1] = v26;
        }
      }
      PCMatrix44Tmpl<double>::rightMult((uint64_t)&v193, (double *)v184);
    }
    else
    {
      if (&v193 != a5)
      {
        for (j = 0; j != 16; j += 4)
        {
          v28 = (_OWORD *)((char *)&v193 + j * 8);
          v29 = *(_OWORD *)&a5[j + 2];
          *v28 = *(_OWORD *)&a5[j];
          v28[1] = v29;
        }
      }
      *(_QWORD *)&v192[40] = 0x3FF0000000000000;
      *(_QWORD *)v192 = 0x3FF0000000000000;
      *(_QWORD *)&v189[40] = 0x3FF0000000000000;
      *(_QWORD *)v189 = 0x3FF0000000000000;
      memset(&v189[8], 0, 32);
      v190 = 0u;
      v191 = 0u;
      memset(&v192[8], 0, 32);
    }
    OZShape::computeOutlinePolygons(a1, a4 + 42, (uint64_t)a4, a2, a3, (double *)v189, a6, a7, v9, 1, 1, 1u);
    v187 = 0;
    __p = 0;
    v188 = 0;
    OZShape::computeOutlinePolygons(a1, (uint64_t *)&__p, (uint64_t)a4, a2, a3, (double *)v189, a6, a7, v9, 1, -1, 1u);
    v32 = a4[42];
    v31 = a4[43];
    v33 = __p;
    if (v31 != v32)
    {
      v34 = v187;
      if (v187 != __p)
      {
        for (k = 0; k != 128; k += 64)
        {
          v36 = *(_OWORD *)(v32 + k);
          v37 = *(_OWORD *)(v32 + k + 16);
          v38 = *(_OWORD *)(v32 + k + 48);
          v39 = &v184[k / 0x10];
          v39[2] = *(_OWORD *)(v32 + k + 32);
          v39[3] = v38;
          *v39 = v36;
          v39[1] = v37;
        }
        v40 = 0;
        v185 = *(_QWORD *)(v32 + 128);
        v41 = v31 - 136;
        do
        {
          v42 = *(_OWORD *)(v41 + v40);
          v43 = *(_OWORD *)(v41 + v40 + 16);
          v44 = *(_OWORD *)(v41 + v40 + 48);
          v45 = &v182[v40];
          v45[2] = *(_OWORD *)(v41 + v40 + 32);
          v45[3] = v44;
          *v45 = v42;
          v45[1] = v43;
          v40 += 64;
        }
        while (v40 != 128);
        v46 = 0;
        v183 = *(_QWORD *)(v31 - 8);
        do
        {
          v47 = *(_OWORD *)&v33[v46 / 8];
          v48 = *(_OWORD *)&v33[v46 / 8 + 2];
          v49 = *(_OWORD *)&v33[v46 / 8 + 6];
          v50 = &v180[v46 / 0x10];
          v50[2] = *(_OWORD *)&v33[v46 / 8 + 4];
          v50[3] = v49;
          *v50 = v47;
          v50[1] = v48;
          v46 += 64;
        }
        while (v46 != 128);
        v51 = 0;
        v181 = v33[16];
        v52 = (char *)(v34 - 17);
        do
        {
          v53 = *(_OWORD *)&v52[v51];
          v54 = *(_OWORD *)&v52[v51 + 16];
          v55 = *(_OWORD *)&v52[v51 + 48];
          v56 = &v178[v51];
          v56[2] = *(_OWORD *)&v52[v51 + 32];
          v56[3] = v55;
          *v56 = v53;
          v56[1] = v54;
          v51 += 64;
        }
        while (v51 != 128);
        v179 = *(v34 - 1);
        if (*(_DWORD *)(a3 + 32) == 1)
          OZShape::computeRoundCaps(a1, a4 + 42, (uint64_t *)&__p, (uint64_t)a2, a3, (uint64_t)v184, (uint64_t)v182, (uint64_t)v180, v15, (uint64_t)v178, &v193, 0);
        if (*(_DWORD *)(a3 + 28) == 1)
          OZShape::computeRoundCaps(a1, a4 + 42, (uint64_t *)&__p, (uint64_t)a2, a3, (uint64_t)v184, (uint64_t)v182, (uint64_t)v180, v15, (uint64_t)v178, &v193, 1);
        if (*(_DWORD *)(a3 + 32) == 2)
          v33 = (_QWORD *)OZShape::computeBevelCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 0);
        if (*(_DWORD *)(a3 + 28) == 2)
          v33 = (_QWORD *)OZShape::computeBevelCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 1);
        if (*(_DWORD *)(a3 + 32) == 3)
          v33 = (_QWORD *)OZShape::computeArrowCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, a3, (double *)v184, (uint64_t)v182, v180, (uint64_t)v178, 0);
        if (*(_DWORD *)(a3 + 28) == 3)
          v33 = (_QWORD *)OZShape::computeArrowCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, a3, (double *)v184, (uint64_t)v182, v180, (uint64_t)v178, 1);
        if (!*(_DWORD *)(a3 + 32))
          v33 = (_QWORD *)OZShape::computeNormalCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 0, 0);
        if (!*(_DWORD *)(a3 + 28))
          v33 = (_QWORD *)OZShape::computeNormalCaps(v15, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 1, 0);
        if (*(_DWORD *)(a3 + 32) == 4)
          v33 = (_QWORD *)OZShape::computeNormalCaps(0.05, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 0, 1);
        if (*(_DWORD *)(a3 + 28) == 4)
          OZShape::computeNormalCaps(0.05, (uint64_t)v33, a4 + 42, (uint64_t *)&__p, v30, (double *)v184, (uint64_t)v182, (double *)v180, (uint64_t)v178, 1, 1);
        v57 = __p;
        v58 = (uint64_t)v187;
        *((_BYTE *)__p + 131) = 0;
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a4 + 42, a4[43], (uint64_t)v57, v58, 0xF0F0F0F0F0F0F0F1 * ((v58 - (uint64_t)v57) >> 3));
        v155 = a4 + 42;
        v59 = a4[42];
        v157 = a3;
        if (a4[43] == v59)
        {
          v156 = a4 + 45;
          v61 = a4 + 46;
          v91 = a4[46];
        }
        else
        {
          v152 = a1;
          v60 = 0;
          v153 = 0;
          v156 = a4 + 45;
          v61 = a4 + 46;
          v154 = a4 + 47;
          v62 = 1;
          do
          {
            OZShapeEdgePolygon::transformPoints((double *)(v59 + 136 * v60), &v193);
            if (*(_BYTE *)(a3 + 176))
            {
              v63 = v14;
              v174 = 0u;
              memset(v175, 0, sizeof(v175));
              v172 = 0u;
              v173 = 0u;
              v170 = 0u;
              v171 = 0u;
              v168 = 0u;
              v169 = 0u;
              v176 = 1;
              v177 = 0;
              v64 = *v155 + 136 * v60;
              LOBYTE(v177) = *(_BYTE *)(v64 + 132);
              HIBYTE(v177) = *(_BYTE *)(v64 + 135);
              v65 = *(_OWORD *)(v64 + 112);
              v168 = *(_OWORD *)(v64 + 96);
              v169 = v65;
              v66 = *(_OWORD *)(v64 + 80);
              v170 = *(_OWORD *)(v64 + 64);
              v171 = v66;
              v67 = *(double *)(v64 + 120);
              v68 = *(double *)(v64 + 88);
              v69 = *(double *)(v64 + 96);
              v70 = *(double *)(v64 + 64);
              v71 = *(double *)(v64 + 72);
              v72 = *(double *)(v64 + 104);
              v73 = OZShapeEdgePolygon::checkWindingOrder((OZShapeEdgePolygon *)v64);
              v74 = (v67 * v71 - v68 * v72) / (v68 * v67);
              if (v68 * v67 < 0.0)
                v74 = -v74;
              v75 = (v67 * v70 - v68 * v69) / (v68 * v67);
              if (v68 * v67 < 0.0)
                v75 = -v75;
              v76 = -1.0;
              if (v73)
                v76 = 1.0;
              v14 = v63;
              v77 = v63 / sqrt(v75 * v75 + v74 * v74);
              v78 = *v155;
              v79 = *v155 + 136 * v60;
              v80 = *(_OWORD *)(v79 + 80);
              v172 = *(_OWORD *)(v79 + 64);
              v173 = v80;
              v81 = -(v74 * v76) * v77;
              v82 = fabs(*(double *)(v79 + 88));
              *(double *)&v172 = *(double *)(v79 + 64) + v81 * v82;
              v83 = v76 * v75 * v77;
              *((double *)&v172 + 1) = *(double *)(v79 + 72) + v83 * v82;
              v84 = *(_OWORD *)(v79 + 112);
              v174 = *(_OWORD *)(v79 + 96);
              *(_OWORD *)v175 = v84;
              v85 = fabs(*(double *)(v79 + 120));
              *(double *)&v174 = *(double *)(v79 + 96) + v81 * v85;
              *((double *)&v174 + 1) = *(double *)(v79 + 104) + v83 * v85;
              if (v62 != 1 && *(_BYTE *)(v78 + 136 * v60 + 131))
              {
                v166 = 1;
                v167 = v177;
                v158 = v168;
                v159 = v169;
                v160 = v168;
                v161 = v169;
                v164 = 0u;
                memset(v165, 0, sizeof(v165));
                v162 = v174;
                v163 = *(_OWORD *)v175;
                v86 = *v61;
                v87 = *(_OWORD *)(*v61 - 56);
                v164 = *(_OWORD *)(*v61 - 72);
                *(_OWORD *)v165 = v87;
                if (*(_BYTE *)(v78 + 136 * v60 + 133))
                {
                  OZShape::subdivideTriangle(v152, 1, (uint64_t)a2, a3, v156, (unint64_t)&v158, (__int128 *)(v86 - 136), (double *)&v168, v63, &v193, v177 == 0, 1u);
                }
                else
                {
                  if (v86 >= *v154)
                  {
                    v88 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v158);
                  }
                  else
                  {
                    std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v86, (uint64_t)&v158);
                    v88 = v86 + 136;
                    *v61 = v86 + 136;
                  }
                  *v61 = v88;
                }
                v78 = *v155;
              }
              v89 = *v61;
              if (!*(_BYTE *)(v78 + 136 * v60 + 131))
                v153 = -252645135 * ((v89 - *v156) >> 3);
              if (v89 >= *v154)
              {
                v90 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
              }
              else
              {
                std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v89, (uint64_t)&v168);
                v90 = v89 + 136;
                *v61 = v89 + 136;
              }
              *v61 = v90;
            }
            v60 = v62;
            v59 = a4[42];
            v11 = 0xF0F0F0F0F0F0F0F1 * ((a4[43] - v59) >> 3) > v62++;
          }
          while (v11);
          v91 = *v61;
          v92 = (__int128 *)*v156;
          if (*v61 != *v156 && v153)
          {
            v93 = (char *)v92 + 136 * v153;
            v174 = 0u;
            memset(v175, 0, sizeof(v175));
            v172 = 0u;
            v173 = 0u;
            v170 = 0u;
            v171 = 0u;
            v168 = 0u;
            v169 = 0u;
            v176 = 1;
            v177 = 0;
            v164 = 0u;
            memset(v165, 0, sizeof(v165));
            v162 = 0u;
            v163 = 0u;
            v160 = 0u;
            v161 = 0u;
            v158 = 0u;
            v159 = 0u;
            v166 = 1;
            v167 = 0;
            v94 = v92[1];
            v168 = *v92;
            v169 = v94;
            v95 = v92[1];
            v170 = *v92;
            v171 = v95;
            v96 = v92[7];
            v172 = v92[6];
            v173 = v96;
            v97 = *((_OWORD *)v93 + 7);
            v174 = *((_OWORD *)v93 + 6);
            *(_OWORD *)v175 = v97;
            v98 = *(_OWORD *)(v93 - 88);
            v158 = *(_OWORD *)(v93 - 104);
            v159 = v98;
            v99 = *(_OWORD *)(v93 - 88);
            v160 = *(_OWORD *)(v93 - 104);
            v161 = v99;
            v100 = *(_OWORD *)(v91 - 56);
            v162 = *(_OWORD *)(v91 - 72);
            v163 = v100;
            v101 = *(_OWORD *)(v93 - 56);
            v164 = *(_OWORD *)(v93 - 72);
            *(_OWORD *)v165 = v101;
            if (v91 >= *v154)
            {
              v102 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
            }
            else
            {
              std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v91, (uint64_t)&v168);
              v102 = v91 + 136;
              *v61 = v102;
            }
            *v61 = v102;
            if (v102 >= *v154)
            {
              v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v158);
            }
            else
            {
              std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v154, v102, (uint64_t)&v158);
              v91 = v102 + 136;
              *v61 = v91;
            }
            *v61 = v91;
          }
        }
        if (*(_BYTE *)(a3 + 176))
        {
          if (*(_DWORD *)(a3 + 28) != 4)
            goto LABEL_137;
          v104 = a4[42];
          v103 = a4[43];
          if (v103 == v104)
            goto LABEL_137;
          v105 = 0;
          v106 = a4 + 47;
          v107 = 1;
          do
          {
            if (*(_BYTE *)(v104 + 136 * v105 + 134))
            {
              v108 = (__int128 *)(v104 + 136 * v105);
              v174 = 0u;
              memset(v175, 0, sizeof(v175));
              v172 = 0u;
              v173 = 0u;
              v170 = 0u;
              v171 = 0u;
              v168 = 0u;
              v169 = 0u;
              v176 = 1;
              v177 = 0;
              HIBYTE(v177) = *((_BYTE *)v108 + 135);
              v109 = v108[1];
              v168 = *v108;
              v169 = v109;
              v110 = v108[7];
              v170 = v108[6];
              v171 = v110;
              v111 = *((double *)v108 + 3);
              *(_QWORD *)&v110 = *((_QWORD *)v108 + 15);
              v112 = v111 * *(double *)&v110;
              v113 = (v111 * *((double *)v108 + 12) - *(double *)&v110 * *(double *)v108) / (v111 * *(double *)&v110);
              v114 = (v111 * *((double *)v108 + 13) - *(double *)&v110 * *((double *)v108 + 1))
                   / (v111
                    * *(double *)&v110);
              if (v112 >= 0.0)
                v115 = v113;
              else
                v115 = -v113;
              if (v112 >= 0.0)
                v116 = v114;
              else
                v116 = -v114;
              v117 = v14 / sqrt(v115 * v115 + v116 * v116);
              v118 = v108[7];
              v172 = v108[6];
              v173 = v118;
              v119 = fabs(*((double *)v108 + 15));
              *(double *)&v172 = *((double *)v108 + 12) + v119 * (v116 * v117);
              v120 = -(v115 * v117);
              *((double *)&v172 + 1) = *((double *)v108 + 13) + v119 * v120;
              v121 = v108[1];
              v174 = *v108;
              *(_OWORD *)v175 = v121;
              *(double *)&v121 = fabs(*((double *)v108 + 3));
              *(double *)&v174 = *(double *)v108 + v116 * v117 * *(double *)&v121;
              *((double *)&v174 + 1) = *((double *)v108 + 1) + v120 * *(double *)&v121;
              if (v91 >= *v106)
              {
                v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
              }
              else
              {
                std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                v91 += 136;
                *v61 = v91;
              }
              *v61 = v91;
              if (HIBYTE(v177))
              {
                v122 = *v155 + 136 * v105;
                v123 = *(_OWORD *)(v122 + 112);
                v172 = *(_OWORD *)(v122 + 96);
                v173 = v123;
                v124 = v117 * -v116;
                v125 = fabs(*(double *)(v122 + 120));
                *(double *)&v172 = *(double *)(v122 + 96) + v124 * v125;
                *((double *)&v172 + 1) = *(double *)(v122 + 104) + v115 * v117 * v125;
                v126 = *(_OWORD *)(v122 + 16);
                v174 = *(_OWORD *)v122;
                *(_OWORD *)v175 = v126;
                v127 = fabs(*(double *)(v122 + 24));
                *(double *)&v174 = *(double *)v122 + v124 * v127;
                *((double *)&v174 + 1) = *(double *)(v122 + 8) + v115 * v117 * v127;
                if (v91 >= *v106)
                {
                  v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
                }
                else
                {
                  std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                  v91 += 136;
                  *v61 = v91;
                }
                *v61 = v91;
              }
              v104 = a4[42];
              v103 = a4[43];
            }
            v105 = v107;
            v11 = 0xF0F0F0F0F0F0F0F1 * ((v103 - v104) >> 3) > v107++;
          }
          while (v11);
          if (*(_BYTE *)(v157 + 176))
          {
LABEL_137:
            if (*(_DWORD *)(v157 + 32) == 4)
            {
              v129 = a4[42];
              v128 = a4[43];
              if (v128 != v129)
              {
                v130 = 0;
                v131 = a4 + 47;
                v132 = 1;
                do
                {
                  if (*(_BYTE *)(v129 + 136 * v130 + 134))
                  {
                    v133 = v129 + 136 * v130;
                    v174 = 0u;
                    memset(v175, 0, sizeof(v175));
                    v172 = 0u;
                    v173 = 0u;
                    v170 = 0u;
                    v171 = 0u;
                    v168 = 0u;
                    v169 = 0u;
                    v176 = 1;
                    v177 = 0;
                    HIBYTE(v177) = *(_BYTE *)(v133 + 135);
                    v134 = *(_OWORD *)(v133 + 80);
                    v168 = *(_OWORD *)(v133 + 64);
                    v169 = v134;
                    v135 = *(_OWORD *)(v133 + 48);
                    v170 = *(_OWORD *)(v133 + 32);
                    v171 = v135;
                    v136 = *(double *)(v133 + 88);
                    *(_QWORD *)&v135 = *(_QWORD *)(v133 + 56);
                    v137 = v136 * *(double *)&v135;
                    v138 = (*(double *)&v135 * *(double *)(v133 + 64) - v136 * *(double *)(v133 + 32))
                         / (v136
                          * *(double *)&v135);
                    v139 = (*(double *)&v135 * *(double *)(v133 + 72) - v136 * *(double *)(v133 + 40))
                         / (v136
                          * *(double *)&v135);
                    if (v137 >= 0.0)
                      v140 = v138;
                    else
                      v140 = -v138;
                    if (v137 >= 0.0)
                      v141 = v139;
                    else
                      v141 = -v139;
                    v142 = v14 / sqrt(v140 * v140 + v141 * v141);
                    v143 = *(_OWORD *)(v133 + 48);
                    v172 = *(_OWORD *)(v133 + 32);
                    v173 = v143;
                    *(double *)&v143 = -(v141 * v142);
                    v144 = fabs(*(double *)(v133 + 56));
                    *(double *)&v172 = *(double *)(v133 + 32) + v144 * *(double *)&v143;
                    *((double *)&v172 + 1) = *(double *)(v133 + 40) + v144 * (v140 * v142);
                    v145 = *(_OWORD *)(v133 + 80);
                    v174 = *(_OWORD *)(v133 + 64);
                    *(_OWORD *)v175 = v145;
                    *(double *)&v145 = fabs(*(double *)(v133 + 88));
                    *(double *)&v174 = *(double *)(v133 + 64) + *(double *)&v143 * *(double *)&v145;
                    *((double *)&v174 + 1) = *(double *)(v133 + 72) + v140 * v142 * *(double *)&v145;
                    if (v91 >= *v131)
                    {
                      v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
                    }
                    else
                    {
                      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                      v91 += 136;
                      *v61 = v91;
                    }
                    *v61 = v91;
                    if (HIBYTE(v177))
                    {
                      v146 = *v155 + 136 * v130;
                      v147 = *(_OWORD *)(v146 + 48);
                      v172 = *(_OWORD *)(v146 + 32);
                      v173 = v147;
                      v148 = fabs(*(double *)(v146 + 56));
                      *(double *)&v172 = *(double *)(v146 + 32) + v141 * v142 * v148;
                      v149 = -(v140 * v142);
                      *((double *)&v172 + 1) = *(double *)(v146 + 40) + v149 * v148;
                      v150 = *(_OWORD *)(v146 + 80);
                      v174 = *(_OWORD *)(v146 + 64);
                      *(_OWORD *)v175 = v150;
                      v151 = fabs(*(double *)(v146 + 88));
                      *(double *)&v174 = *(double *)(v146 + 64) + v141 * v142 * v151;
                      *((double *)&v174 + 1) = *(double *)(v146 + 72) + v149 * v151;
                      if (v91 >= *v131)
                      {
                        v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v156, (uint64_t)&v168);
                      }
                      else
                      {
                        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 47), v91, (uint64_t)&v168);
                        v91 += 136;
                        *v61 = v91;
                      }
                      *v61 = v91;
                    }
                    v129 = a4[42];
                    v128 = a4[43];
                  }
                  v130 = v132;
                  v11 = 0xF0F0F0F0F0F0F0F1 * ((v128 - v129) >> 3) > v132++;
                }
                while (v11);
              }
            }
          }
        }
        *(_BYTE *)(v157 + 1195) = 0;
        v33 = __p;
      }
    }
    if (v33)
    {
      v187 = v33;
      operator delete(v33);
    }
  }
}

void sub_1B300EEE4(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  void *v4;

  *v2 = v1;
  v4 = (void *)STACK[0x398];
  if (STACK[0x398])
  {
    STACK[0x3A0] = (unint64_t)v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void OZShape::computeOutlinePolygons(uint64_t a1, uint64_t *a2, uint64_t a3, const CMTime *a4, uint64_t a5, double *a6, int a7, int a8, double a9, char a10, int a11, unsigned __int8 a12)
{
  double v19;
  uint64_t ValueAsInt;
  uint64_t v21;
  _QWORD **v22;
  _QWORD **v23;
  _QWORD **v24;
  _QWORD *v25;
  char *v26;
  char *v27;
  void **p_p;
  void **v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;
  _QWORD *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  uint64_t v48;
  _QWORD *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  uint64_t v59;
  _QWORD *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  _QWORD *v71;
  char *v72;
  char *v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  uint64_t v81;
  _QWORD *v82;
  char *v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  char *v100;
  char *v101;
  char *v102;
  uint64_t v103;
  _QWORD *v104;
  char *v105;
  char *v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  uint64_t v114;
  _QWORD *v115;
  char *v116;
  char *v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  char *v123;
  char *v124;
  uint64_t v125;
  double v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  double v130;
  double v131;
  double v132;
  double v133;
  double v134;
  double v135;
  uint64_t i;
  _OWORD *v137;
  __int128 v138;
  uint64_t k;
  _OWORD *v140;
  __int128 v141;
  double v142;
  uint64_t m;
  _OWORD *v144;
  __int128 v145;
  uint64_t j;
  _OWORD *v147;
  __int128 v148;
  double v149;
  double v150;
  uint64_t n;
  _OWORD *v152;
  __int128 v153;
  int v154;
  int v155;
  int v156;
  _BYTE *v157;
  uint64_t v158;
  double v159;
  BOOL v161;
  OZChannelCurve *v162;
  int v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  double v167;
  double v168;
  double v169;
  double v170;
  double v171;
  double v172;
  unint64_t v173;
  __int128 v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  double v178;
  double v179;
  double v180;
  double v181;
  double v182;
  double v183;
  double v184;
  double v185;
  double v186;
  double v187;
  double v188;
  double v189;
  double v190;
  unint64_t v191;
  uint64_t v192;
  double v193;
  uint64_t v194;
  double v195;
  double v196;
  double v197;
  double v198;
  double v199;
  uint64_t v200;
  __int128 v201;
  int v202;
  char *v203;
  char *v204;
  char *v205;
  char *FirstVertex;
  const CMTime *v207;
  char *v208;
  char *v209;
  const CMTime *v210;
  char *LastVertex;
  char *v212;
  double v213;
  int v214;
  char *Vertex;
  char *v216;
  char *v217;
  void *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  BOOL isVertexFlattened;
  BOOL v223;
  uint64_t v224;
  void *v225;
  uint64_t v226;
  uint64_t v227;
  BOOL v228;
  BOOL v229;
  uint64_t v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  int v236;
  unint64_t v237;
  uint64_t v238;
  unint64_t ii;
  unint64_t v240;
  __int128 v241;
  float64x2_t v242;
  double v243;
  double v244;
  double v245;
  double v246;
  double v247;
  double v248;
  double v249;
  double v250;
  double v251;
  double v252;
  __int128 v253;
  double v254;
  double v255;
  __int128 v256;
  unint64_t v257;
  __int128 v258;
  __int128 v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  _OWORD *v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  uint64_t v272;
  BOOL v273;
  char v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t *v279;
  uint64_t *v280;
  int v281;
  BOOL v282;
  unint64_t *v283;
  unint64_t v284;
  uint64_t v285;
  uint64_t v286;
  double v287;
  int v288;
  uint64_t v289;
  int v290;
  uint64_t v291;
  const CMTime *v292;
  int v293;
  uint64_t v294;
  uint64_t v295;
  __int128 v296;
  __int128 v297;
  uint64_t v298;
  __int128 v299;
  __int128 v300;
  uint64_t v301;
  __int128 v302;
  __int128 v303;
  uint64_t v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  uint64_t v313;
  __int128 v314;
  __int128 v315;
  __int128 v316;
  __int128 v317;
  __int128 v318;
  __int128 v319;
  __int128 v320;
  _BYTE v321[19];
  char v322;
  int v323;
  __int128 v324;
  __int128 v325;
  __int128 v326;
  __int128 v327;
  __int128 v328;
  __int128 v329;
  __int128 v330;
  _BYTE v331[19];
  char v332;
  int v333;
  __int128 v334;
  __int128 v335;
  __int128 v336;
  float64x2_t v337;
  __int128 v338;
  __int128 v339;
  __int128 v340;
  _BYTE v341[19];
  char v342;
  int v343;
  int v344;
  int v345;
  void **v346;
  void **v347;
  void **v348;
  void *v349;
  char *v350;
  unint64_t v351;
  void *v352;
  char *v353;
  unint64_t v354;
  void *__p;
  char *v356;
  unint64_t v357;
  double v358;
  uint64_t v359;
  __int128 v360;
  __int128 v361;
  __int128 v362;
  __int128 v363;
  __int128 v364;
  __int128 v365;
  __int128 v366;
  double v367;
  __int128 v368;
  __int128 v369;
  uint64_t v370;
  __int128 v371;
  __int128 v372;
  uint64_t v373;
  __int128 v374;
  __int128 v375;
  uint64_t v376;
  _BYTE v377[48];
  float64x2_t v378;
  __int128 v379;
  _BYTE v380[48];

  *(_QWORD *)&v380[40] = 0x3FF0000000000000;
  *(_QWORD *)v380 = 0x3FF0000000000000;
  *(_QWORD *)&v377[40] = 0x3FF0000000000000;
  *(_QWORD *)v377 = 0x3FF0000000000000;
  memset(&v377[8], 0, 32);
  v378 = 0u;
  v379 = 0u;
  memset(&v380[8], 0, 32);
  v376 = 0x3FF0000000000000;
  v373 = 0x3FF0000000000000;
  v370 = 0x3FF0000000000000;
  v367 = 1.0;
  v368 = 0u;
  v369 = 0u;
  v371 = 0u;
  v372 = 0u;
  v374 = 0u;
  v375 = 0u;
  v365 = 0uLL;
  *(_QWORD *)&v366 = 0;
  *((_QWORD *)&v366 + 1) = 0x3FF0000000000000;
  v363 = 0uLL;
  *(_QWORD *)&v364 = 0;
  *((_QWORD *)&v364 + 1) = 0x3FF0000000000000;
  v361 = 0uLL;
  *(_QWORD *)&v362 = 0;
  *((_QWORD *)&v362 + 1) = 0x3FF0000000000000;
  v359 = 0;
  v358 = 0.0;
  *(_QWORD *)&v360 = 0;
  *((_QWORD *)&v360 + 1) = 0x3FF0000000000000;
  v19 = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  v294 = a1;
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0);
  v293 = ValueAsInt;
  v356 = 0;
  __p = 0;
  v357 = 0;
  v353 = 0;
  v352 = 0;
  v354 = 0;
  v350 = 0;
  v349 = 0;
  v351 = 0;
  v348 = 0;
  v347 = 0;
  v346 = 0;
  v291 = a3;
  if (!*(_DWORD *)(a5 + 120) || *(_DWORD *)(a5 + 168) || (a12 & 1) != 0)
  {
    p_p = (void **)(a3 + 216);
    v348 = (void **)(a3 + 216);
    v347 = (void **)(a3 + 240);
    v29 = (void **)(a3 + 192);
    goto LABEL_158;
  }
  v292 = a4;
  v22 = (_QWORD **)(a3 + 216);
  if (&__p != (void **)(a3 + 216))
    ValueAsInt = (uint64_t)std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)&__p, *(char **)(a3 + 216), *(_QWORD *)(a3 + 224), (uint64_t)(*(_QWORD *)(a3 + 224) - *(_QWORD *)(a3 + 216)) >> 3);
  v23 = (_QWORD **)(a3 + 240);
  if (&v352 != (void **)(a3 + 240))
    ValueAsInt = (uint64_t)std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)&v352, *(char **)(a3 + 240), *(_QWORD *)(a3 + 248), (uint64_t)(*(_QWORD *)(a3 + 248) - *(_QWORD *)(a3 + 240)) >> 3);
  v24 = (_QWORD **)(a3 + 192);
  if (&v349 != (void **)(v291 + 192))
    ValueAsInt = (uint64_t)std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)&v349, *(char **)(v291 + 192), *(_QWORD *)(v291 + 200), (uint64_t)(*(_QWORD *)(v291 + 200) - *(_QWORD *)(v291 + 192)) >> 3);
  v25 = *v22;
  v26 = v356;
  if ((unint64_t)v356 >= v357)
  {
    ValueAsInt = (uint64_t)__p;
    v30 = (v356 - (_BYTE *)__p) >> 3;
    v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61)
      goto LABEL_358;
    v32 = v357 - (_QWORD)__p;
    if ((uint64_t)(v357 - (_QWORD)__p) >> 2 > v31)
      v31 = v32 >> 2;
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8)
      v33 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v33 = v31;
    if (v33)
    {
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v357, v33);
      v26 = v356;
      ValueAsInt = (uint64_t)__p;
    }
    else
    {
      v34 = 0;
    }
    v35 = &v34[8 * v30];
    v36 = &v34[8 * v33];
    *(_QWORD *)v35 = *v25;
    v27 = v35 + 8;
    while (v26 != (char *)ValueAsInt)
    {
      v37 = *((_QWORD *)v26 - 1);
      v26 -= 8;
      *((_QWORD *)v35 - 1) = v37;
      v35 -= 8;
    }
    __p = v35;
    v356 = v27;
    v357 = (unint64_t)v36;
    if (ValueAsInt)
      operator delete((void *)ValueAsInt);
  }
  else
  {
    *(_QWORD *)v356 = *v25;
    v27 = v26 + 8;
  }
  v356 = v27;
  v38 = *v23;
  v39 = v353;
  if ((unint64_t)v353 >= v354)
  {
    ValueAsInt = (uint64_t)v352;
    v41 = (v353 - (_BYTE *)v352) >> 3;
    v42 = v41 + 1;
    if ((unint64_t)(v41 + 1) >> 61)
      goto LABEL_358;
    v43 = v354 - (_QWORD)v352;
    if ((uint64_t)(v354 - (_QWORD)v352) >> 2 > v42)
      v42 = v43 >> 2;
    if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
      v44 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v44 = v42;
    if (v44)
    {
      v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v354, v44);
      v39 = v353;
      ValueAsInt = (uint64_t)v352;
    }
    else
    {
      v45 = 0;
    }
    v46 = &v45[8 * v41];
    v47 = &v45[8 * v44];
    *(_QWORD *)v46 = *v38;
    v40 = v46 + 8;
    while (v39 != (char *)ValueAsInt)
    {
      v48 = *((_QWORD *)v39 - 1);
      v39 -= 8;
      *((_QWORD *)v46 - 1) = v48;
      v46 -= 8;
    }
    v352 = v46;
    v353 = v40;
    v354 = (unint64_t)v47;
    if (ValueAsInt)
      operator delete((void *)ValueAsInt);
  }
  else
  {
    *(_QWORD *)v353 = *v38;
    v40 = v39 + 8;
  }
  v353 = v40;
  v49 = *v24;
  v50 = v350;
  if ((unint64_t)v350 >= v351)
  {
    ValueAsInt = (uint64_t)v349;
    v52 = (v350 - (_BYTE *)v349) >> 3;
    v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 61)
      goto LABEL_358;
    v54 = v351 - (_QWORD)v349;
    if ((uint64_t)(v351 - (_QWORD)v349) >> 2 > v53)
      v53 = v54 >> 2;
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
      v55 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v55 = v53;
    if (v55)
    {
      v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v351, v55);
      v50 = v350;
      ValueAsInt = (uint64_t)v349;
    }
    else
    {
      v56 = 0;
    }
    v57 = &v56[8 * v52];
    v58 = &v56[8 * v55];
    *(_QWORD *)v57 = *v49;
    v51 = v57 + 8;
    while (v50 != (char *)ValueAsInt)
    {
      v59 = *((_QWORD *)v50 - 1);
      v50 -= 8;
      *((_QWORD *)v57 - 1) = v59;
      v57 -= 8;
    }
    v349 = v57;
    v350 = v51;
    v351 = (unint64_t)v58;
    if (ValueAsInt)
      operator delete((void *)ValueAsInt);
  }
  else
  {
    *(_QWORD *)v350 = *v49;
    v51 = v50 + 8;
  }
  v350 = v51;
  v60 = *v22;
  v61 = v356;
  if ((unint64_t)v356 >= v357)
  {
    ValueAsInt = (uint64_t)__p;
    v63 = (v356 - (_BYTE *)__p) >> 3;
    v64 = v63 + 1;
    if ((unint64_t)(v63 + 1) >> 61)
      goto LABEL_358;
    v65 = v357 - (_QWORD)__p;
    if ((uint64_t)(v357 - (_QWORD)__p) >> 2 > v64)
      v64 = v65 >> 2;
    if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8)
      v66 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v66 = v64;
    if (v66)
    {
      v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v357, v66);
      v61 = v356;
      ValueAsInt = (uint64_t)__p;
    }
    else
    {
      v67 = 0;
    }
    v68 = &v67[8 * v63];
    v69 = &v67[8 * v66];
    *(_QWORD *)v68 = v60[1];
    v62 = v68 + 8;
    while (v61 != (char *)ValueAsInt)
    {
      v70 = *((_QWORD *)v61 - 1);
      v61 -= 8;
      *((_QWORD *)v68 - 1) = v70;
      v68 -= 8;
    }
    __p = v68;
    v356 = v62;
    v357 = (unint64_t)v69;
    if (ValueAsInt)
      operator delete((void *)ValueAsInt);
  }
  else
  {
    *(_QWORD *)v356 = v60[1];
    v62 = v61 + 8;
  }
  v356 = v62;
  v71 = *v23;
  v72 = v353;
  if ((unint64_t)v353 >= v354)
  {
    ValueAsInt = (uint64_t)v352;
    v74 = (v353 - (_BYTE *)v352) >> 3;
    v75 = v74 + 1;
    if ((unint64_t)(v74 + 1) >> 61)
      goto LABEL_358;
    v76 = v354 - (_QWORD)v352;
    if ((uint64_t)(v354 - (_QWORD)v352) >> 2 > v75)
      v75 = v76 >> 2;
    if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8)
      v77 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v77 = v75;
    if (v77)
    {
      v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v354, v77);
      v72 = v353;
      ValueAsInt = (uint64_t)v352;
    }
    else
    {
      v78 = 0;
    }
    v79 = &v78[8 * v74];
    v80 = &v78[8 * v77];
    *(_QWORD *)v79 = v71[1];
    v73 = v79 + 8;
    while (v72 != (char *)ValueAsInt)
    {
      v81 = *((_QWORD *)v72 - 1);
      v72 -= 8;
      *((_QWORD *)v79 - 1) = v81;
      v79 -= 8;
    }
    v352 = v79;
    v353 = v73;
    v354 = (unint64_t)v80;
    if (ValueAsInt)
      operator delete((void *)ValueAsInt);
  }
  else
  {
    *(_QWORD *)v353 = v71[1];
    v73 = v72 + 8;
  }
  v353 = v73;
  v82 = *v24;
  v83 = v350;
  if ((unint64_t)v350 >= v351)
  {
    ValueAsInt = (uint64_t)v349;
    v85 = (v350 - (_BYTE *)v349) >> 3;
    v86 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 61)
      goto LABEL_358;
    v87 = v351 - (_QWORD)v349;
    if ((uint64_t)(v351 - (_QWORD)v349) >> 2 > v86)
      v86 = v87 >> 2;
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
      v88 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v88 = v86;
    if (v88)
    {
      v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v351, v88);
      v83 = v350;
      ValueAsInt = (uint64_t)v349;
    }
    else
    {
      v89 = 0;
    }
    v90 = &v89[8 * v85];
    v91 = &v89[8 * v88];
    *(_QWORD *)v90 = v82[1];
    v84 = v90 + 8;
    while (v83 != (char *)ValueAsInt)
    {
      v92 = *((_QWORD *)v83 - 1);
      v83 -= 8;
      *((_QWORD *)v90 - 1) = v92;
      v90 -= 8;
    }
    v349 = v90;
    v350 = v84;
    v351 = (unint64_t)v91;
    if (ValueAsInt)
      operator delete((void *)ValueAsInt);
  }
  else
  {
    *(_QWORD *)v350 = v82[1];
    v84 = v83 + 8;
  }
  v350 = v84;
  v93 = *(_QWORD *)(v291 + 216);
  if ((unint64_t)(*(_QWORD *)(v291 + 224) - v93) >= 0x11)
  {
    v94 = v356;
    if ((unint64_t)v356 >= v357)
    {
      ValueAsInt = (uint64_t)__p;
      v96 = (v356 - (_BYTE *)__p) >> 3;
      v97 = v96 + 1;
      if ((unint64_t)(v96 + 1) >> 61)
        goto LABEL_358;
      v98 = v357 - (_QWORD)__p;
      if ((uint64_t)(v357 - (_QWORD)__p) >> 2 > v97)
        v97 = v98 >> 2;
      if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8)
        v99 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v99 = v97;
      if (v99)
      {
        v100 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v357, v99);
        v94 = v356;
        ValueAsInt = (uint64_t)__p;
      }
      else
      {
        v100 = 0;
      }
      v101 = &v100[8 * v96];
      v102 = &v100[8 * v99];
      *(_QWORD *)v101 = *(_QWORD *)(v93 + 16);
      v95 = v101 + 8;
      while (v94 != (char *)ValueAsInt)
      {
        v103 = *((_QWORD *)v94 - 1);
        v94 -= 8;
        *((_QWORD *)v101 - 1) = v103;
        v101 -= 8;
      }
      __p = v101;
      v356 = v95;
      v357 = (unint64_t)v102;
      if (ValueAsInt)
        operator delete((void *)ValueAsInt);
    }
    else
    {
      *(_QWORD *)v356 = *(_QWORD *)(v93 + 16);
      v95 = v94 + 8;
    }
    v356 = v95;
    v104 = *v23;
    v105 = v353;
    if ((unint64_t)v353 >= v354)
    {
      ValueAsInt = (uint64_t)v352;
      v107 = (v353 - (_BYTE *)v352) >> 3;
      v108 = v107 + 1;
      if ((unint64_t)(v107 + 1) >> 61)
        goto LABEL_358;
      v109 = v354 - (_QWORD)v352;
      if ((uint64_t)(v354 - (_QWORD)v352) >> 2 > v108)
        v108 = v109 >> 2;
      if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFF8)
        v110 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v110 = v108;
      if (v110)
      {
        v111 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v354, v110);
        v105 = v353;
        ValueAsInt = (uint64_t)v352;
      }
      else
      {
        v111 = 0;
      }
      v112 = &v111[8 * v107];
      v113 = &v111[8 * v110];
      *(_QWORD *)v112 = v104[2];
      v106 = v112 + 8;
      while (v105 != (char *)ValueAsInt)
      {
        v114 = *((_QWORD *)v105 - 1);
        v105 -= 8;
        *((_QWORD *)v112 - 1) = v114;
        v112 -= 8;
      }
      v352 = v112;
      v353 = v106;
      v354 = (unint64_t)v113;
      if (ValueAsInt)
        operator delete((void *)ValueAsInt);
    }
    else
    {
      *(_QWORD *)v353 = v104[2];
      v106 = v105 + 8;
    }
    v353 = v106;
    v115 = *v24;
    v116 = v350;
    if ((unint64_t)v350 < v351)
    {
      *(_QWORD *)v350 = v115[2];
      v117 = v116 + 8;
LABEL_156:
      v350 = v117;
      goto LABEL_157;
    }
    ValueAsInt = (uint64_t)v349;
    v118 = (v350 - (_BYTE *)v349) >> 3;
    v119 = v118 + 1;
    if (!((unint64_t)(v118 + 1) >> 61))
    {
      v120 = v351 - (_QWORD)v349;
      if ((uint64_t)(v351 - (_QWORD)v349) >> 2 > v119)
        v119 = v120 >> 2;
      if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFF8)
        v121 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v121 = v119;
      if (v121)
      {
        v122 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v351, v121);
        v116 = v350;
        ValueAsInt = (uint64_t)v349;
      }
      else
      {
        v122 = 0;
      }
      v123 = &v122[8 * v118];
      v124 = &v122[8 * v121];
      *(_QWORD *)v123 = v115[2];
      v117 = v123 + 8;
      while (v116 != (char *)ValueAsInt)
      {
        v125 = *((_QWORD *)v116 - 1);
        v116 -= 8;
        *((_QWORD *)v123 - 1) = v125;
        v123 -= 8;
      }
      v349 = v123;
      v350 = v117;
      v351 = (unint64_t)v124;
      if (ValueAsInt)
        operator delete((void *)ValueAsInt);
      goto LABEL_156;
    }
LABEL_358:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
LABEL_157:
  p_p = &__p;
  v348 = &__p;
  v347 = &v352;
  v29 = &v349;
  a3 = v291;
  a4 = v292;
LABEL_158:
  v346 = v29;
  v345 = 0;
  v344 = ((unint64_t)((_BYTE *)p_p[1] - (_BYTE *)*p_p) >> 3) - 1;
  if ((a12 & 1) != 0)
  {
    v126 = a9 * 0.25 + 1.0;
    if (a9 > 4.0)
      v126 = 2.0;
    v287 = v126;
    if (a9 > 4.0)
      a9 = a9 + -2.0;
    else
      a9 = a9 * 0.4375 + 0.25;
    ValueAsInt = OZShape::isWriteOnEffectEnabled(v294, a5);
    if ((_DWORD)ValueAsInt)
      OZShape::getWriteOnEffect(v294, a4, a5, v21, &v345, &v344, &v348, &v347, &v346);
  }
  else if (a9 < 0.0 || a9 >= 2.0)
  {
    v287 = 0.0;
    if (a9 < 0.0 && a9 > -2.0)
    {
      if (*(_DWORD *)(a5 + 8) && *(double *)(a5 + 16) < 2.0 && !*(_DWORD *)(a5 + 116))
        a9 = -1.0;
      else
        a9 = -2.0;
    }
  }
  else
  {
    if (*(_DWORD *)(a5 + 8) && *(double *)(a5 + 16) < 2.0 && !*(_DWORD *)(a5 + 116))
      a9 = 1.0;
    else
      a9 = 2.0;
    v287 = 0.0;
  }
  v127 = a3;
  v128 = *(_QWORD *)(a3 + 368);
  v129 = *(_QWORD *)(v127 + 360);
  if (*(_DWORD *)(a5 + 8))
  {
    v130 = 1.0;
    v131 = 1.0;
  }
  else
  {
    v131 = 1.0;
    v130 = 1.0;
    if (fabs(*(double *)(a5 + 224)) < 0.0000001)
      goto LABEL_193;
    OZChannel::getValueAsDouble((OZChannel *)(v294 + 13416), MEMORY[0x1E0CA2E68], 0.0);
    v130 = v132;
    OZChannel::getValueAsDouble((OZChannel *)(v294 + 13568), MEMORY[0x1E0CA2E68], 0.0);
    v131 = v133;
    if (!*(_DWORD *)(a5 + 8))
      goto LABEL_193;
  }
  if (a12)
  {
    if (*(_BYTE *)(a5 + 13))
    {
      PCMatrix44Tmpl<double>::leftShear((double *)v377, *(double *)(a5 + 264), *(long double *)(a5 + 272));
      v135 = *(double *)(a5 + 248);
      v134 = *(double *)(a5 + 256);
      if (v135 != 1.0)
      {
        *(float64x2_t *)v377 = vmulq_n_f64(*(float64x2_t *)v377, v135);
        *(float64x2_t *)&v377[16] = vmulq_n_f64(*(float64x2_t *)&v377[16], v135);
      }
      if (v134 != 1.0)
      {
        *(float64x2_t *)&v377[32] = vmulq_n_f64(*(float64x2_t *)&v377[32], v134);
        v378 = vmulq_n_f64(v378, v134);
      }
      v338 = v379;
      v339 = *(_OWORD *)v380;
      v340 = *(_OWORD *)&v380[16];
      *(_OWORD *)v341 = *(_OWORD *)&v380[32];
      v334 = *(_OWORD *)v377;
      v335 = *(_OWORD *)&v377[16];
      v336 = *(_OWORD *)&v377[32];
      v337 = v378;
      PCMatrix44Tmpl<double>::invert((double *)&v334, (double *)&v334, 0.0);
      if (&v367 != a6)
      {
        for (i = 0; i != 16; i += 4)
        {
          v137 = (_OWORD *)((char *)&v367 + i * 8);
          v138 = *(_OWORD *)&a6[i + 2];
          *v137 = *(_OWORD *)&a6[i];
          v137[1] = v138;
        }
      }
      PCMatrix44Tmpl<double>::rightMult((uint64_t)&v367, (double *)&v334);
      v288 = 1;
LABEL_198:
      v142 = v19;
      goto LABEL_216;
    }
    if (&v367 != a6)
    {
      for (j = 0; j != 16; j += 4)
      {
        v147 = (_OWORD *)((char *)&v367 + j * 8);
        v148 = *(_OWORD *)&a6[j + 2];
        *v147 = *(_OWORD *)&a6[j];
        v147[1] = v148;
      }
    }
    *(_QWORD *)&v380[40] = 0x3FF0000000000000;
    *(_QWORD *)v380 = 0x3FF0000000000000;
    *(_QWORD *)&v377[40] = 0x3FF0000000000000;
    *(_QWORD *)v377 = 0x3FF0000000000000;
    memset(&v377[8], 0, 32);
    v378 = 0u;
    v379 = 0u;
    v288 = 1;
    v142 = v19;
    memset(&v380[8], 0, 32);
    goto LABEL_216;
  }
LABEL_193:
  if (a8)
  {
    *(_QWORD *)&v380[40] = 0x3FF0000000000000;
    *(_QWORD *)v380 = 0x3FF0000000000000;
    *(_QWORD *)&v377[40] = 0x3FF0000000000000;
    *(_QWORD *)v377 = 0x3FF0000000000000;
    memset(&v377[8], 0, 32);
    v378 = 0u;
    v379 = 0u;
    memset(&v380[8], 0, 32);
    if (&v367 != a6)
    {
      for (k = 0; k != 16; k += 4)
      {
        v140 = (_OWORD *)((char *)&v367 + k * 8);
        v141 = *(_OWORD *)&a6[k + 2];
        *v140 = *(_OWORD *)&a6[k];
        v140[1] = v141;
      }
    }
    v288 = 0;
    goto LABEL_198;
  }
  ValueAsInt = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v294 + 184))(v294);
  if ((ValueAsInt & 1) != 0)
  {
    v376 = 0x3FF0000000000000;
    v373 = 0x3FF0000000000000;
    v368 = 0u;
    v369 = 0u;
    v371 = 0u;
    v372 = 0u;
    v374 = 0u;
    v375 = 0u;
    v142 = 1.0;
    v370 = 0x3FF0000000000000;
    v367 = 1.0;
    if (v377 != (_BYTE *)a6)
    {
      for (m = 0; m != 16; m += 4)
      {
        v144 = &v377[m * 8];
        v145 = *(_OWORD *)&a6[m + 2];
        *v144 = *(_OWORD *)&a6[m];
        v144[1] = v145;
      }
    }
    v288 = 0;
  }
  else
  {
    v149 = fabs(*(double *)(a5 + 248));
    v150 = fabs(*(double *)(a5 + 256));
    if (v149 != 1.0)
    {
      *(float64x2_t *)v377 = vmulq_n_f64(*(float64x2_t *)v377, v149);
      *(float64x2_t *)&v377[16] = vmulq_n_f64(*(float64x2_t *)&v377[16], v149);
    }
    if (v150 != 1.0)
    {
      *(float64x2_t *)&v377[32] = vmulq_n_f64(*(float64x2_t *)&v377[32], v150);
      v378 = vmulq_n_f64(v378, v150);
    }
    v338 = v379;
    v339 = *(_OWORD *)v380;
    v340 = *(_OWORD *)&v380[16];
    *(_OWORD *)v341 = *(_OWORD *)&v380[32];
    v334 = *(_OWORD *)v377;
    v335 = *(_OWORD *)&v377[16];
    v336 = *(_OWORD *)&v377[32];
    v337 = v378;
    PCMatrix44Tmpl<double>::invert((double *)&v334, (double *)&v334, 0.0);
    if (&v367 != a6)
    {
      for (n = 0; n != 16; n += 4)
      {
        v152 = (_OWORD *)((char *)&v367 + n * 8);
        v153 = *(_OWORD *)&a6[n + 2];
        *v152 = *(_OWORD *)&a6[n];
        v152[1] = v153;
      }
    }
    PCMatrix44Tmpl<double>::rightMult((uint64_t)&v367, (double *)&v334);
    v288 = 0;
    v142 = 1.0;
  }
LABEL_216:
  v290 = a11;
  if (a10)
  {
    a2[1] = *a2;
    if (a12)
      *(_QWORD *)(v291 + 368) = *(_QWORD *)(v291 + 360);
  }
  if (a9 < 0.0)
  {
    v154 = *(_DWORD *)(a5 + 8);
    v155 = a11;
    if (a11 == -1)
      v156 = 1;
    else
      v156 = -1;
    if (!v154)
      v155 = v156;
    v290 = v155;
    if (!v154)
      a9 = -a9;
  }
  v276 = 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3);
  v157 = v348[1];
  if (v157 != *v348)
    std::vector<OZShapeEdgePolygon>::reserve(a2, v276 + ((v157 - (_BYTE *)*v348) >> 2) - 2);
  if (a9 < 0.0)
  {
    OZShape::computeInsideFeatheringPolygons(v294, a2, (_QWORD *)v291, -a9, v21, a5, (double *)v377);
    goto LABEL_344;
  }
  v158 = v345;
  if (v345 <= v344)
  {
    v280 = (uint64_t *)(v291 + 360);
    v275 = 0xF0F0F0F0F0F0F0F1 * ((v128 - v129) >> 3);
    v284 = ((_BYTE *)v348[1] - (_BYTE *)*v348) >> 3;
    v159 = (double)v290;
    v283 = (unint64_t *)(a2 + 2);
    v161 = a7 == 1 || v293 != 1;
    v282 = v161;
    v162 = (OZChannelCurve *)(v294 + 208);
    v279 = (unint64_t *)(v291 + 376);
    if (v293 == 2)
      v163 = 1;
    else
      v163 = a7;
    v281 = v163;
    while (1)
    {
      v164 = a2[1];
      v289 = *a2;
      *(double *)&v365 = v142 * *((double *)*v348 + v158);
      *((_QWORD *)&v365 + 1) = *((_QWORD *)*v347 + v158);
      v366 = xmmword_1B304EEE0;
      PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v365, (double *)&v365);
      if (*(_DWORD *)(a5 + 168) && (OZShape::isWriteOnEffectEnabled(v294, a5) & a12 & 1) == 0)
      {
        v175 = v284 - 1;
        if (v158)
          v175 = (v158 - 1) % v284;
        *(double *)&v363 = v142 * *((double *)*v348 + v175);
        *((_QWORD *)&v363 + 1) = *((_QWORD *)*v347 + v175);
        v364 = xmmword_1B304EEE0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v363, (double *)&v363);
        v176 = (v158 + 1) % v284;
        *(double *)&v361 = v142 * *((double *)*v348 + v176);
        *((_QWORD *)&v361 + 1) = *((_QWORD *)*v347 + v176);
        v362 = xmmword_1B304EEE0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v361, (double *)&v361);
        v177 = (v158 + 2) % v284;
        v358 = v142 * *((double *)*v348 + v177);
        v359 = *((_QWORD *)*v347 + v177);
        v360 = xmmword_1B304EEE0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, &v358, &v358);
        v285 = v164;
        v178 = -((*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1)));
        if (*((double *)&v364 + 1) * *((double *)&v366 + 1) < 0.0)
        {
          v179 = -((*(double *)&v365 * *((double *)&v364 + 1) - *(double *)&v363 * *((double *)&v366 + 1))
                 / (*((double *)&v364 + 1)
                  * *((double *)&v366 + 1)));
        }
        else
        {
          v178 = (*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1));
          v179 = (*(double *)&v365 * *((double *)&v364 + 1) - *(double *)&v363 * *((double *)&v366 + 1))
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1));
        }
        v180 = (*((double *)&v366 + 1) * *(double *)&v361 - *(double *)&v365 * *((double *)&v362 + 1))
             / (*((double *)&v366 + 1)
              * *((double *)&v362 + 1));
        v181 = -((*((double *)&v366 + 1) * *((double *)&v361 + 1) - *((double *)&v365 + 1) * *((double *)&v362 + 1))
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1)));
        if (*((double *)&v366 + 1) * *((double *)&v362 + 1) < 0.0)
          v180 = -v180;
        else
          v181 = (*((double *)&v366 + 1) * *((double *)&v361 + 1) - *((double *)&v365 + 1) * *((double *)&v362 + 1))
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1));
        v182 = sqrt(v180 * v180 + v181 * v181);
        *((_QWORD *)&v334 + 1) = *((_QWORD *)&v365 + 1);
        v335 = v366;
        *((_QWORD *)&v336 + 1) = *((_QWORD *)&v361 + 1);
        v337 = (float64x2_t)v362;
        *(double *)&v334 = *(double *)&v365 / v142;
        *(double *)&v336 = *(double *)&v361 / v142;
        v339 = v362;
        v183 = -(v181 * a9) / v182 * v159;
        *(_OWORD *)v341 = v366;
        v184 = fabs(*((double *)&v362 + 1));
        v185 = a9 * v180 / v182 * v159;
        *(double *)&v338 = *(double *)&v361 / v142 + v183 * v184 / v19 / v130;
        *((double *)&v338 + 1) = *((double *)&v361 + 1) + v185 * v184 / v131;
        v186 = fabs(*((double *)&v366 + 1));
        v187 = sqrt(v179 * v179 + v178 * v178);
        v342 = 1;
        LOBYTE(v343) = v290 < 0;
        *(_WORD *)((char *)&v343 + 1) = 0;
        HIBYTE(v343) = 0;
        v341[18] = 0;
        *(_WORD *)&v341[16] = 0;
        *(double *)&v340 = *(double *)&v365 / v142 + v183 * v186 / v19 / v130;
        *((double *)&v340 + 1) = *((double *)&v365 + 1) + v185 * v186 / v131;
        v332 = 1;
        LOBYTE(v333) = v290 < 0;
        *(_WORD *)((char *)&v333 + 1) = 0;
        HIBYTE(v333) = 0;
        *((_QWORD *)&v324 + 1) = *((_QWORD *)&v363 + 1);
        v325 = v364;
        *((_QWORD *)&v326 + 1) = *((_QWORD *)&v365 + 1);
        v327 = v366;
        *(double *)&v324 = *(double *)&v363 / v142;
        *(double *)&v326 = *(double *)&v365 / v142;
        v329 = v366;
        v188 = -(v178 * a9) / v187 * v159;
        *(_OWORD *)v331 = v364;
        v189 = a9 * v179 / v187 * v159;
        *(double *)&v328 = *(double *)&v365 / v142 + v188 * v186 / v19 / v130;
        *((double *)&v328 + 1) = *((double *)&v365 + 1) + v189 * v186 / v131;
        v331[18] = 0;
        *(_WORD *)&v331[16] = 0;
        v190 = fabs(*((double *)&v364 + 1));
        *(double *)&v330 = *(double *)&v363 / v142 + v188 * v190 / v19 / v130;
        *((double *)&v330 + 1) = *((double *)&v363 + 1) + v189 * v190 / v131;
        v191 = a2[1];
        if (v191 >= a2[2])
        {
          v192 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v324);
        }
        else
        {
          std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v283, a2[1], (uint64_t)&v324);
          v192 = v191 + 136;
          a2[1] = v191 + 136;
        }
        a2[1] = v192;
        v322 = 1;
        LOBYTE(v323) = v290 < 0;
        *(_WORD *)((char *)&v323 + 1) = 0;
        HIBYTE(v323) = 0;
        *((_QWORD *)&v314 + 1) = *((_QWORD *)&v365 + 1);
        v315 = v366;
        *(double *)&v314 = *(double *)&v365 / v142;
        v316 = v314;
        v317 = v366;
        v319 = v366;
        v213 = fabs(*((double *)&v366 + 1));
        *(double *)&v318 = *(double *)&v365 / v142 + v183 * v213 / v19 / v130;
        *((double *)&v318 + 1) = *((double *)&v365 + 1) + v185 * v213 / v131;
        v321[18] = 0;
        *(_WORD *)&v321[16] = 0;
        v320 = v328;
        *(_OWORD *)v321 = v329;
        v214 = v281;
        if (!v282)
        {
          Vertex = (char *)OZChannelCurve::getVertex(v162, a4, (double)(int)vcvtmd_s64_f64(*((double *)*v346 + v158) + 0.5 + 0.0000001));
          v217 = v216;
          v218 = OZChannelCurve::getVertex(v162, a4, *((Float64 *)*v346 + v158));
          v219 = (uint64_t)v162;
          v221 = v220;
          isVertexFlattened = OZChannelCurve::isVertexFlattened(v219, Vertex, v217);
          if (v218)
            v223 = isVertexFlattened;
          else
            v223 = 0;
          if (v223 && v221 != 0)
            v214 = a7;
          else
            v214 = 1;
        }
        OZShape::subdivideTriangle(v294, v214, (uint64_t)a4, a5, a2, (unint64_t)&v314, &v324, (double *)&v334, a9, &v367, v290 > 0, a12);
        v164 = v285;
      }
      else if (v158)
      {
        v165 = 8 * v158;
        v166 = 8 * v158 - 8;
        *(double *)&v363 = v142 * *(double *)((char *)*v348 + v166);
        *((_QWORD *)&v363 + 1) = *(_QWORD *)((char *)*v347 + v166);
        v364 = xmmword_1B304EEE0;
        PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v363, (double *)&v363);
        v167 = (*(double *)&v365 * *((double *)&v364 + 1) - *(double *)&v363 * *((double *)&v366 + 1))
             / (*((double *)&v364 + 1)
              * *((double *)&v366 + 1));
        if (*((double *)&v364 + 1) * *((double *)&v366 + 1) >= 0.0)
          v168 = (*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
               / (*((double *)&v364 + 1)
                * *((double *)&v366 + 1));
        else
          v168 = -((*((double *)&v364 + 1) * *((double *)&v365 + 1) - *((double *)&v366 + 1) * *((double *)&v363 + 1))
                 / (*((double *)&v364 + 1)
                  * *((double *)&v366 + 1)));
        if (*((double *)&v364 + 1) * *((double *)&v366 + 1) < 0.0)
          v167 = -v167;
        v169 = sqrt(v167 * v167 + v168 * v168);
        *((_QWORD *)&v334 + 1) = *((_QWORD *)&v363 + 1);
        v335 = v364;
        *((_QWORD *)&v336 + 1) = *((_QWORD *)&v365 + 1);
        v337 = (float64x2_t)v366;
        *(double *)&v334 = *(double *)&v363 / v142;
        *(double *)&v336 = *(double *)&v365 / v142;
        v339 = v366;
        v170 = -(v168 * a9) / v169 * v159;
        v171 = fabs(*((double *)&v366 + 1));
        v342 = 1;
        LOBYTE(v343) = v290 < 0;
        *(_WORD *)((char *)&v343 + 1) = 0;
        HIBYTE(v343) = 0;
        v340 = 0u;
        memset(v341, 0, sizeof(v341));
        v172 = a9 * v167 / v169 * v159;
        *(double *)&v338 = *(double *)&v365 / v142 + v170 * v171 / v19 / v130;
        *((double *)&v338 + 1) = *((double *)&v365 + 1) + v172 * v171 / v131;
        if (v158 <= v345 + 1)
        {
          *(_OWORD *)v341 = v335;
          v193 = fabs(*((double *)&v335 + 1));
          *(double *)&v340 = *(double *)&v363 / v142 + v170 * v193 / v19 / v130;
          *((double *)&v340 + 1) = *((double *)&v334 + 1) + v172 * v193 / v131;
          v173 = a2[1];
        }
        else
        {
          v173 = a2[1];
          v174 = *(_OWORD *)(v173 - 56);
          v340 = *(_OWORD *)(v173 - 72);
          *(_OWORD *)v341 = v174;
        }
        if (v173 >= *v283)
        {
          v194 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v334);
        }
        else
        {
          std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v283, v173, (uint64_t)&v334);
          v194 = v173 + 136;
          a2[1] = v173 + 136;
        }
        a2[1] = v194;
        if (v344 != (_DWORD)v158)
        {
          v286 = v164;
          v330 = 0u;
          memset(v331, 0, sizeof(v331));
          v328 = 0u;
          v329 = 0u;
          v326 = 0u;
          v327 = 0u;
          v324 = 0u;
          v325 = 0u;
          v332 = 1;
          LOBYTE(v333) = v290 < 0;
          *(_WORD *)((char *)&v333 + 1) = 0;
          HIBYTE(v333) = 0;
          *(double *)&v361 = v142 * *(double *)((char *)*v348 + v165 + 8);
          *((_QWORD *)&v361 + 1) = *(_QWORD *)((char *)*v347 + v165 + 8);
          v362 = xmmword_1B304EEE0;
          PCMatrix44Tmpl<double>::transform<double>((double *)v377, (double *)&v361, (double *)&v361);
          v195 = (*(double *)&v361 * *((double *)&v366 + 1) - *(double *)&v365 * *((double *)&v362 + 1))
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1));
          v196 = (*((double *)&v366 + 1) * *((double *)&v361 + 1) - *((double *)&v362 + 1) * *((double *)&v365 + 1))
               / (*((double *)&v366 + 1)
                * *((double *)&v362 + 1));
          if (*((double *)&v366 + 1) * *((double *)&v362 + 1) < 0.0)
          {
            v196 = -v196;
            v195 = -v195;
          }
          *((_QWORD *)&v324 + 1) = *((_QWORD *)&v365 + 1);
          v325 = v366;
          *(double *)&v324 = *(double *)&v365 / v142;
          v326 = v324;
          v327 = v366;
          v329 = v366;
          v197 = sqrt(v195 * v195 + v196 * v196);
          v198 = *((double *)&v366 + 1) * (-(v196 * a9) / v197 * v159) / v19 / v130;
          v199 = *((double *)&v366 + 1) * (a9 * v195 / v197 * v159) / v131;
          *(double *)&v328 = *(double *)&v365 / v142 + v198;
          *((double *)&v328 + 1) = *((double *)&v365 + 1) + v199;
          v200 = a2[1];
          v201 = *(_OWORD *)(v200 - 56);
          v330 = *(_OWORD *)(v200 - 72);
          *(_OWORD *)v331 = v201;
          v322 = 1;
          LOBYTE(v323) = v290 < 0;
          *(_WORD *)((char *)&v323 + 1) = 0;
          HIBYTE(v323) = 0;
          *((_QWORD *)&v314 + 1) = *((_QWORD *)&v365 + 1);
          v315 = v366;
          *((_QWORD *)&v316 + 1) = *((_QWORD *)&v361 + 1);
          v317 = v362;
          *(double *)&v314 = *(double *)&v365 / v142;
          *(double *)&v316 = *(double *)&v361 / v142;
          v319 = v362;
          *(double *)&v318 = *(double *)&v361 / v142 + v198;
          *((double *)&v318 + 1) = v199 + *((double *)&v361 + 1);
          v321[18] = 0;
          *(_WORD *)&v321[16] = 0;
          v320 = v328;
          *(_OWORD *)v321 = v366;
          v202 = v281;
          if (!v282)
          {
            v203 = (char *)OZChannelCurve::getVertex(v162, a4, (double)(int)vcvtmd_s64_f64(*((double *)*v346 + v158) + 0.5 + 0.0000001));
            v205 = v204;
            FirstVertex = (char *)OZChannelCurve::getFirstVertex(v162, a4, 1);
            v207 = a4;
            v209 = v208;
            v210 = v207;
            LastVertex = (char *)OZChannelCurve::getLastVertex(v162, v207, 1);
            if (v203 == FirstVertex && v205 == v209 || v203 == LastVertex && v205 == v212)
            {
              v202 = 1;
              a4 = v210;
            }
            else
            {
              v224 = (uint64_t)v162;
              a4 = v210;
              v225 = OZChannelCurve::getVertex(v162, v210, *((Float64 *)*v346 + v158));
              v227 = v226;
              v228 = OZChannelCurve::isVertexFlattened(v224, v203, v205);
              if (v225)
                v229 = v228;
              else
                v229 = 0;
              if (v229 && v227 != 0)
                v202 = a7;
              else
                v202 = 1;
            }
          }
          v230 = a2[1];
          v231 = *(_OWORD *)(v230 - 56);
          v232 = *(_OWORD *)(v230 - 24);
          v311 = *(_OWORD *)(v230 - 40);
          v312 = v232;
          v313 = *(_QWORD *)(v230 - 8);
          v233 = *(_OWORD *)(v230 - 120);
          v234 = *(_OWORD *)(v230 - 88);
          v307 = *(_OWORD *)(v230 - 104);
          v308 = v234;
          v309 = *(_OWORD *)(v230 - 72);
          v310 = v231;
          v305 = *(_OWORD *)(v230 - 136);
          v306 = v233;
          OZShape::subdivideTriangle(v294, v202, (uint64_t)a4, a5, a2, (unint64_t)&v324, &v305, (double *)&v314, a9, &v367, v290 > 0, a12);
          v164 = v286;
        }
      }
      ValueAsInt = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v294 + 184))(v294);
      if ((v288 | ValueAsInt ^ 1) == 1)
        break;
LABEL_343:
      v273 = v158++ < v344;
      v162 = (OZChannelCurve *)(v294 + 208);
      if (!v273)
        goto LABEL_344;
    }
    v236 = *(double *)(a5 + 224) > 0.0 && v290 > 0 && *(_DWORD *)(a5 + 120) == 0;
    v237 = 0xF0F0F0F0F0F0F0F1 * ((v164 - v289) >> 3);
    v238 = *a2;
    for (ii = 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3); ; ii = 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3))
    {
      if (v237 >= ii)
        goto LABEL_343;
      v240 = v238 + 136 * v237;
      ValueAsInt = (uint64_t)OZShapeEdgePolygon::transformPoints((double *)v240, &v367);
      if (*(_DWORD *)(a5 + 168))
      {
        ValueAsInt = OZShape::isWriteOnEffectEnabled(v294, a5);
        if ((ValueAsInt & 1) == 0 && ((*(_BYTE *)(a5 + 176) == 0) & ~v236) == 0)
        {
          v340 = 0u;
          memset(v341, 0, sizeof(v341));
          v338 = 0u;
          v339 = 0u;
          v336 = 0u;
          v337 = 0u;
          v334 = 0u;
          v335 = 0u;
          v342 = 1;
          v343 = 0;
          LOBYTE(v343) = *(_BYTE *)(v238 + 136 * v237 + 132);
          v241 = *(_OWORD *)(v240 + 112);
          v334 = *(_OWORD *)(v240 + 96);
          v335 = v241;
          v242 = *(float64x2_t *)(v240 + 80);
          v336 = *(_OWORD *)(v240 + 64);
          v337 = v242;
          v243 = *(double *)(v240 + 120);
          v244 = *(double *)(v240 + 88);
          v245 = v244 * v243;
          v246 = (v243 * *(double *)(v240 + 64) - v244 * *(double *)(v240 + 96)) / (v244 * v243);
          v247 = (v243 * *(double *)(v240 + 72) - v244 * *(double *)(v240 + 104)) / (v244 * v243);
          if (v245 >= 0.0)
            v248 = v246;
          else
            v248 = -v246;
          if (v245 >= 0.0)
            v249 = v247;
          else
            v249 = -v247;
          ValueAsInt = OZShapeEdgePolygon::checkWindingOrder((OZShapeEdgePolygon *)(v238 + 136 * v237));
          v250 = -1.0;
          if ((_DWORD)ValueAsInt)
            v250 = 1.0;
          v251 = sqrt(v248 * v248 + v249 * v249);
          if (v251 <= -0.0000001 || v251 >= 0.0000001)
            break;
        }
      }
LABEL_338:
      ++v237;
      v238 = *a2;
    }
    if (v236)
      v287 = *(double *)(a5 + 224);
    v252 = v287 / v251;
    v253 = *(_OWORD *)(v240 + 80);
    v338 = *(_OWORD *)(v240 + 64);
    v339 = v253;
    v254 = v250 * -v249 * v252;
    *(double *)&v253 = fabs(*(double *)(v240 + 88));
    *(double *)&v338 = *(double *)(v240 + 64) + v254 * *(double *)&v253;
    v255 = v250 * v248 * v252;
    *((double *)&v338 + 1) = *(double *)(v240 + 72) + v255 * *(double *)&v253;
    v256 = *(_OWORD *)(v240 + 112);
    v340 = *(_OWORD *)(v240 + 96);
    *(_OWORD *)v341 = v256;
    *(double *)&v256 = fabs(*(double *)(v240 + 120));
    *(double *)&v340 = *(double *)(v240 + 96) + v254 * *(double *)&v256;
    *((double *)&v340 + 1) = *(double *)(v240 + 104) + v255 * *(double *)&v256;
    if (!v237)
      goto LABEL_332;
    if (!*(_BYTE *)(v238 + 136 * v237 + 131))
      goto LABEL_332;
    v257 = *(_QWORD *)(v291 + 368);
    if (v257 == *(_QWORD *)(v291 + 360))
      goto LABEL_332;
    v324 = v334;
    v325 = v335;
    v330 = 0u;
    memset(v331, 0, sizeof(v331));
    v332 = 1;
    v304 = 0x3FF0000000000000;
    v301 = 0x3FF0000000000000;
    v298 = 0x3FF0000000000000;
    v295 = 0x3FF0000000000000;
    v296 = 0u;
    v297 = 0u;
    v299 = 0u;
    v300 = 0u;
    v302 = 0u;
    v303 = 0u;
    v333 = v343;
    v326 = v334;
    v327 = v335;
    v328 = v340;
    v329 = *(_OWORD *)v341;
    if (v236)
    {
      v258 = *(_OWORD *)(v257 - 56);
      v330 = *(_OWORD *)(v257 - 72);
      *(_OWORD *)v331 = v258;
      OZShape::subdivideTriangle(v294, 1, (uint64_t)a4, a5, v280, (unint64_t)&v324, (__int128 *)(v257 - 136), (double *)&v334, v287, (double *)&v295, v290 < 1, 0);
    }
    else
    {
      v259 = *(_OWORD *)(v257 - 56);
      v330 = *(_OWORD *)(v257 - 72);
      *(_OWORD *)v331 = v259;
      if (v257 >= *v279)
      {
        v260 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v324);
        v261 = v291;
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, v257, (uint64_t)&v324);
        v260 = v257 + 136;
        v261 = v291;
        *(_QWORD *)(v291 + 368) = v257 + 136;
      }
      *(_QWORD *)(v261 + 368) = v260;
    }
    if (v344 == (_DWORD)v158 && v237 == 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3) - 1)
    {
      v262 = 0;
      v320 = 0u;
      memset(v321, 0, sizeof(v321));
      v318 = 0u;
      v319 = 0u;
      v316 = 0u;
      v317 = 0u;
      v314 = 0u;
      v315 = 0u;
      v322 = 1;
      v263 = *v280;
      v264 = *v280 + 136 * v275;
      v323 = 0;
      do
      {
        v265 = *(_OWORD *)(v264 + v262);
        v266 = *(_OWORD *)(v264 + v262 + 16);
        v267 = *(_OWORD *)(v264 + v262 + 48);
        v268 = (__int128 *)((char *)&v305 + v262);
        v268[2] = *(_OWORD *)(v264 + v262 + 32);
        v268[3] = v267;
        *v268 = v265;
        v268[1] = v266;
        v262 += 64;
      }
      while (v262 != 128);
      v313 = *(_QWORD *)(v263 + 136 * v275 + 128);
      LOBYTE(v323) = v333;
      v314 = v336;
      v315 = (__int128)v337;
      v316 = v305;
      v317 = v306;
      v318 = v311;
      v319 = v312;
      v320 = v338;
      *(_OWORD *)v321 = v339;
      v269 = *(_QWORD *)(v291 + 368);
      if (v269 >= *(_QWORD *)(v291 + 376))
      {
        v270 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v334);
        v271 = v291;
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, *(_QWORD *)(v291 + 368), (uint64_t)&v334);
        v270 = v269 + 136;
        v271 = v291;
        *(_QWORD *)(v291 + 368) = v270;
      }
      *(_QWORD *)(v271 + 368) = v270;
      if (v270 < *(_QWORD *)(v271 + 376))
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, v270, (uint64_t)&v314);
        goto LABEL_334;
      }
      ValueAsInt = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v314);
    }
    else
    {
LABEL_332:
      v270 = *(_QWORD *)(v291 + 368);
      if (v270 < *(_QWORD *)(v291 + 376))
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)v279, *(_QWORD *)(v291 + 368), (uint64_t)&v334);
LABEL_334:
        ValueAsInt = v270 + 136;
        v272 = v291;
        *(_QWORD *)(v291 + 368) = v270 + 136;
LABEL_337:
        *(_QWORD *)(v272 + 368) = ValueAsInt;
        goto LABEL_338;
      }
      ValueAsInt = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(v280, (uint64_t)&v334);
    }
    v272 = v291;
    goto LABEL_337;
  }
LABEL_344:
  if (a8)
  {
    v274 = v288;
    if (!*(_DWORD *)(a5 + 168))
      v274 = 1;
    if ((v274 & 1) == 0)
      OZShape::transformOutlinePolygonList(ValueAsInt, a2, v276, &v367);
  }
  if (v349)
  {
    v350 = (char *)v349;
    operator delete(v349);
  }
  if (v352)
  {
    v353 = (char *)v352;
    operator delete(v352);
  }
  if (__p)
  {
    v356 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1B3010FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  uint64_t v43;
  void *v45;
  void *v46;
  void *v47;

  *(_QWORD *)(a43 + 368) = v43;
  v45 = (void *)STACK[0x418];
  if (STACK[0x418])
  {
    STACK[0x420] = (unint64_t)v45;
    operator delete(v45);
  }
  v46 = (void *)STACK[0x430];
  if (STACK[0x430])
  {
    STACK[0x438] = (unint64_t)v46;
    operator delete(v46);
  }
  v47 = (void *)STACK[0x448];
  if (STACK[0x448])
  {
    STACK[0x450] = (unint64_t)v47;
    operator delete(v47);
  }
  _Unwind_Resume(a1);
}

void OZShape::computeRoundCaps(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10, double *a11, char a12)
{
  __int128 v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  BOOL v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  unint64_t v34;
  float64x2_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 *v41;
  __int128 v42;
  __int128 v43;
  __int128 v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  float64x2_t v57;
  __int128 v58;
  __int128 v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  float64x2_t v70;
  __int128 v71;
  __int128 v72;
  float64x2_t v73;
  __int128 v76[4];
  float64x2_t v77;
  __int128 v78;
  float64x2_t v79;
  __int128 v80;
  uint64_t v81;
  float64x2_t v82;
  __int128 v83;
  float64x2_t v84;
  __int128 v85;
  float64x2_t v86;
  __int128 v87;
  float64x2_t v88;
  _BYTE v89[24];

  v88 = 0u;
  memset(v89, 0, 19);
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v89[19] = 1;
  *(_DWORD *)&v89[20] = 0;
  if ((a12 & 1) != 0)
  {
    v22 = *(_OWORD *)(a6 + 16);
    v82 = *(float64x2_t *)a6;
    v83 = v22;
    v84 = v82;
    v85 = v22;
    v23 = *(double *)(a6 + 56);
    *(_QWORD *)&v22 = *(_QWORD *)(a6 + 24);
    v24 = *(double *)&v22 * *(double *)(a6 + 32) - v23 * *(double *)a6;
    v25 = *(double *)&v22 * *(double *)(a6 + 40);
    *(double *)&v22 = v23 * *(double *)&v22;
    v26 = v24 / *(double *)&v22;
    v27 = (v25 - v23 * *(double *)(a6 + 8)) / *(double *)&v22;
    v28 = *(double *)&v22 < 0.0;
    if (*(double *)&v22 >= 0.0)
      v29 = v26;
    else
      v29 = -v26;
    if (v28)
      v30 = -v27;
    else
      v30 = v27;
    v31 = sqrt(v29 * v29 + v30 * v30);
    v32 = -v29 / v31 * a9;
    v33 = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
    v34 = 0;
    v35.f64[0] = v32 / v33;
    *(_WORD *)&v89[20] = 256;
    v36 = *(_OWORD *)(a6 + 112);
    v86 = *(float64x2_t *)(a6 + 96);
    v87 = v36;
    v35.f64[1] = -v30 / v31 * a9;
    v37 = *(_OWORD *)(a6 + 16);
    v73 = v35;
    v88 = vaddq_f64(*(float64x2_t *)a6, vmulq_n_f64(v35, fabs(*(double *)(a6 + 24))));
    *(_OWORD *)v89 = v37;
    do
    {
      v38 = *(__int128 *)((char *)&v82 + v34);
      v39 = *(__int128 *)((char *)&v82 + v34 + 16);
      v40 = *(__int128 *)((char *)&v85 + v34);
      v41 = &v76[v34 / 0x10];
      v41[2] = *(__int128 *)((char *)&v84 + v34);
      v41[3] = v40;
      *v41 = v38;
      v41[1] = v39;
      v34 += 64;
    }
    while (v34 != 128);
    v81 = *(_QWORD *)&v89[16];
    v77 = v88;
    v78 = *(_OWORD *)v89;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a2, (unint64_t)&v82, v76, (double *)a6, a9, a11, 257, 1u);
    v89[20] = 1;
    v42 = *(_OWORD *)(a8 + 16);
    v82 = *(float64x2_t *)a8;
    v83 = v42;
    v84 = v82;
    v85 = v42;
    v43 = *(_OWORD *)(a8 + 112);
    v86 = *(float64x2_t *)(a8 + 96);
    v87 = v43;
    v88 = v82;
    *(_OWORD *)v89 = v42;
    v88 = vaddq_f64(v82, vmulq_n_f64(v73, fabs(*(double *)(a8 + 24))));
    v76[2] = (__int128)v82;
    v76[3] = v42;
    v76[0] = (__int128)v82;
    v76[1] = v42;
    v81 = *(_QWORD *)&v89[16];
    v79 = v88;
    v80 = v42;
    v77 = v88;
    v78 = v42;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a3, (unint64_t)&v82, v76, (double *)a8, a9, a11, 256, 1u);
    *(_BYTE *)(a6 + 133) = 1;
    *(_BYTE *)(a8 + 133) = 1;
  }
  else
  {
    v45 = *(_OWORD *)(a7 + 48);
    v82 = *(float64x2_t *)(a7 + 32);
    v83 = v45;
    v84 = v82;
    v85 = v45;
    v46 = *(double *)(a7 + 56);
    *(_QWORD *)&v45 = *(_QWORD *)(a7 + 24);
    v47 = *(double *)(a7 + 40);
    v48 = *(double *)(a7 + 8);
    v49 = *(double *)&v45 * *(double *)(a7 + 32) - v46 * *(double *)a7;
    *(_WORD *)&v89[20] = 256;
    v50 = *(double *)&v45 * v47;
    v51 = v46 * *(double *)&v45;
    v52 = v49 / v51;
    v53 = (v50 - v46 * v48) / v51;
    if (v51 >= 0.0)
      v54 = v53;
    else
      v54 = -v53;
    if (v51 >= 0.0)
      v55 = v52;
    else
      v55 = -v52;
    v56 = sqrt(v55 * v55 + v54 * v54);
    v57.f64[0] = v55 / v56 * a9 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
    v57.f64[1] = v54 / v56 * a9;
    v58 = *(_OWORD *)(a7 + 48);
    v86 = vaddq_f64(*(float64x2_t *)(a7 + 32), vmulq_n_f64(v57, fabs(*(double *)(a7 + 56))));
    v87 = v58;
    v59 = *(_OWORD *)(a7 + 80);
    v88 = *(float64x2_t *)(a7 + 64);
    *(_OWORD *)v89 = v59;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a2, (unint64_t)&v82, (__int128 *)a7, (double *)a7, a9, a11, 1, 1u);
    v60 = *(double *)(a10 + 56);
    v61 = *(double *)(a10 + 24);
    v62 = v61 * *(double *)(a10 + 32) - v60 * *(double *)a10;
    v63 = v61 * *(double *)(a10 + 40);
    v64 = v60 * v61;
    v65 = v62 / v64;
    v66 = (v63 - v60 * *(double *)(a10 + 8)) / v64;
    if (v64 >= 0.0)
      v67 = v66;
    else
      v67 = -v66;
    if (v64 >= 0.0)
      v68 = v65;
    else
      v68 = -v65;
    v69 = sqrt(v68 * v68 + v67 * v67);
    v70.f64[0] = v68 / v69 * a9 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
    v89[20] = 1;
    v71 = *(_OWORD *)(a10 + 48);
    v82 = *(float64x2_t *)(a10 + 32);
    v83 = v71;
    v84 = v82;
    v85 = v71;
    v70.f64[1] = v67 / v69 * a9;
    v86 = vaddq_f64(v82, vmulq_n_f64(v70, fabs(*(double *)(a10 + 56))));
    v87 = v71;
    v72 = *(_OWORD *)(a10 + 80);
    v88 = *(float64x2_t *)(a10 + 64);
    *(_OWORD *)v89 = v72;
    OZShape::subdivideTriangle(a1, 1, a4, a5, a3, (unint64_t)&v82, (__int128 *)a10, (double *)a10, a9, a11, 0, 1u);
    *(_BYTE *)(a7 + 133) = 1;
    *(_BYTE *)(a10 + 133) = 1;
  }
}

unint64_t OZShape::computeBevelCaps(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, double *a6, uint64_t a7, double *a8, uint64_t a9, char a10)
{
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  double v27;
  double v28;
  uint64_t v29;
  unint64_t result;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  __int128 v43;
  double v44;
  __int128 v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  __int128 v49;
  double v50;
  double v51;
  double v52;
  __int128 v53;
  unint64_t v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  _BYTE v62[19];
  char v63;
  int v64;

  v61 = 0u;
  memset(v62, 0, sizeof(v62));
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v63 = 1;
  v64 = 0;
  if ((a10 & 1) != 0)
  {
    v13 = a8[15];
    v14 = a8[11];
    v15 = v14 * v13;
    v16 = (v13 * a8[8] - v14 * a8[12]) / (v14 * v13);
    v17 = (v13 * a8[9] - v14 * a8[13]) / (v14 * v13);
    if (v15 < 0.0)
    {
      v17 = -v17;
      v16 = -v16;
    }
    v18 = sqrt(v16 * v16 + v17 * v17);
    v19 = -v16 / v18 * a1;
    v20 = -v17 / v18 * a1;
    LOWORD(v64) = 257;
    v21 = *((_OWORD *)a8 + 1);
    v55 = *(_OWORD *)a8;
    v56 = v21;
    v57 = v55;
    v58 = v21;
    v22 = *((_OWORD *)a8 + 7);
    v59 = *((_OWORD *)a8 + 6);
    v60 = v22;
    v23 = *((_OWORD *)a8 + 1);
    v61 = *(_OWORD *)a8;
    *(_OWORD *)v62 = v23;
    *(double *)&v22 = fabs(a8[3]);
    *(double *)&v23 = *a8 + v19 * *(double *)&v22;
    *(double *)&v22 = a8[1] + v20 * *(double *)&v22;
    *(_QWORD *)&v61 = v23;
    *((_QWORD *)&v61 + 1) = v22;
    v24 = *a4;
    *(_BYTE *)(v24 + 133) = 1;
    std::vector<OZShapeEdgePolygon>::insert(a4, v24, (unint64_t)&v55);
    LOBYTE(v64) = 0;
    v25 = *((_OWORD *)a6 + 1);
    v55 = *(_OWORD *)a6;
    v56 = v25;
    v57 = v55;
    v58 = v25;
    v26 = *((_OWORD *)a6 + 7);
    v59 = *((_OWORD *)a6 + 6);
    v60 = v26;
    v61 = v55;
    *(_OWORD *)v62 = v25;
    v27 = fabs(a6[3]);
    *(double *)&v25 = *a6 + v19 * v27;
    v28 = a6[1] + v20 * v27;
    *(_QWORD *)&v61 = v25;
    *((double *)&v61 + 1) = v28;
    v29 = *a3;
    *(_BYTE *)(v29 + 133) = 1;
    return std::vector<OZShapeEdgePolygon>::insert(a3, v29, (unint64_t)&v55);
  }
  else
  {
    v32 = *(double *)(a7 + 56);
    v33 = *(double *)(a7 + 24);
    v34 = *(double *)(a7 + 32);
    v35 = v32 * v33;
    v36 = (v33 * v34 - v32 * *(double *)a7) / (v32 * v33);
    v37 = *(double *)(a7 + 40);
    v38 = (v33 * v37 - v32 * *(double *)(a7 + 8)) / (v32 * v33);
    if (v35 >= 0.0)
    {
      v39 = v36;
    }
    else
    {
      v38 = -v38;
      v39 = -v36;
    }
    v40 = sqrt(v39 * v39 + v38 * v38);
    v41 = v39 / v40 * a1;
    v42 = v38 / v40 * a1;
    LOWORD(v64) = 256;
    v43 = *(_OWORD *)(a7 + 48);
    v55 = *(_OWORD *)(a7 + 32);
    v56 = v43;
    v57 = v55;
    v58 = v43;
    v60 = v43;
    v44 = fabs(v32);
    *(double *)&v59 = v34 + v44 * v41;
    *((double *)&v59 + 1) = v37 + v44 * v42;
    v45 = *(_OWORD *)(a7 + 80);
    v61 = *(_OWORD *)(a7 + 64);
    *(_OWORD *)v62 = v45;
    v46 = a3[2];
    v47 = a3[1];
    *(_BYTE *)(v47 - 3) = 1;
    if (v47 >= v46)
    {
      v48 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v55);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v47, (uint64_t)&v55);
      v48 = v47 + 136;
      a3[1] = v47 + 136;
    }
    a3[1] = v48;
    v49 = *(_OWORD *)(a9 + 48);
    v55 = *(_OWORD *)(a9 + 32);
    v56 = v49;
    v57 = v55;
    v58 = v49;
    v59 = v55;
    v60 = v49;
    v50 = fabs(*(double *)(a9 + 56));
    v51 = *(double *)(a9 + 32);
    v52 = *(double *)(a9 + 40);
    LOBYTE(v64) = 1;
    *(double *)&v59 = v51 + v41 * v50;
    *((double *)&v59 + 1) = v52 + v42 * v50;
    v53 = *(_OWORD *)(a9 + 80);
    v61 = *(_OWORD *)(a9 + 64);
    *(_OWORD *)v62 = v53;
    v54 = a4[1];
    *(_BYTE *)(v54 - 3) = 1;
    if (v54 >= a4[2])
    {
      result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v55);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v54, (uint64_t)&v55);
      result = v54 + 136;
      a4[1] = v54 + 136;
    }
    a4[1] = result;
  }
  return result;
}

void sub_1B3011818(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B3011820(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unint64_t OZShape::computeArrowCaps(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, double *a7, uint64_t a8, __int128 *a9, uint64_t a10, char a11)
{
  __int128 *v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  __int128 v34;
  __int128 v35;
  double v36;
  double v37;
  double v39;
  double v40;
  __int128 *v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  __int128 *v54;
  double v55;
  double v56;
  double v57;
  __int128 v58;
  double v59;
  __int128 v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  double v64;
  double v65;
  __int128 v66;
  __int128 v67;
  double v68;
  double v69;
  double v70;
  __int128 v71;
  double v72;
  double v73;
  __int128 v74;
  double v75;
  double v76;
  double v77;
  uint64_t v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  __int128 v85;
  __int128 v86;
  double v87;
  double v88;
  double v89;
  BOOL v90;
  double v91;
  __int128 v92;
  double v93;
  double v94;
  double v95;
  __int128 v96;
  unint64_t v97;
  unint64_t v98;
  double v99;
  BOOL v100;
  double v101;
  __int128 v102;
  __int128 v103;
  double v104;
  double v105;
  double v106;
  __int128 v107;
  double v108;
  double v109;
  double v110;
  __int128 v111;
  double v112;
  double v113;
  double v114;
  uint64_t v115;
  unint64_t result;
  __int128 v117;
  double v118;
  double v119;
  double v120;
  __int128 *v121;
  double v122;
  double v123;
  double v124;
  __int128 *v125;
  double v126;
  double v127;
  double v128;
  __int128 v129;
  double v130;
  __int128 v131;
  unint64_t v132;
  unint64_t v133;
  double v134;
  BOOL v135;
  double v136;
  __int128 v137;
  double v138;
  double v139;
  double v140;
  double v141;
  __int128 v142;
  unint64_t v143;
  unint64_t v144;
  __int128 v145;
  double v146;
  double v147;
  double v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  _BYTE v156[19];
  char v157;
  int v158;

  v155 = 0u;
  memset(v156, 0, sizeof(v156));
  v153 = 0u;
  v154 = 0u;
  v151 = 0u;
  v152 = 0u;
  v149 = 0u;
  v150 = 0u;
  v157 = 1;
  v158 = 0;
  if ((a11 & 1) == 0)
  {
    v39 = *(double *)(a8 + 56);
    v40 = *(double *)(a8 + 24);
    v41 = (__int128 *)(a8 + 32);
    v42 = *(double *)(a8 + 32);
    v43 = v39 * v40;
    v44 = (v40 * v42 - v39 * *(double *)a8) / (v39 * v40);
    v45 = *(double *)(a8 + 40);
    v46 = (v40 * v45 - v39 * *(double *)(a8 + 8)) / (v39 * v40);
    if (v43 >= 0.0)
    {
      v47 = v44;
    }
    else
    {
      v46 = -v46;
      v47 = -v44;
    }
    v48 = sqrt(v47 * v47 + v46 * v46);
    v49 = *(double *)(a6 + 104);
    v50 = *(double *)(a6 + 96) + 1.0;
    v51 = v50 * (v47 / v48 * a1);
    v52 = v50 * (v46 / v48 * a1);
    v53 = *(double *)(a8 + 88);
    v54 = (__int128 *)(a8 + 64);
    v55 = *(double *)(a8 + 64);
    v56 = *(double *)(a8 + 72);
    v57 = v49 + 1.0;
    LOWORD(v158) = 256;
    if (fabs(v49) >= 0.0000001)
    {
      v89 = (v39 * v55 - v42 * v53) / (v39 * v53);
      v90 = v39 * v53 < 0.0;
      if (v39 * v53 < 0.0)
        v89 = -v89;
      v91 = (v39 * v56 - v45 * v53) / (v39 * v53);
      if (v90)
        v91 = -v91;
      v92 = *(_OWORD *)(a8 + 48);
      v149 = *v41;
      v150 = v92;
      v152 = v92;
      v93 = fabs(v39);
      *(double *)&v151 = v42 + v93 * (v51 * 0.5);
      *((double *)&v151 + 1) = v45 + v93 * (v52 * 0.5);
      v154 = v92;
      v94 = v57 * v89;
      v95 = v57 * v91;
      *(double *)&v153 = v42 + v93 * (v57 * v89);
      *((double *)&v153 + 1) = v45 + v93 * (v57 * v91);
      v96 = *(_OWORD *)(a8 + 80);
      v155 = *v54;
      *(_OWORD *)v156 = v96;
      v97 = a3[1];
      if (v97 >= a3[2])
      {
        v98 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v149);
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), a3[1], (uint64_t)&v149);
        v98 = v97 + 136;
        a3[1] = v98;
      }
      a3[1] = v98;
      v117 = v41[1];
      v149 = *v41;
      v150 = v117;
      v118 = fabs(*(double *)(a8 + 56));
      v119 = *(double *)(a8 + 32);
      v120 = *(double *)(a8 + 40);
      *(double *)&v149 = v119 + v51 * 0.5 * v118;
      *((double *)&v149 + 1) = v120 + v52 * 0.5 * v118;
      v152 = v117;
      v151 = v149;
      v154 = v117;
      *(double *)&v153 = v119 + v51 * v118;
      *((double *)&v153 + 1) = v120 + v52 * v118;
      *(_OWORD *)v156 = v41[1];
      *(double *)&v155 = v119 + v94 * v118;
      *((double *)&v155 + 1) = v120 + v95 * v118;
      *(_BYTE *)(v98 - 3) = 1;
      if (v98 < a3[2])
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v98, (uint64_t)&v149);
        v63 = v98 + 136;
        goto LABEL_35;
      }
    }
    else
    {
      v58 = *(_OWORD *)(a8 + 48);
      v149 = *v41;
      v150 = v58;
      v151 = v149;
      v152 = v58;
      v154 = v58;
      v59 = fabs(v39);
      *(double *)&v153 = v42 + v59 * v51;
      *((double *)&v153 + 1) = v45 + v59 * v52;
      v60 = *(_OWORD *)(a8 + 80);
      v155 = *v54;
      *(_OWORD *)v156 = v60;
      v61 = a3[2];
      v62 = a3[1];
      *(_BYTE *)(v62 - 3) = 1;
      if (v62 < v61)
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v62, (uint64_t)&v149);
        v63 = v62 + 136;
LABEL_35:
        a3[1] = v63;
        goto LABEL_37;
      }
    }
    v63 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v149);
LABEL_37:
    a3[1] = v63;
    v121 = (__int128 *)(a10 + 64);
    v122 = *(double *)(a10 + 64);
    v123 = *(double *)(a10 + 88);
    v124 = *(double *)(a10 + 56);
    v125 = (__int128 *)(a10 + 32);
    v126 = *(double *)(a10 + 32);
    v127 = *(double *)(a10 + 72);
    v128 = *(double *)(a10 + 40);
    LOBYTE(v158) = 1;
    if (fabs(*(double *)(a6 + 104)) >= 0.0000001)
    {
      v134 = (v124 * v122 - v123 * v126) / (v123 * v124);
      v135 = v123 * v124 < 0.0;
      if (v123 * v124 < 0.0)
        v134 = -v134;
      v136 = (v124 * v127 - v123 * v128) / (v123 * v124);
      if (v135)
        v136 = -v136;
      v137 = *(_OWORD *)(a10 + 48);
      v149 = *v125;
      v150 = v137;
      v152 = v137;
      v138 = fabs(v124);
      *(double *)&v151 = v126 + v51 * 0.5 * v138;
      *((double *)&v151 + 1) = v52 * 0.5 * v138 + v128;
      v154 = v137;
      v139 = v57 * v134;
      v140 = v138 * (v57 * v134);
      v141 = v57 * v136;
      *(double *)&v153 = v126 + v140;
      *((double *)&v153 + 1) = v128 + v138 * v141;
      v142 = *(_OWORD *)(a10 + 80);
      v155 = *v121;
      *(_OWORD *)v156 = v142;
      v143 = a4[1];
      if (v143 >= a4[2])
      {
        v144 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v149);
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), a4[1], (uint64_t)&v149);
        v144 = v143 + 136;
        a4[1] = v144;
      }
      a4[1] = v144;
      v145 = *(_OWORD *)(a10 + 48);
      v149 = *v125;
      v150 = v145;
      v146 = fabs(*(double *)(a10 + 56));
      v147 = *(double *)(a10 + 32);
      v148 = *(double *)(a10 + 40);
      *(double *)&v149 = v147 + v51 * 0.5 * v146;
      *((double *)&v149 + 1) = v148 + v52 * 0.5 * v146;
      v152 = v145;
      v151 = v149;
      v154 = v145;
      *(double *)&v153 = v147 + v51 * v146;
      *((double *)&v153 + 1) = v148 + v52 * v146;
      *(_OWORD *)v156 = *(_OWORD *)(a10 + 48);
      *(double *)&v155 = v147 + v139 * v146;
      *((double *)&v155 + 1) = v148 + v141 * v146;
      *(_BYTE *)(v144 - 3) = 1;
      if (v144 < a4[2])
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v144, (uint64_t)&v149);
        result = v144 + 136;
        goto LABEL_49;
      }
    }
    else
    {
      v129 = *(_OWORD *)(a10 + 48);
      v149 = *v125;
      v150 = v129;
      v151 = v149;
      v152 = v129;
      v154 = v129;
      v130 = fabs(v124);
      *(double *)&v153 = v126 + v51 * v130;
      *((double *)&v153 + 1) = v52 * v130 + v128;
      v131 = *(_OWORD *)(a10 + 80);
      v155 = *v121;
      *(_OWORD *)v156 = v131;
      v132 = a4[2];
      v133 = a4[1];
      *(_BYTE *)(v133 - 3) = 1;
      if (v133 < v132)
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v133, (uint64_t)&v149);
        result = v133 + 136;
LABEL_49:
        a4[1] = result;
LABEL_51:
        a4[1] = result;
        return result;
      }
    }
    result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v149);
    goto LABEL_51;
  }
  v16 = a9 + 6;
  v17 = *((double *)a9 + 11);
  v18 = *((double *)a9 + 15);
  v19 = v17 * v18;
  v21 = *((double *)a9 + 7);
  v20 = *((double *)a9 + 8);
  v22 = (v18 * v20 - v17 * *((double *)a9 + 12)) / (v17 * v18);
  v23 = *((double *)a9 + 9);
  v24 = (v18 * v23 - v17 * *((double *)a9 + 13)) / (v17 * v18);
  if (v19 >= 0.0)
  {
    v25 = v22;
  }
  else
  {
    v24 = -v24;
    v25 = -v22;
  }
  v26 = sqrt(v25 * v25 + v24 * v24);
  v27 = *(double *)(a6 + 104);
  v28 = *(double *)(a6 + 96) + 1.0;
  v29 = v28 * (-v25 / v26 * a1);
  v30 = v28 * (-v24 / v26 * a1);
  v31 = *((double *)a9 + 4);
  v32 = *((double *)a9 + 5);
  v33 = v27 + 1.0;
  LOWORD(v158) = 257;
  if (fabs(v27) >= 0.0000001)
  {
    v64 = (v23 * v21 - v17 * v32) / (v17 * v21);
    if (v17 * v21 < 0.0)
      v64 = -v64;
    v65 = (v20 * v21 - v17 * v31) / (v17 * v21);
    if (v17 * v21 < 0.0)
      v65 = -v65;
    v67 = a9[1];
    v149 = *a9;
    v66 = v149;
    v150 = v67;
    v68 = fabs(*((double *)a9 + 3));
    v69 = *(double *)a9;
    v70 = *((double *)a9 + 1);
    *(double *)&v149 = *(double *)a9 + v29 * 0.5 * v68;
    *((double *)&v149 + 1) = v70 + v30 * 0.5 * v68;
    v151 = v66;
    v152 = v67;
    v71 = a9[7];
    v153 = *v16;
    v154 = v71;
    *(_OWORD *)v156 = v67;
    v72 = v33 * v65;
    v73 = v33 * v64;
    *(double *)&v155 = v69 + v33 * v65 * v68;
    *((double *)&v155 + 1) = v70 + v33 * v64 * v68;
    std::vector<OZShapeEdgePolygon>::insert(a4, *a4, (unint64_t)&v149);
    v74 = a9[1];
    v149 = *a9;
    v150 = v74;
    v75 = fabs(*((double *)a9 + 3));
    v76 = *(double *)a9;
    v77 = *((double *)a9 + 1);
    *(double *)&v149 = *(double *)a9 + v29 * 0.5 * v75;
    *((double *)&v149 + 1) = v77 + v30 * 0.5 * v75;
    v152 = v74;
    v151 = v149;
    v154 = v74;
    *(double *)&v153 = v76 + v72 * v75;
    *((double *)&v153 + 1) = v77 + v73 * v75;
    *(_OWORD *)v156 = v74;
    *(double *)&v155 = v76 + v29 * v75;
    *((double *)&v155 + 1) = v77 + v30 * v75;
  }
  else
  {
    v34 = a9[1];
    v149 = *a9;
    v150 = v34;
    v151 = v149;
    v152 = v34;
    v35 = a9[7];
    v153 = *v16;
    v154 = v35;
    v155 = v149;
    *(_OWORD *)v156 = v34;
    v36 = fabs(*((double *)a9 + 3));
    *(double *)&v34 = *(double *)a9 + v29 * v36;
    v37 = *((double *)a9 + 1) + v30 * v36;
    *(_QWORD *)&v155 = v34;
    *((double *)&v155 + 1) = v37;
  }
  v78 = *a4;
  *(_BYTE *)(v78 + 133) = 1;
  std::vector<OZShapeEdgePolygon>::insert(a4, v78, (unint64_t)&v149);
  v79 = a7[11];
  v80 = a7[7];
  v81 = a7[8];
  v82 = a7[9];
  v83 = a7[4];
  v84 = a7[5];
  LOBYTE(v158) = 0;
  if (fabs(*(double *)(a6 + 104)) >= 0.0000001)
  {
    v99 = (v80 * v82 - v79 * v84) / (v79 * v80);
    v100 = v79 * v80 < 0.0;
    if (v79 * v80 < 0.0)
      v99 = -v99;
    v101 = (v80 * v81 - v79 * v83) / (v79 * v80);
    if (v100)
      v101 = -v101;
    v103 = *((_OWORD *)a7 + 1);
    v149 = *(_OWORD *)a7;
    v102 = v149;
    v150 = v103;
    v104 = fabs(a7[3]);
    v105 = *a7;
    v106 = a7[1];
    *(double *)&v149 = *a7 + v29 * 0.5 * v104;
    *((double *)&v149 + 1) = v106 + v30 * 0.5 * v104;
    v151 = v102;
    v152 = v103;
    v107 = *((_OWORD *)a7 + 7);
    v153 = *((_OWORD *)a7 + 6);
    v154 = v107;
    *(_OWORD *)v156 = v103;
    v108 = v33 * v101;
    v109 = v105 + v33 * v101 * v104;
    v110 = v33 * v99;
    *(double *)&v155 = v109;
    *((double *)&v155 + 1) = v106 + v110 * v104;
    std::vector<OZShapeEdgePolygon>::insert(a3, *a3, (unint64_t)&v149);
    v111 = *((_OWORD *)a7 + 1);
    v149 = *(_OWORD *)a7;
    v150 = v111;
    v112 = fabs(a7[3]);
    v113 = *a7;
    v114 = a7[1];
    *(double *)&v149 = *a7 + v29 * 0.5 * v112;
    *((double *)&v149 + 1) = v114 + v30 * 0.5 * v112;
    v152 = v111;
    v151 = v149;
    v154 = v111;
    *(double *)&v153 = v113 + v108 * v112;
    *((double *)&v153 + 1) = v114 + v110 * v112;
    *(_OWORD *)v156 = v111;
    *(double *)&v155 = v113 + v29 * v112;
    *((double *)&v155 + 1) = v114 + v30 * v112;
  }
  else
  {
    v85 = *((_OWORD *)a7 + 1);
    v149 = *(_OWORD *)a7;
    v150 = v85;
    v151 = v149;
    v152 = v85;
    v86 = *((_OWORD *)a7 + 7);
    v153 = *((_OWORD *)a7 + 6);
    v154 = v86;
    v155 = v149;
    *(_OWORD *)v156 = v85;
    v87 = fabs(a7[3]);
    *(double *)&v85 = *a7 + v29 * v87;
    v88 = a7[1] + v30 * v87;
    *(_QWORD *)&v155 = v85;
    *((double *)&v155 + 1) = v88;
  }
  v115 = *a3;
  *(_BYTE *)(v115 + 133) = 1;
  return std::vector<OZShapeEdgePolygon>::insert(a3, v115, (unint64_t)&v149);
}

void sub_1B301210C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B3012118(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B3012120(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B301212C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unint64_t OZShape::computeNormalCaps(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, double *a6, uint64_t a7, double *a8, uint64_t a9, char a10, char a11)
{
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  BOOL v20;
  double v21;
  double v22;
  __int128 v23;
  double v24;
  double v25;
  __int128 v26;
  double v27;
  double v28;
  __int128 v29;
  double v30;
  double v31;
  double v32;
  __int128 v33;
  __int128 v34;
  double v35;
  double v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  double v40;
  unint64_t v41;
  _BYTE *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  __int128 v55;
  __int128 v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  __int128 v65;
  __int128 v66;
  double v67;
  __int128 v68;
  __int128 v69;
  double v70;
  double v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  double v76;
  double v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  _BYTE *v81;
  unint64_t v82;
  uint64_t v83;
  _BYTE *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t result;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  _BYTE v99[19];
  char v100;
  int v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  _BYTE v109[19];
  char v110;
  int v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  _BYTE v119[19];
  char v120;
  int v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  _BYTE v129[19];
  char v130;
  int v131;

  v128 = 0u;
  memset(v129, 0, sizeof(v129));
  v126 = 0u;
  v127 = 0u;
  v124 = 0u;
  v125 = 0u;
  v122 = 0u;
  v123 = 0u;
  v130 = 1;
  v131 = 0;
  v118 = 0u;
  memset(v119, 0, sizeof(v119));
  v116 = 0u;
  v117 = 0u;
  v114 = 0u;
  v115 = 0u;
  v112 = 0u;
  v113 = 0u;
  v120 = 1;
  v121 = 0;
  v108 = 0u;
  memset(v109, 0, sizeof(v109));
  v106 = 0u;
  v107 = 0u;
  v104 = 0u;
  v105 = 0u;
  v102 = 0u;
  v103 = 0u;
  v110 = 1;
  v111 = 0;
  v98 = 0u;
  memset(v99, 0, sizeof(v99));
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  v100 = 1;
  v101 = 0;
  if ((a10 & 1) != 0)
  {
    v13 = a8[15];
    v14 = a8[11];
    v15 = a8[12];
    v16 = v14 * v13;
    v17 = (v13 * a8[8] - v14 * v15) / (v14 * v13);
    v18 = a8[13];
    v19 = (v13 * a8[9] - v14 * v18) / (v14 * v13);
    v20 = v16 < 0.0;
    if (v16 >= 0.0)
      v21 = v17;
    else
      v21 = -v17;
    if (v20)
      v22 = -v19;
    else
      v22 = v19;
    LOWORD(v131) = 257;
    v23 = *((_OWORD *)a8 + 1);
    v122 = *(_OWORD *)a8;
    v123 = v23;
    v124 = v122;
    v125 = v23;
    v24 = sqrt(v21 * v21 + v22 * v22);
    v25 = -v21 / v24 * a1;
    v26 = *((_OWORD *)a8 + 7);
    v126 = *((_OWORD *)a8 + 6);
    v127 = v26;
    *(_OWORD *)v129 = *((_OWORD *)a8 + 7);
    v27 = -v22 / v24 * a1;
    v28 = fabs(v13);
    *(double *)&v128 = v15 + v28 * v25;
    *((double *)&v128 + 1) = v18 + v28 * v27;
    LOWORD(v121) = 257;
    v29 = *((_OWORD *)a8 + 1);
    v112 = *(_OWORD *)a8;
    v113 = v29;
    v114 = v112;
    v115 = v29;
    v117 = *(_OWORD *)v129;
    v116 = v128;
    v118 = v112;
    *(_OWORD *)v119 = v29;
    v30 = fabs(a8[3]);
    v31 = *a8 + v25 * v30;
    v32 = a8[1] + v27 * v30;
    *(double *)&v118 = v31;
    *((double *)&v118 + 1) = v32;
    BYTE1(v111) = 1;
    v33 = *((_OWORD *)a6 + 1);
    v102 = *(_OWORD *)a6;
    v103 = v33;
    v104 = v102;
    v105 = v33;
    v34 = *((_OWORD *)a6 + 7);
    v106 = *((_OWORD *)a6 + 6);
    v107 = v34;
    v108 = v106;
    *(_OWORD *)v109 = v34;
    v35 = fabs(a6[15]);
    *(double *)&v34 = a6[12] + v25 * v35;
    v36 = a6[13] + v27 * v35;
    *(_QWORD *)&v108 = v34;
    *((double *)&v108 + 1) = v36;
    BYTE1(v101) = 1;
    v37 = *((_OWORD *)a6 + 1);
    v92 = *(_OWORD *)a6;
    v93 = v37;
    v38 = *((_OWORD *)a6 + 1);
    v94 = *(_OWORD *)a6;
    v95 = v38;
    v97 = *((_OWORD *)a6 + 7);
    *(_QWORD *)&v96 = v34;
    *((double *)&v96 + 1) = v36;
    v39 = *((_OWORD *)a6 + 1);
    v98 = *(_OWORD *)a6;
    *(_OWORD *)v99 = v39;
    *(double *)&v34 = fabs(a6[3]);
    v40 = a6[1] + v27 * *(double *)&v34;
    *(double *)&v98 = *a6 + v25 * *(double *)&v34;
    *((double *)&v98 + 1) = v40;
    if ((a11 & 1) != 0)
    {
      v41 = (a3[1] - *a3) / 136;
      if (v41 >= 0x28)
        v41 = 40;
      if (v41)
      {
        v42 = (_BYTE *)(*a3 + 134);
        do
        {
          *v42 = 1;
          v42 += 136;
          --v41;
        }
        while (v41);
      }
      v43 = *a4;
      v44 = 40;
      if ((unint64_t)((a4[1] - *a4) / 136) < 0x28)
        v44 = (a4[1] - *a4) / 136;
      if (v44)
      {
        v45 = 0;
        v46 = 136 * v44;
        do
        {
          *(_BYTE *)(v43 + v45 + 134) = 1;
          v45 += 136;
        }
        while (v46 != v45);
      }
    }
    else
    {
      v43 = *a4;
    }
    *(_BYTE *)(v43 + 133) = 1;
    std::vector<OZShapeEdgePolygon>::insert(a4, v43, (unint64_t)&v122);
    std::vector<OZShapeEdgePolygon>::insert(a4, *a4, (unint64_t)&v112);
    v86 = *a3;
    *(_BYTE *)(v86 + 133) = 1;
    std::vector<OZShapeEdgePolygon>::insert(a3, v86, (unint64_t)&v102);
    return std::vector<OZShapeEdgePolygon>::insert(a3, *a3, (unint64_t)&v92);
  }
  else
  {
    v47 = *(double *)(a7 + 56);
    v48 = *(double *)(a7 + 24);
    v49 = *(double *)(a7 + 32);
    v50 = v47 * v48;
    v51 = (v48 * v49 - v47 * *(double *)a7) / (v47 * v48);
    v52 = *(double *)(a7 + 40);
    v53 = (v48 * v52 - v47 * *(double *)(a7 + 8)) / (v47 * v48);
    if (v50 >= 0.0)
    {
      v54 = v51;
    }
    else
    {
      v53 = -v53;
      v54 = -v51;
    }
    BYTE1(v131) = 1;
    v55 = *(_OWORD *)(a7 + 48);
    v122 = *(_OWORD *)(a7 + 32);
    v123 = v55;
    v124 = v122;
    v125 = v55;
    v56 = *(_OWORD *)(a7 + 80);
    v126 = *(_OWORD *)(a7 + 64);
    v127 = v56;
    v57 = sqrt(v54 * v54 + v53 * v53);
    v58 = v54 / v57;
    v59 = v53 / v57;
    v60 = v58 * a1;
    v61 = v59 * a1;
    v62 = fabs(*(double *)(a7 + 88));
    v63 = *(double *)(a7 + 64) + v62 * v60;
    v64 = *(double *)(a7 + 72) + v62 * v61;
    *(double *)&v126 = v63;
    *((double *)&v126 + 1) = v64;
    v65 = *(_OWORD *)(a7 + 80);
    v128 = *(_OWORD *)(a7 + 64);
    *(_OWORD *)v129 = v65;
    BYTE1(v121) = 1;
    v66 = *(_OWORD *)(a7 + 48);
    v112 = *(_OWORD *)(a7 + 32);
    v113 = v66;
    v114 = v112;
    v115 = v66;
    v117 = v66;
    v67 = fabs(v47);
    *(double *)&v116 = v49 + v67 * v60;
    *((double *)&v116 + 1) = v52 + v67 * v61;
    *(_OWORD *)v119 = *(_OWORD *)(a7 + 80);
    *(double *)&v118 = v63;
    *((double *)&v118 + 1) = v64;
    LOWORD(v111) = 257;
    v68 = *(_OWORD *)(a9 + 48);
    v102 = *(_OWORD *)(a9 + 32);
    v103 = v68;
    v104 = v102;
    v105 = v68;
    v69 = *(_OWORD *)(a9 + 80);
    v106 = *(_OWORD *)(a9 + 64);
    v107 = v69;
    v70 = fabs(*(double *)(a9 + 88));
    *(double *)&v69 = *(double *)(a9 + 64) + v60 * v70;
    v71 = *(double *)(a9 + 72) + v61 * v70;
    *(_QWORD *)&v106 = v69;
    *((double *)&v106 + 1) = v71;
    v72 = *(_OWORD *)(a9 + 80);
    v108 = *(_OWORD *)(a9 + 64);
    *(_OWORD *)v109 = v72;
    LOWORD(v101) = 257;
    v73 = *(_OWORD *)(a9 + 48);
    v92 = *(_OWORD *)(a9 + 32);
    v93 = v73;
    v74 = *(_OWORD *)(a9 + 48);
    v94 = *(_OWORD *)(a9 + 32);
    v95 = v74;
    v75 = *(_OWORD *)(a9 + 48);
    v96 = *(_OWORD *)(a9 + 32);
    v97 = v75;
    v76 = fabs(*(double *)(a9 + 56));
    v77 = *(double *)(a9 + 40);
    *(double *)&v96 = *(double *)(a9 + 32) + v60 * v76;
    *((double *)&v96 + 1) = v77 + v61 * v76;
    *(_OWORD *)v99 = *(_OWORD *)(a9 + 80);
    *(_QWORD *)&v98 = v69;
    *((double *)&v98 + 1) = v71;
    v78 = a3[1];
    if (a11)
    {
      v79 = (uint64_t)(v78 - *a3) / 136;
      v80 = 40;
      if (v79 < 0x28)
        v80 = (uint64_t)(v78 - *a3) / 136;
      if (v80)
      {
        v81 = (_BYTE *)(*a3 + 136 * v79 - 2);
        do
        {
          *v81 = 1;
          v81 -= 136;
          --v80;
        }
        while (v80);
      }
      v82 = (a4[1] - *a4) / 136;
      v83 = 40;
      if (v82 < 0x28)
        v83 = (a4[1] - *a4) / 136;
      if (v83)
      {
        v84 = (_BYTE *)(*a4 + 136 * v82 - 2);
        do
        {
          *v84 = 1;
          v84 -= 136;
          --v83;
        }
        while (v83);
      }
    }
    *(_BYTE *)(v78 - 3) = 1;
    if (v78 >= a3[2])
    {
      v85 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v122);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v78, (uint64_t)&v122);
      v85 = v78 + 136;
      a3[1] = v85;
    }
    a3[1] = v85;
    if (v85 >= a3[2])
    {
      v88 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a3, (uint64_t)&v112);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a3 + 2), v85, (uint64_t)&v112);
      v88 = v85 + 136;
      a3[1] = v85 + 136;
    }
    a3[1] = v88;
    v89 = a4[2];
    v90 = a4[1];
    *(_BYTE *)(v90 - 3) = 1;
    if (v90 >= v89)
    {
      v91 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v102);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v90, (uint64_t)&v102);
      v91 = v90 + 136;
      a4[1] = v91;
    }
    a4[1] = v91;
    if (v91 >= a4[2])
    {
      result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a4, (uint64_t)&v92);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a4 + 2), v91, (uint64_t)&v92);
      result = v91 + 136;
      a4[1] = v91 + 136;
    }
    a4[1] = result;
  }
  return result;
}

void sub_1B301274C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B3012758(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void OZShape::subdivideTriangle(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t *a5, unint64_t a6, __int128 *a7, double *a8, double a9, double *a10, __int16 a11, unsigned __int8 a12)
{
  char v19;
  double v20;
  double v21;
  double v22;
  const CMTime *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  __int128 *v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  long double v50;
  long double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  uint64_t *v60;
  uint64_t v61;
  double v62;
  double v63;
  double v64;
  double v65;
  BOOL v66;
  __double2 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  double v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  _BOOL4 v79;
  __int128 v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  __int128 v89;
  uint64_t v90;
  __int128 v91;
  double v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  double v96;
  __int128 v97;
  __double2 v98;
  double *v99;
  char *v100;
  double *v101;
  __int128 v102;
  double v103;
  double v104;
  double v105;
  double *v106;
  double *v107;
  double v108;
  double v109;
  double v110;
  double v111;
  BOOL v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  double v123;
  double v124;
  double v125;
  double v126;
  double v127;
  double v128;
  double v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  OZShapeEdgePolygon *v135;
  __int128 v136;
  __double2 v137;
  double *v138;
  char *v139;
  double *v140;
  __int128 v141;
  double v142;
  double v143;
  double v144;
  double *v145;
  double *v146;
  double v147;
  double v148;
  double v149;
  double v150;
  BOOL v151;
  double v152;
  double v153;
  __int128 v154;
  double v155;
  __int128 v156;
  __int128 v157;
  OZShapeEdgePolygon *v158;
  unint64_t v159;
  uint64_t v160;
  unsigned int v161;
  __int128 v163;
  OZShapeEdgePolygon *v164;
  unint64_t v165;
  int v166;
  double v167;
  double v168;
  double v169;
  double v170;
  double v171;
  double v172;
  double v173;
  double v174;
  _OWORD *v175;
  double v176;
  double v177;
  __int128 *v178;
  double v179;
  double v182;
  __int128 v183;
  __int128 v184;
  void *__p[2];
  __int128 v186;
  OZShapeEdgePolygon *v187;
  double v188;
  uint64_t v189;
  __int128 v190;
  double v191;
  double v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  _BYTE v200[35];
  char v201;
  char v202;
  __int16 v203;
  char v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  _BYTE v212[19];
  uint64_t v213;

  v213 = *MEMORY[0x1E0C80C00];
  v19 = *(_BYTE *)(a6 + 132);
  v194 = 0u;
  v195 = 0u;
  v196 = 0u;
  v197 = 0u;
  v198 = 0u;
  v199 = 0u;
  memset(v200, 0, sizeof(v200));
  v201 = 1;
  v202 = v19;
  v203 = 0;
  v204 = 0;
  v211 = 0u;
  memset(v212, 0, sizeof(v212));
  v209 = 0u;
  v210 = 0u;
  v207 = 0u;
  v208 = 0u;
  v205 = 0u;
  v206 = 0u;
  v182 = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  if (!OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)a6))
    return;
  v20 = 4.0 / a9;
  if (((4.0 / a9 <= 0.174532925) & a12) == 0)
    v20 = 0.174532925;
  v179 = v20;
  v21 = 1.0;
  if (*(_DWORD *)(a4 + 8))
  {
    v22 = 1.0;
  }
  else
  {
    v22 = 1.0;
    if (fabs(*(double *)(a4 + 224)) >= 0.0000001)
    {
      v23 = (const CMTime *)MEMORY[0x1E0CA2E68];
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E0CA2E68], 0.0);
      v22 = v24;
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), v23, 0.0);
    }
  }
  v25 = *(double *)(a6 + 120);
  v26 = *(double *)(a6 + 24);
  v27 = *(double *)(a6 + 96);
  v175 = (_OWORD *)(a6 + 96);
  v173 = *(double *)(a6 + 8);
  v174 = *(double *)a6;
  v28 = (v26 * v27 - v25 * *(double *)a6) / (v25 * v26);
  v29 = *(double *)(a6 + 104);
  if (v25 * v26 >= 0.0)
    v30 = (v26 * v29 - v25 * v173) / (v25 * v26);
  else
    v30 = -((v26 * v29 - v25 * v173) / (v25 * v26));
  if (v25 * v26 < 0.0)
    v28 = -v28;
  v31 = *(double *)(a6 + 88);
  v32 = *(double *)(a6 + 56);
  v33 = v31 * v32;
  v178 = (__int128 *)(a6 + 64);
  v34 = (__int128 *)(a6 + 32);
  v35 = (v32 * *(double *)(a6 + 64) - v31 * *(double *)(a6 + 32)) / (v31 * v32);
  v36 = (v32 * *(double *)(a6 + 72) - v31 * *(double *)(a6 + 40)) / (v31 * v32);
  if (v33 >= 0.0)
  {
    v37 = v35;
  }
  else
  {
    v36 = -v36;
    v37 = -v35;
  }
  v176 = v22;
  v177 = v21;
  v38 = v182 * v22 * v28;
  v39 = v21 * v30;
  v40 = v182 * v22 * v37;
  v41 = v21 * v36;
  v42 = fabs(v38) >= 0.0000001 ? v38 : 0.0;
  v43 = fabs(v40) >= 0.0000001 ? v40 : 0.0;
  v44 = fabs(v39) >= 0.0000001 ? v39 : 0.0;
  v45 = fabs(v41) >= 0.0000001 ? v41 : 0.0;
  if (a9 == 0.0)
    return;
  v46 = sqrt(v42 * v42 + v44 * v44);
  if (v46 == 0.0)
    return;
  v47 = sqrt(v43 * v43 + v45 * v45);
  if (v47 == 0.0)
    return;
  v172 = *(double *)(a6 + 24);
  v168 = a9;
  v48 = (v42 * a9 + v44 * 0.0) / (v46 * a9);
  v49 = (v42 * v43 + v44 * v45) / (v46 * v47);
  v50 = 1.0;
  v51 = 1.0;
  if (v48 <= 1.0)
  {
    v51 = v48;
    if (v48 < -1.0)
      v51 = -1.0;
  }
  v169 = v43;
  v170 = *(double *)(a6 + 72);
  v171 = *(double *)(a6 + 64);
  v52 = *(double *)(a6 + 120);
  if (v49 <= 1.0)
  {
    v50 = v49;
    if (v49 < -1.0)
      v50 = -1.0;
  }
  v53 = acos(v51);
  if (v44 < 0.0)
    v53 = -v53;
  v167 = v53;
  v54 = v53;
  v55 = acos(v50);
  if ((*(_QWORD *)&v54 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*(_QWORD *)&v55 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || vabdd_f64(0.0, v55) < 0.0000001)
  {
    return;
  }
  v56 = v52;
  v57 = v42 * v45 - v44 * v169;
  if (!(_BYTE)a11)
  {
    v58 = v167;
    if (v57 >= 0.0 || a2 != 1 || fabs(v57) < 0.0000001)
    {
      v59 = v167 + v55;
      goto LABEL_55;
    }
LABEL_50:
    v60 = a5;
    v61 = a5[1];
    if (v61 != *a5 && fabs(v55) > v179)
    {
      *(_BYTE *)(v61 - 1) = 1;
      *(_BYTE *)(a6 + 135) = 1;
    }
    goto LABEL_116;
  }
  v58 = v167;
  if (v57 > 0.0 && a2 == 1 && fabs(v57) >= 0.0000001)
    goto LABEL_50;
  v59 = v167 - v55;
LABEL_55:
  v62 = v59 - v58;
  if (a2 == 2 || (v63 = fabs(v62), !a2) && v63 <= v179)
  {
    if (v56 * v31 >= 0.0)
      v64 = (v56 * v170 - v29 * v31) / (v56 * v31);
    else
      v64 = -((v56 * v170 - v29 * v31) / (v56 * v31));
    if (v56 * v31 >= 0.0)
      v65 = (v56 * v171 - v27 * v31) / (v56 * v31);
    else
      v65 = -((v56 * v171 - v27 * v31) / (v56 * v31));
    v66 = v57 <= 0.0;
    if (!(_BYTE)a11)
      v66 = v57 >= 0.0;
    if (v66)
    {
      v190 = 0uLL;
      v67 = __sincos_stret(v167 + v62 * 0.5);
      *(double *)&v193 = v174 + v172 * (v67.__cosval * v168 / v182 / v176);
      *((double *)&v193 + 1) = v173 + v172 * (v67.__sinval * v168 / v177);
      v68 = *(_OWORD *)(a6 + 16);
      v194 = *(_OWORD *)a6;
      v195 = v68;
      v69 = *(_OWORD *)(a6 + 48);
      v196 = *v34;
      v197 = v69;
      v70 = *(_OWORD *)(a6 + 80);
      v198 = *v178;
      v199 = v70;
      v71 = *(_OWORD *)(a6 + 112);
      *(_OWORD *)v200 = *v175;
      *(_OWORD *)&v200[16] = v71;
      *(_QWORD *)&v71 = *((_QWORD *)a7 + 15);
      v72 = *((double *)a7 + 11);
      v73 = *(double *)&v71 * v72;
      v74 = *((double *)a7 + 13);
      *(_QWORD *)&v183 = *((_QWORD *)a7 + 12);
      *((double *)&v183 + 1) = v74;
      v75 = *(double *)&v71 * *((double *)a7 + 8) - v72 * *(double *)&v183 / (*(double *)&v71 * v72);
      v76 = *(double *)&v71 * *((double *)a7 + 9) - v72 * v74 / (*(double *)&v71 * v72);
      *(double *)&v187 = v75;
      v188 = v76;
      if (v73 < 0.0)
      {
        v75 = -v75;
        v76 = -v76;
        *(double *)&v187 = v75;
        v188 = v76;
      }
      v77 = sqrt(v75 * v75 + v76 * v76);
      if (v77 <= -0.000000100000001 || v77 >= 0.000000100000001)
      {
        *(double *)&v187 = v75 / v77;
        v188 = v76 / v77;
      }
      v191 = -v65;
      v192 = -v64;
      v78 = sqrt(v65 * v65 + v64 * v64);
      v79 = v78 >= 0.000000100000001 || v78 <= -0.000000100000001;
      if (v79)
      {
        v191 = -v65 / v78;
        v192 = -v64 / v78;
      }
      __p[0] = 0;
      __p[1] = 0;
      *(_QWORD *)&v186 = 0;
      if (PCAlgorithm::findIntersection((double *)&v183, (double *)&v187, (double *)&v193, &v191, (double *)&v190))
      {
        v80 = *v175;
        v198 = v190;
        *(_OWORD *)v200 = v80;
        v200[32] = 1;
        v200[34] = 0;
        std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v194);
        *(_OWORD *)v200 = v190;
        v198 = v193;
        std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v194);
        v81 = a8[15];
        v82 = a8[11];
        v83 = v81 * v82;
        v84 = a8[9];
        v85 = v81 * a8[8] - v82 * a8[12] / (v81 * v82);
        v86 = a8[13];
        *(double *)&v183 = a8[12];
        *((double *)&v183 + 1) = v86;
        v87 = v81 * v84 - v82 * v86 / (v81 * v82);
        *(double *)&v187 = v85;
        v188 = v87;
        if (v83 < 0.0)
        {
          v85 = -v85;
          v87 = -v87;
          *(double *)&v187 = v85;
          v188 = v87;
        }
        v88 = sqrt(v85 * v85 + v87 * v87);
        if (v88 <= -0.000000100000001 || v88 >= 0.000000100000001)
        {
          *(double *)&v187 = v85 / v88;
          v188 = v87 / v88;
        }
        v191 = v65;
        v192 = v64;
        if (v79)
        {
          v191 = v65 / v78;
          v192 = v64 / v78;
        }
        if (PCAlgorithm::findIntersection((double *)&v183, (double *)&v187, (double *)&v193, &v191, (double *)&v190))
        {
          v198 = v190;
          *(_OWORD *)v200 = v193;
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v194);
          v89 = *v178;
          *(_OWORD *)v200 = v190;
          v198 = v89;
          v200[34] = 1;
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v194);
          if (__p[1] != __p[0])
          {
            v90 = 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3);
            if (HIBYTE(a11))
            {
LABEL_88:
              std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, *a5, (uint64_t)__p[0], (uint64_t)__p[1], v90);
              goto LABEL_134;
            }
LABEL_169:
            std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, a5[1], (uint64_t)__p[0], (uint64_t)__p[1], v90);
            goto LABEL_134;
          }
          goto LABEL_134;
        }
        if (!HIBYTE(a11))
        {
LABEL_133:
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](a5, a6);
          goto LABEL_134;
        }
      }
      else if (!HIBYTE(a11))
      {
        goto LABEL_133;
      }
      std::vector<OZShapeEdgePolygon>::insert(a5, *a5, a6);
      goto LABEL_134;
    }
    if (HIBYTE(a11))
    {
      v60 = a5;
LABEL_91:
      std::vector<OZShapeEdgePolygon>::insert(v60, *v60, a6);
      return;
    }
    v60 = a5;
LABEL_116:
    std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](v60, a6);
    return;
  }
  if (!a2)
  {
    v190 = 0uLL;
    v114 = *((double *)a7 + 15);
    v115 = *((double *)a7 + 11);
    v116 = v114 * v115;
    v117 = *((double *)a7 + 9);
    v118 = v114 * *((double *)a7 + 8) - v115 * *((double *)a7 + 12) / (v114 * v115);
    v119 = *((double *)a7 + 13);
    *(_QWORD *)&v183 = *((_QWORD *)a7 + 12);
    *((double *)&v183 + 1) = v119;
    v120 = v114 * v117 - v115 * v119 / (v114 * v115);
    *(double *)&v187 = v118;
    v188 = v120;
    if (v116 < 0.0)
    {
      v118 = -v118;
      v120 = -v120;
      *(double *)&v187 = v118;
      v188 = v120;
    }
    v121 = sqrt(v118 * v118 + v120 * v120);
    if (v121 <= -0.000000100000001 || v121 >= 0.000000100000001)
    {
      v118 = v118 / v121;
      v120 = v120 / v121;
      *(double *)&v187 = v118;
      v188 = v120;
    }
    v122 = a8[15];
    v123 = a8[11];
    v124 = v122 * v123;
    v125 = a8[9];
    v126 = v122 * a8[8] - v123 * a8[12] / (v122 * v123);
    v127 = a8[13];
    *(double *)&v193 = a8[12];
    *((double *)&v193 + 1) = v127;
    v128 = v122 * v125 - v123 * v127 / (v122 * v123);
    v191 = v126;
    v192 = v128;
    if (v124 < 0.0)
    {
      *(double *)&v187 = -v118;
      v188 = -v120;
    }
    v129 = sqrt(v126 * v126 + v128 * v128);
    if (v129 <= -0.000000100000001 || v129 >= 0.000000100000001)
    {
      v191 = v126 / v129;
      v192 = v128 / v129;
    }
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v186 = 0;
    if (PCAlgorithm::findIntersection((double *)&v183, (double *)&v187, (double *)&v193, &v191, (double *)&v190))
    {
      v130 = *(_OWORD *)(a6 + 16);
      v194 = *(_OWORD *)a6;
      v195 = v130;
      v131 = *(_OWORD *)(a6 + 48);
      v196 = *v34;
      v197 = v131;
      v132 = *(_OWORD *)(a6 + 80);
      v133 = *(_OWORD *)(a6 + 112);
      *(_OWORD *)v200 = *v175;
      *(_OWORD *)&v200[16] = v133;
      v198 = v190;
      v199 = v132;
      *(_OWORD *)v200 = *(_OWORD *)(a6 + 96);
      v200[32] = 1;
      v200[34] = 0;
      std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v194);
      v134 = *(_OWORD *)(a6 + 80);
      v198 = *v178;
      v199 = v134;
      *(_OWORD *)v200 = v190;
      v200[34] = 1;
      std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)__p, (uint64_t)&v194);
      if (HIBYTE(a11))
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, *a5, (uint64_t)__p[0], (uint64_t)__p[1], 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3));
      else
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, a5[1], (uint64_t)__p[0], (uint64_t)__p[1], 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3));
      goto LABEL_134;
    }
    BYTE2(v166) = a12;
    LOWORD(v166) = a11;
    OZShape::subdivideTriangle(a1, 2, a3, a4, __p, a6, a7, a8, v168, a10, v166);
    if (__p[1] != __p[0])
    {
      v90 = 0xF0F0F0F0F0F0F0F1 * (((char *)__p[1] - (char *)__p[0]) >> 3);
      if (HIBYTE(a11))
        goto LABEL_88;
      goto LABEL_169;
    }
LABEL_134:
    v135 = (OZShapeEdgePolygon *)__p[0];
    if (!__p[0])
      return;
    __p[1] = __p[0];
    goto LABEL_136;
  }
  if (v63 <= v179)
  {
    v60 = a5;
    if (HIBYTE(a11))
      goto LABEL_91;
    goto LABEL_116;
  }
  *(double *)&v187 = 0.0;
  v188 = 0.0;
  v189 = 0;
  std::vector<OZShapeEdgePolygon>::reserve((uint64_t *)&v187, 0x14uLL);
  v91 = a7[7];
  v211 = a7[6];
  *(_OWORD *)v212 = v91;
  *(_DWORD *)&v212[15] = *(_DWORD *)((char *)a7 + 127);
  v92 = v62 / (v63 / v179);
  v93 = a7[3];
  v207 = a7[2];
  v208 = v93;
  v94 = a7[5];
  v209 = a7[4];
  v210 = v94;
  v95 = a7[1];
  v205 = *a7;
  v206 = v95;
  v96 = v167;
  if (v167 <= v59)
  {
    if (v167 < v59)
    {
      do
      {
        v136 = *(_OWORD *)(a6 + 16);
        v194 = *(_OWORD *)a6;
        v195 = v136;
        v196 = v194;
        v197 = v136;
        v96 = v92 + v96;
        v137 = __sincos_stret(v96);
        if ((_BYTE)a11)
        {
          v198 = v211;
          v199 = *(_OWORD *)v212;
          v138 = (double *)v200;
          v139 = (char *)&v195 + 8;
          v140 = (double *)&v200[8];
        }
        else
        {
          *(_OWORD *)v200 = v209;
          *(_OWORD *)&v200[16] = v210;
          v138 = (double *)&v198;
          v139 = (char *)&v197 + 8;
          v140 = (double *)&v198 + 1;
        }
        v141 = *(_OWORD *)(a6 + 16);
        *(_OWORD *)v138 = *(_OWORD *)a6;
        *((_OWORD *)v138 + 1) = v141;
        *(_QWORD *)&v141 = *(_QWORD *)v139;
        *v138 = *v138 + v137.__cosval * v168 * *(double *)v139 / v182 / v176;
        *v140 = *v140 + v137.__sinval * v168 * *(double *)&v141 / v177;
        if (OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)&v194))
        {
          if (*(OZShapeEdgePolygon **)&v188 == v187)
            goto LABEL_161;
          *(_OWORD *)__p = *(_OWORD *)(*(_QWORD *)&v188 - 72);
          v186 = *(_OWORD *)(*(_QWORD *)&v188 - 56);
          v183 = v198;
          v184 = v199;
          PCMatrix44Tmpl<double>::transform<double>(a10, (double *)__p, (double *)__p);
          PCMatrix44Tmpl<double>::transform<double>(a10, (double *)&v183, (double *)&v183);
          v142 = *((double *)&v184 + 1);
          v143 = *((double *)&v186 + 1) * *((double *)&v184 + 1);
          if (vabdd_f64(0.0, *((double *)&v186 + 1) * *((double *)&v184 + 1)) < 0.0000001)
            goto LABEL_161;
          if ((_BYTE)a11)
          {
            v144 = *((double *)&v186 + 1) * *(double *)&v183 - *((double *)&v184 + 1) * *(double *)__p;
            v145 = (double *)&v183 + 1;
            v146 = (double *)&__p[1];
            v147 = *((double *)&v186 + 1);
          }
          else
          {
            v144 = *((double *)&v184 + 1) * *(double *)__p - *((double *)&v186 + 1) * *(double *)&v183;
            v146 = (double *)&v183 + 1;
            v145 = (double *)&__p[1];
            v147 = *((double *)&v184 + 1);
            v142 = *((double *)&v186 + 1);
          }
          v148 = (v147 * *v145 - v142 * *v146) / v143;
          v149 = v144 / v143;
          v150 = -(v144 / v143);
          v151 = v143 < 0.0;
          if (v143 >= 0.0)
            v152 = v149;
          else
            v152 = v150;
          if (v151)
            v148 = -v148;
          if (sqrt(v152 * v152 + v148 * v148) >= 1.0)
          {
LABEL_161:
            std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)&v187, (uint64_t)&v194);
            v211 = *(_OWORD *)v200;
            *(_OWORD *)v212 = *(_OWORD *)&v200[16];
            *(_DWORD *)&v212[15] = *(_DWORD *)&v200[31];
            v207 = v196;
            v208 = v197;
            v209 = v198;
            v210 = v199;
            v205 = v194;
            v206 = v195;
          }
        }
      }
      while (v96 < v59);
    }
    v135 = v187;
    v153 = v188;
    if (*(OZShapeEdgePolygon **)&v188 != v187)
    {
      if ((_BYTE)a11)
      {
        v154 = *v175;
        *(_OWORD *)(*(_QWORD *)&v188 - 24) = *(_OWORD *)(a6 + 112);
        *(_OWORD *)(*(_QWORD *)&v153 - 40) = v154;
      }
      else
      {
        v157 = *v178;
        *(_OWORD *)(*(_QWORD *)&v188 - 56) = *(_OWORD *)(a6 + 80);
        *(_OWORD *)(*(_QWORD *)&v153 - 72) = v157;
      }
      if (!OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)(*(_QWORD *)&v153 - 136)))
        *(_QWORD *)&v188 -= 136;
      if (!OZShapeEdgePolygon::isValid(v187))
      {
        v158 = v187;
        if ((OZShapeEdgePolygon *)((char *)v187 + 136) != *(OZShapeEdgePolygon **)&v188)
        {
          v159 = *(_QWORD *)&v188 - (_QWORD)v187 - 272;
          memmove(v187, (char *)v187 + 136, 136 * (v159 / 0x88) + 136);
          v158 = (OZShapeEdgePolygon *)((char *)v158 + 136 * (v159 / 0x88) + 136);
        }
        v188 = *(double *)&v158;
      }
      if ((a11 & 0x100) == 0)
      {
        v135 = v187;
        if (*(OZShapeEdgePolygon **)&v188 == v187)
          goto LABEL_195;
        v160 = 0;
        v161 = 1;
        do
        {
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](a5, (uint64_t)v135 + 136 * v160);
          v160 = v161;
          v135 = v187;
        }
        while (0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(_QWORD *)&v188 - (_QWORD)v187) >> 3) > v161++);
        goto LABEL_194;
      }
      goto LABEL_180;
    }
  }
  else
  {
    while (v96 > v59 || vabdd_f64(v96, v59) < 0.0000001)
    {
      v97 = *(_OWORD *)(a6 + 16);
      v194 = *(_OWORD *)a6;
      v195 = v97;
      v196 = v194;
      v197 = v97;
      v96 = v92 + v96;
      v98 = __sincos_stret(v96);
      if ((_BYTE)a11)
      {
        *(_OWORD *)v200 = v209;
        *(_OWORD *)&v200[16] = v210;
        v99 = (double *)&v198;
        v100 = (char *)&v197 + 8;
        v101 = (double *)&v198 + 1;
      }
      else
      {
        v198 = v211;
        v199 = *(_OWORD *)v212;
        v99 = (double *)v200;
        v100 = (char *)&v195 + 8;
        v101 = (double *)&v200[8];
      }
      v102 = *(_OWORD *)(a6 + 16);
      *(_OWORD *)v99 = *(_OWORD *)a6;
      *((_OWORD *)v99 + 1) = v102;
      *(_QWORD *)&v102 = *(_QWORD *)v100;
      *v99 = *v99 + v98.__cosval * v168 * *(double *)v100 / v182 / v176;
      *v101 = *v101 + v98.__sinval * v168 * *(double *)&v102 / v177;
      if (OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)&v194))
      {
        if (*(OZShapeEdgePolygon **)&v188 == v187)
          goto LABEL_114;
        *(_OWORD *)__p = *(_OWORD *)(*(_QWORD *)&v188 - 72);
        v186 = *(_OWORD *)(*(_QWORD *)&v188 - 56);
        v183 = v198;
        v184 = v199;
        PCMatrix44Tmpl<double>::transform<double>(a10, (double *)__p, (double *)__p);
        PCMatrix44Tmpl<double>::transform<double>(a10, (double *)&v183, (double *)&v183);
        v103 = *((double *)&v186 + 1);
        v104 = *((double *)&v186 + 1) * *((double *)&v184 + 1);
        if (vabdd_f64(0.0, *((double *)&v186 + 1) * *((double *)&v184 + 1)) < 0.0000001)
          goto LABEL_114;
        if ((_BYTE)a11)
        {
          v105 = *((double *)&v184 + 1) * *(double *)__p - *((double *)&v186 + 1) * *(double *)&v183;
          v107 = (double *)&v183 + 1;
          v106 = (double *)&__p[1];
          v108 = *((double *)&v184 + 1);
        }
        else
        {
          v105 = *((double *)&v186 + 1) * *(double *)&v183 - *((double *)&v184 + 1) * *(double *)__p;
          v106 = (double *)&v183 + 1;
          v107 = (double *)&__p[1];
          v108 = *((double *)&v186 + 1);
          v103 = *((double *)&v184 + 1);
        }
        v109 = (v108 * *v106 - v103 * *v107) / v104;
        v110 = v105 / v104;
        v111 = -(v105 / v104);
        v112 = v104 < 0.0;
        if (v104 >= 0.0)
          v113 = v110;
        else
          v113 = v111;
        if (v112)
          v109 = -v109;
        if (sqrt(v113 * v113 + v109 * v109) >= 1.0)
        {
LABEL_114:
          std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100]((uint64_t *)&v187, (uint64_t)&v194);
          v211 = *(_OWORD *)v200;
          *(_OWORD *)v212 = *(_OWORD *)&v200[16];
          *(_DWORD *)&v212[15] = *(_DWORD *)&v200[31];
          v207 = v196;
          v208 = v197;
          v209 = v198;
          v210 = v199;
          v205 = v194;
          v206 = v195;
        }
      }
    }
    v135 = v187;
    v155 = v188;
    if (*(OZShapeEdgePolygon **)&v188 != v187)
    {
      if ((_BYTE)a11)
      {
        v156 = *v178;
        *(_OWORD *)(*(_QWORD *)&v188 - 56) = *(_OWORD *)(a6 + 80);
        *(_OWORD *)(*(_QWORD *)&v155 - 72) = v156;
      }
      else
      {
        v163 = *v175;
        *(_OWORD *)(*(_QWORD *)&v188 - 24) = *(_OWORD *)(a6 + 112);
        *(_OWORD *)(*(_QWORD *)&v155 - 40) = v163;
      }
      if (!OZShapeEdgePolygon::isValid((OZShapeEdgePolygon *)(*(_QWORD *)&v155 - 136)))
        *(_QWORD *)&v188 -= 136;
      if (!OZShapeEdgePolygon::isValid(v187))
      {
        v164 = v187;
        if ((OZShapeEdgePolygon *)((char *)v187 + 136) != *(OZShapeEdgePolygon **)&v188)
        {
          v165 = *(_QWORD *)&v188 - (_QWORD)v187 - 272;
          memmove(v187, (char *)v187 + 136, 136 * (v165 / 0x88) + 136);
          v164 = (OZShapeEdgePolygon *)((char *)v164 + 136 * (v165 / 0x88) + 136);
        }
        v188 = *(double *)&v164;
      }
      if (!HIBYTE(a11))
      {
        std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, a5[1], (uint64_t)v187, *(uint64_t *)&v188, 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(_QWORD *)&v188 - (_QWORD)v187) >> 3));
        goto LABEL_194;
      }
LABEL_180:
      std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(a5, *a5, (uint64_t)v187, *(uint64_t *)&v188, 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(_QWORD *)&v188 - (_QWORD)v187) >> 3));
LABEL_194:
      v135 = v187;
    }
  }
LABEL_195:
  if (*(double *)&v135 != 0.0)
  {
    v188 = *(double *)&v135;
LABEL_136:
    operator delete(v135);
  }
}

void sub_1B3013A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<OZShapeEdgePolygon>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t result;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  v5 = *(_QWORD *)(v3 - 8);
  if (v5 >= v4)
  {
    result = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a1, a2);
  }
  else
  {
    std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v3, *(_QWORD *)(v3 - 8), a2);
    result = v5 + 136;
    a1[1] = v5 + 136;
  }
  a1[1] = result;
  return result;
}

void sub_1B3013B1C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

unint64_t std::vector<OZShapeEdgePolygon>::insert(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  void *__p;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;

  v4 = a2;
  v6 = a1[1];
  v9 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v8 = v9;
  if (v6 >= v9)
  {
    v16 = *a1;
    v17 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v6 - *a1) >> 3) + 1;
    if (v17 > 0x1E1E1E1E1E1E1E1)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v18 = 0xF0F0F0F0F0F0F0F1 * ((a2 - v16) >> 3);
    v19 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v8 - v16) >> 3);
    v20 = 2 * v19;
    if (2 * v19 <= v17)
      v20 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v6 - *a1) >> 3) + 1;
    if (v19 >= 0xF0F0F0F0F0F0F0)
      v21 = 0x1E1E1E1E1E1E1E1;
    else
      v21 = v20;
    v28 = v7;
    if (v21)
      v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v7, v21);
    else
      v22 = 0;
    __p = v22;
    v25 = &v22[136 * v18];
    v26 = v25;
    v27 = &v22[136 * v21];
    std::__split_buffer<OZShapeEdgePolygon>::push_back[abi:ne180100](&__p, a3);
    v4 = std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p, v4);
    if (v26 != v25)
      v26 = &v25[(v26 - v25 - 136) % 0x88uLL];
    if (__p)
      operator delete(__p);
  }
  else if (a2 == v6)
  {
    std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v7, a2, a3);
    a1[1] = v4 + 136;
  }
  else
  {
    std::vector<OZShapeEdgePolygon>::__move_range((uint64_t)a1, a2, v6, a2 + 136);
    if (v4 <= a3)
      a3 += 136 * (a1[1] > a3);
    *(_OWORD *)v4 = *(_OWORD *)a3;
    v10 = *(_OWORD *)(a3 + 16);
    v11 = *(_OWORD *)(a3 + 32);
    v12 = *(_OWORD *)(a3 + 64);
    *(_OWORD *)(v4 + 48) = *(_OWORD *)(a3 + 48);
    *(_OWORD *)(v4 + 64) = v12;
    *(_OWORD *)(v4 + 16) = v10;
    *(_OWORD *)(v4 + 32) = v11;
    v13 = *(_OWORD *)(a3 + 80);
    v14 = *(_OWORD *)(a3 + 96);
    v15 = *(_OWORD *)(a3 + 112);
    *(_QWORD *)(v4 + 128) = *(_QWORD *)(a3 + 128);
    *(_OWORD *)(v4 + 96) = v14;
    *(_OWORD *)(v4 + 112) = v15;
    *(_OWORD *)(v4 + 80) = v13;
  }
  return v4;
}

void sub_1B3013CE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v13 + 8) = v12;
  _Unwind_Resume(exception_object);
}

void OZShape::computeSoftEdges(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, int a5, char a6, int a7, double a8)
{
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = 0x3FF0000000000000;
  v14 = 0x3FF0000000000000;
  v11 = 0x3FF0000000000000;
  v8 = 0x3FF0000000000000;
  v9 = 0u;
  v10 = 0u;
  v12 = 0u;
  v13 = 0u;
  v15 = 0u;
  v16 = 0u;
  OZShape::computeOutlinePolygons(a1, (uint64_t *)(a4 + 312), a4, a2, a3, (double *)&v8, 1, a5, a8, a6, a7, 0);
}

void OZShape::computeOutline(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t *a4, double *a5, int a6, int a7, double a8)
{
  double v15;

  if (*(_BYTE *)(a3 + 1195))
  {
    a4[43] = a4[42];
    a4[46] = a4[45];
  }
  v15 = a8 * 0.5;
  OZShape::computeOutlinePolygons(a1, a4 + 42, (uint64_t)a4, a2, a3, a5, a6, a7, a8 * 0.5, 1, 1, 1u);
  OZShape::computeOutlinePolygons(a1, a4 + 42, (uint64_t)a4, a2, a3, a5, a6, a7, v15, 0, -1, 1u);
  *(_BYTE *)(a3 + 1195) = 0;
}

void OZShape::computeAntialiasedBorders(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, double *a5, int a6, char a7, int a8, double a9)
{
  OZShape::computeOutlinePolygons(a1, (uint64_t *)(a4 + 288), a4, a2, a3, a5, a6, 0, a9, a7, a8, 0);
}

uint64_t OZShape::isWriteOnEffectEnabled(uint64_t a1, uint64_t a2)
{
  double v3;
  uint64_t result;
  double v5;

  if (!*(_DWORD *)(a2 + 8))
    return 0;
  v3 = *(double *)(a2 + 72);
  if (!*(_DWORD *)(a2 + 168)
    || (result = 0, v5 = vabdd_f64(*(double *)(a2 + 80), v3), v5 <= 1.0) && fabs(v5 + -1.0) >= 0.0000001)
  {
    if (fabs(v3) >= 0.0000001
      || fabs(*(double *)(a2 + 80) + -1.0) >= 0.0000001
      || fabs(*(double *)(a2 + 88)) >= 0.0000001
      || OZChannel::hasKeypoints((OZChannel *)(a1 + 9976))
      || OZChannel::hasKeypoints((OZChannel *)(a1 + 10128))
      || OZChannel::hasKeypoints((OZChannel *)(a1 + 10592)))
    {
      return 1;
    }
    else
    {
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
    }
  }
  return result;
}

void OZShape::getWriteOnEffect(uint64_t a1, const CMTime *a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, _QWORD *a7, _QWORD *a8, _QWORD *a9)
{
  double v9;
  double v10;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v30;
  double v31;
  double v32;
  _BOOL4 v33;
  double v34;
  _BOOL4 v35;
  double v36;
  char v37;
  double v38;
  uint64_t v39;
  signed int v40;
  unsigned int v41;
  int v42;
  _BOOL4 v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  int ValueAsInt;
  int v48;
  unint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  _QWORD *v65;
  char *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  _QWORD *v77;
  char *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  char *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  _QWORD *v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  char *v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  char *v100;
  _QWORD *v101;
  char *v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  char *v107;
  char *v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  char *v112;
  _QWORD *v113;
  char *v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  char *v119;
  char *v120;
  uint64_t v121;
  double *v122;
  double v123;
  double *v124;
  BOOL v125;
  double v126;
  double v127;
  double *v128;
  double *v129;
  double *v130;
  double *v131;
  double *v132;
  double *v133;
  int v134;
  double v135;
  double v136;
  double v137;
  double v138;
  char *v139;
  char *v140;
  uint64_t v141;
  double *v142;
  _QWORD *v143;
  char *v144;
  char *v145;
  uint64_t v146;
  double *v147;
  _QWORD *v148;
  unsigned int v149;
  double *v150;
  double *v151;
  double *v152;
  double *v153;
  unsigned int v154;
  char *v155;
  char *v156;
  uint64_t v157;
  _QWORD *v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  char *v163;
  char *v164;
  uint64_t v165;
  unint64_t v166;
  char *v167;
  _QWORD *v168;
  char *v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  unint64_t v173;
  char *v174;
  char *v175;
  uint64_t v176;
  unint64_t v177;
  char *v178;
  _QWORD *v179;
  char *v180;
  uint64_t v181;
  unint64_t v182;
  uint64_t v183;
  unint64_t v184;
  char *v185;
  char *v186;
  uint64_t v187;
  uint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  char *v192;
  uint64_t v193;
  unint64_t v194;
  uint64_t v195;
  unint64_t v196;
  char *v197;
  int v198;
  double *v199;
  double *v200;
  double v201;
  _QWORD *v202;
  _QWORD *v203;
  double *v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  unint64_t v208;
  char *v209;
  double *v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  unint64_t v214;
  char *v215;
  char *v216;
  uint64_t v217;
  unint64_t v218;
  char *v219;
  _QWORD *v220;
  char *v221;
  uint64_t v222;
  unint64_t v223;
  uint64_t v224;
  unint64_t v225;
  char *v226;
  char *v227;
  uint64_t v228;
  unint64_t v229;
  char *v230;
  char *v231;
  uint64_t v232;
  unint64_t v233;
  uint64_t v234;
  unint64_t v235;
  char *v236;
  char *v237;
  uint64_t v238;
  double *v239;
  uint64_t v240;
  unint64_t v241;
  char *v242;
  _QWORD *v243;
  char *v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  unint64_t v248;
  char *v249;
  char *v250;
  uint64_t v251;
  unint64_t v252;
  uint64_t v253;
  unint64_t v254;
  uint64_t v255;
  uint64_t v256;
  char *v257;
  uint64_t v258;
  unint64_t v259;
  char *v260;
  _QWORD *v261;
  char *v262;
  uint64_t v263;
  unint64_t v264;
  uint64_t v265;
  unint64_t v266;
  char *v267;
  char *v268;
  uint64_t v269;
  unint64_t v270;
  char *v271;
  _QWORD *v272;
  char *v273;
  uint64_t v274;
  unint64_t v275;
  uint64_t v276;
  unint64_t v277;
  char *v278;
  char *v279;
  uint64_t v280;
  double v281;
  double v282;
  char *v283;
  uint64_t v284;
  unint64_t v285;
  char *v286;
  _QWORD *v287;
  char *v288;
  uint64_t v289;
  unint64_t v290;
  uint64_t v291;
  unint64_t v292;
  char *v293;
  char *v294;
  uint64_t v295;
  unint64_t v296;
  char *v297;
  _QWORD *v298;
  char *v299;
  uint64_t v300;
  unint64_t v301;
  uint64_t v302;
  unint64_t v303;
  char *v304;
  char *v305;
  uint64_t v306;
  char *v307;
  char *v308;
  uint64_t v309;
  _QWORD *v310;
  double v311;
  char v312;
  char *v313;
  char *v314;
  uint64_t v315;
  double *v316;
  _QWORD *v317;
  char *v318;
  char *v319;
  uint64_t v320;
  double *v321;
  _QWORD *v322;
  unsigned int v323;
  char v324;
  char *v325;
  char *v326;
  uint64_t v327;
  _QWORD *v328;
  uint64_t v329;
  unint64_t v330;
  uint64_t v331;
  unint64_t v332;
  char *v333;
  char *v334;
  uint64_t v335;
  unint64_t v336;
  char *v337;
  _QWORD *v338;
  char *v339;
  uint64_t v340;
  unint64_t v341;
  uint64_t v342;
  unint64_t v343;
  char *v344;
  char *v345;
  uint64_t v346;
  unint64_t v347;
  char *v348;
  _QWORD *v349;
  char *v350;
  uint64_t v351;
  unint64_t v352;
  uint64_t v353;
  unint64_t v354;
  char *v355;
  char *v356;
  uint64_t v357;
  uint64_t v358;
  unint64_t v359;
  uint64_t v360;
  unint64_t v361;
  char *v362;
  uint64_t v363;
  unint64_t v364;
  uint64_t v365;
  unint64_t v366;
  char *v367;
  char *v368;
  uint64_t v369;
  unint64_t v370;
  char *v371;
  _QWORD *v372;
  char *v373;
  uint64_t v374;
  unint64_t v375;
  uint64_t v376;
  unint64_t v377;
  char *v378;
  char *v379;
  uint64_t v380;
  unint64_t v381;
  char *v382;
  _QWORD *v383;
  char *v384;
  uint64_t v385;
  unint64_t v386;
  uint64_t v387;
  unint64_t v388;
  char *v389;
  char *v390;
  uint64_t v391;
  char *v392;
  uint64_t v393;
  unint64_t v394;
  char *v395;
  _QWORD *v396;
  char *v397;
  uint64_t v398;
  unint64_t v399;
  uint64_t v400;
  unint64_t v401;
  char *v402;
  char *v403;
  uint64_t v404;
  unint64_t v405;
  char *v406;
  _QWORD *v407;
  char *v408;
  uint64_t v409;
  unint64_t v410;
  uint64_t v411;
  unint64_t v412;
  char *v413;
  char *v414;
  uint64_t v415;
  double v416;
  char *v417;
  char *v418;
  uint64_t v419;
  double *v420;
  _QWORD *v421;
  uint64_t v422;
  unint64_t v423;
  uint64_t v424;
  unint64_t v425;
  char *v426;
  char *v427;
  uint64_t v428;
  unint64_t v429;
  char *v430;
  _QWORD *v431;
  char *v432;
  uint64_t v433;
  unint64_t v434;
  uint64_t v435;
  unint64_t v436;
  char *v437;
  char *v438;
  uint64_t v439;
  unint64_t v440;
  char *v441;
  _QWORD *v442;
  char *v443;
  uint64_t v444;
  unint64_t v445;
  uint64_t v446;
  unint64_t v447;
  char *v448;
  char *v449;
  uint64_t v450;
  char v451;
  double v452;
  double v453;
  double v454;
  double v455;
  double v456;
  char *v457;
  char *v458;
  uint64_t v459;
  double *v460;
  _QWORD *v461;
  char *v462;
  char *v463;
  uint64_t v464;
  double *v465;
  _QWORD *v466;
  int v467;
  double *v468;
  double *v469;
  double *v470;
  double *v471;
  unsigned int v472;
  double *v473;
  double *v474;
  double v475;
  double *v476;
  int v477;
  double *v478;
  double *v479;
  double v480;
  _QWORD *v481;
  _QWORD *v482;
  double *v483;
  uint64_t v484;
  unint64_t v485;
  uint64_t v486;
  unint64_t v487;
  char *v488;
  double *v489;
  uint64_t v490;
  unint64_t v491;
  uint64_t v492;
  unint64_t v493;
  char *v494;
  char *v495;
  uint64_t v496;
  unint64_t v497;
  char *v498;
  _QWORD *v499;
  char *v500;
  uint64_t v501;
  unint64_t v502;
  uint64_t v503;
  unint64_t v504;
  char *v505;
  char *v506;
  uint64_t v507;
  unint64_t v508;
  char *v509;
  char *v510;
  uint64_t v511;
  unint64_t v512;
  uint64_t v513;
  unint64_t v514;
  char *v515;
  char *v516;
  uint64_t v517;
  double *v518;
  uint64_t v519;
  unint64_t v520;
  char *v521;
  _QWORD *v522;
  char *v523;
  uint64_t v524;
  unint64_t v525;
  uint64_t v526;
  unint64_t v527;
  char *v528;
  char *v529;
  uint64_t v530;
  unint64_t v531;
  uint64_t v532;
  unint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  unint64_t v537;
  uint64_t v538;
  unint64_t v539;
  char *v540;
  uint64_t v541;
  unint64_t v542;
  uint64_t v543;
  unint64_t v544;
  char *v545;
  char *v546;
  uint64_t v547;
  unint64_t v548;
  char *v549;
  _QWORD *v550;
  char *v551;
  uint64_t v552;
  unint64_t v553;
  uint64_t v554;
  unint64_t v555;
  char *v556;
  char *v557;
  uint64_t v558;
  unint64_t v559;
  char *v560;
  _QWORD *v561;
  char *v562;
  uint64_t v563;
  unint64_t v564;
  uint64_t v565;
  unint64_t v566;
  char *v567;
  char *v568;
  uint64_t v569;
  char *v570;
  uint64_t v571;
  unint64_t v572;
  char *v573;
  _QWORD *v574;
  char *v575;
  uint64_t v576;
  unint64_t v577;
  uint64_t v578;
  unint64_t v579;
  char *v580;
  char *v581;
  uint64_t v582;
  unint64_t v583;
  char *v584;
  _QWORD *v585;
  char *v586;
  uint64_t v587;
  unint64_t v588;
  uint64_t v589;
  unint64_t v590;
  char *v591;
  char *v592;
  uint64_t v593;
  double v594;
  double *v595;
  double *v596;
  char *v597;
  char *v598;
  double *v599;
  uint64_t v600;
  _QWORD *v601;
  uint64_t v602;
  int v603;
  double *v604;
  double *v605;
  double *v606;
  unsigned int v607;
  double *v608;
  double *v609;
  double v610;
  double *v611;
  int v612;
  double *v613;
  double *v614;
  double v615;
  _QWORD *v616;
  _QWORD *v617;
  double *v618;
  uint64_t v619;
  unint64_t v620;
  uint64_t v621;
  unint64_t v622;
  char *v623;
  double *v624;
  uint64_t v625;
  unint64_t v626;
  uint64_t v627;
  unint64_t v628;
  char *v629;
  char *v630;
  uint64_t v631;
  unint64_t v632;
  char *v633;
  _QWORD *v634;
  char *v635;
  uint64_t v636;
  unint64_t v637;
  uint64_t v638;
  unint64_t v639;
  char *v640;
  char *v641;
  uint64_t v642;
  unint64_t v643;
  char *v644;
  char *v645;
  uint64_t v646;
  unint64_t v647;
  uint64_t v648;
  unint64_t v649;
  char *v650;
  char *v651;
  uint64_t v652;
  double *v653;
  uint64_t v654;
  unint64_t v655;
  char *v656;
  _QWORD *v657;
  char *v658;
  uint64_t v659;
  unint64_t v660;
  uint64_t v661;
  unint64_t v662;
  char *v663;
  char *v664;
  uint64_t v665;
  unint64_t v666;
  uint64_t v667;
  unint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  double *v673;
  double v674;
  double v675;
  int v676;
  double *v677;
  double *v678;
  double *v679;
  unsigned int v680;
  uint64_t v681;
  uint64_t v682;
  _QWORD *v683;
  double v684;
  double v685;
  double v686;
  _QWORD *v687;
  uint64_t v688;
  unint64_t v689;
  uint64_t v690;
  unint64_t v691;
  char *v692;
  char *v693;
  char *v694;
  uint64_t v695;
  _QWORD *v696;
  uint64_t v697;
  unint64_t v698;
  uint64_t v699;
  unint64_t v700;
  char *v701;
  double *v702;
  double *v703;
  double v704;
  double *v705;
  int v706;
  double *v707;
  double *v708;
  double v709;
  _QWORD *v710;
  _QWORD *v711;
  double *v712;
  uint64_t v713;
  unint64_t v714;
  uint64_t v715;
  unint64_t v716;
  char *v717;
  double *v718;
  uint64_t v719;
  unint64_t v720;
  uint64_t v721;
  unint64_t v722;
  char *v723;
  char *v724;
  uint64_t v725;
  unint64_t v726;
  char *v727;
  _QWORD *v728;
  char *v729;
  uint64_t v730;
  unint64_t v731;
  uint64_t v732;
  unint64_t v733;
  char *v734;
  char *v735;
  uint64_t v736;
  unint64_t v737;
  char *v738;
  char *v739;
  uint64_t v740;
  unint64_t v741;
  uint64_t v742;
  unint64_t v743;
  char *v744;
  char *v745;
  uint64_t v746;
  double *v747;
  uint64_t v748;
  unint64_t v749;
  char *v750;
  _QWORD *v751;
  char *v752;
  uint64_t v753;
  unint64_t v754;
  uint64_t v755;
  unint64_t v756;
  char *v757;
  char *v758;
  uint64_t v759;
  unint64_t v760;
  uint64_t v761;
  unint64_t v762;
  uint64_t v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t v766;
  uint64_t v767;
  double *v768;
  uint64_t v769;
  unint64_t v770;
  char *v771;
  _QWORD *v772;
  char *v773;
  uint64_t v774;
  unint64_t v775;
  uint64_t v776;
  unint64_t v777;
  char *v778;
  double *v779;
  uint64_t v780;
  unint64_t v781;
  double *v782;
  double *v783;
  double *v784;
  uint64_t v785;
  unint64_t v786;
  uint64_t v787;
  unint64_t v788;
  char *v789;
  double *v790;
  double *v791;
  uint64_t v792;
  uint64_t v793;
  unint64_t v794;
  uint64_t v795;
  unint64_t v796;
  char *v797;
  char *v798;
  uint64_t v799;
  _QWORD *v800;
  unint64_t v801;
  char *v802;
  _QWORD *v803;
  char *v804;
  uint64_t v805;
  unint64_t v806;
  uint64_t v807;
  unint64_t v808;
  char *v809;
  char *v810;
  uint64_t v811;
  double v812;
  unint64_t v813;
  double *v814;
  uint64_t v815;
  unint64_t v816;
  uint64_t v817;
  uint64_t v818;
  double *v819;
  uint64_t v820;
  unint64_t v821;
  char *v822;
  _QWORD *v823;
  char *v824;
  uint64_t v825;
  unint64_t v826;
  uint64_t v827;
  unint64_t v828;
  char *v829;
  double *v830;
  uint64_t v831;
  unint64_t v832;
  char *v833;
  uint64_t v834;
  unint64_t v835;
  uint64_t v836;
  uint64_t v837;
  double *v838;
  double *v839;
  double *v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  double v844;
  double *v845;
  char *v846;
  int64_t v847;
  char *v848;
  int64_t v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  char *v853;
  int v854;
  uint64_t v855;
  char *v856;
  double v857;
  double v858;
  double v859;
  uint64_t v860;
  uint64_t v861;
  _DWORD *v865;
  uint64_t v866;
  int v867;
  double v868;
  double *v869;
  double *v870;
  double *v871;
  double *v872;
  uint64_t v873;
  double **v874;
  uint64_t v875;
  _BOOL4 v876;
  OZChannel *v877;
  char v878;
  double *v879;
  _BOOL4 v880;
  uint64_t v881;
  uint64_t v882;
  char **v883;
  double *v884;
  char **v885;
  uint64_t v886;
  uint64_t v887;
  _QWORD *v888;
  double v889[2];

  v9 = *(double *)(a3 + 72);
  v10 = *(double *)(a3 + 80);
  if (vabdd_f64(v9, v10) < 0.0000001 || v9 > v10)
  {
    if (a5)
      *a5 = 0;
    if (a6)
    {
      v12 = 0;
LABEL_1501:
      *a6 = v12;
      return;
    }
    return;
  }
  v865 = a6;
  v14 = *(_QWORD *)(a3 + 752);
  v15 = v14 + 192;
  if (*(_BYTE *)(a3 + 112))
    v16 = 400;
  else
    v16 = 192;
  if (*(_BYTE *)(a3 + 112))
    v15 = v14 + 400;
  v17 = 448;
  if (!*(_BYTE *)(a3 + 112))
    v17 = 240;
  v887 = v17;
  v18 = 424;
  if (!*(_BYTE *)(a3 + 112))
    v18 = 216;
  v886 = v18;
  if (*(_BYTE *)(a3 + 112))
    v19 = v14 + 424;
  else
    v19 = v14 + 216;
  v866 = v15;
  if (*(_QWORD *)(v15 + 8) != *(_QWORD *)(v14 + v16))
  {
    if (*(_DWORD *)(a3 + 180))
      v22 = a3 + 760;
    else
      v22 = a3 + 368;
    v873 = v22;
    v23 = v10 - v9;
    v24 = v9 + *(double *)(a3 + 88);
    v25 = v10 - v9 + v24;
    if (*(_DWORD *)(a3 + 168))
    {
      v26 = 1.0;
      v27 = fmod(v9 + *(double *)(a3 + 88), 1.0);
      v28 = 0.0;
      if (v24 >= 1.0 || v24 < 0.0)
        v24 = v27;
      if (v25 > 1.0 || v25 <= 0.0)
        v25 = fmod(v25, 1.0);
    }
    else
    {
      v30 = 1.0;
      if (v24 <= 1.0)
        v31 = v24;
      else
        v31 = 1.0;
      if (v24 >= 0.0)
        v28 = v31;
      else
        v28 = 0.0;
      if (v25 <= 1.0)
        v30 = v25;
      if (v25 >= 0.0)
        v26 = v30;
      else
        v26 = 0.0;
      v25 = v26;
      v24 = v28;
    }
    v32 = fabs(v23);
    v33 = v32 > 1.0;
    if (fabs(v32 + -1.0) < 0.0000001)
      v33 = 1;
    if (v33)
    {
      v25 = v26;
      v24 = v28;
    }
    *(_QWORD *)(a3 + 328) = *(_QWORD *)(a3 + 320);
    *(_QWORD *)(a3 + 352) = *(_QWORD *)(a3 + 344);
    *(_QWORD *)(a3 + 304) = *(_QWORD *)(a3 + 296);
    v35 = !OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0)
       || OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4
       && (OZChannel::getValueAsDouble((OZChannel *)(a1 + 12072), a2, 0.0), v34 < 0.01)
       || OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 5;
    v880 = v35;
    v877 = (OZChannel *)(a1 + 1072);
    if (OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4)
    {
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 12072), a2, 0.0);
      v876 = v36 > 0.99;
    }
    else
    {
      v876 = 0;
    }
    v37 = 0;
    v874 = (double **)(a3 + 320);
    v885 = (char **)(a3 + 344);
    v883 = (char **)(a3 + 296);
    v888 = (_QWORD *)(a3 + 336);
    v881 = a3 + 312;
    v882 = a3 + 360;
    v859 = fabs(v25 + -1.0);
    v38 = 0.5;
    v875 = v19;
    v860 = v16;
    v861 = v14;
    while (1)
    {
      v39 = (uint64_t)(*(_QWORD *)(v19 + 8) - *(_QWORD *)(v14 + v886)) >> 3;
      v40 = vcvtmd_s64_f64(v24 * (double)(unint64_t)v39 + v38 + 0.0000001);
      v41 = vcvtmd_s64_f64(v25 * (double)(unint64_t)v39 + v38 + 0.0000001);
      v42 = v24 <= v25 ? v41 : (uint64_t)(*(_QWORD *)(v19 + 8) - *(_QWORD *)(v14 + v886)) >> 3;
      v43 = v42 == v39;
      v44 = v42 == (_DWORD)v39 ? -1 : 0;
      v45 = v42 - v43;
      v46 = v40 - (v40 == (_DWORD)v39);
      if (v42 - v43 != v46)
        break;
LABEL_1479:
      if (v24 > v25)
      {
        v37 = 1;
        v24 = 0.0;
        if (*(_DWORD *)(a3 + 168))
          continue;
      }
      goto LABEL_1491;
    }
    v878 = v37;
    ValueAsInt = OZChannel::getValueAsInt(v877, MEMORY[0x1E0CA2E68], 0.0);
    v48 = v880;
    if (ValueAsInt != 4)
      v48 = 1;
    if (((v48 | v876) & 1) == 0)
    {
      while (v46 <= v45)
      {
        v86 = *(char **)(a3 + 320);
        v87 = *(char **)(a3 + 328);
        v88 = *(_QWORD *)(v14 + v886);
        v89 = v87 - v86;
        if (v87 == v86
          || vabdd_f64(*((double *)v87 - 1), *(double *)(v88 + 8 * v46)) >= 0.0000001
          || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *(double *)(*(_QWORD *)(v14 + v887) + 8 * v46)) >= 0.0000001)
        {
          if ((unint64_t)v87 >= *v888)
          {
            v91 = v89 >> 3;
            v92 = (v89 >> 3) + 1;
            if (v92 >> 61)
              goto LABEL_1505;
            v93 = *v888 - (_QWORD)v86;
            if (v93 >> 2 > v92)
              v92 = v93 >> 2;
            if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFF8)
              v94 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v94 = v92;
            if (v94)
            {
              v95 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v94);
              v86 = *(char **)(a3 + 320);
              v87 = *(char **)(a3 + 328);
            }
            else
            {
              v95 = 0;
            }
            v96 = &v95[8 * v91];
            *(_QWORD *)v96 = *(_QWORD *)(v88 + 8 * v46);
            v90 = v96 + 8;
            while (v87 != v86)
            {
              v97 = *((_QWORD *)v87 - 1);
              v87 -= 8;
              *((_QWORD *)v96 - 1) = v97;
              v96 -= 8;
            }
            *(_QWORD *)(a3 + 320) = v96;
            *(_QWORD *)(a3 + 328) = v90;
            *(_QWORD *)(a3 + 336) = &v95[8 * v94];
            if (v86)
              operator delete(v86);
          }
          else
          {
            *(_QWORD *)v87 = *(_QWORD *)(v88 + 8 * v46);
            v90 = v87 + 8;
          }
          *(_QWORD *)(a3 + 328) = v90;
          v98 = *(_QWORD *)(v14 + v887);
          v100 = *(char **)(a3 + 352);
          v99 = *(_QWORD *)(a3 + 360);
          if ((unint64_t)v100 >= v99)
          {
            v102 = *v885;
            v103 = (v100 - *v885) >> 3;
            v104 = v103 + 1;
            if ((unint64_t)(v103 + 1) >> 61)
              goto LABEL_1503;
            v105 = v99 - (_QWORD)v102;
            if (v105 >> 2 > v104)
              v104 = v105 >> 2;
            if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8)
              v106 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v106 = v104;
            if (v106)
            {
              v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v106);
              v102 = *(char **)(a3 + 344);
              v100 = *(char **)(a3 + 352);
            }
            else
            {
              v107 = 0;
            }
            v108 = &v107[8 * v103];
            *(_QWORD *)v108 = *(_QWORD *)(v98 + 8 * v46);
            v101 = v108 + 8;
            while (v100 != v102)
            {
              v109 = *((_QWORD *)v100 - 1);
              v100 -= 8;
              *((_QWORD *)v108 - 1) = v109;
              v108 -= 8;
            }
            *(_QWORD *)(a3 + 344) = v108;
            *(_QWORD *)(a3 + 352) = v101;
            *(_QWORD *)(a3 + 360) = &v107[8 * v106];
            if (v102)
              operator delete(v102);
          }
          else
          {
            *(_QWORD *)v100 = *(_QWORD *)(v98 + 8 * v46);
            v101 = v100 + 8;
          }
          *(_QWORD *)(a3 + 352) = v101;
          v110 = *(_QWORD *)(v14 + v16);
          v112 = *(char **)(a3 + 304);
          v111 = *(_QWORD *)(a3 + 312);
          if ((unint64_t)v112 >= v111)
          {
            v114 = *v883;
            v115 = (v112 - *v883) >> 3;
            v116 = v115 + 1;
            if ((unint64_t)(v115 + 1) >> 61)
              goto LABEL_1504;
            v117 = v111 - (_QWORD)v114;
            if (v117 >> 2 > v116)
              v116 = v117 >> 2;
            if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFF8)
              v118 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v118 = v116;
            if (v118)
            {
              v119 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v118);
              v114 = *(char **)(a3 + 296);
              v112 = *(char **)(a3 + 304);
            }
            else
            {
              v119 = 0;
            }
            v120 = &v119[8 * v115];
            *(_QWORD *)v120 = *(_QWORD *)(v110 + 8 * v46);
            v113 = v120 + 8;
            while (v112 != v114)
            {
              v121 = *((_QWORD *)v112 - 1);
              v112 -= 8;
              *((_QWORD *)v120 - 1) = v121;
              v120 -= 8;
            }
            *(_QWORD *)(a3 + 296) = v120;
            *(_QWORD *)(a3 + 304) = v113;
            *(_QWORD *)(a3 + 312) = &v119[8 * v118];
            if (v114)
              operator delete(v114);
          }
          else
          {
            *(_QWORD *)v112 = *(_QWORD *)(v110 + 8 * v46);
            v113 = v112 + 8;
          }
          *(_QWORD *)(a3 + 304) = v113;
        }
        ++v46;
      }
      goto LABEL_1463;
    }
    if (*(_DWORD *)(a3 + 180))
    {
      if ((int)v46 <= (int)v45)
      {
        v49 = v40 - (unint64_t)(v40 == (_DWORD)v39);
        do
        {
          v50 = *(char **)(a3 + 320);
          v51 = *(char **)(a3 + 328);
          v52 = *(_QWORD *)(v14 + v886);
          v53 = v51 - v50;
          if (v51 == v50
            || vabdd_f64(*((double *)v51 - 1), *(double *)(v52 + 8 * v49)) >= 0.0000001
            || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *(double *)(*(_QWORD *)(v14 + v887) + 8 * v49)) >= 0.0000001)
          {
            if ((unint64_t)v51 >= *v888)
            {
              v55 = v53 >> 3;
              v56 = (v53 >> 3) + 1;
              if (v56 >> 61)
                goto LABEL_1505;
              v57 = *v888 - (_QWORD)v50;
              if (v57 >> 2 > v56)
                v56 = v57 >> 2;
              if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8)
                v58 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v58 = v56;
              if (v58)
              {
                v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v58);
                v50 = *(char **)(a3 + 320);
                v51 = *(char **)(a3 + 328);
              }
              else
              {
                v59 = 0;
              }
              v60 = &v59[8 * v55];
              *(_QWORD *)v60 = *(_QWORD *)(v52 + 8 * v49);
              v54 = v60 + 8;
              while (v51 != v50)
              {
                v61 = *((_QWORD *)v51 - 1);
                v51 -= 8;
                *((_QWORD *)v60 - 1) = v61;
                v60 -= 8;
              }
              *(_QWORD *)(a3 + 320) = v60;
              *(_QWORD *)(a3 + 328) = v54;
              *(_QWORD *)(a3 + 336) = &v59[8 * v58];
              if (v50)
                operator delete(v50);
            }
            else
            {
              *(_QWORD *)v51 = *(_QWORD *)(v52 + 8 * v49);
              v54 = v51 + 8;
            }
            *(_QWORD *)(a3 + 328) = v54;
            v62 = *(_QWORD *)(v14 + v887);
            v64 = *(char **)(a3 + 352);
            v63 = *(_QWORD *)(a3 + 360);
            if ((unint64_t)v64 >= v63)
            {
              v66 = *v885;
              v67 = (v64 - *v885) >> 3;
              v68 = v67 + 1;
              if ((unint64_t)(v67 + 1) >> 61)
                goto LABEL_1503;
              v69 = v63 - (_QWORD)v66;
              if (v69 >> 2 > v68)
                v68 = v69 >> 2;
              if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
                v70 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v70 = v68;
              if (v70)
              {
                v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v70);
                v66 = *(char **)(a3 + 344);
                v64 = *(char **)(a3 + 352);
              }
              else
              {
                v71 = 0;
              }
              v72 = &v71[8 * v67];
              *(_QWORD *)v72 = *(_QWORD *)(v62 + 8 * v49);
              v65 = v72 + 8;
              while (v64 != v66)
              {
                v73 = *((_QWORD *)v64 - 1);
                v64 -= 8;
                *((_QWORD *)v72 - 1) = v73;
                v72 -= 8;
              }
              *(_QWORD *)(a3 + 344) = v72;
              *(_QWORD *)(a3 + 352) = v65;
              *(_QWORD *)(a3 + 360) = &v71[8 * v70];
              if (v66)
                operator delete(v66);
            }
            else
            {
              *(_QWORD *)v64 = *(_QWORD *)(v62 + 8 * v49);
              v65 = v64 + 8;
            }
            *(_QWORD *)(a3 + 352) = v65;
            v74 = *(_QWORD *)(v14 + v16);
            v76 = *(char **)(a3 + 304);
            v75 = *(_QWORD *)(a3 + 312);
            if ((unint64_t)v76 >= v75)
            {
              v78 = *v883;
              v79 = (v76 - *v883) >> 3;
              v80 = v79 + 1;
              if ((unint64_t)(v79 + 1) >> 61)
                goto LABEL_1504;
              v81 = v75 - (_QWORD)v78;
              if (v81 >> 2 > v80)
                v80 = v81 >> 2;
              if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8)
                v82 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v82 = v80;
              if (v82)
              {
                v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v82);
                v78 = *(char **)(a3 + 296);
                v76 = *(char **)(a3 + 304);
              }
              else
              {
                v83 = 0;
              }
              v84 = &v83[8 * v79];
              *(_QWORD *)v84 = *(_QWORD *)(v74 + 8 * v49);
              v77 = v84 + 8;
              while (v76 != v78)
              {
                v85 = *((_QWORD *)v76 - 1);
                v76 -= 8;
                *((_QWORD *)v84 - 1) = v85;
                v84 -= 8;
              }
              *(_QWORD *)(a3 + 296) = v84;
              *(_QWORD *)(a3 + 304) = v77;
              *(_QWORD *)(a3 + 312) = &v83[8 * v82];
              if (v78)
                operator delete(v78);
            }
            else
            {
              *(_QWORD *)v76 = *(_QWORD *)(v74 + 8 * v49);
              v77 = v76 + 8;
            }
            *(_QWORD *)(a3 + 304) = v77;
          }
          ++v49;
        }
        while (v42 + v44 + 1 != (_DWORD)v49);
      }
      goto LABEL_1463;
    }
    v122 = *(double **)(v14 + v16);
    v123 = v122[v45];
    v124 = *(double **)(v866 + 8);
    v125 = v859 >= 0.0000001 || v124 == v122;
    v126 = v122[v45];
    if (!v125)
      v126 = ceil(*(v124 - 1));
    v127 = v122[v46];
    v128 = *(double **)(v14 + v886);
    v129 = *(double **)(v14 + v887);
    v130 = *(double **)(v873 + 216);
    v131 = *(double **)(v873 + 240);
    v133 = *(double **)(v873 + 192);
    v132 = *(double **)(v873 + 200);
    v884 = *(double **)(v866 + 8);
    v879 = v132;
    if (v126 - v127 < 1.0 && vabdd_f64(floor(v127), floor(v126)) < 0.0000001)
    {
      if (v133 != v132)
      {
        while (*v133 < v127)
        {
          ++v133;
          ++v130;
          ++v131;
          if (v133 == v132)
          {
            v133 = *(double **)(v873 + 200);
            break;
          }
        }
      }
      if (v124 == v122)
      {
        if (!v880)
          goto LABEL_1044;
        goto LABEL_1463;
      }
      v134 = 0;
      v135 = 0.0;
      v136 = 0.0;
      v137 = 0.0;
      while (1)
      {
        v138 = *v122;
        if (*v122 > v126)
          goto LABEL_506;
        if (v138 < v127)
        {
          ++v128;
          ++v129;
          ++v122;
          goto LABEL_504;
        }
        if (v880)
        {
          if ((v134 & 1) == 0)
          {
            v139 = *(char **)(a3 + 320);
            v140 = *(char **)(a3 + 328);
            v141 = v140 - v139;
            if (v140 == v139
              || vabdd_f64(*((double *)v140 - 1), *v128) >= 0.0000001
              || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v129) >= 0.0000001)
            {
              v142 = v131;
              if ((unint64_t)v140 >= *v888)
              {
                v188 = v141 >> 3;
                v189 = (v141 >> 3) + 1;
                if (v189 >> 61)
                  goto LABEL_1505;
                v190 = *v888 - (_QWORD)v139;
                if (v190 >> 2 > v189)
                  v189 = v190 >> 2;
                if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8)
                  v191 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v191 = v189;
                if (v191)
                {
                  v192 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v191);
                  v139 = *(char **)(a3 + 320);
                  v140 = *(char **)(a3 + 328);
                }
                else
                {
                  v192 = 0;
                }
                v257 = &v192[8 * v188];
                *(double *)v257 = *v128;
                v143 = v257 + 8;
                while (v140 != v139)
                {
                  v258 = *((_QWORD *)v140 - 1);
                  v140 -= 8;
                  *((_QWORD *)v257 - 1) = v258;
                  v257 -= 8;
                }
                *(_QWORD *)(a3 + 320) = v257;
                *(_QWORD *)(a3 + 328) = v143;
                *(_QWORD *)(a3 + 336) = &v192[8 * v191];
                if (v139)
                  operator delete(v139);
              }
              else
              {
                *(double *)v140 = *v128;
                v143 = v140 + 8;
              }
              *(_QWORD *)(a3 + 328) = v143;
              v260 = *(char **)(a3 + 352);
              v259 = *(_QWORD *)(a3 + 360);
              if ((unint64_t)v260 >= v259)
              {
                v262 = *v885;
                v263 = (v260 - *v885) >> 3;
                v264 = v263 + 1;
                if ((unint64_t)(v263 + 1) >> 61)
                  goto LABEL_1503;
                v265 = v259 - (_QWORD)v262;
                if (v265 >> 2 > v264)
                  v264 = v265 >> 2;
                if ((unint64_t)v265 >= 0x7FFFFFFFFFFFFFF8)
                  v266 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v266 = v264;
                if (v266)
                {
                  v267 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v266);
                  v262 = *(char **)(a3 + 344);
                  v260 = *(char **)(a3 + 352);
                }
                else
                {
                  v267 = 0;
                }
                v268 = &v267[8 * v263];
                *(double *)v268 = *v129;
                v261 = v268 + 8;
                while (v260 != v262)
                {
                  v269 = *((_QWORD *)v260 - 1);
                  v260 -= 8;
                  *((_QWORD *)v268 - 1) = v269;
                  v268 -= 8;
                }
                *(_QWORD *)(a3 + 344) = v268;
                *(_QWORD *)(a3 + 352) = v261;
                *(_QWORD *)(a3 + 360) = &v267[8 * v266];
                if (v262)
                  operator delete(v262);
              }
              else
              {
                *(double *)v260 = *v129;
                v261 = v260 + 8;
              }
              *(_QWORD *)(a3 + 352) = v261;
              v271 = *(char **)(a3 + 304);
              v270 = *(_QWORD *)(a3 + 312);
              if ((unint64_t)v271 >= v270)
              {
                v273 = *v883;
                v274 = (v271 - *v883) >> 3;
                v275 = v274 + 1;
                if ((unint64_t)(v274 + 1) >> 61)
                  goto LABEL_1504;
                v276 = v270 - (_QWORD)v273;
                if (v276 >> 2 > v275)
                  v275 = v276 >> 2;
                if ((unint64_t)v276 >= 0x7FFFFFFFFFFFFFF8)
                  v277 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v277 = v275;
                if (v277)
                {
                  v278 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v277);
                  v273 = *(char **)(a3 + 296);
                  v271 = *(char **)(a3 + 304);
                }
                else
                {
                  v278 = 0;
                }
                v279 = &v278[8 * v274];
                *(double *)v279 = *v122;
                v272 = v279 + 8;
                while (v271 != v273)
                {
                  v280 = *((_QWORD *)v271 - 1);
                  v271 -= 8;
                  *((_QWORD *)v279 - 1) = v280;
                  v279 -= 8;
                }
                *(_QWORD *)(a3 + 296) = v279;
                *(_QWORD *)(a3 + 304) = v272;
                *(_QWORD *)(a3 + 312) = &v278[8 * v277];
                if (v273)
                  operator delete(v273);
              }
              else
              {
                *(double *)v271 = *v122;
                v272 = v271 + 8;
              }
              *(_QWORD *)(a3 + 304) = v272;
              v138 = *v122;
              v131 = v142;
              v132 = v879;
            }
          }
          v281 = *v128++;
          v135 = v281;
          v282 = *v129++;
          v136 = v282;
          ++v122;
          v134 = 1;
          v137 = v138;
          v124 = v884;
          goto LABEL_504;
        }
        if (v133 == v132)
        {
          if ((v134 & 1) == 0)
            goto LABEL_222;
        }
        else
        {
          if (((*v133 < v126) & v134) == 1)
          {
            v144 = *(char **)(a3 + 320);
            v145 = *(char **)(a3 + 328);
            v146 = v145 - v144;
            if (v145 == v144
              || vabdd_f64(*((double *)v145 - 1), *v130) >= 0.0000001
              || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v131) >= 0.0000001)
            {
              v147 = v131;
              if ((unint64_t)v145 >= *v888)
              {
                v193 = v146 >> 3;
                v194 = (v146 >> 3) + 1;
                if (v194 >> 61)
                  goto LABEL_1505;
                v195 = *v888 - (_QWORD)v144;
                if (v195 >> 2 > v194)
                  v194 = v195 >> 2;
                if ((unint64_t)v195 >= 0x7FFFFFFFFFFFFFF8)
                  v196 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v196 = v194;
                if (v196)
                {
                  v197 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v196);
                  v144 = *(char **)(a3 + 320);
                  v145 = *(char **)(a3 + 328);
                }
                else
                {
                  v197 = 0;
                }
                v283 = &v197[8 * v193];
                *(double *)v283 = *v130;
                v148 = v283 + 8;
                while (v145 != v144)
                {
                  v284 = *((_QWORD *)v145 - 1);
                  v145 -= 8;
                  *((_QWORD *)v283 - 1) = v284;
                  v283 -= 8;
                }
                *(_QWORD *)(a3 + 320) = v283;
                *(_QWORD *)(a3 + 328) = v148;
                *(_QWORD *)(a3 + 336) = &v197[8 * v196];
                if (v144)
                  operator delete(v144);
              }
              else
              {
                *(double *)v145 = *v130;
                v148 = v145 + 8;
              }
              *(_QWORD *)(a3 + 328) = v148;
              v286 = *(char **)(a3 + 352);
              v285 = *(_QWORD *)(a3 + 360);
              if ((unint64_t)v286 >= v285)
              {
                v288 = *v885;
                v289 = (v286 - *v885) >> 3;
                v290 = v289 + 1;
                if ((unint64_t)(v289 + 1) >> 61)
                  goto LABEL_1503;
                v291 = v285 - (_QWORD)v288;
                if (v291 >> 2 > v290)
                  v290 = v291 >> 2;
                if ((unint64_t)v291 >= 0x7FFFFFFFFFFFFFF8)
                  v292 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v292 = v290;
                if (v292)
                {
                  v293 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v292);
                  v288 = *(char **)(a3 + 344);
                  v286 = *(char **)(a3 + 352);
                }
                else
                {
                  v293 = 0;
                }
                v294 = &v293[8 * v289];
                *(double *)v294 = *v147;
                v287 = v294 + 8;
                while (v286 != v288)
                {
                  v295 = *((_QWORD *)v286 - 1);
                  v286 -= 8;
                  *((_QWORD *)v294 - 1) = v295;
                  v294 -= 8;
                }
                *(_QWORD *)(a3 + 344) = v294;
                *(_QWORD *)(a3 + 352) = v287;
                *(_QWORD *)(a3 + 360) = &v293[8 * v292];
                if (v288)
                  operator delete(v288);
              }
              else
              {
                *(double *)v286 = *v147;
                v287 = v286 + 8;
              }
              *(_QWORD *)(a3 + 352) = v287;
              v297 = *(char **)(a3 + 304);
              v296 = *(_QWORD *)(a3 + 312);
              if ((unint64_t)v297 >= v296)
              {
                v299 = *v883;
                v300 = (v297 - *v883) >> 3;
                v301 = v300 + 1;
                if ((unint64_t)(v300 + 1) >> 61)
                  goto LABEL_1504;
                v302 = v296 - (_QWORD)v299;
                if (v302 >> 2 > v301)
                  v301 = v302 >> 2;
                if ((unint64_t)v302 >= 0x7FFFFFFFFFFFFFF8)
                  v303 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v303 = v301;
                if (v303)
                {
                  v304 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v303);
                  v299 = *(char **)(a3 + 296);
                  v297 = *(char **)(a3 + 304);
                }
                else
                {
                  v304 = 0;
                }
                v305 = &v304[8 * v300];
                *(double *)v305 = *v133;
                v298 = v305 + 8;
                while (v297 != v299)
                {
                  v306 = *((_QWORD *)v297 - 1);
                  v297 -= 8;
                  *((_QWORD *)v305 - 1) = v306;
                  v305 -= 8;
                }
                *(_QWORD *)(a3 + 296) = v305;
                *(_QWORD *)(a3 + 304) = v298;
                *(_QWORD *)(a3 + 312) = &v304[8 * v303];
                if (v299)
                  operator delete(v299);
              }
              else
              {
                *(double *)v297 = *v133;
                v298 = v297 + 8;
              }
              *(_QWORD *)(a3 + 304) = v298;
              v131 = v147;
              v132 = v879;
            }
            v124 = v884;
            if (v122 == v884)
            {
LABEL_501:
              v122 = v884;
            }
            else
            {
              while (*v122 < *v133)
              {
                ++v128;
                ++v129;
                if (++v122 == v884)
                  goto LABEL_501;
              }
            }
            ++v133;
            ++v130;
            ++v131;
            goto LABEL_503;
          }
          if (((vabdd_f64(*v133, v126) < 0.0000001) & v134) == 0)
          {
LABEL_222:
            v870 = v131;
            if (v122 == v124)
            {
              v122 = v124;
            }
            else
            {
              v154 = 0;
              while (*v122 <= v126)
              {
                v155 = *(char **)(a3 + 320);
                v156 = *(char **)(a3 + 328);
                v157 = v156 - v155;
                if (v156 == v155
                  || vabdd_f64(*((double *)v156 - 1), *v128) >= 0.0000001
                  || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v129) >= 0.0000001)
                {
                  if ((unint64_t)v156 >= *v888)
                  {
                    v159 = v157 >> 3;
                    v160 = (v157 >> 3) + 1;
                    if (v160 >> 61)
                      goto LABEL_1505;
                    v161 = *v888 - (_QWORD)v155;
                    if (v161 >> 2 > v160)
                      v160 = v161 >> 2;
                    if ((unint64_t)v161 >= 0x7FFFFFFFFFFFFFF8)
                      v162 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v162 = v160;
                    if (v162)
                    {
                      v163 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v162);
                      v155 = *(char **)(a3 + 320);
                      v156 = *(char **)(a3 + 328);
                    }
                    else
                    {
                      v163 = 0;
                    }
                    v164 = &v163[8 * v159];
                    *(double *)v164 = *v128;
                    v158 = v164 + 8;
                    while (v156 != v155)
                    {
                      v165 = *((_QWORD *)v156 - 1);
                      v156 -= 8;
                      *((_QWORD *)v164 - 1) = v165;
                      v164 -= 8;
                    }
                    *(_QWORD *)(a3 + 320) = v164;
                    *(_QWORD *)(a3 + 328) = v158;
                    *(_QWORD *)(a3 + 336) = &v163[8 * v162];
                    if (v155)
                      operator delete(v155);
                  }
                  else
                  {
                    *(double *)v156 = *v128;
                    v158 = v156 + 8;
                  }
                  *(_QWORD *)(a3 + 328) = v158;
                  v167 = *(char **)(a3 + 352);
                  v166 = *(_QWORD *)(a3 + 360);
                  if ((unint64_t)v167 >= v166)
                  {
                    v169 = *v885;
                    v170 = (v167 - *v885) >> 3;
                    v171 = v170 + 1;
                    if ((unint64_t)(v170 + 1) >> 61)
                      goto LABEL_1503;
                    v172 = v166 - (_QWORD)v169;
                    if (v172 >> 2 > v171)
                      v171 = v172 >> 2;
                    if ((unint64_t)v172 >= 0x7FFFFFFFFFFFFFF8)
                      v173 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v173 = v171;
                    if (v173)
                    {
                      v174 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v173);
                      v169 = *(char **)(a3 + 344);
                      v167 = *(char **)(a3 + 352);
                    }
                    else
                    {
                      v174 = 0;
                    }
                    v175 = &v174[8 * v170];
                    *(double *)v175 = *v129;
                    v168 = v175 + 8;
                    while (v167 != v169)
                    {
                      v176 = *((_QWORD *)v167 - 1);
                      v167 -= 8;
                      *((_QWORD *)v175 - 1) = v176;
                      v175 -= 8;
                    }
                    *(_QWORD *)(a3 + 344) = v175;
                    *(_QWORD *)(a3 + 352) = v168;
                    *(_QWORD *)(a3 + 360) = &v174[8 * v173];
                    if (v169)
                      operator delete(v169);
                  }
                  else
                  {
                    *(double *)v167 = *v129;
                    v168 = v167 + 8;
                  }
                  *(_QWORD *)(a3 + 352) = v168;
                  v178 = *(char **)(a3 + 304);
                  v177 = *(_QWORD *)(a3 + 312);
                  if ((unint64_t)v178 >= v177)
                  {
                    v180 = *v883;
                    v181 = (v178 - *v883) >> 3;
                    v182 = v181 + 1;
                    if ((unint64_t)(v181 + 1) >> 61)
                      goto LABEL_1504;
                    v183 = v177 - (_QWORD)v180;
                    if (v183 >> 2 > v182)
                      v182 = v183 >> 2;
                    if ((unint64_t)v183 >= 0x7FFFFFFFFFFFFFF8)
                      v184 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v184 = v182;
                    if (v184)
                    {
                      v185 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v184);
                      v180 = *(char **)(a3 + 296);
                      v178 = *(char **)(a3 + 304);
                    }
                    else
                    {
                      v185 = 0;
                    }
                    v186 = &v185[8 * v181];
                    *(double *)v186 = *v122;
                    v179 = v186 + 8;
                    while (v178 != v180)
                    {
                      v187 = *((_QWORD *)v178 - 1);
                      v178 -= 8;
                      *((_QWORD *)v186 - 1) = v187;
                      v186 -= 8;
                    }
                    *(_QWORD *)(a3 + 296) = v186;
                    *(_QWORD *)(a3 + 304) = v179;
                    *(_QWORD *)(a3 + 312) = &v185[8 * v184];
                    if (v180)
                      operator delete(v180);
                  }
                  else
                  {
                    *(double *)v178 = *v122;
                    v179 = v178 + 8;
                  }
                  *(_QWORD *)(a3 + 304) = v179;
                  LOBYTE(v134) = 1;
                }
                ++v128;
                ++v129;
                ++v122;
                if (v154 > 1)
                {
                  v124 = v884;
                  if ((v134 & 1) != 0)
                    goto LABEL_299;
                  goto LABEL_458;
                }
                ++v154;
                v124 = v884;
                if (v122 == v884)
                  break;
              }
            }
            if ((v134 & 1) == 0)
            {
LABEL_458:
              v134 = 0;
              v131 = v870;
              v132 = v879;
              goto LABEL_504;
            }
LABEL_299:
            v132 = v879;
            v131 = v870;
            if (v133 == v879)
            {
              v134 = 1;
LABEL_456:
              v133 = v879;
              goto LABEL_504;
            }
            while (*v133 <= *(double *)(*(_QWORD *)(a3 + 304) - 8))
            {
              ++v133;
              ++v130;
              ++v131;
              v134 = 1;
              if (v133 == v879)
                goto LABEL_456;
            }
LABEL_503:
            v134 = 1;
            goto LABEL_504;
          }
        }
        v869 = v131;
        v867 = v134;
        if (v122 == v124)
        {
LABEL_214:
          v122 = v124;
        }
        else
        {
          while (*v122 < v126)
          {
            ++v128;
            ++v129;
            if (++v122 == v124)
              goto LABEL_214;
          }
        }
        v149 = 0;
        v150 = *(double **)(v14 + v16);
        v151 = v122 - 3;
        v152 = v129 - 3;
        v153 = v128 - 3;
        while (1)
        {
          if (v122 == v150)
          {
            v151 = v150;
            goto LABEL_304;
          }
          if (v122 != v124 && *v122 <= v127)
            break;
          --v128;
          --v129;
          --v122;
          if (++v149 == 3)
            goto LABEL_305;
        }
        v151 = v122;
LABEL_304:
        v152 = v129;
        v153 = v128;
LABEL_305:
        if (v149 && v151 != v124)
          break;
LABEL_413:
        if (v151 == v124)
        {
          v122 = v124;
          v129 = v152;
          v128 = v153;
          v16 = v860;
          v14 = v861;
          LOBYTE(v134) = v867;
LABEL_506:
          if (v880)
          {
            if ((v134 & 1) == 0)
              goto LABEL_1463;
            v307 = *(char **)(a3 + 320);
            v308 = *(char **)(a3 + 328);
            v309 = v308 - v307;
            if (v308 != v307
              && vabdd_f64(*((double *)v308 - 1), v135) < 0.0000001
              && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), v136) < 0.0000001)
            {
              goto LABEL_1463;
            }
            if ((unint64_t)v308 >= *v888)
            {
              v793 = v309 >> 3;
              v794 = (v309 >> 3) + 1;
              if (v794 >> 61)
LABEL_1505:
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v795 = *v888 - (_QWORD)v307;
              if (v795 >> 2 > v794)
                v794 = v795 >> 2;
              if ((unint64_t)v795 >= 0x7FFFFFFFFFFFFFF8)
                v796 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v796 = v794;
              if (v796)
              {
                v797 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v796);
                v307 = *(char **)(a3 + 320);
                v308 = *(char **)(a3 + 328);
              }
              else
              {
                v797 = 0;
              }
              v819 = (double *)&v797[8 * v793];
              *v819 = v135;
              v310 = v819 + 1;
              while (v308 != v307)
              {
                v820 = *((_QWORD *)v308 - 1);
                v308 -= 8;
                *((_QWORD *)v819-- - 1) = v820;
              }
              *(_QWORD *)(a3 + 320) = v819;
              *(_QWORD *)(a3 + 328) = v310;
              *(_QWORD *)(a3 + 336) = &v797[8 * v796];
              if (v307)
                operator delete(v307);
            }
            else
            {
              *(double *)v308 = v135;
              v310 = v308 + 8;
            }
            *(_QWORD *)(a3 + 328) = v310;
            v822 = *(char **)(a3 + 352);
            v821 = *(_QWORD *)(a3 + 360);
            if ((unint64_t)v822 >= v821)
            {
              v824 = *v885;
              v825 = (v822 - *v885) >> 3;
              v826 = v825 + 1;
              if ((unint64_t)(v825 + 1) >> 61)
LABEL_1503:
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v827 = v821 - (_QWORD)v824;
              if (v827 >> 2 > v826)
                v826 = v827 >> 2;
              if ((unint64_t)v827 >= 0x7FFFFFFFFFFFFFF8)
                v828 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v828 = v826;
              if (v828)
              {
                v829 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v828);
                v824 = *(char **)(a3 + 344);
                v822 = *(char **)(a3 + 352);
              }
              else
              {
                v829 = 0;
              }
              v830 = (double *)&v829[8 * v825];
              *v830 = v136;
              v823 = v830 + 1;
              while (v822 != v824)
              {
                v831 = *((_QWORD *)v822 - 1);
                v822 -= 8;
                *((_QWORD *)v830-- - 1) = v831;
              }
              *(_QWORD *)(a3 + 344) = v830;
              *(_QWORD *)(a3 + 352) = v823;
              *(_QWORD *)(a3 + 360) = &v829[8 * v828];
              if (v824)
                operator delete(v824);
            }
            else
            {
              *(double *)v822 = v136;
              v823 = v822 + 8;
            }
            *(_QWORD *)(a3 + 352) = v823;
            v833 = *(char **)(a3 + 304);
            v832 = *(_QWORD *)(a3 + 312);
            if ((unint64_t)v833 < v832)
            {
              *(double *)v833 = v137;
              v783 = (double *)(v833 + 8);
              goto LABEL_1447;
            }
            v784 = (double *)*v883;
            v834 = (v833 - *v883) >> 3;
            v835 = v834 + 1;
            if ((unint64_t)(v834 + 1) >> 61)
LABEL_1504:
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v836 = v832 - (_QWORD)v784;
            if (v836 >> 2 > v835)
              v835 = v836 >> 2;
            if ((unint64_t)v836 >= 0x7FFFFFFFFFFFFFF8)
              v788 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v788 = v835;
            if (v788)
            {
              v789 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v788);
              v784 = *(double **)(a3 + 296);
              v833 = *(char **)(a3 + 304);
            }
            else
            {
              v789 = 0;
            }
            v790 = (double *)&v789[8 * v834];
            *v790 = v137;
            v791 = v790 + 1;
            while (v833 != (char *)v784)
            {
              v837 = *((_QWORD *)v833 - 1);
              v833 -= 8;
              *((_QWORD *)v790-- - 1) = v837;
            }
LABEL_1460:
            *(_QWORD *)(a3 + 296) = v790;
            *(_QWORD *)(a3 + 304) = v791;
            *(_QWORD *)(a3 + 312) = &v789[8 * v788];
            if (v784)
              operator delete(v784);
            goto LABEL_1462;
          }
          if ((v134 & 1) == 0)
          {
LABEL_1044:
            while (v122 != v124)
            {
              if (*v122 >= v126)
                goto LABEL_1172;
              ++v128;
              ++v129;
              ++v122;
            }
            v122 = v124;
LABEL_1172:
            v676 = 0;
            v677 = v122 - 3;
            v678 = v129 - 3;
            v679 = v128 - 3;
            while (1)
            {
              if (v122 == *(double **)(v14 + v16))
              {
                v677 = *(double **)(v14 + v16);
                goto LABEL_1211;
              }
              if (v122 != v124 && *v122 <= v127)
                break;
              --v128;
              --v129;
              --v122;
              if (--v676 == -3)
              {
                v680 = 3;
                goto LABEL_1213;
              }
            }
            v677 = v122;
LABEL_1211:
            if (v676)
            {
              v680 = -v676;
              v679 = v128;
              v678 = v129;
LABEL_1213:
              v702 = *(double **)(a3 + 296);
              v703 = *(double **)(a3 + 304);
              if (v703 != v702)
              {
                v704 = *v677;
                v705 = v703 - 1;
                do
                {
                  if (*v705 < v704)
                    break;
                  *(_QWORD *)(a3 + 328) -= 8;
                  *(_QWORD *)(a3 + 352) -= 8;
                  *(_QWORD *)(a3 + 304) = v705;
                  v125 = v705-- == v702;
                }
                while (!v125);
              }
              if (v680 && v677 != v124)
              {
                v706 = 0;
                v707 = *(double **)(a3 + 304);
                while (1)
                {
                  v708 = *(double **)(a3 + 328);
                  if (v707 == *(double **)(a3 + 296))
                  {
                    if ((unint64_t)v708 >= *v888)
                    {
                      v712 = *v874;
                      v713 = v708 - *v874;
                      v714 = v713 + 1;
                      if ((unint64_t)(v713 + 1) >> 61)
                        goto LABEL_1507;
                      v715 = *v888 - (_QWORD)v712;
                      if (v715 >> 2 > v714)
                        v714 = v715 >> 2;
                      if ((unint64_t)v715 >= 0x7FFFFFFFFFFFFFF8)
                        v716 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v716 = v714;
                      if (v716)
                      {
                        v717 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v716);
                        v712 = *(double **)(a3 + 320);
                        v708 = *(double **)(a3 + 328);
                      }
                      else
                      {
                        v717 = 0;
                      }
                      v724 = &v717[8 * v713];
                      *(double *)v724 = *v679;
                      v711 = v724 + 8;
                      while (v708 != v712)
                      {
                        v725 = *((_QWORD *)v708-- - 1);
                        *((_QWORD *)v724 - 1) = v725;
                        v724 -= 8;
                      }
                      *(_QWORD *)(a3 + 320) = v724;
                      *(_QWORD *)(a3 + 328) = v711;
                      *(_QWORD *)(a3 + 336) = &v717[8 * v716];
                      if (v712)
                        operator delete(v712);
                      v124 = v884;
                    }
                    else
                    {
                      *v708 = *v679;
                      v711 = v708 + 1;
                    }
                    *(_QWORD *)(a3 + 328) = v711;
                    v727 = *(char **)(a3 + 352);
                    v726 = *(_QWORD *)(a3 + 360);
                    if ((unint64_t)v727 >= v726)
                    {
                      v729 = *v885;
                      v730 = (v727 - *v885) >> 3;
                      v731 = v730 + 1;
                      if ((unint64_t)(v730 + 1) >> 61)
                        goto LABEL_1503;
                      v732 = v726 - (_QWORD)v729;
                      if (v732 >> 2 > v731)
                        v731 = v732 >> 2;
                      if ((unint64_t)v732 >= 0x7FFFFFFFFFFFFFF8)
                        v733 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v733 = v731;
                      if (v733)
                      {
                        v734 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v733);
                        v729 = *(char **)(a3 + 344);
                        v727 = *(char **)(a3 + 352);
                      }
                      else
                      {
                        v734 = 0;
                      }
                      v735 = &v734[8 * v730];
                      *(double *)v735 = *v678;
                      v728 = v735 + 8;
                      while (v727 != v729)
                      {
                        v736 = *((_QWORD *)v727 - 1);
                        v727 -= 8;
                        *((_QWORD *)v735 - 1) = v736;
                        v735 -= 8;
                      }
                      *(_QWORD *)(a3 + 344) = v735;
                      *(_QWORD *)(a3 + 352) = v728;
                      *(_QWORD *)(a3 + 360) = &v734[8 * v733];
                      if (v729)
                        operator delete(v729);
                      v124 = v884;
                    }
                    else
                    {
                      *(double *)v727 = *v678;
                      v728 = v727 + 8;
                    }
                    *(_QWORD *)(a3 + 352) = v728;
                    v738 = *(char **)(a3 + 304);
                    v737 = *(_QWORD *)(a3 + 312);
                    if ((unint64_t)v738 >= v737)
                    {
                      v739 = *v883;
                      v740 = (v738 - *v883) >> 3;
                      v741 = v740 + 1;
                      if ((unint64_t)(v740 + 1) >> 61)
                        goto LABEL_1504;
                      v742 = v737 - (_QWORD)v739;
                      if (v742 >> 2 > v741)
                        v741 = v742 >> 2;
                      if ((unint64_t)v742 >= 0x7FFFFFFFFFFFFFF8)
                        v743 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v743 = v741;
                      if (v743)
                      {
                        v744 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v743);
                        v739 = *(char **)(a3 + 296);
                        v738 = *(char **)(a3 + 304);
                      }
                      else
                      {
                        v744 = 0;
                      }
                      v745 = &v744[8 * v740];
                      *(double *)v745 = *v677;
                      v707 = (double *)(v745 + 8);
                      while (v738 != v739)
                      {
                        v746 = *((_QWORD *)v738 - 1);
                        v738 -= 8;
                        *((_QWORD *)v745 - 1) = v746;
                        v745 -= 8;
                      }
LABEL_1320:
                      *(_QWORD *)(a3 + 296) = v745;
                      *(_QWORD *)(a3 + 304) = v707;
                      *(_QWORD *)(a3 + 312) = &v744[8 * v743];
                      if (v739)
                        operator delete(v739);
                      v124 = v884;
                      goto LABEL_1323;
                    }
                  }
                  else
                  {
                    v709 = *v679;
                    if (vabdd_f64(*(v708 - 1), *v679) < 0.0000001
                      && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v678) < 0.0000001
                      || *(v707 - 1) >= *v677)
                    {
                      goto LABEL_1324;
                    }
                    if ((unint64_t)v708 >= *v888)
                    {
                      v718 = *v874;
                      v719 = v708 - *v874;
                      v720 = v719 + 1;
                      if ((unint64_t)(v719 + 1) >> 61)
LABEL_1507:
                        std::vector<double>::__throw_length_error[abi:ne180100]();
                      v721 = *v888 - (_QWORD)v718;
                      if (v721 >> 2 > v720)
                        v720 = v721 >> 2;
                      if ((unint64_t)v721 >= 0x7FFFFFFFFFFFFFF8)
                        v722 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v722 = v720;
                      if (v722)
                      {
                        v723 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v722);
                        v718 = *(double **)(a3 + 320);
                        v708 = *(double **)(a3 + 328);
                        v709 = *v679;
                      }
                      else
                      {
                        v723 = 0;
                      }
                      v747 = (double *)&v723[8 * v719];
                      *v747 = v709;
                      v710 = v747 + 1;
                      while (v708 != v718)
                      {
                        v748 = *((_QWORD *)v708-- - 1);
                        *((_QWORD *)v747-- - 1) = v748;
                      }
                      *(_QWORD *)(a3 + 320) = v747;
                      *(_QWORD *)(a3 + 328) = v710;
                      *(_QWORD *)(a3 + 336) = &v723[8 * v722];
                      if (v718)
                        operator delete(v718);
                      v124 = v884;
                    }
                    else
                    {
                      *v708 = v709;
                      v710 = v708 + 1;
                    }
                    *(_QWORD *)(a3 + 328) = v710;
                    v750 = *(char **)(a3 + 352);
                    v749 = *(_QWORD *)(a3 + 360);
                    if ((unint64_t)v750 >= v749)
                    {
                      v752 = *v885;
                      v753 = (v750 - *v885) >> 3;
                      v754 = v753 + 1;
                      if ((unint64_t)(v753 + 1) >> 61)
                        goto LABEL_1503;
                      v755 = v749 - (_QWORD)v752;
                      if (v755 >> 2 > v754)
                        v754 = v755 >> 2;
                      if ((unint64_t)v755 >= 0x7FFFFFFFFFFFFFF8)
                        v756 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v756 = v754;
                      if (v756)
                      {
                        v757 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v756);
                        v752 = *(char **)(a3 + 344);
                        v750 = *(char **)(a3 + 352);
                      }
                      else
                      {
                        v757 = 0;
                      }
                      v758 = &v757[8 * v753];
                      *(double *)v758 = *v678;
                      v751 = v758 + 8;
                      while (v750 != v752)
                      {
                        v759 = *((_QWORD *)v750 - 1);
                        v750 -= 8;
                        *((_QWORD *)v758 - 1) = v759;
                        v758 -= 8;
                      }
                      *(_QWORD *)(a3 + 344) = v758;
                      *(_QWORD *)(a3 + 352) = v751;
                      *(_QWORD *)(a3 + 360) = &v757[8 * v756];
                      if (v752)
                        operator delete(v752);
                      v124 = v884;
                    }
                    else
                    {
                      *(double *)v750 = *v678;
                      v751 = v750 + 8;
                    }
                    *(_QWORD *)(a3 + 352) = v751;
                    v738 = *(char **)(a3 + 304);
                    v760 = *(_QWORD *)(a3 + 312);
                    if ((unint64_t)v738 >= v760)
                    {
                      v739 = *v883;
                      v761 = (v738 - *v883) >> 3;
                      v762 = v761 + 1;
                      if ((unint64_t)(v761 + 1) >> 61)
                        goto LABEL_1504;
                      v763 = v760 - (_QWORD)v739;
                      if (v763 >> 2 > v762)
                        v762 = v763 >> 2;
                      if ((unint64_t)v763 >= 0x7FFFFFFFFFFFFFF8)
                        v743 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v743 = v762;
                      if (v743)
                      {
                        v744 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v743);
                        v739 = *(char **)(a3 + 296);
                        v738 = *(char **)(a3 + 304);
                      }
                      else
                      {
                        v744 = 0;
                      }
                      v745 = &v744[8 * v761];
                      *(double *)v745 = *v677;
                      v707 = (double *)(v745 + 8);
                      while (v738 != v739)
                      {
                        v764 = *((_QWORD *)v738 - 1);
                        v738 -= 8;
                        *((_QWORD *)v745 - 1) = v764;
                        v745 -= 8;
                      }
                      goto LABEL_1320;
                    }
                  }
                  *(double *)v738 = *v677;
                  v707 = (double *)(v738 + 8);
LABEL_1323:
                  *(_QWORD *)(a3 + 304) = v707;
LABEL_1324:
                  ++v677;
                  if (++v706 < v680)
                  {
                    ++v679;
                    ++v678;
                    if (v677 != v124)
                      continue;
                  }
                  break;
                }
              }
            }
            v122 = v677 + 1;
          }
          if (*(_DWORD *)(a3 + 168))
          {
            if (v122 != v124)
              goto LABEL_1463;
            v765 = *(_QWORD *)(a3 + 328);
            v673 = *(double **)(v873 + 216);
            if (v765 != *(_QWORD *)(a3 + 320)
              && vabdd_f64(*(double *)(v765 - 8), *v673) < 0.0000001
              && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), **(double **)(v873 + 240)) < 0.0000001)
            {
              goto LABEL_1463;
            }
            goto LABEL_1332;
          }
          goto LABEL_1334;
        }
        v128 = v153 + 1;
        v129 = v152 + 1;
        v122 = v151 + 1;
        v16 = v860;
        v14 = v861;
        v131 = v869;
        v132 = v879;
        v134 = v867;
LABEL_504:
        if (v122 == v124)
        {
          v122 = v124;
          goto LABEL_506;
        }
      }
      v198 = 0;
      v199 = *(double **)(a3 + 304);
      while (1)
      {
        v200 = *(double **)(a3 + 328);
        if (v199 == *(double **)(a3 + 296))
        {
          if ((unint64_t)v200 >= *v888)
          {
            v204 = *v874;
            v205 = v200 - *v874;
            v206 = v205 + 1;
            if ((unint64_t)(v205 + 1) >> 61)
              goto LABEL_1506;
            v207 = *v888 - (_QWORD)v204;
            if (v207 >> 2 > v206)
              v206 = v207 >> 2;
            if ((unint64_t)v207 >= 0x7FFFFFFFFFFFFFF8)
              v208 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v208 = v206;
            if (v208)
            {
              v209 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v208);
              v204 = *(double **)(a3 + 320);
              v200 = *(double **)(a3 + 328);
            }
            else
            {
              v209 = 0;
            }
            v216 = &v209[8 * v205];
            *(double *)v216 = *v153;
            v203 = v216 + 8;
            while (v200 != v204)
            {
              v217 = *((_QWORD *)v200-- - 1);
              *((_QWORD *)v216 - 1) = v217;
              v216 -= 8;
            }
            *(_QWORD *)(a3 + 320) = v216;
            *(_QWORD *)(a3 + 328) = v203;
            *(_QWORD *)(a3 + 336) = &v209[8 * v208];
            if (v204)
              operator delete(v204);
            v124 = v884;
          }
          else
          {
            *v200 = *v153;
            v203 = v200 + 1;
          }
          *(_QWORD *)(a3 + 328) = v203;
          v219 = *(char **)(a3 + 352);
          v218 = *(_QWORD *)(a3 + 360);
          if ((unint64_t)v219 >= v218)
          {
            v221 = *v885;
            v222 = (v219 - *v885) >> 3;
            v223 = v222 + 1;
            if ((unint64_t)(v222 + 1) >> 61)
              goto LABEL_1503;
            v224 = v218 - (_QWORD)v221;
            if (v224 >> 2 > v223)
              v223 = v224 >> 2;
            if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFF8)
              v225 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v225 = v223;
            if (v225)
            {
              v226 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v225);
              v221 = *(char **)(a3 + 344);
              v219 = *(char **)(a3 + 352);
            }
            else
            {
              v226 = 0;
            }
            v227 = &v226[8 * v222];
            *(double *)v227 = *v152;
            v220 = v227 + 8;
            while (v219 != v221)
            {
              v228 = *((_QWORD *)v219 - 1);
              v219 -= 8;
              *((_QWORD *)v227 - 1) = v228;
              v227 -= 8;
            }
            *(_QWORD *)(a3 + 344) = v227;
            *(_QWORD *)(a3 + 352) = v220;
            *(_QWORD *)(a3 + 360) = &v226[8 * v225];
            if (v221)
              operator delete(v221);
            v124 = v884;
          }
          else
          {
            *(double *)v219 = *v152;
            v220 = v219 + 8;
          }
          *(_QWORD *)(a3 + 352) = v220;
          v230 = *(char **)(a3 + 304);
          v229 = *(_QWORD *)(a3 + 312);
          if ((unint64_t)v230 >= v229)
          {
            v231 = *v883;
            v232 = (v230 - *v883) >> 3;
            v233 = v232 + 1;
            if ((unint64_t)(v232 + 1) >> 61)
              goto LABEL_1504;
            v234 = v229 - (_QWORD)v231;
            if (v234 >> 2 > v233)
              v233 = v234 >> 2;
            if ((unint64_t)v234 >= 0x7FFFFFFFFFFFFFF8)
              v235 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v235 = v233;
            if (v235)
            {
              v236 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v235);
              v231 = *(char **)(a3 + 296);
              v230 = *(char **)(a3 + 304);
            }
            else
            {
              v236 = 0;
            }
            v237 = &v236[8 * v232];
            *(double *)v237 = *v151;
            v199 = (double *)(v237 + 8);
            while (v230 != v231)
            {
              v238 = *((_QWORD *)v230 - 1);
              v230 -= 8;
              *((_QWORD *)v237 - 1) = v238;
              v237 -= 8;
            }
LABEL_407:
            *(_QWORD *)(a3 + 296) = v237;
            *(_QWORD *)(a3 + 304) = v199;
            *(_QWORD *)(a3 + 312) = &v236[8 * v235];
            if (v231)
              operator delete(v231);
            v124 = v884;
            goto LABEL_410;
          }
        }
        else
        {
          v201 = *v153;
          if (vabdd_f64(*(v200 - 1), *v153) < 0.0000001
            && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v152) < 0.0000001
            || *(v199 - 1) >= *v151)
          {
            goto LABEL_411;
          }
          if ((unint64_t)v200 >= *v888)
          {
            v210 = *v874;
            v211 = v200 - *v874;
            v212 = v211 + 1;
            if ((unint64_t)(v211 + 1) >> 61)
              goto LABEL_1506;
            v213 = *v888 - (_QWORD)v210;
            if (v213 >> 2 > v212)
              v212 = v213 >> 2;
            if ((unint64_t)v213 >= 0x7FFFFFFFFFFFFFF8)
              v214 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v214 = v212;
            if (v214)
            {
              v215 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v214);
              v210 = *(double **)(a3 + 320);
              v200 = *(double **)(a3 + 328);
              v201 = *v153;
            }
            else
            {
              v215 = 0;
            }
            v239 = (double *)&v215[8 * v211];
            *v239 = v201;
            v202 = v239 + 1;
            while (v200 != v210)
            {
              v240 = *((_QWORD *)v200-- - 1);
              *((_QWORD *)v239-- - 1) = v240;
            }
            *(_QWORD *)(a3 + 320) = v239;
            *(_QWORD *)(a3 + 328) = v202;
            *(_QWORD *)(a3 + 336) = &v215[8 * v214];
            if (v210)
              operator delete(v210);
            v124 = v884;
          }
          else
          {
            *v200 = v201;
            v202 = v200 + 1;
          }
          *(_QWORD *)(a3 + 328) = v202;
          v242 = *(char **)(a3 + 352);
          v241 = *(_QWORD *)(a3 + 360);
          if ((unint64_t)v242 >= v241)
          {
            v244 = *v885;
            v245 = (v242 - *v885) >> 3;
            v246 = v245 + 1;
            if ((unint64_t)(v245 + 1) >> 61)
              goto LABEL_1503;
            v247 = v241 - (_QWORD)v244;
            if (v247 >> 2 > v246)
              v246 = v247 >> 2;
            if ((unint64_t)v247 >= 0x7FFFFFFFFFFFFFF8)
              v248 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v248 = v246;
            if (v248)
            {
              v249 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v248);
              v244 = *(char **)(a3 + 344);
              v242 = *(char **)(a3 + 352);
            }
            else
            {
              v249 = 0;
            }
            v250 = &v249[8 * v245];
            *(double *)v250 = *v152;
            v243 = v250 + 8;
            while (v242 != v244)
            {
              v251 = *((_QWORD *)v242 - 1);
              v242 -= 8;
              *((_QWORD *)v250 - 1) = v251;
              v250 -= 8;
            }
            *(_QWORD *)(a3 + 344) = v250;
            *(_QWORD *)(a3 + 352) = v243;
            *(_QWORD *)(a3 + 360) = &v249[8 * v248];
            if (v244)
              operator delete(v244);
            v124 = v884;
          }
          else
          {
            *(double *)v242 = *v152;
            v243 = v242 + 8;
          }
          *(_QWORD *)(a3 + 352) = v243;
          v230 = *(char **)(a3 + 304);
          v252 = *(_QWORD *)(a3 + 312);
          if ((unint64_t)v230 >= v252)
          {
            v231 = *v883;
            v253 = (v230 - *v883) >> 3;
            v254 = v253 + 1;
            if ((unint64_t)(v253 + 1) >> 61)
              goto LABEL_1504;
            v255 = v252 - (_QWORD)v231;
            if (v255 >> 2 > v254)
              v254 = v255 >> 2;
            if ((unint64_t)v255 >= 0x7FFFFFFFFFFFFFF8)
              v235 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v235 = v254;
            if (v235)
            {
              v236 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v235);
              v231 = *(char **)(a3 + 296);
              v230 = *(char **)(a3 + 304);
            }
            else
            {
              v236 = 0;
            }
            v237 = &v236[8 * v253];
            *(double *)v237 = *v151;
            v199 = (double *)(v237 + 8);
            while (v230 != v231)
            {
              v256 = *((_QWORD *)v230 - 1);
              v230 -= 8;
              *((_QWORD *)v237 - 1) = v256;
              v237 -= 8;
            }
            goto LABEL_407;
          }
        }
        *(double *)v230 = *v151;
        v199 = (double *)(v230 + 8);
LABEL_410:
        *(_QWORD *)(a3 + 304) = v199;
LABEL_411:
        ++v153;
        ++v152;
        ++v151;
        if (++v198 >= v149 || v151 == v124)
          goto LABEL_413;
      }
    }
    if (v133 != v132)
    {
      while (*v133 < v127)
      {
        ++v133;
        ++v130;
        ++v131;
        if (v133 == v132)
        {
          v133 = *(double **)(v873 + 200);
          break;
        }
      }
    }
    v311 = ceil(v127);
    if (v124 != v122)
    {
      v312 = 0;
      while (*v122 <= v311)
      {
        if (*v122 >= v127)
        {
          if (v880)
          {
            if ((v312 & 1) == 0)
            {
              v313 = *(char **)(a3 + 320);
              v314 = *(char **)(a3 + 328);
              v315 = v314 - v313;
              if (v314 == v313
                || vabdd_f64(*((double *)v314 - 1), *v128) >= 0.0000001
                || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v129) >= 0.0000001)
              {
                v316 = v131;
                if ((unint64_t)v314 >= *v888)
                {
                  v358 = v315 >> 3;
                  v359 = (v315 >> 3) + 1;
                  if (v359 >> 61)
                    goto LABEL_1505;
                  v360 = *v888 - (_QWORD)v313;
                  if (v360 >> 2 > v359)
                    v359 = v360 >> 2;
                  if ((unint64_t)v360 >= 0x7FFFFFFFFFFFFFF8)
                    v361 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v361 = v359;
                  if (v361)
                  {
                    v362 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v361);
                    v313 = *(char **)(a3 + 320);
                    v314 = *(char **)(a3 + 328);
                  }
                  else
                  {
                    v362 = 0;
                  }
                  v368 = &v362[8 * v358];
                  *(double *)v368 = *v128;
                  v317 = v368 + 8;
                  while (v314 != v313)
                  {
                    v369 = *((_QWORD *)v314 - 1);
                    v314 -= 8;
                    *((_QWORD *)v368 - 1) = v369;
                    v368 -= 8;
                  }
                  *(_QWORD *)(a3 + 320) = v368;
                  *(_QWORD *)(a3 + 328) = v317;
                  *(_QWORD *)(a3 + 336) = &v362[8 * v361];
                  if (v313)
                    operator delete(v313);
                }
                else
                {
                  *(double *)v314 = *v128;
                  v317 = v314 + 8;
                }
                *(_QWORD *)(a3 + 328) = v317;
                v371 = *(char **)(a3 + 352);
                v370 = *(_QWORD *)(a3 + 360);
                if ((unint64_t)v371 >= v370)
                {
                  v373 = *v885;
                  v374 = (v371 - *v885) >> 3;
                  v375 = v374 + 1;
                  if ((unint64_t)(v374 + 1) >> 61)
                    goto LABEL_1503;
                  v376 = v370 - (_QWORD)v373;
                  if (v376 >> 2 > v375)
                    v375 = v376 >> 2;
                  if ((unint64_t)v376 >= 0x7FFFFFFFFFFFFFF8)
                    v377 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v377 = v375;
                  if (v377)
                  {
                    v378 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v377);
                    v373 = *(char **)(a3 + 344);
                    v371 = *(char **)(a3 + 352);
                  }
                  else
                  {
                    v378 = 0;
                  }
                  v379 = &v378[8 * v374];
                  *(double *)v379 = *v129;
                  v372 = v379 + 8;
                  while (v371 != v373)
                  {
                    v380 = *((_QWORD *)v371 - 1);
                    v371 -= 8;
                    *((_QWORD *)v379 - 1) = v380;
                    v379 -= 8;
                  }
                  *(_QWORD *)(a3 + 344) = v379;
                  *(_QWORD *)(a3 + 352) = v372;
                  *(_QWORD *)(a3 + 360) = &v378[8 * v377];
                  if (v373)
                    operator delete(v373);
                }
                else
                {
                  *(double *)v371 = *v129;
                  v372 = v371 + 8;
                }
                *(_QWORD *)(a3 + 352) = v372;
                v382 = *(char **)(a3 + 304);
                v381 = *(_QWORD *)(a3 + 312);
                if ((unint64_t)v382 >= v381)
                {
                  v384 = *v883;
                  v385 = (v382 - *v883) >> 3;
                  v386 = v385 + 1;
                  if ((unint64_t)(v385 + 1) >> 61)
                    goto LABEL_1504;
                  v387 = v381 - (_QWORD)v384;
                  if (v387 >> 2 > v386)
                    v386 = v387 >> 2;
                  if ((unint64_t)v387 >= 0x7FFFFFFFFFFFFFF8)
                    v388 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v388 = v386;
                  if (v388)
                  {
                    v389 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v388);
                    v384 = *(char **)(a3 + 296);
                    v382 = *(char **)(a3 + 304);
                  }
                  else
                  {
                    v389 = 0;
                  }
                  v390 = &v389[8 * v385];
                  *(double *)v390 = *v122;
                  v383 = v390 + 8;
                  while (v382 != v384)
                  {
                    v391 = *((_QWORD *)v382 - 1);
                    v382 -= 8;
                    *((_QWORD *)v390 - 1) = v391;
                    v390 -= 8;
                  }
                  *(_QWORD *)(a3 + 296) = v390;
                  *(_QWORD *)(a3 + 304) = v383;
                  *(_QWORD *)(a3 + 312) = &v389[8 * v388];
                  if (v384)
                    operator delete(v384);
                }
                else
                {
                  *(double *)v382 = *v122;
                  v383 = v382 + 8;
                }
                *(_QWORD *)(a3 + 304) = v383;
                v131 = v316;
                v132 = v879;
              }
            }
            ++v128;
            ++v129;
            ++v122;
            v312 = 1;
            v124 = v884;
            goto LABEL_703;
          }
          if (v133 != v132 && ((*v133 <= v311) & v312) == 1)
          {
            v318 = *(char **)(a3 + 320);
            v319 = *(char **)(a3 + 328);
            v320 = v319 - v318;
            if (v319 == v318
              || vabdd_f64(*((double *)v319 - 1), *v130) >= 0.0000001
              || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v131) >= 0.0000001)
            {
              v321 = v131;
              if ((unint64_t)v319 >= *v888)
              {
                v363 = v320 >> 3;
                v364 = (v320 >> 3) + 1;
                if (v364 >> 61)
                  goto LABEL_1505;
                v365 = *v888 - (_QWORD)v318;
                if (v365 >> 2 > v364)
                  v364 = v365 >> 2;
                if ((unint64_t)v365 >= 0x7FFFFFFFFFFFFFF8)
                  v366 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v366 = v364;
                if (v366)
                {
                  v367 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v366);
                  v318 = *(char **)(a3 + 320);
                  v319 = *(char **)(a3 + 328);
                }
                else
                {
                  v367 = 0;
                }
                v392 = &v367[8 * v363];
                *(double *)v392 = *v130;
                v322 = v392 + 8;
                while (v319 != v318)
                {
                  v393 = *((_QWORD *)v319 - 1);
                  v319 -= 8;
                  *((_QWORD *)v392 - 1) = v393;
                  v392 -= 8;
                }
                *(_QWORD *)(a3 + 320) = v392;
                *(_QWORD *)(a3 + 328) = v322;
                *(_QWORD *)(a3 + 336) = &v367[8 * v366];
                if (v318)
                  operator delete(v318);
              }
              else
              {
                *(double *)v319 = *v130;
                v322 = v319 + 8;
              }
              *(_QWORD *)(a3 + 328) = v322;
              v395 = *(char **)(a3 + 352);
              v394 = *(_QWORD *)(a3 + 360);
              if ((unint64_t)v395 >= v394)
              {
                v397 = *v885;
                v398 = (v395 - *v885) >> 3;
                v399 = v398 + 1;
                if ((unint64_t)(v398 + 1) >> 61)
                  goto LABEL_1503;
                v400 = v394 - (_QWORD)v397;
                if (v400 >> 2 > v399)
                  v399 = v400 >> 2;
                if ((unint64_t)v400 >= 0x7FFFFFFFFFFFFFF8)
                  v401 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v401 = v399;
                if (v401)
                {
                  v402 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v401);
                  v397 = *(char **)(a3 + 344);
                  v395 = *(char **)(a3 + 352);
                }
                else
                {
                  v402 = 0;
                }
                v403 = &v402[8 * v398];
                *(double *)v403 = *v321;
                v396 = v403 + 8;
                while (v395 != v397)
                {
                  v404 = *((_QWORD *)v395 - 1);
                  v395 -= 8;
                  *((_QWORD *)v403 - 1) = v404;
                  v403 -= 8;
                }
                *(_QWORD *)(a3 + 344) = v403;
                *(_QWORD *)(a3 + 352) = v396;
                *(_QWORD *)(a3 + 360) = &v402[8 * v401];
                if (v397)
                  operator delete(v397);
              }
              else
              {
                *(double *)v395 = *v321;
                v396 = v395 + 8;
              }
              *(_QWORD *)(a3 + 352) = v396;
              v406 = *(char **)(a3 + 304);
              v405 = *(_QWORD *)(a3 + 312);
              if ((unint64_t)v406 >= v405)
              {
                v408 = *v883;
                v409 = (v406 - *v883) >> 3;
                v410 = v409 + 1;
                if ((unint64_t)(v409 + 1) >> 61)
                  goto LABEL_1504;
                v411 = v405 - (_QWORD)v408;
                if (v411 >> 2 > v410)
                  v410 = v411 >> 2;
                if ((unint64_t)v411 >= 0x7FFFFFFFFFFFFFF8)
                  v412 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v412 = v410;
                if (v412)
                {
                  v413 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v412);
                  v408 = *(char **)(a3 + 296);
                  v406 = *(char **)(a3 + 304);
                }
                else
                {
                  v413 = 0;
                }
                v414 = &v413[8 * v409];
                *(double *)v414 = *v133;
                v407 = v414 + 8;
                while (v406 != v408)
                {
                  v415 = *((_QWORD *)v406 - 1);
                  v406 -= 8;
                  *((_QWORD *)v414 - 1) = v415;
                  v414 -= 8;
                }
                *(_QWORD *)(a3 + 296) = v414;
                *(_QWORD *)(a3 + 304) = v407;
                *(_QWORD *)(a3 + 312) = &v413[8 * v412];
                if (v408)
                  operator delete(v408);
              }
              else
              {
                *(double *)v406 = *v133;
                v407 = v406 + 8;
              }
              *(_QWORD *)(a3 + 304) = v407;
              v131 = v321;
              v132 = v879;
            }
            v124 = v884;
            if (v122 == v884)
            {
LABEL_700:
              v122 = v884;
            }
            else
            {
              while (*v122 < *v133)
              {
                ++v128;
                ++v129;
                if (++v122 == v884)
                  goto LABEL_700;
              }
            }
            ++v133;
            ++v130;
            ++v131;
            goto LABEL_702;
          }
          if ((v312 & 1) != 0)
          {
            ++v128;
            ++v129;
            ++v122;
LABEL_702:
            v312 = 1;
            goto LABEL_703;
          }
          if (v122 == v124)
            goto LABEL_704;
          v871 = v131;
          v323 = 0;
          v324 = 0;
          do
          {
            v325 = *(char **)(a3 + 320);
            v326 = *(char **)(a3 + 328);
            v327 = v326 - v325;
            if (v326 == v325
              || vabdd_f64(*((double *)v326 - 1), *v128) >= 0.0000001
              || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v129) >= 0.0000001)
            {
              if ((unint64_t)v326 >= *v888)
              {
                v329 = v327 >> 3;
                v330 = (v327 >> 3) + 1;
                if (v330 >> 61)
                  goto LABEL_1505;
                v331 = *v888 - (_QWORD)v325;
                if (v331 >> 2 > v330)
                  v330 = v331 >> 2;
                if ((unint64_t)v331 >= 0x7FFFFFFFFFFFFFF8)
                  v332 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v332 = v330;
                if (v332)
                {
                  v333 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v332);
                  v325 = *(char **)(a3 + 320);
                  v326 = *(char **)(a3 + 328);
                }
                else
                {
                  v333 = 0;
                }
                v334 = &v333[8 * v329];
                *(double *)v334 = *v128;
                v328 = v334 + 8;
                while (v326 != v325)
                {
                  v335 = *((_QWORD *)v326 - 1);
                  v326 -= 8;
                  *((_QWORD *)v334 - 1) = v335;
                  v334 -= 8;
                }
                *(_QWORD *)(a3 + 320) = v334;
                *(_QWORD *)(a3 + 328) = v328;
                *(_QWORD *)(a3 + 336) = &v333[8 * v332];
                if (v325)
                  operator delete(v325);
              }
              else
              {
                *(double *)v326 = *v128;
                v328 = v326 + 8;
              }
              *(_QWORD *)(a3 + 328) = v328;
              v337 = *(char **)(a3 + 352);
              v336 = *(_QWORD *)(a3 + 360);
              if ((unint64_t)v337 >= v336)
              {
                v339 = *v885;
                v340 = (v337 - *v885) >> 3;
                v341 = v340 + 1;
                if ((unint64_t)(v340 + 1) >> 61)
                  goto LABEL_1503;
                v342 = v336 - (_QWORD)v339;
                if (v342 >> 2 > v341)
                  v341 = v342 >> 2;
                if ((unint64_t)v342 >= 0x7FFFFFFFFFFFFFF8)
                  v343 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v343 = v341;
                if (v343)
                {
                  v344 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v343);
                  v339 = *(char **)(a3 + 344);
                  v337 = *(char **)(a3 + 352);
                }
                else
                {
                  v344 = 0;
                }
                v345 = &v344[8 * v340];
                *(double *)v345 = *v129;
                v338 = v345 + 8;
                while (v337 != v339)
                {
                  v346 = *((_QWORD *)v337 - 1);
                  v337 -= 8;
                  *((_QWORD *)v345 - 1) = v346;
                  v345 -= 8;
                }
                *(_QWORD *)(a3 + 344) = v345;
                *(_QWORD *)(a3 + 352) = v338;
                *(_QWORD *)(a3 + 360) = &v344[8 * v343];
                if (v339)
                  operator delete(v339);
              }
              else
              {
                *(double *)v337 = *v129;
                v338 = v337 + 8;
              }
              *(_QWORD *)(a3 + 352) = v338;
              v348 = *(char **)(a3 + 304);
              v347 = *(_QWORD *)(a3 + 312);
              if ((unint64_t)v348 >= v347)
              {
                v350 = *v883;
                v351 = (v348 - *v883) >> 3;
                v352 = v351 + 1;
                if ((unint64_t)(v351 + 1) >> 61)
                  goto LABEL_1504;
                v353 = v347 - (_QWORD)v350;
                if (v353 >> 2 > v352)
                  v352 = v353 >> 2;
                if ((unint64_t)v353 >= 0x7FFFFFFFFFFFFFF8)
                  v354 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v354 = v352;
                if (v354)
                {
                  v355 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v354);
                  v350 = *(char **)(a3 + 296);
                  v348 = *(char **)(a3 + 304);
                }
                else
                {
                  v355 = 0;
                }
                v356 = &v355[8 * v351];
                *(double *)v356 = *v122;
                v349 = v356 + 8;
                while (v348 != v350)
                {
                  v357 = *((_QWORD *)v348 - 1);
                  v348 -= 8;
                  *((_QWORD *)v356 - 1) = v357;
                  v356 -= 8;
                }
                *(_QWORD *)(a3 + 296) = v356;
                *(_QWORD *)(a3 + 304) = v349;
                *(_QWORD *)(a3 + 312) = &v355[8 * v354];
                if (v350)
                  operator delete(v350);
              }
              else
              {
                *(double *)v348 = *v122;
                v349 = v348 + 8;
              }
              *(_QWORD *)(a3 + 304) = v349;
              v324 = 1;
            }
            ++v128;
            ++v129;
            ++v122;
            v124 = v884;
            if (v323 > 1)
              break;
            ++v323;
          }
          while (v122 != v884);
          if ((v324 & 1) != 0)
          {
            v132 = v879;
            v131 = v871;
            if (v133 == v879)
            {
              v312 = 1;
LABEL_657:
              v133 = v879;
              goto LABEL_703;
            }
            while (*v133 <= *(double *)(*(_QWORD *)(a3 + 304) - 8))
            {
              ++v133;
              ++v130;
              ++v131;
              v312 = 1;
              if (v133 == v879)
                goto LABEL_657;
            }
            goto LABEL_702;
          }
          v312 = 0;
          v131 = v871;
          v132 = v879;
        }
        else
        {
          ++v128;
          ++v129;
          ++v122;
        }
LABEL_703:
        if (v122 == v124)
        {
LABEL_704:
          v122 = v124;
          break;
        }
      }
    }
    v416 = floor(v123);
    if (v133 == v132)
    {
LABEL_761:
      v133 = v132;
    }
    else
    {
      while (*v133 <= v416)
      {
        if (*v133 >= v311)
        {
          v417 = *(char **)(a3 + 320);
          v418 = *(char **)(a3 + 328);
          v419 = v418 - v417;
          if (v418 == v417
            || vabdd_f64(*((double *)v418 - 1), *v130) >= 0.0000001
            || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v131) >= 0.0000001)
          {
            v420 = v131;
            if ((unint64_t)v418 >= *v888)
            {
              v422 = v419 >> 3;
              v423 = (v419 >> 3) + 1;
              if (v423 >> 61)
                goto LABEL_1505;
              v424 = *v888 - (_QWORD)v417;
              if (v424 >> 2 > v423)
                v423 = v424 >> 2;
              if ((unint64_t)v424 >= 0x7FFFFFFFFFFFFFF8)
                v425 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v425 = v423;
              if (v425)
              {
                v426 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v425);
                v417 = *(char **)(a3 + 320);
                v418 = *(char **)(a3 + 328);
              }
              else
              {
                v426 = 0;
              }
              v427 = &v426[8 * v422];
              *(double *)v427 = *v130;
              v421 = v427 + 8;
              while (v418 != v417)
              {
                v428 = *((_QWORD *)v418 - 1);
                v418 -= 8;
                *((_QWORD *)v427 - 1) = v428;
                v427 -= 8;
              }
              *(_QWORD *)(a3 + 320) = v427;
              *(_QWORD *)(a3 + 328) = v421;
              *(_QWORD *)(a3 + 336) = &v426[8 * v425];
              if (v417)
                operator delete(v417);
            }
            else
            {
              *(double *)v418 = *v130;
              v421 = v418 + 8;
            }
            *(_QWORD *)(a3 + 328) = v421;
            v430 = *(char **)(a3 + 352);
            v429 = *(_QWORD *)(a3 + 360);
            if ((unint64_t)v430 >= v429)
            {
              v432 = *v885;
              v433 = (v430 - *v885) >> 3;
              v434 = v433 + 1;
              if ((unint64_t)(v433 + 1) >> 61)
                goto LABEL_1503;
              v435 = v429 - (_QWORD)v432;
              if (v435 >> 2 > v434)
                v434 = v435 >> 2;
              if ((unint64_t)v435 >= 0x7FFFFFFFFFFFFFF8)
                v436 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v436 = v434;
              if (v436)
              {
                v437 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v436);
                v432 = *(char **)(a3 + 344);
                v430 = *(char **)(a3 + 352);
              }
              else
              {
                v437 = 0;
              }
              v438 = &v437[8 * v433];
              *(double *)v438 = *v420;
              v431 = v438 + 8;
              while (v430 != v432)
              {
                v439 = *((_QWORD *)v430 - 1);
                v430 -= 8;
                *((_QWORD *)v438 - 1) = v439;
                v438 -= 8;
              }
              *(_QWORD *)(a3 + 344) = v438;
              *(_QWORD *)(a3 + 352) = v431;
              *(_QWORD *)(a3 + 360) = &v437[8 * v436];
              if (v432)
                operator delete(v432);
            }
            else
            {
              *(double *)v430 = *v420;
              v431 = v430 + 8;
            }
            *(_QWORD *)(a3 + 352) = v431;
            v441 = *(char **)(a3 + 304);
            v440 = *(_QWORD *)(a3 + 312);
            if ((unint64_t)v441 >= v440)
            {
              v443 = *v883;
              v444 = (v441 - *v883) >> 3;
              v445 = v444 + 1;
              if ((unint64_t)(v444 + 1) >> 61)
                goto LABEL_1504;
              v446 = v440 - (_QWORD)v443;
              if (v446 >> 2 > v445)
                v445 = v446 >> 2;
              if ((unint64_t)v446 >= 0x7FFFFFFFFFFFFFF8)
                v447 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v447 = v445;
              if (v447)
              {
                v448 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v447);
                v443 = *(char **)(a3 + 296);
                v441 = *(char **)(a3 + 304);
              }
              else
              {
                v448 = 0;
              }
              v449 = &v448[8 * v444];
              *(double *)v449 = *v133;
              v442 = v449 + 8;
              while (v441 != v443)
              {
                v450 = *((_QWORD *)v441 - 1);
                v441 -= 8;
                *((_QWORD *)v449 - 1) = v450;
                v449 -= 8;
              }
              *(_QWORD *)(a3 + 296) = v449;
              *(_QWORD *)(a3 + 304) = v442;
              *(_QWORD *)(a3 + 312) = &v448[8 * v447];
              if (v443)
                operator delete(v443);
            }
            else
            {
              *(double *)v441 = *v133;
              v442 = v441 + 8;
            }
            *(_QWORD *)(a3 + 304) = v442;
            v131 = v420;
            v132 = v879;
          }
        }
        ++v130;
        ++v131;
        ++v133;
        v124 = v884;
        if (v133 == v132)
          goto LABEL_761;
      }
    }
    if (v122 == v124)
    {
      v122 = v124;
      if (v880)
        goto LABEL_1021;
      goto LABEL_1035;
    }
    v451 = 0;
    v868 = 0.0;
    v452 = 0.0;
    v453 = 0.0;
    while (1)
    {
      v454 = *v122;
      if (*v122 > v126)
        goto LABEL_1015;
      if (v454 <= v416)
      {
        ++v128;
        ++v129;
        ++v122;
        goto LABEL_1013;
      }
      if (v880)
      {
        v455 = *v128++;
        v868 = v455;
        v456 = *v129++;
        v452 = v456;
        ++v122;
        v451 = 1;
        v453 = v454;
        goto LABEL_1013;
      }
      if (v133 == v132)
        goto LABEL_783;
      if (*v133 < v126)
      {
        v457 = *(char **)(a3 + 320);
        v458 = *(char **)(a3 + 328);
        v459 = v458 - v457;
        if (v458 == v457
          || vabdd_f64(*((double *)v458 - 1), *v130) >= 0.0000001
          || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v131) >= 0.0000001)
        {
          v460 = v131;
          if ((unint64_t)v458 >= *v888)
          {
            v536 = v459 >> 3;
            v537 = (v459 >> 3) + 1;
            if (v537 >> 61)
              goto LABEL_1505;
            v538 = *v888 - (_QWORD)v457;
            if (v538 >> 2 > v537)
              v537 = v538 >> 2;
            if ((unint64_t)v538 >= 0x7FFFFFFFFFFFFFF8)
              v539 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v539 = v537;
            if (v539)
            {
              v540 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v539);
              v457 = *(char **)(a3 + 320);
              v458 = *(char **)(a3 + 328);
            }
            else
            {
              v540 = 0;
            }
            v546 = &v540[8 * v536];
            *(double *)v546 = *v130;
            v461 = v546 + 8;
            while (v458 != v457)
            {
              v547 = *((_QWORD *)v458 - 1);
              v458 -= 8;
              *((_QWORD *)v546 - 1) = v547;
              v546 -= 8;
            }
            *(_QWORD *)(a3 + 320) = v546;
            *(_QWORD *)(a3 + 328) = v461;
            *(_QWORD *)(a3 + 336) = &v540[8 * v539];
            if (v457)
              operator delete(v457);
          }
          else
          {
            *(double *)v458 = *v130;
            v461 = v458 + 8;
          }
          *(_QWORD *)(a3 + 328) = v461;
          v549 = *(char **)(a3 + 352);
          v548 = *(_QWORD *)(a3 + 360);
          if ((unint64_t)v549 >= v548)
          {
            v551 = *v885;
            v552 = (v549 - *v885) >> 3;
            v553 = v552 + 1;
            if ((unint64_t)(v552 + 1) >> 61)
              goto LABEL_1503;
            v554 = v548 - (_QWORD)v551;
            if (v554 >> 2 > v553)
              v553 = v554 >> 2;
            if ((unint64_t)v554 >= 0x7FFFFFFFFFFFFFF8)
              v555 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v555 = v553;
            if (v555)
            {
              v556 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v555);
              v551 = *(char **)(a3 + 344);
              v549 = *(char **)(a3 + 352);
            }
            else
            {
              v556 = 0;
            }
            v557 = &v556[8 * v552];
            *(double *)v557 = *v460;
            v550 = v557 + 8;
            while (v549 != v551)
            {
              v558 = *((_QWORD *)v549 - 1);
              v549 -= 8;
              *((_QWORD *)v557 - 1) = v558;
              v557 -= 8;
            }
            *(_QWORD *)(a3 + 344) = v557;
            *(_QWORD *)(a3 + 352) = v550;
            *(_QWORD *)(a3 + 360) = &v556[8 * v555];
            if (v551)
              operator delete(v551);
          }
          else
          {
            *(double *)v549 = *v460;
            v550 = v549 + 8;
          }
          *(_QWORD *)(a3 + 352) = v550;
          v560 = *(char **)(a3 + 304);
          v559 = *(_QWORD *)(a3 + 312);
          if ((unint64_t)v560 >= v559)
          {
            v562 = *v883;
            v563 = (v560 - *v883) >> 3;
            v564 = v563 + 1;
            if ((unint64_t)(v563 + 1) >> 61)
              goto LABEL_1504;
            v565 = v559 - (_QWORD)v562;
            if (v565 >> 2 > v564)
              v564 = v565 >> 2;
            if ((unint64_t)v565 >= 0x7FFFFFFFFFFFFFF8)
              v566 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v566 = v564;
            if (v566)
            {
              v567 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v566);
              v562 = *(char **)(a3 + 296);
              v560 = *(char **)(a3 + 304);
            }
            else
            {
              v567 = 0;
            }
            v568 = &v567[8 * v563];
            *(double *)v568 = *v133;
            v561 = v568 + 8;
            while (v560 != v562)
            {
              v569 = *((_QWORD *)v560 - 1);
              v560 -= 8;
              *((_QWORD *)v568 - 1) = v569;
              v568 -= 8;
            }
            *(_QWORD *)(a3 + 296) = v568;
            *(_QWORD *)(a3 + 304) = v561;
            *(_QWORD *)(a3 + 312) = &v567[8 * v566];
            if (v562)
              operator delete(v562);
          }
          else
          {
            *(double *)v560 = *v133;
            v561 = v560 + 8;
          }
          *(_QWORD *)(a3 + 304) = v561;
          v451 = 1;
          v131 = v460;
          v132 = v879;
        }
        v124 = v884;
        if (v122 == v884)
        {
LABEL_971:
          v122 = v884;
        }
        else
        {
          while (*v122 < *v133)
          {
            ++v128;
            ++v129;
            if (++v122 == v884)
              goto LABEL_971;
          }
        }
        ++v133;
        ++v130;
        ++v131;
        goto LABEL_1013;
      }
      if (vabdd_f64(*v133, v126) >= 0.0000001)
      {
        v462 = *(char **)(a3 + 320);
        v463 = *(char **)(a3 + 328);
        v464 = v463 - v462;
        if (v463 == v462
          || vabdd_f64(*((double *)v463 - 1), *v128) >= 0.0000001
          || vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v129) >= 0.0000001)
        {
          v465 = v131;
          if ((unint64_t)v463 >= *v888)
          {
            v541 = v464 >> 3;
            v542 = (v464 >> 3) + 1;
            if (v542 >> 61)
              goto LABEL_1505;
            v543 = *v888 - (_QWORD)v462;
            if (v543 >> 2 > v542)
              v542 = v543 >> 2;
            if ((unint64_t)v543 >= 0x7FFFFFFFFFFFFFF8)
              v544 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v544 = v542;
            if (v544)
            {
              v545 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v544);
              v462 = *(char **)(a3 + 320);
              v463 = *(char **)(a3 + 328);
            }
            else
            {
              v545 = 0;
            }
            v570 = &v545[8 * v541];
            *(double *)v570 = *v128;
            v466 = v570 + 8;
            while (v463 != v462)
            {
              v571 = *((_QWORD *)v463 - 1);
              v463 -= 8;
              *((_QWORD *)v570 - 1) = v571;
              v570 -= 8;
            }
            *(_QWORD *)(a3 + 320) = v570;
            *(_QWORD *)(a3 + 328) = v466;
            *(_QWORD *)(a3 + 336) = &v545[8 * v544];
            if (v462)
              operator delete(v462);
          }
          else
          {
            *(double *)v463 = *v128;
            v466 = v463 + 8;
          }
          *(_QWORD *)(a3 + 328) = v466;
          v573 = *(char **)(a3 + 352);
          v572 = *(_QWORD *)(a3 + 360);
          if ((unint64_t)v573 >= v572)
          {
            v575 = *v885;
            v576 = (v573 - *v885) >> 3;
            v577 = v576 + 1;
            if ((unint64_t)(v576 + 1) >> 61)
              goto LABEL_1503;
            v578 = v572 - (_QWORD)v575;
            if (v578 >> 2 > v577)
              v577 = v578 >> 2;
            if ((unint64_t)v578 >= 0x7FFFFFFFFFFFFFF8)
              v579 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v579 = v577;
            if (v579)
            {
              v580 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v579);
              v575 = *(char **)(a3 + 344);
              v573 = *(char **)(a3 + 352);
            }
            else
            {
              v580 = 0;
            }
            v581 = &v580[8 * v576];
            *(double *)v581 = *v129;
            v574 = v581 + 8;
            while (v573 != v575)
            {
              v582 = *((_QWORD *)v573 - 1);
              v573 -= 8;
              *((_QWORD *)v581 - 1) = v582;
              v581 -= 8;
            }
            *(_QWORD *)(a3 + 344) = v581;
            *(_QWORD *)(a3 + 352) = v574;
            *(_QWORD *)(a3 + 360) = &v580[8 * v579];
            if (v575)
              operator delete(v575);
          }
          else
          {
            *(double *)v573 = *v129;
            v574 = v573 + 8;
          }
          *(_QWORD *)(a3 + 352) = v574;
          v584 = *(char **)(a3 + 304);
          v583 = *(_QWORD *)(a3 + 312);
          if ((unint64_t)v584 >= v583)
          {
            v586 = *v883;
            v587 = (v584 - *v883) >> 3;
            v588 = v587 + 1;
            if ((unint64_t)(v587 + 1) >> 61)
              goto LABEL_1504;
            v589 = v583 - (_QWORD)v586;
            if (v589 >> 2 > v588)
              v588 = v589 >> 2;
            if ((unint64_t)v589 >= 0x7FFFFFFFFFFFFFF8)
              v590 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v590 = v588;
            if (v590)
            {
              v591 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v590);
              v586 = *(char **)(a3 + 296);
              v584 = *(char **)(a3 + 304);
            }
            else
            {
              v591 = 0;
            }
            v592 = &v591[8 * v587];
            *(double *)v592 = *v122;
            v585 = v592 + 8;
            while (v584 != v586)
            {
              v593 = *((_QWORD *)v584 - 1);
              v584 -= 8;
              *((_QWORD *)v592 - 1) = v593;
              v592 -= 8;
            }
            *(_QWORD *)(a3 + 296) = v592;
            *(_QWORD *)(a3 + 304) = v585;
            *(_QWORD *)(a3 + 312) = &v591[8 * v590];
            if (v586)
              operator delete(v586);
          }
          else
          {
            *(double *)v584 = *v122;
            v585 = v584 + 8;
          }
          *(_QWORD *)(a3 + 304) = v585;
          v451 = 1;
          v131 = v465;
          v132 = v879;
        }
        ++v128;
        ++v129;
        ++v122;
        v124 = v884;
        goto LABEL_1013;
      }
LABEL_783:
      while (v122 != v124)
      {
        if (*v122 >= v126)
          goto LABEL_787;
        ++v128;
        ++v129;
        ++v122;
      }
      v122 = v124;
LABEL_787:
      v467 = 0;
      v468 = *(double **)(v14 + v16);
      v469 = v122 - 3;
      v470 = v129 - 3;
      v471 = v128 - 3;
      v872 = v131;
      while (1)
      {
        if (v122 == v468)
        {
          v469 = v468;
          if (!v467)
            goto LABEL_918;
          goto LABEL_794;
        }
        if (v122 != v124 && *v122 <= v127)
          break;
        --v128;
        --v129;
        --v122;
        if (--v467 == -3)
        {
          v472 = 3;
          goto LABEL_795;
        }
      }
      v469 = v122;
      if (!v467)
      {
LABEL_918:
        v470 = v129;
        v471 = v128;
        goto LABEL_919;
      }
LABEL_794:
      v472 = -v467;
      v471 = v128;
      v470 = v129;
LABEL_795:
      v473 = *(double **)(a3 + 296);
      v474 = *(double **)(a3 + 304);
      if (v474 != v473)
      {
        v475 = *v469;
        v476 = v474 - 1;
        do
        {
          if (*v476 < v475)
            break;
          *(_QWORD *)(a3 + 328) -= 8;
          *(_QWORD *)(a3 + 352) -= 8;
          *(_QWORD *)(a3 + 304) = v476;
          v125 = v476-- == v473;
        }
        while (!v125);
      }
      if (v472 && v469 != v124)
        break;
LABEL_919:
      if (v469 == v124)
      {
        v122 = v124;
        v129 = v470;
        v128 = v471;
        v16 = v860;
        v14 = v861;
        goto LABEL_1015;
      }
      v128 = v471 + 1;
      v129 = v470 + 1;
      v122 = v469 + 1;
      v16 = v860;
      v14 = v861;
      v131 = v872;
      v132 = v879;
LABEL_1013:
      if (v122 == v124)
      {
        v122 = v124;
LABEL_1015:
        if (v880)
        {
          if ((v451 & 1) != 0)
          {
            v594 = v868;
            if (v859 < 0.0000001)
            {
              v453 = *(double *)(*(_QWORD *)(v873 + 200) - 8);
              if (*(_DWORD *)(a3 + 168))
              {
                v453 = v453 + 1.0;
                v595 = *(double **)(v873 + 216);
                v596 = *(double **)(v873 + 240);
              }
              else
              {
                v595 = (double *)(*(_QWORD *)(v873 + 224) - 8);
                v596 = (double *)(*(_QWORD *)(v873 + 248) - 8);
              }
              v594 = *v595;
              v452 = *v596;
            }
            v693 = *(char **)(a3 + 320);
            v694 = *(char **)(a3 + 328);
            v695 = v694 - v693;
            if (v694 != v693
              && vabdd_f64(*((double *)v694 - 1), v594) < 0.0000001
              && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), v452) < 0.0000001)
            {
              goto LABEL_1463;
            }
            if ((unint64_t)v694 >= *v888)
            {
              v697 = v695 >> 3;
              v698 = (v695 >> 3) + 1;
              if (v698 >> 61)
                goto LABEL_1505;
              v699 = *v888 - (_QWORD)v693;
              if (v699 >> 2 > v698)
                v698 = v699 >> 2;
              if ((unint64_t)v699 >= 0x7FFFFFFFFFFFFFF8)
                v700 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v700 = v698;
              if (v700)
              {
                v701 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v700);
                v693 = *(char **)(a3 + 320);
                v694 = *(char **)(a3 + 328);
              }
              else
              {
                v701 = 0;
              }
              v768 = (double *)&v701[8 * v697];
              *v768 = v594;
              v696 = v768 + 1;
              while (v694 != v693)
              {
                v769 = *((_QWORD *)v694 - 1);
                v694 -= 8;
                *((_QWORD *)v768-- - 1) = v769;
              }
              *(_QWORD *)(a3 + 320) = v768;
              *(_QWORD *)(a3 + 328) = v696;
              *(_QWORD *)(a3 + 336) = &v701[8 * v700];
              if (v693)
                operator delete(v693);
            }
            else
            {
              *(double *)v694 = v594;
              v696 = v694 + 8;
            }
            *(_QWORD *)(a3 + 328) = v696;
            v771 = *(char **)(a3 + 352);
            v770 = *(_QWORD *)(a3 + 360);
            if ((unint64_t)v771 >= v770)
            {
              v773 = *v885;
              v774 = (v771 - *v885) >> 3;
              v775 = v774 + 1;
              if ((unint64_t)(v774 + 1) >> 61)
                goto LABEL_1503;
              v776 = v770 - (_QWORD)v773;
              if (v776 >> 2 > v775)
                v775 = v776 >> 2;
              if ((unint64_t)v776 >= 0x7FFFFFFFFFFFFFF8)
                v777 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v777 = v775;
              if (v777)
              {
                v778 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v777);
                v773 = *(char **)(a3 + 344);
                v771 = *(char **)(a3 + 352);
              }
              else
              {
                v778 = 0;
              }
              v779 = (double *)&v778[8 * v774];
              *v779 = v452;
              v772 = v779 + 1;
              while (v771 != v773)
              {
                v780 = *((_QWORD *)v771 - 1);
                v771 -= 8;
                *((_QWORD *)v779-- - 1) = v780;
              }
              *(_QWORD *)(a3 + 344) = v779;
              *(_QWORD *)(a3 + 352) = v772;
              *(_QWORD *)(a3 + 360) = &v778[8 * v777];
              if (v773)
                operator delete(v773);
            }
            else
            {
              *(double *)v771 = v452;
              v772 = v771 + 8;
            }
            *(_QWORD *)(a3 + 352) = v772;
            v782 = *(double **)(a3 + 304);
            v781 = *(_QWORD *)(a3 + 312);
            if ((unint64_t)v782 >= v781)
            {
              v784 = (double *)*v883;
              v785 = ((char *)v782 - *v883) >> 3;
              v786 = v785 + 1;
              if ((unint64_t)(v785 + 1) >> 61)
                goto LABEL_1504;
              v787 = v781 - (_QWORD)v784;
              if (v787 >> 2 > v786)
                v786 = v787 >> 2;
              if ((unint64_t)v787 >= 0x7FFFFFFFFFFFFFF8)
                v788 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v788 = v786;
              if (v788)
              {
                v789 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v788);
                v784 = *(double **)(a3 + 296);
                v782 = *(double **)(a3 + 304);
              }
              else
              {
                v789 = 0;
              }
              v790 = (double *)&v789[8 * v785];
              *v790 = v453;
              v791 = v790 + 1;
              while (v782 != v784)
              {
                v792 = *((_QWORD *)v782-- - 1);
                *((_QWORD *)v790-- - 1) = v792;
              }
              goto LABEL_1460;
            }
            *v782 = v453;
            v783 = v782 + 1;
            goto LABEL_1447;
          }
LABEL_1021:
          if (!*(_DWORD *)(a3 + 168))
          {
LABEL_1334:
            if (v122 != v124)
              goto LABEL_1463;
            v766 = *(_QWORD *)(a3 + 328);
            v767 = *(_QWORD *)(v873 + 224);
            if (v766 != *(_QWORD *)(a3 + 320)
              && vabdd_f64(*(double *)(v766 - 8), *(double *)(v767 - 8)) < 0.0000001
              && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *(double *)(*(_QWORD *)(v873 + 248) - 8)) < 0.0000001)
            {
              goto LABEL_1463;
            }
            v683 = (_QWORD *)(v767 - 8);
            goto LABEL_1339;
          }
          if (v122 != v124)
            goto LABEL_1463;
          v597 = *(char **)(a3 + 320);
          v598 = *(char **)(a3 + 328);
          v599 = *(double **)(v873 + 216);
          v600 = v598 - v597;
          if (v598 != v597
            && vabdd_f64(*((double *)v598 - 1), *v599) < 0.0000001
            && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), **(double **)(v873 + 240)) < 0.0000001)
          {
            goto LABEL_1463;
          }
          if ((unint64_t)v598 >= *v888)
          {
            v688 = v600 >> 3;
            v689 = (v600 >> 3) + 1;
            if (v689 >> 61)
              goto LABEL_1505;
            v690 = *v888 - (_QWORD)v597;
            if (v690 >> 2 > v689)
              v689 = v690 >> 2;
            if ((unint64_t)v690 >= 0x7FFFFFFFFFFFFFF8)
              v691 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v691 = v689;
            if (v691)
            {
              v692 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v691);
              v597 = *(char **)(a3 + 320);
              v598 = *(char **)(a3 + 328);
            }
            else
            {
              v692 = 0;
            }
            v602 = v873;
            v798 = &v692[8 * v688];
            *(double *)v798 = *v599;
            v601 = v798 + 8;
            while (v598 != v597)
            {
              v799 = *((_QWORD *)v598 - 1);
              v598 -= 8;
              *((_QWORD *)v798 - 1) = v799;
              v798 -= 8;
            }
            *(_QWORD *)(a3 + 320) = v798;
            *(_QWORD *)(a3 + 328) = v601;
            *(_QWORD *)(a3 + 336) = &v692[8 * v691];
            if (v597)
              operator delete(v597);
          }
          else
          {
            *(double *)v598 = *v599;
            v601 = v598 + 8;
            v602 = v873;
          }
          *(_QWORD *)(a3 + 328) = v601;
          v800 = *(_QWORD **)(v602 + 240);
          v802 = *(char **)(a3 + 352);
          v801 = *(_QWORD *)(a3 + 360);
          if ((unint64_t)v802 >= v801)
          {
            v804 = *v885;
            v805 = (v802 - *v885) >> 3;
            v806 = v805 + 1;
            if ((unint64_t)(v805 + 1) >> 61)
              goto LABEL_1503;
            v807 = v801 - (_QWORD)v804;
            if (v807 >> 2 > v806)
              v806 = v807 >> 2;
            if ((unint64_t)v807 >= 0x7FFFFFFFFFFFFFF8)
              v808 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v808 = v806;
            if (v808)
            {
              v809 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v808);
              v804 = *(char **)(a3 + 344);
              v802 = *(char **)(a3 + 352);
            }
            else
            {
              v809 = 0;
            }
            v810 = &v809[8 * v805];
            *(_QWORD *)v810 = *v800;
            v803 = v810 + 8;
            while (v802 != v804)
            {
              v811 = *((_QWORD *)v802 - 1);
              v802 -= 8;
              *((_QWORD *)v810 - 1) = v811;
              v810 -= 8;
            }
            *(_QWORD *)(a3 + 344) = v810;
            *(_QWORD *)(a3 + 352) = v803;
            *(_QWORD *)(a3 + 360) = &v809[8 * v808];
            if (v804)
              operator delete(v804);
          }
          else
          {
            *(_QWORD *)v802 = *v800;
            v803 = v802 + 8;
          }
          *(_QWORD *)(a3 + 352) = v803;
          v812 = *(double *)(*(_QWORD *)(v602 + 200) - 8) + 1.0;
          v814 = *(double **)(a3 + 304);
          v813 = *(_QWORD *)(a3 + 312);
          if ((unint64_t)v814 >= v813)
          {
            v784 = (double *)*v883;
            v815 = ((char *)v814 - *v883) >> 3;
            v816 = v815 + 1;
            if ((unint64_t)(v815 + 1) >> 61)
              goto LABEL_1504;
            v817 = v813 - (_QWORD)v784;
            if (v817 >> 2 > v816)
              v816 = v817 >> 2;
            if ((unint64_t)v817 >= 0x7FFFFFFFFFFFFFF8)
              v788 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v788 = v816;
            if (v788)
            {
              v789 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v788);
              v784 = *(double **)(a3 + 296);
              v814 = *(double **)(a3 + 304);
            }
            else
            {
              v789 = 0;
            }
            v790 = (double *)&v789[8 * v815];
            *v790 = v812;
            v791 = v790 + 1;
            while (v814 != v784)
            {
              v818 = *((_QWORD *)v814-- - 1);
              *((_QWORD *)v790-- - 1) = v818;
            }
            goto LABEL_1460;
          }
          *v814 = v812;
          v783 = v814 + 1;
LABEL_1447:
          v791 = v783;
LABEL_1462:
          *(_QWORD *)(a3 + 304) = v791;
LABEL_1463:
          v838 = *(double **)(a3 + 320);
          if (*(_QWORD *)(a3 + 328) - (_QWORD)v838 < 0x11uLL || (fabs(v24) >= 0.0000001) | v878 & 1)
          {
            v19 = v875;
            v38 = 0.5;
          }
          else
          {
            v853 = *(char **)(v873 + 216);
            if (vabdd_f64(*v838, *(double *)v853) >= 0.00001
              || vabdd_f64(*(double *)*v885, **(double **)(v873 + 240)) >= 0.00001)
            {
              std::vector<double>::insert((uint64_t)v874, *(char **)(a3 + 320), v853);
              std::vector<double>::insert((uint64_t)v885, *v885, *(char **)(v873 + 240));
              std::vector<double>::insert((uint64_t)v883, *v883, *(char **)(v873 + 192));
            }
            v854 = OZChannel::getValueAsInt(v877, MEMORY[0x1E0CA2E68], 0.0);
            v838 = *v874;
            v19 = v875;
            v38 = 0.5;
            if (v854 != 4)
            {
              v855 = *(_QWORD *)(v873 + 216);
              v857 = *(double *)(v855 + 8);
              v856 = (char *)(v855 + 8);
              if (vabdd_f64(*v838, v857) >= 0.00001
                || vabdd_f64(*(double *)*v885, *(double *)(*(_QWORD *)(v873 + 240) + 8)) >= 0.00001)
              {
                v858 = *(double *)(*(_QWORD *)(v873 + 192) + 8);
                if (*((double *)*v883 + 1) > v858 && *(double *)*v883 < v858)
                {
                  std::vector<double>::insert((uint64_t)v874, (char *)v838 + 8, v856);
                  std::vector<double>::insert((uint64_t)v885, *v885 + 8, (char *)(*(_QWORD *)(v873 + 240) + 8));
                  std::vector<double>::insert((uint64_t)v883, *v883 + 8, (char *)(*(_QWORD *)(v873 + 192) + 8));
                  v838 = *v874;
                }
              }
            }
          }
          v839 = *(double **)(a3 + 328);
          if ((unint64_t)((char *)v839 - (char *)v838) >= 0x11)
          {
            v840 = v839 - 1;
            v841 = v839 - v838 - 2;
            if (vabdd_f64(*(v839 - 1), v838[v841]) >= 0.00001
              || (v842 = *(_QWORD *)(a3 + 352),
                  v844 = *(double *)(v842 - 8),
                  v843 = v842 - 8,
                  vabdd_f64(v844, *(double *)(*(_QWORD *)(a3 + 344) + 8 * v841)) >= 0.00001)
              || (*(_QWORD *)(a3 + 328) = v840,
                  *(_QWORD *)(a3 + 352) = v843,
                  *(_QWORD *)(a3 + 304) -= 8,
                  --v839,
                  (unint64_t)((char *)v840 - (char *)v838) >= 0x11))
            {
              v845 = v838 + 1;
              if (vabdd_f64(*v838, v838[1]) < 0.00001)
              {
                v846 = *v885;
                if (vabdd_f64(*(double *)*v885, *((double *)*v885 + 1)) < 0.00001)
                {
                  v847 = (char *)v839 - (char *)v845;
                  if (v839 != v845)
                  {
                    memmove(v838, v845, (char *)v839 - (char *)v845);
                    v846 = *v885;
                  }
                  *(_QWORD *)(a3 + 328) = (char *)v838 + v847;
                  v848 = *(char **)(a3 + 352);
                  v849 = v848 - (v846 + 8);
                  if (v848 != v846 + 8)
                    memmove(v846, v846 + 8, v848 - (v846 + 8));
                  *(_QWORD *)(a3 + 352) = &v846[v849];
                  v851 = *(_QWORD *)(a3 + 296);
                  v850 = *(_QWORD *)(a3 + 304);
                  v852 = v850 - (v851 + 8);
                  if (v850 != v851 + 8)
                    memmove(*(void **)(a3 + 296), (const void *)(v851 + 8), v850 - (v851 + 8));
                  *(_QWORD *)(a3 + 304) = v851 + v852;
                }
              }
            }
          }
          goto LABEL_1479;
        }
        if ((v451 & 1) != 0)
          goto LABEL_1163;
        while (v122 != v124)
        {
          if (*v122 >= v126)
            goto LABEL_1035;
          ++v128;
          ++v129;
          ++v122;
        }
        v122 = v124;
LABEL_1035:
        v603 = 0;
        v604 = v122 - 3;
        v605 = v129 - 3;
        v606 = v128 - 3;
        while (1)
        {
          if (v122 == *(double **)(v14 + v16))
          {
            v604 = *(double **)(v14 + v16);
            if (v603)
              goto LABEL_1048;
            goto LABEL_1162;
          }
          if (v122 != v124 && *v122 <= v127)
            break;
          --v128;
          --v129;
          --v122;
          if (--v603 == -3)
          {
            v607 = 3;
            goto LABEL_1049;
          }
        }
        v604 = v122;
        if (v603)
        {
LABEL_1048:
          v607 = -v603;
          v606 = v128;
          v605 = v129;
LABEL_1049:
          v608 = *(double **)(a3 + 296);
          v609 = *(double **)(a3 + 304);
          if (v609 != v608)
          {
            v610 = *v604;
            v611 = v609 - 1;
            do
            {
              if (*v611 < v610)
                break;
              *(_QWORD *)(a3 + 328) -= 8;
              *(_QWORD *)(a3 + 352) -= 8;
              *(_QWORD *)(a3 + 304) = v611;
              v125 = v611-- == v608;
            }
            while (!v125);
          }
          if (v607 && v604 != v124)
          {
            v612 = 0;
            v613 = *(double **)(a3 + 304);
            while (1)
            {
              v614 = *(double **)(a3 + 328);
              if (v613 == *(double **)(a3 + 296))
              {
                if ((unint64_t)v614 >= *v888)
                {
                  v618 = *v874;
                  v619 = v614 - *v874;
                  v620 = v619 + 1;
                  if ((unint64_t)(v619 + 1) >> 61)
                    goto LABEL_1506;
                  v621 = *v888 - (_QWORD)v618;
                  if (v621 >> 2 > v620)
                    v620 = v621 >> 2;
                  if ((unint64_t)v621 >= 0x7FFFFFFFFFFFFFF8)
                    v622 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v622 = v620;
                  if (v622)
                  {
                    v623 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v622);
                    v618 = *(double **)(a3 + 320);
                    v614 = *(double **)(a3 + 328);
                  }
                  else
                  {
                    v623 = 0;
                  }
                  v630 = &v623[8 * v619];
                  *(double *)v630 = *v606;
                  v617 = v630 + 8;
                  while (v614 != v618)
                  {
                    v631 = *((_QWORD *)v614-- - 1);
                    *((_QWORD *)v630 - 1) = v631;
                    v630 -= 8;
                  }
                  *(_QWORD *)(a3 + 320) = v630;
                  *(_QWORD *)(a3 + 328) = v617;
                  *(_QWORD *)(a3 + 336) = &v623[8 * v622];
                  if (v618)
                    operator delete(v618);
                  v124 = v884;
                }
                else
                {
                  *v614 = *v606;
                  v617 = v614 + 1;
                }
                *(_QWORD *)(a3 + 328) = v617;
                v633 = *(char **)(a3 + 352);
                v632 = *(_QWORD *)(a3 + 360);
                if ((unint64_t)v633 >= v632)
                {
                  v635 = *v885;
                  v636 = (v633 - *v885) >> 3;
                  v637 = v636 + 1;
                  if ((unint64_t)(v636 + 1) >> 61)
                    goto LABEL_1503;
                  v638 = v632 - (_QWORD)v635;
                  if (v638 >> 2 > v637)
                    v637 = v638 >> 2;
                  if ((unint64_t)v638 >= 0x7FFFFFFFFFFFFFF8)
                    v639 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v639 = v637;
                  if (v639)
                  {
                    v640 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v639);
                    v635 = *(char **)(a3 + 344);
                    v633 = *(char **)(a3 + 352);
                  }
                  else
                  {
                    v640 = 0;
                  }
                  v641 = &v640[8 * v636];
                  *(double *)v641 = *v605;
                  v634 = v641 + 8;
                  while (v633 != v635)
                  {
                    v642 = *((_QWORD *)v633 - 1);
                    v633 -= 8;
                    *((_QWORD *)v641 - 1) = v642;
                    v641 -= 8;
                  }
                  *(_QWORD *)(a3 + 344) = v641;
                  *(_QWORD *)(a3 + 352) = v634;
                  *(_QWORD *)(a3 + 360) = &v640[8 * v639];
                  if (v635)
                    operator delete(v635);
                  v124 = v884;
                }
                else
                {
                  *(double *)v633 = *v605;
                  v634 = v633 + 8;
                }
                *(_QWORD *)(a3 + 352) = v634;
                v644 = *(char **)(a3 + 304);
                v643 = *(_QWORD *)(a3 + 312);
                if ((unint64_t)v644 >= v643)
                {
                  v645 = *v883;
                  v646 = (v644 - *v883) >> 3;
                  v647 = v646 + 1;
                  if ((unint64_t)(v646 + 1) >> 61)
                    goto LABEL_1504;
                  v648 = v643 - (_QWORD)v645;
                  if (v648 >> 2 > v647)
                    v647 = v648 >> 2;
                  if ((unint64_t)v648 >= 0x7FFFFFFFFFFFFFF8)
                    v649 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v649 = v647;
                  if (v649)
                  {
                    v650 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v649);
                    v645 = *(char **)(a3 + 296);
                    v644 = *(char **)(a3 + 304);
                  }
                  else
                  {
                    v650 = 0;
                  }
                  v651 = &v650[8 * v646];
                  *(double *)v651 = *v604;
                  v613 = (double *)(v651 + 8);
                  while (v644 != v645)
                  {
                    v652 = *((_QWORD *)v644 - 1);
                    v644 -= 8;
                    *((_QWORD *)v651 - 1) = v652;
                    v651 -= 8;
                  }
LABEL_1156:
                  *(_QWORD *)(a3 + 296) = v651;
                  *(_QWORD *)(a3 + 304) = v613;
                  *(_QWORD *)(a3 + 312) = &v650[8 * v649];
                  if (v645)
                    operator delete(v645);
                  v124 = v884;
                  goto LABEL_1159;
                }
              }
              else
              {
                v615 = *v606;
                if (vabdd_f64(*(v614 - 1), *v606) < 0.0000001
                  && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v605) < 0.0000001
                  || *(v613 - 1) >= *v604)
                {
                  goto LABEL_1160;
                }
                if ((unint64_t)v614 >= *v888)
                {
                  v624 = *v874;
                  v625 = v614 - *v874;
                  v626 = v625 + 1;
                  if ((unint64_t)(v625 + 1) >> 61)
                    goto LABEL_1506;
                  v627 = *v888 - (_QWORD)v624;
                  if (v627 >> 2 > v626)
                    v626 = v627 >> 2;
                  if ((unint64_t)v627 >= 0x7FFFFFFFFFFFFFF8)
                    v628 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v628 = v626;
                  if (v628)
                  {
                    v629 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v628);
                    v624 = *(double **)(a3 + 320);
                    v614 = *(double **)(a3 + 328);
                    v615 = *v606;
                  }
                  else
                  {
                    v629 = 0;
                  }
                  v653 = (double *)&v629[8 * v625];
                  *v653 = v615;
                  v616 = v653 + 1;
                  while (v614 != v624)
                  {
                    v654 = *((_QWORD *)v614-- - 1);
                    *((_QWORD *)v653-- - 1) = v654;
                  }
                  *(_QWORD *)(a3 + 320) = v653;
                  *(_QWORD *)(a3 + 328) = v616;
                  *(_QWORD *)(a3 + 336) = &v629[8 * v628];
                  if (v624)
                    operator delete(v624);
                  v124 = v884;
                }
                else
                {
                  *v614 = v615;
                  v616 = v614 + 1;
                }
                *(_QWORD *)(a3 + 328) = v616;
                v656 = *(char **)(a3 + 352);
                v655 = *(_QWORD *)(a3 + 360);
                if ((unint64_t)v656 >= v655)
                {
                  v658 = *v885;
                  v659 = (v656 - *v885) >> 3;
                  v660 = v659 + 1;
                  if ((unint64_t)(v659 + 1) >> 61)
                    goto LABEL_1503;
                  v661 = v655 - (_QWORD)v658;
                  if (v661 >> 2 > v660)
                    v660 = v661 >> 2;
                  if ((unint64_t)v661 >= 0x7FFFFFFFFFFFFFF8)
                    v662 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v662 = v660;
                  if (v662)
                  {
                    v663 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v662);
                    v658 = *(char **)(a3 + 344);
                    v656 = *(char **)(a3 + 352);
                  }
                  else
                  {
                    v663 = 0;
                  }
                  v664 = &v663[8 * v659];
                  *(double *)v664 = *v605;
                  v657 = v664 + 8;
                  while (v656 != v658)
                  {
                    v665 = *((_QWORD *)v656 - 1);
                    v656 -= 8;
                    *((_QWORD *)v664 - 1) = v665;
                    v664 -= 8;
                  }
                  *(_QWORD *)(a3 + 344) = v664;
                  *(_QWORD *)(a3 + 352) = v657;
                  *(_QWORD *)(a3 + 360) = &v663[8 * v662];
                  if (v658)
                    operator delete(v658);
                  v124 = v884;
                }
                else
                {
                  *(double *)v656 = *v605;
                  v657 = v656 + 8;
                }
                *(_QWORD *)(a3 + 352) = v657;
                v644 = *(char **)(a3 + 304);
                v666 = *(_QWORD *)(a3 + 312);
                if ((unint64_t)v644 >= v666)
                {
                  v645 = *v883;
                  v667 = (v644 - *v883) >> 3;
                  v668 = v667 + 1;
                  if ((unint64_t)(v667 + 1) >> 61)
                    goto LABEL_1504;
                  v669 = v666 - (_QWORD)v645;
                  if (v669 >> 2 > v668)
                    v668 = v669 >> 2;
                  if ((unint64_t)v669 >= 0x7FFFFFFFFFFFFFF8)
                    v649 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v649 = v668;
                  if (v649)
                  {
                    v650 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v649);
                    v645 = *(char **)(a3 + 296);
                    v644 = *(char **)(a3 + 304);
                  }
                  else
                  {
                    v650 = 0;
                  }
                  v651 = &v650[8 * v667];
                  *(double *)v651 = *v604;
                  v613 = (double *)(v651 + 8);
                  while (v644 != v645)
                  {
                    v670 = *((_QWORD *)v644 - 1);
                    v644 -= 8;
                    *((_QWORD *)v651 - 1) = v670;
                    v651 -= 8;
                  }
                  goto LABEL_1156;
                }
              }
              *(double *)v644 = *v604;
              v613 = (double *)(v644 + 8);
LABEL_1159:
              *(_QWORD *)(a3 + 304) = v613;
LABEL_1160:
              ++v604;
              if (++v612 < v607)
              {
                ++v606;
                ++v605;
                if (v604 != v124)
                  continue;
              }
              break;
            }
          }
        }
LABEL_1162:
        v122 = &v604[v604 != v124];
LABEL_1163:
        if (v122 != v124)
          goto LABEL_1463;
        v672 = *(_QWORD *)(a3 + 296);
        v671 = *(_QWORD *)(a3 + 304);
        if (*(_DWORD *)(a3 + 168))
        {
          if (v671 == v672)
          {
            std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, *(_QWORD **)(v873 + 216));
            v687 = *(_QWORD **)(v873 + 240);
LABEL_1333:
            std::vector<double>::push_back[abi:ne180100]((uint64_t)v885, v687);
            v889[0] = ceil(*(double *)(*(_QWORD *)(v866 + 8) - 8));
            std::vector<double>::push_back[abi:ne180100]((uint64_t)v883, v889);
            goto LABEL_1463;
          }
          v673 = *(double **)(v873 + 216);
          if (vabdd_f64(*(double *)(*(_QWORD *)(a3 + 328) - 8), *v673) < 0.0000001
            && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), **(double **)(v873 + 240)) < 0.0000001)
          {
            goto LABEL_1463;
          }
          v674 = *(double *)(v671 - 8);
          v675 = ceil(*(double *)(*(_QWORD *)(v866 + 8) - 8));
          if (v674 >= v675 || vabdd_f64(v674, v675) < 0.00001)
            goto LABEL_1463;
LABEL_1332:
          std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, v673);
          v687 = *(_QWORD **)(v873 + 240);
          goto LABEL_1333;
        }
        v681 = v873;
        if (v671 == v672)
        {
          std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, (_QWORD *)(*(_QWORD *)(v873 + 224) - 8));
          goto LABEL_1341;
        }
        v682 = *(_QWORD *)(v873 + 224);
        v684 = *(double *)(v682 - 8);
        v683 = (_QWORD *)(v682 - 8);
        if (vabdd_f64(*(double *)(*(_QWORD *)(a3 + 328) - 8), v684) < 0.0000001
          && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *(double *)(*(_QWORD *)(v873 + 248) - 8)) < 0.0000001)
        {
          goto LABEL_1463;
        }
        v685 = *(double *)(v671 - 8);
        v686 = *(double *)(*(_QWORD *)(v873 + 200) - 8);
        if (v685 >= v686 || vabdd_f64(v685, v686) < 0.00001)
          goto LABEL_1463;
LABEL_1339:
        std::vector<double>::push_back[abi:ne180100]((uint64_t)v874, v683);
        v681 = v873;
LABEL_1341:
        std::vector<double>::push_back[abi:ne180100]((uint64_t)v885, (_QWORD *)(*(_QWORD *)(v681 + 248) - 8));
        std::vector<double>::push_back[abi:ne180100]((uint64_t)v883, (_QWORD *)(*(_QWORD *)(v681 + 200) - 8));
        goto LABEL_1463;
      }
    }
    v477 = 0;
    v478 = *(double **)(a3 + 304);
    while (1)
    {
      v479 = *(double **)(a3 + 328);
      if (v478 == *(double **)(a3 + 296))
      {
        if ((unint64_t)v479 >= *v888)
        {
          v483 = *v874;
          v484 = v479 - *v874;
          v485 = v484 + 1;
          if ((unint64_t)(v484 + 1) >> 61)
            goto LABEL_1506;
          v486 = *v888 - (_QWORD)v483;
          if (v486 >> 2 > v485)
            v485 = v486 >> 2;
          if ((unint64_t)v486 >= 0x7FFFFFFFFFFFFFF8)
            v487 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v487 = v485;
          if (v487)
          {
            v488 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v487);
            v483 = *(double **)(a3 + 320);
            v479 = *(double **)(a3 + 328);
          }
          else
          {
            v488 = 0;
          }
          v495 = &v488[8 * v484];
          *(double *)v495 = *v471;
          v482 = v495 + 8;
          while (v479 != v483)
          {
            v496 = *((_QWORD *)v479-- - 1);
            *((_QWORD *)v495 - 1) = v496;
            v495 -= 8;
          }
          *(_QWORD *)(a3 + 320) = v495;
          *(_QWORD *)(a3 + 328) = v482;
          *(_QWORD *)(a3 + 336) = &v488[8 * v487];
          if (v483)
            operator delete(v483);
          v124 = v884;
        }
        else
        {
          *v479 = *v471;
          v482 = v479 + 1;
        }
        *(_QWORD *)(a3 + 328) = v482;
        v498 = *(char **)(a3 + 352);
        v497 = *(_QWORD *)(a3 + 360);
        if ((unint64_t)v498 >= v497)
        {
          v500 = *v885;
          v501 = (v498 - *v885) >> 3;
          v502 = v501 + 1;
          if ((unint64_t)(v501 + 1) >> 61)
            goto LABEL_1503;
          v503 = v497 - (_QWORD)v500;
          if (v503 >> 2 > v502)
            v502 = v503 >> 2;
          if ((unint64_t)v503 >= 0x7FFFFFFFFFFFFFF8)
            v504 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v504 = v502;
          if (v504)
          {
            v505 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v504);
            v500 = *(char **)(a3 + 344);
            v498 = *(char **)(a3 + 352);
          }
          else
          {
            v505 = 0;
          }
          v506 = &v505[8 * v501];
          *(double *)v506 = *v470;
          v499 = v506 + 8;
          while (v498 != v500)
          {
            v507 = *((_QWORD *)v498 - 1);
            v498 -= 8;
            *((_QWORD *)v506 - 1) = v507;
            v506 -= 8;
          }
          *(_QWORD *)(a3 + 344) = v506;
          *(_QWORD *)(a3 + 352) = v499;
          *(_QWORD *)(a3 + 360) = &v505[8 * v504];
          if (v500)
            operator delete(v500);
          v124 = v884;
        }
        else
        {
          *(double *)v498 = *v470;
          v499 = v498 + 8;
        }
        *(_QWORD *)(a3 + 352) = v499;
        v509 = *(char **)(a3 + 304);
        v508 = *(_QWORD *)(a3 + 312);
        if ((unint64_t)v509 >= v508)
        {
          v510 = *v883;
          v511 = (v509 - *v883) >> 3;
          v512 = v511 + 1;
          if ((unint64_t)(v511 + 1) >> 61)
            goto LABEL_1504;
          v513 = v508 - (_QWORD)v510;
          if (v513 >> 2 > v512)
            v512 = v513 >> 2;
          if ((unint64_t)v513 >= 0x7FFFFFFFFFFFFFF8)
            v514 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v514 = v512;
          if (v514)
          {
            v515 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v514);
            v510 = *(char **)(a3 + 296);
            v509 = *(char **)(a3 + 304);
          }
          else
          {
            v515 = 0;
          }
          v516 = &v515[8 * v511];
          *(double *)v516 = *v469;
          v478 = (double *)(v516 + 8);
          while (v509 != v510)
          {
            v517 = *((_QWORD *)v509 - 1);
            v509 -= 8;
            *((_QWORD *)v516 - 1) = v517;
            v516 -= 8;
          }
LABEL_902:
          *(_QWORD *)(a3 + 296) = v516;
          *(_QWORD *)(a3 + 304) = v478;
          *(_QWORD *)(a3 + 312) = &v515[8 * v514];
          if (v510)
            operator delete(v510);
          v124 = v884;
          goto LABEL_905;
        }
      }
      else
      {
        v480 = *v471;
        if (vabdd_f64(*(v479 - 1), *v471) < 0.0000001
          && vabdd_f64(*(double *)(*(_QWORD *)(a3 + 352) - 8), *v470) < 0.0000001
          || *(v478 - 1) >= *v469)
        {
          goto LABEL_906;
        }
        if ((unint64_t)v479 >= *v888)
        {
          v489 = *v874;
          v490 = v479 - *v874;
          v491 = v490 + 1;
          if ((unint64_t)(v490 + 1) >> 61)
LABEL_1506:
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v492 = *v888 - (_QWORD)v489;
          if (v492 >> 2 > v491)
            v491 = v492 >> 2;
          if ((unint64_t)v492 >= 0x7FFFFFFFFFFFFFF8)
            v493 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v493 = v491;
          if (v493)
          {
            v494 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v888, v493);
            v489 = *(double **)(a3 + 320);
            v479 = *(double **)(a3 + 328);
            v480 = *v471;
          }
          else
          {
            v494 = 0;
          }
          v518 = (double *)&v494[8 * v490];
          *v518 = v480;
          v481 = v518 + 1;
          while (v479 != v489)
          {
            v519 = *((_QWORD *)v479-- - 1);
            *((_QWORD *)v518-- - 1) = v519;
          }
          *(_QWORD *)(a3 + 320) = v518;
          *(_QWORD *)(a3 + 328) = v481;
          *(_QWORD *)(a3 + 336) = &v494[8 * v493];
          if (v489)
            operator delete(v489);
          v124 = v884;
        }
        else
        {
          *v479 = v480;
          v481 = v479 + 1;
        }
        *(_QWORD *)(a3 + 328) = v481;
        v521 = *(char **)(a3 + 352);
        v520 = *(_QWORD *)(a3 + 360);
        if ((unint64_t)v521 >= v520)
        {
          v523 = *v885;
          v524 = (v521 - *v885) >> 3;
          v525 = v524 + 1;
          if ((unint64_t)(v524 + 1) >> 61)
            goto LABEL_1503;
          v526 = v520 - (_QWORD)v523;
          if (v526 >> 2 > v525)
            v525 = v526 >> 2;
          if ((unint64_t)v526 >= 0x7FFFFFFFFFFFFFF8)
            v527 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v527 = v525;
          if (v527)
          {
            v528 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v882, v527);
            v523 = *(char **)(a3 + 344);
            v521 = *(char **)(a3 + 352);
          }
          else
          {
            v528 = 0;
          }
          v529 = &v528[8 * v524];
          *(double *)v529 = *v470;
          v522 = v529 + 8;
          while (v521 != v523)
          {
            v530 = *((_QWORD *)v521 - 1);
            v521 -= 8;
            *((_QWORD *)v529 - 1) = v530;
            v529 -= 8;
          }
          *(_QWORD *)(a3 + 344) = v529;
          *(_QWORD *)(a3 + 352) = v522;
          *(_QWORD *)(a3 + 360) = &v528[8 * v527];
          if (v523)
            operator delete(v523);
          v124 = v884;
        }
        else
        {
          *(double *)v521 = *v470;
          v522 = v521 + 8;
        }
        *(_QWORD *)(a3 + 352) = v522;
        v509 = *(char **)(a3 + 304);
        v531 = *(_QWORD *)(a3 + 312);
        if ((unint64_t)v509 >= v531)
        {
          v510 = *v883;
          v532 = (v509 - *v883) >> 3;
          v533 = v532 + 1;
          if ((unint64_t)(v532 + 1) >> 61)
            goto LABEL_1504;
          v534 = v531 - (_QWORD)v510;
          if (v534 >> 2 > v533)
            v533 = v534 >> 2;
          if ((unint64_t)v534 >= 0x7FFFFFFFFFFFFFF8)
            v514 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v514 = v533;
          if (v514)
          {
            v515 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v881, v514);
            v510 = *(char **)(a3 + 296);
            v509 = *(char **)(a3 + 304);
          }
          else
          {
            v515 = 0;
          }
          v516 = &v515[8 * v532];
          *(double *)v516 = *v469;
          v478 = (double *)(v516 + 8);
          while (v509 != v510)
          {
            v535 = *((_QWORD *)v509 - 1);
            v509 -= 8;
            *((_QWORD *)v516 - 1) = v535;
            v516 -= 8;
          }
          goto LABEL_902;
        }
      }
      *(double *)v509 = *v469;
      v478 = (double *)(v509 + 8);
LABEL_905:
      *(_QWORD *)(a3 + 304) = v478;
      v451 = 1;
LABEL_906:
      ++v471;
      ++v470;
      ++v469;
      if (++v477 >= v472 || v469 == v124)
        goto LABEL_919;
    }
  }
LABEL_1491:
  if (a7)
    *a7 = a3 + 320;
  a6 = v865;
  if (a8)
    *a8 = a3 + 344;
  if (a9)
    *a9 = a3 + 296;
  if (a5)
    *a5 = 0;
  if (v865)
  {
    v12 = ((*(_QWORD *)(a3 + 328) - *(_QWORD *)(a3 + 320)) >> 3) - 1;
    goto LABEL_1501;
  }
}

void std::vector<OZShapeEdgePolygon>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *__p;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xF0F0F0F0F0F0F0F1 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x1E1E1E1E1E1E1E2)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v11 = v3;
    __p = std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v3, a2);
    v8 = (char *)__p + v5;
    v9 = (char *)__p + v5;
    v10 = (char *)__p + 136 * v6;
    std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p);
    if (v9 != v8)
      v9 = &v8[(v9 - v8 - 136) % 0x88uLL];
    if (__p)
      operator delete(__p);
  }
}

void sub_1B3018598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void OZShape::computeInsideFeatheringPolygons(uint64_t a1, uint64_t *a2, _QWORD *a3, double a4, uint64_t a5, uint64_t a6, double *a7)
{
  double v13;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  double v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  unint64_t v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  unint64_t v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double *v58;
  double *v59;
  double *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  double *v66;
  double *v67;
  double *v68;
  uint64_t v69;
  float64x2_t *v70;
  float64x2_t v71;
  float64x2_t v72;
  double *v73;
  double v74;
  double *v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  float64x2_t v91;
  float64x2_t v92;
  int32x2_t v93;
  double v94;
  double v95;
  unint64_t v96;
  uint64_t v97;
  float64x2_t v98;
  double v99;
  double v100;
  double *v101;
  double *v102;
  double v103;
  double v104;
  double v105;
  double v106;
  double v107;
  double v108;
  double v109;
  double v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  unint64_t v120;
  uint64_t v121;
  _OWORD *v122;
  uint64_t v123;
  uint64_t v124;
  _OWORD *v125;
  __int128 v126;
  _OWORD *v127;
  __int128 v128;
  uint64_t v129;
  char *v130;
  __int128 v131;
  uint64_t v132;
  uint64_t v133;
  __int128 v134;
  float64x2_t v135;
  __int128 v136;
  float64x2_t v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  _BYTE v142[19];
  int v143;
  char v144;
  double *v145;
  double *v146;
  double *v147;

  v13 = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  v145 = 0;
  v146 = 0;
  v147 = 0;
  v14 = 1.0;
  if (*(_DWORD *)(a6 + 8))
  {
    v15 = 1.0;
  }
  else
  {
    v15 = 1.0;
    if (fabs(*(double *)(a6 + 224)) >= 0.0000001)
    {
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E0CA2E68], 0.0);
      v14 = v16;
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), MEMORY[0x1E0CA2E68], 0.0);
    }
  }
  v17 = a3[28] - a3[27];
  if (v17)
  {
    v18 = 0;
    v19 = v17 >> 3;
    v20 = (v17 >> 3) - 1;
    v21 = v15 * v15;
    v22 = v14 * (v13 * v13 * v14);
    if ((unint64_t)(v17 >> 3) <= 1)
      v23 = 1;
    else
      v23 = v17 >> 3;
    do
    {
      v24 = a3[27];
      v25 = *(double *)(v24 + 8 * v18);
      v26 = a3[30];
      v27 = *(double *)(v26 + 8 * v18);
      v28 = a7[12];
      v29 = a7[13];
      v30 = a7[15];
      v31 = v30 + v25 * v28 + v27 * v29;
      v32 = *a7;
      v33 = a7[1];
      v34 = a7[3];
      v35 = a7[4];
      v36 = (v34 + v25 * *a7 + v27 * v33) / v31;
      v37 = a7[5];
      v38 = v25 * v35 + v27 * v37;
      v39 = a7[7];
      v40 = (v39 + v38) / v31;
      v41 = (v18 - 1) % v19;
      if (!v18)
        v41 = v20;
      v42 = *(double *)(v24 + 8 * v41);
      v43 = *(double *)(v26 + 8 * v41);
      v44 = v30 + v28 * v42 + v29 * v43;
      v45 = (v34 + v32 * v42 + v33 * v43) / v44;
      v46 = v39 + v35 * v42 + v37 * v43;
      v47 = ++v18 % v19;
      v48 = *(double *)(v24 + 8 * v47);
      v49 = v46 / v44;
      v50 = *(double *)(v26 + 8 * v47);
      v51 = v30 + v28 * v48 + v29 * v50;
      v52 = (v39 + v35 * v48 + v37 * v50) / v51;
      v53 = (v34 + v32 * v48 + v33 * v50) / v51 - v45;
      v54 = v52 - v49;
      v55 = sqrt(v53 * v53 / v21 + v54 * v54 / v22);
      v56 = v36 + v54 * a4 / v55 / v22;
      v57 = v40 - v53 * a4 / v55 / v21;
      v58 = v146;
      if (v146 >= v147)
      {
        v60 = v145;
        v61 = ((char *)v146 - (char *)v145) >> 4;
        v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 60)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v63 = (char *)v147 - (char *)v145;
        if (v147 - v145 > v62)
          v62 = v63 >> 3;
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0)
          v64 = 0xFFFFFFFFFFFFFFFLL;
        else
          v64 = v62;
        if (v64)
        {
          v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)&v147, v64);
          v60 = v145;
          v58 = v146;
        }
        else
        {
          v65 = 0;
        }
        v66 = (double *)&v65[16 * v61];
        *v66 = v56;
        v66[1] = v57;
        v67 = v66;
        if (v58 != v60)
        {
          do
          {
            *((_OWORD *)v67 - 1) = *((_OWORD *)v58 - 1);
            v67 -= 2;
            v58 -= 2;
          }
          while (v58 != v60);
          v60 = v145;
        }
        v59 = v66 + 2;
        v145 = v67;
        v146 = v66 + 2;
        v147 = (double *)&v65[16 * v64];
        if (v60)
          operator delete(v60);
      }
      else
      {
        *v146 = v56;
        v58[1] = v57;
        v59 = v58 + 2;
      }
      v146 = v59;
    }
    while (v18 != v23);
  }
  else
  {
    v59 = v146;
  }
  v68 = v145;
  if ((int)((unint64_t)((char *)v59 - (char *)v145) >> 4) < 2)
  {
    v69 = 0;
  }
  else
  {
    v69 = 0;
    do
    {
      v141 = 0u;
      memset(v142, 0, sizeof(v142));
      v139 = 0u;
      v140 = 0u;
      v137 = 0u;
      v138 = 0u;
      v135 = 0u;
      v136 = 0u;
      v143 = 257;
      v144 = 0;
      v70 = (float64x2_t *)&v68[2 * v69];
      v71 = *v70;
      v135 = v71;
      *((_QWORD *)&v136 + 1) = 0x3FF0000000000000;
      v72 = v70[1];
      v137 = v72;
      *((_QWORD *)&v138 + 1) = 0x3FF0000000000000;
      v73 = (double *)(a3[27] + 8 * v69);
      v74 = v73[1];
      v75 = (double *)(a3[30] + 8 * v69);
      v76 = v75[1];
      v77 = a7[12];
      v78 = a7[13];
      v79 = a7[15];
      v80 = v79 + v74 * v77 + v76 * v78;
      v81 = *a7;
      v82 = a7[1];
      v83 = a7[3];
      v84 = a7[4];
      v85 = (v83 + v74 * *a7 + v76 * v82) / v80;
      v86 = a7[5];
      v87 = v74 * v84 + v76 * v86;
      v88 = a7[7];
      *(double *)&v139 = v85;
      *((double *)&v139 + 1) = (v88 + v87) / v80;
      v140 = xmmword_1B304EEE0;
      v89 = v79 + v77 * *v73 + v78 * *v75;
      v90 = v84 * *v73 + v86 * *v75;
      *(double *)&v141 = (v83 + v81 * *v73 + v82 * *v75) / v89;
      *((double *)&v141 + 1) = (v88 + v90) / v89;
      *(_OWORD *)v142 = xmmword_1B304EEE0;
      v91 = vsubq_f64(v72, v71);
      v92 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v91.f64[0], 0);
      v92.f64[0] = v85 - *(double *)&v141;
      v91.f64[0] = *((double *)&v139 + 1) - *((double *)&v141 + 1);
      v93 = vmovn_s64(vcltzq_f64(vdivq_f64(v92, v91)));
      if ((v93.i8[4] & 1) != 0)
        v94 = -1.0;
      else
        v94 = 1.0;
      if ((v93.i8[0] & 1) != 0)
        v95 = -1.0;
      else
        v95 = 1.0;
      if (vabdd_f64(v94, v95) >= 0.0000001)
      {
        v135 = v72;
        v137 = v71;
      }
      v96 = a2[1];
      if (v96 >= a2[2])
      {
        v97 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v135);
      }
      else
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a2 + 2), a2[1], (uint64_t)&v135);
        v97 = v96 + 136;
        a2[1] = v96 + 136;
      }
      ++v69;
      a2[1] = v97;
      v68 = v145;
    }
    while (v69 < ((((char *)v146 - (char *)v145) << 28) - 0x100000000) >> 32);
  }
  if (*(_DWORD *)(a6 + 168))
  {
    v142[18] = 0;
    *(_WORD *)&v142[16] = 0;
    v143 = 257;
    v144 = 0;
    v98 = *(float64x2_t *)&v68[2 * v69];
    v135 = v98;
    v136 = xmmword_1B304EEE0;
    v99 = *v68;
    v100 = v68[1];
    v137.f64[0] = v99;
    v137.f64[1] = v100;
    v138 = xmmword_1B304EEE0;
    v101 = (double *)a3[27];
    v102 = (double *)a3[30];
    v103 = a7[12];
    v104 = a7[13];
    v105 = a7[15];
    v106 = v105 + *v101 * v103 + *v102 * v104;
    v107 = *a7;
    v108 = a7[1];
    v109 = a7[3];
    v110 = a7[4];
    v111 = a7[5];
    v112 = a7[7];
    v113 = (v112 + *v101 * v110 + *v102 * v111) / v106;
    *(double *)&v139 = (v109 + *v101 * *a7 + *v102 * v108) / v106;
    *((double *)&v139 + 1) = v113;
    v140 = xmmword_1B304EEE0;
    v114 = v101[v69];
    v115 = v102[v69];
    v116 = v105 + v103 * v114 + v104 * v115;
    *(double *)&v141 = (v109 + v107 * v114 + v108 * v115) / v116;
    *((double *)&v141 + 1) = (v112 + v110 * v114 + v111 * v115) / v116;
    *(_OWORD *)v142 = xmmword_1B304EEE0;
    v117 = (*(double *)&v139 - *(double *)&v141) / (v113 - *((double *)&v141 + 1));
    v118 = 1.0;
    if ((v99 - v98.f64[0]) / (v100 - v98.f64[1]) >= 0.0)
      v119 = 1.0;
    else
      v119 = -1.0;
    if (v117 < 0.0)
      v118 = -1.0;
    if (vabdd_f64(v119, v118) >= 0.0000001)
    {
      v135.f64[0] = v99;
      v135.f64[1] = v100;
      v137 = v98;
    }
    v120 = a2[1];
    if (v120 >= a2[2])
    {
      v121 = std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(a2, (uint64_t)&v135);
    }
    else
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a2 + 2), a2[1], (uint64_t)&v135);
      v121 = v120 + 136;
      a2[1] = v120 + 136;
    }
    a2[1] = v121;
  }
  else
  {
    v121 = a2[1];
  }
  v122 = (_OWORD *)*a2;
  if ((int)(-252645135 * ((unint64_t)(v121 - *a2) >> 3)) < 2)
  {
    v124 = 0;
  }
  else
  {
    v123 = 0;
    v124 = 0;
    do
    {
      v125 = (_OWORD *)((char *)v122 + v123);
      v126 = v125[3];
      *(_OWORD *)((char *)v125 + 136) = v125[2];
      *(_OWORD *)((char *)v125 + 152) = v126;
      v127 = (_OWORD *)(*a2 + v123);
      v128 = v127[5];
      *(_OWORD *)((char *)v127 + 232) = v127[4];
      ++v124;
      *(_OWORD *)((char *)v127 + 248) = v128;
      v122 = (_OWORD *)*a2;
      v123 += 136;
    }
    while (v124 < (int)(-1 - 252645135 * ((unint64_t)(a2[1] - *a2) >> 3)));
  }
  if (*(_DWORD *)(a6 + 168))
  {
    v129 = 17 * v124;
    v130 = (char *)v122 + 8 * v129;
    v131 = *((_OWORD *)v130 + 3);
    *v122 = *((_OWORD *)v130 + 2);
    v122[1] = v131;
    v132 = *a2;
    v133 = *a2 + 8 * v129;
    v134 = *(_OWORD *)(v133 + 80);
    *(_OWORD *)(v132 + 96) = *(_OWORD *)(v133 + 64);
    *(_OWORD *)(v132 + 112) = v134;
  }
  if (v145)
  {
    v146 = v145;
    operator delete(v145);
  }
}

void sub_1B3018D50(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 168);
  if (v3)
  {
    *(_QWORD *)(v1 - 160) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double *OZShape::transformOutlinePolygonList(uint64_t a1, uint64_t *a2, unsigned int a3, double *a4)
{
  uint64_t v4;
  uint64_t v7;
  unsigned int v8;
  double *result;

  v4 = *a2;
  if (0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3) > a3)
  {
    v7 = a3;
    v8 = a3 + 1;
    do
    {
      result = OZShapeEdgePolygon::transformPoints((double *)(v4 + 136 * v7), a4);
      v7 = v8;
      v4 = *a2;
    }
    while (0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 3) > v8++);
  }
  return result;
}

uint64_t *HGArray<__simd128_float32_t,(HGFormat)28>::reserve(uint64_t *result, int a2)
{
  if (*result)
  {
    if (*(_DWORD *)(*result + 12) < a2)
      return (uint64_t *)HGArrayData::allocate(*result, a2);
  }
  else if (a2 > 0)
  {
    return (uint64_t *)HGArrayDataRef::allocate((HGArrayDataRef *)result, 16, a2, a2);
  }
  return result;
}

void `anonymous namespace'::addTriangleStripSequenceToArray(_anonymous_namespace_ *this, OZShapeVertexArrayData *a2)
{
  int v2;
  uint64_t v4;
  int v5;
  unint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  _DWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  int v18;

  v2 = (int)a2;
  v4 = *((_QWORD *)this + 3);
  if (v4)
    LODWORD(v4) = *(_DWORD *)(v4 + 8);
  v5 = v4 - (_DWORD)a2;
  if ((int)v4 - (int)a2 >= 1)
  {
    v6 = *((_QWORD *)this + 2);
    v7 = (_DWORD *)*((_QWORD *)this + 1);
    if ((unint64_t)v7 >= v6)
    {
      v9 = *(_DWORD **)this;
      v10 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *(_QWORD *)this) >> 2);
      v11 = v10 + 1;
      if (v10 + 1 > 0x1555555555555555)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (_QWORD)v9) >> 2);
      if (2 * v12 > v11)
        v11 = 2 * v12;
      if (v12 >= 0xAAAAAAAAAAAAAAALL)
        v13 = 0x1555555555555555;
      else
        v13 = v11;
      if (v13)
      {
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Vec3f>>((uint64_t)this + 16, v13);
        v9 = *(_DWORD **)this;
        v7 = (_DWORD *)*((_QWORD *)this + 1);
      }
      else
      {
        v14 = 0;
      }
      v15 = &v14[12 * v10];
      v16 = &v14[12 * v13];
      *(_DWORD *)v15 = 5;
      *((_DWORD *)v15 + 1) = v2;
      *((_DWORD *)v15 + 2) = v5;
      v8 = v15 + 12;
      if (v7 != v9)
      {
        do
        {
          v17 = *(_QWORD *)(v7 - 3);
          v7 -= 3;
          v18 = v7[2];
          *(_QWORD *)(v15 - 12) = v17;
          v15 -= 12;
          *((_DWORD *)v15 + 2) = v18;
        }
        while (v7 != v9);
        v9 = *(_DWORD **)this;
      }
      *(_QWORD *)this = v15;
      *((_QWORD *)this + 1) = v8;
      *((_QWORD *)this + 2) = v16;
      if (v9)
        operator delete(v9);
    }
    else
    {
      *v7 = 5;
      v7[1] = (_DWORD)a2;
      v7[2] = v5;
      v8 = v7 + 3;
    }
    *((_QWORD *)this + 1) = v8;
  }
}

uint64_t *HGArray<__simd128_float32_t,(HGFormat)28>::resize(uint64_t *result, int a2)
{
  uint64_t v3;

  v3 = *result;
  if (*result)
  {
    if (*(_DWORD *)(v3 + 12) < a2)
      result = (uint64_t *)HGArrayData::allocate(*result, a2);
    *(_DWORD *)(v3 + 8) = a2;
  }
  else if (a2 > 0)
  {
    return (uint64_t *)HGArrayDataRef::allocate((HGArrayDataRef *)result, 16, a2, a2);
  }
  return result;
}

uint64_t HGArray<__simd128_float32_t,(HGFormat)28>::HGArray(uint64_t a1)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 28;
  HGArrayDataRef::allocate((HGArrayDataRef *)a1, 16, 0, 0);
  return a1;
}

void sub_1B30190F0(_Unwind_Exception *exception_object)
{
  uint64_t *v1;

  if (*v1)
    HGArrayData::Release(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<OZShapeEdgePolygon>::__insert_with_size[abi:ne180100]<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *__p;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;

  v5 = a2;
  if (a5 >= 1)
  {
    v7 = a3;
    v11 = a1[2];
    v9 = (uint64_t)(a1 + 2);
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if ((uint64_t)(0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v11 - v12) >> 3)) >= a5)
    {
      v20 = v12 - a2;
      if (a5 <= (uint64_t)(0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v12 - a2) >> 3)))
      {
        v21 = a3 + 136 * a5;
      }
      else
      {
        v21 = a3 + 8 * ((uint64_t)(v12 - a2) >> 3);
        std::vector<OZShapeEdgePolygon>::__construct_at_end<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>((uint64_t)a1, v21, a4);
        if (v20 < 1)
          return v5;
      }
      std::vector<OZShapeEdgePolygon>::__move_range((uint64_t)a1, v5, v12, v5 + 136 * a5);
      if (v21 != v7)
      {
        v22 = v5;
        do
        {
          *(_OWORD *)v22 = *(_OWORD *)v7;
          v23 = *(_OWORD *)(v7 + 16);
          v24 = *(_OWORD *)(v7 + 32);
          v25 = *(_OWORD *)(v7 + 64);
          *(_OWORD *)(v22 + 48) = *(_OWORD *)(v7 + 48);
          *(_OWORD *)(v22 + 64) = v25;
          *(_OWORD *)(v22 + 16) = v23;
          *(_OWORD *)(v22 + 32) = v24;
          v26 = *(_OWORD *)(v7 + 80);
          v27 = *(_OWORD *)(v7 + 96);
          v28 = *(_OWORD *)(v7 + 112);
          *(_QWORD *)(v22 + 128) = *(_QWORD *)(v7 + 128);
          *(_OWORD *)(v22 + 96) = v27;
          *(_OWORD *)(v22 + 112) = v28;
          *(_OWORD *)(v22 + 80) = v26;
          v7 += 136;
          v22 += 136;
        }
        while (v7 != v21);
      }
    }
    else
    {
      v13 = *a1;
      v14 = a5 - 0xF0F0F0F0F0F0F0FLL * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x1E1E1E1E1E1E1E1)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v15 = 0xF0F0F0F0F0F0F0F1 * ((a2 - v13) >> 3);
      v16 = 0xF0F0F0F0F0F0F0F1 * ((v10 - v13) >> 3);
      v17 = 2 * v16;
      if (2 * v16 <= v14)
        v17 = a5 - 0xF0F0F0F0F0F0F0FLL * ((uint64_t)(v12 - *a1) >> 3);
      if (v16 >= 0xF0F0F0F0F0F0F0)
        v18 = 0x1E1E1E1E1E1E1E1;
      else
        v18 = v17;
      v38 = v9;
      if (v18)
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v9, v18);
      else
        v19 = 0;
      v29 = (uint64_t)&v19[136 * v15];
      __p = v19;
      v35 = v29;
      v36 = v29;
      v37 = &v19[136 * v18];
      v30 = 17 * a5;
      v31 = v29 + 136 * a5;
      v32 = 8 * v30;
      do
      {
        std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v38, v29, v7);
        v29 += 136;
        v7 += 136;
        v32 -= 136;
      }
      while (v32);
      v36 = v31;
      v5 = std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p, v5);
      if (v36 != v35)
        v36 = (v36 - v35 - 136) % 0x88uLL + v35;
      if (__p)
        operator delete(__p);
    }
  }
  return v5;
}

void sub_1B3019344(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<OZShapeEdgePolygon>::__construct_at_end<std::__wrap_iter<OZShapeEdgePolygon*>,std::__wrap_iter<OZShapeEdgePolygon*>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v7;

  v4 = *(_QWORD *)(a1 + 8);
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(a1 + 16, v4 + v7, a2 + v7);
      v7 += 136;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(_QWORD *)(a1 + 8) = v4;
}

void sub_1B3019410(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

__n128 std::vector<OZShapeEdgePolygon>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v11;
  __n128 result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v7 = *(_QWORD *)(a1 + 8);
  v8 = v7 - a4;
  v9 = a2 + v7 - a4;
  if (v9 >= a3)
  {
    v11 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 8);
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(a1 + 16, v11, v9);
      v9 += 136;
      v11 += 136;
    }
    while (v9 < a3);
  }
  *(_QWORD *)(a1 + 8) = v11;
  if (v7 != a4)
  {
    v13 = v7 - 136;
    v14 = 8 * (v8 >> 3);
    v15 = a2 - 136;
    do
    {
      *(_OWORD *)v13 = *(_OWORD *)(v15 + v14);
      v16 = *(_OWORD *)(v15 + v14 + 16);
      v17 = *(_OWORD *)(v15 + v14 + 32);
      v18 = *(_OWORD *)(v15 + v14 + 64);
      *(_OWORD *)(v13 + 48) = *(_OWORD *)(v15 + v14 + 48);
      *(_OWORD *)(v13 + 64) = v18;
      *(_OWORD *)(v13 + 16) = v16;
      *(_OWORD *)(v13 + 32) = v17;
      result = *(__n128 *)(v15 + v14 + 80);
      v19 = *(_OWORD *)(v15 + v14 + 96);
      v20 = *(_OWORD *)(v15 + v14 + 112);
      *(_QWORD *)(v13 + 128) = *(_QWORD *)(v15 + v14 + 128);
      *(_OWORD *)(v13 + 96) = v19;
      *(_OWORD *)(v13 + 112) = v20;
      *(__n128 *)(v13 + 80) = result;
      v13 -= 136;
      v14 -= 136;
    }
    while (v14);
  }
  return result;
}

void sub_1B3019510(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = a3;
  v6 = a2[1];
  v7 = (uint64_t)(a1 + 2);
  v8 = *a1;
  v9 = v6;
  if (*a1 != a3)
  {
    v10 = a3;
    v9 = a2[1];
    do
    {
      v9 -= 136;
      v10 -= 136;
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v7, v9, v10);
    }
    while (v10 != v8);
  }
  a2[1] = v9;
  v11 = a1[1];
  v12 = a2[2];
  if (v11 != v3)
  {
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v7, v12, v3);
      v3 += 136;
      v12 += 136;
    }
    while (v3 != v11);
    v9 = a2[1];
  }
  a2[2] = v12;
  v13 = *a1;
  *a1 = v9;
  a2[1] = v13;
  v14 = a1[1];
  a1[1] = a2[2];
  a2[2] = v14;
  v15 = a1[2];
  a1[2] = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return v6;
}

void std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  _OWORD *v4;

  for (i = 0; i != 128; i += 32)
  {
    v4 = (_OWORD *)(a2 + i);
    *v4 = *(_OWORD *)(a3 + i);
    v4[1] = *(_OWORD *)(a3 + i + 16);
  }
  *(_QWORD *)(a2 + 128) = *(_QWORD *)(a3 + 128);
}

uint64_t std::vector<OZShapeEdgePolygon>::__push_back_slow_path<OZShapeEdgePolygon const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *__p;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0xF0F0F0F0F0F0F0F1 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0x1E1E1E1E1E1E1E1)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  if (0xE1E1E1E1E1E1E1E2 * ((a1[2] - *a1) >> 3) > v4)
    v4 = 0xE1E1E1E1E1E1E1E2 * ((a1[2] - *a1) >> 3);
  if (0xF0F0F0F0F0F0F0F1 * ((a1[2] - *a1) >> 3) >= 0xF0F0F0F0F0F0F0)
    v6 = 0x1E1E1E1E1E1E1E1;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  __p = v7;
  v11 = &v7[136 * v3];
  v13 = &v7[136 * v6];
  std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 136;
  std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(a1, &__p);
  v8 = a1[1];
  if (v12 != v11)
    v12 = &v11[(v12 - v11 - 136) % 0x88uLL];
  if (__p)
    operator delete(__p);
  return v8;
}

void sub_1B301976C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<OZShapeEdgePolygon>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = a2[1];
  if (v4 != *a1)
  {
    do
    {
      v6 -= 136;
      v4 -= 136;
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)(a1 + 2), v6, v4);
    }
    while (v4 != v5);
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void std::__split_buffer<OZShapeEdgePolygon>::push_back[abi:ne180100](void **a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  void *v6;
  int64_t v7;
  uint64_t v8;
  char *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;

  v4 = (uint64_t)a1[2];
  if ((void *)v4 == a1[3])
  {
    v6 = *a1;
    v5 = (char *)a1[1];
    if (v5 <= *a1)
    {
      if ((void *)v4 == v6)
        v17 = 1;
      else
        v17 = 0xE1E1E1E1E1E1E1E2 * ((v4 - (uint64_t)v6) >> 3);
      v18 = v17 >> 2;
      v19 = (uint64_t)a1[4];
      v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>(v19, v17);
      v22 = v21;
      v23 = &v20[136 * v18];
      v24 = (uint64_t)a1[1];
      v4 = (uint64_t)v23;
      v25 = (uint64_t)a1[2] - v24;
      if (v25)
      {
        v26 = v25 / 136;
        v4 = (uint64_t)&v23[136 * v26];
        v27 = 136 * v26;
        v28 = (uint64_t)v23;
        do
        {
          std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(v19, v28, v24);
          v28 += 136;
          v24 += 136;
          v27 -= 136;
        }
        while (v27);
      }
      v29 = *a1;
      *a1 = v20;
      a1[1] = v23;
      a1[2] = (void *)v4;
      a1[3] = &v20[136 * v22];
      if (v29)
      {
        operator delete(v29);
        v4 = (uint64_t)a1[2];
      }
    }
    else
    {
      v7 = 0xF0F0F0F0F0F0F0F1 * ((v5 - (_BYTE *)*a1) >> 3);
      v8 = v7 + 2;
      if (v7 >= -1)
        v8 = v7 + 1;
      if (v5 == (char *)v4)
      {
        v16 = (uint64_t)&v5[-136 * (v8 >> 1)];
      }
      else
      {
        do
        {
          v9 = &v5[-136 * (v8 >> 1)];
          *(_OWORD *)v9 = *(_OWORD *)v5;
          v10 = *((_OWORD *)v5 + 1);
          v11 = *((_OWORD *)v5 + 2);
          v12 = *((_OWORD *)v5 + 4);
          *((_OWORD *)v9 + 3) = *((_OWORD *)v5 + 3);
          *((_OWORD *)v9 + 4) = v12;
          *((_OWORD *)v9 + 1) = v10;
          *((_OWORD *)v9 + 2) = v11;
          v13 = *((_OWORD *)v5 + 5);
          v14 = *((_OWORD *)v5 + 6);
          v15 = *((_OWORD *)v5 + 7);
          *((_QWORD *)v9 + 16) = *((_QWORD *)v5 + 16);
          *((_OWORD *)v9 + 6) = v14;
          *((_OWORD *)v9 + 7) = v15;
          *((_OWORD *)v9 + 5) = v13;
          v5 += 136;
        }
        while (v5 != (char *)v4);
        v4 = (uint64_t)a1[1];
        v16 = (uint64_t)&v5[-136 * (v8 >> 1)];
      }
      a1[1] = (void *)(v4 - 136 * (v8 >> 1));
      a1[2] = (void *)v16;
      v4 = v16;
    }
  }
  std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>((uint64_t)a1[4], v4, a2);
  a1[2] = (char *)a1[2] + 136;
}

void sub_1B3019A18(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

double *OZShapeEdgePolygon::transformPoints(double *a1, double *a2)
{
  PCMatrix44Tmpl<double>::transform<double>(a2, a1, a1);
  PCMatrix44Tmpl<double>::transform<double>(a2, a1 + 4, a1 + 4);
  PCMatrix44Tmpl<double>::transform<double>(a2, a1 + 8, a1 + 8);
  return PCMatrix44Tmpl<double>::transform<double>(a2, a1 + 12, a1 + 12);
}

BOOL OZShapeEdgePolygon::isValid(OZShapeEdgePolygon *this)
{
  return vabdd_f64(*((double *)this + 8), *((double *)this + 12)) >= 0.0000001
      || vabdd_f64(*((double *)this + 9), *((double *)this + 13)) >= 0.0000001
      || vabdd_f64(*((double *)this + 10), *((double *)this + 14)) >= 0.0000001
      || vabdd_f64(*((double *)this + 11), *((double *)this + 15)) >= 0.0000001
      || vabdd_f64(*(double *)this, *((double *)this + 4)) >= 0.0000001
      || vabdd_f64(*((double *)this + 1), *((double *)this + 5)) >= 0.0000001
      || vabdd_f64(*((double *)this + 2), *((double *)this + 6)) >= 0.0000001
      || vabdd_f64(*((double *)this + 3), *((double *)this + 7)) >= 0.0000001;
}

BOOL OZShapeEdgePolygon::checkWindingOrder(OZShapeEdgePolygon *this)
{
  uint64_t v1;
  OZShapeEdgePolygon *v2;
  double v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  const double *v10;
  const double *v11;
  int8x16_t v12;
  const double *v13;
  const double *v14;
  int8x16_t v15;
  double v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  _BYTE v21[32];
  uint64_t v22;
  _BYTE v23[32];
  uint64_t v24;
  _BYTE v25[32];
  uint64_t v26;
  uint64_t v27;

  v1 = 0;
  v27 = *MEMORY[0x1E0C80C00];
  v2 = this;
  do
  {
    v3 = *((double *)v2 + 3);
    if (v3 <= 0.0)
      return 1;
    v4 = *(_QWORD *)v2;
    v5 = *((_QWORD *)v2 + 1);
    v2 = (OZShapeEdgePolygon *)((char *)v2 + 32);
    *(_QWORD *)&v25[v1] = v4;
    *(_QWORD *)&v23[v1] = v5;
    *(double *)&v21[v1] = v3;
    v1 += 8;
  }
  while (v1 != 32);
  v6 = 0;
  v7 = *((_QWORD *)this + 1);
  v26 = *(_QWORD *)this;
  v24 = v7;
  v22 = *((_QWORD *)this + 3);
  do
  {
    v8 = *(double *)&v21[v6];
    if (vabdd_f64(0.0, v8) >= 0.0000001)
    {
      *(double *)&v25[v6] = *(double *)&v25[v6] / v8;
      *(double *)&v23[v6] = *(double *)&v23[v6] / v8;
    }
    v6 += 8;
  }
  while (v6 != 40);
  v9 = 0;
  v10 = (const double *)v23;
  v12 = (int8x16_t)vld1q_dup_f64(v10);
  v11 = v10 + 1;
  v13 = (const double *)v25;
  v15 = (int8x16_t)vld1q_dup_f64(v13);
  v14 = v13 + 1;
  v16 = 0.0;
  do
  {
    v17 = *(float64x2_t *)&v11[v9];
    v18 = *(float64x2_t *)&v14[v9];
    v19 = vsubq_f64(vmulq_f64((float64x2_t)vextq_s8(v15, (int8x16_t)v18, 8uLL), v17), vmulq_f64(v18, (float64x2_t)vextq_s8(v12, (int8x16_t)v17, 8uLL)));
    v16 = v16 + v19.f64[0] + v19.f64[1];
    v9 += 2;
    v12 = (int8x16_t)v17;
    v15 = (int8x16_t)v18;
  }
  while (v9 != 4);
  return v16 > 0.0;
}

void OZShapeRenderParams::OZShapeRenderParams(OZShapeRenderParams *this)
{
  uint64_t v2;
  __int128 v8;
  __int128 *v10;
  __int128 v11;
  __int128 v12;

  *(_QWORD *)this = &off_1E65EA850;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  PCWorkingColorVector::PCWorkingColorVector((OZShapeRenderParams *)((char *)this + 280));
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_QWORD *)this + 45) = 0;
  *((_QWORD *)this + 50) = 0;
  *((_QWORD *)this + 51) = 0xBFF0000000000000;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  v2 = MEMORY[0x1E0CA2E68];
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((_QWORD *)this + 48) = *(_QWORD *)(v2 + 16);
  *((_QWORD *)this + 49) = 0;
  *((_OWORD *)this + 23) = *(_OWORD *)v2;
  *((_QWORD *)this + 68) = 0x3FF0000000000000;
  *((_QWORD *)this + 63) = 0x3FF0000000000000;
  *((_QWORD *)this + 58) = 0x3FF0000000000000;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 26) = xmmword_1B304F7C0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_DWORD *)this + 138) = 0x1000000;
  *((_QWORD *)this + 94) = 0;
  *((_QWORD *)this + 98) = 0;
  *((_QWORD *)this + 99) = 0;
  __asm { FMOV            V2.2D, #-1.0 }
  *((_OWORD *)this + 50) = _Q2;
  *(_OWORD *)((char *)this + 952) = 0u;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *(_OWORD *)((char *)this + 1064) = 0u;
  *(_OWORD *)((char *)this + 1080) = 0u;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *(_OWORD *)((char *)this + 1128) = 0u;
  *(_OWORD *)((char *)this + 760) = *(_OWORD *)v2;
  *((_QWORD *)this + 97) = *(_QWORD *)(v2 + 16);
  *((_QWORD *)this + 117) = 0x3FF0000000000000;
  *((_QWORD *)this + 112) = 0x3FF0000000000000;
  *((_QWORD *)this + 107) = 0x3FF0000000000000;
  *((_QWORD *)this + 102) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 920) = 0u;
  *((_DWORD *)this + 236) = 0x1000000;
  *((_QWORD *)this + 165) = 0x3FF0000000000000;
  *((_QWORD *)this + 160) = 0x3FF0000000000000;
  *((_QWORD *)this + 155) = 0x3FF0000000000000;
  *((_QWORD *)this + 150) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1208) = 0u;
  *(_OWORD *)((char *)this + 1224) = 0u;
  *((_OWORD *)this + 78) = 0u;
  *((_OWORD *)this + 79) = 0u;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *((_DWORD *)this + 2) = -1;
  *((_QWORD *)this + 2) = 0xC08F400000000000;
  *(_OWORD *)((char *)this + 72) = xmmword_1B304EEE0;
  *((_BYTE *)this + 112) = 0;
  *(_QWORD *)&v8 = -1;
  *((_QWORD *)&v8 + 1) = -1;
  *(_QWORD *)((char *)this + 116) = -1;
  *((_QWORD *)this + 21) = 0xFFFFFFFF00000000;
  *((int64x2_t *)this + 14) = vdupq_n_s64(0xC08F400000000000);
  *(_OWORD *)((char *)this + 24) = v8;
  *((_QWORD *)this + 24) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)((char *)this + 40) = _Q0;
  *(_OWORD *)((char *)this + 56) = _Q0;
  *((_OWORD *)this + 8) = _Q0;
  *((_OWORD *)this + 9) = _Q0;
  *(_OWORD *)((char *)this + 88) = xmmword_1B305A270;
  *((_QWORD *)this + 13) = 0xBFF0000000000000;
  *((_QWORD *)this + 20) = 0x3FF0000000000000;
  *((_DWORD *)this + 31) = -1;
  v10 = (__int128 *)MEMORY[0x1E0CA2E28];
  v11 = *MEMORY[0x1E0CA2E28];
  *((_QWORD *)this + 145) = *(_QWORD *)(MEMORY[0x1E0CA2E28] + 16);
  *(_OWORD *)((char *)this + 1144) = v11;
  v12 = *v10;
  *((_QWORD *)this + 148) = *((_QWORD *)v10 + 2);
  *((_OWORD *)this + 73) = v12;
  *(_OWORD *)((char *)this + 248) = _Q0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_WORD *)this + 120) = 0;
  *((_WORD *)this + 6) = 0;
  *((_DWORD *)this + 298) = 16843009;
  *((_BYTE *)this + 176) = 1;
  *(_QWORD *)((char *)this + 180) = 0x100000000;
  *((_BYTE *)this + 216) = 0;
  *((_BYTE *)this + 242) = 0;
}

void OZShapeRenderParams::OZShapeRenderParams(OZShapeRenderParams *this, OZShapeRenderParams *a2, int a3)
{
  uint64_t v6;
  char *v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t i;
  const OZShapeReparametrizedContour *v20;
  OZShapeReparametrizedContour *v21;

  *(_QWORD *)this = &off_1E65EA850;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  PCWorkingColorVector::PCWorkingColorVector((OZShapeRenderParams *)((char *)this + 280));
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_QWORD *)this + 45) = 0;
  *((_QWORD *)this + 50) = 0;
  *((_QWORD *)this + 51) = 0xBFF0000000000000;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  v6 = MEMORY[0x1E0CA2E68];
  *((_QWORD *)this + 48) = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  *((_QWORD *)this + 49) = 0;
  *((_OWORD *)this + 23) = *(_OWORD *)v6;
  *((_QWORD *)this + 68) = 0x3FF0000000000000;
  *((_QWORD *)this + 63) = 0x3FF0000000000000;
  *((_QWORD *)this + 58) = 0x3FF0000000000000;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 26) = xmmword_1B304F7C0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_DWORD *)this + 138) = 0x1000000;
  *((_QWORD *)this + 94) = 0;
  *((_QWORD *)this + 98) = 0;
  *((_QWORD *)this + 99) = 0;
  __asm { FMOV            V2.2D, #-1.0 }
  *((_OWORD *)this + 50) = _Q2;
  *(_OWORD *)((char *)this + 952) = 0u;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *(_OWORD *)((char *)this + 1064) = 0u;
  *(_OWORD *)((char *)this + 1080) = 0u;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *(_OWORD *)((char *)this + 1128) = 0u;
  *(_OWORD *)((char *)this + 760) = *(_OWORD *)v6;
  *((_QWORD *)this + 97) = *(_QWORD *)(v6 + 16);
  *((_QWORD *)this + 117) = 0x3FF0000000000000;
  *((_QWORD *)this + 112) = 0x3FF0000000000000;
  *((_QWORD *)this + 107) = 0x3FF0000000000000;
  *((_QWORD *)this + 102) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 920) = 0u;
  *((_DWORD *)this + 236) = 0x1000000;
  v12 = (char *)this + 1200;
  *((_QWORD *)this + 165) = 0x3FF0000000000000;
  *((_QWORD *)this + 160) = 0x3FF0000000000000;
  *((_QWORD *)this + 155) = 0x3FF0000000000000;
  *((_QWORD *)this + 150) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1208) = 0u;
  *(_OWORD *)((char *)this + 1224) = 0u;
  *((_OWORD *)this + 78) = 0u;
  *((_OWORD *)this + 79) = 0u;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_BYTE *)this + 13) = *((_BYTE *)a2 + 13);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  *((_QWORD *)this + 11) = *((_QWORD *)a2 + 11);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *((_BYTE *)this + 112) = *((_BYTE *)a2 + 112);
  *(_QWORD *)((char *)this + 116) = *(_QWORD *)((char *)a2 + 116);
  *((_QWORD *)this + 21) = *((_QWORD *)a2 + 21);
  *((_OWORD *)this + 14) = *((_OWORD *)a2 + 14);
  *((_QWORD *)this + 24) = *((_QWORD *)a2 + 24);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)a2 + 200);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *((_QWORD *)this + 8) = *((_QWORD *)a2 + 8);
  *((_QWORD *)this + 16) = *((_QWORD *)a2 + 16);
  *((_QWORD *)this + 17) = *((_QWORD *)a2 + 17);
  *((_QWORD *)this + 18) = *((_QWORD *)a2 + 18);
  *((_QWORD *)this + 19) = *((_QWORD *)a2 + 19);
  *((_DWORD *)this + 31) = *((_DWORD *)a2 + 31);
  *v13 = *(_OWORD *)((char *)a2 + 280);
  *(_WORD *)((char *)this + 1193) = *(_WORD *)((char *)a2 + 1193);
  v14 = *(_OWORD *)((char *)a2 + 1144);
  *((_QWORD *)this + 145) = *((_QWORD *)a2 + 145);
  *(_OWORD *)((char *)this + 1144) = v14;
  v15 = *((_OWORD *)a2 + 73);
  *((_QWORD *)this + 148) = *((_QWORD *)a2 + 148);
  *((_OWORD *)this + 73) = v15;
  *(_OWORD *)((char *)this + 248) = *(_OWORD *)((char *)a2 + 248);
  v16 = *((_QWORD *)a2 + 34);
  *((_QWORD *)this + 33) = *((_QWORD *)a2 + 33);
  *((_QWORD *)this + 34) = v16;
  *((_BYTE *)this + 1192) = 1;
  *((_BYTE *)this + 241) = *((_BYTE *)a2 + 241);
  *((_QWORD *)this + 20) = *((_QWORD *)a2 + 20);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_BYTE *)this + 12) = *((_BYTE *)a2 + 12);
  *((_BYTE *)this + 176) = *((_BYTE *)a2 + 176);
  *((_BYTE *)this + 240) = *((_BYTE *)a2 + 240);
  *(_QWORD *)((char *)this + 180) = *(_QWORD *)((char *)a2 + 180);
  *((_BYTE *)this + 216) = *((_BYTE *)a2 + 216);
  if (a2 != this)
  {
    v17 = 0;
    v18 = (char *)a2 + 1200;
    do
    {
      for (i = 0; i != 32; i += 8)
        *(_QWORD *)&v12[i] = *(_QWORD *)&v18[i];
      ++v17;
      v12 += 32;
      v18 += 32;
    }
    while (v17 != 4);
  }
  *((_BYTE *)this + 242) = *((_BYTE *)a2 + 242);
  if (a3)
  {
    OZShapeContour::operator=((uint64_t)this + 368, (__int128 *)a2 + 23);
    v20 = (const OZShapeReparametrizedContour *)*((_QWORD *)a2 + 94);
    if (v20)
    {
      v21 = (OZShapeReparametrizedContour *)operator new();
      OZShapeReparametrizedContour::OZShapeReparametrizedContour(v21, v20);
      std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100]((OZShapeReparametrizedContour **)this + 94, v21);
    }
    OZShapeContour::operator=((uint64_t)this + 760, (__int128 *)((char *)a2 + 760));
  }
}

void sub_1B301A1EC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  OZShapeContour *v2;
  OZShapeContour *v3;
  OZShapeReparametrizedContour **v4;
  uint64_t v5;
  void **v6;
  void *v8;
  void *v9;
  void *v10;

  MEMORY[0x1B5E29170](v5, 0x10A0C401050895ELL);
  OZShapeContour::~OZShapeContour(v3);
  std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100](v4, 0);
  OZShapeContour::~OZShapeContour(v2);
  v8 = (void *)v1[43];
  if (v8)
  {
    v1[44] = v8;
    operator delete(v8);
  }
  v9 = (void *)v1[40];
  if (v9)
  {
    v1[41] = v9;
    operator delete(v9);
  }
  v10 = *v6;
  if (*v6)
  {
    v1[38] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(a1);
}

void OZShapeContour::operator=(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;

  *(_WORD *)(a1 + 185) = *(_WORD *)((char *)a2 + 185);
  *(_BYTE *)(a1 + 187) = *((_BYTE *)a2 + 187);
  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  v5 = *(__int128 *)((char *)a2 + 24);
  *(_OWORD *)(a1 + 40) = *(__int128 *)((char *)a2 + 40);
  *(_OWORD *)(a1 + 24) = v5;
  if (a2 == (__int128 *)a1)
  {
    *(_BYTE *)(a1 + 184) = *((_BYTE *)a2 + 184);
  }
  else
  {
    v6 = 0;
    v7 = (uint64_t)a2 + 56;
    v8 = a1 + 56;
    do
    {
      for (i = 0; i != 32; i += 8)
        *(_QWORD *)(v8 + i) = *(_QWORD *)(v7 + i);
      ++v6;
      v8 += 32;
      v7 += 32;
    }
    while (v6 != 4);
    *(_BYTE *)(a1 + 184) = *((_BYTE *)a2 + 184);
    if (a2 != (__int128 *)a1)
    {
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 192), *((char **)a2 + 24), *((_QWORD *)a2 + 25), (uint64_t)(*((_QWORD *)a2 + 25) - *((_QWORD *)a2 + 24)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 216), *((char **)a2 + 27), *((_QWORD *)a2 + 28), (uint64_t)(*((_QWORD *)a2 + 28) - *((_QWORD *)a2 + 27)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 240), *((char **)a2 + 30), *((_QWORD *)a2 + 31), (uint64_t)(*((_QWORD *)a2 + 31) - *((_QWORD *)a2 + 30)) >> 3);
      std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>((_QWORD *)(a1 + 264), *((__int128 **)a2 + 33), *((__int128 **)a2 + 34), (uint64_t)(*((_QWORD *)a2 + 34) - *((_QWORD *)a2 + 33)) >> 4);
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 288), *((_QWORD *)a2 + 36), *((_QWORD *)a2 + 37), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 37) - *((_QWORD *)a2 + 36)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 312), *((_QWORD *)a2 + 39), *((_QWORD *)a2 + 40), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 40) - *((_QWORD *)a2 + 39)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 336), *((_QWORD *)a2 + 42), *((_QWORD *)a2 + 43), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 43) - *((_QWORD *)a2 + 42)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)(a1 + 360), *((_QWORD *)a2 + 45), *((_QWORD *)a2 + 46), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 46) - *((_QWORD *)a2 + 45)) >> 3));
    }
  }
}

void OZShapeRenderParams::assign(OZShapeRenderParams *this, OZShapeRenderParams *a2, int a3)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t i;
  const OZShapeReparametrizedContour *v12;
  OZShapeReparametrizedContour *v13;

  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_BYTE *)this + 13) = *((_BYTE *)a2 + 13);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  *((_QWORD *)this + 11) = *((_QWORD *)a2 + 11);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *((_BYTE *)this + 112) = *((_BYTE *)a2 + 112);
  *(_QWORD *)((char *)this + 116) = *(_QWORD *)((char *)a2 + 116);
  *((_QWORD *)this + 21) = *((_QWORD *)a2 + 21);
  *((_OWORD *)this + 14) = *((_OWORD *)a2 + 14);
  *((_QWORD *)this + 24) = *((_QWORD *)a2 + 24);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)a2 + 200);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *((_QWORD *)this + 8) = *((_QWORD *)a2 + 8);
  *((_QWORD *)this + 16) = *((_QWORD *)a2 + 16);
  *((_QWORD *)this + 17) = *((_QWORD *)a2 + 17);
  *((_QWORD *)this + 18) = *((_QWORD *)a2 + 18);
  *((_QWORD *)this + 19) = *((_QWORD *)a2 + 19);
  *((_DWORD *)this + 31) = *((_DWORD *)a2 + 31);
  *(_OWORD *)((char *)this + 280) = *(_OWORD *)((char *)a2 + 280);
  *(_WORD *)((char *)this + 1193) = *(_WORD *)((char *)a2 + 1193);
  v5 = *(_OWORD *)((char *)a2 + 1144);
  *((_QWORD *)this + 145) = *((_QWORD *)a2 + 145);
  *(_OWORD *)((char *)this + 1144) = v5;
  v6 = *((_OWORD *)a2 + 73);
  *((_QWORD *)this + 148) = *((_QWORD *)a2 + 148);
  *((_OWORD *)this + 73) = v6;
  *(_OWORD *)((char *)this + 248) = *(_OWORD *)((char *)a2 + 248);
  v7 = *((_QWORD *)a2 + 34);
  *((_QWORD *)this + 33) = *((_QWORD *)a2 + 33);
  *((_QWORD *)this + 34) = v7;
  *((_BYTE *)this + 1192) = *((_BYTE *)a2 + 1192);
  *((_BYTE *)this + 241) = *((_BYTE *)a2 + 241);
  *((_QWORD *)this + 20) = *((_QWORD *)a2 + 20);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_BYTE *)this + 12) = *((_BYTE *)a2 + 12);
  *((_BYTE *)this + 1195) = *((_BYTE *)a2 + 1195);
  *((_BYTE *)this + 176) = *((_BYTE *)a2 + 176);
  *((_BYTE *)this + 240) = *((_BYTE *)a2 + 240);
  *(_QWORD *)((char *)this + 180) = *(_QWORD *)((char *)a2 + 180);
  *((_BYTE *)this + 216) = *((_BYTE *)a2 + 216);
  if (a2 != this)
  {
    v8 = 0;
    v9 = (char *)a2 + 1200;
    v10 = (char *)this + 1200;
    do
    {
      for (i = 0; i != 32; i += 8)
        *(_QWORD *)&v10[i] = *(_QWORD *)&v9[i];
      ++v8;
      v10 += 32;
      v9 += 32;
    }
    while (v8 != 4);
  }
  *((_BYTE *)this + 242) = *((_BYTE *)a2 + 242);
  if (a3)
  {
    OZShapeContour::operator=((uint64_t)this + 368, (__int128 *)a2 + 23);
    v12 = (const OZShapeReparametrizedContour *)*((_QWORD *)a2 + 94);
    if (v12)
    {
      v13 = (OZShapeReparametrizedContour *)operator new();
      OZShapeReparametrizedContour::OZShapeReparametrizedContour(v13, v12);
      std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100]((OZShapeReparametrizedContour **)this + 94, v13);
    }
    OZShapeContour::operator=((uint64_t)this + 760, (__int128 *)((char *)a2 + 760));
  }
}

void sub_1B301A600(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A0C401050895ELL);
  _Unwind_Resume(a1);
}

void OZShapeRenderParams::~OZShapeRenderParams(OZShapeReparametrizedContour **this)
{
  OZShapeReparametrizedContour *v2;
  OZShapeReparametrizedContour *v3;
  OZShapeReparametrizedContour *v4;

  *this = (OZShapeReparametrizedContour *)&off_1E65EA850;
  OZShapeContour::~OZShapeContour((OZShapeContour *)(this + 95));
  std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100](this + 94, 0);
  OZShapeContour::~OZShapeContour((OZShapeContour *)(this + 46));
  v2 = this[43];
  if (v2)
  {
    this[44] = v2;
    operator delete(v2);
  }
  v3 = this[40];
  if (v3)
  {
    this[41] = v3;
    operator delete(v3);
  }
  v4 = this[37];
  if (v4)
  {
    this[38] = v4;
    operator delete(v4);
  }
}

{
  OZShapeRenderParams::~OZShapeRenderParams(this);
  JUMPOUT(0x1B5E29170);
}

void OZShapeRenderParams::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  const OZShapeReparametrizedContour *v12;
  OZShapeReparametrizedContour *v13;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 13) = *(_BYTE *)(a2 + 13);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
  *(_QWORD *)(a1 + 116) = *(_QWORD *)(a2 + 116);
  *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 280) = *(_OWORD *)(a2 + 280);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(a2 + 124);
  *(_QWORD *)(a1 + 180) = *(_QWORD *)(a2 + 180);
  *(_BYTE *)(a1 + 216) = *(_BYTE *)(a2 + 216);
  *(_WORD *)(a1 + 1193) = *(_WORD *)(a2 + 1193);
  v4 = *(_OWORD *)(a2 + 1144);
  *(_QWORD *)(a1 + 1160) = *(_QWORD *)(a2 + 1160);
  *(_OWORD *)(a1 + 1144) = v4;
  v5 = *(_OWORD *)(a2 + 1168);
  *(_QWORD *)(a1 + 1184) = *(_QWORD *)(a2 + 1184);
  *(_OWORD *)(a1 + 1168) = v5;
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  v6 = *(_QWORD *)(a2 + 272);
  *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
  *(_QWORD *)(a1 + 272) = v6;
  *(_BYTE *)(a1 + 1192) = *(_BYTE *)(a2 + 1192);
  *(_BYTE *)(a1 + 1195) = *(_BYTE *)(a2 + 1195);
  *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
  *(_WORD *)(a1 + 240) = *(_WORD *)(a2 + 240);
  v7 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 104) = v7;
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(a2 + 12);
  if (a2 != a1)
  {
    v8 = 0;
    v9 = a2 + 1200;
    v10 = a1 + 1200;
    do
    {
      for (i = 0; i != 32; i += 8)
        *(_QWORD *)(v10 + i) = *(_QWORD *)(v9 + i);
      ++v8;
      v10 += 32;
      v9 += 32;
    }
    while (v8 != 4);
  }
  OZShapeContour::operator=(a1 + 368, (__int128 *)(a2 + 368));
  *(_BYTE *)(a1 + 242) = *(_BYTE *)(a2 + 242);
  v12 = *(const OZShapeReparametrizedContour **)(a2 + 752);
  if (v12)
  {
    v13 = (OZShapeReparametrizedContour *)operator new();
    OZShapeReparametrizedContour::OZShapeReparametrizedContour(v13, v12);
    std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100]((OZShapeReparametrizedContour **)(a1 + 752), v13);
  }
  OZShapeContour::operator=(a1 + 760, (__int128 *)(a2 + 760));
  if (a2 != a1)
  {
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 296), *(char **)(a2 + 296), *(_QWORD *)(a2 + 304), (uint64_t)(*(_QWORD *)(a2 + 304) - *(_QWORD *)(a2 + 296)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 320), *(char **)(a2 + 320), *(_QWORD *)(a2 + 328), (uint64_t)(*(_QWORD *)(a2 + 328) - *(_QWORD *)(a2 + 320)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a1 + 344), *(char **)(a2 + 344), *(_QWORD *)(a2 + 352), (uint64_t)(*(_QWORD *)(a2 + 352) - *(_QWORD *)(a2 + 344)) >> 3);
  }
}

void sub_1B301A91C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A0C401050895ELL);
  _Unwind_Resume(a1);
}

void std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>(char **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _OWORD *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;

  v5 = a3;
  v6 = a2;
  v8 = (uint64_t)a1[2];
  v9 = *a1;
  if (0xF0F0F0F0F0F0F0F1 * ((v8 - (uint64_t)v9) >> 3) < a4)
  {
    if (v9)
    {
      a1[1] = v9;
      operator delete(v9);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x1E1E1E1E1E1E1E1)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = 0xF0F0F0F0F0F0F0F1 * (v8 >> 3);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    if (v10 >= 0xF0F0F0F0F0F0F0)
      v12 = 0x1E1E1E1E1E1E1E1;
    else
      v12 = v11;
    std::vector<OZShapeEdgePolygon>::__vallocate[abi:ne180100](a1, v12);
    v13 = (uint64_t)a1;
    v14 = v6;
    a3 = v5;
LABEL_21:
    std::vector<OZShapeEdgePolygon>::__construct_at_end<OZShapeEdgePolygon*,OZShapeEdgePolygon*>(v13, v14, a3);
    return;
  }
  v15 = a1[1];
  if (0xF0F0F0F0F0F0F0F1 * ((v15 - v9) >> 3) < a4)
  {
    v14 = a2 + 8 * ((v15 - v9) >> 3);
    if (v15 != v9)
    {
      v16 = 8 * ((v15 - v9) >> 3);
      do
      {
        *(_OWORD *)v9 = *(_OWORD *)v6;
        v17 = *(_OWORD *)(v6 + 16);
        v18 = *(_OWORD *)(v6 + 32);
        v19 = *(_OWORD *)(v6 + 64);
        *((_OWORD *)v9 + 3) = *(_OWORD *)(v6 + 48);
        *((_OWORD *)v9 + 4) = v19;
        *((_OWORD *)v9 + 1) = v17;
        *((_OWORD *)v9 + 2) = v18;
        v20 = *(_OWORD *)(v6 + 80);
        v21 = *(_OWORD *)(v6 + 96);
        v22 = *(_OWORD *)(v6 + 112);
        *((_QWORD *)v9 + 16) = *(_QWORD *)(v6 + 128);
        *((_OWORD *)v9 + 6) = v21;
        *((_OWORD *)v9 + 7) = v22;
        *((_OWORD *)v9 + 5) = v20;
        v6 += 136;
        v9 += 136;
        v16 -= 136;
      }
      while (v16);
    }
    v13 = (uint64_t)a1;
    goto LABEL_21;
  }
  if (a2 == a3)
  {
    v23 = v9;
  }
  else
  {
    v23 = v9;
    do
    {
      *(_OWORD *)v9 = *(_OWORD *)v6;
      v24 = *(_OWORD *)(v6 + 16);
      v25 = *(_OWORD *)(v6 + 32);
      v26 = *(_OWORD *)(v6 + 64);
      *((_OWORD *)v9 + 3) = *(_OWORD *)(v6 + 48);
      *((_OWORD *)v9 + 4) = v26;
      *((_OWORD *)v9 + 1) = v24;
      *((_OWORD *)v9 + 2) = v25;
      v27 = *(_OWORD *)(v6 + 80);
      v28 = *(_OWORD *)(v6 + 96);
      v29 = *(_OWORD *)(v6 + 112);
      *((_QWORD *)v9 + 16) = *(_QWORD *)(v6 + 128);
      *((_OWORD *)v9 + 6) = v28;
      *((_OWORD *)v9 + 7) = v29;
      *((_OWORD *)v9 + 5) = v27;
      v6 += 136;
      v9 += 136;
      v23 = (_OWORD *)((char *)v23 + 136);
    }
    while (v6 != a3);
  }
  a1[1] = (char *)v23;
}

void std::vector<OZShapeEdgePolygon>::__construct_at_end<OZShapeEdgePolygon*,OZShapeEdgePolygon*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v7;

  v4 = *(_QWORD *)(a1 + 8);
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      std::allocator<OZShapeEdgePolygon>::construct[abi:ne180100]<OZShapeEdgePolygon,OZShapeEdgePolygon&>(a1 + 16, v4 + v7, a2 + v7);
      v7 += 136;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(_QWORD *)(a1 + 8) = v4;
}

void sub_1B301AB7C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *std::vector<OZShapeEdgePolygon>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x1E1E1E1E1E1E1E2)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LightingStyleLight>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[136 * v4];
  return result;
}

OZShapeReparametrizedContour *std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100](OZShapeReparametrizedContour **a1, OZShapeReparametrizedContour *a2)
{
  OZShapeReparametrizedContour *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    OZShapeReparametrizedContour::~OZShapeReparametrizedContour(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

void OZShapeReparametrizedContour::OZShapeReparametrizedContour(OZShapeReparametrizedContour *this, const OZShapeReparametrizedContour *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  void *v9;

  OZShapeContour::OZShapeContour(this, a2);
  v5 = (char *)(v4 + 400);
  v6 = (char *)(v4 + 424);
  v7 = (char *)(v4 + 448);
  *(_QWORD *)(v4 + 464) = 0;
  *(_OWORD *)(v4 + 432) = 0u;
  *(_OWORD *)(v4 + 448) = 0u;
  *(_OWORD *)(v4 + 400) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  v8 = *((_QWORD *)a2 + 48);
  if (v8)
  {
    v9 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 248))(v8);
    if (v9)
    *((_QWORD *)this + 48) = v9;
  }
  *((_QWORD *)this + 49) = *((_QWORD *)a2 + 49);
  if (this != a2)
  {
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v5, *((char **)a2 + 50), *((_QWORD *)a2 + 51), (uint64_t)(*((_QWORD *)a2 + 51) - *((_QWORD *)a2 + 50)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v6, *((char **)a2 + 53), *((_QWORD *)a2 + 54), (uint64_t)(*((_QWORD *)a2 + 54) - *((_QWORD *)a2 + 53)) >> 3);
    std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v7, *((char **)a2 + 56), *((_QWORD *)a2 + 57), (uint64_t)(*((_QWORD *)a2 + 57) - *((_QWORD *)a2 + 56)) >> 3);
  }
}

void sub_1B301ACE4(_Unwind_Exception *a1)
{
  OZShapeContour *v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;

  v6 = *v4;
  if (*v4)
  {
    *((_QWORD *)v1 + 57) = v6;
    operator delete(v6);
  }
  OZShapeReparametrizedContour::OZShapeReparametrizedContour(v3, v2, (uint64_t)v1);
  OZShapeContour::~OZShapeContour(v1);
  _Unwind_Resume(a1);
}

void OZShapeContour::OZShapeContour(OZShapeContour *this, const OZShapeContour *a2)
{
  char *v9;
  char *v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  char *v14;
  uint64_t i;
  char *v16;

  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 40) = _Q0;
  *((_QWORD *)this + 7) = 0x3FF0000000000000;
  v9 = (char *)this + 56;
  *((_QWORD *)this + 22) = 0x3FF0000000000000;
  *((_QWORD *)this + 17) = 0x3FF0000000000000;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 15) = 0u;
  v10 = (char *)this + 240;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *(_WORD *)((char *)this + 185) = *(_WORD *)((char *)a2 + 185);
  *((_BYTE *)this + 187) = *((_BYTE *)a2 + 187);
  v11 = *(_OWORD *)a2;
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *(_OWORD *)this = v11;
  v12 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 40);
  *(_OWORD *)((char *)this + 24) = v12;
  if (a2 == this)
  {
    *((_BYTE *)this + 184) = *((_BYTE *)a2 + 184);
  }
  else
  {
    v13 = 0;
    v16 = (char *)this + 216;
    v14 = (char *)a2 + 56;
    do
    {
      for (i = 0; i != 32; i += 8)
        *(_QWORD *)&v9[i] = *(_QWORD *)&v14[i];
      ++v13;
      v9 += 32;
      v14 += 32;
    }
    while (v13 != 4);
    *((_BYTE *)this + 184) = *((_BYTE *)a2 + 184);
    if (a2 != this)
    {
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)this + 192, *((char **)a2 + 24), *((_QWORD *)a2 + 25), (uint64_t)(*((_QWORD *)a2 + 25) - *((_QWORD *)a2 + 24)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v16, *((char **)a2 + 27), *((_QWORD *)a2 + 28), (uint64_t)(*((_QWORD *)a2 + 28) - *((_QWORD *)a2 + 27)) >> 3);
      std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(v10, *((char **)a2 + 30), *((_QWORD *)a2 + 31), (uint64_t)(*((_QWORD *)a2 + 31) - *((_QWORD *)a2 + 30)) >> 3);
      std::vector<PCVector2<double>>::__assign_with_size[abi:ne180100]<PCVector2<double>*,PCVector2<double>*>((_QWORD *)this + 33, *((__int128 **)a2 + 33), *((__int128 **)a2 + 34), (uint64_t)(*((_QWORD *)a2 + 34) - *((_QWORD *)a2 + 33)) >> 4);
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 36, *((_QWORD *)a2 + 36), *((_QWORD *)a2 + 37), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 37) - *((_QWORD *)a2 + 36)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 39, *((_QWORD *)a2 + 39), *((_QWORD *)a2 + 40), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 40) - *((_QWORD *)a2 + 39)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 42, *((_QWORD *)a2 + 42), *((_QWORD *)a2 + 43), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 43) - *((_QWORD *)a2 + 42)) >> 3));
      std::vector<OZShapeEdgePolygon>::__assign_with_size[abi:ne180100]<OZShapeEdgePolygon*,OZShapeEdgePolygon*>((char **)this + 45, *((_QWORD *)a2 + 45), *((_QWORD *)a2 + 46), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)a2 + 46) - *((_QWORD *)a2 + 45)) >> 3));
    }
  }
}

void sub_1B301AF1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  _QWORD *v10;
  void **v11;
  void **v12;
  void **v13;
  void **v14;
  void **v15;
  void **v16;
  void **v17;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  v19 = *v17;
  if (*v17)
  {
    v10[46] = v19;
    operator delete(v19);
  }
  v20 = *v16;
  if (*v16)
  {
    v10[43] = v20;
    operator delete(v20);
  }
  v21 = *v15;
  if (*v15)
  {
    v10[40] = v21;
    operator delete(v21);
  }
  v22 = *v14;
  if (*v14)
  {
    v10[37] = v22;
    operator delete(v22);
  }
  v23 = *v13;
  if (*v13)
  {
    v10[34] = v23;
    operator delete(v23);
  }
  v24 = *v12;
  if (*v12)
  {
    v10[31] = v24;
    operator delete(v24);
  }
  v25 = *a10;
  if (*a10)
  {
    v10[28] = v25;
    operator delete(v25);
  }
  v26 = *v11;
  if (*v11)
  {
    v10[25] = v26;
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void OZShapeReparametrizedContour::OZShapeReparametrizedContour(void **a1, void **a2, uint64_t a3)
{
  void *v5;
  void *v6;

  v5 = *a1;
  if (v5)
  {
    *(_QWORD *)(a3 + 432) = v5;
    operator delete(v5);
  }
  v6 = *a2;
  if (*a2)
  {
    *(_QWORD *)(a3 + 408) = v6;
    operator delete(v6);
  }
}

void heShapeTesselationCallback(double *a1, double **a2, float *a3, double **a4, void **a5)
{
  double *v10;
  double v11;
  uint64_t v12;
  double *v13;
  double v14;
  unint64_t v15;
  double **v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  double **v23;
  char *v24;
  char *v25;
  char *v26;
  double *v27;

  v10 = (double *)malloc_type_malloc(0x30uLL, 0x100004000313F17uLL);
  *v10 = *a1;
  v10[1] = a1[1];
  v10[2] = a1[2];
  v11 = *a3;
  v12 = (uint64_t)*a2;
  v13 = a2[1];
  v14 = a3[1];
  v10[3] = **a2 * v11 + *v13 * v14;
  v10[4] = *(double *)(v12 + 8) * v11 + v13[1] * v14;
  v10[5] = *(double *)(v12 + 16) * v11 + v13[2] * v14;
  v15 = (unint64_t)a5[2];
  v16 = (double **)a5[1];
  if ((unint64_t)v16 >= v15)
  {
    v18 = ((char *)v16 - (_BYTE *)*a5) >> 3;
    if ((unint64_t)(v18 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v19 = v15 - (_QWORD)*a5;
    v20 = v19 >> 2;
    if (v19 >> 2 <= (unint64_t)(v18 + 1))
      v20 = v18 + 1;
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v21 = v20;
    if (v21)
      v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a5 + 2), v21);
    else
      v22 = 0;
    v23 = (double **)&v22[8 * v18];
    v24 = &v22[8 * v21];
    *v23 = v10;
    v17 = v23 + 1;
    v26 = (char *)*a5;
    v25 = (char *)a5[1];
    if (v25 != *a5)
    {
      do
      {
        v27 = (double *)*((_QWORD *)v25 - 1);
        v25 -= 8;
        *--v23 = v27;
      }
      while (v25 != v26);
      v25 = (char *)*a5;
    }
    *a5 = v23;
    a5[1] = v17;
    a5[2] = v24;
    if (v25)
      operator delete(v25);
  }
  else
  {
    *v16 = v10;
    v17 = v16 + 1;
  }
  a5[1] = v17;
  *a4 = v10;
}

void heShapeTesselationEndCallback(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  _DWORD *v9;
  char *v10;
  _DWORD *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  int v20;

  v2 = a1[1];
  if (v2 != *a1)
  {
    v3 = 0;
    v4 = 1;
    v2 = *a1;
    do
    {
      free(*(void **)(v2 + 8 * v3));
      v3 = v4;
      v2 = *a1;
      ++v4;
    }
    while (v3 < (a1[1] - *a1) >> 3);
  }
  a1[1] = v2;
  v5 = a1[19];
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 24);
    if (v6)
      v7 = *(_DWORD *)(v6 + 8);
    else
      v7 = 0;
    v8 = *(_QWORD *)(v5 + 16);
    v9 = *(_DWORD **)(v5 + 8);
    if ((unint64_t)v9 >= v8)
    {
      v11 = *(_DWORD **)v5;
      v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - *(_QWORD *)v5) >> 2);
      v13 = v12 + 1;
      if (v12 + 1 > 0x1555555555555555)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - (_QWORD)v11) >> 2);
      if (2 * v14 > v13)
        v13 = 2 * v14;
      if (v14 >= 0xAAAAAAAAAAAAAAALL)
        v15 = 0x1555555555555555;
      else
        v15 = v13;
      if (v15)
      {
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Vec3f>>(v5 + 16, v15);
        v11 = *(_DWORD **)v5;
        v9 = *(_DWORD **)(v5 + 8);
      }
      else
      {
        v16 = 0;
      }
      v17 = &v16[12 * v12];
      v18 = &v16[12 * v15];
      *(_QWORD *)v17 = 4;
      *((_DWORD *)v17 + 2) = v7;
      v10 = v17 + 12;
      if (v9 != v11)
      {
        do
        {
          v19 = *(_QWORD *)(v9 - 3);
          v9 -= 3;
          v20 = v9[2];
          *(_QWORD *)(v17 - 12) = v19;
          v17 -= 12;
          *((_DWORD *)v17 + 2) = v20;
        }
        while (v9 != v11);
        v11 = *(_DWORD **)v5;
      }
      *(_QWORD *)v5 = v17;
      *(_QWORD *)(v5 + 8) = v10;
      *(_QWORD *)(v5 + 16) = v18;
      if (v11)
        operator delete(v11);
    }
    else
    {
      *(_QWORD *)v9 = 4;
      v9[2] = v7;
      v10 = (char *)(v9 + 3);
    }
    *(_QWORD *)(v5 + 8) = v10;
  }
}

double heVertexCallback(float64x2_t *a1, double *a2)
{
  _OWORD *v3;
  double result;
  __int128 v5;
  __int128 v6;

  if (*((_QWORD *)a2 + 19))
  {
    *(float32x2_t *)&v6 = vcvt_f32_f64(*a1);
    *((_QWORD *)&v6 + 1) = 0x3F80000000000000;
    PCMatrix44Tmpl<double>::transform<float>(a2 + 3, (float *)&v6, (uint64_t)&v6);
    v5 = v6;
    *(_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*((_QWORD *)a2 + 19) + 24)) = v5;
    v3 = (_OWORD *)HGArray<__simd128_float32_t,(HGFormat)28>::append((HGArrayDataRef *)(*((_QWORD *)a2 + 19) + 40));
    result = 1.92414562e12;
    *v3 = xmmword_1B3565CA0;
  }
  return result;
}

uint64_t OZShape::calcHashForState(OZShape *this, PCSerializerWriteStream *a2, const CMTime *a3)
{
  unint64_t isEnabled;
  unint64_t v7;
  uint64_t result;

  OZChannelCurve::calcHashForState((OZShape *)((char *)this + 208), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1072), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1328), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1480), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 1632), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 14752), a2, a3);
  isEnabled = OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 2784), 0, 1);
  (*(void (**)(PCSerializerWriteStream *, unint64_t))(*(_QWORD *)a2 + 48))(a2, isEnabled);
  if (OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 2784), 0, 1))
  {
    OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 2784), a2, a3);
    OZChannel::calcHashForState((OZChannel *)((char *)this + 2912), a2, a3);
    if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 2912), MEMORY[0x1E0CA2E68], 0.0))
    {
      OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 4328), a2, a3);
    }
    else
    {
      OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 3168), a2, a3);
      OZChannel::calcHashForState((OZChannel *)((char *)this + 4176), a2, a3);
    }
  }
  v7 = OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 6800), 0, 1);
  (*(void (**)(PCSerializerWriteStream *, unint64_t))(*(_QWORD *)a2 + 48))(a2, v7);
  if (OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 6800), 0, 1))
    OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 6800), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 11512), a2, a3);
  OZChannel::calcHashForState((OZChannel *)((char *)this + 11664), a2, a3);
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 12856), MEMORY[0x1E0CA2E68], 0.0))
  {
    OZChannel::calcHashForState((OZChannel *)((char *)this + 13008), a2, a3);
    OZChannel::calcHashForState((OZChannel *)((char *)this + 13264), a2, a3);
  }
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E0CA2E68], 0.0) == 4)
  {
    OZChannel::calcHashForState((OZChannel *)((char *)this + 12072), a2, a3);
    OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 12224), a2, a3);
  }
  result = OZChannel::getValueAsInt((OZChannel *)((char *)this + 1072), MEMORY[0x1E0CA2E68], 0.0);
  if ((_DWORD)result == 5)
    return OZChannelFolder::calcHashForState((OZChannelFolder *)((char *)this + 12224), a2, a3);
  return result;
}

double OZShape::getBorderSize(uint64_t a1, uint64_t a2, _QWORD *a3, double *a4)
{
  CGColorSpace *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  double v12;
  double result;
  __int128 v14;
  CGColorSpace *v15;
  int v16;

  v14 = *(_OWORD *)(a2 + 16);
  v8 = *(CGColorSpace **)(a2 + 80);
  v15 = v8;
  if (v8)
    PCCFRefTraits<CGColorSpace *>::retain(v8);
  v16 = *(_DWORD *)(a2 + 88);
  v9 = 2664;
  if (!BYTE8(v14))
    v9 = 2672;
  v10 = *(_QWORD *)(a1 + v9);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v15);
  v11 = *(_DWORD *)(v10 + 8);
  if (v11 && *(double *)(v10 + 16) > 2.0
    || (v12 = *(double *)(v10 + 224), v12 > 0.0) && *(_DWORD *)(v10 + 120)
    || v12 < 0.0 && *(_DWORD *)(v10 + 120))
  {
    if (a3)
      *a3 = 0;
    result = 0.0;
    if (a4)
LABEL_14:
      *a4 = result;
  }
  else
  {
    result = fabs(v12);
    if (result < 0.0000001 && *(_DWORD *)(v10 + 120) || v11 && (result = *(double *)(v10 + 16), result <= 2.0))
    {
      if (a3)
        *a3 = 0x4000000000000000;
      result = 2.0;
      if (a4)
        goto LABEL_14;
    }
  }
  return result;
}

uint64_t OZShape::getCurrentRenderParams(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = 2664;
  if (!*(_BYTE *)(a2 + 24))
    v2 = 2672;
  return *(_QWORD *)(a1 + v2);
}

void OZShape::getShapeBounds(uint64_t a1, float64x2_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Contour;
  float64x2_t v9;
  int v10;
  double v11;
  float v12;
  float64x2_t v18;
  double v19;
  float v20;
  float v21;
  double v22;
  double v23;
  float v24;
  const CMTime *v25;
  double v26;
  double v27;
  double v28;
  float v29;
  double v30;
  double v31;
  float v32;
  double v33;
  float v34;
  double v35;
  const CMTime *v36;
  double v37;
  double v38;
  double v39;
  float64_t v40;
  float64_t v41;
  float64x2_t v42;
  float64_t v43;
  int v44;
  int v45;
  int v46;
  char *v47;
  uint64_t v48;
  double v49;
  unsigned int v50;
  double v51;
  char *v52;
  double v53;

  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3, a4, 0, 1);
  Contour = OZShape::getContour((OZShape *)a1, (const CMTime *)a3, (OZShapeRenderParams *)a4);
  v9 = *(float64x2_t *)(Contour + 40);
  *a2 = *(float64x2_t *)(Contour + 24);
  a2[1] = v9;
  if (a2[1].f64[0] < 0.0 || a2[1].f64[1] < 0.0)
    return;
  v10 = *(_DWORD *)(a4 + 8);
  if (!v10 || (v11 = *(double *)(a4 + 16), v11 <= 2.0))
  {
    v23 = *(double *)(a4 + 224);
    if (v23 > 0.0 && *(_DWORD *)(a4 + 120))
    {
      v24 = v23;
      v25 = (const CMTime *)MEMORY[0x1E0CA2E68];
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E0CA2E68], 0.0);
      v27 = v26;
      OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), v25, 0.0);
      v29 = v24;
      if (v27 != 0.0)
        v29 = v24 / fabs(v27);
      if (v28 != 0.0)
        v24 = v24 / fabs(v28);
      v30 = v29;
      v31 = v24;
    }
    else
    {
      if (v23 < 0.0 && *(_DWORD *)(a4 + 120)
        || (fabs(v23) >= 0.0000001 || !*(_DWORD *)(a4 + 120)) && (!v10 || *(double *)(a4 + 16) > 2.0))
      {
        return;
      }
      v32 = 2.0 / *(double *)(a3 + 32);
      v33 = *(double *)(a4 + 248);
      if (v33 != 0.0)
        v32 = v32 / fabs(v33);
      v34 = 2.0 / *(double *)(a3 + 40);
      v35 = *(double *)(a4 + 256);
      if (v35 != 0.0)
        v34 = v34 / fabs(v35);
      if (v23 <= 0.0 && *(_DWORD *)(a4 + 120))
      {
        v36 = (const CMTime *)MEMORY[0x1E0CA2E68];
        OZChannel::getValueAsDouble((OZChannel *)(a1 + 13416), MEMORY[0x1E0CA2E68], 0.0);
        v38 = v37;
        OZChannel::getValueAsDouble((OZChannel *)(a1 + 13568), v36, 0.0);
        if (v38 != 0.0)
          v32 = v32 / fabs(v38);
        if (v39 != 0.0)
          v34 = v34 / fabs(v39);
      }
      v30 = v32;
      v31 = v34;
    }
    v40 = a2->f64[1] - v31;
    a2->f64[0] = a2->f64[0] - v30;
    a2->f64[1] = v40;
    v41 = a2[1].f64[1] - (-v31 - v31);
    a2[1].f64[0] = a2[1].f64[0] - (-v30 - v30);
    a2[1].f64[1] = v41;
    return;
  }
  v12 = v11 * 0.5;
  if (*(_DWORD *)(a4 + 28) == 3 || *(_DWORD *)(a4 + 32) == 3)
  {
    __asm { FMOV            V1.2D, #0.5 }
    v18 = vmulq_f64(vmulq_n_f64(*(float64x2_t *)(a4 + 96), v11), _Q1);
    if (v18.f64[1] >= v18.f64[0])
      v18.f64[0] = v18.f64[1];
    v12 = v18.f64[0] + v12;
  }
  if (*(_BYTE *)(a4 + 13))
  {
    v51 = 1.0;
    v53 = 1.0;
    (*(void (**)(uint64_t, double *, double *, uint64_t))(*(_QWORD *)a1 + 368))(a1, &v51, &v53, a3);
    v19 = fabs(v51);
    v20 = 0.0;
    v21 = 0.0;
    if (v19 >= 0.0000001)
      v21 = v12 / v19;
    v22 = fabs(v53);
    if (v22 >= 0.0000001)
      v20 = v12 / v22;
    v12 = v20;
  }
  else
  {
    v21 = v12;
  }
  v42.f64[0] = v21 / (*(double (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  v43 = a2->f64[1] - v12;
  a2->f64[0] = a2->f64[0] - v42.f64[0];
  a2->f64[1] = v43;
  v42.f64[1] = v12;
  a2[1] = vsubq_f64(a2[1], vsubq_f64(vnegq_f64(v42), v42));
  v44 = *(_DWORD *)(a4 + 24);
  if (!v44
    || (v45 = *(_DWORD *)(a4 + 28)) == 0
    || (v46 = *(_DWORD *)(a4 + 32), v46 == 2)
    || v45 == 2
    || v44 == 2
    || !v46)
  {
    if (v21 >= v12)
      v12 = v21;
    v53 = 0.0;
    OZChannelCurve::getVerticesList((OZChannelCurve *)(a1 + 208), (char **)&v51);
    v47 = v52;
    if (v52 != *(char **)&v51)
    {
      v48 = 0;
      v49 = v12;
      v50 = 1;
      v47 = *(char **)&v51;
      do
      {
        OZChannelCurve::getVertexParametricValue(a1 + 208, *(char **)&v47[16 * v48], *(_QWORD *)&v47[16 * v48 + 8], (CMTime *)a3, &v53);
        OZShape::calcIntersectionForOutlineAtPoint(a1, (CMTime *)a3, (_DWORD *)a4, a2, v53, v49);
        v48 = v50;
        v47 = *(char **)&v51;
        ++v50;
      }
      while (v48 != (uint64_t)&v52[-*(_QWORD *)&v51] >> 4);
    }
    if (v47)
    {
      v52 = v47;
      operator delete(v47);
    }
  }
}

void sub_1B301BBB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void OZShape::calculateBounds(OZShape *this, const OZShapeRenderState *a2)
{
  __int128 v4;
  __int128 v5;
  CGColorSpace *v6;
  uint64_t v7;
  OZShapeRenderParams *v8;
  uint64_t Contour;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  float64_t v18;
  float64x2_t v19[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  CGColorSpace *v24;
  int v25;

  v4 = *((_OWORD *)a2 + 3);
  v21 = *((_OWORD *)a2 + 2);
  v22 = v4;
  v23 = *((_OWORD *)a2 + 4);
  v5 = *((_OWORD *)a2 + 1);
  v19[1] = *(float64x2_t *)a2;
  v20 = v5;
  v6 = (CGColorSpace *)*((_QWORD *)a2 + 10);
  v24 = v6;
  if (v6)
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  v25 = *((_DWORD *)a2 + 22);
  v7 = 2664;
  if (!BYTE8(v20))
    v7 = 2672;
  v8 = *(OZShapeRenderParams **)((char *)this + v7);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v24);
  Contour = OZShape::getContour(this, (const CMTime *)a2, v8);
  if (OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 6800), 0, 1))
    OZChannelBase::isEnabled((OZChannelBase *)((char *)this + 2784), 0, 1);
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(Contour + 40) = _Q0;
  v15 = *(_QWORD *)(Contour + 216);
  if (*(_QWORD *)(Contour + 224) != v15)
  {
    v16 = 0;
    v17 = 1;
    do
    {
      v18 = *(double *)(*(_QWORD *)(Contour + 240) + 8 * v16);
      v19[0].f64[0] = *(float64_t *)(v15 + 8 * v16);
      v19[0].f64[1] = v18;
      PCRect<double>::operator|=((float64x2_t *)(Contour + 24), v19);
      v16 = v17;
      v15 = *(_QWORD *)(Contour + 216);
      ++v17;
    }
    while (v16 != (*(_QWORD *)(Contour + 224) - v15) >> 3);
  }
  *((_BYTE *)v8 + 1192) = 0;
}

BOOL OZShape::shouldDrawSoftEdges(OZShape *this, const OZShapeRenderParams *a2)
{
  int v3;
  _BOOL8 result;

  result = 1;
  if (*((_DWORD *)a2 + 2))
  {
    if ((OZShape::isWriteOnEffectEnabled((uint64_t)this, (uint64_t)a2) & 1) == 0)
    {
      v3 = *((_DWORD *)a2 + 29);
      if (v3 != 1
        && (v3
         || *((double *)a2 + 2) >= 2.0
         && fabs(*((double *)a2 + 8) + -1.0) < 0.0000001
         && (*((_DWORD *)a2 + 42) || !*((_DWORD *)a2 + 30))))
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t OZShape::shouldDrawAntialiasingOnFill(OZShape *this, const OZShapeRenderParams *a2)
{
  int v3;
  int v4;

  v3 = *((_DWORD *)a2 + 30);
  if (*((_DWORD *)a2 + 2))
  {
    if (v3)
    {
      if ((OZShape::isWriteOnEffectEnabled((uint64_t)this, (uint64_t)a2) & 1) != 0)
        return 1;
      v4 = *((_DWORD *)a2 + 29);
      if (v4 == 1 || !v4 && (*((double *)a2 + 2) < 2.0 || fabs(*((double *)a2 + 8) + -1.0) >= 0.0000001))
        return 1;
      if (!*((_DWORD *)a2 + 42))
        return 1;
    }
  }
  else if (v3 && fabs(*((double *)a2 + 28)) < 0.0000001)
  {
    return 1;
  }
  return 0;
}

BOOL OZShape::shouldDrawSecondPassOutline(OZShape *this, const OZShapeRenderParams *a2)
{
  return *((_DWORD *)a2 + 2) != 0;
}

uint64_t OZShape::shouldDrawParticles(uint64_t a1, CMTime *a2)
{
  int ValueAsInt;
  uint64_t result;
  CMTime v5;

  v5 = *a2;
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 6928), &v5, 0.0);
  LODWORD(result) = OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1);
  if ((ValueAsInt - 1) < 2)
    return result;
  else
    return 0;
}

BOOL OZShape::shouldDrawOnlyParticles(uint64_t a1, CMTime *a2)
{
  int ValueAsInt;
  int isEnabled;
  _BOOL8 result;
  CMTime v6;

  v6 = *a2;
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 6928), &v6, 0.0);
  isEnabled = OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1);
  result = 0;
  if (isEnabled)
    return (OZChannelBase::isEnabled((OZChannelBase *)(a1 + 2784), 0, 1) & 1) == 0 && (ValueAsInt - 1) < 2;
  return result;
}

BOOL OZShape::shouldDrawFillAndParticles(uint64_t a1, CMTime *a2)
{
  int ValueAsInt;
  int isEnabled;
  _BOOL8 result;
  CMTime v6;

  v6 = *a2;
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 6928), &v6, 0.0);
  isEnabled = OZChannelBase::isEnabled((OZChannelBase *)(a1 + 6800), 0, 1);
  result = 0;
  if (isEnabled)
    return OZChannelBase::isEnabled((OZChannelBase *)(a1 + 2784), 0, 1)
        && (ValueAsInt - 1) < 2;
  return result;
}

BOOL OZShape::shouldRenderInPlace(OZShape *this, OZShapeRenderParams *a2)
{
  int v2;
  double *v3;

  v2 = *((_DWORD *)a2 + 30);
  if (!*((_DWORD *)a2 + 2))
  {
    if (!v2)
      goto LABEL_8;
    v3 = (double *)((char *)a2 + 152);
LABEL_7:
    v2 = fabs(*((double *)a2 + 20) * *v3 + -1.0) < 0.0000001;
    goto LABEL_8;
  }
  if (!v2)
  {
    v3 = (double *)((char *)a2 + 64);
    goto LABEL_7;
  }
  v2 = 0;
  if (!*((_BYTE *)a2 + 553))
    return 0;
LABEL_8:
  if (!*((_DWORD *)a2 + 42))
    v2 = 0;
  return v2 == 1 && !*((_BYTE *)a2 + 176);
}

uint64_t OZShape::getHeliumParameters(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, char a5, uint64_t a6)
{
  PCMutex *v11;
  _BOOL4 isGeometricShape;
  CGColorSpace *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  OZGradientGroupShader *v19;
  CGColorSpace *CGColorSpace;
  uint64_t v21;
  uint64_t v22;
  double *v23;
  uint64_t i;
  __int128 *RenderContour;
  const OZShapeReparametrizedContour *ReparametrizedContour;
  OZShapeReparametrizedContour *v27;
  int ValueAsInt;
  __int128 *RenderContourWithRoundness;
  __int128 v30;
  CGColorSpace *v31;
  int v32;
  uint64_t v33;
  char v34;

  v11 = (PCMutex *)(a1 + 8);
  v33 = a1 + 8;
  PCMutex::lock((PCMutex *)(a1 + 8));
  v34 = 1;
  isGeometricShape = OZShape::isGeometricShape((OZShape *)a1);
  if (!isGeometricShape
    && (int)OZDynamicCurve::getNumberOfValidKeypoints((os_unfair_lock_s *)(a1 + 496), (const CMTime *)a2) < 2)
  {
    goto LABEL_12;
  }
  v30 = *(_OWORD *)(a2 + 16);
  v13 = *(CGColorSpace **)(a2 + 80);
  v31 = v13;
  if (v13)
    PCCFRefTraits<CGColorSpace *>::retain(v13);
  v32 = *(_DWORD *)(a2 + 88);
  v14 = 2664;
  if (!BYTE8(v30))
    v14 = 2672;
  v15 = *(_QWORD *)(a1 + v14);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v31);
  v16 = OZChannel::getValueAsInt((OZChannel *)(a1 + 14600), MEMORY[0x1E0CA2E68], 0.0) == 1 ? 0 : a5;
  *(_BYTE *)(v15 + 176) = v16;
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, v15, 0, 1);
  if (fabs(*(double *)(v15 + 248)) < 0.0000001 || fabs(*(double *)(v15 + 256)) < 0.0000001)
    goto LABEL_12;
  if (!*(_QWORD *)(a1 + 18720) && *(_DWORD *)(v15 + 124) == 1)
  {
    v19 = (OZGradientGroupShader *)operator new();
    CGColorSpace = (CGColorSpace *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(a2 + 80));
    OZGradientGroupShader::OZGradientGroupShader(v19, (OZChannelGradientExtras *)(a1 + 4328), CGColorSpace, 1.0);
    *(_QWORD *)(a1 + 18720) = v19;
  }
  if (isGeometricShape)
  {
    if (fabs(*(double *)(v15 + 200)) < 0.0000001)
    {
      if (fabs(*(double *)(v15 + 224)) < 0.0000001 && *(_DWORD *)(v15 + 120) && !*(_DWORD *)(v15 + 8))
        goto LABEL_12;
      *(_QWORD *)(v15 + 200) = 0x3FF0000000000000;
    }
    if (fabs(*(double *)(v15 + 208)) < 0.0000001)
    {
      if (fabs(*(double *)(v15 + 224)) >= 0.0000001 || !*(_DWORD *)(v15 + 120) || *(_DWORD *)(v15 + 8))
      {
        *(_QWORD *)(v15 + 208) = 0x3FF0000000000000;
        goto LABEL_28;
      }
LABEL_12:
      v17 = 0;
      goto LABEL_13;
    }
  }
LABEL_28:
  v21 = v15 + 1200;
  if ((double *)(v15 + 1200) != a3)
  {
    v22 = 0;
    v23 = a3;
    do
    {
      for (i = 0; i != 4; ++i)
        *(double *)(v21 + i * 8) = v23[i];
      ++v22;
      v21 += 32;
      v23 += 4;
    }
    while (v22 != 4);
  }
  OZShapeRenderParams::assign((OZShapeRenderParams *)a6, (OZShapeRenderParams *)v15, 0);
  RenderContour = (__int128 *)OZShape::getRenderContour(a1, (const CMTime *)a2, a6, a3);
  OZShapeContour::operator=(a6 + 368, RenderContour);
  *(_BYTE *)(a6 + 1192) = 0;
  if (*(_DWORD *)(a6 + 8) && OZShape::isWriteOnEffectEnabled(a1, a6))
  {
    ReparametrizedContour = (const OZShapeReparametrizedContour *)OZShape::getReparametrizedContour(a1, a2, a6, 0);
    v27 = (OZShapeReparametrizedContour *)operator new();
    OZShapeReparametrizedContour::OZShapeReparametrizedContour(v27, ReparametrizedContour);
    std::unique_ptr<OZShapeReparametrizedContour>::reset[abi:ne180100]((OZShapeReparametrizedContour **)(a6 + 752), v27);
    *(_BYTE *)(a6 + 1193) = 0;
  }
  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0);
  v17 = 1;
  if (*(int *)(a6 + 180) >= 1 && ValueAsInt != 4)
  {
    RenderContourWithRoundness = (__int128 *)OZShape::getRenderContourWithRoundness(a1, a2, a6, a3);
    OZShapeContour::operator=(a6 + 760, RenderContourWithRoundness);
    *(_BYTE *)(a6 + 1194) = 0;
  }
LABEL_13:
  PCMutex::unlock(v11);
  return v17;
}

void sub_1B301C3A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  MEMORY[0x1B5E29170](v13, 0x10A0C401050895ELL);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t OZShape::getHeliumRender@<X0>(uint64_t a1@<X0>, const CMTime *a2@<X1>, double *a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X4>, HGHWMultiBlend **a6@<X8>)
{
  uint64_t result;
  int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t *v20;
  char v21;
  int v22;
  double v23;
  _BOOL4 v24;
  HGHWMultiBlend *v25;
  HGCrop *v26;
  HGHWMultiBlend *v27;

  result = OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0);
  v13 = result;
  if (*(_DWORD *)(a5 + 120))
  {
    v14 = (_DWORD)result == 4 || *(_DWORD *)(a5 + 180) == 0;
    v15 = 760;
    if (v14)
      v15 = 368;
    v16 = a5 + v15;
    if (*(_QWORD *)(a5 + v15 + 216) == *(_QWORD *)(a5 + v15 + 224)
      || *(_QWORD *)(v16 + 240) == *(_QWORD *)(v16 + 248)
      || *(_QWORD *)(v16 + 192) == *(_QWORD *)(v16 + 200))
    {
      goto LABEL_47;
    }
    if (OZShape::shouldDrawSoftEdges((OZShape *)a1, (const OZShapeRenderParams *)a5)
      && (OZShape::shouldDrawAntialiasingOnFill((OZShape *)a1, (const OZShapeRenderParams *)a5) & 1) == 0
      && *(_QWORD *)(v16 + 312) == *(_QWORD *)(v16 + 320))
    {
      OZShape::computeSoftEdges(a1, a2, a5, v16, 0, 1, 1, *(double *)(a5 + 224));
      if (!*(_BYTE *)(v16 + 185) || *(_BYTE *)(v16 + 186) || !*(_BYTE *)(v16 + 187))
        OZShape::computeSoftEdges(a1, a2, a5, v16, 0, 0, -1, *(double *)(a5 + 224));
    }
  }
  v17 = *(_DWORD *)(a5 + 8);
  if (*(double *)(a5 + 16) <= 0.0 || v17 == 0)
    goto LABEL_21;
  result = OZShape::isWriteOnEffectEnabled(a1, a5);
  if (!*(_DWORD *)(a5 + 180) || v13 == 4)
  {
    if (*(_DWORD *)(a5 + 168) || !(_DWORD)result)
      v20 = (uint64_t *)(a5 + 368);
    else
      v20 = *(uint64_t **)(a5 + 752);
  }
  else
  {
    v20 = (uint64_t *)(a5 + 760);
  }
  if (v20[27] == v20[28] || v20[30] == v20[31] || v20[24] == v20[25])
  {
LABEL_47:
    v25 = 0;
    goto LABEL_54;
  }
  if (*(_BYTE *)(a5 + 1195) || v20[43] == v20[42])
  {
    if (*(_DWORD *)(a5 + 168))
      v21 = result;
    else
      v21 = 1;
    v22 = *(_DWORD *)(a5 + 24);
    v23 = *(double *)(a5 + 16);
    v24 = !PCMatrix44Tmpl<double>::isIdentity(a3);
    if ((v21 & 1) != 0)
      OZShape::computeOpenStroke(a1, a2, a5, v20, a3, v22, v24, v23);
    else
      OZShape::computeOutline(a1, a2, a5, v20, a3, v22, v24, v23);
  }
  v17 = *(_DWORD *)(a5 + 8);
LABEL_21:
  if (*(_DWORD *)(a5 + 124) != 1 || *(_DWORD *)(a5 + 120) == 0)
  {
    if (!v17)
      goto LABEL_49;
LABEL_27:
    result = (uint64_t)OZShape::getSecondPassOutlineHeliumNode((OZShape *)a1, a2, (uint64_t)a3, a5, &v27);
    goto LABEL_50;
  }
  if (v17 || OZShape::shouldDrawSoftEdges((OZShape *)a1, (const OZShapeRenderParams *)a5))
  {
    result = OZShape::getSecondPassGradientToHeliumNode((OZShape *)a1, a2, (uint64_t)a3, a4, a5, &v27);
    goto LABEL_50;
  }
  if (*(_DWORD *)(a5 + 8))
    goto LABEL_27;
LABEL_49:
  result = OZShape::drawToHeliumNode(a1, a2, (uint64_t)a3, a5, (uint64_t *)&v27);
LABEL_50:
  v25 = v27;
  if (v27)
  {
    v26 = (HGCrop *)HGObject::operator new(0x1A0uLL);
    HGCrop::HGCrop(v26);
    (*(void (**)(HGCrop *, _QWORD, float, float, float, float))(*(_QWORD *)v26 + 96))(v26, 0, -1000000.0, -1000000.0, 1000000.0, 1000000.0);
    (*(void (**)(HGCrop *, _QWORD, HGHWMultiBlend *))(*(_QWORD *)v26 + 120))(v26, 0, v25);
    if (v25 != v26)
    {
      (*(void (**)(HGHWMultiBlend *))(*(_QWORD *)v25 + 24))(v25);
      v25 = v26;
      (*(void (**)(HGCrop *))(*(_QWORD *)v26 + 16))(v26);
    }
    result = (*(uint64_t (**)(HGCrop *))(*(_QWORD *)v26 + 24))(v26);
  }
LABEL_54:
  *a6 = v25;
  return result;
}

void sub_1B301C764(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

BOOL OZShape::shouldDrawSecondPassGradientInHelium(OZShape *a1, int a2, OZShapeRenderParams *a3)
{
  return *((_DWORD *)a3 + 31) == 1
      && *((_DWORD *)a3 + 30)
      && (*((_DWORD *)a3 + 2) || OZShape::shouldDrawSoftEdges(a1, a3));
}

uint64_t OZShape::getSecondPassGradientToHeliumNode@<X0>(OZShape *a1@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X4>, HGHWMultiBlend **a6@<X8>)
{
  int v12;
  PCMutex *v13;
  uint64_t v14;
  double v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t CGColorSpace;
  HgcShapeSoftEdgeColorizeSecondPass *v19;
  uint64_t result;
  int v21;
  HGNode *v22;
  HgcShapeGradientBlend *v23;
  HGHWMultiBlend *v24;
  HgcShapeSoftEdgeColorizeSecondPass *v25;
  HGNode *v26;
  HgcShapeGradientBlend *v27;
  HgcShapeSoftEdgeColorizeSecondPass *v28;
  CMTime v29;
  HGNode *v30;
  char v31;

  *a6 = 0;
  v12 = *(_DWORD *)(a5 + 8);
  v13 = (PCMutex *)((char *)a1 + 8);
  v30 = (HGNode *)((char *)a1 + 8);
  PCMutex::lock((PCMutex *)((char *)a1 + 8));
  v31 = 1;
  v14 = *((_QWORD *)a1 + 2340);
  v15 = (*(double (**)(OZShape *))(*(_QWORD *)a1 + 176))(a1);
  *(double *)(*(_QWORD *)(v14 + 16) + 176) = v15;
  *(double *)(*(_QWORD *)(v14 + 8) + 176) = v15;
  v16 = (_QWORD *)*((_QWORD *)a1 + 2340);
  v29 = *a2;
  OZGradientGroupShader::updateWithXForm(v16, &v29, a4);
  v17 = *(_QWORD *)(*((_QWORD *)a1 + 2340) + 24);
  CGColorSpace = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&a2[3].timescale);
  (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v17 + 48))(&v28, v17, CGColorSpace);
  v19 = v28;
  result = PCMutex::unlock(v13);
  v21 = *(_DWORD *)(a5 + 120);
  if (v12)
  {
    if (v21)
    {
      OZShape::drawToHeliumNode((uint64_t)a1, a2, a3, a5, (uint64_t *)&v30);
      result = (uint64_t)OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a5, &v28);
      v22 = v30;
      if (v30)
      {
        v23 = (HgcShapeGradientBlend *)HGObject::operator new(0x1A0uLL);
        *((_OWORD *)v23 + 24) = 0u;
        *((_OWORD *)v23 + 25) = 0u;
        *((_OWORD *)v23 + 22) = 0u;
        *((_OWORD *)v23 + 23) = 0u;
        *((_OWORD *)v23 + 20) = 0u;
        *((_OWORD *)v23 + 21) = 0u;
        *((_OWORD *)v23 + 18) = 0u;
        *((_OWORD *)v23 + 19) = 0u;
        *((_OWORD *)v23 + 16) = 0u;
        *((_OWORD *)v23 + 17) = 0u;
        *((_OWORD *)v23 + 14) = 0u;
        *((_OWORD *)v23 + 15) = 0u;
        *((_OWORD *)v23 + 12) = 0u;
        *((_OWORD *)v23 + 13) = 0u;
        *((_OWORD *)v23 + 10) = 0u;
        *((_OWORD *)v23 + 11) = 0u;
        *((_OWORD *)v23 + 8) = 0u;
        *((_OWORD *)v23 + 9) = 0u;
        *((_OWORD *)v23 + 6) = 0u;
        *((_OWORD *)v23 + 7) = 0u;
        *((_OWORD *)v23 + 4) = 0u;
        *((_OWORD *)v23 + 5) = 0u;
        *((_OWORD *)v23 + 2) = 0u;
        *((_OWORD *)v23 + 3) = 0u;
        *(_OWORD *)v23 = 0u;
        *((_OWORD *)v23 + 1) = 0u;
        HgcShapeGradientBlend::HgcShapeGradientBlend(v23);
        *(_QWORD *)v23 = off_1E65EA880;
        HGNode::SetInput((HGNode *)v23, 0, v22);
        (*(void (**)(HgcShapeGradientBlend *, uint64_t, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v23 + 120))(v23, 1, v19);
        v24 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
        HGHWMultiBlend::HGHWMultiBlend(v24);
        (*(void (**)(HGHWMultiBlend *, _QWORD, float, float, float, float))(*(_QWORD *)v24 + 96))(v24, 0, 9.0, 0.0, 0.0, 0.0);
        if (*(_DWORD *)(a5 + 116) == 1)
        {
          v25 = v28;
          (*(void (**)(HGHWMultiBlend *, _QWORD, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v24 + 120))(v24, 0, v28);
          (*(void (**)(HGHWMultiBlend *, uint64_t, HgcShapeGradientBlend *))(*(_QWORD *)v24 + 120))(v24, 1, v23);
        }
        else
        {
          (*(void (**)(HGHWMultiBlend *, _QWORD, HgcShapeGradientBlend *))(*(_QWORD *)v24 + 120))(v24, 0, v23);
          v25 = v28;
          (*(void (**)(HGHWMultiBlend *, uint64_t, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v24
                                                                                                  + 120))(v24, 1, v28);
        }
        *a6 = v24;
        (*(void (**)(HGHWMultiBlend *))(*(_QWORD *)v24 + 16))(v24);
        (*(void (**)(HGHWMultiBlend *))(*(_QWORD *)v24 + 24))(v24);
        (*(void (**)(HgcShapeGradientBlend *))(*(_QWORD *)v23 + 24))(v23);
        if (!v25)
        {
LABEL_16:
          result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v22 + 24))(v22);
          goto LABEL_17;
        }
      }
      else
      {
        v25 = v28;
        if (!v28)
          goto LABEL_17;
        *a6 = v28;
        (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v25 + 16))(v25);
      }
      result = (*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v25 + 24))(v25);
      if (!v22)
        goto LABEL_17;
      goto LABEL_16;
    }
    result = (uint64_t)OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a5, (HgcShapeSoftEdgeColorizeSecondPass **)&v30);
    if (v30)
      *a6 = (HGHWMultiBlend *)v30;
  }
  else if (v21)
  {
    result = OZShape::drawToHeliumNode((uint64_t)a1, a2, a3, a5, (uint64_t *)&v30);
    v26 = v30;
    if (v30)
    {
      v27 = (HgcShapeGradientBlend *)HGObject::operator new(0x1A0uLL);
      *((_OWORD *)v27 + 24) = 0u;
      *((_OWORD *)v27 + 25) = 0u;
      *((_OWORD *)v27 + 22) = 0u;
      *((_OWORD *)v27 + 23) = 0u;
      *((_OWORD *)v27 + 20) = 0u;
      *((_OWORD *)v27 + 21) = 0u;
      *((_OWORD *)v27 + 18) = 0u;
      *((_OWORD *)v27 + 19) = 0u;
      *((_OWORD *)v27 + 16) = 0u;
      *((_OWORD *)v27 + 17) = 0u;
      *((_OWORD *)v27 + 14) = 0u;
      *((_OWORD *)v27 + 15) = 0u;
      *((_OWORD *)v27 + 12) = 0u;
      *((_OWORD *)v27 + 13) = 0u;
      *((_OWORD *)v27 + 10) = 0u;
      *((_OWORD *)v27 + 11) = 0u;
      *((_OWORD *)v27 + 8) = 0u;
      *((_OWORD *)v27 + 9) = 0u;
      *((_OWORD *)v27 + 6) = 0u;
      *((_OWORD *)v27 + 7) = 0u;
      *((_OWORD *)v27 + 4) = 0u;
      *((_OWORD *)v27 + 5) = 0u;
      *((_OWORD *)v27 + 2) = 0u;
      *((_OWORD *)v27 + 3) = 0u;
      *(_OWORD *)v27 = 0u;
      *((_OWORD *)v27 + 1) = 0u;
      HgcShapeGradientBlend::HgcShapeGradientBlend(v27);
      *(_QWORD *)v27 = off_1E65EA880;
      HGNode::SetInput((HGNode *)v27, 0, v26);
      (*(void (**)(HgcShapeGradientBlend *, uint64_t, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v27 + 120))(v27, 1, v19);
      *a6 = v27;
      (*(void (**)(HgcShapeGradientBlend *))(*(_QWORD *)v27 + 16))(v27);
      (*(void (**)(HgcShapeGradientBlend *))(*(_QWORD *)v27 + 24))(v27);
      result = (*(uint64_t (**)(HGNode *))(*(_QWORD *)v26 + 24))(v26);
    }
  }
LABEL_17:
  if (v19)
    return (*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v19 + 24))(v19);
  return result;
}

void sub_1B301CC0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  _Unwind_Resume(exception_object);
}

HGGLNode *OZShape::getSecondPassOutlineHeliumNode@<X0>(OZShape *a1@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, HGHWMultiBlend **a5@<X8>)
{
  HGGLNode *result;
  HgcShapeSoftEdgeColorizeSecondPass *v10;
  HGHWMultiBlend *v11;
  HgcShapeSoftEdgeColorizeSecondPass *v12;
  HgcShapeSoftEdgeColorizeSecondPass *v13;
  HgcShapeSoftEdgeColorizeSecondPass *v14;
  HgcShapeSoftEdgeColorizeSecondPass *v15;

  *a5 = 0;
  if (*(_DWORD *)(a4 + 120))
  {
    OZShape::drawToHeliumNode((uint64_t)a1, a2, a3, a4, (uint64_t *)&v15);
    result = OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a4, &v14);
    v10 = v15;
    if (v15)
    {
      v11 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
      HGHWMultiBlend::HGHWMultiBlend(v11);
      (*(void (**)(HGHWMultiBlend *, _QWORD, float, float, float, float))(*(_QWORD *)v11 + 96))(v11, 0, 9.0, 0.0, 0.0, 0.0);
      if (*(_DWORD *)(a4 + 116) == 1)
      {
        v12 = v14;
        (*(void (**)(HGHWMultiBlend *, _QWORD, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v11 + 120))(v11, 0, v14);
        (*(void (**)(HGHWMultiBlend *, uint64_t, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v11 + 120))(v11, 1, v10);
      }
      else
      {
        (*(void (**)(HGHWMultiBlend *, _QWORD, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v11 + 120))(v11, 0, v10);
        v12 = v14;
        (*(void (**)(HGHWMultiBlend *, uint64_t, HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v11 + 120))(v11, 1, v14);
      }
      *a5 = v11;
      (*(void (**)(HGHWMultiBlend *))(*(_QWORD *)v11 + 16))(v11);
      (*(void (**)(HGHWMultiBlend *))(*(_QWORD *)v11 + 24))(v11);
      if (!v12)
        return (HGGLNode *)(*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v10 + 24))(v10);
    }
    else
    {
      v13 = v14;
      if (!v14)
        return result;
      *a5 = v14;
      (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v13 + 16))(v13);
      v12 = v13;
    }
    result = (HGGLNode *)(*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v12 + 24))(v12);
    if (!v10)
      return result;
    return (HGGLNode *)(*(uint64_t (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v10 + 24))(v10);
  }
  result = OZShape::getOutlineHeliumNode(a1, (uint64_t)a2, (double *)a4, &v15);
  if (v15)
    *a5 = v15;
  return result;
}

void sub_1B301CF78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t v11;

  if (a9)
    (*(void (**)(uint64_t))(*(_QWORD *)a9 + 24))(a9);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  _Unwind_Resume(exception_object);
}

HGGLNode *OZShape::getOutlineHeliumNode@<X0>(OZShape *a1@<X0>, uint64_t a2@<X1>, double *a3@<X4>, HgcShapeSoftEdgeColorizeSecondPass **a4@<X8>)
{
  HGGLNode *v8;
  OZShape *active;
  double v10;
  float v11;
  float v12;
  float v13;
  HgcShapeSoftEdgeClrInPlace *v14;
  int v15;
  uint64_t v16;
  HgcShapeSoftEdgeClr *v17;
  _BOOL4 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  float v22;
  HGGLNode *v23;
  uint64_t v24;
  uint64_t EdgeTextureKernelType;
  HgcShapeSoftEdgeColorizeSecondPass *v26;
  HGGLNode *result;
  HGGLNode *v28;
  HGGLNode *v29;

  v8 = (HGGLNode *)HGObject::operator new(0x1B0uLL);
  HGGLNode::HGGLNode(v8, 0);
  v29 = v8;
  *a4 = 0;
  HGGLNode::hglTexParameteri((const char **)v8, (const char *)0xDE1, (char *)0x2801, 9729.0);
  HGGLNode::hglTexParameteri((const char **)v29, (const char *)0xDE1, (char *)0x2800, 9729.0);
  HGGLNode::hglTexParameteri((const char **)v29, (const char *)0xDE1, (char *)0x2802, 33071.0);
  HGGLNode::hglTexParameteri((const char **)v29, (const char *)0xDE1, (char *)0x2803, 33071.0);
  active = (OZShape *)HGGLNode::hglActiveTexture(v29, 192);
  v10 = a3[8];
  v11 = a3[5] * v10;
  v12 = v10 * a3[6];
  v13 = v10 * a3[7];
  if (OZShape::shouldRenderInPlace(active, (OZShapeRenderParams *)a3))
  {
    v14 = (HgcShapeSoftEdgeClrInPlace *)HGObject::operator new(0x1B0uLL);
    HgcShapeSoftEdgeClrInPlace::HgcShapeSoftEdgeClrInPlace(v14);
    v15 = 0;
    v16 = 1;
  }
  else
  {
    v17 = (HgcShapeSoftEdgeClr *)HGObject::operator new(0x1B0uLL);
    v14 = v17;
    v18 = v11 < 0.0;
    if (v12 < 0.0)
      v18 = 1;
    if (v13 < 0.0)
      v18 = 1;
    if (v11 > 1.0)
      v18 = 1;
    if (v12 > 1.0)
      v18 = 1;
    v15 = v13 > 1.0 || v18;
    HgcShapeSoftEdgeClr::HgcShapeSoftEdgeClr(v17);
    v16 = 0;
  }
  HGGLNode::addFragmentShader((HGRasterizer **)v29, v14);
  v22 = v10;
  if (v15)
    v19.n128_f32[0] = 1.0;
  else
    v19.n128_f32[0] = v11;
  if (v15)
    v20.n128_f32[0] = 1.0;
  else
    v20.n128_f32[0] = v12;
  if (v15)
    v21.n128_f32[0] = 1.0;
  else
    v21.n128_f32[0] = v13;
  (*(void (**)(HgcShapeSoftEdgeClrInPlace *, uint64_t, __n128, __n128, __n128))(*(_QWORD *)v14 + 96))(v14, v16, v19, v20, v21);
  HGGLNode::hglClearToBlack(v29);
  OZShape::drawShapeOutlineToHeliumNode((uint64_t)a1, a2, (uint64_t)a3, &v29, &v28);
  v23 = v28;
  if (v28)
    *a4 = v28;
  v24 = *(_QWORD *)(a2 + 56);
  EdgeTextureKernelType = OZShape::getEdgeTextureKernelType(a1, 1.0);
  (*(void (**)(HGGLNode **__return_ptr, OZShape *, uint64_t, uint64_t))(*(_QWORD *)a1 + 392))(&v28, a1, v24, EdgeTextureKernelType);
  (*(void (**)(HGGLNode *, _QWORD, HGGLNode *))(*(_QWORD *)v29 + 120))(v29, 0, v28);
  (*(void (**)(HGGLNode *, uint64_t, uint64_t))(*(_QWORD *)v28 + 136))(v28, 0xFFFFFFFFLL, 4);
  if (v15)
  {
    v26 = (HgcShapeSoftEdgeColorizeSecondPass *)HGObject::operator new(0x200uLL);
    HgcShapeSoftEdgeColorizeSecondPass::HgcShapeSoftEdgeColorizeSecondPass(v26);
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, _QWORD, HGGLNode *))(*(_QWORD *)v26 + 120))(v26, 0, v23);
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, uint64_t, float, float, float, float))(*(_QWORD *)v26 + 96))(v26, v16, v11, v12, v13, v22);
    if (v23 != v26)
    {
      if (v23)
        (*(void (**)(HGGLNode *))(*(_QWORD *)v23 + 24))(v23);
      *a4 = v26;
      (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v26 + 16))(v26);
    }
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v26 + 24))(v26);
  }
  if (v28)
    (*(void (**)(HGGLNode *))(*(_QWORD *)v28 + 24))(v28);
  (*(void (**)(HgcShapeSoftEdgeClrInPlace *))(*(_QWORD *)v14 + 24))(v14);
  result = v29;
  if (v29)
    return (HGGLNode *)(*(uint64_t (**)(HGGLNode *))(*(_QWORD *)v29 + 24))(v29);
  return result;
}

void sub_1B301D324(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  void *v11;
  uint64_t v12;

  HGObject::operator delete(v11);
  if (a9)
    (*(void (**)(uint64_t))(*(_QWORD *)a9 + 24))(a9);
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(a1);
}

uint64_t OZShape::drawToHeliumNode@<X0>(uint64_t a1@<X0>, const CMTime *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t result;
  int v11;
  int v12;
  unsigned int v13;
  BOOL v14;
  HGGLNode *v16;
  double v17;
  HgcShapeAlphaBias *v18;
  float v19;
  HGGLNode *v20;

  *a5 = 0;
  result = OZShape::isGeometricShape((OZShape *)a1);
  if ((result & 1) == 0)
  {
    result = OZDynamicCurve::getNumberOfValidKeypoints((os_unfair_lock_s *)(a1 + 496), a2);
    if ((int)result < 2)
      return result;
  }
  v11 = *(_DWORD *)(a4 + 8);
  v12 = *(_DWORD *)(a4 + 120);
  v13 = *(double *)(a4 + 16);
  v14 = v11 && v12 == 0;
  if (v14 && v13 - 1 < 2)
    return result;
  if (*(_DWORD *)(a4 + 168))
    goto LABEL_12;
  result = OZChannel::getValueAsInt((OZChannel *)(a1 + 12856), MEMORY[0x1E0CA2E68], 0.0);
  if ((_DWORD)result
    || (result = OZChannel::getValueAsInt((OZChannel *)(a1 + 14280), MEMORY[0x1E0CA2E68], 0.0), !(_DWORD)result))
  {
    v16 = 0;
  }
  else
  {
    if (v12)
    {
LABEL_12:
      result = (uint64_t)OZShape::drawCurveToHeliumNode((HGGLNode *)a1, (uint64_t)a2, a4, a3, 0, &v20);
      goto LABEL_13;
    }
    v16 = 0;
    if (v11 && !v13)
    {
      result = (uint64_t)OZShape::drawCurveToHeliumNode((HGGLNode *)a1, (uint64_t)a2, a4, a3, 1, &v20);
LABEL_13:
      v16 = v20;
      if (v20)
        *a5 = (uint64_t)v20;
    }
  }
  v17 = *(double *)(a4 + 232);
  if (v17 <= -0.0000001 || v17 >= 0.0000001)
  {
    v18 = (HgcShapeAlphaBias *)HGObject::operator new(0x1A0uLL);
    HgcShapeAlphaBias::HgcShapeAlphaBias(v18);
    (*(void (**)(HgcShapeAlphaBias *, _QWORD, HGGLNode *))(*(_QWORD *)v18 + 120))(v18, 0, v16);
    v19 = exp(v17 / 100.0 * 0.693147181);
    (*(void (**)(HgcShapeAlphaBias *, _QWORD, float, float, float, float))(*(_QWORD *)v18 + 96))(v18, 0, v19, 0.0, 0.0, 0.0);
    v16 = v18;
  }
  else
  {
    if (!v16)
      return result;
    (*(void (**)(HGGLNode *))(*(_QWORD *)v16 + 16))(v16);
  }
  result = *a5;
  if ((HGGLNode *)*a5 == v16)
    return (*(uint64_t (**)(HGGLNode *))(*(_QWORD *)v16 + 24))(v16);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  *a5 = (uint64_t)v16;
  return result;
}

void sub_1B301D654(_Unwind_Exception *exception_object)
{
  _QWORD *v1;

  if (*v1)
    (*(void (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1);
  _Unwind_Resume(exception_object);
}

HGGLNode *OZShape::drawCurveToHeliumNode@<X0>(HGGLNode *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W5>, HGGLNode **a6@<X8>)
{
  OZShape *v10;
  uint64_t v12;
  HGGLNode *v13;
  uint64_t v14;
  uint64_t EdgeTextureKernelType;
  _BOOL4 v16;
  double v17;
  float v18;
  float v19;
  float v20;
  _BOOL4 v27;
  HgcShapeSoftEdgeClr *v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  float v32;
  float v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  GLUtesselator *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  float v45;
  float v46;
  HgcShapeSoftEdgeClr *v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  unsigned int v55;
  unsigned int v56;
  unint64_t v57;
  int v58;
  unint64_t i;
  unsigned int v60;
  unsigned int v61;
  char *v62;
  char *v63;
  _BOOL4 shouldDrawSoftEdges;
  char *v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  int v73;
  uint64_t shouldDrawAntialiasingOnFill;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  HgcShapeSoftEdgeColorizeSecondPass *v81;
  HgcShapeSoftEdgeColorizeSecondPass *v82;
  int v83;
  _BOOL4 v84;
  HGGLNode **v85;
  HgcShapeSoftEdgeClr *v86;
  uint64_t v87;
  __int128 data;
  uint64_t v89;
  _BYTE v90[48];
  __int128 v91;
  __int128 v92;
  _BYTE v93[48];
  void **v94;
  __int128 v95;
  __int128 v96;
  char *v97;
  char *v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  HGGLNode *v105[2];

  v10 = result;
  *a6 = 0;
  if (*(_DWORD *)(a3 + 180)
    && (result = (HGGLNode *)OZChannel::getValueAsInt((OZChannel *)((char *)result + 1072), MEMORY[0x1E0CA2E68], 0.0),
        (_DWORD)result != 4))
  {
    v12 = a3 + 760;
  }
  else
  {
    v12 = a3 + 368;
  }
  if (*(_QWORD *)(v12 + 216) == *(_QWORD *)(v12 + 224)
    || *(_QWORD *)(v12 + 240) == *(_QWORD *)(v12 + 248)
    || a5
    || *(_QWORD *)(v12 + 192) == *(_QWORD *)(v12 + 200)
    || !*(_DWORD *)(a3 + 120))
  {
    return result;
  }
  v85 = a6;
  v13 = (HGGLNode *)HGObject::operator new(0x1B0uLL);
  HGGLNode::HGGLNode(v13, 0);
  v105[0] = v13;
  if (v13)
  {
    *a6 = v13;
    (*(void (**)(HGGLNode *))(*(_QWORD *)v13 + 16))(v13);
  }
  v14 = *(_QWORD *)(a2 + 56);
  EdgeTextureKernelType = OZShape::getEdgeTextureKernelType(v10, *(double *)(a3 + 224));
  (*(void (**)(uint64_t *__return_ptr, OZShape *, uint64_t, uint64_t))(*(_QWORD *)v10 + 392))(&v104, v10, v14, EdgeTextureKernelType);
  (*(void (**)(HGGLNode *, _QWORD, uint64_t))(*(_QWORD *)v105[0] + 120))(v105[0], 0, v104);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v104 + 136))(v104, 0xFFFFFFFFLL, 4);
  v97 = 0;
  v98 = 0;
  v99 = 0;
  HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v100);
  HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v102);
  HGGLNode::hglTexParameteri((const char **)v105[0], (const char *)0xDE1, (char *)0x2801, 9729.0);
  HGGLNode::hglTexParameteri((const char **)v105[0], (const char *)0xDE1, (char *)0x2800, 9729.0);
  HGGLNode::hglTexParameteri((const char **)v105[0], (const char *)0xDE1, (char *)0x2802, 33071.0);
  HGGLNode::hglTexParameteri((const char **)v105[0], (const char *)0xDE1, (char *)0x2803, 33071.0);
  HGGLNode::hglActiveTexture(v105[0], 192);
  v16 = !*(_BYTE *)(v12 + 185) || *(_BYTE *)(v12 + 186) || *(_BYTE *)(v12 + 187) == 0;
  v17 = *(double *)(a3 + 152);
  v18 = *(double *)(a3 + 128) * v17;
  v19 = v17 * *(double *)(a3 + 136);
  v20 = v17 * *(double *)(a3 + 144);
  _ZF = v20 <= 1.0 && v19 <= 1.0 && v20 >= 0.0 && v19 >= 0.0 && v18 >= 0.0 && v18 <= 1.0 || !v16;
  v27 = !_ZF
     && (*(_DWORD *)(a3 + 124) != 1
      || !*(_DWORD *)(a3 + 120)
      || !*(_DWORD *)(a3 + 8) && !OZShape::shouldDrawSoftEdges(v10, (const OZShapeRenderParams *)a3));
  v28 = (HgcShapeSoftEdgeClr *)HGObject::operator new(0x1B0uLL);
  HgcShapeSoftEdgeClr::HgcShapeSoftEdgeClr(v28);
  HGGLNode::addFragmentShader((HGRasterizer **)v105[0], v28);
  v32 = v17;
  v86 = v28;
  if (*(_DWORD *)(a3 + 124) != 1 || !*(_DWORD *)(a3 + 120))
  {
    v33 = 1.0;
    v29.n128_u32[0] = 1.0;
    v30.n128_u32[0] = 1.0;
    v31.n128_u32[0] = 1.0;
    if (v27)
      goto LABEL_48;
    goto LABEL_47;
  }
  v33 = 1.0;
  if (*(_DWORD *)(a3 + 8))
  {
    v29.n128_u32[0] = 1.0;
    v30.n128_u32[0] = 1.0;
    v31.n128_u32[0] = 1.0;
    goto LABEL_48;
  }
  shouldDrawSoftEdges = OZShape::shouldDrawSoftEdges(v10, (const OZShapeRenderParams *)a3);
  v29.n128_u32[0] = 1.0;
  v30.n128_u32[0] = 1.0;
  v31.n128_u32[0] = 1.0;
  if (!v27 && !shouldDrawSoftEdges)
  {
LABEL_47:
    v33 = v18;
    v29.n128_f32[0] = v19;
    v30.n128_f32[0] = v20;
    v31.n128_f32[0] = v32;
  }
LABEL_48:
  (*(void (**)(HgcShapeSoftEdgeClr *, _QWORD, float, __n128, __n128, __n128))(*(_QWORD *)v28 + 96))(v28, 0, v33, v29, v30, v31);
  HGGLNode::hglClearToBlack(v105[0]);
  v83 = v16;
  v84 = v27;
  if (*(_BYTE *)(v12 + 185) && !*(_BYTE *)(v12 + 186))
  {
    v49 = (*(_QWORD *)(v12 + 224) - *(_QWORD *)(v12 + 216)) >> 3;
    if (*(_DWORD *)(a3 + 168))
      v50 = (v49 + 1);
    else
      v50 = v49;
    v51 = 3 * v50 - 3;
    HGArray<__simd128_float32_t,(HGFormat)28>::resize(&v100, v51);
    HGArray<__simd128_float32_t,(HGFormat)28>::resize(&v102, v51);
    __asm { FMOV            V2.2D, #0.5 }
    *(float32x2_t *)&data = vcvt_f32_f64(vaddq_f64(*(float64x2_t *)(v12 + 24), vmulq_f64(*(float64x2_t *)(v12 + 40), _Q2)));
    *((_QWORD *)&data + 1) = 0x3F80000000000000;
    PCMatrix44Tmpl<double>::transform<float>((double *)a4, (float *)&data, (uint64_t)&data);
    *(float *)&v55 = **(double **)(v12 + 216);
    *(float *)&v56 = **(double **)(v12 + 240);
    *(_QWORD *)&v96 = __PAIR64__(v56, v55);
    *((_QWORD *)&v96 + 1) = 0x3F80000000000000;
    PCMatrix44Tmpl<double>::transform<float>((double *)a4, (float *)&v96, (uint64_t)&v96);
    if ((int)v50 >= 2)
    {
      v57 = (uint64_t)(*(_QWORD *)(v12 + 200) - *(_QWORD *)(v12 + 192)) >> 3;
      v58 = 1;
      for (i = 1; i != v50; ++i)
      {
        *(float *)&v60 = *(double *)(*(_QWORD *)(v12 + 216) + 8 * (i % v57));
        *(float *)&v61 = *(double *)(*(_QWORD *)(v12 + 240) + 8 * (i % v57));
        *(_QWORD *)&v95 = __PAIR64__(v61, v60);
        *((_QWORD *)&v95 + 1) = 0x3F80000000000000;
        PCMatrix44Tmpl<double>::transform<float>((double *)a4, (float *)&v95, (uint64_t)&v95);
        *(_OWORD *)(*(_QWORD *)(v100 + 16) + *(int *)(v100 + 4) * (uint64_t)(v58 - 1) + v101) = v96;
        *(_OWORD *)(*(_QWORD *)(v100 + 16) + *(int *)(v100 + 4) * (uint64_t)v58 + v101) = v95;
        *(_OWORD *)(*(_QWORD *)(v100 + 16) + *(int *)(v100 + 4) * (uint64_t)(v58 + 1) + v101) = data;
        *(_OWORD *)(*(_QWORD *)(v102 + 16) + *(int *)(v102 + 4) * (uint64_t)(v58 + 1) + v103) = xmmword_1B3565CA0;
        *(_OWORD *)(*(_QWORD *)(v102 + 16) + *(int *)(v102 + 4) * (uint64_t)v58 + v103) = xmmword_1B3565CA0;
        *(_OWORD *)(*(_QWORD *)(v102 + 16) + *(int *)(v102 + 4) * (uint64_t)(v58 - 1) + v103) = xmmword_1B3565CA0;
        v96 = v95;
        v58 += 3;
      }
    }
    v62 = v98;
    if ((unint64_t)v98 >= v99)
    {
      v65 = v97;
      v66 = 0xAAAAAAAAAAAAAAABLL * ((v98 - v97) >> 2);
      v67 = v66 + 1;
      v48 = (uint64_t *)v85;
      if (v66 + 1 > 0x1555555555555555)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      if (0x5555555555555556 * ((uint64_t)(v99 - (_QWORD)v97) >> 2) > v67)
        v67 = 0x5555555555555556 * ((uint64_t)(v99 - (_QWORD)v97) >> 2);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v99 - (_QWORD)v97) >> 2) >= 0xAAAAAAAAAAAAAAALL)
        v68 = 0x1555555555555555;
      else
        v68 = v67;
      if (v68)
      {
        v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Vec3f>>((uint64_t)&v99, v68);
        v65 = v97;
        v62 = v98;
      }
      else
      {
        v69 = 0;
      }
      v70 = &v69[12 * v66];
      v71 = &v69[12 * v68];
      *(_QWORD *)v70 = 4;
      *((_DWORD *)v70 + 2) = v51;
      v63 = v70 + 12;
      if (v62 != v65)
      {
        do
        {
          v72 = *(_QWORD *)(v62 - 12);
          v62 -= 12;
          v73 = *((_DWORD *)v62 + 2);
          *(_QWORD *)(v70 - 12) = v72;
          v70 -= 12;
          *((_DWORD *)v70 + 2) = v73;
        }
        while (v62 != v65);
        v65 = v97;
      }
      v97 = v70;
      v98 = v63;
      v99 = (unint64_t)v71;
      if (v65)
        operator delete(v65);
    }
    else
    {
      *(_QWORD *)v98 = 4;
      *((_DWORD *)v62 + 2) = v51;
      v63 = v62 + 12;
      v48 = (uint64_t *)v85;
    }
    v98 = v63;
    v47 = v86;
  }
  else
  {
    data = 0uLL;
    *(_QWORD *)&v93[40] = 0x3FF0000000000000;
    *(_QWORD *)v93 = 0x3FF0000000000000;
    *(_QWORD *)&v90[40] = 0x3FF0000000000000;
    v89 = 0;
    *(_QWORD *)v90 = 0x3FF0000000000000;
    memset(&v90[8], 0, 32);
    v91 = 0u;
    v92 = 0u;
    memset(&v93[8], 0, 32);
    if (v90 != (_BYTE *)a4)
    {
      v34 = *(_OWORD *)(a4 + 80);
      v92 = *(_OWORD *)(a4 + 64);
      *(_OWORD *)v93 = v34;
      v35 = *(_OWORD *)(a4 + 112);
      *(_OWORD *)&v93[16] = *(_OWORD *)(a4 + 96);
      *(_OWORD *)&v93[32] = v35;
      v36 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)v90 = *(_OWORD *)a4;
      *(_OWORD *)&v90[16] = v36;
      v37 = *(_OWORD *)(a4 + 48);
      *(_OWORD *)&v90[32] = *(_OWORD *)(a4 + 32);
      v91 = v37;
    }
    v94 = (void **)&v97;
    v38 = gluNewTess();
    gluTessCallback(v38, 0x1870Au, (GLvoid (*)(void))heBeginCallback);
    gluTessCallback(v38, 0x1870Bu, (GLvoid (*)(void))heVertexCallback);
    gluTessCallback(v38, 0x1870Eu, (GLvoid (*)(void))heShapeTesselationEdgeCallback);
    gluTessCallback(v38, 0x1870Cu, (GLvoid (*)(void))heShapeTesselationEndCallback);
    gluTessCallback(v38, 0x1870Fu, (GLvoid (*)(void))heShapeTesselationCallback);
    gluTessProperty(v38, 0x1872Cu, 100131.0);
    gluTessBeginPolygon(v38, &data);
    gluTessBeginContour(v38);
    v87 = a2;
    if (*(_DWORD *)(a3 + 168))
      v39 = ((*(_QWORD *)(v12 + 224) - *(_QWORD *)(v12 + 216)) >> 3) + 1;
    else
      v39 = (*(_QWORD *)(v12 + 224) - *(_QWORD *)(v12 + 216)) >> 3;
    v40 = operator new[]();
    v41 = v40;
    if (v39 >= 1)
    {
      v42 = 0;
      v43 = (*(_QWORD *)(v12 + 224) - *(_QWORD *)(v12 + 216)) >> 3;
      v44 = v40;
      do
      {
        v45 = *(double *)(*(_QWORD *)(v12 + 216) + 8 * (v42 % (int)v43));
        *(double *)v44 = v45;
        v46 = *(double *)(*(_QWORD *)(v12 + 240) + 8 * (v42 % (int)v43));
        *(double *)(v44 + 8) = v46;
        *(_QWORD *)(v44 + 16) = 0;
        gluTessVertex(v38, (GLdouble *)v44, (GLvoid *)v44);
        ++v42;
        v44 += 24;
      }
      while (v39 != v42);
    }
    gluTessEndContour(v38);
    gluTessEndPolygon(v38);
    gluDeleteTess(v38);
    MEMORY[0x1B5E2914C](v41, 0x1000C8000313F17);
    v47 = v86;
    a2 = v87;
    if ((_QWORD)data)
    {
      *((_QWORD *)&data + 1) = data;
      operator delete((void *)data);
    }
    v48 = (uint64_t *)v85;
  }
  shouldDrawAntialiasingOnFill = OZShape::shouldDrawSoftEdges(v10, (const OZShapeRenderParams *)a3);
  if ((_DWORD)shouldDrawAntialiasingOnFill)
  {
    shouldDrawAntialiasingOnFill = OZShape::shouldDrawAntialiasingOnFill(v10, (const OZShapeRenderParams *)a3);
    if ((_DWORD)shouldDrawAntialiasingOnFill)
    {
      if (*(_BYTE *)(a3 + 176))
      {
        v75 = !*(_BYTE *)(v12 + 185) || *(_BYTE *)(v12 + 186) || *(_BYTE *)(v12 + 187) == 0;
        OZShape::drawAntialiasedBordersToHeliumNode((OZShapeRenderParams *)a3, v10, a2, v12, v75, v105, (uint64_t *)&v97, (HGGLNode **)&data);
        shouldDrawAntialiasingOnFill = *v48;
        v80 = data;
        if (*v48 == (_QWORD)data)
        {
          if (shouldDrawAntialiasingOnFill)
            shouldDrawAntialiasingOnFill = (*(uint64_t (**)(uint64_t))(*(_QWORD *)shouldDrawAntialiasingOnFill
                                                                              + 24))(shouldDrawAntialiasingOnFill);
        }
        else
        {
          if (shouldDrawAntialiasingOnFill)
          {
            shouldDrawAntialiasingOnFill = (*(uint64_t (**)(uint64_t))(*(_QWORD *)shouldDrawAntialiasingOnFill
                                                                              + 24))(shouldDrawAntialiasingOnFill);
            v80 = data;
          }
          *v48 = v80;
        }
      }
    }
    else
    {
      v76 = *(_QWORD *)(a2 + 56);
      v77 = OZShape::getEdgeTextureKernelType(v10, *(double *)(a3 + 224));
      (*(void (**)(__int128 *__return_ptr, OZShape *, uint64_t, uint64_t))(*(_QWORD *)v10 + 392))(&data, v10, v76, v77);
      OZShape::drawOutlinePolygonsToHeliumNode(v10, (OZShapeRenderParams *)a3, (uint64_t *)(v12 + 312), a2, v12, 0, 0, v83, (HGGLNode **)&v96, *(double *)(a3 + 224), v105, &data, (double *)a4, (uint64_t *)&v97);
      v78 = *v48;
      v79 = v96;
      if (*v48 == (_QWORD)v96)
      {
        if (v78)
          (*(void (**)(uint64_t))(*(_QWORD *)v78 + 24))(v78);
      }
      else
      {
        if (v78)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v78 + 24))(v78);
          v79 = v96;
        }
        *v48 = v79;
      }
      shouldDrawAntialiasingOnFill = data;
      if ((_QWORD)data)
        shouldDrawAntialiasingOnFill = (*(uint64_t (**)(_QWORD))(*(_QWORD *)data + 24))(data);
    }
  }
  OZShape::drawVertexArrayList((OZShape *)shouldDrawAntialiasingOnFill, (const char **)v105[0], (OZShapeVertexArrayData *)&v97);
  if (v84)
  {
    v81 = (HgcShapeSoftEdgeColorizeSecondPass *)HGObject::operator new(0x200uLL);
    HgcShapeSoftEdgeColorizeSecondPass::HgcShapeSoftEdgeColorizeSecondPass(v81);
    v82 = (HgcShapeSoftEdgeColorizeSecondPass *)*v48;
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, _QWORD, uint64_t))(*(_QWORD *)v81 + 120))(v81, 0, *v48);
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, _QWORD, float, float, float, float))(*(_QWORD *)v81 + 96))(v81, 0, v18, v19, v20, v32);
    if (v82 != v81)
    {
      if (v82)
        (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v82 + 24))(v82);
      *v48 = (uint64_t)v81;
      (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v81 + 16))(v81);
    }
    (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *))(*(_QWORD *)v81 + 24))(v81);
  }
  (*(void (**)(HgcShapeSoftEdgeClr *))(*(_QWORD *)v47 + 24))(v47);
  if (v102)
    HGArrayData::Release(v102);
  if (v100)
    HGArrayData::Release(v100);
  if (v97)
  {
    v98 = v97;
    operator delete(v97);
  }
  if (v104)
    (*(void (**)(uint64_t))(*(_QWORD *)v104 + 24))(v104);
  result = v105[0];
  if (v105[0])
    return (HGGLNode *)(*(uint64_t (**)(HGGLNode *))(*(_QWORD *)v105[0] + 24))(v105[0]);
  return result;
}

void sub_1B301E18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;

  if (__p)
    (*(void (**)(void *))(*(_QWORD *)__p + 24))(__p);
  if (a16)
    (*(void (**)(uint64_t))(*(_QWORD *)a16 + 24))(a16);
  OZShapeVertexArrayData::~OZShapeVertexArrayData((OZShapeVertexArrayData *)(v20 - 208));
  v22 = *(_QWORD *)(v20 - 152);
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  v23 = *(_QWORD *)(v20 - 144);
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
  if (*a15)
    (*(void (**)(_QWORD))(*(_QWORD *)*a15 + 24))(*a15);
  _Unwind_Resume(a1);
}

uint64_t OZShape::getEdgeTextureHeliumNode@<X0>(LiEdgeTexture *a1@<X2>, HGBitmapLoader **a2@<X8>)
{
  return OZShapeEdgeTexture::getHeliumNode(a1, a2);
}

uint64_t OZShape::getEdgeTextureKernelType(OZShape *this, double a2)
{
  if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 13872), MEMORY[0x1E0CA2E68], 0.0))
  {
    if (a2 <= 0.0)
      return 5;
    else
      return 4;
  }
  else if (OZChannel::getValueAsInt((OZChannel *)((char *)this + 11816), MEMORY[0x1E0CA2E68], 0.0) == 2)
  {
    return 6;
  }
  else
  {
    return 3;
  }
}

uint64_t OZShape::drawAntialiasedBordersToHeliumNode@<X0>(OZShapeRenderParams *a1@<X2>, OZShape *a2@<X0>, uint64_t a3@<X1>, uint64_t a4@<X3>, int a5@<W4>, HGGLNode **a6@<X5>, uint64_t *a7@<X6>, HGGLNode **a8@<X8>)
{
  uint64_t result;
  uint64_t v9;

  v9 = 0;
  OZShape::drawOutlinePolygonsToHeliumNode(a2, a1, (uint64_t *)(a4 + 288), a3, a4, 0, 1, a5, a8, 2.0, a6, &v9, 0, a7);
  result = v9;
  if (v9)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  return result;
}

void sub_1B301E468(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 - 24);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  _Unwind_Resume(exception_object);
}

const char *OZShape::drawVertexArrayList(OZShape *this, const char **a2, OZShapeVertexArrayData *a3)
{
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  HGGLNode::hglEnableClientState(a2, 32884);
  HGGLNode::hglEnableClientState(a2, 32888);
  HGGLNode::hglTexCoordArray((HGArrayDataRef **)a2, (OZShapeVertexArrayData *)((char *)a3 + 40));
  HGGLNode::hglVertexArray((HGGLNode *)a2, (OZShapeVertexArrayData *)((char *)a3 + 24), v5);
  v6 = *(_QWORD *)a3;
  if ((int)(-1431655765 * ((*((_QWORD *)a3 + 1) - *(_QWORD *)a3) >> 2)) >= 1)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      HGGLNode::hglDrawArrays((HGGLNode *)a2, *(_DWORD *)(v6 + v7), *(_DWORD *)(v6 + v7 + 4), *(_DWORD *)(v6 + v7 + 8));
      ++v8;
      v6 = *(_QWORD *)a3;
      v7 += 12;
    }
    while (v8 < (int)(-1431655765 * ((*((_QWORD *)a3 + 1) - *(_QWORD *)a3) >> 2)));
  }
  HGGLNode::hglDisableClientState(a2, 32884);
  return HGGLNode::hglDisableClientState(a2, 32888);
}

void OZShape::drawOutlineToHeliumNode(OZShape *a1@<X0>, uint64_t a2@<X1>, double *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, HGGLNode **a6@<X5>, HGGLNode **a7@<X8>)
{
  OZShape *v14;
  HGGLNode *v15;
  HGGLNode *v16;
  uint64_t v17;
  void *__p;
  void *v19;
  uint64_t v20;
  HGArrayData *v21;
  HGArrayData *v22;

  __p = 0;
  v19 = 0;
  v20 = 0;
  HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v21);
  HGArray<__simd128_float32_t,(HGFormat)28>::HGArray((uint64_t)&v22);
  v17 = 0;
  OZShape::drawOutlinePolygonsToHeliumNode(a1, (OZShapeRenderParams *)a3, (uint64_t *)(a4 + 336), a2, a4, 1, 0, a5, &v16, a3[2], a6, &v17, 0, (uint64_t *)&__p);
  v14 = v16;
  if (v16)
    v14 = (OZShape *)(*(uint64_t (**)(HGGLNode *))(*(_QWORD *)v16 + 24))(v16);
  OZShape::drawVertexArrayList(v14, (const char **)*a6, (OZShapeVertexArrayData *)&__p);
  v15 = *a6;
  *a7 = *a6;
  if (v15)
    (*(void (**)(HGGLNode *))(*(_QWORD *)v15 + 16))(v15);
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  if (v22)
    HGArrayData::Release((uint64_t)v22);
  if (v21)
    HGArrayData::Release((uint64_t)v21);
  if (__p)
  {
    v19 = __p;
    operator delete(__p);
  }
}

void sub_1B301E688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, HGArrayData *a19)
{
  if (a19)
    HGArrayData::Release((uint64_t)a19);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void OZShape::drawShapeOutlineToHeliumNode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, HGGLNode **a4@<X4>, HGGLNode **a5@<X8>)
{
  HGGLNode *v10;
  _BYTE *v11;
  int v12;
  HGGLNode *v13;
  HGGLNode *v14;

  v10 = *a4;
  *a5 = *a4;
  if (v10)
    (*(void (**)(HGGLNode *))(*(_QWORD *)v10 + 16))(v10);
  if (*(_DWORD *)(a3 + 180)
    && OZChannel::getValueAsInt((OZChannel *)(a1 + 1072), MEMORY[0x1E0CA2E68], 0.0) != 4)
  {
    v11 = (_BYTE *)(a3 + 760);
  }
  else if (*(_DWORD *)(a3 + 168) || !OZShape::isWriteOnEffectEnabled(a1, a3))
  {
    v11 = (_BYTE *)(a3 + 368);
  }
  else
  {
    v11 = *(_BYTE **)(a3 + 752);
  }
  if (*(double *)(a3 + 16) > 0.0 && *(_DWORD *)(a3 + 8))
  {
    v12 = !v11[185] || v11[186] || v11[187] == 0;
    OZShape::drawOutlineToHeliumNode((OZShape *)a1, a2, (double *)a3, (uint64_t)v11, v12, a4, &v14);
    v13 = v14;
    if (v10 == v14)
    {
      if (v10)
        (*(void (**)(HGGLNode *))(*(_QWORD *)v10 + 24))(v10);
    }
    else
    {
      if (v10)
        (*(void (**)(HGGLNode *))(*(_QWORD *)v10 + 24))(v10);
      *a5 = v13;
    }
  }
}

void sub_1B301E820(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::HRotoshapeGradientBlend::~HRotoshapeGradientBlend(HGNode *this)
{
  void *v1;

  HgcShapeGradientBlend::~HgcShapeGradientBlend(this);
  HGObject::operator delete(v1);
}

uint64_t `anonymous namespace'::HRotoshapeGradientBlend::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGNode *Input;
  uint64_t DOD;
  uint64_t v9;
  uint64_t v10;
  HGNode *v11;
  uint64_t v12;
  uint64_t v13;

  if (a3 >= 2)
    return 0;
  Input = HGRenderer::GetInput(a2, this, 0);
  DOD = HGRenderer::GetDOD(a2, Input);
  v10 = v9;
  v11 = HGRenderer::GetInput(a2, this, 1u);
  v12 = HGRenderer::GetDOD(a2, v11);
  return HGRectIntersection(DOD, v10, v12, v13);
}

uint64_t `anonymous namespace'::HRotoshapeGradientBlend::GetROI(_anonymous_namespace_::HRotoshapeGradientBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 <= 1)
    return *(_QWORD *)&a4.var0;
  else
    return 0;
}

void sub_1B301EA00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  uint64_t v10;

  PCString::~PCString(&a10);
  MEMORY[0x1B5E29170](v10, 0x10E1C409E4CE797);
  _Unwind_Resume(a1);
}

void OZGradientData::OZGradientData(OZGradientData *this, int a2)
{
  uint64_t v4;
  unint64_t *v5;

  HGObject::HGObject(this);
  *(_QWORD *)v4 = off_1E65EAAE8;
  *(_DWORD *)(v4 + 12) = a2;
  *((_QWORD *)this + 3) = HGMemory::allocate((HGMemory *)(4 * a2), (unint64_t *)this + 2, v5);
}

void sub_1B301EAAC(_Unwind_Exception *a1)
{
  HGObject *v1;

  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void OZGradientData::~OZGradientData(HGMemory **this, void *a2)
{
  *this = (HGMemory *)off_1E65EAAE8;
  HGMemory::release(this[3], a2);
  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;

  OZGradientData::~OZGradientData(this, a2);
  HGObject::operator delete(v2);
}

void OZGradient::OZGradient(OZGradient *this, OZChannelGradient *a2, uint64_t a3, CGColorSpace *a4, uint64_t a5)
{
  int v6;
  uint64_t v8;
  uint64_t v9;
  OZGradientData **v10;
  OZGradientData *v11;
  OZGradientData *v12;

  v6 = (int)a4;
  v8 = *((_QWORD *)a2 + 1);
  *(_QWORD *)this = v8;
  *(_QWORD *)((char *)this + *(_QWORD *)(v8 - 24)) = *((_QWORD *)a2 + 2);
  v9 = *(_QWORD *)a2;
  *(_QWORD *)this = *(_QWORD *)a2;
  *(_QWORD *)((char *)this + *(_QWORD *)(v9 - 24)) = *((_QWORD *)a2 + 3);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v10 = (OZGradientData **)((char *)this + 8);
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 1120403456;
  *((_QWORD *)this + 4) = a3;
  *((_BYTE *)this + 40) = 0;
  *((_QWORD *)this + 21) = 0x3FF0000000000000;
  *((_QWORD *)this + 16) = 0x3FF0000000000000;
  *((_QWORD *)this + 11) = 0x3FF0000000000000;
  *((_QWORD *)this + 6) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  PCWorkingColorVector::PCWorkingColorVector((OZGradient *)((char *)this + 184));
  *((_QWORD *)this + 25) = a5;
  v11 = (OZGradientData *)HGObject::operator new(0x20uLL);
  OZGradientData::OZGradientData(v11, 4 * v6);
  v12 = *v10;
  if (*v10 == v11)
  {
    if (v11)
      (*(void (**)(OZGradientData *))(*(_QWORD *)v11 + 24))(v11);
  }
  else
  {
    if (v12)
      (*(void (**)(OZGradientData *))(*(_QWORD *)v12 + 24))(v12);
    *v10 = v11;
  }
  *((_QWORD *)this + 22) = 0x3FF0000000000000;
}

void sub_1B301EC0C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  _QWORD *v2;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  if (*v2)
    (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 24))(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t OZGradient::OZGradient(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = a2[1];
  *(_QWORD *)a1 = v5;
  *(_QWORD *)(a1 + *(_QWORD *)(v5 - 24)) = a2[2];
  v6 = *a2;
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = a2[3];
  v7 = a3[1];
  *(_QWORD *)(a1 + 8) = v7;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
  *(_QWORD *)(a1 + 16) = a3[2];
  *(_QWORD *)(a1 + 24) = a3[3];
  *(_QWORD *)(a1 + 32) = a3[4];
  *(_BYTE *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 168) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 128) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 88) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 48) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 176) = a3[22];
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)(a1 + 184));
  *(_QWORD *)(a1 + 200) = a3[25];
  return a1;
}

void sub_1B301ED28(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 8);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  _Unwind_Resume(exception_object);
}

void OZGradient::~OZGradient(OZGradient *this, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a2;
  *(_QWORD *)this = *a2;
  *(_QWORD *)((char *)this + *(_QWORD *)(v2 - 24)) = a2[3];
  v3 = *((_QWORD *)this + 1);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
}

void OZGradient::~OZGradient(OZGradient *this)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 208) = &off_1E65EB048;
  *(_BYTE *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
}

{
  uint64_t v1;

  *(_QWORD *)(v1 + 208) = &off_1E65EB048;
  *(_BYTE *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
  JUMPOUT(0x1B5E29170);
}

void `virtual thunk to'OZGradient::~OZGradient(OZGradient *this)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 208) = &off_1E65EB048;
  *(_BYTE *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
}

{
  OZGradient::~OZGradient((OZGradient *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24)));
}

void OZGradient::init(OZGradient *this, CGColorSpace *a2)
{
  *((_QWORD *)this + 25) = a2;
  OZChannelGradient::getGradient(*((uint64_t ***)this + 4), MEMORY[0x1E0CA2E68], 1, a2, *(_QWORD *)(*((_QWORD *)this + 1) + 24), ((double)*(int *)(*((_QWORD *)this + 1) + 12) * 0.25), 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

void OZGradient::getHash(OZGradient *this, CMTime *a2)
{
  OZChannelGradient::getGradientHash(*((_QWORD *)this + 4));
}

uint64_t OZGradient::update(OZGradient *this, CMTime *a2)
{
  uint64_t v4;
  int32x4_t v6;

  (*(void (**)(int32x4_t *__return_ptr))(*(_QWORD *)this + 40))(&v6);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v6, *(int32x4_t *)((char *)this + 184))))) & 1) == 0
    && *((_BYTE *)this + 40))
  {
    return 0;
  }
  v4 = 1;
  OZChannelGradient::getGradient(*((uint64_t ***)this + 4), a2, 1, *((CGColorSpace **)this + 25), *(_QWORD *)(*((_QWORD *)this + 1) + 24), ((double)*(int *)(*((_QWORD *)this + 1) + 12) * 0.25), 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
  *((_BYTE *)this + 40) = 1;
  *(int32x4_t *)((char *)this + 184) = v6;
  return v4;
}

void OZGradient1D::OZGradient1D(OZGradient1D *this, OZChannelGradient *a2, uint64_t a3, CGColorSpace *a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v7;

  OZGradient::OZGradient(this, (OZChannelGradient *)((char *)a2 + 8), a3, a4, a5);
  v6 = *(_QWORD *)a2;
  *v7 = *(_QWORD *)a2;
  *(_QWORD *)((char *)v7 + *(_QWORD *)(v6 - 24)) = *((_QWORD *)a2 + 5);
  (*(void (**)(_QWORD *, _QWORD))(*v7 + 16))(v7, v7[25]);
}

void sub_1B301F01C(_Unwind_Exception *a1)
{
  OZGradient *v1;
  uint64_t *v2;

  OZGradient::~OZGradient(v1, v2);
  _Unwind_Resume(a1);
}

void OZGradient1D::OZGradient1D(OZGradient1D *this, OZChannelGradient *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  *((_QWORD *)this + 26) = &off_1E65EB048;
  *((_QWORD *)this + 27) = 0;
  *((_BYTE *)this + 224) = 1;
  OZGradient::OZGradient(this, (OZChannelGradient *)off_1E65EAC40, (uint64_t)a2, a3, (uint64_t)a4);
  *(_QWORD *)this = &off_1E65EABC8;
  *((_QWORD *)this + 26) = &unk_1E65EAC20;
  OZChannelGradient::getGradient(*((uint64_t ***)this + 4), MEMORY[0x1E0CA2E68], 1, *((CGColorSpace **)this + 25), *(_QWORD *)(*((_QWORD *)this + 1) + 24), ((double)*(int *)(*((_QWORD *)this + 1) + 12) * 0.25), 0, (PCToneMapMethod *)&kPCNoToneMapMethod);
}

void sub_1B301F0E4(_Unwind_Exception *a1)
{
  uint64_t v1;
  PC_Sp_counted_base **v2;
  uint64_t v3;

  OZGradient::~OZGradient((OZGradient *)v1, (uint64_t *)off_1E65EAC40);
  *(_QWORD *)(v1 + 208) = v3;
  *(_BYTE *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t OZGradient1D::OZGradient1D(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t v6;

  v5 = (_QWORD *)OZGradient::OZGradient(a1, a2 + 1, a3);
  v6 = *a2;
  *v5 = *a2;
  *(_QWORD *)((char *)v5 + *(_QWORD *)(v6 - 24)) = a2[5];
  (*(void (**)(_QWORD *, _QWORD))(*v5 + 16))(v5, v5[25]);
  return a1;
}

void sub_1B301F174(_Unwind_Exception *a1)
{
  OZGradient *v1;
  uint64_t *v2;

  OZGradient::~OZGradient(v1, v2);
  _Unwind_Resume(a1);
}

void OZGradient1D::~OZGradient1D(OZGradient1D *this)
{
  uint64_t v1;

  OZGradient::~OZGradient(this, (uint64_t *)off_1E65EAC40);
  *(_QWORD *)(v1 + 208) = &off_1E65EB048;
  *(_BYTE *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
}

{
  uint64_t v1;

  OZGradient::~OZGradient(this, (uint64_t *)off_1E65EAC40);
  *(_QWORD *)(v1 + 208) = &off_1E65EB048;
  *(_BYTE *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
  JUMPOUT(0x1B5E29170);
}

void `virtual thunk to'OZGradient1D::~OZGradient1D(OZGradient1D *this)
{
  uint64_t v1;

  OZGradient::~OZGradient((OZGradient1D *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24)), (uint64_t *)off_1E65EAC40);
  *(_QWORD *)(v1 + 208) = &off_1E65EB048;
  *(_BYTE *)(v1 + 224) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 216));
}

{
  OZGradient1D::~OZGradient1D((OZGradient1D *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24)));
}

HGColorConform *OZGradient1D::getHeliumLUT@<X0>(OZGradient1D *this@<X0>, CGColorSpace *a2@<X1>, HGColorConform **a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  HGBitmap *v10;
  HGBitmapLoader *v11;
  HGColorConform *result;
  HGColorConform *v13;
  HGColorConform *v14;

  v6 = HGRectMake4i(0, 0, ((double)*(int *)(*((_QWORD *)this + 1) + 12) * 0.25), 1u);
  v8 = v7;
  v9 = *(_QWORD *)(*((_QWORD *)this + 1) + 24);
  v10 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGTexture::HGTexture((uint64_t)v10, v6, v8, 28, v9);
  HGBitmap::SetStorage(v10, *((HGObject **)this + 1));
  v11 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v11, v10);
  *a3 = v11;
  v13 = v14;
  if (v11 == v14)
  {
    if (v11)
      result = (HGColorConform *)(*(uint64_t (**)(HGBitmapLoader *))(*(_QWORD *)v11 + 24))(v11);
  }
  else
  {
    if (v11)
      result = (HGColorConform *)(*(uint64_t (**)(HGBitmapLoader *))(*(_QWORD *)v11 + 24))(v11);
    *a3 = v13;
  }
  if (v10)
    return (HGColorConform *)(*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v10 + 24))(v10);
  return result;
}

void sub_1B301F398(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

HGColorConform *`anonymous namespace'::colorCorrectIfNecessary@<X0>(CGColorSpaceRef space@<X1>, CGColorSpace *a2@<X2>, HGColorConform **a3@<X0>, HGColorConform **a4@<X8>)
{
  HGColorConform *result;
  HGColorConform *v9;

  if (PCColorSpaceHandle::isSameColorSpace(space, a2, a2))
  {
    result = *a3;
    *a4 = *a3;
    if (result)
      return (HGColorConform *)(*(uint64_t (**)(HGColorConform *))(*(_QWORD *)result + 16))(result);
  }
  else
  {
    v9 = (HGColorConform *)HGObject::operator new(0x320uLL);
    HGColorConform::HGColorConform(v9);
    HGColorConform::SetConversion((HGNode *)v9, space, a2);
    result = (HGColorConform *)(*(uint64_t (**)(HGColorConform *, _QWORD, HGColorConform *))(*(_QWORD *)v9 + 120))(v9, 0, *a3);
    *a4 = v9;
  }
  return result;
}

void sub_1B301F4D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t OZGradient1D::getHeliumGradientTexture(float32x4_t *a1, float32x4_t *a2, uint64_t *a3, float64x2_t *a4, float64x2_t *a5, uint64_t a6)
{
  float32x4_t *v6;
  uint64_t i;
  uint64_t j;

  v6 = a1 + 3;
  if (&a1[3] != a2)
  {
    for (i = 0; i != 4; ++i)
    {
      for (j = 0; j != 4; ++j)
        v6->i64[j] = a2->i64[j];
      v6 += 2;
      a2 += 2;
    }
  }
  a1[11].i64[0] = *a3;
  a1[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a4), *a5);
  return (*(uint64_t (**)(float32x4_t *, uint64_t))(a1->i64[0] + 48))(a1, a6);
}

uint64_t OZGradient1D::getHeliumGradientTexture@<X0>(OZGradient1D *this@<X0>, CGColorSpace *a2@<X1>, HGGradient **a3@<X8>)
{
  HGGradient *v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  HGColorConform *v17;
  uint64_t result;
  HGColorConform *v19;

  v6 = (HGGradient *)HGObject::operator new(0x210uLL);
  HGGradient::HGGradient(v6);
  HGGradient::SetGradientMode((uint64_t)v6, 0);
  v7 = *((double *)this + 22);
  (*(void (**)(HGGradient *, _QWORD, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 0, v7, 1.0, 1.0, 1.0);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 1, *((float *)this + 4), *((float *)this + 5), 0.0, 0.0);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 2, *((float *)this + 6), *((float *)this + 7), 0.0, 0.0);
  v8 = *((double *)this + 6);
  v9 = *((double *)this + 7);
  v10 = *((double *)this + 9);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 3, v8, v9, 0.0, v10);
  v11 = *((double *)this + 10);
  v12 = *((double *)this + 11);
  v13 = *((double *)this + 13);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 4, v11, v12, 0.0, v13);
  v14 = *((double *)this + 18);
  v15 = *((double *)this + 19);
  v16 = *((double *)this + 21);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v6 + 96))(v6, 5, v14, v15, 0.0, v16);
  OZGradient1D::getHeliumLUT(this, a2, &v19);
  v17 = v19;
  result = (*(uint64_t (**)(HGGradient *, _QWORD, HGColorConform *))(*(_QWORD *)v6 + 120))(v6, 0, v19);
  *a3 = v6;
  if (v17)
    return (*(uint64_t (**)(HGColorConform *))(*(_QWORD *)v17 + 24))(v17);
  return result;
}

void sub_1B301F6F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void OZGradientRadial::OZGradientRadial(OZGradientRadial *this, OZChannelGradient *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  *((_QWORD *)this + 34) = &off_1E65EB048;
  *((_QWORD *)this + 35) = 0;
  *((_BYTE *)this + 288) = 1;
  OZGradient1D::OZGradient1D(this, (OZChannelGradient *)off_1E65EACF8, (uint64_t)a2, a3, (uint64_t)a4);
  *(_QWORD *)this = &off_1E65EAC80;
  *((_QWORD *)this + 34) = &unk_1E65EACD8;
  *((_WORD *)this + 104) = 0;
  PCColor::PCColor((PCColor *)((char *)this + 216));
}

void sub_1B301F7CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  OZGradient::~OZGradient((OZGradient *)v1, (uint64_t *)off_1E65EAD00);
  *(_QWORD *)(v1 + 272) = v2;
  *(_BYTE *)(v1 + 288) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 280));
  _Unwind_Resume(a1);
}

uint64_t OZGradientRadial::OZGradientRadial(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  CGColorSpace *v6;

  *(_QWORD *)(a1 + 272) = &off_1E65EB048;
  *(_QWORD *)(a1 + 280) = 0;
  *(_BYTE *)(a1 + 288) = 1;
  OZGradient1D::OZGradient1D(a1, (uint64_t *)off_1E65EACF8, (_QWORD *)a2);
  *(_QWORD *)a1 = &off_1E65EAC80;
  *(_QWORD *)(a1 + 272) = &unk_1E65EACD8;
  *(_WORD *)(a1 + 208) = *(_WORD *)(a2 + 208);
  v4 = *(_OWORD *)(a2 + 216);
  v5 = *(_OWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v5;
  *(_OWORD *)(a1 + 216) = v4;
  v6 = *(CGColorSpace **)(a2 + 264);
  *(_QWORD *)(a1 + 264) = v6;
  if (v6)
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
  return a1;
}

void sub_1B301F89C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  OZGradient::~OZGradient((OZGradient *)v1, (uint64_t *)off_1E65EAD00);
  *(_QWORD *)(v1 + 272) = v2;
  *(_BYTE *)(v1 + 288) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 280));
  _Unwind_Resume(a1);
}

void OZGradientRadial::~OZGradientRadial(OZGradientRadial *this)
{
  *(_QWORD *)this = &off_1E65EAC80;
  *((_QWORD *)this + 34) = &unk_1E65EACD8;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 33);
  OZGradient::~OZGradient(this, (uint64_t *)off_1E65EAD00);
  *((_QWORD *)this + 34) = &off_1E65EB048;
  *((_BYTE *)this + 288) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 35);
}

{
  OZGradientRadial::~OZGradientRadial(this);
  JUMPOUT(0x1B5E29170);
}

void `virtual thunk to'OZGradientRadial::~OZGradientRadial(OZGradientRadial *this)
{
  OZGradientRadial::~OZGradientRadial((OZGradientRadial *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24)));
}

{
  OZGradientRadial::~OZGradientRadial((OZGradientRadial *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24)));
  JUMPOUT(0x1B5E29170);
}

void OZGradientRadial::getHash(OZGradientRadial *this, CMTime *a2)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int *v5;
  int8x8_t *Hash;
  int8x8_t v7[521];

  MEMORY[0x1E0C80A78](this);
  v3 = v2;
  v5 = v4;
  v7[520] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  OZChannelGradient::getGradientHash(*(_QWORD *)(v2 + 32));
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v7);
  PCHashWriteStream::writeValue(v7, *(_BYTE *)(v3 + 208));
  PCHashWriteStream::writeValue(v7, *(_BYTE *)(v3 + 209));
  Hash = PCHashWriteStream::getHash(v7);
  PCHash128::operator+=(v5, (int *)Hash);
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v7);
}

void sub_1B301FA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _Unwind_Resume(exception_object);
}

uint64_t OZGradientRadial::update(OZGradientRadial *this, CMTime *a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  _DWORD *v6;
  _DWORD *v12;
  uint64_t v14;
  uint64_t v15;
  CMTime v16;

  v16 = *a2;
  v3 = OZGradient::update(this, &v16);
  if ((_DWORD)v3)
  {
    if (*((_BYTE *)this + 208))
    {
      v4 = *((_QWORD *)this + 1);
      v5 = ((double)*(int *)(v4 + 12) * 0.25);
      if (v5)
      {
        v6 = (_DWORD *)(*(_QWORD *)(v4 + 24) + 12);
        __asm { FMOV            V0.2S, #1.0 }
        do
        {
          *((_QWORD *)v6 - 1) = _D0;
          *v6 = 1065353216;
          v6 += 4;
          --v5;
        }
        while (v5);
      }
    }
    if (*((_BYTE *)this + 209))
    {
      v12 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 24)
                     + 4 * (4 * ((double)*(int *)(*((_QWORD *)this + 1) + 12) * 0.25) - 4));
      v14 = 0;
      v15 = 0;
      PCColor::getRGBA((PCColor *)((char *)this + 216), (float *)&v15 + 1, (float *)&v15, (float *)&v14 + 1, (float *)&v14, *((CGColorSpace **)this + 25));
      *v12 = HIDWORD(v15);
      v12[1] = v15;
      v12[2] = HIDWORD(v14);
      v12[3] = v14;
    }
  }
  return v3;
}

uint64_t OZGradientRadial::getHeliumGradientTexture@<X0>(OZGradientRadial *this@<X0>, CGColorSpace *a2@<X1>, HGGradient **a3@<X8>)
{
  double v6;
  float v7;
  float v8;
  float v9;
  float v10;
  HGGradient *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  HGBitmap *v30;
  HGBitmapLoader *v31;
  HGColorConform *v32;
  uint64_t result;
  HGColorConform *v34;
  HGColorConform *v35;

  v6 = *((double *)this + 22);
  v8 = *((float *)this + 6);
  v7 = *((float *)this + 7);
  v10 = *((float *)this + 4);
  v9 = *((float *)this + 5);
  v11 = (HGGradient *)HGObject::operator new(0x210uLL);
  HGGradient::HGGradient(v11);
  HGGradient::SetGradientMode((uint64_t)v11, 1);
  v12 = *((double *)this + 22);
  (*(void (**)(HGGradient *, _QWORD, float, float, float, float))(*(_QWORD *)v11 + 96))(v11, 0, v12, 1.0, 1.0, 1.0);
  v13 = *((double *)this + 22) * *((float *)this + 4);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v11 + 96))(v11, 1, v13, *((float *)this + 5), 0.0, 0.0);
  v14 = sqrt(v6 * (float)(v8 - v10) * (v6 * (float)(v8 - v10)) + (float)(v7 - v9) * (float)(v7 - v9));
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v11 + 96))(v11, 2, fabsf(v14), 0.0, 0.0, 0.0);
  v15 = *((double *)this + 6);
  v16 = *((double *)this + 7);
  v17 = *((double *)this + 9);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v11 + 96))(v11, 3, v15, v16, 0.0, v17);
  v18 = *((double *)this + 10);
  v19 = *((double *)this + 11);
  v20 = *((double *)this + 13);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v11 + 96))(v11, 4, v18, v19, 0.0, v20);
  v21 = *((double *)this + 18);
  v22 = *((double *)this + 19);
  v23 = *((double *)this + 21);
  (*(void (**)(HGGradient *, uint64_t, float, float, float, float))(*(_QWORD *)v11 + 96))(v11, 5, v21, v22, 0.0, v23);
  v24 = HGRectMake4i(0, 0, ((double)*(int *)(*((_QWORD *)this + 1) + 12) * 0.25), 1u);
  v26 = v25;
  v27 = *((_QWORD *)this + 1);
  v28 = *(_QWORD *)(v27 + 24);
  v29 = *(unsigned int *)(v27 + 16);
  v30 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v30, v24, v26, 28, v28, v29, v29);
  HGBitmap::SetStorage(v30, *((HGObject **)this + 1));
  v31 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v31, v30);
  v35 = v31;
  v32 = v34;
  if (v31 == v34)
  {
    if (v31)
    {
      (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v31 + 24))(v31);
      v32 = v31;
    }
    else
    {
      v32 = 0;
    }
  }
  else
  {
    if (v31)
      (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v31 + 24))(v31);
    v34 = 0;
    v35 = v32;
  }
  result = (*(uint64_t (**)(HGGradient *, _QWORD, HGColorConform *))(*(_QWORD *)v11 + 120))(v11, 0, v32);
  *a3 = v11;
  if (v32)
    result = (*(uint64_t (**)(HGColorConform *))(*(_QWORD *)v32 + 24))(v32);
  if (v30)
    return (*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v30 + 24))(v30);
  return result;
}

void sub_1B301FE80(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void OZGradientGroupShader::OZGradientGroupShader(OZGradientGroupShader *this, OZChannelGradientExtras *a2, CGColorSpace *a3, double a4)
{
  OZGradient1D *v7;
  double *v8;

  *(_QWORD *)this = a2;
  v7 = (OZGradient1D *)operator new();
  OZGradient1D::OZGradient1D(v7, *(OZChannelGradient **)this, (CGColorSpace *)0x100, a3);
  *((_QWORD *)this + 1) = v7;
  v8 = (double *)operator new();
  OZGradientRadial::OZGradientRadial((OZGradientRadial *)v8, *(OZChannelGradient **)this, (CGColorSpace *)0x100, a3);
  *((_QWORD *)this + 2) = v8;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = a3;
  v8[22] = a4;
}

void sub_1B3020000(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C406B4B8A35);
  _Unwind_Resume(a1);
}

void OZGradientGroupShader::~OZGradientGroupShader(OZGradientGroupShader *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 1) = 0;
  v3 = *((_QWORD *)this + 2);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_QWORD *)this + 2) = 0;
}

uint64_t OZGradientGroupShader::update(OZGradientGroupShader *this, CMTime *a2)
{
  int ValueAsInt;
  uint64_t v5;
  uint64_t v6;
  __int128 v8;
  CMTimeEpoch epoch;

  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(*(_QWORD *)this + 800), a2, 0.0);
  v5 = 16;
  if (!ValueAsInt)
    v5 = 8;
  v6 = *(_QWORD *)((char *)this + v5);
  *((_QWORD *)this + 3) = v6;
  v8 = *(_OWORD *)&a2->value;
  epoch = a2->epoch;
  return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v6 + 24))(v6, &v8);
}

uint64_t OZGradientGroupShader::updateWithXForm(_QWORD *a1, const CMTime *a2, _OWORD *a3)
{
  int ValueAsInt;
  uint64_t v7;
  float *v8;
  char *v9;
  char *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t i;
  float *v23;
  __int128 v24;
  float v25;
  float v26;
  float v27;
  float v28;
  __int128 v30;
  CMTimeEpoch epoch;
  _BYTE v32[48];
  __int128 v33;
  __int128 v34;
  _BYTE v35[48];

  ValueAsInt = OZChannel::getValueAsInt((OZChannel *)(*a1 + 800), a2, 0.0);
  v7 = 2;
  if (!ValueAsInt)
    v7 = 1;
  v8 = (float *)a1[v7];
  a1[3] = v8;
  if (*a1)
  {
    if (v9)
    {
      v10 = v9;
      OZChannel::getValueAsDouble((OZChannel *)(v9 + 1192), a2, 0.0);
      v12 = v11;
      OZChannel::getValueAsDouble((OZChannel *)(v10 + 1344), a2, 0.0);
      v14 = v13;
      OZChannel::getValueAsDouble((OZChannel *)(v10 + 1896), a2, 0.0);
      v16 = v15;
      OZChannel::getValueAsDouble((OZChannel *)(v10 + 2048), a2, 0.0);
      v8 = (float *)a1[3];
      if (a3)
      {
        v18 = a3[5];
        v34 = a3[4];
        *(_OWORD *)v35 = v18;
        v19 = a3[7];
        *(_OWORD *)&v35[16] = a3[6];
        *(_OWORD *)&v35[32] = v19;
        v20 = a3[1];
        *(_OWORD *)v32 = *a3;
        *(_OWORD *)&v32[16] = v20;
        v21 = a3[3];
        *(_OWORD *)&v32[32] = a3[2];
        v33 = v21;
      }
      else
      {
        *(_QWORD *)&v35[40] = 0x3FF0000000000000;
        *(_QWORD *)v35 = 0x3FF0000000000000;
        *(_QWORD *)&v32[40] = 0x3FF0000000000000;
        *(_QWORD *)v32 = 0x3FF0000000000000;
        memset(&v32[8], 0, 32);
        v33 = 0u;
        v34 = 0u;
        memset(&v35[8], 0, 32);
      }
      for (i = 0; i != 32; i += 8)
      {
        v23 = &v8[i];
        v24 = *(_OWORD *)&v32[i * 4 + 16];
        *((_OWORD *)v23 + 3) = *(_OWORD *)&v32[i * 4];
        *((_OWORD *)v23 + 4) = v24;
      }
      v25 = v12;
      v26 = v14;
      v8[4] = v25;
      v8[5] = v26;
      v27 = v16;
      v28 = v17;
      v8[6] = v27;
      v8[7] = v28;
    }
  }
  v30 = *(_OWORD *)&a2->value;
  epoch = a2->epoch;
  return (*(uint64_t (**)(float *, __int128 *))(*(_QWORD *)v8 + 24))(v8, &v30);
}

void PCShared::~PCShared(PCShared *this)
{
  *((_QWORD *)this + 1) = &off_1E65EB048;
  *((_BYTE *)this + 24) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 2);
}

{
  *((_QWORD *)this + 1) = &off_1E65EB048;
  *((_BYTE *)this + 24) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 2);
  JUMPOUT(0x1B5E29170);
}

void `virtual thunk to'PCShared::~PCShared(PCShared *this)
{
  char *v1;

  v1 = (char *)this + *(_QWORD *)(*(_QWORD *)this - 24);
  *((_QWORD *)v1 + 1) = &off_1E65EB048;
  v1[24] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 2);
}

{
  char *v1;

  v1 = (char *)this + *(_QWORD *)(*(_QWORD *)this - 24);
  *((_QWORD *)v1 + 1) = &off_1E65EB048;
  v1[24] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 2);
  JUMPOUT(0x1B5E29170);
}

uint64_t PCShared_base::dispose(uint64_t this)
{
  if (this)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 8))(this);
  return this;
}

void PCShared_base::~PCShared_base(PCShared_base *this)
{
  *(_QWORD *)this = &off_1E65EB048;
  *((_BYTE *)this + 16) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 1);
}

{
  *(_QWORD *)this = &off_1E65EB048;
  *((_BYTE *)this + 16) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 1);
  JUMPOUT(0x1B5E29170);
}

void PCWeakCount::~PCWeakCount(PC_Sp_counted_base **this)
{
  PC_Sp_counted_base *v1;

  v1 = *this;
  if (v1)
    PC_Sp_counted_base::weak_release(v1);
}

const char *HgcShapeSoftEdgeColorizeSecondPass::GetProgram(HgcShapeSoftEdgeColorizeSecondPass *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000023e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0 = float4(r0.xxxx)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc50da6:bd1ed7f1:a3dcbc7d:50cc653d\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000231\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).x;\n"
             "    output.color0 = r0.xxxx*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=0bc76ed3:09c436ca:6d851111:8bb685f7\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001ff\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.x = texture2D(hg_Texture0, hg_TexCoord0.xy).x;\n"
           "    gl_FragColor = r0.xxxx*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=b131b046:6e0ac2f3:4508da6a:0c8907d8\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeSoftEdgeColorizeSecondPass::InitProgramDescriptor(HgcShapeSoftEdgeColorizeSecondPass *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeColorizeSecondPass_hgc_visible", "//Metal1.0     \n//LEN=000000011d\n[[ visible ]] FragmentOut HgcShapeSoftEdgeColorizeSecondPass_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = color0.x;\n"
    "    output.color0 = r0.xxxx*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B302051C()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcShapeSoftEdgeColorizeSecondPass");
}

void sub_1B302052C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3051440;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B302062C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B302066C()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3020664);
}

_QWORD *HgcShapeSoftEdgeColorizeSecondPass::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeColorizeSecondPass [hgc1]");
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::BindTexture(HgcShapeSoftEdgeColorizeSecondPass *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::Bind(HgcShapeSoftEdgeColorizeSecondPass *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 62), 1);
  (*(void (**)(HgcShapeSoftEdgeColorizeSecondPass *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::RenderTile(HgcShapeSoftEdgeColorizeSecondPass *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t *v15;
  uint64_t v16;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 22);
    v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v16) = 0;
      }
      else
      {
        v9 = 0;
        v10 = 32;
        do
        {
          v11 = *(float32x4_t *)*((_QWORD *)this + 62);
          v12 = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10 - 16)));
          v13 = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10)));
          v14 = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10 + 16)));
          v15 = (float32x4_t *)(v5 + v10);
          v15[-2] = vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(v6 + v10 - 32)));
          v15[-1] = v12;
          *v15 = v13;
          v15[1] = v14;
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v16) = -v9;
      }
      if ((int)v16 < v4)
      {
        v16 = v16;
        do
        {
          *(float32x4_t *)(v5 + 16 * v16) = vmulq_n_f32(*(float32x4_t *)*((_QWORD *)this + 62), COERCE_FLOAT(*(_OWORD *)(v6 + 16 * v16)));
          ++v16;
        }
        while (v16 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::GetDOD(HgcShapeSoftEdgeColorizeSecondPass *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::GetROI(HgcShapeSoftEdgeColorizeSecondPass *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcShapeSoftEdgeColorizeSecondPass::HgcShapeSoftEdgeColorizeSecondPass(HgcShapeSoftEdgeColorizeSecondPass *this)
{
  uint64_t v2;
  uint64_t v3;

  HGColorMatrix::HGColorMatrix(this);
  *(_QWORD *)v2 = off_1E65EB070;
  *(_DWORD *)(v2 + 504) = 1;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 32) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 48) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 64) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 80) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 96) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 112) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 128) = xmmword_1B304EFF0;
  *((_QWORD *)this + 62) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B302093C(_Unwind_Exception *a1)
{
  HGColorMatrix *v1;

  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeColorizeSecondPass::~HgcShapeSoftEdgeColorizeSecondPass(HgcShapeSoftEdgeColorizeSecondPass *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EB070;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40265AC83CLL);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  void *v1;

  HgcShapeSoftEdgeColorizeSecondPass::~HgcShapeSoftEdgeColorizeSecondPass(this);
  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeColorizeSecondPass::SetParameter(HgcShapeSoftEdgeColorizeSecondPass *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 62);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  v7 = 1;
  *((_DWORD *)this + 126) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v7;
}

float HgcShapeSoftEdgeColorizeSecondPass::GetParameter(HgcShapeSoftEdgeColorizeSecondPass *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 62);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

HGNode *HgcShapeSoftEdgeColorizeSecondPass::GetOutput(__n128 *this, HGRenderer *a2, __n128 a3, __n128 a4, int32x2_t a5)
{
  unint64_t v5;
  __n128 *v6;

  if (this[31].n128_u32[2])
  {
    v5 = this[31].n128_u64[0];
    *(double *)&a5 = 0.0;
    a4 = (__n128)vmulq_f32(*(float32x4_t *)v5, (float32x4_t)0);
    *(float32x4_t *)(v5 + 16) = vmulq_n_f32(*(float32x4_t *)v5, COERCE_FLOAT(*(_OWORD *)(v5 + 80)));
    *(__n128 *)(this[31].n128_u64[0] + 32) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 48) = a4;
    *(__n128 *)(this[31].n128_u64[0] + 64) = a4;
    v6 = (__n128 *)this[31].n128_u64[0];
    this[27] = v6[1];
    this[28] = v6[2];
    this[29] = v6[3];
    a3 = v6[4];
    this[30] = a3;
    this[31].n128_u32[2] = 0;
  }
  return HGColorMatrix::GetOutput((HGColorMatrix *)this, a2, a3.n128_f64[0], a4.n128_f64[0], a5);
}

const char *HgcShapeSoftEdgeSubtractAlpha::GetProgram(HgcShapeSoftEdgeSubtractAlpha *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000030a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1.w = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r0.w = r0.w - r1.w;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8e212562:2be34449:a55b7522:a773cb44\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002f6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1.w = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r0.w = r0.w - r1.w;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2ccb5981:f6d6baf5:874983b9:e721a7c3\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000274\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1.w = texture2D(hg_Texture0, hg_TexCoord0.xy).w;\n"
           "    r0.w = r0.w - r1.w;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=97b858b6:94e2926a:b6feeb87:128df125\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcShapeSoftEdgeSubtractAlpha::InitProgramDescriptor(HgcShapeSoftEdgeSubtractAlpha *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeSubtractAlpha_hgc_visible", "//Metal1.0     \n//LEN=0000000162\n[[ visible ]] FragmentOut HgcShapeSoftEdgeSubtractAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color1;\n"
    "    r1.w = color0.w;\n"
    "    r0.w = r0.w - r1.w;\n"
    "    r0.xyz = r0.xyz*r0.www;\n"
    "    output.color0 = r0;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B3020B98()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcShapeSoftEdgeSubtractAlpha");
}

void sub_1B3020BA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B30514B0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B3020CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3020D30()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3020D28);
}

_QWORD *HgcShapeSoftEdgeSubtractAlpha::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeSubtractAlpha [hgc1]");
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::BindTexture(HgcShapeSoftEdgeSubtractAlpha *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::Bind(HgcShapeSoftEdgeSubtractAlpha *this, HGHandler *a2)
{
  (*(void (**)(HgcShapeSoftEdgeSubtractAlpha *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::RenderTile(HgcShapeSoftEdgeSubtractAlpha *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t *v26;
  uint64_t v27;
  float32x4_t v28;
  int8x16_t v29;
  int8x16_t v30;
  float32x4_t v31;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 26);
    v8 = *((_QWORD *)a2 + 12);
    v9 = 16 * *((int *)a2 + 22);
    v10 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v27) = 0;
      }
      else
      {
        v11 = 0;
        v12 = 32;
        do
        {
          v13 = *(float32x4_t *)(v8 + v12 - 32);
          v14 = *(float32x4_t *)(v8 + v12 - 16);
          v15 = *(float32x4_t *)(v8 + v12);
          v16 = *(float32x4_t *)(v8 + v12 + 16);
          v17 = (int8x16_t)vsubq_f32(v13, *(float32x4_t *)(v6 + v12 - 32));
          v18 = (int8x16_t)vsubq_f32(v14, *(float32x4_t *)(v6 + v12 - 16));
          v19 = (int8x16_t)vsubq_f32(v15, *(float32x4_t *)(v6 + v12));
          v20 = (int8x16_t)vsubq_f32(v16, *(float32x4_t *)(v6 + v12 + 16));
          v21 = *(int8x16_t *)*((_QWORD *)this + 51);
          v22 = (float32x4_t)vbslq_s8(v21, v17, (int8x16_t)v13);
          v23 = (float32x4_t)vbslq_s8(v21, v18, (int8x16_t)v14);
          v24 = (float32x4_t)vbslq_s8(v21, v19, (int8x16_t)v15);
          v25 = (float32x4_t)vbslq_s8(v21, v20, (int8x16_t)v16);
          v26 = (int8x16_t *)(v5 + v12);
          v26[-2] = vbslq_s8(v21, v17, (int8x16_t)vmulq_laneq_f32(v22, v22, 3));
          v26[-1] = vbslq_s8(v21, v18, (int8x16_t)vmulq_laneq_f32(v23, v23, 3));
          *v26 = vbslq_s8(v21, v19, (int8x16_t)vmulq_laneq_f32(v24, v24, 3));
          v26[1] = vbslq_s8(v21, v20, (int8x16_t)vmulq_laneq_f32(v25, v25, 3));
          v11 -= 4;
          v12 += 64;
        }
        while (v4 + v11 > 3);
        LODWORD(v27) = -v11;
      }
      if ((int)v27 < v4)
      {
        v27 = v27;
        do
        {
          v28 = *(float32x4_t *)(v8 + 16 * v27);
          v29 = (int8x16_t)vsubq_f32(v28, *(float32x4_t *)(v6 + 16 * v27));
          v30 = *(int8x16_t *)*((_QWORD *)this + 51);
          v31 = (float32x4_t)vbslq_s8(v30, v29, (int8x16_t)v28);
          *(int8x16_t *)(v5 + 16 * v27++) = vbslq_s8(v30, v29, (int8x16_t)vmulq_laneq_f32(v31, v31, 3));
        }
        while (v27 < v4);
      }
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::GetDOD(HgcShapeSoftEdgeSubtractAlpha *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::GetROI(HgcShapeSoftEdgeSubtractAlpha *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcShapeSoftEdgeSubtractAlpha::HgcShapeSoftEdgeSubtractAlpha(HgcShapeSoftEdgeSubtractAlpha *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65EB2E8;
  v3 = (_OWORD *)operator new();
  *v3 = xmmword_1B3050F70;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B302103C(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeSubtractAlpha::~HgcShapeSoftEdgeSubtractAlpha(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EB2E8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40451B5BE8);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcShapeSoftEdgeSubtractAlpha::~HgcShapeSoftEdgeSubtractAlpha(this);
  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::SetParameter(HgcShapeSoftEdgeSubtractAlpha *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcShapeSoftEdgeSubtractAlpha::GetParameter(HgcShapeSoftEdgeSubtractAlpha *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcShapeSoftEdgeClr::GetProgram(HgcShapeSoftEdgeClr *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002d0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[5].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[5].zw);\n"
             "    r0.x = (half) hg_Texture0.sample(hg_Sampler0, float2(r0.xy)).x;\n"
             "    output.color0 = float4(r0.xxxx)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=fa47e8dc:4e19468c:97518949:b262ea97\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000029f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[5].xy;\n"
             "    r0.xy = r0.xy*hg_Params[5].zw;\n"
             "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
             "    output.color0 = r0.xxxx*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f2684eb6:17faaf05:9b5c2070:8c3af7e8\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000325\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal5.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal5.zw;\n"
           "    r0.x = texture2D(hg_Texture0, r0.xy).x;\n"
           "    gl_FragColor = r0.xxxx*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=e4d40c06:c2e5521c:3841fc93:3af28a0f\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0006:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeSoftEdgeClr::InitProgramDescriptor(HgcShapeSoftEdgeClr *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeClr_hgc_visible", "//Metal1.0     \n//LEN=00000001df\n[[ visible ]] FragmentOut HgcShapeSoftEdgeClr_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[5].xy;\n"
    "    r0.xy = r0.xy*hg_Params[5].zw;\n"
    "    r0.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
    "    output.color0 = r0.xxxx*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B3021190()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcShapeSoftEdgeClr");
}

void sub_1B30211A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3052790;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B3021320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3021370()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3021368);
}

_QWORD *HgcShapeSoftEdgeClr::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeClr [hgc1]");
}

uint64_t HgcShapeSoftEdgeClr::BindTexture(HgcShapeSoftEdgeClr *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 5, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::Bind(HgcShapeSoftEdgeClr *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t))(*(_QWORD *)a2 + 120))(a2, *((_QWORD *)this + 51) + 16);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HgcShapeSoftEdgeClr *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t *v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x4_t *v14;
  float32x4_t v15;

  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  v4 = a2[1];
  v5 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 3);
  v6 = *(float32x4_t **)(a1 + 408);
  v7 = v6[9];
  v8 = v6[10];
  v9 = vminq_f32(vmaxq_f32(vrecpeq_f32(v5), v7), v8);
  v10 = vminq_f32(vmaxq_f32(vmulq_f32(v9, vrecpsq_f32(v5, v9)), v7), v8);
  v11 = a3[11].i32[0];
  v12 = vsubq_f32(vmulq_f32(v4, vmulq_f32(v10, vrecpsq_f32(v5, v10))), v3);
  v13 = vaddq_s32(vcvtq_s32_f32(v12), vcltzq_f32(v12));
  v12.i64[0] = vsubq_f32(v12, vcvtq_f32_s32(v13)).u64[0];
  v14 = (float32x4_t *)(*(_QWORD *)&a3[10] + 16 * (v13.i32[0] + v13.i32[1] * (int)v11));
  v15 = vaddq_f32(*v14, vmulq_n_f32(vsubq_f32(v14[1], *v14), v12.f32[0]));
  *(float32x4_t *)*(_QWORD *)&a3[2] = vmulq_n_f32(*v6, vaddq_f32(v15, vmulq_lane_f32(vsubq_f32(vaddq_f32(v14[v11], vmulq_n_f32(vsubq_f32(v14[(int)v11 + 1], v14[v11]), v12.f32[0])), v15), *(float32x2_t *)v12.f32, 1)).f32[0]);
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::RenderTile(HgcShapeSoftEdgeClr *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  int32x2_t v7;
  uint64_t v8;
  float32x4_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t *v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t v19;
  int32x4_t v20;
  float32x4_t *v21;
  float32x4_t v22;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = a2[2];
    v8 = 16 * a2[3].i32[0];
    v9 = v5;
    do
    {
      if (v6 >= 1)
      {
        v10 = 0;
        v11 = v9;
        do
        {
          v12 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
          v13 = (float32x4_t *)*((_QWORD *)this + 51);
          v14 = v13[9];
          v15 = v13[10];
          v16 = vminq_f32(vmaxq_f32(vrecpeq_f32(v12), v14), v15);
          v17 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpsq_f32(v12, v16)), v14), v15);
          v18 = a2[11].i32[0];
          v19 = vsubq_f32(vmulq_f32(v11, vmulq_f32(v17, vrecpsq_f32(v12, v17))), v5);
          v20 = vaddq_s32(vcvtq_s32_f32(v19), vcltzq_f32(v19));
          v19.i64[0] = vsubq_f32(v19, vcvtq_f32_s32(v20)).u64[0];
          v21 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v20.i32[0] + v20.i32[1] * (int)v18));
          v22 = vaddq_f32(*v21, vmulq_n_f32(vsubq_f32(v21[1], *v21), v19.f32[0]));
          *(float32x4_t *)(*(_QWORD *)&v7 + v10) = vmulq_n_f32(*v13, vaddq_f32(v22, vmulq_lane_f32(vsubq_f32(vaddq_f32(v21[v18], vmulq_n_f32(vsubq_f32(v21[(int)v18 + 1], v21[v18]), v19.f32[0])), v22), *(float32x2_t *)v19.f32, 1)).f32[0]);
          v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B304F230);
          v10 += 16;
        }
        while (16 * v6 != v10);
      }
      v9 = vaddq_f32(v9, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeClr::GetDOD(HgcShapeSoftEdgeClr *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  const HGTransform *v9;
  uint64_t v10;
  uint64_t v11;
  HGTransformUtils *v12;
  float v13;
  uint64_t DOD;
  uint64_t v15;
  float64x2_t v17[9];
  HGRect v18;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  v9 = (const HGTransform *)HGRectGrow(v6, v5, v8);
  v11 = v10;
  HGTransform::HGTransform((HGTransform *)v17);
  HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((_QWORD *)this + 51) + 16));
  HGTransform::Invert2D((HGTransform *)v17);
  v13 = HGTransformUtils::MinW(v12);
  *(_QWORD *)&v18.var0 = v11;
  DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v17, v9, v18, 0.5, v13);
  v4 = HGRectUnion(0, 0, DOD, v15);
  HGTransform::~HGTransform((HGTransform *)v17);
  return v4;
}

void sub_1B3021840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HgcShapeSoftEdgeClr::GetROI(HgcShapeSoftEdgeClr *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  HGTransformUtils *v8;
  float v9;
  uint64_t ROI;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float64x2_t v17[9];
  HGRect v18;

  v4 = 0;
  if (!a3)
  {
    v5 = *(_QWORD *)&a4.var2;
    v6 = *(_QWORD *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((_QWORD *)this + 51) + 16));
    v9 = HGTransformUtils::MinW(v8);
    *(_QWORD *)&v18.var0 = v5;
    ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v9);
    v12 = HGRectUnion(0, 0, ROI, v11);
    v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v12, v14, v15);
  }
  return v4;
}

void sub_1B3021934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeClr::HgcShapeSoftEdgeClr(HgcShapeSoftEdgeClr *this)
{
  uint64_t v2;
  uint64_t v3;

  HGNode3D::HGNode3D(this);
  *(_QWORD *)v2 = off_1E65EB550;
  *(_DWORD *)(v2 + 416) = 1;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 32) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 48) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 64) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 80) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 96) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 112) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 128) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 144) = xmmword_1B30527A0;
  *(int32x4_t *)(v3 + 160) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcShapeSoftEdgeClr *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B3021A10(_Unwind_Exception *a1)
{
  HGMipmapLevel *v1;

  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeClr::~HgcShapeSoftEdgeClr(HgcShapeSoftEdgeClr *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EB550;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40C3A7E6FCLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  void *v1;

  HgcShapeSoftEdgeClr::~HgcShapeSoftEdgeClr(this);
  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeClr::SetParameter(HgcShapeSoftEdgeClr *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  v7 = 1;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v7;
}

float HgcShapeSoftEdgeClr::GetParameter(HgcShapeSoftEdgeClr *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

double HgcShapeSoftEdgeClr::GetOutput(HgcShapeSoftEdgeClr *this, HGRenderer *a2)
{
  uint64_t v2;
  __int128 v3;
  double result;

  if (*((_DWORD *)this + 104))
  {
    v2 = *((_QWORD *)this + 51);
    v3 = *(_OWORD *)(v2 + 96);
    *(_OWORD *)(v2 + 16) = *(unint64_t *)(v2 + 80);
    *(_OWORD *)(*((_QWORD *)this + 51) + 32) = (unint64_t)v3;
    *(_OWORD *)(*((_QWORD *)this + 51) + 48) = xmmword_1B304F250;
    result = 0.0;
    *(_OWORD *)(*((_QWORD *)this + 51) + 64) = xmmword_1B304EFF0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcShapeAlphaBias::GetProgram(HgcShapeAlphaBias *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000331\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = pow(r0.w, half(hg_Params[0].w));\n"
             "    r1.xyz = r0.xyz*r1.www;\n"
             "    r1.xyz = r1.xyz/r0.www;\n"
             "    r2.x = c0.x - r0.w;\n"
             "    output.color0 = select(float4(r0), float4(r1), float4(r2.xxxx) < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=036b020b:04d95457:27ac6026:fc832375\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000030f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = pow(r0.w, hg_Params[0].w);\n"
             "    r1.xyz = r0.xyz*r1.www;\n"
             "    r1.xyz = r1.xyz/r0.www;\n"
             "    r2.x = c0.x - r0.w;\n"
             "    output.color0 = select(r0, r1, r2.xxxx < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3faf21c0:d38a8a3c:f5168635:aedd7782\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000339\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = pow(r0.w, hg_ProgramLocal0.w);\n"
           "    r1.xyz = r0.xyz*r1.www;\n"
           "    r1.xyz = r1.xyz/r0.www;\n"
           "    r2.x = c0.x - r0.w;\n"
           "    gl_FragColor = vec4(r2.x < 0.00000 ? r1.x : r0.x, r2.x < 0.00000 ? r1.y : r0.y, r2.x < 0.00000 ? r1.z : r"
           "0.z, r2.x < 0.00000 ? r1.w : r0.w);\n"
           "}\n"
           "//MD5=c47dd433:0bd6ec29:e56572fa:825df2b7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeAlphaBias::InitProgramDescriptor(HgcShapeAlphaBias *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeAlphaBias_hgc_visible", "//Metal1.0     \n//LEN=00000001ea\n[[ visible ]] FragmentOut HgcShapeAlphaBias_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(9.999999975e-07, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.w = pow(r0.w, hg_Params[0].w);\n"
    "    r1.xyz = r0.xyz*r1.www;\n"
    "    r1.xyz = r1.xyz/r0.www;\n"
    "    r2.x = c0.x - r0.w;\n"
    "    output.color0 = select(r0, r1, r2.xxxx < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B3021C54()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcShapeAlphaBias");
}

void sub_1B3021C64(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3051440;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B3021D64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3021DA4()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3021D9CLL);
}

_QWORD *HgcShapeAlphaBias::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeAlphaBias [hgc1]");
}

uint64_t HgcShapeAlphaBias::BindTexture(HgcShapeAlphaBias *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcShapeAlphaBias::Bind(HgcShapeAlphaBias *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcShapeAlphaBias *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcShapeAlphaBias::RenderTile(HgcShapeAlphaBias *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t *v63;
  unsigned int v64;
  float32x4_t v65;
  uint64_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 6);
    v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 2)
      {
        v64 = 0;
      }
      else
      {
        v9 = 0;
        v10 = 16;
        do
        {
          v12 = *(float32x4_t *)(v6 + v10 - 16);
          v11 = *(float32x4_t *)(v6 + v10);
          v13 = *((_QWORD *)this + 51);
          v14 = *(int8x16_t *)(v13 + 16);
          v15 = *(float32x4_t *)(v13 + 32);
          v16 = *(float32x4_t *)(v13 + 48);
          v17 = (float32x4_t)vorrq_s8(vandq_s8(v14, (int8x16_t)v12), (int8x16_t)v15);
          v18 = (float32x4_t)vorrq_s8(vandq_s8(v14, (int8x16_t)v11), (int8x16_t)v15);
          v19 = (int8x16_t)vcgtq_f32(v16, v12);
          v20 = *(int8x16_t *)(v13 + 64);
          v21 = *(float32x4_t *)(v13 + 80);
          v22 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v11, 0x17uLL)), (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v16, v11)));
          v23 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v12, 0x17uLL)), (float32x4_t)vandq_s8(v20, v19)), v21);
          v24 = *(float32x4_t *)(v13 + 96);
          v25 = *(float32x4_t *)(v13 + 112);
          v26 = vsubq_f32(v22, v21);
          v27 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v17, v24));
          v28 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v18, v24));
          v29 = vaddq_f32(v23, v27);
          v30 = vsubq_f32(vsubq_f32(v17, v15), vmulq_f32(vmulq_f32(v25, v27), v17));
          v31 = vsubq_f32(vsubq_f32(v18, v15), vmulq_f32(vmulq_f32(v25, v28), v18));
          v32 = *(float32x4_t *)(v13 + 128);
          v33 = *(float32x4_t *)(v13 + 144);
          v34 = vaddq_f32(v32, vmulq_f32(v33, v30));
          v35 = vaddq_f32(v32, vmulq_f32(v33, v31));
          v36 = *(float32x4_t *)(v13 + 160);
          v37 = *(float32x4_t *)(v13 + 176);
          v38 = vmulq_f32(*(float32x4_t *)v13, vaddq_f32(vaddq_f32(v26, v28), vmulq_f32(v31, vaddq_f32(vaddq_f32(v36, vmulq_f32(v31, v37)), vmulq_f32(vmulq_f32(v31, v31), v35)))));
          v39 = *(float32x4_t *)(v13 + 192);
          v40 = *(float32x4_t *)(v13 + 208);
          v41 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v13, vaddq_f32(v29, vmulq_f32(v30, vaddq_f32(vaddq_f32(v36, vmulq_f32(v30, v37)), vmulq_f32(vmulq_f32(v30, v30), v34))))), v39);
          v42 = vmaxq_f32(v38, v39);
          v43 = vcvtq_f32_s32(vcvtq_s32_f32(v41));
          v44 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
          v45 = vsubq_f32(v43, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v43, v41)));
          v46 = vsubq_f32(v44, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v44, v42)));
          v47 = vsubq_f32(v41, v45);
          v48 = *(float32x4_t *)(v13 + 224);
          v49 = *(float32x4_t *)(v13 + 240);
          v50 = vsubq_f32(v42, v46);
          v51 = *(int32x4_t *)(v13 + 256);
          v52 = *(int8x16_t *)(v13 + 272);
          v53 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v47, vaddq_f32(v49, vmulq_f32(v47, vaddq_f32(v40, vmulq_f32(v48, v47)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v45)), 0x17uLL));
          v54 = vmulq_f32(vaddq_f32(v15, vmulq_f32(v50, vaddq_f32(v49, vmulq_f32(v50, vaddq_f32(v40, vmulq_f32(v48, v50)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(v51, vcvtq_s32_f32(v46)), 0x17uLL));
          v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3);
          v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
          v57 = vmaxq_f32(vmulq_f32(v49, vrecpeq_f32(v55)), v48);
          v58 = vmaxq_f32(vmulq_f32(v49, vrecpeq_f32(v56)), v48);
          v59 = *(float32x4_t *)(v13 + 288);
          v60 = *(float32x4_t *)(v13 + 304);
          v61 = vminq_f32(v57, v59);
          v62 = vminq_f32(v58, v59);
          v63 = (int8x16_t *)(v5 + v10);
          v63[-1] = vbslq_s8((int8x16_t)vcgtq_f32(v60, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v40, v55), 0)), vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_f32(vmulq_f32(v61, vrecpsq_f32(v55, v61)), (float32x4_t)vbslq_s8(v52, (int8x16_t)v53, (int8x16_t)vmulq_laneq_f32(v12, v53, 3)))), (int8x16_t)v12);
          *v63 = vbslq_s8((int8x16_t)vcgtq_f32(v60, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v40, v56), 0)), vbslq_s8(v52, (int8x16_t)v54, (int8x16_t)vmulq_f32(vmulq_f32(v62, vrecpsq_f32(v56, v62)), (float32x4_t)vbslq_s8(v52, (int8x16_t)v54, (int8x16_t)vmulq_laneq_f32(v11, v54, 3)))), (int8x16_t)v11);
          v9 -= 2;
          v10 += 32;
        }
        while (v4 + v9 > 1);
        v64 = -v9;
      }
      if ((int)v64 < v4)
      {
        v65 = *(float32x4_t *)(v6 + 16 * v64);
        v66 = *((_QWORD *)this + 51);
        v67 = *(float32x4_t *)(v66 + 32);
        v68 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v66 + 16), (int8x16_t)v65), (int8x16_t)v67);
        v69 = (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v68, *(float32x4_t *)(v66 + 96)));
        v70 = vsubq_f32(vsubq_f32(v68, v67), vmulq_f32(vmulq_f32(*(float32x4_t *)(v66 + 112), v69), v68));
        v71 = *(float32x4_t *)(v66 + 208);
        v72 = vmaxq_f32(vmulq_f32(*(float32x4_t *)v66, vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v65, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v66 + 64), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v66 + 48), v65))), *(float32x4_t *)(v66 + 80)), v69), vmulq_f32(v70, vaddq_f32(vaddq_f32(*(float32x4_t *)(v66 + 160), vmulq_f32(v70, *(float32x4_t *)(v66 + 176))), vmulq_f32(vmulq_f32(v70, v70), vaddq_f32(*(float32x4_t *)(v66 + 128), vmulq_f32(*(float32x4_t *)(v66 + 144), v70))))))),
                *(float32x4_t *)(v66 + 192));
        v73 = vcvtq_f32_s32(vcvtq_s32_f32(v72));
        v74 = vsubq_f32(v73, (float32x4_t)vandq_s8((int8x16_t)v67, (int8x16_t)vcgtq_f32(v73, v72)));
        v75 = vsubq_f32(v72, v74);
        v76 = *(float32x4_t *)(v66 + 224);
        v77 = *(float32x4_t *)(v66 + 240);
        v78 = vmulq_f32(vaddq_f32(v67, vmulq_f32(v75, vaddq_f32(v77, vmulq_f32(v75, vaddq_f32(v71, vmulq_f32(v76, v75)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v66 + 256), vcvtq_s32_f32(v74)), 0x17uLL));
        v79 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3);
        v80 = vminq_f32(vmaxq_f32(vmulq_f32(v77, vrecpeq_f32(v79)), v76), *(float32x4_t *)(v66 + 288));
        *(int8x16_t *)(v5 + 16 * v64) = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v66 + 304), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vsubq_f32(v71, v79), 0)), vbslq_s8(*(int8x16_t *)(v66 + 272), (int8x16_t)v78, (int8x16_t)vmulq_f32(vmulq_f32(v80, vrecpsq_f32(v79, v80)), (float32x4_t)vbslq_s8(*(int8x16_t *)(v66 + 272), (int8x16_t)v78, (int8x16_t)vmulq_laneq_f32(v65, v78, 3)))), (int8x16_t)v65);
      }
      v6 += v8;
      v5 += v7;
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcShapeAlphaBias::GetDOD(HgcShapeAlphaBias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcShapeAlphaBias::GetROI(HgcShapeAlphaBias *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcShapeAlphaBias::HgcShapeAlphaBias(HgcShapeAlphaBias *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65EB7C8;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B355C370;
  *(_OWORD *)(v3 + 32) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050E40;
  *(_OWORD *)(v3 + 64) = xmmword_1B3050E50;
  *(_OWORD *)(v3 + 80) = xmmword_1B3050E60;
  *(_OWORD *)(v3 + 96) = xmmword_1B3050E70;
  *(_OWORD *)(v3 + 112) = xmmword_1B3050E80;
  *(_OWORD *)(v3 + 128) = xmmword_1B3051360;
  *(_OWORD *)(v3 + 144) = xmmword_1B3051370;
  *(_OWORD *)(v3 + 160) = xmmword_1B3051380;
  *(_OWORD *)(v3 + 176) = xmmword_1B3051390;
  *(_OWORD *)(v3 + 192) = xmmword_1B3050F00;
  *(_OWORD *)(v3 + 208) = xmmword_1B3565DA0;
  *(_OWORD *)(v3 + 224) = xmmword_1B3565DB0;
  *(_OWORD *)(v3 + 240) = xmmword_1B3565DC0;
  *(_OWORD *)(v3 + 256) = xmmword_1B3050F60;
  *(_OWORD *)(v3 + 272) = xmmword_1B3050F70;
  *(int32x4_t *)(v3 + 288) = vdupq_n_s32(0x7F7FFFFFu);
  *(_OWORD *)(v3 + 304) = 0u;
  *(_OWORD *)(v3 + 320) = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B30223BC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcShapeAlphaBias::~HgcShapeAlphaBias(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EB7C8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C4055B0EC01);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcShapeAlphaBias::~HgcShapeAlphaBias(this);
  HGObject::operator delete(v1);
}

uint64_t HgcShapeAlphaBias::SetParameter(HgcShapeAlphaBias *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  __n128 *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (__n128 *)*((_QWORD *)this + 51);
  if (v8->n128_f32[0] == 0.0 && v8->n128_f32[1] == 0.0 && v8->n128_f32[2] == 0.0 && v8->n128_f32[3] == a3.n128_f32[0])
    return 0;
  v8->n128_u64[0] = 0;
  v8->n128_u32[3] = a3.n128_u32[0];
  a3.n128_f32[1] = a4;
  v8->n128_u32[2] = 0;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v8[20] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcShapeAlphaBias::GetParameter(HgcShapeAlphaBias *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = v3[80];
    a3[1] = v3[81];
    a3[2] = v3[82];
    result = v3[83];
    a3[3] = result;
  }
  return result;
}

const char *HgcShapeSoftEdgeClrInPlace::GetProgram(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = half2(frag._texCoord0.xy)/half2(frag._texCoord0.ww);\n"
             "    r0.xy = r0.xy + half2(hg_Params[6].xy);\n"
             "    r0.xy = r0.xy*half2(hg_Params[6].zw);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, float2(r0.xy));\n"
             "    r0 = half4(hg_Params[0])*r0;\n"
             "    output.color0 = float4(r0)*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=20355668:a4f824fd:5c70d0dc:40dc3ff8\n"
             "//SIG=02400000:00000000:00000000:00000000:0000:0007:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002b0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = frag._texCoord0.xy/frag._texCoord0.ww;\n"
             "    r0.xy = r0.xy + hg_Params[6].xy;\n"
             "    r0.xy = r0.xy*hg_Params[6].zw;\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    r0 = hg_Params[0]*r0;\n"
             "    output.color0 = r0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=cd0af800:73edd9a1:f1cd8bb5:754f2b15\n"
             "//SIG=02000000:00000000:00000000:00000000:0000:0007:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000035f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = hg_TexCoord0.xy/hg_TexCoord0.ww;\n"
           "    r0.xy = r0.xy + hg_ProgramLocal6.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal6.zw;\n"
           "    r0 = texture2D(hg_Texture0, r0.xy);\n"
           "    r0 = hg_ProgramLocal0*r0;\n"
           "    gl_FragColor = r0*hg_ProgramLocal1;\n"
           "}\n"
           "//MD5=52d75abf:59af0be7:83a946b0:42b4e3ef\n"
           "//SIG=02000000:00000000:00000000:00000000:0000:0007:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcShapeSoftEdgeClrInPlace::InitProgramDescriptor(HgcShapeSoftEdgeClrInPlace *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeSoftEdgeClrInPlace_hgc_visible", "//Metal1.0     \n//LEN=00000001f7\n[[ visible ]] FragmentOut HgcShapeSoftEdgeClrInPlace_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = texCoord0.xy/texCoord0.ww;\n"
    "    r0.xy = r0.xy + hg_Params[6].xy;\n"
    "    r0.xy = r0.xy*hg_Params[6].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r0 = hg_Params[0]*r0;\n"
    "    output.color0 = r0*hg_Params[1];\n"
    "    return output;\n"
    "}\n");
}

void sub_1B30225B8()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcShapeSoftEdgeClrInPlace");
}

void sub_1B30225C8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3051040;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B3022748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3022798()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3022790);
}

_QWORD *HgcShapeSoftEdgeClrInPlace::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeSoftEdgeClrInPlace [hgc1]");
}

uint64_t HgcShapeSoftEdgeClrInPlace::BindTexture(HgcShapeSoftEdgeClrInPlace *this, HGHandler *a2, int a3)
{
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;

  if (a3)
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)a2 + 136))(a2, 6, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::Bind(HgcShapeSoftEdgeClrInPlace *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  (*(void (**)(HGHandler *, uint64_t))(*(_QWORD *)a2 + 120))(a2, *((_QWORD *)this + 51) + 32);
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 1, *((_QWORD *)this + 51) + 16, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 2, *((_QWORD *)this + 51) + 32, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 3, *((_QWORD *)this + 51) + 48, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 4, *((_QWORD *)this + 51) + 64, 1);
  (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 144))(a2, 5, *((_QWORD *)this + 51) + 80, 1);
  (*(void (**)(HgcShapeSoftEdgeClrInPlace *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::RenderFragment(uint64_t a1, float32x4_t *a2, int32x2_t *a3)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t *v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x4_t *v14;
  float32x4_t v15;

  *(float32x2_t *)v3.f32 = vadd_f32(vcvt_f32_s32(*a3), (float32x2_t)0x3F0000003F000000);
  v3.i64[1] = 0x3F80000000000000;
  v4 = a2[1];
  v5 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 3);
  v6 = *(float32x4_t **)(a1 + 408);
  v7 = v6[10];
  v8 = v6[11];
  v9 = vminq_f32(vmaxq_f32(vrecpeq_f32(v5), v7), v8);
  v10 = vminq_f32(vmaxq_f32(vmulq_f32(v9, vrecpsq_f32(v5, v9)), v7), v8);
  v11 = a3[11].i32[0];
  v12 = vsubq_f32(vmulq_f32(v4, vmulq_f32(v10, vrecpsq_f32(v5, v10))), v3);
  v13 = vaddq_s32(vcvtq_s32_f32(v12), vcltzq_f32(v12));
  v12.i64[0] = vsubq_f32(v12, vcvtq_f32_s32(v13)).u64[0];
  v14 = (float32x4_t *)(*(_QWORD *)&a3[10] + 16 * (v13.i32[0] + v13.i32[1] * (int)v11));
  v15 = vaddq_f32(*v14, vmulq_n_f32(vsubq_f32(v14[1], *v14), v12.f32[0]));
  *(float32x4_t *)*(_QWORD *)&a3[2] = vmulq_f32(v6[1], vmulq_f32(*v6, vaddq_f32(v15, vmulq_lane_f32(vsubq_f32(vaddq_f32(v14[v11], vmulq_n_f32(vsubq_f32(v14[(int)v11 + 1], v14[v11]), v12.f32[0])), v15), *(float32x2_t *)v12.f32, 1))));
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::RenderTile(HgcShapeSoftEdgeClrInPlace *this, int32x2_t *a2)
{
  int32x2_t v2;
  int v3;
  int v4;
  float32x4_t v5;
  int v6;
  int32x2_t v7;
  uint64_t v8;
  float32x4_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t *v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t v19;
  int32x4_t v20;
  float32x4_t *v21;
  float32x4_t v22;

  v2 = *a2;
  v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    v6 = a2[1].i32[0] - v2.i32[0];
    v7 = a2[2];
    v8 = 16 * a2[3].i32[0];
    v9 = v5;
    do
    {
      if (v6 >= 1)
      {
        v10 = 0;
        v11 = v9;
        do
        {
          v12 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
          v13 = (float32x4_t *)*((_QWORD *)this + 51);
          v14 = v13[10];
          v15 = v13[11];
          v16 = vminq_f32(vmaxq_f32(vrecpeq_f32(v12), v14), v15);
          v17 = vminq_f32(vmaxq_f32(vmulq_f32(v16, vrecpsq_f32(v12, v16)), v14), v15);
          v18 = a2[11].i32[0];
          v19 = vsubq_f32(vmulq_f32(v11, vmulq_f32(v17, vrecpsq_f32(v12, v17))), v5);
          v20 = vaddq_s32(vcvtq_s32_f32(v19), vcltzq_f32(v19));
          v19.i64[0] = vsubq_f32(v19, vcvtq_f32_s32(v20)).u64[0];
          v21 = (float32x4_t *)(*(_QWORD *)&a2[10] + 16 * (v20.i32[0] + v20.i32[1] * (int)v18));
          v22 = vaddq_f32(*v21, vmulq_n_f32(vsubq_f32(v21[1], *v21), v19.f32[0]));
          *(float32x4_t *)(*(_QWORD *)&v7 + v10) = vmulq_f32(v13[1], vmulq_f32(*v13, vaddq_f32(v22, vmulq_lane_f32(vsubq_f32(vaddq_f32(v21[v18], vmulq_n_f32(vsubq_f32(v21[(int)v18 + 1], v21[v18]), v19.f32[0])), v22), *(float32x2_t *)v19.f32, 1))));
          v11 = vaddq_f32(v11, (float32x4_t)xmmword_1B304F230);
          v10 += 16;
        }
        while (16 * v6 != v10);
      }
      v9 = vaddq_f32(v9, (float32x4_t)xmmword_1B304F240);
      ++v4;
      *(_QWORD *)&v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcShapeSoftEdgeClrInPlace::GetDOD(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  const HGTransform *v9;
  uint64_t v10;
  uint64_t v11;
  HGTransformUtils *v12;
  float v13;
  uint64_t DOD;
  uint64_t v15;
  float64x2_t v17[9];
  HGRect v18;

  if (a3)
    return 0;
  v5 = *(_QWORD *)&a4.var2;
  v6 = *(_QWORD *)&a4.var0;
  v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  v9 = (const HGTransform *)HGRectGrow(v6, v5, v8);
  v11 = v10;
  HGTransform::HGTransform((HGTransform *)v17);
  HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((_QWORD *)this + 51) + 32));
  HGTransform::Invert2D((HGTransform *)v17);
  v13 = HGTransformUtils::MinW(v12);
  *(_QWORD *)&v18.var0 = v11;
  DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v17, v9, v18, 0.5, v13);
  v4 = HGRectUnion(0, 0, DOD, v15);
  HGTransform::~HGTransform((HGTransform *)v17);
  return v4;
}

void sub_1B3022C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HgcShapeSoftEdgeClrInPlace::GetROI(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  HGTransformUtils *v8;
  float v9;
  uint64_t ROI;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float64x2_t v17[9];
  HGRect v18;

  v4 = 0;
  if (!a3)
  {
    v5 = *(_QWORD *)&a4.var2;
    v6 = *(_QWORD *)&a4.var0;
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::LoadMatrixf(v17, (float32x2_t *)(*((_QWORD *)this + 51) + 32));
    v9 = HGTransformUtils::MinW(v8);
    *(_QWORD *)&v18.var0 = v5;
    ROI = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v18, 0.5, v9);
    v12 = HGRectUnion(0, 0, ROI, v11);
    v14 = v13;
    HGTransform::~HGTransform((HGTransform *)v17);
    v15 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v12, v14, v15);
  }
  return v4;
}

void sub_1B3022D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HGTransform::~HGTransform((HGTransform *)&a9);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeClrInPlace::HgcShapeSoftEdgeClrInPlace(HgcShapeSoftEdgeClrInPlace *this)
{
  uint64_t v2;
  uint64_t v3;

  HGNode3D::HGNode3D(this);
  *(_QWORD *)v2 = off_1E65EBA30;
  *(_DWORD *)(v2 + 416) = 1;
  v3 = operator new();
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 48) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 64) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 80) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 96) = xmmword_1B304F230;
  *(_OWORD *)(v3 + 112) = xmmword_1B304F240;
  *(_OWORD *)(v3 + 128) = xmmword_1B304F250;
  *(_OWORD *)(v3 + 144) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 160) = xmmword_1B30527A0;
  *(int32x4_t *)(v3 + 176) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 51) = v3;
  (*(void (**)(HgcShapeSoftEdgeClrInPlace *, _QWORD, uint64_t))(*(_QWORD *)this + 136))(this, 0, 1);
  *((_DWORD *)this + 4) |= 0x601u;
}

void sub_1B3022E64(_Unwind_Exception *a1)
{
  HGMipmapLevel *v1;

  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HgcShapeSoftEdgeClrInPlace::~HgcShapeSoftEdgeClrInPlace(HgcShapeSoftEdgeClrInPlace *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EBA30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C408070C27FLL);
  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  void *v1;

  HgcShapeSoftEdgeClrInPlace::~HgcShapeSoftEdgeClrInPlace(this);
  HGObject::operator delete(v1);
}

uint64_t HgcShapeSoftEdgeClrInPlace::SetParameter(HgcShapeSoftEdgeClrInPlace *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 51);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  v11 = 1;
  *((_DWORD *)this + 104) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v11;
}

uint64_t HgcShapeSoftEdgeClrInPlace::GetParameter(HgcShapeSoftEdgeClrInPlace *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

double HgcShapeSoftEdgeClrInPlace::GetOutput(HgcShapeSoftEdgeClrInPlace *this, HGRenderer *a2)
{
  uint64_t v2;
  __int128 v3;
  double result;

  if (*((_DWORD *)this + 104))
  {
    v2 = *((_QWORD *)this + 51);
    v3 = *(_OWORD *)(v2 + 112);
    *(_OWORD *)(v2 + 32) = *(unint64_t *)(v2 + 96);
    *(_OWORD *)(*((_QWORD *)this + 51) + 48) = (unint64_t)v3;
    *(_OWORD *)(*((_QWORD *)this + 51) + 64) = xmmword_1B304F250;
    result = 0.0;
    *(_OWORD *)(*((_QWORD *)this + 51) + 80) = xmmword_1B304EFF0;
    *((_DWORD *)this + 104) = 0;
  }
  return result;
}

const char *HgcShapeGradientBlend::GetProgram(HgcShapeGradientBlend *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002de\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = float4(r0)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0df246b2:91c6b5d4:f02b9e9b:5bc3bb86\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = r0*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c316191:1aca7ae1:745f6a82:ec814054\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000023f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    gl_FragColor = r0*r1;\n"
           "}\n"
           "//MD5=f3072827:20dc9050:204f7dc4:c2f25be5\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcShapeGradientBlend::InitProgramDescriptor(HgcShapeGradientBlend *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcShapeGradientBlend_hgc_visible", "//Metal1.0     \n//LEN=0000000125\n[[ visible ]] FragmentOut HgcShapeGradientBlend_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    output.color0 = r0*r1;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B30230CC()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcShapeGradientBlend");
}

void sub_1B30230DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B30514B0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B302321C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3023264()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B302325CLL);
}

_QWORD *HgcShapeGradientBlend::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcShapeGradientBlend [hgc1]");
}

uint64_t HgcShapeGradientBlend::BindTexture(HgcShapeGradientBlend *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    if (a3)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcShapeGradientBlend::Bind(HgcShapeGradientBlend *this, HGHandler *a2)
{
  (*(void (**)(HgcShapeGradientBlend *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcShapeGradientBlend::RenderTile(HgcShapeGradientBlend *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t *v16;
  uint64_t v17;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 12);
    v7 = 16 * *((int *)a2 + 22);
    v8 = *((_QWORD *)a2 + 10);
    v9 = 16 * *((int *)a2 + 26);
    v10 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v17) = 0;
      }
      else
      {
        v11 = 0;
        v12 = 32;
        do
        {
          v13 = vmulq_f32(*(float32x4_t *)(v8 + v12 - 16), *(float32x4_t *)(v6 + v12 - 16));
          v14 = vmulq_f32(*(float32x4_t *)(v8 + v12), *(float32x4_t *)(v6 + v12));
          v15 = vmulq_f32(*(float32x4_t *)(v8 + v12 + 16), *(float32x4_t *)(v6 + v12 + 16));
          v16 = (float32x4_t *)(v5 + v12);
          v16[-2] = vmulq_f32(*(float32x4_t *)(v8 + v12 - 32), *(float32x4_t *)(v6 + v12 - 32));
          v16[-1] = v13;
          *v16 = v14;
          v16[1] = v15;
          v11 -= 4;
          v12 += 64;
        }
        while (v4 + v11 > 3);
        LODWORD(v17) = -v11;
      }
      if ((int)v17 < v4)
      {
        v17 = v17;
        do
        {
          *(float32x4_t *)(v5 + 16 * v17) = vmulq_f32(*(float32x4_t *)(v8 + 16 * v17), *(float32x4_t *)(v6 + 16 * v17));
          ++v17;
        }
        while (v17 < v4);
      }
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcShapeGradientBlend::GetDOD(HgcShapeGradientBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcShapeGradientBlend::GetROI(HgcShapeGradientBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcShapeGradientBlend::HgcShapeGradientBlend(HgcShapeGradientBlend *this)
{
  _QWORD *v2;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65EBCA8;
  *((_QWORD *)this + 51) = operator new();
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B3023514(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcShapeGradientBlend::~HgcShapeGradientBlend(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EBCA8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0xC400A2AC0F1);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcShapeGradientBlend::~HgcShapeGradientBlend(this);
  HGObject::operator delete(v1);
}

uint64_t HgcShapeGradientBlend::SetParameter(HgcShapeGradientBlend *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcShapeGradientBlend::GetParameter(HgcShapeGradientBlend *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

PGContext *PGContextHelper::destroyPGContext(PGContext *this, const PGContext *a2)
{
  if (this)
  {
    PGContext::~PGContext(this);
    JUMPOUT(0x1B5E29170);
  }
  return this;
}

uint64_t (*createPGContextPtr@<X0>(const ProGL::ContextHandle *a1@<X0>, _QWORD *a2@<X8>))(ProGL::ContextHandle *this)
{
  uint64_t (*result)(ProGL::ContextHandle *);
  uint64_t v5;
  BOOL v6;
  int v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  result = ProGL::ContextHandle::operator void (ProGL::ContextHandle::*)(void)const(a1);
  if (v5)
    v6 = (v5 & 1 | (unint64_t)result) == 0;
  else
    v6 = 1;
  v7 = v6;
  if (result || !v7)
  {
    v8 = (_QWORD *)operator new();
    *v8 = 0;
    v8[1] = 0;
    v9 = *((_QWORD *)a1 + 1);
    v8[2] = *(_QWORD *)a1;
    v8[3] = v9;
    if (v9)
    {
      v10 = (unint64_t *)(v9 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    return (uint64_t (*)(ProGL::ContextHandle *))std::shared_ptr<PGContext>::shared_ptr[abi:ne180100]<PGContext,PGContextDeleter,void>(a2, v8);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return result;
}

void PGInitPGContext(void)
{
  pthread_key_t *v0;

  {
    v0 = (pthread_key_t *)operator new();
    pthread_key_create(v0, (void (__cdecl *)(void *))PCThreadSpecific<std::shared_ptr<PGContext>>::destroy);
  }
}

void sub_1B30236A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x1000C4000313F17);
  _Unwind_Resume(a1);
}

uint64_t PGGetPerThreadContext(void)
{
  pthread_key_t *v0;
  _QWORD *v1;
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  _QWORD v6[2];
  __int128 v7;

  {
    NSLog(CFSTR("sPerThreadContexts == 0 in PGGetPerThreadContext()"));
  }
  v1 = pthread_getspecific(*v0);
  if (!v1)
  {
    v1 = (_QWORD *)operator new();
    *v1 = 0;
    v1[1] = 0;
    ProGL::getPerThreadContext(v6);
    createPGContextPtr((const ProGL::ContextHandle *)v6, &v7);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)v1, &v7);
    v2 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
    if (*((_QWORD *)&v7 + 1))
    {
      v3 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 - 1, v3));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v6);
  }
  return *v1;
}

void sub_1B30237B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void PGFindContext(EAGLContext *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD v3[2];

  if (a1)
  {
    ProGL::findContext((_anonymous_namespace_ *)a1, v3);
    createPGContextPtr((const ProGL::ContextHandle *)v3, a2);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v3);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1B3023814(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void PGFindContext(const ProGL::GL *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD v3[2];

  ProGL::GL::getPGLContextHandle(a1, v3);
  createPGContextPtr((const ProGL::ContextHandle *)v3, a2);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v3);
}

void sub_1B3023868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void PGContext::~PGContext(PGContext *this)
{
  std::__shared_weak_count *v2;

  ProGL::ContextHandle::~ContextHandle((PGContext *)((char *)this + 16));
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t PGContext::getVirtualScreen(PGContext *this)
{
  return ProGL::ContextHandle::getVirtualScreen((PGContext *)((char *)this + 16));
}

uint64_t PGContext::setVirtualScreen(PGContext *this)
{
  return ProGL::ContextHandle::setVirtualScreen((PGContext *)((char *)this + 16));
}

void PGSetCurrentContextSentry::PGSetCurrentContextSentry(PGSetCurrentContextSentry *this)
{
  ProGL::CurrentContextSentry *v1;

  v1 = ProGL::CurrentContextSentry::CurrentContextSentry(this);
  *((_QWORD *)v1 + 2) = 0;
  *((_QWORD *)v1 + 3) = 0;
}

void PGSetCurrentContextSentry::PGSetCurrentContextSentry(PGSetCurrentContextSentry *this, const PGContext *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  if (a2)
  {
    v4 = *((_QWORD *)a2 + 3);
    v8 = *((_QWORD *)a2 + 2);
    v9 = v4;
    if (v4)
    {
      v5 = (unint64_t *)(v4 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
  }
  else
  {
    v8 = 0;
    v9 = 0;
  }
  ProGL::CurrentContextSentry::CurrentContextSentry(this, (const ProGL::ContextHandle *)&v8);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v8);
  v7 = (_QWORD *)((char *)this + 16);
  if (a2)
  {
    std::shared_ptr<OZStyle>::shared_ptr[abi:ne180100]<OZStyle,void>(v7, a2);
  }
  else
  {
    *v7 = 0;
    *((_QWORD *)this + 3) = 0;
  }
}

void sub_1B302395C(_Unwind_Exception *a1)
{
  ProGL::CurrentContextSentry *v1;

  ProGL::CurrentContextSentry::~CurrentContextSentry(v1);
  _Unwind_Resume(a1);
}

void PGSetCurrentContextSentry::PGSetCurrentContextSentry(PGSetCurrentContextSentry *this, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD v10[2];

  v4 = *(_QWORD *)(*a2 + 24);
  v10[0] = *(_QWORD *)(*a2 + 16);
  v10[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  ProGL::CurrentContextSentry::CurrentContextSentry(this, (const ProGL::ContextHandle *)v10);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v10);
  *((_QWORD *)this + 2) = *a2;
  v7 = a2[1];
  *((_QWORD *)this + 3) = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
}

void sub_1B3023A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  _Unwind_Resume(a1);
}

void PGSetCurrentContextSentry::~PGSetCurrentContextSentry(PGSetCurrentContextSentry *this)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
  ProGL::CurrentContextSentry::~CurrentContextSentry(this);
}

void PGPerThreadSetCurrentContextSentry::PGPerThreadSetCurrentContextSentry(PGPerThreadSetCurrentContextSentry *this)
{
  _QWORD *v2;
  uint64_t *v3;
  ProGL::CurrentContextSentry *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD v9[2];

  v2 = (_QWORD *)PGGetPerThreadContext();
  v3 = std::shared_ptr<OZStyle>::shared_ptr[abi:ne180100]<OZStyle,void>(this, v2);
  v5 = *v3;
  v4 = (ProGL::CurrentContextSentry *)(v3 + 2);
  v6 = *(_QWORD *)(v5 + 24);
  v9[0] = *(_QWORD *)(v5 + 16);
  v9[1] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  ProGL::CurrentContextSentry::CurrentContextSentry(v4, (const ProGL::ContextHandle *)v9);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v9);
}

void sub_1B3023ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a9);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v9);
  _Unwind_Resume(a1);
}

void PGPerThreadSetCurrentContextSentry::~PGPerThreadSetCurrentContextSentry(PGPerThreadSetCurrentContextSentry *this)
{
  ProGL::CurrentContextSentry::~CurrentContextSentry((PGPerThreadSetCurrentContextSentry *)((char *)this + 16));
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

void PGGetCurrentPGContext(_QWORD *a1@<X8>)
{
  PGFindContext((EAGLContext *)objc_msgSend(MEMORY[0x1E0CD0958], "currentContext"), a1);
}

_QWORD *std::shared_ptr<PGContext>::shared_ptr[abi:ne180100]<PGContext,PGContextDeleter,void>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E65EBF10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_1B3023B98(void *a1)
{
  PGContext *v1;
  const PGContext *v2;

  __cxa_begin_catch(a1);
  PGContextHelper::destroyPGContext(v1, v2);
  __cxa_rethrow();
}

void sub_1B3023BAC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

PGContext *std::__shared_ptr_pointer<PGContext *,PGContextDeleter,std::allocator<PGContext>>::__on_zero_shared(uint64_t a1, const PGContext *a2)
{
  return PGContextHelper::destroyPGContext(*(PGContext **)(a1 + 24), a2);
}

uint64_t std::__shared_ptr_pointer<PGContext *,PGContextDeleter,std::allocator<PGContext>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

uint64_t PCThreadSpecific<std::shared_ptr<PGContext>>::destroy(uint64_t result)
{
  if (result)
  {
    std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t *PGTextureHelper::new2DTexture@<X0>(PGTextureHelper *this@<X0>, ProGL::GL *a2@<X1>, int a3@<W2>, int a4@<W3>, GLint a5@<W4>, GLenum a6@<W6>, GLenum a7@<W7>, uint64_t *a8@<X8>, CGColorSpace **a9, const PCColorSpaceHandle *a10, void *a11)
{
  int v16;
  PGTexture2D *v18;
  int v19;

  v16 = (int)a2;
  v18 = (PGTexture2D *)operator new();
  PGTexture2D::PGTexture2D(v18, this, v16, a3, a9, a4, a5, v19, a6, a7, a10);
  return std::shared_ptr<PGTexture2D>::shared_ptr[abi:ne180100]<PGTexture2D,PGTextureHelper,void>(a8, (uint64_t)v18);
}

void sub_1B3023CE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C401276B8E6);
  _Unwind_Resume(a1);
}

uint64_t *PGTextureHelper::new2DTexture@<X0>(ProGL::Private::TextureImpl **this@<X0>, uint64_t *a2@<X8>)
{
  PGTexture2D *v5;

  v5 = (PGTexture2D *)operator new();
  PGTexture2D::PGTexture2D(v5, this);
  return std::shared_ptr<PGTexture2D>::shared_ptr[abi:ne180100]<PGTexture2D,PGTextureHelper,void>(a2, (uint64_t)v5);
}

void sub_1B3023D58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C401276B8E6);
  _Unwind_Resume(a1);
}

void PGCreateTextureFromPGLTexture(void (**a1)(_anonymous_namespace_ **this)@<X0>, _QWORD *a2@<X8>)
{
  void (*v4)(_anonymous_namespace_ **);
  uint64_t v5;
  BOOL v6;
  char v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 v11;

  v4 = ProGL::TextureHandle::operator void (ProGL::TextureHandle::*)(void)(a1);
  if (v5)
    v6 = (v5 & 1 | (unint64_t)v4) == 0;
  else
    v6 = 1;
  v7 = v6;
  *a2 = 0;
  a2[1] = 0;
  if ((v4 || (v7 & 1) == 0)
    && ProGL::TextureHandle::getTarget((ProGL::Private::TextureImpl **)a1) == 3553)
  {
    PGTextureHelper::new2DTexture((ProGL::Private::TextureImpl **)a1, (uint64_t *)&v11);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)a2, &v11);
    v8 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
    if (*((_QWORD *)&v11 + 1))
    {
      v9 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
}

void sub_1B3023E28(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void PGTexture::PGTexture(PGTexture *this, ProGL::GL *a2, int a3, int a4, CGColorSpace **a5, int a6, _anonymous_namespace_ *a7, _anonymous_namespace_ *a8)
{
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  CGColorSpace *v20[4];

  if (a3 >= 4096)
    v12 = 4096;
  else
    v12 = a3;
  if (v12 <= 1)
    v13 = 1;
  else
    v13 = v12;
  if (a4 >= 4096)
    v14 = 4096;
  else
    v14 = a4;
  if (v14 <= 1)
    v15 = 1;
  else
    v15 = v14;
  PCImage::PCImage((uint64_t)this, v13, v15, v16, v17, a5);
  *(_QWORD *)this = &unk_1E65EBF70;
  ProGL::createTexture(a2, (_QWORD *)this + 8);
  *((_DWORD *)this + 6) = 2;
  v18 = (*(uint64_t (**)(PGTexture *))(*(_QWORD *)this + 16))(this);
  v19 = (*(uint64_t (**)(PGTexture *))(*(_QWORD *)this + 24))(this);
  v20[0] = 0;
  v20[1] = 0;
  *(double *)&v20[2] = (double)v18;
  *(double *)&v20[3] = (double)v19;
  ProGL::TextureHandle::setTextureCoords((uint64_t *)this + 8, (uint64_t)v20);
  PCImage::getColorSpace(this, v20);
  ProGL::TextureHandle::setColorSpace((CGColorSpace **)this + 8, v20);
  PCCFRef<CGColorSpace *>::~PCCFRef(v20);
}

void sub_1B3023F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9)
{
  CGColorSpace **v9;
  uint64_t v10;

  PCCFRef<CGColorSpace *>::~PCCFRef(&a9);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v10);
  PCImage::~PCImage(v9);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::glTypeToDepth(_anonymous_namespace_ *this)
{
  unsigned int v1;
  unsigned int v2;

  if (((_DWORD)this - 34234) >= 2)
    v1 = 1;
  else
    v1 = 8;
  if (((1 << (char)this) & 3) != 0)
    v2 = 8;
  else
    v2 = 16;
  if (((1 << (char)this) & 0x70) != 0)
    v2 = 32;
  if (((_DWORD)this - 5120) <= 6)
    return v2;
  else
    return v1;
}

uint64_t `anonymous namespace'::glFormatToNumberOfChannels(_anonymous_namespace_ *this)
{
  int v1;
  uint64_t result;

  v1 = (_DWORD)this - 6406;
  result = 1;
  switch(v1)
  {
    case 0:
    case 3:
      return result;
    case 1:
      result = 3;
      break;
    case 4:
      result = 2;
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

void PGTexture::PGTexture(PGTexture *this, ProGL::Private::TextureImpl **a2)
{
  int Width;
  int Height;
  _anonymous_namespace_ *ActualInternalFormat;
  int v7;
  uint64_t (**v8)(PGTexture *);
  ProGL::Private::TextureImpl *v9;
  unint64_t *v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  CGColorSpace *v14[4];

  Width = ProGL::TextureHandle::getWidth(a2);
  Height = ProGL::TextureHandle::getHeight(a2);
  ActualInternalFormat = ProGL::TextureHandle::getActualInternalFormat(a2);
  ProGL::TextureHandle::getColorSpace(a2, v14);
  PCImage::PCImage((uint64_t)this, Width, Height, 32, v7, v14);
  PCCFRef<CGColorSpace *>::~PCCFRef(v14);
  v8 = (uint64_t (**)(PGTexture *))&unk_1E65EBF70;
  *(_QWORD *)this = &unk_1E65EBF70;
  *((_QWORD *)this + 8) = *a2;
  v9 = a2[1];
  *((_QWORD *)this + 9) = v9;
  if (v9)
  {
    v10 = (unint64_t *)((char *)v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    v8 = *(uint64_t (***)(PGTexture *))this;
  }
  *((_DWORD *)this + 6) = 2;
  v12 = v8[2](this);
  v13 = (*(uint64_t (**)(PGTexture *))(*(_QWORD *)this + 24))(this);
  v14[0] = 0;
  v14[1] = 0;
  *(double *)&v14[2] = (double)v12;
  *(double *)&v14[3] = (double)v13;
  ProGL::TextureHandle::setTextureCoords((uint64_t *)this + 8, (uint64_t)v14);
  PCImage::getColorSpace(this, v14);
  ProGL::TextureHandle::setColorSpace((CGColorSpace **)this + 8, v14);
  PCCFRef<CGColorSpace *>::~PCCFRef(v14);
}

void sub_1B3024168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9)
{
  CGColorSpace **v9;
  uint64_t v10;

  PCCFRef<CGColorSpace *>::~PCCFRef(&a9);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v10);
  PCImage::~PCImage(v9);
  _Unwind_Resume(a1);
}

ProGL::Private::TextureImpl *PGTexture::getSize(PGTexture *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  ProGL::Private::TextureImpl *Size;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  ProGL::Private::TextureImpl *v9;
  std::__shared_weak_count *v10;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 9);
  v9 = (ProGL::Private::TextureImpl *)*((_QWORD *)this + 8);
  v10 = v1;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldxr(p_shared_owners);
    while (__stxr(v3 + 1, p_shared_owners));
  }
  Size = ProGL::TextureHandle::getSize(&v9);
  v5 = v10;
  if (v10)
  {
    v6 = (unint64_t *)&v10->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return Size;
}

void sub_1B3024230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t PGTexture::getPGLTexture@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 72);
  *a2 = *(_QWORD *)(this + 64);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t PGTexture::bind(ProGL::Private::TextureImpl **this)
{
  GLenum Target;
  _BYTE v4[40];

  ProGL::GL::GL((ProGL::GL *)v4);
  this += 8;
  Target = ProGL::TextureHandle::getTarget(this);
  ProGL::TextureHandle::bind((OZChannelBase **)this, (ProGL::GL *)v4, Target);
  ProGL::GL::~GL((ProGL::GL *)v4);
  return 1;
}

void sub_1B30242BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

uint64_t PGTexture::unbind(OZChannelBase **this)
{
  _BYTE v3[40];

  ProGL::GL::GL((ProGL::GL *)v3);
  ProGL::TextureHandle::unbind(this + 8, (ProGL::GL *)v3);
  ProGL::GL::~GL((ProGL::GL *)v3);
  return 1;
}

void sub_1B3024314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

uint64_t PGTexture::enable(ProGL::Private::TextureImpl **this)
{
  GLenum Target;

  Target = ProGL::TextureHandle::getTarget(this + 8);
  glEnable(Target);
  return 1;
}

uint64_t PGTexture::disable(ProGL::Private::TextureImpl **this)
{
  _BYTE v3[40];

  ProGL::GL::GL((ProGL::GL *)v3);
  PGTexture::disable(this, (ProGL::GL *)v3);
  ProGL::GL::~GL((ProGL::GL *)v3);
  return 1;
}

void sub_1B302438C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

uint64_t PGTexture::disable(ProGL::Private::TextureImpl **this, ProGL::GL *a2)
{
  OZChannelBase **v3;
  GLenum Target;

  v3 = (OZChannelBase **)(this + 8);
  if (ProGL::TextureHandle::isBound(this + 8))
  {
    ProGL::TextureHandle::unbind(v3, a2);
  }
  else
  {
    Target = ProGL::TextureHandle::getTarget((ProGL::Private::TextureImpl **)v3);
    glBindTexture(Target, 0);
  }
  return 1;
}

void PGTexture::setParameteri(OZChannelBase **this, GLenum a2, GLint a3)
{
  _BYTE v6[40];

  ProGL::GL::GL((ProGL::GL *)v6);
  ProGL::TextureHandle::texParameter(this + 8, (ProGL::GL *)v6, a2, a3);
  ProGL::GL::~GL((ProGL::GL *)v6);
}

void sub_1B3024448(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

double PGTexture::setTexCoords(uint64_t a1, float32x2_t *a2)
{
  float64x2_t v2;
  double result;
  _OWORD v4[2];

  v2 = vcvtq_f64_f32(a2[1]);
  v4[0] = vcvtq_f64_f32(*a2);
  v4[1] = v2;
  *(_QWORD *)&result = ProGL::TextureHandle::setTextureCoords((uint64_t *)(a1 + 64), (uint64_t)v4).n128_u64[0];
  return result;
}

float64_t PGTexture::getTexCoords(uint64_t a1, float32x4_t *a2)
{
  float64_t result;
  float64x2_t v4;
  float64x2_t v5;

  ProGL::TextureHandle::getTextureCoords((ProGL::TextureHandle *)(a1 + 64), (__n128 *)&v4);
  result = v5.f64[0];
  *a2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v4), v5);
  return result;
}

double PGTexture::getTexCoords(PGTexture *this, double *a2, double *a3, double *a4, double *a5)
{
  __n128 v9;
  double v10;
  double v11;
  double result;
  __n128 v13;
  double v14;
  double v15;

  ProGL::TextureHandle::getTextureCoords((PGTexture *)((char *)this + 64), &v13);
  v9 = v13;
  v10 = v14;
  v11 = v15;
  *a2 = v13.n128_f64[0];
  *a3 = v9.n128_f64[0] + v10;
  *a4 = v9.n128_f64[1];
  result = v9.n128_f64[1] + v11;
  *a5 = v9.n128_f64[1] + v11;
  return result;
}

void PGTexture::getContext(PGTexture *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD v3[2];
  _BYTE v4[40];

  ProGL::TextureHandle::getContext((PGTexture *)((char *)this + 64), v3);
  ProGL::GL::GL((ProGL::GL *)v4, (const ProGL::ContextHandle *)v3);
  PGFindContext((const ProGL::GL *)v4, a2);
  ProGL::GL::~GL((ProGL::GL *)v4);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v3);
}

void sub_1B302458C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  ProGL::GL::~GL((ProGL::GL *)va1);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va);
  _Unwind_Resume(a1);
}

ProGL::Private::TextureImpl *PGTexture::getFormat(ProGL::Private::TextureImpl **this)
{
  return ProGL::TextureHandle::getActualInternalFormat(this + 8);
}

uint64_t PGTexture::getAttributes(uint64_t a1, uint64_t a2)
{
  ProGL::Private::TextureImpl **v3;
  PCPixelFormat *ActualInternalFormat;
  uint64_t result;

  v3 = (ProGL::Private::TextureImpl **)a1;
  PCImage::getAttributes(a1, a2);
  v3 += 8;
  *(_DWORD *)(a2 + 32) = ProGL::TextureHandle::getTarget(v3);
  ActualInternalFormat = ProGL::TextureHandle::getActualInternalFormat(v3);
  result = PCPixelFormat::getPixelFormat(ActualInternalFormat, 5125);
  *(_DWORD *)(a2 + 20) = result;
  return result;
}

void PGTexture::toBitmap(PGTexture *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PCPrint("File %s, line %d should not have been reached:\n\t", a2, a3, a4, a5, a6, a7, a8, (char)"/Library/Caches/com.apple.xbs/Sources/MotioniOS/ProGraphics/PGTexture.cpp");
  pcAbortImpl();
}

void sub_1B3024640()
{
  _QWORD *v0;

  *v0 = 0;
  v0[1] = 0;
}

CGColorSpace **PGTexture::setColorSpace(CGColorSpace **this, CGColorSpace **a2)
{
  CGColorSpace *v4;

  PCImage::setColorSpace((uint64_t)this, a2);
  PCImage::getColorSpace((PCImage *)this, &v4);
  ProGL::TextureHandle::setColorSpace(this + 8, &v4);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v4);
}

void sub_1B30246A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PGTexture2D::PGTexture2D(PGTexture2D *this, ProGL::GL *a2, int a3, int a4, CGColorSpace **a5, int a6, GLint a7, int a8, GLenum a9, GLenum a10, void *a11)
{
  PCImage *v15;
  int v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  OZChannelBase *v23;
  std::__shared_weak_count *v24;

  PGTexture::PGTexture(this, a2, a3, a4, a5, a6, (_anonymous_namespace_ *)a9, (_anonymous_namespace_ *)a10);
  *(_QWORD *)v15 = &off_1E65EBFD0;
  *((_DWORD *)this + 20) = PCImage::getWidth(v15) + 2 * a6;
  v16 = (*(uint64_t (**)(PGTexture2D *))(*(_QWORD *)this + 24))(this);
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 21) = v16 + 2 * a6;
  *((_QWORD *)this + 12) = 0;
  v17 = (std::__shared_weak_count *)*((_QWORD *)this + 9);
  v23 = (OZChannelBase *)*((_QWORD *)this + 8);
  v24 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
  }
  ProGL::TextureHandle::bind(&v23, a2, 0xDE1u);
  ProGL::TextureHandle::texParameter(&v23, a2, 0x2801u, 9729);
  ProGL::TextureHandle::texParameter(&v23, a2, 0x2800u, 9729);
  ProGL::TextureHandle::texParameter(&v23, a2, 0x2802u, 33071);
  ProGL::TextureHandle::texParameter(&v23, a2, 0x2803u, 33071);
  ProGL::TextureHandle::texImage2D(&v23, a2, 0xDE1u, 0, a7, *((_DWORD *)this + 20), *((_DWORD *)this + 21), a6, a9, a10, a11);
  PGTexture::disable((ProGL::Private::TextureImpl **)this, a2);
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1B3024840(_Unwind_Exception *a1)
{
  CGColorSpace **v1;

  *v1 = (CGColorSpace *)&unk_1E65EBF70;
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(v1 + 8));
  PCImage::~PCImage(v1);
  _Unwind_Resume(a1);
}

void PGTexture2D::PGTexture2D(PGTexture2D *this, ProGL::Private::TextureImpl **a2)
{
  PCImage *v4;
  int Width;
  int v6;
  unsigned int Border;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  OZChannelBase *v14;
  std::__shared_weak_count *v15;
  _BYTE v16[40];

  PGTexture::PGTexture(this, a2);
  *(_QWORD *)v4 = &off_1E65EBFD0;
  Width = PCImage::getWidth(v4);
  *((_DWORD *)this + 20) = Width + 2 * ProGL::TextureHandle::getBorder(a2);
  v6 = (*(uint64_t (**)(PGTexture2D *))(*(_QWORD *)this + 24))(this);
  Border = ProGL::TextureHandle::getBorder(a2);
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 21) = v6 + 2 * Border;
  *((_QWORD *)this + 12) = 0;
  ProGL::GL::GL((ProGL::GL *)v16);
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 9);
  v14 = (OZChannelBase *)*((_QWORD *)this + 8);
  v15 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  ProGL::TextureHandle::bind(&v14, (ProGL::GL *)v16, 0xDE1u);
  PGTexture::disable((ProGL::Private::TextureImpl **)this, (ProGL::GL *)v16);
  v11 = v15;
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  ProGL::GL::~GL((ProGL::GL *)v16);
}

void sub_1B3024990(_Unwind_Exception *a1)
{
  CGColorSpace **v1;
  uint64_t v2;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v2);
  *v1 = (CGColorSpace *)&unk_1E65EBF70;
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(v1 + 8));
  PCImage::~PCImage(v1);
  _Unwind_Resume(a1);
}

void PGTexture2D::~PGTexture2D(CGColorSpace **this)
{
  *this = (CGColorSpace *)&off_1E65EBFD0;
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(this + 11));
  *this = (CGColorSpace *)&unk_1E65EBF70;
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(this + 8));
  PCImage::~PCImage(this);
}

{
  PGTexture2D::~PGTexture2D(this);
  JUMPOUT(0x1B5E29170);
}

CGColorSpace **PGTexture2D::setBitmapRef(ProGL::Private::TextureImpl **a1, PCImage **a2)
{
  GLenum Target;
  GLint Border;
  GLint v6;
  GLsizei v7;
  GLsizei v8;
  GLenum ActualInternalFormat;
  const GLvoid *pixels;
  CGColorSpace *v12;

  PGTexture::bind(a1);
  Target = ProGL::TextureHandle::getTarget(a1 + 8);
  Border = ProGL::TextureHandle::getBorder(a1 + 8);
  v6 = ProGL::TextureHandle::getBorder(a1 + 8);
  v7 = (*((uint64_t (**)(ProGL::Private::TextureImpl **))*a1 + 2))(a1);
  v8 = (*((uint64_t (**)(ProGL::Private::TextureImpl **))*a1 + 3))(a1);
  ActualInternalFormat = ProGL::TextureHandle::getActualInternalFormat(a1 + 8);
  pixels = (const GLvoid *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)*a2 + 8) + 16))(*((_QWORD *)*a2 + 8));
  glTexSubImage2D(Target, 0, Border, v6, v7, v8, ActualInternalFormat, 0x1405u, pixels);
  glFlush();
  PGTexture::unbind((OZChannelBase **)a1);
  PCImage::getColorSpace(*a2, &v12);
  (*((void (**)(ProGL::Private::TextureImpl **, CGColorSpace **))*a1 + 7))(a1, &v12);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v12);
}

void sub_1B3024B5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void PGTexture2D::setDataPtr(ProGL::Private::TextureImpl **this, const void *a2, GLenum a3, GLenum a4)
{
  GLenum Target;
  GLint Border;
  GLint v10;
  GLsizei v11;
  GLsizei v12;

  PGTexture::bind(this);
  Target = ProGL::TextureHandle::getTarget(this + 8);
  Border = ProGL::TextureHandle::getBorder(this + 8);
  v10 = ProGL::TextureHandle::getBorder(this + 8);
  v11 = (*((uint64_t (**)(ProGL::Private::TextureImpl **))*this + 2))(this);
  v12 = (*((uint64_t (**)(ProGL::Private::TextureImpl **))*this + 3))(this);
  glTexSubImage2D(Target, 0, Border, v10, v11, v12, a3, a4, a2);
  glFlush();
  PGTexture::unbind((OZChannelBase **)this);
  std::shared_ptr<OZFontFace>::reset[abi:ne180100](this + 11);
}

void PGTexture2D::setDataPtr(ProGL::Private::TextureImpl **this, const void *a2, int a3, int a4, GLsizei a5, GLsizei a6, GLenum a7, GLenum a8)
{
  GLenum Target;
  GLint v17;
  unsigned int Border;

  PGTexture::bind(this);
  Target = ProGL::TextureHandle::getTarget(this + 8);
  v17 = ProGL::TextureHandle::getBorder(this + 8) + a3;
  Border = ProGL::TextureHandle::getBorder(this + 8);
  glTexSubImage2D(Target, 0, v17, Border + a4, a5, a6, a7, a8, a2);
  glFlush();
  PGTexture::unbind((OZChannelBase **)this);
  std::shared_ptr<OZFontFace>::reset[abi:ne180100](this + 11);
}

CGColorSpace **PGTexture2D::dumpImage(ProGL::Private::TextureImpl **this)
{
  HGGLBlendingInfo **v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v7;
  std::__shared_weak_count *v8;
  CGColorSpace *v9;

  v2 = this + 8;
  ProGL::TextureHandle::getTarget(this + 8);
  ProGL::TextureHandle::getName(v2);
  (*((void (**)(ProGL::Private::TextureImpl **))*this + 2))(this);
  (*((void (**)(ProGL::Private::TextureImpl **))*this + 3))(this);
  (*((void (**)(ProGL::Private::TextureImpl **))*this + 6))(this);
  PCImage::getColorSpace((PCImage *)this, &v9);
  PGTexture::getContext((PGTexture *)this, &v7);
  PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v9);
  v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v9);
}

void sub_1B3024DD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

void PGTexture2D::toTexture(PCImage **a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  unsigned int v5;
  GLenum GLDataFormat;
  GLenum GLDataType;
  unsigned int v8;
  int v9;
  const PCColorSpaceHandle *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  CGColorSpace *v17;
  _BYTE v18[32];
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  PCDynamicCast<PGTexture2D,PCImage>((uint64_t)a1, &v21);
  if (v21)
  {
    v4 = (uint64_t)v22;
    *a2 = v21;
    a2[1] = v4;
  }
  else
  {
    PCDynamicCast<PCBitmap,PCImage>((uint64_t)a1, &v19);
    if (v19)
    {
      v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v19 + 64) + 48))(*(_QWORD *)(v19 + 64));
      GLDataFormat = PCPixelFormat::getGLDataFormat(v5);
      GLDataType = PCPixelFormat::getGLDataType(v5);
      PGPerThreadSetCurrentContextSentry::PGPerThreadSetCurrentContextSentry((PGPerThreadSetCurrentContextSentry *)v18);
      v8 = (*(uint64_t (**)(PCImage *))(*(_QWORD *)*a1 + 16))(*a1);
      v9 = (*(uint64_t (**)(PCImage *))(*(_QWORD *)*a1 + 24))(*a1);
      PCImage::getColorSpace(*a1, &v17);
      v10 = (const PCColorSpaceHandle *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v19 + 64) + 16))(*(_QWORD *)(v19 + 64));
      PGMake2DTexture(&v17, v10, (ProGL::GL *)v8, v9, 0, GLDataFormat, GLDataType, a2);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v17);
      PGPerThreadSetCurrentContextSentry::~PGPerThreadSetCurrentContextSentry((PGPerThreadSetCurrentContextSentry *)v18);
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
    }
    v11 = v20;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v14 = v22;
    if (v22)
    {
      v15 = (unint64_t *)&v22->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
}

void sub_1B3024F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;
  uint64_t v11;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  PGPerThreadSetCurrentContextSentry::~PGPerThreadSetCurrentContextSentry((PGPerThreadSetCurrentContextSentry *)va);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

void PGMake2DTexture(CGColorSpace **a1@<X2>, const PCColorSpaceHandle *a2@<X6>, ProGL::GL *a3@<X0>, int a4@<W1>, int a5@<W3>, GLenum a6@<W4>, GLenum a7@<W5>, uint64_t *a8@<X8>)
{
  void *v16;
  _BYTE v17[40];

  ProGL::GL::GL((ProGL::GL *)v17);
  PGTextureHelper::new2DTexture((PGTextureHelper *)v17, a3, a4, a5, a6, a6, a7, a8, a1, a2, v16);
  ProGL::GL::~GL((ProGL::GL *)v17);
}

void sub_1B3025064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void PGInitTextures(void)
{
  PCSingleton *v0;
  ProGL::Private *v1;

  {
    v0 = (PCSingleton *)operator new();
    PCSingleton::PCSingleton(v0, 10000);
    *(_QWORD *)v0 = &off_1E65EC060;
    PGLInit(v1);
  }
}

void sub_1B30250D4(_Unwind_Exception *a1)
{
  PCSingleton *v1;

  PCSingleton::~PCSingleton(v1);
  MEMORY[0x1B5E29170](v1, 0x81C40B8603338);
  _Unwind_Resume(a1);
}

uint64_t PGCreateImage@<X0>(const PCImageAttributes *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  const PGContext *v8;
  GLenum GLDataFormat;
  GLenum GLDataType;
  GLenum v11;
  double v12;
  double v13;
  __n128 v14;
  const void *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  PGTexture2D *v20;
  std::__shared_weak_count *v21;
  _BYTE v22[32];
  __int128 v23;
  double v24;
  double v25;

  *a2 = 0;
  a2[1] = 0;
  if (*(_DWORD *)a1 == 2)
  {
    v8 = (const PGContext *)*((_QWORD *)a1 + 8);
    if (!v8)
      v8 = (const PGContext *)PGGetPerThreadContext();
    PGSetCurrentContextSentry::PGSetCurrentContextSentry((PGSetCurrentContextSentry *)v22, v8);
    GLDataFormat = PCPixelFormat::getGLDataFormat(*((_DWORD *)a1 + 5));
    GLDataType = PCPixelFormat::getGLDataType(*((_DWORD *)a1 + 5));
    if (*((_DWORD *)a1 + 8) == 3553)
    {
      v11 = GLDataType;
      PGMake2DTexture((CGColorSpace **)a1 + 3, *((const PCColorSpaceHandle **)a1 + 6), (ProGL::GL *)*((unsigned int *)a1 + 1), *((_DWORD *)a1 + 2), 0, GLDataFormat, GLDataType, (uint64_t *)&v20);
      std::shared_ptr<TXTextStyle>::operator=[abi:ne180100](a2, (uint64_t *)&v20);
      v12 = (double)(*((_DWORD *)a1 + 1) / *((_DWORD *)v20 + 20));
      v13 = (double)(*((_DWORD *)a1 + 2) / *((_DWORD *)v20 + 21));
      v23 = 0uLL;
      v24 = v12;
      v25 = v13;
      v14 = ProGL::TextureHandle::setTextureCoords((uint64_t *)v20 + 8, (uint64_t)&v23);
      v15 = (const void *)*((_QWORD *)a1 + 6);
      if (v15)
        PGTexture2D::setDataPtr((ProGL::Private::TextureImpl **)v20, v15, 0, 0, *((_DWORD *)a1 + 1), *((_DWORD *)a1 + 2), GLDataFormat, v11);
      v16 = v21;
      if (v21)
      {
        p_shared_owners = (unint64_t *)&v21->__shared_owners_;
        do
          v18 = __ldaxr(p_shared_owners);
        while (__stlxr(v18 - 1, p_shared_owners));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *, __n128))v16->__on_zero_shared)(v16, v14);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
    }
    PGSetCurrentContextSentry::~PGSetCurrentContextSentry((PGSetCurrentContextSentry *)v22);
  }
  else if (*(_DWORD *)a1 == 1)
  {
    v4 = operator new();
    PCBitmap::PCBitmap(v4, *((unsigned int *)a1 + 1), *((unsigned int *)a1 + 2), *((unsigned int *)a1 + 5), (const PCImageAttributes *)((char *)a1 + 24), 1);
    std::shared_ptr<PCBitmap>::shared_ptr[abi:ne180100]<PCBitmap,void>((uint64_t *)&v23, v4);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)a2, &v23);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
    if (*((_QWORD *)&v23 + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  return PCImage::setIsPremultiplied(*a2, *((_BYTE *)a1 + 40));
}

void sub_1B30252DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void PGCreatePooledImage(const PCImageAttributes *a1@<X0>, uint64_t *a2@<X8>)
{
  unsigned int v4;
  int v5;
  int v6;
  int GLInternalFormat;
  void (*v8)(_anonymous_namespace_ **);
  uint64_t v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(_anonymous_namespace_ **);
  std::__shared_weak_count *v22;
  _BYTE v23[20];
  int v24;

  if (*(_DWORD *)a1 == 1)
  {
    PGCreateImage(a1, a2);
  }
  else
  {
    v4 = *((_DWORD *)a1 + 8);
    v5 = *((_DWORD *)a1 + 1);
    v6 = *((_DWORD *)a1 + 2);
    GLInternalFormat = PCPixelFormat::getGLInternalFormat(*((_DWORD *)a1 + 5));
    ProGL::getCurrentContext(&v21);
    ProGL::TextureDescription::TextureDescription((ProGL::TextureDescription *)v23, v4, v5, v6, GLInternalFormat, (const ProGL::ContextHandle *)&v21);
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v21);
    ProGL::findTextureInPool((ProGL *)v23, &v21);
    v8 = ProGL::TextureHandle::operator void (ProGL::TextureHandle::*)(void)(&v21);
    if (v9)
      v10 = (v9 & 1 | (unint64_t)v8) == 0;
    else
      v10 = 1;
    v11 = !v10;
    if (v8 || v11)
    {
      v12 = 0;
      v13 = 0;
      v19 = 0;
      v20 = 0;
      if (v24 == 3553)
      {
        PGTextureHelper::new2DTexture((ProGL::Private::TextureImpl **)&v21, &v17);
        v13 = v17;
        v12 = v18;
        v19 = v17;
        v20 = v18;
      }
      if (operator!=((_QWORD *)a1 + 3))
        (*(void (**)(uint64_t, char *))(*(_QWORD *)v13 + 56))(v13, (char *)a1 + 24);
      PCImage::setIsPremultiplied(v13, *((_BYTE *)a1 + 40));
      *a2 = v13;
      a2[1] = v12;
    }
    else
    {
      PGCreateImage(a1, a2);
    }
    v14 = v22;
    if (v22)
    {
      p_shared_owners = (unint64_t *)&v22->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)v23);
  }
}

void sub_1B30254CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)va2);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::TextureSingleton::~TextureSingleton(_anonymous_namespace_::TextureSingleton *this)
{
  *(_QWORD *)this = &off_1E65EC060;
  PGLCleanup(this);
  PCSingleton::~PCSingleton(this);
}

{
  JUMPOUT(0x1B5E29170);
}

uint64_t *std::shared_ptr<PGTexture2D>::shared_ptr[abi:ne180100]<PGTexture2D,PGTextureHelper,void>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E65EC098;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2)
    v5 = (_QWORD *)(a2 + 8);
  else
    v5 = 0;
  std::shared_ptr<TXTextStyle>::__enable_weak_this[abi:ne180100]<OZStyle,TXTextStyle,void>((uint64_t)a1, v5, a2);
  return a1;
}

void sub_1B30255D8(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  __cxa_rethrow();
}

void sub_1B30255F8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<PGTexture2D *,PGTextureHelper,std::allocator<PGTexture2D>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<PGTexture2D *,PGTextureHelper,std::allocator<PGTexture2D>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

float64x2_t PGImaging::gaussianBlurRect(char a1, float64x2_t *a2, float64x2_t *a3, float64x2_t result)
{
  float64x2_t v4;
  int v5;

  v4 = a2[1];
  *a3 = *a2;
  a3[1] = v4;
  if ((a1 & 1) == 0)
  {
    v5 = vcvtpd_s64_f64(result.f64[0] + result.f64[0]);
    result = vsubq_f64(a3[1], (float64x2_t)vdupq_lane_s64(COERCE__INT64(-(double)v5 - (double)v5), 0));
    *a3 = vsubq_f64(*a3, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v5), 0));
    a3[1] = result;
  }
  return result;
}

float64x2_t PGImaging::outlineRect(float64x2_t *a1, float64x2_t *a2, double a3)
{
  uint64_t v3;
  float64x2_t result;
  float64x2_t v5;

  *(double *)&v3 = a3 + a3;
  result = vsubq_f64(*a1, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a3, 0));
  v5 = vaddq_f64((float64x2_t)vdupq_lane_s64(v3, 0), a1[1]);
  *a2 = result;
  a2[1] = v5;
  return result;
}

void PGProgram::PGProgram(PGProgram *this, int a2, const char *a3)
{
  *(_QWORD *)this = &off_1E65EC0F8;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_BYTE *)this + 16) = 1;
}

void PGProgram::~PGProgram(PGProgram *this)
{
  char *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  _BYTE v11[32];

  *(_QWORD *)this = &off_1E65EC0F8;
  v2 = (char *)this + 24;
  if (*((_QWORD *)this + 3))
  {
    v3 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
    v9 = *((_QWORD *)this + 3);
    v10 = v3;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }
    PGSetCurrentContextSentry::PGSetCurrentContextSentry(v11, &v9);
    v6 = v10;
    if (v10)
    {
      v7 = (unint64_t *)&v10->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    glDeleteProgram(*((_DWORD *)this + 3));
    PGSetCurrentContextSentry::~PGSetCurrentContextSentry((PGSetCurrentContextSentry *)v11);
  }
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)v2);
}

{
  PGProgram::~PGProgram(this);
  JUMPOUT(0x1B5E29170);
}

void PGProgram::enable(PGProgram *this)
{
  glUseProgram(*((_DWORD *)this + 3));
}

void PGProgram::disable(PGProgram *this)
{
  glUseProgram(0);
}

void PGProgram::setLocalParameter(PGProgram *this, float a2, float a3, float a4, float a5)
{
  glUseProgram(*((_DWORD *)this + 3));
}

uint64_t `anonymous namespace'::PGInfoImpl::instance(_anonymous_namespace_::PGInfoImpl *this)
{
  unint64_t v1;
  char v3;
  char **v4;
  char *v5;

  if (v1 != -1)
  {
    v5 = &v3;
    v4 = &v5;
  }
}

uint64_t PGInfo::getMaxTextureSize(PGInfo *this, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (int)this;
  v5 = 1;
  if (a2 != 16)
    v5 = 2;
  if (a2 == 8)
    v5 = 0;
  return *(_QWORD *)(*(_QWORD *)(v4 + 8) + 48 * v3 + 8 * v5 + 24);
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<`anonymous namespace'::PGInfoImpl::instance(void)::$_0 &&>>()
{
  int64x2_t **v0;
  int64x2_t **v1;
  ProGL::Private *v2;
  unint64_t v3;
  int64x2_t *v4;
  int64x2_t *v5;
  int64x2_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  int64x2_t v13;
  int64x2_t v14;

  v0 = (int64x2_t **)operator new();
  PCSingleton::PCSingleton((PCSingleton *)v0, 1000);
  *v0 = (int64x2_t *)&off_1E65EC158;
  v0[1] = 0;
  v1 = v0 + 1;
  v0[2] = 0;
  v0[3] = 0;
  PGLInit(v2);
  v4 = v0[2];
  v3 = (unint64_t)v0[3];
  if ((unint64_t)v4 >= v3)
  {
    v6 = *v1;
    v7 = 0xAAAAAAAAAAAAAAABLL * (v4 - *v1);
    v8 = v7 + 1;
    if (v7 + 1 > 0x555555555555555)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v3 - (_QWORD)v6) >> 4);
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x2AAAAAAAAAAAAAALL)
      v10 = 0x555555555555555;
    else
      v10 = v8;
    if (v10)
    {
      if (v10 > 0x555555555555555)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(48 * v10);
    }
    else
    {
      v11 = 0;
    }
    v12 = &v11[48 * v7];
    *(int64x2_t *)v12 = vdupq_n_s64(0x10000000uLL);
    v12[16] = 1;
    *(_OWORD *)(v12 + 24) = xmmword_1B3565F30;
    *((_QWORD *)v12 + 5) = 512;
    v5 = (int64x2_t *)(v12 + 48);
    if (v4 != v6)
    {
      do
      {
        v13 = v4[-3];
        v14 = v4[-1];
        *((int64x2_t *)v12 - 2) = v4[-2];
        *((int64x2_t *)v12 - 1) = v14;
        *((int64x2_t *)v12 - 3) = v13;
        v12 -= 48;
        v4 -= 3;
      }
      while (v4 != v6);
      v4 = v6;
    }
    v0[1] = (int64x2_t *)v12;
    v0[2] = v5;
    v0[3] = (int64x2_t *)&v11[48 * v10];
    if (v4)
      operator delete(v4);
  }
  else
  {
    *v4 = vdupq_n_s64(0x10000000uLL);
    v4[1].i8[0] = 1;
    *(int64x2_t *)((char *)&v4[1] + 8) = (int64x2_t)xmmword_1B3565F30;
    v4[2].i64[1] = 512;
    v5 = v4 + 3;
  }
  v0[2] = v5;
}

void sub_1B3025A40(_Unwind_Exception *a1)
{
  PCSingleton *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 2) = v4;
    operator delete(v4);
  }
  PCSingleton::~PCSingleton(v1);
  MEMORY[0x1B5E29170](v1, 0xA1C4030951706);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::PGInfoImpl::~PGInfoImpl(_anonymous_namespace_::PGInfoImpl *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E65EC158;
  PGLCleanup(this);
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  PCSingleton::~PCSingleton(this);
}

{
  JUMPOUT(0x1B5E29170);
}

uint64_t PGHelium::Instance(PGHelium *this)
{
  if (PGHelium::Instance(void)::once != -1)
    dispatch_once(&PGHelium::Instance(void)::once, &__block_literal_global_87);
  return PGHelium::_instance;
}

uint64_t ___ZN8PGHelium8InstanceEv_block_invoke()
{
  PGHelium *v0;

  v0 = (PGHelium *)operator new();
  PGHelium::PGHelium(v0);
  PGHelium::_instance = (uint64_t)v0;
  return HGLogger::setLevel((HGLogger *)"graph", (const char *)2);
}

void sub_1B3025B7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t PGHelium::purge(PGHelium *this)
{
  uint64_t result;

  if (PGHelium::_instance)
    return PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::clear(*(_QWORD *)(PGHelium::_instance + 8));
  return result;
}

void PGHelium::PGHelium(PGHelium *this)
{
  OZChannelBase *v2;
  const PCString *v3;
  __CFBundle *MainBundle;
  const __CFString *Identifier;

  PCSingleton::PCSingleton(this, 0);
  OZChannelBase::setRangeName(v2, v3);
  *(_QWORD *)this = &off_1E65EC1D0;
  PCCache<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::PCCache((uint64_t *)this + 1, -1);
  *((_BYTE *)this + 16) = 0;
  MainBundle = CFBundleGetMainBundle();
  Identifier = CFBundleGetIdentifier(MainBundle);
  if (Identifier)
    *((_BYTE *)this + 16) = CFStringCompare(Identifier, CFSTR("com.apple.motionapp"), 0) == kCFCompareEqualTo;
  PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::setMaxCost(*((_QWORD *)this + 1), 35000000);
}

void sub_1B3025C44(_Unwind_Exception *a1)
{
  PCSingleton *v1;
  uint64_t *v2;

  PCCache<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::~PCCache(v2);
  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

void PGHelium::~PGHelium(PGHelium *this)
{
  *(_QWORD *)this = &off_1E65EC1D0;
  PGHelium::_instance = 0;
  PCCache<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::~PCCache((uint64_t *)this + 1);
  PCSingleton::~PCSingleton(this);
}

{
  *(_QWORD *)this = &off_1E65EC1D0;
  PGHelium::_instance = 0;
  PCCache<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::~PCCache((uint64_t *)this + 1);
  PCSingleton::~PCSingleton(this);
  JUMPOUT(0x1B5E29170);
}

void PGHelium::acquireRenderer(_QWORD *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, _QWORD *a8@<X8>)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (*(_DWORD *)(*a1 + 8))
  {
    if (*(void (***)(HGGPUComputeDevice *__hidden))*a1 == off_1E6523A60)
    {
      v8 = a1[1];
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
    }
    PCPrint("File %s, line %d should not have been reached:\n\t", (uint64_t)a1, a2, a3, a4, a5, a6, a7, (char)"/Library/Caches/com.apple.xbs/Sources/MotioniOS/ProGraphics/PGHelium.cpp");
    pcAbortImpl();
  }
  *a8 = 0;
  a8[1] = 0;
}

void sub_1B3025DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PGHelium::convertPCMatrix44@<X0>(__int128 *a1@<X0>, HGTransform **a2@<X8>)
{
  HGTransform *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v4 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v4);
  v5 = a1[5];
  v19 = a1[4];
  v20 = v5;
  v6 = a1[7];
  v21 = a1[6];
  v22 = v6;
  v7 = a1[1];
  v14 = *a1;
  v15 = v7;
  v8 = a1[3];
  v16 = a1[2];
  v9 = *((_QWORD *)&v14 + 1);
  v10 = v15;
  v11 = *((_QWORD *)&v19 + 1);
  *((_QWORD *)&v14 + 1) = v16;
  *(_QWORD *)&v15 = v19;
  v12 = *((_QWORD *)&v20 + 1);
  *((_QWORD *)&v15 + 1) = v21;
  *(_QWORD *)&v16 = v9;
  *(_QWORD *)&v19 = v10;
  *((_QWORD *)&v19 + 1) = v8;
  v17 = v11;
  v18 = *((_QWORD *)&v21 + 1);
  *((_QWORD *)&v20 + 1) = v22;
  *(_QWORD *)&v21 = *((_QWORD *)&v10 + 1);
  *a2 = v4;
  *((_QWORD *)&v21 + 1) = *((_QWORD *)&v8 + 1);
  *(_QWORD *)&v22 = v12;
  return (*(uint64_t (**)(HGTransform *, __int128 *))(*(_QWORD *)v4 + 72))(v4, &v14);
}

void sub_1B3025E9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

double PGHelium::convertHGTransform@<D0>(PGHelium *this@<X0>, const HGTransform *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  double result;

  v4 = (*(uint64_t (**)(PGHelium *, const HGTransform *))(*(_QWORD *)this + 272))(this, a2);
  v5 = 0;
  *(_QWORD *)(a3 + 120) = 0x3FF0000000000000;
  *(_QWORD *)(a3 + 80) = 0x3FF0000000000000;
  *(_QWORD *)(a3 + 40) = 0x3FF0000000000000;
  *(_QWORD *)a3 = 0x3FF0000000000000;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  do
  {
    result = *(double *)(v4 + 8 * v5);
    *(double *)(a3 + 32 * (v5 & 3) + 8 * (v5 >> 2)) = result;
    ++v5;
  }
  while ((_DWORD)v5 != 16);
  return result;
}

uint64_t PGHelium::convertBitsPerChannel(PGHelium *this, int a2, int a3)
{
  return PGHelium::makeFormat(this, a2, a3, a2 > 8);
}

uint64_t PGHelium::makeFormat(PGHelium *this, int a2, int a3, int a4)
{
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;
  uint64_t result;
  PCException *exception;
  PCException *v11;
  PCException *v12;
  PCString v13;

  if (a2 < 16 && a4)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v13, "floating-point format must be at least 16 bits");
    PCException::PCException(exception, &v13);
    *(_QWORD *)exception = &unk_1E65EA798;
  }
  if (a2 > 16 && (a4 & 1) == 0)
  {
    v11 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v13, "integer format must be no more than 16 bits");
    PCException::PCException(v11, &v13);
    *(_QWORD *)v11 = &unk_1E65EA798;
  }
  switch((int)this)
  {
    case 1:
      if (a2 == 8)
        return 1;
      if (a2 == 32)
        return 7;
      if (a2 != 16)
        goto LABEL_39;
      v4 = a4 == 0;
      v5 = 3;
      v6 = 5;
      goto LABEL_28;
    case 2:
      if (a2 == 8)
        return 10;
      if (a2 == 32)
        return 13;
      if (a2 != 16)
        goto LABEL_39;
      v7 = a4 == 0;
      v8 = 11;
LABEL_22:
      if (v7)
        result = v8;
      else
        result = v8 + 1;
      break;
    case 3:
      if (a2 == 8)
        return 17;
      if (a2 == 32)
        return 21;
      if (a2 != 16)
        goto LABEL_39;
      v7 = a4 == 0;
      v8 = 19;
      goto LABEL_22;
    case 4:
      switch(a2)
      {
        case 32:
          return 28;
        case 16:
          v4 = a4 == 0;
          v5 = 25;
          v6 = 27;
          break;
        case 8:
          v4 = a3 == 0;
          v5 = 24;
          v6 = 22;
          break;
        default:
LABEL_39:
          v12 = (PCException *)__cxa_allocate_exception(0x40uLL);
          PCString::PCString(&v13, "format not supported");
          PCException::PCException(v12, &v13);
          *(_QWORD *)v12 = &unk_1E65EA798;
      }
LABEL_28:
      if (v4)
        result = v5;
      else
        result = v6;
      break;
    default:
      goto LABEL_39;
  }
  return result;
}

void sub_1B302618C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t PGHelium::makeFormat(int a1)
{
  if ((a1 - 1) > 0x10)
    return 0;
  else
    return dword_1B356603C[a1 - 1];
}

uint64_t PGHelium::createBitmapNode@<X0>(_QWORD *a1@<X0>, unsigned int *a2@<X1>, int a3@<W2>, unsigned int *a4@<X3>, HGBitmapLoader **a5@<X8>)
{
  int v10;
  int v11;
  PGHelium *v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  uint64_t Format;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  PCBitmap *v26;
  __int128 v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  __CFString *var0;
  uint64_t *p_info;
  unint64_t v33;
  const void *Representation;
  void *v35;
  uint64_t FactoryForSerialization;
  HGBitmap *v37;
  uint64_t v38;
  unsigned int BytesPerRow;
  HGObject *v40;
  HGObject *v41;
  std::__shared_weak_count *v42;
  PCBitmap *v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  HGTexture *v55;
  HGBitmapLoader *v56;
  PCException *exception;
  uint64_t v59;
  std::__shared_weak_count *v60;
  PCBitmap *v61[2];
  PCString v62[2];
  HGRect v63;

  if (!*a1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(v62, "null img");
    PCException::PCException(exception, v62);
    *(_QWORD *)exception = &unk_1E65EA798;
  }
  PCDynamicCast<PCBitmap,PCImage>((uint64_t)a1, v61);
  PCDynamicCast<PGTexture,PCImage>((uint64_t)a1, &v59);
  v10 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
  v11 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 24))(*a1);
  v13 = *(_DWORD *)(*a1 + 36);
  v12 = (PGHelium *)*(unsigned int *)(*a1 + 40);
  if (v61[0])
  {
    v14 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v61[0] + 8) + 48))(*((_QWORD *)v61[0] + 8));
    if (v14 >= 0x12)
      v15 = 0;
    else
      v15 = (0x20018u >> v14) & 1;
  }
  else
  {
    v15 = 0;
    if (v59)
      goto LABEL_10;
  }
  if (v61[0])
  {
    v16 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v61[0] + 8) + 48))(*((_QWORD *)v61[0] + 8));
    Format = PGHelium::makeFormat(v16);
    goto LABEL_11;
  }
LABEL_10:
  Format = PGHelium::makeFormat(v12, v13, v15, v13 > 8);
LABEL_11:
  v18 = Format;
  v19 = *a2;
  if (a3)
  {
    v20 = a2[1];
    if (!a4)
      goto LABEL_22;
LABEL_21:
    *a4 = v19;
    a4[1] = v20;
    a4[2] = v10;
    a4[3] = v11;
    goto LABEL_22;
  }
  if (v10 >= 0)
    v21 = v10;
  else
    v21 = v10 + 1;
  v19 -= v21 >> 1;
  if (v11 >= 0)
    v22 = v11;
  else
    v22 = v11 + 1;
  v20 = a2[1] - (v22 >> 1);
  if (a4)
    goto LABEL_21;
LABEL_22:
  v23 = HGRectMake4i(v19, v20, v19 + v10, v20 + v11);
  v25 = v24;
  v26 = v61[0];
  if (!v61[0])
  {
    (*(void (**)(PCString *__return_ptr))(*(_QWORD *)*a1 + 72))(v62);
    v27 = *(_OWORD *)&v62[0].var0;
    v62[0].var0 = 0;
    v62[1].var0 = 0;
    v28 = (std::__shared_weak_count *)v61[1];
    *(_OWORD *)v61 = v27;
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldaxr(p_shared_owners);
      while (__stlxr(v30 - 1, p_shared_owners));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    var0 = v62[1].var0;
    if (v62[1].var0)
    {
      p_info = &v62[1].var0->info;
      do
        v33 = __ldaxr((unint64_t *)p_info);
      while (__stlxr(v33 - 1, (unint64_t *)p_info));
      if (!v33)
      {
        (*((void (**)(__CFString *))var0->isa + 2))(var0);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)var0);
      }
    }
    v26 = v61[0];
  }
  Representation = (const void *)PCBitmap::getRepresentation(v26);
  if (Representation
  {
    FactoryForSerialization = OZFactoryBase::getFactoryForSerialization((uint64_t)v35);
    v37 = (HGBitmap *)FactoryForSerialization;
    if (FactoryForSerialization)
      (*(void (**)(uint64_t))(*(_QWORD *)FactoryForSerialization + 16))(FactoryForSerialization);
    *(_QWORD *)((char *)v37 + 20) = v23;
    *(_QWORD *)((char *)v37 + 28) = v25;
    *(_QWORD *)((char *)v37 + 36) = v23;
    *(_QWORD *)((char *)v37 + 44) = v25;
    (*(void (**)(HGBitmap *))(*(_QWORD *)v37 + 16))(v37);
    (*(void (**)(HGBitmap *))(*(_QWORD *)v37 + 24))(v37);
  }
  else
  {
    v38 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v61[0] + 8) + 16))(*((_QWORD *)v61[0] + 8));
    BytesPerRow = PCBitmap::getBytesPerRow(v61[0]);
    v40 = (HGObject *)HGObject::operator new(0x20uLL);
    v41 = v40;
    v43 = v61[0];
    v42 = (std::__shared_weak_count *)v61[1];
    v62[0] = (PCString)v61[0];
    v62[1] = (PCString)v61[1];
    if (v61[1])
    {
      v44 = (unint64_t *)((char *)v61[1] + 8);
      do
        v45 = __ldxr(v44);
      while (__stxr(v45 + 1, v44));
    }
    HGObject::HGObject(v40);
    *(_QWORD *)v41 = &unk_1E65A2598;
    *((_QWORD *)v41 + 2) = v43;
    *((_QWORD *)v41 + 3) = v42;
    if (v42)
    {
      v46 = (unint64_t *)&v42->__shared_owners_;
      do
        v47 = __ldxr(v46);
      while (__stxr(v47 + 1, v46));
      do
        v48 = __ldaxr(v46);
      while (__stlxr(v48 - 1, v46));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    v37 = (HGBitmap *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v37, v23, v25, v18, v38, BytesPerRow);
    HGBitmap::SetStorage(v37, v41);
    *((_QWORD *)v37 + 9) = PCBitmap::getAllocationSize(v61[0]);
    (*(void (**)(HGBitmap *))(*(_QWORD *)v37 + 16))(v37);
    (*(void (**)(HGBitmap *))(*(_QWORD *)v37 + 24))(v37);
    (*(void (**)(HGObject *))(*(_QWORD *)v41 + 24))(v41);
  }
  v49 = v60;
  if (v60)
  {
    v50 = (unint64_t *)&v60->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v52 = (std::__shared_weak_count *)v61[1];
  if (v61[1])
  {
    v53 = (unint64_t *)((char *)v61[1] + 8);
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  v55 = (HGTexture *)HGObject::operator new(0x80uLL);
  *(_QWORD *)&v63.var0 = v23;
  *(_QWORD *)&v63.var2 = v25;
  HGTexture::HGTexture(v55, v63, v37);
  v56 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v56, (HGBitmap *)v55);
  *a5 = v56;
  if (v55)
    (*(void (**)(HGTexture *))(*(_QWORD *)v55 + 24))(v55);
  return (*(uint64_t (**)(HGBitmap *))(*(_QWORD *)v37 + 24))(v37);
}

void sub_1B30266B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, PCString a13)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1B30267EC()
{
  uint64_t v0;

  if (v0)
    JUMPOUT(0x1B30267F4);
  JUMPOUT(0x1B3026804);
}

void PGHelium::createTextureNode(_QWORD *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, int a4@<W3>, unsigned int *a5@<X4>, HGBitmapLoader **a6@<X8>)
{
  unsigned int Name;
  int Format;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  HGBitmap *v21;
  HGObject *v22;
  HGObject *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  HGBitmapLoader *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unsigned int v38;
  unsigned int v39;
  PCException *exception;
  PCString v41;
  PCString v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;

  PCDynamicCast<PGTexture,PCImage>((uint64_t)a1, &v43);
  if (v43)
  {
    Name = ProGL::TextureHandle::getName((HGGLBlendingInfo **)(v43 + 64));
    Format = PGHelium::makeFormat((PGHelium *)*(unsigned int *)(v43 + 40), *(_DWORD *)(v43 + 36), 0, *(_DWORD *)(v43 + 36) > 8);
    v14 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
    v15 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 24))(*a1);
    v16 = *a3;
    if (a4)
    {
      v17 = a3[1];
      if (!a5)
      {
LABEL_5:
        v18 = HGRectMake4i(v16, v17, v16 + v14, v17 + v15);
        v20 = v19;
        v21 = (HGBitmap *)HGObject::operator new(0xC8uLL);
        HGGLTexture::HGGLTexture((uint64_t)v21, v18, v20, Format, a2, Name, 1);
        v22 = (HGObject *)HGObject::operator new(0x20uLL);
        v23 = v22;
        v25 = v43;
        v24 = v44;
        v45 = v43;
        v46 = v44;
        if (v44)
        {
          p_shared_owners = (unint64_t *)&v44->__shared_owners_;
          do
            v27 = __ldxr(p_shared_owners);
          while (__stxr(v27 + 1, p_shared_owners));
        }
        HGObject::HGObject(v22);
        *(_QWORD *)v23 = &unk_1E65A2598;
        *((_QWORD *)v23 + 2) = v25;
        *((_QWORD *)v23 + 3) = v24;
        if (v24)
        {
          v28 = (unint64_t *)&v24->__shared_owners_;
          do
            v29 = __ldxr(v28);
          while (__stxr(v29 + 1, v28));
          do
            v30 = __ldaxr(v28);
          while (__stlxr(v30 - 1, v28));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
        }
        HGBitmap::SetStorage(v21, v23);
        v31 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
        HGBitmapLoader::HGBitmapLoader(v31, v21);
        *a6 = v31;
        (*(void (**)(HGObject *))(*(_QWORD *)v23 + 24))(v23);
        if (v21)
          (*(void (**)(HGBitmap *))(*(_QWORD *)v21 + 24))(v21);
        goto LABEL_22;
      }
    }
    else
    {
      v38 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v43 + 16))(v43);
      v39 = a3[1];
      v16 -= v38 >> 1;
      v17 = v39 - ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v43 + 24))(v43) >> 1);
      if (!a5)
        goto LABEL_5;
    }
    *a5 = v16;
    a5[1] = v17;
    a5[2] = v14;
    a5[3] = v15;
    goto LABEL_5;
  }
  PCDynamicCast<PCBitmap,PCImage>((uint64_t)a1, &v45);
  if (v45)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v42, "not implemented yet");
    PCString::PCString(&v41, "/Library/Caches/com.apple.xbs/Sources/MotioniOS/ProGraphics/PGHelium.cpp");
    PCException::PCException(exception, &v42, &v41, 758);
    *(_QWORD *)exception = &unk_1E64FFFA0;
  }
  *a6 = 0;
  v32 = v46;
  if (v46)
  {
    v33 = (unint64_t *)&v46->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
LABEL_22:
  v35 = v44;
  if (v44)
  {
    v36 = (unint64_t *)&v44->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
}

void sub_1B3026B40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, char a11, uint64_t a12, char a13)
{
  void *v13;
  int v14;

  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v14)
    __cxa_free_exception(v13);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t PGHelium::renderNodeToBitmap@<X0>(HGRenderer *a1@<X0>, uint64_t *a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, HGGLBlendingInfo *a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t Format;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  int DstAlphaFactor;
  int BitsPerChannel;
  uint64_t v28;
  HGRenderer *v29;
  HGRenderer *v30;
  HGColorConform *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  HGColorConform *v35;
  PCMutex *v36[4];

  v14 = HGRectMake4i(*a3, a3[1], a3[2] + *a3, a3[3] + a3[1]);
  v16 = v15;
  Format = PGHelium::makeFormat(a4);
  if ((int)a3[2] < 1 || (int)a3[3] <= 0)
  {
    v19 = operator new();
    PCBitmap::PCBitmap(v19, 1, 1, a4, a5, 1);
    std::shared_ptr<PCBitmap>::shared_ptr[abi:ne180100]<PCBitmap,void>(a7, v19);
    return PCImage::setIsPremultiplied(*a7, 1);
  }
  else
  {
    v21 = Format;
    v22 = *a2;
    v34 = v22;
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 16))(v22);
    v33 = v22;
    v23 = operator new();
    PCBitmap::PCBitmap(v23, a3[2], a3[3], a4, a5, 1);
    std::shared_ptr<PCBitmap>::shared_ptr[abi:ne180100]<PCBitmap,void>(a7, v23);
    PCImage::setIsPremultiplied(*a7, 1);
    v24 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*a7 + 64) + 16))(*(_QWORD *)(*a7 + 64));
    v25 = HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap((uint64_t)v25, v14, v16, v21, v24);
    DstAlphaFactor = HGGLBlendingInfo::GetDstAlphaFactor(a6);
    BitsPerChannel = PCBitDepth::getBitsPerChannel(DstAlphaFactor);
    v28 = PGHelium::makeFormat((PGHelium *)4, BitsPerChannel, 0, BitsPerChannel > 8);
    if (a1
    {
      v30 = v29;
      v31 = (HGColorConform *)HGObject::operator new(0x320uLL);
      HGColorConform::HGColorConform(v31);
      HGColorConform::SetOutputPixelFormat((uint64_t)v31, v21, 0);
      (*(void (**)(HGColorConform *, _QWORD, uint64_t))(*(_QWORD *)v31 + 120))(v31, 0, v33);
      (*(void (**)(HGColorConform *))(*(_QWORD *)v31 + 16))(v31);
      RendererMutexLocker::RendererMutexLocker((RendererMutexLocker *)v36, v30);
      v35 = v31;
      (*(void (**)(HGColorConform *))(*(_QWORD *)v31 + 16))(v31);
      LiHelium::setUpGLRenderer(v30, v28);
      (*(void (**)(HGRenderer *, void *, HGColorConform *))(*(_QWORD *)v30 + 64))(v30, v25, v31);
      v32 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(_QWORD *)v30 + 128))(v30, 13);
      if (v31)
        (*(void (**)(HGColorConform *))(*(_QWORD *)v35 + 24))(v31);
      RendererMutexLocker::~RendererMutexLocker(v36);
      (*(void (**)(HGColorConform *))(*(_QWORD *)v31 + 24))(v31);
      if (v32)
        std::shared_ptr<OZFontFace>::reset[abi:ne180100](a7);
      (*(void (**)(HGColorConform *))(*(_QWORD *)v31 + 24))(v31);
    }
    else if (!LockAndRenderSoftware(a1, (uint64_t)v25, v28, &v34))
    {
      std::shared_ptr<OZFontFace>::reset[abi:ne180100](a7);
    }
    if (v25)
      (*(void (**)(void *))(*(_QWORD *)v25 + 24))(v25);
    result = v33;
    if (v33)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v33 + 24))(v33);
  }
  return result;
}

void sub_1B3026F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  va_list va;

  va_start(va, a5);
  RendererMutexLocker::~RendererMutexLocker((PCMutex **)va);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v5);
  if (a3)
    (*(void (**)(uint64_t))(*(_QWORD *)a3 + 24))(a3);
  _Unwind_Resume(a1);
}

void sub_1B3027098()
{
  JUMPOUT(0x1B3027078);
}

BOOL LockAndRenderSoftware(HGRenderer *lpsrc, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _BOOL8 v8;
  PCMutex *v10[4];

  RendererMutexLocker::RendererMutexLocker((RendererMutexLocker *)v10, lpsrc);
  (*(void (**)(HGRenderer *, uint64_t, uint64_t))(*(_QWORD *)lpsrc + 120))(lpsrc, 19, a3);
  (*(void (**)(HGRenderer *, uint64_t, _QWORD))(*(_QWORD *)lpsrc + 64))(lpsrc, a2, *a4);
  v8 = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)lpsrc + 128))(lpsrc, 13) == 0;
  RendererMutexLocker::~RendererMutexLocker(v10);
  return v8;
}

void sub_1B3027140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCMutex *a9)
{
  RendererMutexLocker::~RendererMutexLocker(&a9);
  _Unwind_Resume(a1);
}

void PGHelium::renderNodeToMetalTexture(const void *a1@<X0>, uint64_t *a2@<X1>, unsigned int *a3@<X2>, unsigned int a4@<W3>, HGGLBlendingInfo *a5@<X5>, _QWORD *a6@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int BitsPerChannel;
  int Format;
  int DstAlphaFactor;
  int v18;
  HGRenderer *v19;
  uint64_t v20;

  v11 = *a2;
  v20 = v11;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
  v12 = HGRectMake4i(*a3, a3[1], a3[2] + *a3, a3[3] + a3[1]);
  v14 = v13;
  BitsPerChannel = PCPixelFormat::getBitsPerChannel(a4);
  Format = PGHelium::makeFormat((PGHelium *)4, BitsPerChannel, a4 == 3, BitsPerChannel > 8);
  DstAlphaFactor = HGGLBlendingInfo::GetDstAlphaFactor(a5);
  v18 = PCBitDepth::getBitsPerChannel(DstAlphaFactor);
  PGHelium::makeFormat((PGHelium *)4, v18, 0, v18 > 8);
  if (a1)
  else
    v19 = 0;
  LockAndRenderMetal(v19, v12, v14, Format, &v20, a6);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
}

void sub_1B302727C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void LockAndRenderMetal(HGRenderer *lpsrc@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t *a5@<X4>, _QWORD *a6@<X8>)
{
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *lpsrca;
  _BYTE v17[40];
  PCMutex *v18[4];

  RendererMutexLocker::RendererMutexLocker((RendererMutexLocker *)v18, lpsrc);
  v12 = *a5;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
  HGRendererOutput::HGRendererOutput((uint64_t)v17, v12, a2, a3, a4, 5);
  HGRenderer::RenderNode(lpsrc, (const HGRendererOutput *)v17, (char *)1, &lpsrca);
  *a6 = 0;
  v13 = lpsrca;
  if (lpsrca)
  {
    if (!v14
      || (v15 = v14, (*(void (**)(void *))(*(_QWORD *)v14 + 16))(v14), *a6 = v15, (v13 = lpsrca) != 0))
    {
      (*(void (**)(void *))(*(_QWORD *)v13 + 24))(v13);
    }
  }
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  RendererMutexLocker::~RendererMutexLocker(v18);
}

void sub_1B30273C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  if (a2)
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  RendererMutexLocker::~RendererMutexLocker((PCMutex **)va);
  _Unwind_Resume(a1);
}

uint64_t PGHelium::renderNodeToTexture@<X0>(HGRenderer *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, CGColorSpace *a5@<X4>, HGGLBlendingInfo *a6@<X5>, int a7@<W6>, _QWORD *a8@<X8>)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int BitsPerChannel;
  int Format;
  int DstAlphaFactor;
  int v21;
  uint64_t v22;
  HGRenderer *v23;
  HGGPURenderer *v24;
  char *v25;
  HGBitmap *RawGLTexture;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  BOOL v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  PC_Sp_counted_base *var0;
  unint64_t *v40;
  unint64_t v41;
  ProGL *CGColorSpace;
  uint64_t OwningRenderQueue;
  __int128 v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  PC_Sp_counted_base *v48;
  unint64_t *v49;
  unint64_t v50;
  __int128 v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  PC_Sp_counted_base *v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  uint64_t result;
  __int128 v69;
  uint64_t v70[3];
  HGBitmap *v71;
  PCImage *v72[2];
  uint64_t v73;
  PCSharedCount v74[2];

  v14 = *a2;
  v73 = v14;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
  v15 = HGRectMake4i(*(_DWORD *)a3, *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8) + *(_DWORD *)a3, *(_DWORD *)(a3 + 12) + *(_DWORD *)(a3 + 4));
  v17 = v16;
  BitsPerChannel = PCPixelFormat::getBitsPerChannel(a4);
  Format = PGHelium::makeFormat((PGHelium *)4, BitsPerChannel, a4 == 3, BitsPerChannel > 8);
  DstAlphaFactor = HGGLBlendingInfo::GetDstAlphaFactor(a6);
  v21 = PCBitDepth::getBitsPerChannel(DstAlphaFactor);
  v22 = PGHelium::makeFormat((PGHelium *)4, v21, 0, v21 > 8);
  v72[0] = 0;
  v72[1] = 0;
  if (!a1
  {
    v27 = operator new();
    PCBitmap::PCBitmap(v27, *(unsigned int *)(a3 + 8), *(unsigned int *)(a3 + 12), a4, (uint64_t)a5, 1);
    std::shared_ptr<PCBitmap>::shared_ptr[abi:ne180100]<PCBitmap,void>((uint64_t *)v74, v27);
    PCImage::setIsPremultiplied((uint64_t)v74[0].var0, 1);
    v28 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v74[0].var0 + 8) + 16))(*((_QWORD *)v74[0].var0 + 8));
    v29 = HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap((uint64_t)v29, v15, v17, Format, v28);
    v30 = LockAndRenderSoftware(a1, (uint64_t)v29, v22, &v73);
    if (v30)
    {
      v69 = *(_OWORD *)&v74[0].var0;
      if (v74[1].var0)
      {
        v31 = (unint64_t *)((char *)v74[1].var0 + 8);
        do
          v32 = __ldxr(v31);
        while (__stxr(v32 + 1, v31));
      }
      PGTexture2D::toTexture((PCImage **)&v69, v70);
      v33 = (std::__shared_weak_count *)*((_QWORD *)&v69 + 1);
      if (*((_QWORD *)&v69 + 1))
      {
        v34 = (unint64_t *)(*((_QWORD *)&v69 + 1) + 8);
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
      std::shared_ptr<TXTextStyle>::operator=[abi:ne180100](v72, v70);
      v36 = (std::__shared_weak_count *)v70[1];
      if (v70[1])
      {
        v37 = (unint64_t *)(v70[1] + 8);
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
    }
    else
    {
      *a8 = 0;
      a8[1] = 0;
    }
    if (v29)
      (*(void (**)(void *))(*(_QWORD *)v29 + 24))(v29);
    var0 = v74[1].var0;
    if (!v74[1].var0)
      goto LABEL_33;
    v40 = (unint64_t *)((char *)v74[1].var0 + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      (*(void (**)(PC_Sp_counted_base *))(*(_QWORD *)var0 + 16))(var0);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)var0);
      if (!v30)
        goto LABEL_74;
    }
    else
    {
LABEL_33:
      if (!v30)
        goto LABEL_74;
    }
    goto LABEL_73;
  }
  v24 = v23;
  LockAndRenderHardware(v23, v15, v17, Format, &v73, v22, (uint64_t *)&v71);
  if (v71)
  {
    if (a7 && (*((_BYTE *)v71 + 12) & 1) != 0)
    {
      RawGLTexture = (HGBitmap *)HGGPURenderer::GetRawGLTexture(v24, v71, v25);
      if (v71 == RawGLTexture)
      {
        if (RawGLTexture)
          (*(void (**)(HGBitmap *))(*(_QWORD *)RawGLTexture + 24))(RawGLTexture);
      }
      else
      {
        if (v71)
          (*(void (**)(void))(*(_QWORD *)v71 + 24))();
        v71 = RawGLTexture;
      }
    }
    HGGPURenderer::GetCurrentContext(v24, (uint64_t *)v74);
    CGColorSpace = (ProGL *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)v74);
    PCSharedCount::PCSharedCount(v74);
    OwningRenderQueue = HGRenderer::GetOwningRenderQueue(v24);
    *(_OWORD *)v70 = 0uLL;
    if (OwningRenderQueue)
    {
      LiRenderQueueTextureOwner::create((uint64_t *)&v71, OwningRenderQueue, (uint64_t)v74);
      v44 = *(_OWORD *)&v74[0].var0;
      v74[0].var0 = 0;
      v74[1].var0 = 0;
      v45 = (std::__shared_weak_count *)v70[1];
      *(_OWORD *)v70 = v44;
      if (v45)
      {
        p_shared_owners = (unint64_t *)&v45->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
      v48 = v74[1].var0;
      if (v74[1].var0)
      {
        v49 = (unint64_t *)((char *)v74[1].var0 + 8);
        do
          v50 = __ldaxr(v49);
        while (__stlxr(v50 - 1, v49));
        if (!v50)
        {
          (*(void (**)(PC_Sp_counted_base *))(*(_QWORD *)v48 + 16))(v48);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v48);
        }
      }
    }
    LiHelium::createExternallyOwnedTexture(CGColorSpace, (uint64_t)&v71, *(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 12), v70, v74);
    PGCreateTextureFromPGLTexture((void (**)(_anonymous_namespace_ **))v74, &v69);
    v51 = v69;
    v69 = 0uLL;
    v52 = (std::__shared_weak_count *)v72[1];
    *(_OWORD *)v72 = v51;
    if (v52)
    {
      v53 = (unint64_t *)&v52->__shared_owners_;
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }
    v55 = (std::__shared_weak_count *)*((_QWORD *)&v69 + 1);
    if (*((_QWORD *)&v69 + 1))
    {
      v56 = (unint64_t *)(*((_QWORD *)&v69 + 1) + 8);
      do
        v57 = __ldaxr(v56);
      while (__stlxr(v57 - 1, v56));
      if (!v57)
      {
        ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
        std::__shared_weak_count::__release_weak(v55);
      }
    }
    v58 = v74[1].var0;
    if (v74[1].var0)
    {
      v59 = (unint64_t *)((char *)v74[1].var0 + 8);
      do
        v60 = __ldaxr(v59);
      while (__stlxr(v60 - 1, v59));
      if (!v60)
      {
        (*(void (**)(PC_Sp_counted_base *))(*(_QWORD *)v58 + 16))(v58);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v58);
      }
    }
    v61 = (std::__shared_weak_count *)v70[1];
    if (v70[1])
    {
      v62 = (unint64_t *)(v70[1] + 8);
      do
        v63 = __ldaxr(v62);
      while (__stlxr(v63 - 1, v62));
      if (!v63)
      {
        ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
        std::__shared_weak_count::__release_weak(v61);
      }
    }
    if (v71)
      (*(void (**)(HGBitmap *))(*(_QWORD *)v71 + 24))(v71);
LABEL_73:
    PCImage::setColorSpace(v72[0], a5);
    PCImage::setIsPremultiplied((uint64_t)v72[0], 1);
    *(_OWORD *)a8 = *(_OWORD *)v72;
    v72[0] = 0;
    v72[1] = 0;
    goto LABEL_74;
  }
  *a8 = 0;
  a8[1] = 0;
LABEL_74:
  v64 = (std::__shared_weak_count *)v72[1];
  if (v72[1])
  {
    v65 = (unint64_t *)((char *)v72[1] + 8);
    do
      v66 = __ldaxr(v65);
    while (__stlxr(v66 - 1, v65));
    if (!v66)
    {
      ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
      std::__shared_weak_count::__release_weak(v64);
    }
  }
  result = v73;
  if (v73)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v73 + 24))(v73);
  return result;
}

void sub_1B30279AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,PCSharedCount a21)
{
  uint64_t v21;

  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
  if (a16)
    (*(void (**)(uint64_t))(*(_QWORD *)a16 + 24))(a16);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  if (a20)
    (*(void (**)(uint64_t))(*(_QWORD *)a20 + 24))(a20);
  _Unwind_Resume(a1);
}

void LockAndRenderHardware(HGRenderer *lpsrc@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[40];
  uint64_t v17;
  PCMutex *v18[4];

  RendererMutexLocker::RendererMutexLocker((RendererMutexLocker *)v18, lpsrc);
  v14 = *a5;
  v17 = v14;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
  LiHelium::setUpGLRenderer(lpsrc, a6);
  HGRendererOutput::HGRendererOutput((uint64_t)v16, v17, a2, a3, a4, 4);
  HGRenderer::RenderNode(lpsrc, (const HGRendererOutput *)v16, (char *)1, &v15);
  LiHelium::bitmapToTexture(&v15, (uint64_t)lpsrc, a7);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  RendererMutexLocker::~RendererMutexLocker(v18);
}

void sub_1B3027BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RendererMutexLocker::~RendererMutexLocker((PCMutex **)va);
  _Unwind_Resume(a1);
}

void RendererMutexLocker::RendererMutexLocker(RendererMutexLocker *this, HGRenderer *lpsrc)
{
  unsigned __int8 v4;
  unsigned __int8 v5;
  PCMutex *v6;

  if ((v4 & 1) == 0
  {
  }
  if ((v5 & 1) == 0
  {
  }
  if (lpsrc
  {
  }
  else
  {
  }
  *(_QWORD *)this = v6;
  *((_BYTE *)this + 8) = 0;
  PCMutex::lock(v6);
  *((_BYTE *)this + 8) = 1;
}

void sub_1B3027D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RendererMutexLocker::~RendererMutexLocker(PCMutex **this)
{
  PCMutex *v2;

  v2 = *this;
  if (v2)
  {
    if (*((_BYTE *)this + 8))
    {
      PCMutex::unlock(v2);
      *((_BYTE *)this + 8) = 0;
    }
  }
}

uint64_t PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::clear(uint64_t a1)
{
  _QWORD *v1;
  PCMutex *v2;
  _QWORD *v3;

  v1 = (_QWORD *)a1;
  v2 = (PCMutex *)(a1 + 16);
  PCMutex::lock((PCMutex *)(a1 + 16));
  v3 = (_QWORD *)v1[12];
  v1 += 12;
  std::__tree<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::__map_value_compare<std::pair<HGMTLDeviceType,PCHash128>,std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::less<std::pair<HGMTLDeviceType,PCHash128>>,true>,std::allocator<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>>>::destroy((uint64_t)(v1 - 1), v3);
  *(v1 - 1) = v1;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = v1[2];
  v1[6] = 0;
  return PCMutex::unlock(v2);
}

void std::__tree<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::__map_value_compare<std::pair<HGMTLDeviceType,PCHash128>,std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::less<std::pair<HGMTLDeviceType,PCHash128>>,true>,std::allocator<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>>>::destroy(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;

  if (a2)
  {
    std::__tree<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::__map_value_compare<std::pair<HGMTLDeviceType,PCHash128>,std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::less<std::pair<HGMTLDeviceType,PCHash128>>,true>,std::allocator<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::__map_value_compare<std::pair<HGMTLDeviceType,PCHash128>,std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::less<std::pair<HGMTLDeviceType,PCHash128>>,true>,std::allocator<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>>>::destroy(a1, a2[1]);
    v4 = a2[7];
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    operator delete(a2);
  }
}

uint64_t *PCCache<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::PCCache(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = operator new();
  PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::PCCacheImpl(v4, a2);
  *a1 = v4;
  return a1;
}

void sub_1B3027EF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A0C407F3B7D27);
  _Unwind_Resume(a1);
}

uint64_t PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::PCCacheImpl(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  PCMutex::PCMutex((PCMutex *)(a1 + 16));
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 88) = a1 + 96;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = -1;
  *(_QWORD *)(a1 + 160) = a2;
  *(_QWORD *)(a1 + 168) = 0;
  return a1;
}

void sub_1B3027F64(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

uint64_t *PCCache<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::~PCCache(uint64_t *a1)
{
  PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::clear(*a1);
  std::unique_ptr<PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>>::reset[abi:ne180100](a1, 0);
  return a1;
}

uint64_t std::unique_ptr<PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::~PCCacheImpl(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::~PCCacheImpl(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;

  v2 = *(void **)(a1 + 112);
  if (v2)
  {
    *(_QWORD *)(a1 + 120) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::__map_value_compare<std::pair<HGMTLDeviceType,PCHash128>,std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::less<std::pair<HGMTLDeviceType,PCHash128>>,true>,std::allocator<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>>>::destroy(a1 + 88, *(_QWORD **)(a1 + 96));
  PCMutex::~PCMutex((PCMutex *)(a1 + 16));
  v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::setMaxCost(uint64_t a1, uint64_t a2)
{
  PCMutex *v4;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t *v8;

  v4 = (PCMutex *)(a1 + 16);
  PCMutex::lock((PCMutex *)(a1 + 16));
  *(_QWORD *)(a1 + 152) = a2;
  if (!*(_QWORD *)(a1 + 168))
  {
    while (*(_QWORD *)(a1 + 144) > *(_QWORD *)(a1 + 152) || *(_QWORD *)(a1 + 104) > *(_QWORD *)(a1 + 160))
    {
      v6 = *(uint64_t ***)(a1 + 112);
      if (v6 == *(uint64_t ***)(a1 + 120))
        break;
      v8 = *v6;
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::__tree_node<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 112), (uint64_t)&v8);
      v7 = v8;
      *(_QWORD *)(a1 + 144) -= v8[28];
      std::__tree<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::__map_value_compare<std::pair<HGMTLDeviceType,PCHash128>,std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>,std::less<std::pair<HGMTLDeviceType,PCHash128>>,true>,std::allocator<std::__value_type<std::pair<HGMTLDeviceType,PCHash128>,PCCacheImpl<std::pair<HGMTLDeviceType,PCHash128>,PGHelium::MetalTextureCacheEntry,PCMutex,std::less<std::pair<HGMTLDeviceType,PCHash128>>>::Data>>>::erase((uint64_t **)(a1 + 88), v7);
    }
  }
  return PCMutex::unlock(v4);
}

void sub_1B3028104(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PGTextureCache::instance(PGTextureCache *this)
{
  if (PGTextureCache::instance(void)::once != -1)
    dispatch_once(&PGTextureCache::instance(void)::once, &__block_literal_global_88);
  return _instance;
}

void ___ZN14PGTextureCache8instanceEv_block_invoke()
{
  PGTextureCache *v0;

  v0 = (PGTextureCache *)operator new();
  PGTextureCache::PGTextureCache(v0);
  _instance = (uint64_t)v0;
}

void sub_1B3028198(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C4093209011);
  _Unwind_Resume(a1);
}

void PGTextureCache::PGTextureCache(PGTextureCache *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t *v7;
  ProGL *v8;
  unsigned int MaxNumberOfTexturesPerShareGroup;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  __int128 v13;
  size_t v14;
  unint64_t v15;
  int v16[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  PCSingleton::PCSingleton(this, 100);
  *v2 = &unk_1E65EC278;
  ProGL::Init::Init((ProGL::Init *)(v2 + 1));
  *((_QWORD *)this + 2) = 0;
  *((_BYTE *)this + 40) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  v3 = (_QWORD *)operator new();
  v4 = operator new();
  *(_QWORD *)(v4 + 40) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)v4 = 0;
  *(_QWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = v4 + 32;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_QWORD *)(v4 + 80) = 0;
  *(_QWORD *)(v4 + 88) = -1;
  *(_QWORD *)(v4 + 96) = -1;
  *(_QWORD *)(v4 + 104) = 0;
  *v3 = v4;
  std::shared_ptr<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::shared_ptr[abi:ne180100]<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>,void>(&v13, (uint64_t)v3);
  std::vector<std::shared_ptr<std::vector<unsigned char>>>::push_back[abi:ne180100]((char **)this + 2, &v13);
  v5 = (uint64_t *)v13;
  v14 = 8;
  v15 = 0;
  *(_QWORD *)v16 = 0x1800000006;
  sysctl(v16, 2u, &v15, &v14, 0, 0);
  if (v15 >= 0x20000001)
  {
    if (v15 >= 0x40000001)
      v6 = (unint64_t)((double)v15 * 0.2);
    else
      v6 = 0x2000000;
  }
  else
  {
    v6 = 12582912;
  }
  PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::setMaxCost(*v5, v6);
  v7 = (uint64_t *)v13;
  MaxNumberOfTexturesPerShareGroup = ProGL::getMaxNumberOfTexturesPerShareGroup(v8);
  PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::setMaxSize(*v7, MaxNumberOfTexturesPerShareGroup / 0xAuLL);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_1B30283AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  PCSingleton *v9;
  ProGL::Init *v10;
  uint64_t v11;

  MEMORY[0x1B5E29170](v11, 0x20C4093837F09);
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&a9);
  ProGL::Init::~Init(v10);
  PCSingleton::~PCSingleton(v9);
  _Unwind_Resume(a1);
}

void PGTextureCache::disableLimits(PGTextureCache *this)
{
  uint64_t **v1;
  uint64_t **v2;
  uint64_t *v3;

  v1 = (uint64_t **)*((_QWORD *)this + 2);
  v2 = (uint64_t **)*((_QWORD *)this + 3);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 2;
    PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::disableLimits(*v3);
  }
}

void PGTextureCache::enableLimits(PGTextureCache *this)
{
  uint64_t **v1;
  uint64_t **v2;
  uint64_t *v3;

  v1 = (uint64_t **)*((_QWORD *)this + 2);
  v2 = (uint64_t **)*((_QWORD *)this + 3);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 2;
    PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::enableLimits(*v3);
  }
}

BOOL PGTextureCache::add(PGTextureCache *this, uint64_t *a2, __int128 *a3, int a4, PCHash128 *a5)
{
  int v5;
  void (*v11)(_anonymous_namespace_ **);
  uint64_t v12;
  BOOL v13;
  int v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  void (*v33)(_anonymous_namespace_ **);
  std::__shared_weak_count *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;

  v5 = *((unsigned __int8 *)this + 40);
  if (!*((_BYTE *)this + 40))
  {
    if (!*a2)
    {
LABEL_17:
      PGTextureCache::remove(this, a5);
      return v5 == 0;
    }
    PGTexture::getPGLTexture(*a2, &v33);
    v11 = ProGL::TextureHandle::operator void (ProGL::TextureHandle::*)(void)(&v33);
    if (v12)
      v13 = (v12 & 1 | (unint64_t)v11) == 0;
    else
      v13 = 1;
    v15 = v13 && v11 == 0;
    v16 = v34;
    if (!v34)
      goto LABEL_16;
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
      if (v15)
        goto LABEL_17;
    }
    else
    {
LABEL_16:
      if (v15)
        goto LABEL_17;
    }
    v20 = *a2;
    v21 = a2[1];
    v33 = (void (*)(_anonymous_namespace_ **))*a2;
    v34 = (std::__shared_weak_count *)v21;
    if (v21)
    {
      v22 = (unint64_t *)(v21 + 8);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
      v20 = *a2;
    }
    v24 = a3[3];
    v37 = a3[2];
    v38 = v24;
    v25 = a3[1];
    v35 = *a3;
    v36 = v25;
    v26 = a3[7];
    v41 = a3[6];
    v42 = v26;
    v27 = a3[5];
    v39 = a3[4];
    v40 = v27;
    v28 = *(uint64_t **)(*((_QWORD *)this + 2) + 16 * a4);
    v29 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
    PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::addValue(*v28, a5, (uint64_t)&v33, v29);
    v30 = v34;
    if (v34)
    {
      v31 = (unint64_t *)&v34->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
  }
  return v5 == 0;
}

void sub_1B30285F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void PGTextureCache::remove(PGTextureCache *this, const PCHash128 *a2)
{
  uint64_t ***v2;
  uint64_t ***v3;
  uint64_t **v5;

  if (!*((_BYTE *)this + 40))
  {
    v2 = (uint64_t ***)*((_QWORD *)this + 2);
    v3 = (uint64_t ***)*((_QWORD *)this + 3);
    while (v2 != v3)
    {
      v5 = *v2;
      v2 += 2;
      PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::removeKey(*v5, a2);
    }
  }
}

void PGTextureCache::find(uint64_t a1@<X0>, int a2@<W1>, const PCHash128 *a3@<X2>, _BYTE *a4@<X3>, _QWORD *a5@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  _OWORD *v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  _BYTE v20[135];
  char v21;

  v7 = **(_QWORD **)(*(_QWORD *)(a1 + 16) + 16 * a2);
  v21 = 0;
  PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::findValue(v7, a3, &v21, (uint64_t)&v18);
  v8 = v18;
  if (v18)
  {
    if (a4 && v20 != a4)
    {
      for (i = 0; i != 128; i += 32)
      {
        v10 = &a4[i];
        v11 = *(_OWORD *)&v20[i + 16];
        *v10 = *(_OWORD *)&v20[i];
        v10[1] = v11;
      }
    }
    v12 = v19;
    *a5 = v8;
    a5[1] = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
  }
  v15 = v19;
  if (v19)
  {
    v16 = (unint64_t *)&v19->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

BOOL PGTextureCache::add(PGTextureCache *a1, uint64_t *a2, HGGPUComputeDevice **a3, PCHash128 *a4)
{
  int GLVirtualScreen;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(*a3);
  v18 = 0x3FF0000000000000;
  v15 = 0x3FF0000000000000;
  v12 = 0x3FF0000000000000;
  v9 = 0x3FF0000000000000;
  v10 = 0u;
  v11 = 0u;
  v13 = 0u;
  v14 = 0u;
  v16 = 0u;
  v17 = 0u;
  return PGTextureCache::add(a1, a2, (__int128 *)&v9, GLVirtualScreen, a4);
}

void PGTextureCache::find(uint64_t a1@<X0>, HGGPUComputeDevice **a2@<X1>, const PCHash128 *a3@<X2>, _BYTE *a4@<X3>, _QWORD *a5@<X8>)
{
  int GLVirtualScreen;

  GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(*a2);
  PGTextureCache::find(a1, GLVirtualScreen, a3, a4, a5);
}

void PGTextureCache::clear(PGTextureCache *this)
{
  os_unfair_lock_s ***v1;
  os_unfair_lock_s ***v2;
  os_unfair_lock_s **v3;

  v1 = (os_unfair_lock_s ***)*((_QWORD *)this + 2);
  v2 = (os_unfair_lock_s ***)*((_QWORD *)this + 3);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 2;
    PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::clear(*v3);
  }
}

void PGTextureCache::~PGTextureCache(PGTextureCache *this)
{
  PGTextureCache::~PGTextureCache(this);
  JUMPOUT(0x1B5E29170);
}

{
  ProGL::Init *v2;
  void **v3;

  *(_QWORD *)this = &unk_1E65EC278;
  v2 = (PGTextureCache *)((char *)this + 8);
  v3 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&v3);
  ProGL::Init::~Init(v2);
  PCSingleton::~PCSingleton(this);
}

_QWORD *std::shared_ptr<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::shared_ptr[abi:ne180100]<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E65EC2B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B30288F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::reset[abi:ne180100]((os_unfair_lock_s ***)va, 0);
  _Unwind_Resume(a1);
}

os_unfair_lock_s **std::__shared_ptr_pointer<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>> *,std::shared_ptr<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::__shared_ptr_default_delete<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>,PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>,std::allocator<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>>::__on_zero_shared(uint64_t a1)
{
  os_unfair_lock_s **result;

  result = *(os_unfair_lock_s ***)(a1 + 24);
  if (result)
  {
    PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::~PCCache(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>> *,std::shared_ptr<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::__shared_ptr_default_delete<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>,PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>,std::allocator<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

os_unfair_lock_s **PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::~PCCache(os_unfair_lock_s **a1)
{
  PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::clear(*a1);
  std::unique_ptr<PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::reset[abi:ne180100]((uint64_t *)a1, 0);
  return a1;
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::clear(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _QWORD *v3;

  v1 = a1;
  v2 = a1 + 4;
  PCSpinLock::lock(a1 + 4);
  v3 = *(_QWORD **)&v1[8]._os_unfair_lock_opaque;
  v1 += 8;
  std::__tree<std::__value_type<PCHash128,LiTextureStoreToken>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,LiTextureStoreToken>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,LiTextureStoreToken>>>::destroy((uint64_t)&v1[-2], v3);
  *(_QWORD *)&v1[-2]._os_unfair_lock_opaque = v1;
  *(_QWORD *)&v1->_os_unfair_lock_opaque = 0;
  *(_QWORD *)&v1[2]._os_unfair_lock_opaque = 0;
  *(_QWORD *)&v1[6]._os_unfair_lock_opaque = *(_QWORD *)&v1[4]._os_unfair_lock_opaque;
  *(_QWORD *)&v1[12]._os_unfair_lock_opaque = 0;
  PCSpinLock::unlock(v2);
}

uint64_t std::unique_ptr<PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::~PCCacheImpl(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::~PCCacheImpl(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<PCHash128,LiTextureStoreToken>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,LiTextureStoreToken>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,LiTextureStoreToken>>>::destroy(a1 + 24, *(_QWORD **)(a1 + 32));
  PCSpinLock::~PCSpinLock((PCSpinLock *)(a1 + 16));
  v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  return a1;
}

os_unfair_lock_s **std::unique_ptr<PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>>::reset[abi:ne180100](os_unfair_lock_s ***a1, os_unfair_lock_s **a2)
{
  os_unfair_lock_s **result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCache<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::~PCCache(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::setMaxCost(uint64_t a1, unint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t **v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;

  v4 = (os_unfair_lock_s *)(a1 + 16);
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 16));
  *(_QWORD *)(a1 + 88) = a2;
  if (!*(_QWORD *)(a1 + 104))
  {
    while (*(_QWORD *)(a1 + 80) > a2 || *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 96))
    {
      v5 = *(uint64_t ***)(a1 + 48);
      if (v5 == *(uint64_t ***)(a1 + 56))
        break;
      v8 = *v5;
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v8);
      v6 = v8;
      v7 = (uint64_t)(v8 + 6);
      *(_QWORD *)(a1 + 80) -= v8[24];
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v6);
      std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v7);
      operator delete(v6);
      a2 = *(_QWORD *)(a1 + 88);
    }
  }
  PCSpinLock::unlock(v4);
}

void sub_1B3028BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_unfair_lock_s *a9)
{
  PCLockSentry<PCSpinLock>::~PCLockSentry(&a9);
  _Unwind_Resume(a1);
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::remove(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;

  v3 = *(_QWORD *)(*(_QWORD *)a2 + 208);
  v4 = ((a1[1] - *a1) >> 3) - 1;
  if (v3 == v4)
  {
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v3);
  }
  else
  {
    *(_QWORD *)(*a1 + 8 * v3) = *(_QWORD *)(*a1 + 8 * v4);
    *(_QWORD *)(*(_QWORD *)(*a1 + 8 * v3) + 208) = v3;
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v4);
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::bubble(a1, *a1 + 8 * v3);
  }
}

uint64_t *PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::bubble(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  char v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _BOOL4 v12;
  unint64_t v13;
  _BOOL4 v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;

  v2 = *result;
  v3 = result[1] - *result;
  v4 = *(_QWORD *)(*(_QWORD *)a2 + 208);
  v5 = (2 * v4) | 1;
  if (v5 >= v3 >> 3)
  {
LABEL_24:
    if (v4)
    {
      v17 = *(_QWORD *)(v2 + 8 * v4);
      do
      {
        v18 = v4 - 1;
        v19 = (v4 - 1) >> 1;
        v20 = *(_QWORD *)(v2 + 8 * v19);
        if (*(_QWORD *)(v20 + 200) <= *(_QWORD *)(v17 + 200))
          break;
        *(_QWORD *)(v2 + 8 * v4) = v20;
        *(_QWORD *)(v2 + 8 * v19) = v17;
        v2 = *result;
        *(_QWORD *)(*(_QWORD *)(*result + 8 * v4) + 208) = v4;
        v17 = *(_QWORD *)(v2 + 8 * v19);
        *(_QWORD *)(v17 + 208) = v19;
        v4 = (v4 - 1) >> 1;
      }
      while (v18 > 1);
    }
    return result;
  }
  v6 = 0;
  v7 = v3 >> 3;
  v8 = 2 * v4;
  v9 = *(_QWORD *)(v2 + 8 * v4);
  while (1)
  {
    v10 = v8 + 2;
    v11 = *(_QWORD *)(v9 + 200);
    v12 = v10 < v7 && v11 > *(_QWORD *)(*(_QWORD *)(v2 + 8 * v10) + 200);
    v13 = *(_QWORD *)(*(_QWORD *)(v2 + 8 * v5) + 200);
    if (v11 <= v13 && !v12)
      break;
    v15 = v11 > v13 && v12;
    if (v12)
      v16 = v10;
    else
      v16 = v5;
    if (v15)
    {
      if (v13 <= *(_QWORD *)(*(_QWORD *)(v2 + 8 * v10) + 200))
        v16 = v5;
      else
        v16 = v10;
    }
    *(_QWORD *)(v2 + 8 * v4) = *(_QWORD *)(v2 + 8 * v16);
    *(_QWORD *)(v2 + 8 * v16) = v9;
    v2 = *result;
    *(_QWORD *)(*(_QWORD *)(*result + 8 * v4) + 208) = v4;
    v9 = *(_QWORD *)(v2 + 8 * v16);
    *(_QWORD *)(v9 + 208) = v16;
    v8 = 2 * v16;
    v6 = 1;
    v5 = (2 * v16) | 1;
    v4 = v16;
    if (v5 >= v7)
      return result;
  }
  if ((v6 & 1) == 0)
  {
    v4 = *(_QWORD *)(*(_QWORD *)a2 + 208);
    goto LABEL_24;
  }
  return result;
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::setMaxSize(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t **v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;

  v4 = (os_unfair_lock_s *)(a1 + 16);
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 16));
  *(_QWORD *)(a1 + 96) = a2;
  if (!*(_QWORD *)(a1 + 104))
  {
    while (*(_QWORD *)(a1 + 80) > *(_QWORD *)(a1 + 88) || *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 96))
    {
      v5 = *(uint64_t ***)(a1 + 48);
      if (v5 == *(uint64_t ***)(a1 + 56))
        break;
      v8 = *v5;
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v8);
      v6 = v8;
      v7 = (uint64_t)(v8 + 6);
      *(_QWORD *)(a1 + 80) -= v8[24];
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v6);
      std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v7);
      operator delete(v6);
    }
  }
  PCSpinLock::unlock(v4);
}

void sub_1B3028E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_unfair_lock_s *a9)
{
  PCLockSentry<PCSpinLock>::~PCLockSentry(&a9);
  _Unwind_Resume(a1);
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::disableLimits(uint64_t a1)
{
  os_unfair_lock_s *v2;

  v2 = (os_unfair_lock_s *)(a1 + 16);
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 16));
  ++*(_QWORD *)(a1 + 104);
  PCSpinLock::unlock(v2);
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::enableLimits(uint64_t a1)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  uint64_t **v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;

  v2 = (os_unfair_lock_s *)(a1 + 16);
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 16));
  v3 = *(_QWORD *)(a1 + 104) - 1;
  *(_QWORD *)(a1 + 104) = v3;
  if (!v3)
  {
    while (*(_QWORD *)(a1 + 80) > *(_QWORD *)(a1 + 88) || *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 96))
    {
      v4 = *(uint64_t ***)(a1 + 48);
      if (v4 == *(uint64_t ***)(a1 + 56))
        break;
      v7 = *v4;
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v7);
      v5 = v7;
      v6 = (uint64_t)(v7 + 6);
      *(_QWORD *)(a1 + 80) -= v7[24];
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v5);
      std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v6);
      operator delete(v5);
    }
  }
  PCSpinLock::unlock(v2);
}

void sub_1B3028F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_unfair_lock_s *a9)
{
  PCLockSentry<PCSpinLock>::~PCLockSentry(&a9);
  _Unwind_Resume(a1);
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::addValue(uint64_t a1, const PCHash128 *a2, uint64_t a3, unint64_t a4)
{
  os_unfair_lock_s *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t i;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  unint64_t *v25;
  unint64_t v26;
  unsigned __int8 v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  _QWORD *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51[3];
  std::__shared_weak_count *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  _QWORD *v63;
  os_unfair_lock_s *v64;

  v8 = (os_unfair_lock_s *)(a1 + 16);
  v64 = (os_unfair_lock_s *)(a1 + 16);
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 16));
  if (*(_QWORD *)(a1 + 88) < a4 && !*(_QWORD *)(a1 + 104))
  {
LABEL_33:
    PCSpinLock::unlock(v8);
    return;
  }
  v9 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>(a1 + 24, a2);
  v10 = v9;
  v63 = v9;
  if ((_QWORD *)(a1 + 32) != v9)
  {
    v11 = v9 + 6;
    std::shared_ptr<TXTextStyle>::operator=[abi:ne180100](v9 + 6, (uint64_t *)a3);
    if (v11 != (_QWORD *)a3)
    {
      v12 = 0;
      v13 = v10 + 8;
      v14 = a3 + 16;
      do
      {
        for (i = 0; i != 4; ++i)
          v13[i] = *(_QWORD *)(v14 + i * 8);
        ++v12;
        v13 += 4;
        v14 += 32;
      }
      while (v12 != 4);
    }
    PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::update(a1, (uint64_t)&v63, a4);
    goto LABEL_33;
  }
  v16 = *(_QWORD *)(a1 + 72) + 1;
  *(_QWORD *)(a1 + 72) = v16;
  v18 = *(_QWORD *)a3;
  v17 = *(std::__shared_weak_count **)(a3 + 8);
  v51[2] = *(_QWORD *)a3;
  v52 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
  }
  v21 = *(_OWORD *)(a3 + 96);
  v57 = *(_OWORD *)(a3 + 80);
  v58 = v21;
  v22 = *(_OWORD *)(a3 + 128);
  v59 = *(_OWORD *)(a3 + 112);
  v60 = v22;
  v23 = *(_OWORD *)(a3 + 32);
  v53 = *(_OWORD *)(a3 + 16);
  v54 = v23;
  v24 = *(_OWORD *)(a3 + 64);
  v55 = *(_OWORD *)(a3 + 48);
  v56 = v24;
  *(_QWORD *)&v61 = a4;
  *((_QWORD *)&v61 + 1) = v16;
  v62 = 0;
  v38 = *(_OWORD *)a2;
  v39 = v18;
  v40 = v17;
  if (v17)
  {
    v25 = (unint64_t *)&v17->__shared_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  v45 = v57;
  v46 = v58;
  v47 = v59;
  v48 = v60;
  v41 = v53;
  v42 = v54;
  v43 = v55;
  v44 = v56;
  v50 = v62;
  v49 = v61;
  v51[0] = (uint64_t)std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>>::__emplace_unique_key_args<PCHash128,std::pair<PCHash128 const,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>((uint64_t **)(a1 + 24), (const PCHash128 *)&v38, (uint64_t)&v38);
  v51[1] = v27;
  v28 = v40;
  if (v40)
  {
    v29 = (unint64_t *)&v40->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::add((void **)(a1 + 48), v51);
  v31 = *(_QWORD *)(a1 + 80) + a4;
  *(_QWORD *)(a1 + 80) = v31;
  if (!*(_QWORD *)(a1 + 104))
  {
    while (v31 > *(_QWORD *)(a1 + 88) || *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 96))
    {
      v34 = *(_QWORD **)(a1 + 48);
      if (v34 == *(_QWORD **)(a1 + 56))
        break;
      *(_QWORD *)&v38 = *v34;
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v38);
      v32 = (uint64_t *)v38;
      v33 = v38 + 48;
      *(_QWORD *)(a1 + 80) -= *(_QWORD *)(v38 + 192);
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v32);
      std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v33);
      operator delete(v32);
      v31 = *(_QWORD *)(a1 + 80);
    }
  }
  v35 = v52;
  if (v52)
  {
    v36 = (unint64_t *)&v52->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v8 = v64;
  if (v64)
    goto LABEL_33;
}

void sub_1B3029278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  uint64_t v34;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a34);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)(v34 - 72));
  _Unwind_Resume(a1);
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::add(void **a1, uint64_t *a2)
{
  char *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;

  v4 = (char *)*a1;
  v5 = a1[1];
  v6 = ((char *)v5 - (_BYTE *)*a1) >> 3;
  v7 = *a2;
  *(_QWORD *)(*a2 + 208) = v6;
  v10 = (unint64_t)a1[2];
  v8 = (uint64_t)(a1 + 2);
  v9 = v10;
  if ((unint64_t)v5 >= v10)
  {
    if ((unint64_t)(v6 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v12 = v9 - (_QWORD)v4;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v6 + 1))
      v13 = v6 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
    {
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8, v14);
      v7 = *a2;
    }
    else
    {
      v15 = 0;
    }
    v16 = &v15[8 * v6];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = v7;
    v11 = v16 + 8;
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v11;
    a1[2] = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v5 = v7;
    v11 = v5 + 1;
  }
  a1[1] = v11;
  v21 = *(_QWORD *)(*a2 + 208);
  if (v21)
  {
    v22 = (char *)*a1;
    v23 = *((_QWORD *)*a1 + v21);
    do
    {
      v24 = v21 - 1;
      v25 = (v21 - 1) >> 1;
      v26 = *(_QWORD *)&v22[8 * v25];
      if (*(_QWORD *)(v26 + 200) <= *(_QWORD *)(v23 + 200))
        break;
      *(_QWORD *)&v22[8 * v21] = v26;
      *(_QWORD *)&v22[8 * v25] = v23;
      v22 = (char *)*a1;
      *(_QWORD *)(*((_QWORD *)*a1 + v21) + 208) = v21;
      v23 = *(_QWORD *)&v22[8 * v25];
      *(_QWORD *)(v23 + 208) = v25;
      v21 = (v21 - 1) >> 1;
    }
    while (v24 > 1);
  }
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;

  v6 = *(_QWORD *)(a1 + 72) + 1;
  *(_QWORD *)(a1 + 72) = v6;
  *(_QWORD *)(*(_QWORD *)a2 + 200) = v6;
  v7 = (uint64_t *)(a1 + 48);
  PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), a2);
  v8 = *(_QWORD *)a2;
  v9 = a3 - *(_QWORD *)(*(_QWORD *)a2 + 192);
  if (v9)
  {
    v10 = v9 + *(_QWORD *)(a1 + 80);
    *(_QWORD *)(a1 + 80) = v10;
    *(_QWORD *)(v8 + 192) = a3;
    if (!*(_QWORD *)(a1 + 104))
    {
      while (v10 > *(_QWORD *)(a1 + 88) || *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 96))
      {
        v11 = *(uint64_t ***)(a1 + 48);
        if (v11 == *(uint64_t ***)(a1 + 56))
          break;
        v14 = *v11;
        PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::remove(v7, (uint64_t)&v14);
        v12 = v14;
        v13 = (uint64_t)(v14 + 6);
        *(_QWORD *)(a1 + 80) -= v14[24];
        std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), v12);
        std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v13);
        operator delete(v12);
        v10 = *(_QWORD *)(a1 + 80);
      }
    }
  }
}

uint64_t *std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>>::__emplace_unique_key_args<PCHash128,std::pair<PCHash128 const,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>(uint64_t **a1, const PCHash128 *a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v9[3];
  uint64_t v10;

  v5 = (uint64_t **)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::__find_equal<PCHash128>((uint64_t)a1, &v10, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>>::__construct_node<std::pair<PCHash128 const,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<FxDeviceKey,FxDeviceObj const>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<FxDeviceKey,FxDeviceObj const>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

__n128 std::__tree<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>>::__construct_node<std::pair<PCHash128 const,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>>@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __n128 result;

  v5 = a1 + 8;
  v6 = operator new(0xD8uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  v6[2] = *(_OWORD *)a2;
  v7 = *(_QWORD *)(a2 + 24);
  *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  *((_QWORD *)v6 + 7) = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = *(_OWORD *)(a2 + 112);
  v6[8] = *(_OWORD *)(a2 + 96);
  v6[9] = v10;
  v11 = *(_OWORD *)(a2 + 144);
  v6[10] = *(_OWORD *)(a2 + 128);
  v6[11] = v11;
  v12 = *(_OWORD *)(a2 + 48);
  v6[4] = *(_OWORD *)(a2 + 32);
  v6[5] = v12;
  v13 = *(_OWORD *)(a2 + 80);
  v6[6] = *(_OWORD *)(a2 + 64);
  v6[7] = v13;
  result = *(__n128 *)(a2 + 160);
  *((_QWORD *)v6 + 26) = *(_QWORD *)(a2 + 176);
  v6[12] = result;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::findValue(uint64_t a1@<X0>, const PCHash128 *a2@<X1>, _BYTE *a3@<X2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  _QWORD v20[2];

  v8 = (os_unfair_lock_s *)(a1 + 16);
  v20[1] = a1 + 16;
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 16));
  v9 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>(a1 + 24, a2);
  v20[0] = v9;
  if ((_QWORD *)(a1 + 32) == v9)
  {
    *a3 = 0;
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 136) = 0x3FF0000000000000;
    *(_QWORD *)(a4 + 96) = 0x3FF0000000000000;
    *(_QWORD *)(a4 + 56) = 0x3FF0000000000000;
    *(_QWORD *)(a4 + 16) = 0x3FF0000000000000;
    *(_OWORD *)(a4 + 24) = 0u;
    *(_OWORD *)(a4 + 40) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 104) = 0u;
    *(_OWORD *)(a4 + 120) = 0u;
  }
  else
  {
    *(_QWORD *)a4 = v9[6];
    v10 = v9[7];
    *(_QWORD *)(a4 + 8) = v10;
    if (v10)
    {
      v11 = (unint64_t *)(v10 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    v13 = *((_OWORD *)v9 + 4);
    v14 = *((_OWORD *)v9 + 5);
    v15 = *((_OWORD *)v9 + 7);
    *(_OWORD *)(a4 + 48) = *((_OWORD *)v9 + 6);
    *(_OWORD *)(a4 + 64) = v15;
    *(_OWORD *)(a4 + 16) = v13;
    *(_OWORD *)(a4 + 32) = v14;
    v16 = *((_OWORD *)v9 + 8);
    v17 = *((_OWORD *)v9 + 9);
    v18 = *((_OWORD *)v9 + 11);
    *(_OWORD *)(a4 + 112) = *((_OWORD *)v9 + 10);
    *(_OWORD *)(a4 + 128) = v18;
    *(_OWORD *)(a4 + 80) = v16;
    *(_OWORD *)(a4 + 96) = v17;
    v19 = *(_QWORD *)(a1 + 72) + 1;
    *(_QWORD *)(a1 + 72) = v19;
    v9[25] = v19;
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), (uint64_t)v20);
    *a3 = 1;
  }
  PCSpinLock::unlock(v8);
}

void sub_1B3029728(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::removeKey(uint64_t *a1, const PCHash128 *a2)
{
  os_unfair_lock_s *v4;
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8[2];

  v4 = (os_unfair_lock_s *)(a1 + 2);
  v8[1] = a1 + 2;
  PCSpinLock::lock((os_unfair_lock_t)a1 + 4);
  v5 = (uint64_t **)(a1 + 3);
  v6 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>((uint64_t)(a1 + 3), a2);
  v8[0] = v6;
  if (a1 + 4 != v6)
  {
    a1[10] -= v6[24];
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,std::__tree_node<std::__value_type<PCHash128,PCCacheImpl<PCHash128,PGTextureCache::CacheData,PCSpinLock,std::less<PCHash128>>::Data>,void *> *,long>>>::remove(a1 + 6, (uint64_t)v8);
    v7 = v8[0];
    std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(v5, v8[0]);
    std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)(v7 + 6));
    operator delete(v7);
  }
  PCSpinLock::unlock(v4);
}

void sub_1B30297F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void PMLayerDescription::PMLayerDescription(PMLayerDescription *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0x500000000;
  *((_QWORD *)this + 3) = 0x3FF0000000000000;
  *((_DWORD *)this + 8) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 5);
}

void PMLayerDescription::PMLayerDescription(PMLayerDescription *this, const PCString *a2)
{
  *(_OWORD *)this = *(_OWORD *)&a2->var0;
  *((PCString *)this + 2) = a2[2];
  *((PCString *)this + 3) = a2[3];
  *((_DWORD *)this + 8) = a2[4].var0;
  PCString::PCString((PCString *)this + 5, a2 + 5);
}

uint64_t PMLayerDescription::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  PCString::set((PCString *)(a1 + 40), (const PCString *)(a2 + 40));
  return a1;
}

void PMClip::PMClip(PMClip *this, const PCURL *a2, const PMFormatDescription *a3)
{
  PMFormatDescription *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;

  v6 = PMFormatDescription::PMFormatDescription(this);
  *((_QWORD *)v6 + 151) = 0;
  *(_OWORD *)((char *)v6 + 1176) = 0u;
  *(_OWORD *)((char *)v6 + 1192) = 0u;
  *(_OWORD *)((char *)v6 + 1144) = 0u;
  *(_OWORD *)((char *)v6 + 1160) = 0u;
  PCURL::PCURL((PMFormatDescription *)((char *)v6 + 1224), a2);
  PCURL::getAsFileSystemString((const __CFURL **)a2, (PCString *)this + 154);
  *((_WORD *)this + 620) = 0;
  *((_DWORD *)this + 311) = 0;
  *((_WORD *)this + 624) = 0;
  PCMutex::PCMutex((PCMutex *)((char *)this + 1256), 1);
  *(_QWORD *)this = *(_QWORD *)a3;
  memcpy((char *)this + 8, (char *)a3 + 8, 0x1C0uLL);
  PCString::set((PCString *)this + 57, (const PCString *)a3 + 57);
  v7 = *((_QWORD *)a3 + 58);
  *((_DWORD *)this + 118) = *((_DWORD *)a3 + 118);
  *((_QWORD *)this + 58) = v7;
  PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)this + 60, (CGColorSpace **)a3 + 60);
  *(_OWORD *)((char *)this + 488) = *(_OWORD *)((char *)a3 + 488);
  *((_QWORD *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  *((_DWORD *)this + 129) = *((_DWORD *)a3 + 129);
  PMAudioDescription::operator=((uint64_t)this + 520, (uint64_t)a3 + 520);
  *((_QWORD *)this + 79) = 0;
  *((_DWORD *)this + 160) = 0;
  memcpy((char *)this + 648, (char *)a3 + 648, 0x1C0uLL);
  PCString::set((PCString *)this + 137, (const PCString *)a3 + 137);
  v8 = *((_QWORD *)a3 + 138);
  *((_DWORD *)this + 278) = *((_DWORD *)a3 + 278);
  *((_QWORD *)this + 138) = v8;
  PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)this + 140, (CGColorSpace **)a3 + 140);
  *(_OWORD *)((char *)this + 1128) = *(_OWORD *)((char *)a3 + 1128);
  if (*((_QWORD *)a3 + 63))
  {
    v9 = malloc_type_malloc(*((unsigned int *)a3 + 128), 0x69CF949EuLL);
    *((_QWORD *)this + 63) = v9;
    memcpy(v9, *((const void **)a3 + 63), *((unsigned int *)a3 + 128));
    *((_DWORD *)this + 128) = *((_DWORD *)a3 + 128);
  }
  if (*((_QWORD *)a3 + 79))
  {
    v10 = malloc_type_malloc(*((unsigned int *)a3 + 160), 0x21C6B60uLL);
    *((_QWORD *)this + 79) = v10;
    memcpy(v10, *((const void **)a3 + 79), *((unsigned int *)a3 + 160));
    *((_DWORD *)this + 160) = *((_DWORD *)a3 + 160);
  }
  memcpy((char *)this + 648, (char *)a3 + 648, 0x1C0uLL);
  PCString::set((PCString *)this + 137, (const PCString *)a3 + 137);
  v11 = *((_QWORD *)a3 + 138);
  *((_DWORD *)this + 278) = *((_DWORD *)a3 + 278);
  *((_QWORD *)this + 138) = v11;
  PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)this + 140, (CGColorSpace **)a3 + 140);
  *(_OWORD *)((char *)this + 1128) = *(_OWORD *)((char *)a3 + 1128);
}

void sub_1B3029B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCMutex *a10, PCString *a11, PCURL *a12, _QWORD *a13, _QWORD *a14)
{
  PMFormatDescription *v14;
  void *v16;

  PCString::~PCString(a11);
  PCURL::~PCURL(a12);
  v16 = (void *)*((_QWORD *)v14 + 149);
  if (v16)
    operator delete(v16);
  a14 = (_QWORD *)((char *)v14 + 1168);
  std::vector<PMAudioDescription>::__destroy_vector::operator()[abi:ne180100]((void ***)&a14);
  a14 = a13;
  std::vector<PMLayerDescription>::__destroy_vector::operator()[abi:ne180100]((void ***)&a14);
  PMFormatDescription::~PMFormatDescription(v14);
  _Unwind_Resume(a1);
}

void PMClip::PMClip(PMClip *this, const PMClip *a2)
{
  PMFormatDescription *v4;

  v4 = PMFormatDescription::PMFormatDescription(this, a2);
  *((_QWORD *)v4 + 145) = 0;
  *(_OWORD *)((char *)v4 + 1144) = 0u;
  std::vector<PMLayerDescription>::__init_with_size[abi:ne180100]<PMLayerDescription*,PMLayerDescription*>((_QWORD *)v4 + 143, *((_QWORD *)a2 + 143), *((_QWORD *)a2 + 144), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a2 + 144) - *((_QWORD *)a2 + 143)) >> 4));
  *((_QWORD *)this + 148) = 0;
  *((_OWORD *)this + 73) = 0u;
  std::vector<PMAudioDescription>::__init_with_size[abi:ne180100]<PMAudioDescription*,PMAudioDescription*>((_QWORD *)this + 146, *((_QWORD *)a2 + 146), *((_QWORD *)a2 + 147), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)a2 + 147) - *((_QWORD *)a2 + 146)) >> 4));
  std::vector<BOOL>::vector((_QWORD *)this + 149, (uint64_t)a2 + 1192);
  *((_QWORD *)this + 152) = 0;
  PCURL::PCURL((PMClip *)((char *)this + 1224), (const PMClip *)((char *)a2 + 1224));
  PCString::PCString((PCString *)this + 154, (const PCString *)a2 + 154);
  *((_WORD *)this + 620) = *((_WORD *)a2 + 620);
  *((_DWORD *)this + 311) = 0;
  *((_WORD *)this + 624) = 0;
  PCMutex::PCMutex((PCMutex *)((char *)this + 1256), 1);
}

void sub_1B3029CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  PMFormatDescription *v10;
  void **v11;
  PCURL *v12;
  PCString *v13;

  PCString::~PCString(v13);
  PCURL::~PCURL(v12);
  if (*v11)
    operator delete(*v11);
  std::vector<PMAudioDescription>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  std::vector<PMLayerDescription>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  PMFormatDescription::~PMFormatDescription(v10);
  _Unwind_Resume(a1);
}

void sub_1B3029D44()
{
  JUMPOUT(0x1B3029D34);
}

void PMClip::~PMClip(PMClip *this)
{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  v2 = (void *)*((_QWORD *)this + 63);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 79);
  if (v3)
    free(v3);
  PMClip::close(this);
  PCMutex::~PCMutex((PCMutex *)((char *)this + 1256));
  PCString::~PCString((PCString *)this + 154);
  PCURL::~PCURL((PMClip *)((char *)this + 1224));
  v4 = (void *)*((_QWORD *)this + 149);
  if (v4)
    operator delete(v4);
  v5 = (void **)((char *)this + 1168);
  std::vector<PMAudioDescription>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 1144);
  std::vector<PMLayerDescription>::__destroy_vector::operator()[abi:ne180100](&v5);
  PMFormatDescription::~PMFormatDescription(this);
}

uint64_t PMClip::close(PMClip *this)
{
  PCMutex *v2;
  int v3;
  int v4;
  void (*v6)(PMClip *, _QWORD);

  v2 = (PCMutex *)((char *)this + 1256);
  PCMutex::lock((PCMutex *)((char *)this + 1256));
  v3 = *((_DWORD *)this + 311);
  if (v3)
  {
    v4 = v3 - 1;
    *((_DWORD *)this + 311) = v4;
    if (!v4)
    {
      if (*(_QWORD *)this)
      {
        v6 = *(void (**)(PMClip *, _QWORD))(*(_QWORD *)this + 16);
        if (v6)
        {
          v6(this, *((_QWORD *)this + 152));
          *((_QWORD *)this + 152) = 0;
        }
      }
    }
  }
  PCMutex::unlock(v2);
  return 0;
}

void sub_1B3029E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t PMClip::open(PMClip *this)
{
  PCMutex *v2;
  int v3;
  uint64_t v4;
  const __CFURL **v5;
  int isSequence;
  PCURL *URLforIndex;
  unsigned int v8;
  unsigned int v9;
  uint64_t (*v10)(PMClip *, CMTime *, _QWORD, PCURL *, _QWORD);
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t (*v15)(PMClip *, CMTime *, _QWORD, PCURL *, _QWORD);
  unint64_t v16;
  uint64_t v17;
  int SequenceEnd;
  int64_t v19;
  int v21;
  CMTime v22;
  uint64_t v23;
  int v24;
  PCString v25[9];
  PCString v26;
  char *v27;
  char v28;

  v2 = (PCMutex *)((char *)this + 1256);
  v27 = (char *)this + 1256;
  PCMutex::lock((PCMutex *)((char *)this + 1256));
  v28 = 1;
  v3 = *((_DWORD *)this + 311);
  if (!v3)
  {
    if (!*(_QWORD *)this)
    {
      v4 = 1;
      goto LABEL_48;
    }
    v5 = (const __CFURL **)((char *)this + 1224);
    isSequence = PCURL::isSequence((const __CFURL **)this + 153);
    *((_BYTE *)this + 1240) = isSequence;
    URLforIndex = (PMClip *)((char *)this + 1224);
    if (isSequence)
      URLforIndex = PCURL::getURLforIndex((const __CFURL **)this + 153, 0);
    v4 = (**(uint64_t (***)(PMClip *, PCURL *, char *))this)(this, URLforIndex, (char *)this + 1216);
    if ((_DWORD)v4)
    {
      if (!isSequence)
        goto LABEL_47;
      goto LABEL_44;
    }
    ++*((_DWORD *)this + 311);
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
    *(_OWORD *)((char *)this + 72) = 0u;
    *(_OWORD *)((char *)this + 88) = 0u;
    *(_OWORD *)((char *)this + 104) = 0u;
    *(_OWORD *)((char *)this + 120) = 0u;
    *(_OWORD *)((char *)this + 136) = 0u;
    *(_OWORD *)((char *)this + 152) = 0u;
    *(_OWORD *)((char *)this + 168) = 0u;
    *(_OWORD *)((char *)this + 184) = 0u;
    *(_OWORD *)((char *)this + 200) = 0u;
    *(_OWORD *)((char *)this + 216) = 0u;
    *(_OWORD *)((char *)this + 232) = 0u;
    *(_OWORD *)((char *)this + 248) = 0u;
    *(_OWORD *)((char *)this + 8) = 0u;
    *(_OWORD *)((char *)this + 264) = 0u;
    *(_OWORD *)((char *)this + 280) = 0u;
    *(_OWORD *)((char *)this + 296) = 0u;
    *(_OWORD *)((char *)this + 312) = 0u;
    *(_OWORD *)((char *)this + 328) = 0u;
    *(_OWORD *)((char *)this + 344) = 0u;
    *(_OWORD *)((char *)this + 360) = 0u;
    *(_OWORD *)((char *)this + 376) = 0u;
    *(_OWORD *)((char *)this + 392) = 0u;
    *(_OWORD *)((char *)this + 408) = 0u;
    *(_OWORD *)((char *)this + 424) = 0u;
    *(_OWORD *)((char *)this + 440) = 0u;
    *(_OWORD *)((char *)this + 456) = 0u;
    *(_OWORD *)((char *)this + 472) = 0u;
    *(_OWORD *)((char *)this + 488) = 0u;
    *(_OWORD *)((char *)this + 1112) = 0u;
    *(_OWORD *)((char *)this + 1128) = 0u;
    *(_OWORD *)((char *)this + 1080) = 0u;
    *(_OWORD *)((char *)this + 1096) = 0u;
    *(_OWORD *)((char *)this + 1048) = 0u;
    *(_OWORD *)((char *)this + 1064) = 0u;
    *(_OWORD *)((char *)this + 1016) = 0u;
    *(_OWORD *)((char *)this + 1032) = 0u;
    *(_OWORD *)((char *)this + 984) = 0u;
    *(_OWORD *)((char *)this + 1000) = 0u;
    *(_OWORD *)((char *)this + 952) = 0u;
    *(_OWORD *)((char *)this + 968) = 0u;
    *(_OWORD *)((char *)this + 920) = 0u;
    *(_OWORD *)((char *)this + 936) = 0u;
    *(_OWORD *)((char *)this + 888) = 0u;
    *(_OWORD *)((char *)this + 904) = 0u;
    *(_OWORD *)((char *)this + 856) = 0u;
    *(_OWORD *)((char *)this + 872) = 0u;
    *(_OWORD *)((char *)this + 824) = 0u;
    *(_OWORD *)((char *)this + 840) = 0u;
    *(_OWORD *)((char *)this + 792) = 0u;
    *(_OWORD *)((char *)this + 808) = 0u;
    *(_OWORD *)((char *)this + 760) = 0u;
    *(_OWORD *)((char *)this + 776) = 0u;
    *(_OWORD *)((char *)this + 728) = 0u;
    *(_OWORD *)((char *)this + 744) = 0u;
    *(_OWORD *)((char *)this + 696) = 0u;
    *(_OWORD *)((char *)this + 712) = 0u;
    *(_OWORD *)((char *)this + 664) = 0u;
    *(_OWORD *)((char *)this + 680) = 0u;
    *(_OWORD *)((char *)this + 648) = 0u;
    v4 = (*(uint64_t (**)(PMClip *, PCURL *, _QWORD))(*(_QWORD *)this + 24))(this, URLforIndex, *((_QWORD *)this + 152));
    if (!*((_DWORD *)this + 108))
      *((_DWORD *)this + 108) = *((_DWORD *)this + 72);
    if (!*((_DWORD *)this + 109))
      *((_DWORD *)this + 109) = *((_DWORD *)this + 73);
    PMClip::getFormatName(this, &v26);
    if (PCString::empty(&v26))
    {
      *((_BYTE *)this + 1241) = 0;
      if ((_DWORD)v4)
        goto LABEL_43;
    }
    else
    {
      PCString::PCString((PCString *)&v22, "OpenEXR");
      *((_BYTE *)this + 1241) = PCString::compare(&v26, (const PCString *)&v22) == kCFCompareEqualTo;
      PCString::~PCString((PCString *)&v22);
      if ((_DWORD)v4)
        goto LABEL_43;
    }
    v21 = isSequence;
    v8 = *((_DWORD *)this + 98);
    if (v8)
    {
      v9 = 1;
      do
      {
        v22.value = 0;
        *(_QWORD *)&v22.timescale = 0;
        v22.epoch = 0x500000000;
        v23 = 0x3FF0000000000000;
        v24 = 0;
        PCSharedCount::PCSharedCount((PCSharedCount *)v25);
        v10 = *(uint64_t (**)(PMClip *, CMTime *, _QWORD, PCURL *, _QWORD))(*(_QWORD *)this + 32);
        if (v10)
          v4 = v10(this, &v22, v9 - 1, URLforIndex, *((_QWORD *)this + 152));
        else
          v4 = 0;
        v11 = *((_QWORD *)this + 144);
        if (v11 >= *((_QWORD *)this + 145))
        {
          v12 = std::vector<PMLayerDescription>::__push_back_slow_path<PMLayerDescription const&>((uint64_t *)this + 143, (const PCString *)&v22);
        }
        else
        {
          PMLayerDescription::PMLayerDescription(*((PMLayerDescription **)this + 144), (const PCString *)&v22);
          v12 = v11 + 48;
          *((_QWORD *)this + 144) = v11 + 48;
        }
        *((_QWORD *)this + 144) = v12;
        PCString::~PCString(v25);
        if (v9 > v8)
          break;
        ++v9;
      }
      while (!(_DWORD)v4);
    }
    else
    {
      v4 = 0;
    }
    v13 = *((_DWORD *)this + 129);
    if (v13)
    {
      v5 = (const __CFURL **)((char *)this + 1224);
      isSequence = v21;
      if (!(_DWORD)v4)
      {
        v14 = 1;
        do
        {
          PMAudioDescription::PMAudioDescription((PMAudioDescription *)&v22);
          v15 = *(uint64_t (**)(PMClip *, CMTime *, _QWORD, PCURL *, _QWORD))(*(_QWORD *)this + 96);
          if (v15)
            v4 = v15(this, &v22, v14 - 1, URLforIndex, *((_QWORD *)this + 152));
          else
            v4 = 0;
          v16 = *((_QWORD *)this + 147);
          if (v16 >= *((_QWORD *)this + 148))
          {
            v17 = std::vector<PMAudioDescription>::__push_back_slow_path<PMAudioDescription const&>((uint64_t *)this + 146, (const PMAudioDescription *)&v22);
          }
          else
          {
            PMAudioDescription::PMAudioDescription(*((PMAudioDescription **)this + 147), (const PMAudioDescription *)&v22);
            v17 = v16 + 112;
            *((_QWORD *)this + 147) = v16 + 112;
          }
          *((_QWORD *)this + 147) = v17;
          PMAudioDescription::~PMAudioDescription((PCString *)&v22);
          if (v14 >= v13)
            break;
          ++v14;
        }
        while (!(_DWORD)v4);
      }
    }
    else
    {
      v5 = (const __CFURL **)((char *)this + 1224);
      isSequence = v21;
    }
LABEL_43:
    PCString::~PCString(&v26);
    if (!isSequence)
    {
LABEL_47:
      *((_BYTE *)this + 1249) = 0;
      goto LABEL_48;
    }
LABEL_44:
    if (URLforIndex)
    {
      PCURL::~PCURL(URLforIndex);
      MEMORY[0x1B5E29170]();
    }
    SequenceEnd = PCURL::getSequenceEnd(v5);
    v19 = SequenceEnd - PCURL::getSequenceStart(v5) + 1;
    *((_DWORD *)this + 86) = v19;
    CMTimeMake(&v22, v19, (int)*((double *)this + 45));
    *(CMTime *)((char *)this + 296) = v22;
    goto LABEL_47;
  }
  v4 = 0;
  *((_DWORD *)this + 311) = v3 + 1;
LABEL_48:
  PCMutex::unlock(v2);
  return v4;
}

void sub_1B302A298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  PCString::~PCString((PCString *)va);
  PCString::~PCString((PCString *)(v3 - 112));
  PCLockSentry<PCMutex>::~PCLockSentry(v3 - 104);
  _Unwind_Resume(a1);
}

void PMClip::getFormatName(PMClip *this@<X0>, PCString *a2@<X8>)
{
  uint64_t v3;
  const char *v4;

  v3 = *(_QWORD *)this;
  if (v3)
  {
    v4 = (const char *)(*(uint64_t (**)(void))(v3 + 240))();
    PCString::PCString(a2, v4);
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

uint64_t PMClip::reloadResources(PMClip *this)
{
  PCMutex *v2;
  const __CFURL *v3;
  int v4;
  PCURL *URLforIndex;
  void (*v6)(PMClip *, _QWORD);
  unsigned int (*v7)(PMClip *, PCURL *, char *);
  int SequenceEnd;
  int64_t v9;
  CMTime v11;
  char *v12;
  char v13;

  v2 = (PCMutex *)((char *)this + 1256);
  v12 = (char *)this + 1256;
  PCMutex::lock((PCMutex *)((char *)this + 1256));
  v13 = 1;
  if (*((_DWORD *)this + 311))
  {
    v3 = *(const __CFURL **)this;
    if (*(_QWORD *)this && !*((_BYTE *)this + 1249))
    {
      v4 = *((unsigned __int8 *)this + 1240);
      if (*((_BYTE *)this + 1240))
      {
        URLforIndex = PCURL::getURLforIndex((const __CFURL **)this + 153, 0);
        v3 = *(const __CFURL **)this;
      }
      else
      {
        URLforIndex = (PMClip *)((char *)this + 1224);
      }
      v6 = (void (*)(PMClip *, _QWORD))*((_QWORD *)v3 + 2);
      if (v6)
      {
        v6(this, *((_QWORD *)this + 152));
        *((_QWORD *)this + 152) = 0;
        v3 = *(const __CFURL **)this;
      }
      v7 = *(unsigned int (**)(PMClip *, PCURL *, char *))v3;
      if (v7 && !v7(this, URLforIndex, (char *)this + 1216))
        (*(void (**)(PMClip *, PCURL *, _QWORD))(*(_QWORD *)this + 24))(this, URLforIndex, *((_QWORD *)this + 152));
      if (v4)
      {
        if (URLforIndex)
        {
          PCURL::~PCURL(URLforIndex);
          MEMORY[0x1B5E29170]();
        }
        SequenceEnd = PCURL::getSequenceEnd((const __CFURL **)this + 153);
        v9 = SequenceEnd - PCURL::getSequenceStart((const __CFURL **)this + 153) + 1;
        *((_DWORD *)this + 86) = v9;
        CMTimeMake(&v11, v9, (int)*((double *)this + 45));
        *(CMTime *)((char *)this + 296) = v11;
      }
    }
    *((_BYTE *)this + 1249) = 1;
  }
  PCMutex::unlock(v2);
  return 0;
}

void sub_1B302A4B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

void PMClip::getFilename(const __CFURL **this@<X0>, PCString *a2@<X8>)
{
  PCURL::getFilename(this + 153, a2);
}

void PMClip::getShortFilename(CFURLRef *this@<X0>, PCString *a2@<X8>)
{
  PCURL::getShortFilename(this + 153, a2);
}

void PMClip::getExtension(const __CFURL **this@<X0>, PCURL *a2@<X8>)
{
  PCURL::getExtension(this + 153, a2);
}

void PMClip::getAsFileSystemString(const PCString *this@<X0>, PCString *a2@<X8>)
{
  PCString::PCString(a2, this + 154);
}

void PMClip::getAsURLString(const __CFURL **this@<X0>, PCURL *a2@<X8>)
{
  PCURL::getAsURLString(this + 153, a2);
}

void PMClip::getCodecName(PMClip *this@<X0>, PCURL *a2@<X8>)
{
  CFStringRef v3;

  if (*(_QWORD *)this)
  {
    v3 = CFStringCreateWithCString(0, (const char *)this + 8, 0);
    PCURL::PCURL(a2, v3);
    if (v3)
      CFRelease(v3);
  }
  else
  {
    PCSharedCount::PCSharedCount((PCSharedCount *)a2);
  }
}

void sub_1B302A55C(_Unwind_Exception *a1)
{
  PCString *v1;

  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

uint64_t PMClip::getDuration@<X0>(uint64_t this@<X0>, CMTime *a2@<X8>)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  CMTimeEpoch v10;
  CMTime time2;
  CMTime time1;

  v2 = this;
  if (*(_DWORD *)(this + 392))
  {
    a2->epoch = *(_QWORD *)(this + 312);
    *(_OWORD *)&a2->value = *(_OWORD *)(this + 296);
  }
  else
  {
    v4 = *(_DWORD *)(this + 516);
    v5 = MEMORY[0x1E0CA2E68];
    *(_OWORD *)&a2->value = *MEMORY[0x1E0CA2E68];
    a2->epoch = *(_QWORD *)(v5 + 16);
    if (v4)
    {
      v6 = 0;
      v7 = 24;
      do
      {
        v8 = *(_QWORD *)(v2 + 1168) + v7;
        v9 = *(_OWORD *)v8;
        v10 = *(_QWORD *)(v8 + 16);
        *(_OWORD *)&time1.value = *(_OWORD *)v8;
        time1.epoch = v10;
        time2 = *a2;
        this = CMTimeCompare(&time1, &time2);
        if ((int)this >= 1)
        {
          *(_OWORD *)&a2->value = v9;
          a2->epoch = v10;
        }
        ++v6;
        v7 += 112;
      }
      while (v6 < *(unsigned int *)(v2 + 516));
    }
  }
  return this;
}

double PMClip::getSeconds(PMClip *this, double a2)
{
  double result;
  uint64_t v3;
  double *v4;
  double v5;
  double v6;
  double v7;

  if (*((_DWORD *)this + 98))
  {
    LODWORD(a2) = *((_DWORD *)this + 86);
    return (double)*(unint64_t *)&a2 / *((double *)this + 45);
  }
  else
  {
    v3 = *((unsigned int *)this + 129);
    if ((_DWORD)v3)
    {
      v4 = (double *)(*((_QWORD *)this + 146) + 64);
      result = 0.0;
      do
      {
        v5 = (double)*((unint64_t *)v4 - 6);
        v6 = *v4;
        v4 += 14;
        v7 = v5 / v6;
        if (v7 > result)
          result = v7;
        --v3;
      }
      while (v3);
    }
    else
    {
      return 0.0;
    }
  }
  return result;
}

__darwin_time_t PMClip::getModificationDate(PMClip *this)
{
  const __CFURL **v1;
  int SequenceLength;
  int v3;
  __darwin_time_t tv_sec;
  int i;
  const __CFURL **URLforIndex;
  PCURL *v7;
  char *v8;
  int v9;
  char *UTF8Str;
  int v11;
  PCString v13;
  stat v14;

  if (*((_BYTE *)this + 1240))
  {
    v1 = (const __CFURL **)((char *)this + 1224);
    SequenceLength = PCURL::getSequenceLength((const __CFURL **)this + 153);
    if (SequenceLength < 1)
    {
      return 0;
    }
    else
    {
      v3 = SequenceLength;
      tv_sec = 0;
      for (i = 0; i != v3; ++i)
      {
        URLforIndex = (const __CFURL **)PCURL::getURLforIndex(v1, i);
        if (URLforIndex)
        {
          v7 = (PCURL *)URLforIndex;
          PCURL::getAsFileSystemString(URLforIndex, &v13);
          v8 = PCString::createUTF8Str(&v13);
          PCString::~PCString(&v13);
          v9 = stat(v8, &v14);
          free(v8);
          PCURL::~PCURL(v7);
          MEMORY[0x1B5E29170]();
          if (!v9 && v14.st_mtimespec.tv_sec > tv_sec)
            tv_sec = v14.st_mtimespec.tv_sec;
        }
      }
    }
  }
  else
  {
    UTF8Str = PCString::createUTF8Str((PCString *)this + 154);
    v11 = stat(UTF8Str, &v14);
    free(UTF8Str);
    if (v11)
      return 0;
    else
      return v14.st_mtimespec.tv_sec;
  }
  return tv_sec;
}

void sub_1B302A7C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t PMClip::getVideoDescription(uint64_t a1, void *__dst)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a1 + 8;
  memcpy(__dst, (const void *)(a1 + 8), 0x1C0uLL);
  PCString::set((PCString *)__dst + 56, (const PCString *)(a1 + 456));
  v5 = *(_QWORD *)(a1 + 464);
  *((_DWORD *)__dst + 116) = *(_DWORD *)(a1 + 472);
  *((_QWORD *)__dst + 57) = v5;
  PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)__dst + 59, (CGColorSpace **)(a1 + 480));
  *((_OWORD *)__dst + 30) = *(_OWORD *)(v4 + 480);
  if (*(_DWORD *)(a1 + 392))
    return 0;
  else
    return 7;
}

uint64_t PMClip::getLayerDescription(PMClip *this, PMLayerDescription *a2, unsigned int a3)
{
  unsigned int v3;
  BOOL v4;

  v3 = *((_DWORD *)this + 98);
  if (v3)
    v4 = v3 >= a3;
  else
    v4 = 0;
  if (!v4)
    return 7;
  PMLayerDescription::operator=((uint64_t)a2, *((_QWORD *)this + 143) + 48 * a3);
  return 0;
}

uint64_t PMClip::getMediaID@<X0>(PMClip *this@<X0>, PCSharedCount *a2@<X8>)
{
  void (*v4)(PMClip *, char *, PCSharedCount *, _QWORD);

  PCSharedCount::PCSharedCount(a2);
  PCMutex::lock((PCMutex *)((char *)this + 1256));
  if (*(_QWORD *)this)
  {
    v4 = *(void (**)(PMClip *, char *, PCSharedCount *, _QWORD))(*(_QWORD *)this + 56);
    if (v4)
      v4(this, (char *)this + 1224, a2, *((_QWORD *)this + 152));
  }
  return PCMutex::unlock((PCMutex *)((char *)this + 1256));
}

void sub_1B302A918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCString *v9;

  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  PCString::~PCString(v9);
  _Unwind_Resume(a1);
}

uint64_t PMClip::prerollBegin(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, double a5)
{
  PCMutex *v10;
  uint64_t (*v11)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, _QWORD, double);
  uint64_t v12;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  char v17;

  v10 = (PCMutex *)(a1 + 1256);
  v16 = a1 + 1256;
  PCMutex::lock((PCMutex *)(a1 + 1256));
  v17 = 1;
  if (*(_QWORD *)a1 && *(_DWORD *)(a1 + 1244))
  {
    v11 = *(uint64_t (**)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, _QWORD, double))(*(_QWORD *)a1 + 120);
    if (v11)
    {
      v14 = *a2;
      v15 = *((_QWORD *)a2 + 2);
      v12 = v11(a1, a1 + 1224, &v14, a3, a4, *(_QWORD *)(a1 + 1216), a5);
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = 6;
  }
  PCMutex::unlock(v10);
  return v12;
}

void sub_1B302AA0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PMClip::prerollEnd(uint64_t a1, uint64_t a2)
{
  PCMutex *v4;
  uint64_t (*v5)(uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t v6;

  v4 = (PCMutex *)(a1 + 1256);
  PCMutex::lock((PCMutex *)(a1 + 1256));
  if (*(_QWORD *)a1 && *(_DWORD *)(a1 + 1244))
  {
    v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 128);
    if (v5)
      v6 = v5(a1, a1 + 1224, a2, *(_QWORD *)(a1 + 1216));
    else
      v6 = 0;
  }
  else
  {
    v6 = 6;
  }
  PCMutex::unlock(v4);
  return v6;
}

void sub_1B302AAB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t PMClip::setRate(uint64_t a1, double a2, uint64_t a3, uint64_t a4)
{
  PCMutex *v7;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, _QWORD, double);
  uint64_t v9;

  v7 = (PCMutex *)(a1 + 1256);
  PCMutex::lock((PCMutex *)(a1 + 1256));
  if (*(_QWORD *)a1 && *(_DWORD *)(a1 + 1244))
  {
    v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, double))(*(_QWORD *)a1 + 136);
    if (v8)
      v9 = v8(a1, a1 + 1224, a4, *(_QWORD *)(a1 + 1216), a2);
    else
      v9 = 0;
  }
  else
  {
    v9 = 6;
  }
  PCMutex::unlock(v7);
  return v9;
}

void sub_1B302AB74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t PMClip::scheduleTokens(uint64_t a1, __int128 **a2, uint64_t a3, uint64_t a4)
{
  PCMutex *v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, _QWORD);
  uint64_t v10;
  CMTime v12;
  uint64_t v13[4];
  char v14;

  v8 = (PCMutex *)(a1 + 1256);
  v13[3] = a1 + 1256;
  PCMutex::lock((PCMutex *)(a1 + 1256));
  v14 = 1;
  if (*(_QWORD *)a1 && *(_DWORD *)(a1 + 1244))
  {
    memset(v13, 0, 24);
    v12 = *(CMTime *)(a1 + 320);
    transformTokenTimes(a2, v13, &v12);
    if (*(_QWORD *)a1
      && (v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 144)) != 0)
    {
      v10 = v9(a1, a1 + 1224, v13, a3, a4, *(_QWORD *)(a1 + 1216));
    }
    else
    {
      v10 = 0;
    }
    v12.value = (CMTimeValue)v13;
    std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v12);
  }
  else
  {
    v10 = 6;
  }
  PCMutex::unlock(v8);
  return v10;
}

void sub_1B302AC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15)
{
  a9 = (void **)&a12;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void transformTokenTimes(__int128 **a1, uint64_t *a2, CMTime *a3)
{
  __int128 *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 *v9;
  __int128 *v10;
  _QWORD *v11;
  void **v12;
  void **v13;
  _QWORD *v14;
  __int128 v15;
  char *v16;
  __int128 v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  __int128 v24;
  char *v25;
  char *v26;
  char *v27;
  __int128 v28;
  __int128 *v29;
  __int128 v31;
  uint64_t v32;
  CMTime v33;
  CMTime v34;

  v3 = *a1;
  v29 = a1[1];
  if (*a1 != v29)
  {
    do
    {
      std::vector<std::pair<CMTime,std::vector<CMTime>>>::resize(a2, 1 - 0x5555555555555555 * ((a2[1] - *a2) >> 4));
      v5 = *a2;
      v6 = -1 - 0x5555555555555555 * ((a2[1] - *a2) >> 4);
      v7 = *a2 + 48 * v6;
      v8 = *v3;
      *(_QWORD *)(v7 + 16) = *((_QWORD *)v3 + 2);
      *(_OWORD *)v7 = v8;
      v10 = (__int128 *)*((_QWORD *)v3 + 3);
      v9 = (__int128 *)*((_QWORD *)v3 + 4);
      if (v10 != v9)
      {
        v11 = (_QWORD *)(v5 + 48 * v6);
        v12 = (void **)(v11 + 3);
        v13 = (void **)(v11 + 4);
        v14 = v11 + 5;
        do
        {
          v15 = *v10;
          v34.epoch = *((_QWORD *)v10 + 2);
          *(_OWORD *)&v34.value = v15;
          v33 = *a3;
          PC_CMTimeFloorToSampleDuration(&v34, &v33, (uint64_t)&v31);
          v16 = (char *)*v13;
          if ((unint64_t)*v13 >= *v14)
          {
            v19 = 0xAAAAAAAAAAAAAAABLL * ((v16 - (_BYTE *)*v12) >> 3);
            v20 = v19 + 1;
            if (v19 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            if (0x5555555555555556 * ((uint64_t)(*v14 - (_QWORD)*v12) >> 3) > v20)
              v20 = 0x5555555555555556 * ((uint64_t)(*v14 - (_QWORD)*v12) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v14 - (_QWORD)*v12) >> 3) >= 0x555555555555555)
              v21 = 0xAAAAAAAAAAAAAAALL;
            else
              v21 = v20;
            if (v21)
              v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>((uint64_t)v14, v21);
            else
              v22 = 0;
            v23 = &v22[24 * v19];
            v24 = v31;
            *((_QWORD *)v23 + 2) = v32;
            *(_OWORD *)v23 = v24;
            v25 = (char *)*v13;
            v26 = (char *)*v12;
            v27 = v23;
            if (*v13 != *v12)
            {
              do
              {
                v28 = *(_OWORD *)(v25 - 24);
                *((_QWORD *)v27 - 1) = *((_QWORD *)v25 - 1);
                *(_OWORD *)(v27 - 24) = v28;
                v27 -= 24;
                v25 -= 24;
              }
              while (v25 != v26);
              v25 = (char *)*v12;
            }
            *v12 = v27;
            v18 = v23 + 24;
            *v13 = v23 + 24;
            *v14 = &v22[24 * v21];
            if (v25)
              operator delete(v25);
          }
          else
          {
            v17 = v31;
            *((_QWORD *)v16 + 2) = v32;
            *(_OWORD *)v16 = v17;
            v18 = v16 + 24;
          }
          *v13 = v18;
          v10 = (__int128 *)((char *)v10 + 24);
        }
        while (v10 != v9);
      }
      v3 += 3;
    }
    while (v3 != v29);
  }
}

uint64_t PMClip::hintTokensWillImage(uint64_t a1, __int128 **a2, uint64_t a3)
{
  PCMutex *v6;
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t *, uint64_t, _QWORD);
  uint64_t v8;
  CMTime v10;
  uint64_t v11[4];
  char v12;

  v6 = (PCMutex *)(a1 + 1256);
  v11[3] = a1 + 1256;
  PCMutex::lock((PCMutex *)(a1 + 1256));
  v12 = 1;
  if (*(_QWORD *)a1 && *(_DWORD *)(a1 + 1244))
  {
    memset(v11, 0, 24);
    v10 = *(CMTime *)(a1 + 320);
    transformTokenTimes(a2, v11, &v10);
    if (*(_QWORD *)a1
      && (v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)a1 + 152)) != 0)
    {
      v8 = v7(a1, a1 + 1224, v11, a3, *(_QWORD *)(a1 + 1216));
    }
    else
    {
      v8 = 0;
    }
    v10.value = (CMTimeValue)v11;
    std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v10);
  }
  else
  {
    v8 = 6;
  }
  PCMutex::unlock(v6);
  return v8;
}

void sub_1B302AFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15)
{
  a9 = (void **)&a12;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t PMClip::getTokensImage(uint64_t a1, __int128 **a2, uint64_t a3)
{
  PCMutex *v6;
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t *, uint64_t, _QWORD);
  uint64_t v8;
  CMTime v10;
  uint64_t v11[4];
  char v12;

  v6 = (PCMutex *)(a1 + 1256);
  v11[3] = a1 + 1256;
  PCMutex::lock((PCMutex *)(a1 + 1256));
  v12 = 1;
  if (*(_QWORD *)a1 && *(_DWORD *)(a1 + 1244))
  {
    memset(v11, 0, 24);
    v10 = *(CMTime *)(a1 + 320);
    transformTokenTimes(a2, v11, &v10);
    if (*(_QWORD *)a1
      && (v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)a1 + 160)) != 0)
    {
      v8 = v7(a1, a1 + 1224, v11, a3, *(_QWORD *)(a1 + 1216));
    }
    else
    {
      v8 = 0;
    }
    v10.value = (CMTimeValue)v11;
    std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v10);
  }
  else
  {
    v8 = 6;
  }
  PCMutex::unlock(v6);
  return v8;
}

void sub_1B302B0B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15)
{
  a9 = (void **)&a12;
  std::vector<std::pair<CMTime,std::vector<CMTime>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t PMClip::pruneTokensAtTime(PMClip *this, const CMTime *a2, const char *a3)
{
  PCMutex *v6;
  uint64_t (*v7)(PMClip *, char *, __int128 *, const char *, _QWORD);
  uint64_t v8;
  __int128 v10;
  CMTimeEpoch epoch;
  char *v12;
  char v13;

  v6 = (PCMutex *)((char *)this + 1256);
  v12 = (char *)this + 1256;
  PCMutex::lock((PCMutex *)((char *)this + 1256));
  v13 = 1;
  if (*(_QWORD *)this && *((_DWORD *)this + 311))
  {
    v7 = *(uint64_t (**)(PMClip *, char *, __int128 *, const char *, _QWORD))(*(_QWORD *)this + 168);
    if (v7)
    {
      v10 = *(_OWORD *)&a2->value;
      epoch = a2->epoch;
      v8 = v7(this, (char *)this + 1224, &v10, a3, *((_QWORD *)this + 152));
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = 6;
  }
  PCMutex::unlock(v6);
  return v8;
}

void sub_1B302B188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PMClip::pruneTokensExceptAtTime(PMClip *this, const CMTime *a2, const char *a3)
{
  PCMutex *v6;
  uint64_t (*v7)(PMClip *, char *, __int128 *, const char *, _QWORD);
  uint64_t v8;
  __int128 v10;
  CMTimeEpoch epoch;
  char *v12;
  char v13;

  v6 = (PCMutex *)((char *)this + 1256);
  v12 = (char *)this + 1256;
  PCMutex::lock((PCMutex *)((char *)this + 1256));
  v13 = 1;
  if (*(_QWORD *)this && *((_DWORD *)this + 311))
  {
    v7 = *(uint64_t (**)(PMClip *, char *, __int128 *, const char *, _QWORD))(*(_QWORD *)this + 176);
    if (v7)
    {
      v10 = *(_OWORD *)&a2->value;
      epoch = a2->epoch;
      v8 = v7(this, (char *)this + 1224, &v10, a3, *((_QWORD *)this + 152));
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = 6;
  }
  PCMutex::unlock(v6);
  return v8;
}

void sub_1B302B24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PMClip::pruneAllTokens(PMClip *this, const char *a2)
{
  PCMutex *v4;
  uint64_t (*v5)(PMClip *, char *, const char *, _QWORD);
  uint64_t v6;

  v4 = (PCMutex *)((char *)this + 1256);
  PCMutex::lock((PCMutex *)((char *)this + 1256));
  if (*(_QWORD *)this && *((_DWORD *)this + 311))
  {
    v5 = *(uint64_t (**)(PMClip *, char *, const char *, _QWORD))(*(_QWORD *)this + 184);
    if (v5)
      v6 = v5(this, (char *)this + 1224, a2, *((_QWORD *)this + 152));
    else
      v6 = 0;
  }
  else
  {
    v6 = 6;
  }
  PCMutex::unlock(v4);
  return v6;
}

void sub_1B302B2F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t PMClip::getDynamicRangeType(PMClip *this)
{
  int v1;
  CGColorSpace *v5;

  v1 = *((_DWORD *)this + 117);
  if (v1 == 8 || v1 == 18)
    return 1;
  if (v1 == 16)
    return 2;
  v5 = (CGColorSpace *)*((_QWORD *)this + 60);
  if (v5)
  {
    if (!CGColorSpaceIsHLGBased(v5))
    {
      if (CGColorSpaceIsPQBased(*((CGColorSpaceRef *)this + 60)))
        return 2;
      return 0;
    }
    return 1;
  }
  return 0;
}

uint64_t PMClip::getFrame(uint64_t a1, CMTime *a2, uint64_t a3, PMFrameRequest *a4, uint64_t a5, HGNode **a6, uint64_t a7)
{
  PCMutex *v13;
  uint64_t v14;
  double v15;
  PCURL *URLforIndex;
  float v17;
  int v18;
  uint64_t FrameNonCached;
  uint64_t v20;

  v13 = (PCMutex *)(a1 + 1256);
  PCMutex::lock((PCMutex *)(a1 + 1256));
  if (*(_QWORD *)a1 && *(_DWORD *)(a1 + 1244))
  {
    if (*(_QWORD *)(*(_QWORD *)a1 + 80))
    {
      v15 = FigTimeToFrameWithRate(a2, ceil(*(double *)(a1 + 360) + -0.01));
      URLforIndex = (PCURL *)(a1 + 1224);
      if (*(_BYTE *)(a1 + 1240)
        && ((v17 = v15, *(_DWORD *)(a1 + 344) - 1 >= ((int)v17 & ~((int)v17 >> 31)))
          ? (v18 = (int)v17 & ~((int)v17 >> 31))
          : (v18 = *(_DWORD *)(a1 + 344) - 1),
            (URLforIndex = PCURL::getURLforIndex((const __CFURL **)(a1 + 1224), v18)) == 0))
      {
        FrameNonCached = 11;
      }
      else
      {
        FrameNonCached = PMClip::getFrameNonCached((_QWORD *)a1, (__int128 *)&a2->value, v14, a4, (uint64_t)URLforIndex, a5, a6, a7);
        if (*(_BYTE *)(a1 + 1240))
        {
          PCURL::~PCURL(URLforIndex);
          MEMORY[0x1B5E29170](v20, 0x60C4044C4A2DFLL);
        }
      }
    }
    else
    {
      FrameNonCached = 1;
    }
  }
  else
  {
    FrameNonCached = 6;
  }
  PCMutex::unlock(v13);
  return FrameNonCached;
}

void sub_1B302B4B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t PMClip::getFrameNonCached(_QWORD *a1, __int128 *a2, uint64_t a3, PMFrameRequest *a4, uint64_t a5, uint64_t a6, HGNode **a7, uint64_t a8)
{
  int v15;
  uint64_t v16;
  HGNode *v17;
  HGNode *v18;
  int v19;
  HGNode *v20;
  HGNode *v21;
  int v22;
  int v23;
  HGNode *v24;
  HGNode *v25;
  uint64_t (*v26)(_QWORD *, uint64_t, CMTime *, CMTime *, uint64_t, CMTime *, uint64_t, _QWORD, double);
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CMTime v36;
  CMTime v37[4];
  int v38;
  CGColorSpace *v39;
  CGColorSpace *v40;
  CMTime v41;
  CMTime v42;
  CMTime v43;
  CMTime v44;
  CMTime v45;
  CMTime v46;
  CMTime v47;
  CMTime time2;
  CMTime time1;

  v44 = *(CMTime *)(a1 + 40);
  memset(&v43, 0, sizeof(v43));
  v42 = *(CMTime *)(a1 + 40);
  PC_CMTimeHalve(&v42, (uint64_t)&v43);
  memset(&v41, 0, sizeof(v41));
  v37[0] = *(CMTime *)a2;
  time1 = v44;
  PC_CMTimeFloorToSampleDuration(v37, &time1, (uint64_t)&v41);
  PMFrameRequest::PMFrameRequest((uint64_t)v37, (uint64_t)a4);
  if ((int)PMFrameRequest::getResolutionMode(a4) > 0)
  {
    v15 = 0;
LABEL_3:
    v38 = v15;
    goto LABEL_4;
  }
  if (v38 == 2)
  {
    memset(&v36, 0, sizeof(v36));
    operator/(a2, (uint64_t)&v44, (uint64_t)&v36);
    CMTimeMake(&v45, 1, 1);
    time1 = v36;
    time2 = v45;
    PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v46);
    time1 = v36;
    time2 = v46;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v47);
    operator*((__int128 *)&v47.value, (uint64_t)&v44, (uint64_t)&time1);
    v36 = time1;
    time2 = v43;
    if (CMTimeCompare(&time1, &time2) < 0)
      goto LABEL_4;
    v15 = 1;
    goto LABEL_3;
  }
  if (v38 == 1)
  {
    memset(&v36, 0, sizeof(v36));
    operator/(a2, (uint64_t)&v44, (uint64_t)&v36);
    CMTimeMake(&v45, 1, 1);
    time1 = v36;
    time2 = v45;
    PC_CMTimeFloorToSampleDuration(&time1, &time2, (uint64_t)&v46);
    time1 = v36;
    time2 = v46;
    PC_CMTimeSaferSubtract(&time1, &time2, (uint64_t)&v47);
    operator*((__int128 *)&v47.value, (uint64_t)&v44, (uint64_t)&time1);
    v36 = time1;
    time2 = v43;
    if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
    {
      v15 = 2;
      goto LABEL_3;
    }
  }
LABEL_4:
  if (!*((_DWORD *)a1 + 100) || (int)PMFrameRequest::getResolutionMode(a4) >= 1)
  {
    v16 = (*(uint64_t (**)(_QWORD *, uint64_t, CMTime *, CMTime *, uint64_t, HGNode **, uint64_t, _QWORD))(*a1 + 80))(a1, a5, &v41, v37, a6, a7, a8, a1[152]);
    if ((_DWORD)v16)
    {
      v17 = (HGNode *)HGObject::operator new(0x1A0uLL);
      HGNode::HGNode(v17);
      v18 = *a7;
      if (*a7 != v17)
      {
        if (!v18)
        {
LABEL_10:
          *a7 = v17;
          goto LABEL_60;
        }
LABEL_9:
        (*(void (**)(HGNode *))(*(_QWORD *)v18 + 24))(v18);
        goto LABEL_10;
      }
      if (!v17)
        goto LABEL_60;
      goto LABEL_31;
    }
    v19 = v38;
    if (v38)
    {
      v20 = (HGNode *)HGObject::operator new(0x1B0uLL);
      PMStripField::PMStripField(v20, v19 == 1);
      (*(void (**)(HGNode *, _QWORD, HGNode *))(*(_QWORD *)v20 + 120))(v20, 0, *a7);
      v21 = *a7;
      if (*a7 != v20)
      {
        if (v21)
          (*(void (**)(HGNode *))(*(_QWORD *)v21 + 24))(v21);
        *a7 = v20;
        (*(void (**)(HGNode *))(*(_QWORD *)v20 + 16))(v20);
      }
      (*(void (**)(HGNode *))(*(_QWORD *)v20 + 24))(v20);
    }
    v16 = 0;
    goto LABEL_22;
  }
  if (v38)
  {
    v46 = v41;
    if (*((_DWORD *)a1 + 100) != v38)
    {
      time2 = v41;
      v47 = v43;
      PC_CMTimeSaferAdd(&time2, &v47, (uint64_t)&time1);
      v46 = time1;
    }
    v16 = (*(uint64_t (**)(_QWORD *, uint64_t, CMTime *, CMTime *, uint64_t, HGNode **, uint64_t, _QWORD))(*a1 + 80))(a1, a5, &v46, v37, a6, a7, a8, a1[152]);
    if ((_DWORD)v16)
    {
      v17 = (HGNode *)HGObject::operator new(0x1A0uLL);
      HGNode::HGNode(v17);
      v18 = *a7;
      if (*a7 != v17)
      {
        if (!v18)
          goto LABEL_10;
        goto LABEL_9;
      }
      if (!v17)
        goto LABEL_60;
LABEL_31:
      (*(void (**)(HGNode *))(*(_QWORD *)v17 + 24))(v17);
      goto LABEL_60;
    }
LABEL_22:
    *((_BYTE *)a1 + 1249) = 0;
    goto LABEL_60;
  }
  v46.value = 0;
  v45.value = 0;
  if (*((_DWORD *)a1 + 100) == 2)
    v22 = 2;
  else
    v22 = 1;
  if (*((_DWORD *)a1 + 100) == 2)
    v23 = 1;
  else
    v23 = 2;
  v38 = v22;
  v16 = (*(uint64_t (**)(_QWORD *, uint64_t, CMTime *, CMTime *, uint64_t, CMTime *, uint64_t, _QWORD))(*a1 + 80))(a1, a5, &v41, v37, a6, &v46, a8, a1[152]);
  if ((_DWORD)v16)
  {
    v24 = (HGNode *)HGObject::operator new(0x1A0uLL);
    HGNode::HGNode(v24);
    v25 = *a7;
    if (*a7 != v24)
    {
      if (v25)
        goto LABEL_49;
      goto LABEL_50;
    }
    if (!v24)
      goto LABEL_56;
LABEL_55:
    (*(void (**)(HGNode *))(*(_QWORD *)v24 + 24))(v24);
    goto LABEL_56;
  }
  v38 = v23;
  v26 = *(uint64_t (**)(_QWORD *, uint64_t, CMTime *, CMTime *, uint64_t, CMTime *, uint64_t, _QWORD, double))(*a1 + 80);
  time1 = v41;
  time2 = v43;
  v27 = PC_CMTimeSaferAdd(&time1, &time2, (uint64_t)&v47);
  v16 = v26(a1, a5, &v47, v37, a6, &v45, a8, a1[152], v27);
  if (!(_DWORD)v16)
  {
    PCPrint("File %s, line %d should not have been reached:\n\t", v28, v29, v30, v31, v32, v33, v34, (char)"/Library/Caches/com.apple.xbs/Sources/MotioniOS/ProMedia/PMClip.mm");
    pcAbortImpl();
  }
  v24 = (HGNode *)HGObject::operator new(0x1A0uLL);
  HGNode::HGNode(v24);
  v25 = *a7;
  if (*a7 == v24)
  {
    if (!v24)
      goto LABEL_56;
    goto LABEL_55;
  }
  if (v25)
LABEL_49:
    (*(void (**)(HGNode *))(*(_QWORD *)v25 + 24))(v25);
LABEL_50:
  *a7 = v24;
LABEL_56:
  if (v45.value)
    (*(void (**)(CMTimeValue))(*(_QWORD *)v45.value + 24))(v45.value);
  if (v46.value)
    (*(void (**)(CMTimeValue))(*(_QWORD *)v46.value + 24))(v46.value);
LABEL_60:
  PCCFRef<CGColorSpace *>::~PCCFRef(&v40);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v39);
  return v16;
}

void sub_1B302BB78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,CGColorSpace *a39,CGColorSpace *a40)
{
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  uint64_t v44;

  if (v40)
    (*(void (**)(uint64_t))(*(_QWORD *)v40 + 24))(v40);
  v43 = *(_QWORD *)(v41 - 232);
  if (v43)
    (*(void (**)(uint64_t))(*(_QWORD *)v43 + 24))(v43);
  v44 = *(_QWORD *)(v41 - 208);
  if (v44)
    (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a40);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a39);
  _Unwind_Resume(a1);
}

double PMClip::setFrameRate(PMClip *this, double a2)
{
  double v4;
  int32_t v5;
  double result;
  CMTime v7;

  v4 = a2 + 0.5 + 0.0000001;
  *((double *)this + 45) = a2;
  v5 = 10000 * vcvtmd_s64_f64(v4);
  LODWORD(v4) = *((_DWORD *)this + 86);
  PC_CMTimeMakeWithSecondsRoundToNearest(v5, &v7, (double)*(unint64_t *)&v4 / a2);
  *(CMTime *)((char *)this + 296) = v7;
  PC_CMTimeMakeWithSecondsRoundToNearest(v5, &v7, 1.0 / a2);
  result = *(double *)&v7.value;
  *(CMTime *)((char *)this + 320) = v7;
  return result;
}

CGColorSpace **PMClip::guessAlphaFormat(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _BYTE *a5)
{
  __int128 v10;
  CGColorSpace *v11;
  CGColorSpace *obj;
  CGColorSpace **result;
  PCURL *URLforIndex;
  int isSequence;
  char v16;
  PCColor v17;

  *a3 = 0;
  PCColor::PCColor(&v17);
  v10 = *(_OWORD *)&v17.var0.var1[1];
  *(_OWORD *)a4 = *(_OWORD *)&v17.var0.var0;
  *(_OWORD *)(a4 + 16) = v10;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v17.var0.var1[3];
  v11 = *(CGColorSpace **)(a4 + 48);
  obj = v17.var1._obj;
  if (v11 && v11 != v17.var1._obj)
  {
    PCCFRefTraits<CGColorSpace *>::release(v11);
    obj = v17.var1._obj;
  }
  *(_QWORD *)(a4 + 48) = obj;
  v17.var1._obj = 0;
  result = PCCFRef<CGColorSpace *>::~PCCFRef(&v17.var1._obj);
  *a5 = 0;
  if (*(_DWORD *)(a1 + 392) && *(_QWORD *)(*(_QWORD *)a1 + 40))
  {
    URLforIndex = (PCURL *)(a1 + 1224);
    isSequence = PCURL::isSequence((const __CFURL **)(a1 + 1224));
    if (isSequence)
      URLforIndex = PCURL::getURLforIndex((const __CFURL **)(a1 + 1224), 0);
    result = (CGColorSpace **)(*(uint64_t (**)(uint64_t, PCURL *, uint64_t, _DWORD *, _BYTE *, _QWORD))(*(_QWORD *)a1 + 40))(a1, URLforIndex, a2, a3, a5, *(_QWORD *)(a1 + 1216));
    if (!(_DWORD)result)
      *(_BYTE *)(a1 + 453) = *a3 == 2;
    v16 = isSequence ^ 1;
    if (!URLforIndex)
      v16 = 1;
    if ((v16 & 1) == 0)
    {
      PCURL::~PCURL(URLforIndex);
      return (CGColorSpace **)MEMORY[0x1B5E29170]();
    }
  }
  return result;
}

void sub_1B302BEB0(_Unwind_Exception *a1)
{
  CGColorSpace **v1;

  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

uint64_t PMClip::setAlphaFormat(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  PCURL *URLforIndex;
  int isSequence;
  char v11;

  if (*(_DWORD *)(result + 392))
  {
    v5 = result;
    if (*(_QWORD *)(*(_QWORD *)result + 48))
    {
      URLforIndex = (PCURL *)(result + 1224);
      isSequence = PCURL::isSequence((const __CFURL **)(result + 1224));
      if (isSequence)
        URLforIndex = PCURL::getURLforIndex((const __CFURL **)(v5 + 1224), 0);
      result = (*(uint64_t (**)(uint64_t, PCURL *, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v5 + 48))(v5, URLforIndex, a2, a3, a5, *(_QWORD *)(v5 + 1216));
      v11 = isSequence ^ 1;
      if (!URLforIndex)
        v11 = 1;
      if ((v11 & 1) == 0)
      {
        PCURL::~PCURL(URLforIndex);
        JUMPOUT(0x1B5E29170);
      }
    }
  }
  return result;
}

void PMFormatDescription::~PMFormatDescription(PMFormatDescription *this)
{
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 140);
  PCString::~PCString((PCString *)this + 137);
  PMAudioDescription::~PMAudioDescription((PCString *)this + 65);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 60);
  PCString::~PCString((PCString *)this + 57);
}

void PMAudioDescription::~PMAudioDescription(PCString *this)
{
  PCString *v2;

  v2 = this + 11;
  std::vector<PMAudioChannelDescription>::__destroy_vector::operator()[abi:ne180100]((void ***)&v2);
  PCString::~PCString(this + 7);
  PCString::~PCString(this);
}

void std::vector<PMAudioChannelDescription>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  PCString *v2;
  PCString *v4;
  void *v5;

  v1 = *a1;
  v2 = (PCString *)**a1;
  if (v2)
  {
    v4 = (PCString *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        PCString::~PCString(v4 - 2);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::pair<CMTime,std::vector<CMTime>>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::pair<CMTime,std::vector<CMTime>>>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 48 * a2;
    while (v3 != v7)
    {
      v8 = *(void **)(v3 - 24);
      if (v8)
      {
        *(_QWORD *)(v3 - 16) = v8;
        operator delete(v8);
      }
      v3 -= 48;
    }
    a1[1] = v7;
  }
}

void std::vector<std::pair<CMTime,std::vector<CMTime>>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4) >= a2)
  {
    if (a2)
    {
      v13 = 48 * ((48 * a2 - 48) / 0x30) + 48;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 4);
    v9 = v8 + a2;
    if (v8 + a2 > 0x555555555555555)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 4);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x2AAAAAAAAAAAAAALL)
      v11 = 0x555555555555555;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HGBinding>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[48 * v8];
    v18 = &v12[48 * v11];
    v14 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<std::pair<CMTime,std::vector<CMTime>>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::pair<CMTime,std::vector<CMTime>>>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_1B302C26C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<CMTime,std::vector<CMTime>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<CMTime,std::vector<CMTime>>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<CMTime,std::vector<CMTime>>>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<CMTime,std::vector<CMTime>>>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_QWORD *)(a3 - 32);
      *(_OWORD *)(v7 - 48) = *(_OWORD *)(a3 - 48);
      *(_QWORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 - 8);
      *(_QWORD *)(a3 - 24) = 0;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 48;
      *((_QWORD *)&v14 + 1) -= 48;
      a3 -= 48;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<CMTime,std::vector<CMTime>>>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<CMTime,std::vector<CMTime>>>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<CMTime,std::vector<CMTime>>>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<CMTime,std::vector<CMTime>>>,std::reverse_iterator<std::pair<CMTime,std::vector<CMTime>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 24);
    if (v3)
    {
      *(_QWORD *)(v1 + 32) = v3;
      operator delete(v3);
    }
    v1 += 48;
  }
}

uint64_t std::__split_buffer<std::pair<CMTime,std::vector<CMTime>>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::pair<CMTime,std::vector<CMTime>>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::pair<CMTime,std::vector<CMTime>>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 48;
    v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 48;
    }
  }
}

void std::vector<PMLayerDescription>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  PCString *v2;
  PCString *v4;
  void *v5;
  PCString *v6;

  v1 = *a1;
  v2 = (PCString *)**a1;
  if (v2)
  {
    v4 = (PCString *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 6;
        PCString::~PCString(v4 - 1);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<PMAudioDescription>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  PCString *v2;
  PCString *v4;
  void *v5;

  v1 = *a1;
  v2 = (PCString *)**a1;
  if (v2)
  {
    v4 = (PCString *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        PMAudioDescription::~PMAudioDescription(v4 - 14);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::vector<PMLayerDescription>::__init_with_size[abi:ne180100]<PMLayerDescription*,PMLayerDescription*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::pair<CMTime,std::vector<CMTime>>>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMLayerDescription>,PMLayerDescription*,PMLayerDescription*,PMLayerDescription*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B302C5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<PMLayerDescription>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMLayerDescription>,PMLayerDescription*,PMLayerDescription*,PMLayerDescription*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      PMLayerDescription::PMLayerDescription((PMLayerDescription *)(a4 + v7), (const PCString *)(a2 + v7));
      v7 += 48;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1B302C670(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 8;
    do
    {
      PCString::~PCString((PCString *)(v4 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<PMAudioDescription>::__init_with_size[abi:ne180100]<PMAudioDescription*,PMAudioDescription*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<PMAudioDescription>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMAudioDescription>,PMAudioDescription*,PMAudioDescription*,PMAudioDescription*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B302C6F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<PMAudioDescription>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<PMAudioDescription>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x24924924924924ALL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[112 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMAudioDescription>,PMAudioDescription*,PMAudioDescription*,PMAudioDescription*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      PMAudioDescription::PMAudioDescription((PMAudioDescription *)(a4 + v7), (const PMAudioDescription *)(a2 + v7));
      v7 += 112;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1B302C7C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 112;
    do
    {
      PMAudioDescription::~PMAudioDescription((PCString *)(v4 + v2));
      v2 -= 112;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<PMLayerDescription>::__push_back_slow_path<PMLayerDescription const&>(uint64_t *a1, const PCString *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  PMLayerDescription *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x2AAAAAAAAAAAAAALL)
    v9 = 0x555555555555555;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HGBinding>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (PMLayerDescription *)&v10[48 * v4];
  v16 = &v10[48 * v9];
  PMLayerDescription::PMLayerDescription(v14, a2);
  v15 = (char *)v14 + 48;
  std::vector<PMLayerDescription>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<PMLayerDescription>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_1B302C8DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<PMLayerDescription>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<PMLayerDescription>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PMLayerDescription>,std::reverse_iterator<PMLayerDescription*>,std::reverse_iterator<PMLayerDescription*>,std::reverse_iterator<PMLayerDescription*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PMLayerDescription>,std::reverse_iterator<PMLayerDescription*>,std::reverse_iterator<PMLayerDescription*>,std::reverse_iterator<PMLayerDescription*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  PMLayerDescription *v12;

  v10 = 0;
  v11 = a7 - 48;
  while (a3 + v10 != a5)
  {
    v12 = (PMLayerDescription *)(v11 + v10);
    v10 -= 48;
    PMLayerDescription::PMLayerDescription(v12, (const PCString *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<PMLayerDescription>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 48;
    PCString::~PCString((PCString *)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<PMAudioDescription>::__push_back_slow_path<PMAudioDescription const&>(uint64_t *a1, const PMAudioDescription *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  PMAudioDescription *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x249249249249249)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x124924924924924)
    v9 = 0x249249249249249;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PSHeliumNode::TextureSpriteBatcher::Vertex>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (PMAudioDescription *)&v10[112 * v4];
  v16 = &v10[112 * v9];
  PMAudioDescription::PMAudioDescription(v14, a2);
  v15 = (char *)v14 + 112;
  std::vector<PMAudioDescription>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<PMAudioDescription>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_1B302CB50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<PMAudioDescription>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<PMAudioDescription>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PMAudioDescription>,std::reverse_iterator<PMAudioDescription*>,std::reverse_iterator<PMAudioDescription*>,std::reverse_iterator<PMAudioDescription*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<PMAudioDescription>,std::reverse_iterator<PMAudioDescription*>,std::reverse_iterator<PMAudioDescription*>,std::reverse_iterator<PMAudioDescription*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  PMAudioDescription *v12;

  v10 = 0;
  v11 = a7 - 112;
  while (a3 + v10 != a5)
  {
    v12 = (PMAudioDescription *)(v11 + v10);
    v10 -= 112;
    PMAudioDescription::PMAudioDescription(v12, (const PMAudioDescription *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<PMAudioDescription>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 112;
    PMAudioDescription::~PMAudioDescription((PCString *)(i - 112));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void PMMediaManager::PMMediaManager(PMMediaManager *this)
{
  PMMediaManager *v2;

  PCSingleton::PCSingleton(this, 0);
  *(_QWORD *)v2 = &off_1E65EC328;
  *((_QWORD *)v2 + 1) = (char *)v2 + 8;
  *((_QWORD *)v2 + 2) = (char *)v2 + 8;
  *((_QWORD *)v2 + 3) = 0;
  *((_QWORD *)this + 10) = initMyCoreGraphicsPlugin(v2);
  *((_QWORD *)this + 4) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
}

void sub_1B302CD0C(_Unwind_Exception *a1)
{
  PCSingleton *v1;
  _QWORD *v2;

  std::__list_imp<unsigned int>::clear(v2);
  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

void PMMediaManager::~PMMediaManager(PMMediaManager *this)
{
  _QWORD *v2;
  _QWORD *i;
  uint64_t v4;
  void (*v5)(_QWORD);

  *(_QWORD *)this = &off_1E65EC328;
  v2 = (_QWORD *)((char *)this + 8);
  for (i = (_QWORD *)*((_QWORD *)this + 2); i != v2; i = (_QWORD *)i[1])
  {
    v4 = i[2];
    v5 = *(void (**)(_QWORD))(v4 + 272);
    if (v5)
      v5(i[2]);
    MEMORY[0x1B5E29170](v4, 0x80C40B3C365DALL);
  }
  std::__list_imp<unsigned int>::clear(v2);
  std::__list_imp<unsigned int>::clear(v2);
  PCSingleton::~PCSingleton(this);
}

{
  PMMediaManager::~PMMediaManager(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t PMMediaManager::getInstance(PMMediaManager *this)
{
  if (PMMediaManager::getInstance(void)::once != -1)
    dispatch_once(&PMMediaManager::getInstance(void)::once, &__block_literal_global_89);
  return PMMediaManager::_instance;
}

void ___ZN14PMMediaManager11getInstanceEv_block_invoke()
{
  PMMediaManager *v0;

  v0 = (PMMediaManager *)operator new();
  PMMediaManager::PMMediaManager(v0);
  PMMediaManager::_instance = (uint64_t)v0;
}

void sub_1B302CE5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x10A1C40D109E33BLL);
  _Unwind_Resume(a1);
}

_QWORD *PMMediaManager::addPlugin(_QWORD *a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v5;

  result = operator new(0x18uLL);
  v5 = a1[1];
  result[1] = ++a1;
  result[2] = a2;
  *result = v5;
  *(_QWORD *)(v5 + 8) = result;
  *a1 = result;
  ++a1[2];
  return result;
}

uint64_t PMMediaManager::findReader(PMMediaManager *this, const __CFURL **a2)
{
  uint64_t i;
  int v4;
  char *v5;
  uint64_t v6;
  int v7;
  PCString v9;
  PCString v10;

  PCURL::getExtension(a2, (PCURL *)&v10);
  for (i = 0; i != 13; ++i)
  {
    PCString::PCString(&v9, dissallowExtensions[i]);
    v4 = PCString::caseInsensitiveCompare(&v10, &v9);
    PCString::~PCString(&v9);
    if (!v4)
    {
      v6 = 0;
      goto LABEL_10;
    }
  }
  if (objc_msgSend(CFSTR("public.jpeg"), "isEqualToString:", CFSTR("com.adobe.photoshop-image")))
  {
    v5 = (char *)this + 64;
  }
  else
  {
    v7 = objc_msgSend(CFSTR("public.jpeg"), "isEqualToString:", CFSTR("com.ilm.openexr-image"));
    v5 = (char *)this + 80;
    if (v7)
      v5 = (char *)this + 56;
  }
  v6 = *(_QWORD *)v5;
LABEL_10:
  PCString::~PCString(&v10);
  return v6;
}

void sub_1B302CF9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t PMMediaManager::open(PMMediaManager *this, const PCURL *a2, PMClip **a3, PMPluginInterface *a4)
{
  PMClip *v8;
  uint64_t v9;
  uint64_t v10;
  int isSequence;
  PCURL *URLforIndex;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[144];

  v16[143] = *MEMORY[0x1E0C80C00];
  PMFormatDescription::PMFormatDescription((PMFormatDescription *)v16);
  *a3 = 0;
  bzero(v16, 0x478uLL);
  if (a4)
  {
    v16[0] = a4;
LABEL_3:
    v8 = (PMClip *)operator new();
    PMClip::PMClip(v8, a2, (const PMFormatDescription *)v16);
    v9 = PMClip::open(v8);
    if ((_DWORD)v9)
    {
      PMClip::~PMClip(v8);
      MEMORY[0x1B5E29170](v10);
      v8 = 0;
    }
    *a3 = v8;
    goto LABEL_6;
  }
  isSequence = PCURL::isSequence((const __CFURL **)a2);
  URLforIndex = a2;
  if (isSequence)
    URLforIndex = PCURL::getURLforIndex((const __CFURL **)a2, 0);
  v16[0] = PMMediaManager::findReader(this, (const __CFURL **)URLforIndex);
  if (v16[0])
  {
    if (isSequence)
    {
      PCURL::~PCURL(URLforIndex);
      MEMORY[0x1B5E29170](v14);
    }
    goto LABEL_3;
  }
  if (isSequence)
  {
    PCURL::~PCURL(URLforIndex);
    MEMORY[0x1B5E29170](v15);
  }
  v9 = 1;
LABEL_6:
  PMFormatDescription::~PMFormatDescription((PMFormatDescription *)v16);
  return v9;
}

void sub_1B302D140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PMFormatDescription::~PMFormatDescription((PMFormatDescription *)&a9);
  _Unwind_Resume(a1);
}

uint64_t PMFrameRequest::getAlphaType(PMFrameRequest *this)
{
  if (*((_DWORD *)this + 23))
    return 1;
  else
    return *((unsigned int *)this + 42);
}

BOOL PMFrameRequest::getAlphaInvert(PMFrameRequest *this)
{
  return !*((_DWORD *)this + 23) && *((_BYTE *)this + 172) != 0;
}

uint64_t PMFrameRequest::setResolutionMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 164) = a2;
  return result;
}

uint64_t PMFrameRequest::getResolutionMode(PMFrameRequest *this)
{
  return *((unsigned int *)this + 41);
}

double PMFrameRequest::getResolutionModeScale(PMFrameRequest *this)
{
  int v1;
  double result;

  v1 = *((_DWORD *)this + 41);
  result = 1.0;
  if (v1 == 1)
    result = 0.5;
  if (v1 == 2)
    return 0.25;
  return result;
}

CGColorSpace **PMFrameRequest::setWorkingColorSpace(CGColorSpace **this, CGColorSpace *a2)
{
  return PCColorSpaceHandle::setColorSpace(this + 22, a2);
}

CGColorSpace **PMFrameRequest::setOverrideColorSpace(CGColorSpace **this, CGColorSpace *a2)
{
  return PCColorSpaceHandle::setColorSpace(this + 23, a2);
}

uint64_t PMFrameRequest::getOverrideColorSpace(PMFrameRequest *this)
{
  return PCColorSpaceHandle::getCGColorSpace((PMFrameRequest *)((char *)this + 184));
}

uint64_t PMFrameRequest::setConversionMethod(uint64_t result, char a2)
{
  *(_BYTE *)(result + 193) = a2;
  return result;
}

uint64_t PMFrameRequest::setPQPeakNits(uint64_t this, double a2)
{
  *(double *)(this + 200) = a2;
  return this;
}

void PMFrameRequest::getColorDescriptionOverrideToneMapMethod(PMFrameRequest *this, FxColorDescription *a2)
{
  if (*((_BYTE *)this + 192))
    PMGetToneMapMethodForConversion(*((unsigned __int8 *)this + 193), a2);
}

uint64_t PMFrameRequest::isDynamicRangeTrackingRender(PMFrameRequest *this)
{
  return *((unsigned __int8 *)this + 192);
}

double PMGetToneMapMethodForConversion(int a1, FxColorDescription *this)
{
  double result;

  *(_QWORD *)&result = 4;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      *(_QWORD *)&result = 3;
      break;
    case 2:
    case 4:
      goto LABEL_2;
    default:
      if (this)
        result = *(double *)FxColorDescription::getToneMapMethod(this);
      else
LABEL_2:
        result = 0.0;
      break;
  }
  return result;
}

uint64_t PMFrameRequest::isRenderForHDR_Deprecated(PMFrameRequest *this)
{
  return *((unsigned __int8 *)this + 208);
}

uint64_t PMFrameRequest::setRenderIsForHDR_Deprecated(uint64_t this, char a2)
{
  *(_BYTE *)(this + 208) = a2;
  return this;
}

uint64_t PMFrameRequest::setIsDynamicRangeTrackingRender(uint64_t this, char a2)
{
  *(_BYTE *)(this + 192) = a2;
  return this;
}

uint64_t PMFrameRequest::getStillImageInverseToneMapOperator_Deprecated(PMFrameRequest *this)
{
  return *((unsigned int *)this + 53);
}

uint64_t PMFrameRequest::setStillImageInverseToneMapOperator_Deprecated(uint64_t result, int a2)
{
  *(_DWORD *)(result + 212) = a2;
  return result;
}

__n128 PMFrameRequest::setCinematography(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 232) = *(_OWORD *)(a2 + 16);
  *(__n128 *)(a1 + 216) = result;
  return result;
}

void PMAudioDescription::PMAudioDescription(PMAudioDescription *this)
{
  uint64_t v2;
  uint64_t v3;

  PCSharedCount::PCSharedCount((PCSharedCount *)this);
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  v3 = MEMORY[0x1E0CA2E68];
  *(_OWORD *)(v2 + 24) = *MEMORY[0x1E0CA2E68];
  *(_QWORD *)(v2 + 40) = *(_QWORD *)(v3 + 16);
  *(_DWORD *)(v2 + 48) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(v2 + 56));
  *((_OWORD *)this + 4) = xmmword_1B3566250;
  *((_DWORD *)this + 20) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 11) = 0;
}

void sub_1B302D34C(_Unwind_Exception *a1)
{
  PCString *v1;

  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

void PMAudioDescription::PMAudioDescription(PMAudioDescription *this, const PMAudioDescription *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  int v7;

  PCString::PCString((PCString *)this, (const PCString *)a2);
  *(_QWORD *)(v4 + 8) = *((_QWORD *)a2 + 1);
  *(_QWORD *)(v4 + 16) = *((_QWORD *)a2 + 2);
  v5 = *(_OWORD *)((char *)a2 + 24);
  *(_QWORD *)(v4 + 40) = *((_QWORD *)a2 + 5);
  *(_OWORD *)(v4 + 24) = v5;
  *(_DWORD *)(v4 + 48) = *((_DWORD *)a2 + 12);
  PCString::PCString((PCString *)(v4 + 56), (const PCString *)a2 + 7);
  v6 = *((_OWORD *)a2 + 4);
  v7 = *((_DWORD *)a2 + 20);
  *((_QWORD *)this + 11) = 0;
  *((_OWORD *)this + 4) = v6;
  *((_DWORD *)this + 20) = v7;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  std::vector<PMAudioChannelDescription>::__init_with_size[abi:ne180100]<PMAudioChannelDescription*,PMAudioChannelDescription*>((_QWORD *)this + 11, *((_QWORD *)a2 + 11), *((_QWORD *)a2 + 12), (uint64_t)(*((_QWORD *)a2 + 12) - *((_QWORD *)a2 + 11)) >> 4);
}

void sub_1B302D3F8(_Unwind_Exception *a1)
{
  PCString *v1;
  PCString *v2;

  PCString::~PCString(v2);
  PCString::~PCString(v1);
  _Unwind_Resume(a1);
}

uint64_t PMAudioDescription::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  PCString::set((PCString *)a1, (const PCString *)a2);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  PCString::set((PCString *)(a1 + 56), (const PCString *)(a2 + 56));
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  if (a1 != a2)
    std::vector<PMAudioChannelDescription>::__assign_with_size[abi:ne180100]<PMAudioChannelDescription*,PMAudioChannelDescription*>(a1 + 88, *(PCString **)(a2 + 88), *(PCString **)(a2 + 96), (uint64_t)(*(_QWORD *)(a2 + 96) - *(_QWORD *)(a2 + 88)) >> 4);
  return a1;
}

void PMFormatDescription::PMFormatDescription(PMFormatDescription *this)
{
  *(_QWORD *)this = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 57);
  *((_QWORD *)this + 60) = 0;
  *((_QWORD *)this + 63) = 0;
  *((_QWORD *)this + 64) = 0;
  PMAudioDescription::PMAudioDescription((PMFormatDescription *)((char *)this + 520));
  *((_QWORD *)this + 79) = 0;
  *((_DWORD *)this + 160) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 137);
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_BYTE *)this + 644) = 0;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  *(_OWORD *)((char *)this + 744) = 0u;
  *(_OWORD *)((char *)this + 760) = 0u;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *(_OWORD *)((char *)this + 856) = 0u;
  *(_OWORD *)((char *)this + 872) = 0u;
  *(_OWORD *)((char *)this + 888) = 0u;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 920) = 0u;
  *(_OWORD *)((char *)this + 936) = 0u;
  *(_OWORD *)((char *)this + 952) = 0u;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *(_OWORD *)((char *)this + 1064) = 0u;
  *(_OWORD *)((char *)this + 1080) = 0u;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *(_OWORD *)((char *)this + 1128) = 0u;
}

void sub_1B302D5B4(_Unwind_Exception *a1)
{
  uint64_t v1;
  PCString *v2;
  PCString *v3;

  PMAudioDescription::~PMAudioDescription(v3);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + 480));
  PCString::~PCString(v2);
  _Unwind_Resume(a1);
}

void PMFormatDescription::PMFormatDescription(PMFormatDescription *this, const PMFormatDescription *a2)
{
  uint64_t v4;
  CGColorSpace *v5;
  uint64_t v6;
  CGColorSpace *v7;
  void *v8;
  void *v9;

  *(_QWORD *)this = *(_QWORD *)a2;
  memcpy((char *)this + 8, (char *)a2 + 8, 0x1C0uLL);
  PCString::PCString((PCString *)this + 57, (const PCString *)a2 + 57);
  v4 = *((_QWORD *)a2 + 58);
  *((_DWORD *)this + 118) = *((_DWORD *)a2 + 118);
  *((_QWORD *)this + 58) = v4;
  v5 = (CGColorSpace *)*((_QWORD *)a2 + 60);
  *((_QWORD *)this + 60) = v5;
  if (v5)
    PCCFRefTraits<CGColorSpace *>::retain(v5);
  *(_OWORD *)((char *)this + 488) = *(_OWORD *)((char *)a2 + 488);
  *((_QWORD *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  *((_DWORD *)this + 129) = *((_DWORD *)a2 + 129);
  PMAudioDescription::PMAudioDescription((PMFormatDescription *)((char *)this + 520), (const PMFormatDescription *)((char *)a2 + 520));
  *((_QWORD *)this + 79) = 0;
  *((_DWORD *)this + 160) = 0;
  *((_BYTE *)this + 644) = *((_BYTE *)a2 + 644);
  memcpy((char *)this + 648, (char *)a2 + 648, 0x1C0uLL);
  PCString::PCString((PCString *)this + 137, (const PCString *)a2 + 137);
  v6 = *((_QWORD *)a2 + 138);
  *((_DWORD *)this + 278) = *((_DWORD *)a2 + 278);
  *((_QWORD *)this + 138) = v6;
  v7 = (CGColorSpace *)*((_QWORD *)a2 + 140);
  *((_QWORD *)this + 140) = v7;
  if (v7)
    PCCFRefTraits<CGColorSpace *>::retain(v7);
  *(_OWORD *)((char *)this + 1128) = *(_OWORD *)((char *)a2 + 1128);
  if (*((_QWORD *)a2 + 63))
  {
    v8 = malloc_type_malloc(*((unsigned int *)a2 + 128), 0x390D2E3EuLL);
    *((_QWORD *)this + 63) = v8;
    memcpy(v8, *((const void **)a2 + 63), *((unsigned int *)a2 + 128));
    *((_DWORD *)this + 128) = *((_DWORD *)a2 + 128);
  }
  if (*((_QWORD *)a2 + 79))
  {
    v9 = malloc_type_malloc(*((unsigned int *)a2 + 160), 0xEAAFB5A8uLL);
    *((_QWORD *)this + 79) = v9;
    memcpy(v9, *((const void **)a2 + 79), *((unsigned int *)a2 + 160));
    *((_DWORD *)this + 160) = *((_DWORD *)a2 + 160);
  }
}

void sub_1B302D74C(_Unwind_Exception *a1)
{
  uint64_t v1;
  PCString *v2;
  PCString *v3;
  PCString *v4;

  PCString::~PCString(v4);
  PMAudioDescription::~PMAudioDescription(v3);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + 480));
  PCString::~PCString(v2);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<PMAudioChannelDescription>::__init_with_size[abi:ne180100]<PMAudioChannelDescription*,PMAudioChannelDescription*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMAudioChannelDescription>,PMAudioChannelDescription*,PMAudioChannelDescription*,PMAudioChannelDescription*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B302D808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<PMAudioChannelDescription>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMAudioChannelDescription>,PMAudioChannelDescription*,PMAudioChannelDescription*,PMAudioChannelDescription*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      PCString::PCString((PCString *)(a4 + v7), (const PCString *)(a2 + v7));
      *(_DWORD *)(v8 + 8) = *(_DWORD *)(a2 + v7 + 8);
      v7 += 16;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1B302D898(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 16;
    do
    {
      PCString::~PCString((PCString *)(v4 + v2));
      v2 -= 16;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<PMAudioChannelDescription>::__assign_with_size[abi:ne180100]<PMAudioChannelDescription*,PMAudioChannelDescription*>(uint64_t a1, PCString *a2, PCString *a3, unint64_t a4)
{
  uint64_t v8;
  PCString *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  PCString *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v8 = a1 + 16;
  v9 = *(PCString **)a1;
  if (a4 > (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4)
  {
    std::vector<PMAudioChannelDescription>::__vdeallocate((void **)a1);
    if (a4 >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
    v11 = v10 >> 3;
    if (v10 >> 3 <= a4)
      v11 = a4;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__vallocate[abi:ne180100]((_QWORD *)a1, v12);
    v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMAudioChannelDescription>,PMAudioChannelDescription*,PMAudioChannelDescription*,PMAudioChannelDescription*>(v8, (uint64_t)a2, (uint64_t)a3, *(_QWORD *)(a1 + 8));
    goto LABEL_11;
  }
  v14 = (uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 4;
  if (v14 < a4)
  {
    v15 = &a2[2 * v14];
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,PMAudioChannelDescription *,PMAudioChannelDescription *,PMAudioChannelDescription *,0>(a2, v15, v9);
    v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<PMAudioChannelDescription>,PMAudioChannelDescription*,PMAudioChannelDescription*,PMAudioChannelDescription*>(v8, (uint64_t)v15, (uint64_t)a3, *(_QWORD *)(a1 + 8));
LABEL_11:
    *(_QWORD *)(a1 + 8) = v13;
    return;
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,PMAudioChannelDescription *,PMAudioChannelDescription *,PMAudioChannelDescription *,0>(a2, a3, v9);
  v17 = v16;
  v18 = *(_QWORD *)(a1 + 8);
  if (v18 != v16)
  {
    do
      PCString::~PCString((PCString *)(v18 - 16));
    while (v18 != v17);
  }
  *(_QWORD *)(a1 + 8) = v17;
}

void sub_1B302D9E4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1B302D9EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<PMAudioChannelDescription>::__vdeallocate(void **a1)
{
  PCString *v1;
  PCString *v3;
  void *v4;

  v1 = (PCString *)*a1;
  if (*a1)
  {
    v3 = (PCString *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        PCString::~PCString(v3 - 2);
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

PCString *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,PMAudioChannelDescription *,PMAudioChannelDescription *,PMAudioChannelDescription *,0>(PCString *a1, PCString *a2, PCString *this)
{
  PCString *v4;
  PCString *v5;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    PCString::set(this, v4);
    LODWORD(this[1].var0) = v4[1].var0;
    this += 2;
    v4 += 2;
  }
  while (v4 != v5);
  return v5;
}

HGBitmapLoader *PMBitmapToHeliumNode@<X0>(PCBitmap **a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;

  v3 = 0;
  return LiHelium::createBitmapNode(a1, (unsigned int *)&v3, a2);
}

void PMStripField::PMStripField(HGNode *a1, int a2)
{
  uint64_t v3;

  HGNode::HGNode(a1);
  *(_QWORD *)v3 = off_1E65EC3F0;
  *(_DWORD *)(v3 + 408) = a2;
  *(_QWORD *)(v3 + 416) = 0;
}

void PMStripField::~PMStripField(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EC3F0;
  v2 = *((_QWORD *)this + 52);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  void *v1;

  PMStripField::~PMStripField(this);
  HGObject::operator delete(v1);
}

uint64_t PMStripField::GetOutput(PMStripField *this, HGRenderer *a2)
{
  int v4;
  HgcPMStripEvenField *v5;
  HgcPMStripEvenField *v6;
  HgcPMStripEvenField *v7;
  HgcPMStripEvenField **v8;
  uint64_t v9;
  HGNode *Input;

  v4 = *((_DWORD *)this + 102);
  v5 = (HgcPMStripEvenField *)HGObject::operator new(0x1A0uLL);
  v6 = v5;
  if (v4)
  {
    HgcPMStripEvenField::HgcPMStripEvenField(v5);
    v7 = (HgcPMStripEvenField *)*((_QWORD *)this + 52);
    if (v7 != v6)
    {
      v8 = (HgcPMStripEvenField **)((char *)this + 416);
      if (v7)
        goto LABEL_7;
      goto LABEL_8;
    }
    if (!v6)
      goto LABEL_9;
LABEL_11:
    (*(void (**)(HgcPMStripEvenField *))(*(_QWORD *)v6 + 24))(v6);
    goto LABEL_9;
  }
  HgcPMStripOddField::HgcPMStripOddField(v5);
  v7 = (HgcPMStripEvenField *)*((_QWORD *)this + 52);
  if (v7 == v6)
  {
    if (!v6)
      goto LABEL_9;
    goto LABEL_11;
  }
  v8 = (HgcPMStripEvenField **)((char *)this + 416);
  if (v7)
LABEL_7:
    (*(void (**)(HgcPMStripEvenField *))(*(_QWORD *)v7 + 24))(v7);
LABEL_8:
  *v8 = v6;
LABEL_9:
  v9 = *((_QWORD *)this + 52);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v9 + 120))(v9, 0, Input);
  return *((_QWORD *)this + 52);
}

void sub_1B302DC68(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void MyCGInstanceData::MyCGInstanceData(MyCGInstanceData *this)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;

  PMStillInstance::PMStillInstance(this);
  *(_QWORD *)v2 = &off_1E65EC658;
  *(_QWORD *)(v2 + 104) = 0;
  *(_QWORD *)(v2 + 112) = 0;
  *(_QWORD *)(v2 + 96) = 0;
  *(_DWORD *)(v2 + 120) = 1;
  v3 = MEMORY[0x1E0CA2E68];
  v4 = *MEMORY[0x1E0CA2E68];
  *(_OWORD *)(v2 + 128) = xmmword_1B3566270;
  *(_OWORD *)(v2 + 144) = v4;
  *(_QWORD *)(v2 + 160) = *(_QWORD *)(v3 + 16);
  *(_DWORD *)(v2 + 168) = 0;
  *(_BYTE *)(v2 + 172) = 0;
  *(_QWORD *)(v2 + 176) = 0;
  *(_QWORD *)(v2 + 184) = 0;
  PCColorDescription::PCColorDescription((PCColorDescription *)(v2 + 192));
  *((_BYTE *)this + 216) = 1;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_QWORD *)this + 32) = 0;
}

void sub_1B302DD54(_Unwind_Exception *a1)
{
  PMStillInstance *v1;
  uint64_t v2;

  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v2);
  PMStillInstance::~PMStillInstance(v1);
  _Unwind_Resume(a1);
}

void MyCGInstanceData::~MyCGInstanceData(MyCGInstanceData *this)
{
  __CVPixelBufferPool *v2;

  *(_QWORD *)this = &off_1E65EC658;
  v2 = (__CVPixelBufferPool *)*((_QWORD *)this + 32);
  if (v2)
  {
    CVPixelBufferPoolRelease(v2);
    *((_QWORD *)this + 32) = 0;
  }
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 29);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 28);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 24);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)this + 176);
  PMStillInstance::~PMStillInstance(this);
}

{
  MyCGInstanceData::~MyCGInstanceData(this);
  JUMPOUT(0x1B5E29170);
}

uint64_t MyCGInstanceData::open(FxColorDescription *this, const __CFURL **a2)
{
  uint64_t result;
  void *v5;
  void *v6;
  CGImage *v7;
  CGImage *v8;
  CGColorSpace *ColorSpace;
  CGColorSpace *v10;
  CGColorSpace *DeviceRGB;
  CGColorSpace *obj;
  CGColorSpace *v13;
  CGColorSpace *CGColorSpace;
  CGColorSpace *v15;
  CGColorSpace *v16;
  void *v17;
  const __CFData *v18;
  FxColorDescription v19;
  CGColorSpaceRef space;

  result = PMStillInstance::open((PMStillInstance *)this, a2);
  if (!(_DWORD)result)
  {
    v5 = (void *)MEMORY[0x1E0CEA638];
    PCURL::getAsFileSystemString(a2, (PCString *)&v19);
    v6 = (void *)objc_msgSend(v5, "imageWithContentsOfFile:", PCString::ns_str((PCString *)&v19));
    PCString::~PCString((PCString *)&v19);
    v7 = (CGImage *)objc_msgSend(v6, "CGImage");
    if (v7)
    {
      v8 = v7;
      ColorSpace = CGImageGetColorSpace(v7);
      if (ColorSpace)
      {
        v10 = ColorSpace;
        PCCFRefTraits<CGColorSpace *>::retain(ColorSpace);
        space = v10;
      }
      else
      {
        space = 0;
        DeviceRGB = CGColorSpaceCreateDeviceRGB();
        v19._pcColorDesc._colorSpaceRef._obj = DeviceRGB;
        if (space && space != DeviceRGB)
        {
          PCCFRefTraits<CGColorSpace *>::release(space);
          DeviceRGB = v19._pcColorDesc._colorSpaceRef._obj;
        }
        space = DeviceRGB;
        v19._pcColorDesc._colorSpaceRef._obj = 0;
        PCCFRef<CGColorSpace *>::~PCCFRef(&v19._pcColorDesc._colorSpaceRef._obj);
        v10 = space;
      }
      FxColorDescription::FxColorDescription(&v19, v10, (PCToneMapMethod *)&kPCNoToneMapMethod, 1);
      obj = this[6]._pcColorDesc._colorSpaceRef._obj;
      v13 = v19._pcColorDesc._colorSpaceRef._obj;
      if (obj && obj != v19._pcColorDesc._colorSpaceRef._obj)
      {
        PCCFRefTraits<CGColorSpace *>::release(obj);
        v13 = v19._pcColorDesc._colorSpaceRef._obj;
      }
      this[6]._pcColorDesc._colorSpaceRef._obj = v13;
      v19._pcColorDesc._colorSpaceRef._obj = 0;
      this[6]._pcColorDesc._dynamicRange = v19._pcColorDesc._dynamicRange;
      this[6]._pcColorDesc._toneMapMethod = v19._pcColorDesc._toneMapMethod;
      this[6]._isPremultiplied = v19._isPremultiplied;
      PCCFRef<CGColorSpace *>::~PCCFRef(&v19._pcColorDesc._colorSpaceRef._obj);
      CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace(this + 6);
      PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)&v19, CGColorSpace);
      v15 = this[7]._pcColorDesc._colorSpaceRef._obj;
      v16 = v19._pcColorDesc._colorSpaceRef._obj;
      if (v15 && v15 != v19._pcColorDesc._colorSpaceRef._obj)
      {
        PCCFRefTraits<CGColorSpace *>::release(v15);
        v16 = v19._pcColorDesc._colorSpaceRef._obj;
      }
      this[7]._pcColorDesc._colorSpaceRef._obj = v16;
      v19._pcColorDesc._colorSpaceRef._obj = 0;
      PCCFRef<CGColorSpace *>::~PCCFRef(&v19._pcColorDesc._colorSpaceRef._obj);
      v17 = (void *)MEMORY[0x1E0C99D50];
      PCURL::getAsFileSystemString(a2, (PCString *)&v19);
      v18 = (const __CFData *)objc_msgSend(v17, "dataWithContentsOfFile:", PCString::ns_str((PCString *)&v19));
      PCString::~PCString((PCString *)&v19);
      if (v18)
        *(_QWORD *)&this[3]._pcColorDesc._toneMapMethod._gain = CGImageSourceCreateWithData(v18, 0);
      LODWORD(this[7]._pcColorDesc._toneMapMethod._gain) = CGImageGetWidth(v8);
      *((_DWORD *)&this[7]._pcColorDesc._toneMapMethod + 2) = CGImageGetHeight(v8);
      LOBYTE(this[5]._pcColorDesc._toneMapMethod._type) = 1;
      PCCFRef<CGColorSpace *>::~PCCFRef(&space);
      return 0;
    }
    else
    {
      PMStillInstance::close((PMStillInstance *)this);
      return 3;
    }
  }
  return result;
}

void sub_1B302DFEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, uint64_t a11, uint64_t a12, uint64_t a13, CGColorSpace *a14)
{
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&a10);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a14);
  _Unwind_Resume(a1);
}

uint64_t MyCGInstanceData::isOpen(MyCGInstanceData *this)
{
  return *((unsigned __int8 *)this + 172);
}

void MyCGInstanceData::close(__CVBuffer **this)
{
  __CVBuffer *v2;
  __CVBuffer *v3;

  PMStillInstance::close((PMStillInstance *)this);
  v2 = this[31];
  if (v2)
  {
    CVPixelBufferRelease(v2);
    this[31] = 0;
  }
  v3 = this[14];
  if (v3)
  {
    CFRelease(v3);
    this[14] = 0;
  }
  *((_DWORD *)this + 42) = 0;
  *((_BYTE *)this + 172) = 0;
}

CGColorSpace *MyCGInstanceData::getNativeColorDescription@<X0>(MyCGInstanceData *this@<X0>, uint64_t a2@<X8>)
{
  CGColorSpace *result;

  result = (CGColorSpace *)*((_QWORD *)this + 24);
  *(_QWORD *)a2 = result;
  if (result)
    result = PCCFRefTraits<CGColorSpace *>::retain(result);
  *(_QWORD *)(a2 + 8) = *((_QWORD *)this + 25);
  *(_DWORD *)(a2 + 16) = *((_DWORD *)this + 52);
  *(_BYTE *)(a2 + 24) = *((_BYTE *)this + 216);
  return result;
}

uint64_t MyCGInstanceData::getAnimationInfo(MyCGInstanceData *this, const PCURL *a2)
{
  CGImageSource *v3;
  unsigned int Count;
  size_t v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  void *Value;
  void *v16;
  void *v17;
  float v18;
  void *v19;
  float v20;
  void *v21;
  void *v22;
  void *v23;
  float v24;
  void *v25;
  float v26;
  size_t v27;
  uint64_t result;
  int32_t v29;
  CMTime *p_time;
  Float64 v31;
  CMTimeEpoch epoch;
  CMTime v33;
  CMTime time;
  CMTime v35;
  CMTime v36;

  v3 = (CGImageSource *)*((_QWORD *)this + 14);
  if (!v3)
    return 1;
  Count = CGImageSourceGetCount(v3);
  *((_DWORD *)this + 30) = Count;
  if (Count < 2)
  {
    *((_QWORD *)this + 17) = 0x403E000000000000;
    memset(&v36, 0, sizeof(v36));
    CMTimeMakeWithSeconds(&v36, 0.0333333333, 0x40000);
    v33 = v36;
    v29 = (int)*((double *)this + 17);
    p_time = &v33;
  }
  else
  {
    v5 = 0;
    v6 = (const void *)*MEMORY[0x1E0CBCCE0];
    v7 = *MEMORY[0x1E0CBCCF8];
    v8 = *MEMORY[0x1E0CBCCD8];
    v9 = (const void *)*MEMORY[0x1E0CBD028];
    v10 = *MEMORY[0x1E0CBC820];
    v11 = 0.1;
    v12 = *MEMORY[0x1E0CBC810];
    while (1)
    {
      v13 = CGImageSourceCopyPropertiesAtIndex(*((CGImageSourceRef *)this + 14), v5, 0);
      if (!v13)
        break;
      v14 = v13;
      Value = (void *)CFDictionaryGetValue(v13, v6);
      if (Value)
      {
        v16 = Value;
        v17 = (void *)objc_msgSend(Value, "objectForKeyedSubscript:", v7);
        if (!v17 || (objc_msgSend(v17, "floatValue"), v11 = v18, v18 == 0.0))
        {
          v19 = (void *)objc_msgSend(v16, "objectForKeyedSubscript:", v8);
          if (v19)
          {
            objc_msgSend(v19, "floatValue");
            v11 = v20;
          }
        }
      }
      v21 = (void *)CFDictionaryGetValue(v14, v9);
      if (v21)
      {
        v22 = v21;
        v23 = (void *)objc_msgSend(v21, "objectForKeyedSubscript:", v10);
        if (!v23 || (objc_msgSend(v23, "floatValue"), v11 = v24, v24 == 0.0))
        {
          v25 = (void *)objc_msgSend(v22, "objectForKeyedSubscript:", v12);
          if (v25)
          {
            objc_msgSend(v25, "floatValue");
            v11 = v26;
          }
        }
      }
      if (v11 < 0.011)
        v11 = 0.1;
      *((double *)this + 16) = *((double *)this + 16) + v11;
      CFRelease(v14);
      ++v5;
      v27 = *((unsigned int *)this + 30);
      if (v5 >= v27)
        goto LABEL_22;
    }
    LODWORD(v27) = *((_DWORD *)this + 30);
LABEL_22:
    v31 = *((double *)this + 16) / (double)v27;
    *((double *)this + 17) = ceil(1.0 / v31 + -0.01);
    memset(&v36, 0, sizeof(v36));
    CMTimeMakeWithSeconds(&v36, v31, 0x40000);
    time = v36;
    v29 = (int)*((double *)this + 17);
    p_time = &time;
  }
  CMTimeConvertScale(&v35, p_time, v29, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  result = 0;
  epoch = v35.epoch;
  *((_OWORD *)this + 9) = *(_OWORD *)&v35.value;
  *((_QWORD *)this + 20) = epoch;
  return result;
}

CGImage *MyCGInstanceData::newPixelBufferFromImage(MyCGInstanceData *this, CGImageRef image, CGColorSpace **a3)
{
  CGImage *v3;
  size_t Width;
  size_t Height;
  size_t BitsPerComponent;
  CGColorSpace *ColorSpace;
  CGColorSpace *CGColorSpace;
  CGColorSpace *v11;
  CGColorSpace *v12;
  _BOOL4 v13;
  int v14;
  size_t v15;
  uint32_t v16;
  __CVPixelBufferPool *v17;
  size_t BytesPerRow;
  void *BaseAddress;
  CGContext *v20;
  __CFDictionary *Mutable;
  CFDictionaryRef v22;
  const __CFAllocator *v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CVPixelBufferPoolRef *v27;
  size_t v29;
  size_t v30;
  size_t v31;
  int valuePtr;
  CGColorSpace *v33;
  CGColorSpace *v34;
  CVPixelBufferRef pixelBufferOut;
  CGRect v36;
  CGRect v37;

  v3 = image;
  pixelBufferOut = 0;
  if (image)
  {
    Width = CGImageGetWidth(image);
    Height = CGImageGetHeight(v3);
    BitsPerComponent = CGImageGetBitsPerComponent(v3);
    ColorSpace = CGImageGetColorSpace(v3);
    PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)&v34, ColorSpace);
    CGColorSpace = (CGColorSpace *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v34);
    if (CGColorSpaceGetNumberOfComponents(CGColorSpace) == 1)
    {
      PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)&v33, (CFStringRef)*MEMORY[0x1E0C9DA10]);
      v11 = v33;
      if (v34 && v34 != v33)
      {
        PCCFRefTraits<CGColorSpace *>::release(v34);
        v11 = v33;
      }
      v33 = 0;
      v34 = v11;
      PCCFRef<CGColorSpace *>::~PCCFRef(&v33);
    }
    v12 = (CGColorSpace *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v34);
    PCColorSpaceHandle::setColorSpace(a3, v12);
    valuePtr = 1111970369;
    v13 = CGColorSpaceUsesExtendedRange(v12);
    v14 = BitsPerComponent > 8 || v13;
    if (v14)
      v15 = 16;
    else
      v15 = 8;
    if (v14 == 1)
    {
      valuePtr = 1380411457;
      v16 = 4353;
    }
    else
    {
      v16 = 8194;
    }
    v17 = (__CVPixelBufferPool *)*((_QWORD *)this + 32);
    if (!v17)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v30 = v15;
      v22 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA8FF0], v22);
      CFRelease(v22);
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA9028], (const void *)*MEMORY[0x1E0C9AE50]);
      v29 = Width;
      v33 = (CGColorSpace *)(Width + 2);
      v31 = Height + 2;
      v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v24 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
      v25 = CFNumberCreate(v23, kCFNumberLongType, &v33);
      v26 = CFNumberCreate(v23, kCFNumberLongType, &v31);
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA9040], v24);
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA90E0], v25);
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8FD8], v26);
      v27 = (CVPixelBufferPoolRef *)((char *)this + 256);
      LODWORD(v23) = CVPixelBufferPoolCreate(v23, 0, Mutable, v27);
      CFRelease(v24);
      CFRelease(v25);
      CFRelease(v26);
      CFRelease(Mutable);
      if ((_DWORD)v23)
        goto LABEL_20;
      v17 = *v27;
      Width = v29;
      v15 = v30;
    }
    if (!CVPixelBufferPoolCreatePixelBuffer(0, v17, &pixelBufferOut))
    {
      BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
      CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
      BaseAddress = CVPixelBufferGetBaseAddress(pixelBufferOut);
      v20 = CGBitmapContextCreate(BaseAddress, Width + 2, Height + 2, v15, BytesPerRow, v12, v16);
      v36.size.width = (double)(Width + 2);
      v36.size.height = (double)(Height + 2);
      v36.origin.x = 0.0;
      v36.origin.y = 0.0;
      CGContextClearRect(v20, v36);
      v37.size.width = (double)Width;
      v37.size.height = (double)Height;
      v37.origin.x = 1.0;
      v37.origin.y = 1.0;
      CGContextDrawImage(v20, v37, v3);
      CGContextRelease(v20);
      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
      v3 = pixelBufferOut;
LABEL_21:
      PCCFRef<CGColorSpace *>::~PCCFRef(&v34);
      return v3;
    }
LABEL_20:
    v3 = 0;
    goto LABEL_21;
  }
  return v3;
}

void sub_1B302E6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  CGColorSpace *v7;
  va_list va;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, CGColorSpace *);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

uint64_t MyCGInstanceData::getPixelBuffer(MyCGInstanceData *this, const PMFrameRequest *a2, FxColorDescription *a3)
{
  size_t v5;
  CGColorSpace *OverrideColorSpace;
  __CVBuffer *v7;
  CGImage *ImageAtIndex;
  CGColorSpace *CGColorSpace;
  CGColorSpace *obj;
  CGColorSpace *v11;
  FxColorDescription *v12;
  uint64_t v13;
  CGColorSpace *v15;
  CGColorSpace *v16;
  CGColorSpace *v17;
  FxColorDescription v18;
  CGColorSpace *v19;
  CGColorSpace *v20;

  v5 = *((unsigned int *)a2 + 25);
  OverrideColorSpace = (CGColorSpace *)PMFrameRequest::getOverrideColorSpace(a2);
  PCColorSpaceHandle::PCColorSpaceHandle((PCColorSpaceHandle *)&v20, OverrideColorSpace);
  v7 = (__CVBuffer *)*((_QWORD *)this + 31);
  if (!v7)
    goto LABEL_6;
  if ((_DWORD)v5 != *((_DWORD *)this + 42))
  {
LABEL_5:
    CVPixelBufferRelease(v7);
LABEL_6:
    ImageAtIndex = CGImageSourceCreateImageAtIndex(*((CGImageSourceRef *)this + 14), v5, 0);
    v19 = 0;
    *((_QWORD *)this + 31) = MyCGInstanceData::newPixelBufferFromImage(this, ImageAtIndex, &v19);
    CGImageRelease(ImageAtIndex);
    *((_DWORD *)this + 42) = v5;
    PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)this + 28, &v20);
    PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)this + 29, &v19);
    CGColorSpace = (CGColorSpace *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v19);
    FxColorDescription::FxColorDescription(&v18, (const FxColorDescription *)this + 6, CGColorSpace);
    obj = a3->_pcColorDesc._colorSpaceRef._obj;
    v11 = v18._pcColorDesc._colorSpaceRef._obj;
    if (a3->_pcColorDesc._colorSpaceRef._obj && obj != v18._pcColorDesc._colorSpaceRef._obj)
    {
      PCCFRefTraits<CGColorSpace *>::release(obj);
      v11 = v18._pcColorDesc._colorSpaceRef._obj;
    }
    a3->_pcColorDesc._colorSpaceRef._obj = v11;
    v18._pcColorDesc._colorSpaceRef._obj = 0;
    a3->_pcColorDesc._dynamicRange = v18._pcColorDesc._dynamicRange;
    a3->_pcColorDesc._toneMapMethod = v18._pcColorDesc._toneMapMethod;
    a3->_isPremultiplied = v18._isPremultiplied;
    PCCFRef<CGColorSpace *>::~PCCFRef(&v18._pcColorDesc._colorSpaceRef._obj);
    v12 = (FxColorDescription *)&v19;
    goto LABEL_10;
  }
  if (operator!=(&v20, (_QWORD *)this + 28))
  {
    v7 = (__CVBuffer *)*((_QWORD *)this + 31);
    if (!v7)
      goto LABEL_6;
    goto LABEL_5;
  }
  v15 = (CGColorSpace *)PCColorSpaceHandle::getCGColorSpace((MyCGInstanceData *)((char *)this + 232));
  FxColorDescription::FxColorDescription(&v18, (const FxColorDescription *)this + 6, v15);
  v16 = a3->_pcColorDesc._colorSpaceRef._obj;
  v17 = v18._pcColorDesc._colorSpaceRef._obj;
  if (a3->_pcColorDesc._colorSpaceRef._obj && v16 != v18._pcColorDesc._colorSpaceRef._obj)
  {
    PCCFRefTraits<CGColorSpace *>::release(v16);
    v17 = v18._pcColorDesc._colorSpaceRef._obj;
  }
  a3->_pcColorDesc._colorSpaceRef._obj = v17;
  v18._pcColorDesc._colorSpaceRef._obj = 0;
  a3->_pcColorDesc._dynamicRange = v18._pcColorDesc._dynamicRange;
  a3->_pcColorDesc._toneMapMethod = v18._pcColorDesc._toneMapMethod;
  a3->_isPremultiplied = v18._isPremultiplied;
  v12 = &v18;
LABEL_10:
  PCCFRef<CGColorSpace *>::~PCCFRef(&v12->_pcColorDesc._colorSpaceRef._obj);
  v13 = *((_QWORD *)this + 31);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v20);
  return v13;
}

void sub_1B302E8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CGColorSpace *a14)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(&a9);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a14);
  _Unwind_Resume(a1);
}

uint64_t MyCGInstanceData::readRawBitmap@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v3 = *(_QWORD *)(this + 176);
  if (v3)
  {
    v4 = *(_QWORD *)(this + 184);
    *a2 = v3;
    a2[1] = v4;
    if (v4)
    {
      v5 = (unint64_t *)(v4 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return this;
}

uint64_t MyCG_Open(const PMFormatDescription *a1, const PCURL *a2, MyCGInstanceData **a3)
{
  MyCGInstanceData *v5;
  PCURL *v6;
  uint64_t v7;

  v5 = (MyCGInstanceData *)operator new();
  MyCGInstanceData::MyCGInstanceData(v5);
  v6 = (PCURL *)operator new();
  PCURL::PCURL(v6, a2);
  *((_QWORD *)v5 + 13) = v6;
  v7 = (*(uint64_t (**)(MyCGInstanceData *, const PCURL *))(*(_QWORD *)v5 + 16))(v5, a2);
  if ((_DWORD)v7)
  {
    (*(void (**)(MyCGInstanceData *))(*(_QWORD *)v5 + 8))(v5);
    v5 = 0;
  }
  *a3 = v5;
  return v7;
}

void sub_1B302E9D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t MyCG_Create()
{
  return 10;
}

uint64_t MyCG_Close(const PMFormatDescription *a1, _QWORD *a2)
{
  PCURL *v3;

  v3 = (PCURL *)a2[13];
  if (v3)
  {
    PCURL::~PCURL(v3);
    MEMORY[0x1B5E29170]();
  }
  a2[13] = 0;
  (*(void (**)(_QWORD *))(*a2 + 24))(a2);
  (*(void (**)(_QWORD *))(*a2 + 8))(a2);
  return 0;
}

__n128 MyCG_GetInfo(PMFormatDescription *a1, const PCURL *a2, void *a3)
{
  CMTime *v5;
  const PCURL *v6;
  CGImageSource *v7;
  CFStringRef Type;
  char *CStr;
  CFDictionaryRef v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  char v17;
  __n128 result;
  char *v19;
  CMTimeEpoch epoch;
  __int128 v21;
  uint64_t v22;
  CMTime v23;
  CMTime v24;
  CMTime v25;

  if (a3)
  {
    v5 = (CMTime *)((char *)a1 + 8);
    *((_QWORD *)a1 + 36) = *((_QWORD *)a3 + 30);
    *((_QWORD *)a1 + 52) = 0x3FF0000000000000;
    *((double *)a1 + 53) = PCInfo::getWorkingGamma(a1);
    *((_QWORD *)a1 + 49) = 1;
    *((_DWORD *)a1 + 86) = 1;
    *((_QWORD *)a1 + 45) = 0x403E000000000000;
    CMTimeMake(&v25, 1, 30);
    v5[12] = v25;
    CMTimeMake(&v25, 1, (int)*((double *)a1 + 45));
    *(CMTime *)((char *)a1 + 320) = v25;
    *((_QWORD *)a1 + 47) = 0;
    strcpy((char *)a1 + 8, "Adobe Photoshop");
    *(_OWORD *)&v5[10].epoch = xmmword_1B3566280;
    *((_DWORD *)a1 + 111) = 3;
    *((_BYTE *)a1 + 450) = 1;
    *((_WORD *)a1 + 227) = 0;
    v7 = (CGImageSource *)*((_QWORD *)a3 + 14);
    if (v7)
    {
      Type = CGImageSourceGetType(v7);
      PCURL::PCURL((PCURL *)&v25, Type);
      CStr = PCString::createCStr((PCString *)&v25);
      if (CStr)
      {
        strcpy((char *)v5, CStr);
        free(CStr);
      }
      v10 = CGImageSourceCopyPropertiesAtIndex(*((CGImageSourceRef *)a3 + 14), 0, 0);
      v11 = objc_msgSend((id)-[__CFDictionary objectForKey:](v10, "objectForKey:", *MEMORY[0x1E0CBCA08]), "intValue");
      v12 = objc_msgSend((id)-[__CFDictionary objectForKey:](v10, "objectForKey:", *MEMORY[0x1E0CBCEA0]), "BOOLValue");
      v13 = objc_msgSend((id)-[__CFDictionary objectForKey:](v10, "objectForKey:", *MEMORY[0x1E0CBC8C8]), "caseInsensitiveCompare:", CFSTR("Gray"));
      if (v11 <= 8)
        v14 = 0;
      else
        v14 = 3;
      if (v11 <= 8)
        v15 = 3;
      else
        v15 = 16;
      if (v13)
      {
        if (v12)
        {
          if (v11 == 16)
            v16 = 64;
          else
            v16 = 32;
          v17 = 1;
        }
        else
        {
          v17 = 0;
          if (v11 == 16)
            v16 = 48;
          else
            v16 = 24;
        }
      }
      else
      {
        v17 = 0;
        if (v11 == 16)
          v16 = 41;
        else
          v16 = 40;
      }
      *((_DWORD *)a1 + 69) = v16;
      *((_DWORD *)a1 + 68) = v14;
      *((_DWORD *)a1 + 111) = v15;
      *((_BYTE *)a1 + 450) = v17;
      CFRelease(v10);
      PCString::~PCString((PCString *)&v25);
    }
    if (!MyCGInstanceData::getAnimationInfo((MyCGInstanceData *)a3, v6))
    {
      v19 = (char *)&v5[12];
      memset(&v25, 0, sizeof(v25));
      CMTimeMakeWithSeconds(&v25, *((Float64 *)a3 + 16), 1000000000);
      v23 = v25;
      CMTimeConvertScale(&v24, &v23, (int)*((double *)a3 + 17), kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      *((_DWORD *)a1 + 86) = *((_DWORD *)a3 + 30);
      epoch = v24.epoch;
      v25 = v24;
      v21 = *(_OWORD *)&v24.value;
      *((_QWORD *)a1 + 45) = *((_QWORD *)a3 + 17);
      *((_QWORD *)v19 + 2) = epoch;
      *(_OWORD *)v19 = v21;
      v22 = *((_QWORD *)a3 + 20);
      result = *((__n128 *)a3 + 9);
      *((__n128 *)a1 + 20) = result;
      *((_QWORD *)a1 + 42) = v22;
    }
  }
  return result;
}

void sub_1B302ED34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, PCString a15)
{
  PCString::~PCString(&a15);
  _Unwind_Resume(a1);
}

uint64_t MyCG_GetLayerDescription(const PMFormatDescription *a1, PMLayerDescription *a2, unsigned int a3, const PCURL *a4, _QWORD *a5)
{
  uint64_t result;

  if (!a5)
    return 10;
  result = 0;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = a5[30];
  *((_DWORD *)a2 + 5) = *((_DWORD *)a1 + 111);
  return result;
}

uint64_t MyCG_GetFrame(const PMFormatDescription *a1, CFTypeRef *a2, CMTime *a3, uint64_t a4, FxColorDescription *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  double v15;
  int v16;

  v15 = FigTimeToFrameWithRate(a3, *(double *)(a8 + 136));
  v16 = *(_DWORD *)(a8 + 120) - 1;
  if (v16 >= ((int)v15 & ~((int)v15 >> 31)))
    v16 = (int)v15 & ~((int)v15 >> 31);
  *(_DWORD *)(a4 + 100) = v16;
  return PMStillInstance::getFrame((PMStillInstance *)a8, a1, a2, a4, a5, a6, a7);
}

uint64_t MyCG_GetAlphaFormat(PMFormatDescription *a1, int a2, int a3, unsigned int *a4, char *a5, uint64_t **this)
{
  uint64_t v8;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  PCBitmap *v17;
  char v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  CGColorSpace *v27;
  PCBitmap *v28;
  std::__shared_weak_count *v29;
  char v30;
  unsigned int v31;
  PCBitmap *v32;
  std::__shared_weak_count *v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  int v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  char v55;
  CGColorSpace *v56;
  CGColorSpace *v57;
  __int16 v58;
  uint64_t v59;
  char v60;
  int v61;
  char v62;
  uint64_t v63;
  __int128 v64;

  v34 = xmmword_1B30503B0;
  v35 = 0x3FF0000000000000;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0x3FF0000000000000;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v47 = 0;
  v44 = 0;
  v45 = 0;
  v43 = 0x3FF0000000000000;
  v46 = 0;
  v8 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v48 = *MEMORY[0x1E0CA2E68];
  v49 = v8;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0x100000000;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 768;
  v59 = 0x408F400000000000;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = -1;
  __asm { FMOV            V0.2D, #1.0 }
  v64 = _Q0;
  HIDWORD(v44) = a3;
  PMStillInstance::getRawBitmap(this, a1, (const PMFrameRequest *)&v34, &v32);
  if (v32)
  {
    v31 = 0;
    v30 = 0;
    v14 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v32 + 8) + 48))(*((_QWORD *)v32 + 8));
    if (!PCPixelFormat::is8Bit(v14))
    {
      v15 = (*(uint64_t (**)(PCBitmap *))(*(_QWORD *)v32 + 16))(v32);
      v16 = (*(uint64_t (**)(PCBitmap *))(*(_QWORD *)v32 + 24))(v32);
      PCImage::getColorSpace((PCImage *)v32, &v27);
      PCCreateBitmap(v15, v16, 5, (PCColorSpaceHandle *)&v27, 1, (uint64_t)&v28);
      PCCFRef<CGColorSpace *>::~PCCFRef(&v27);
      v17 = v28;
      v18 = (*(uint64_t (**)(PCBitmap *))(*(_QWORD *)v32 + 48))(v32);
      PCImage::setIsPremultiplied((uint64_t)v17, v18);
      PCBitmap::copyWithColorSpaceConversion(v28, v32);
      std::shared_ptr<TXTextStyle>::operator=[abi:ne180100](&v32, (uint64_t *)&v28);
      v19 = v29;
      if (v29)
      {
        p_shared_owners = (unint64_t *)&v29->__shared_owners_;
        do
          v21 = __ldaxr(p_shared_owners);
        while (__stlxr(v21 - 1, p_shared_owners));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
    }
    switch((*(unsigned int (**)(_QWORD))(**((_QWORD **)v32 + 8) + 48))(*((_QWORD *)v32 + 8)))
    {
      case 3u:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      case 4u:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      case 5u:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      case 6u:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      case 0xAu:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      case 0xDu:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      case 0x10u:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      case 0x11u:
        PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>((uint64_t)v32, (int *)&v31, a5, &v30);
        break;
      default:
        break;
    }
    if (v31 <= 3)
      *a4 = v31;
    v22 = 0;
  }
  else
  {
    v22 = 1;
  }
  v23 = v33;
  if (v33)
  {
    v24 = (unint64_t *)&v33->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(&v57);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v56);
  return v22;
}

void sub_1B302F158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,CGColorSpace *a38)
{
  CGColorSpace **v38;

  PCCFRef<CGColorSpace *>::~PCCFRef(&a9);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a38);
  PCCFRef<CGColorSpace *>::~PCCFRef(v38);
  _Unwind_Resume(a1);
}

CGColorSpace **PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)3>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  CGColorSpace **result;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  int v15;
  unsigned int v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  int v20;
  int v21;
  int v22;
  char v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  _BOOL4 v30;
  _BOOL4 v32;
  int v33;
  int v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  float v38;
  int v39;
  char v40;
  BOOL v41;
  unsigned __int8 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  int v48;
  _BYTE *v49;
  unsigned int v50;
  _BOOL4 v51;
  unsigned int v52;
  unsigned int v53;
  float v54;
  float v55;
  unsigned int v56;
  float v57;
  unsigned int v58;
  float v59;
  float v60;
  float v61;
  float v62;
  char v63;
  _BOOL4 v64;
  _BYTE *v65;
  unsigned int v66;
  float v67;
  float v68;
  float v69;
  int v70;
  unsigned __int8 v71;
  char v72;
  _BOOL4 v73;
  char *v74;
  _BYTE *v75;
  PCImage *v76;
  uint64_t v77;
  float v79;
  uint64_t v80;
  OZChannelBase v81;

  result = (CGColorSpace **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v10 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = *(unsigned __int8 *)result;
    v23 = 1;
    v24 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
    do
    {
      v25 = *(unsigned __int8 *)result;
      v9 = *((unsigned __int8 *)result + 1);
      v8 = *((unsigned __int8 *)result + 2);
      v26 = *((unsigned __int8 *)result + 3);
      if (v25 == 255)
      {
        v30 = (_DWORD)v9 == v17 && (_DWORD)v8 == v18 && v26 == v19;
        v20 &= v30;
        if (!v16)
        {
          v20 = 1;
          v19 = *((_BYTE *)result + 3);
          v18 = *((_BYTE *)result + 2);
          v17 = *((_BYTE *)result + 1);
        }
        ++v16;
      }
      else if (!*(_BYTE *)result)
      {
        if (v11)
        {
          v9 = v9 - v12;
          if ((_DWORD)v9 || __PAIR64__(v26, v8) != __PAIR64__(v14, v13))
          {
            v15 = 0;
            if ((int)v9 >= 0)
              v9 = v9;
            else
              v9 = -(int)v9;
            if ((int)v9 > v21)
              v21 = v9;
            LODWORD(v8) = v8 - v13;
            if ((int)v8 >= 0)
              v8 = v8;
            else
              v8 = -(int)v8;
            if (v8 > v21)
              v21 = v8;
            v27 = v26 - v14;
            if (v27 < 0)
              v27 = -v27;
            if (v27 > v21)
              v21 = v27;
          }
        }
        else
        {
          v15 = 1;
          v14 = *((_BYTE *)result + 3);
          v13 = *((_BYTE *)result + 2);
          v12 = *((_BYTE *)result + 1);
        }
        ++v11;
      }
      v23 &= v25 == v22;
      result = (CGColorSpace **)((char *)result + 4);
      --v24;
    }
    while (v24);
  }
  else
  {
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v11 = 0;
    v23 = 1;
  }
  LOBYTE(v77) = v14;
  BYTE4(v77) = v13;
  v32 = v11 == v10 || v16 == v10;
  v33 = (v11 > v10 / 0x64) & v15;
  if (v16 > v10 / 0x64)
    v34 = v20 & (v33 ^ 1);
  else
    v34 = 0;
  v76 = (PCImage *)a1;
  if (!v32 && ((v15 | v20) & 1) == 0 && v21 < 3)
  {
    v74 = a3;
    v75 = a4;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 2.0;
LABEL_56:
    v72 = 1;
    v73 = v32;
    LOBYTE(v77) = v36;
    BYTE4(v77) = v35;
    v71 = v35;
    v12 = v37;
    goto LABEL_60;
  }
  if (((v33 | v34) & 1) == 0)
  {
    v39 = 0;
    v40 = 1;
    v41 = 1;
    v42 = v12;
    if (!v32)
      goto LABEL_78;
    goto LABEL_58;
  }
  v38 = 0.0;
  v74 = a3;
  v75 = a4;
  if ((v33 & 1) != 0)
  {
    v37 = v12;
    v36 = v14;
    v35 = v13;
    goto LABEL_56;
  }
  v72 = 0;
  v73 = v32;
  v71 = v18;
  v37 = v17;
  v36 = v19;
LABEL_60:
  result = (CGColorSpace **)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64), v8, v9);
  v41 = v10 == 0;
  if (v10)
  {
    v43.n128_f32[0] = (float)v37;
    v44.n128_f32[0] = (float)v71;
    v45.n128_f32[0] = (float)v36;
    v48 = v34 << 31 >> 31;
    v49 = (char *)result + 3;
    v46.n128_u32[0] = 1.0;
    v47.n128_u32[0] = 0;
    v50 = v10;
    a3 = v74;
    a4 = v75;
    v42 = v12;
    v51 = v73;
    do
    {
      if (*(v49 - 3) != v48)
      {
        v52 = (*(v49 - 3) ^ v48);
        v53 = 1132396544;
        v54 = 255.0 / (float)v52;
        v55 = 1.0 - (float)((float)v52 / 255.0);
        LOBYTE(v53) = *(v49 - 2);
        *(float *)&v56 = v55 * v43.n128_f32[0];
        v57 = (float)((float)v53 - (float)(v55 * v43.n128_f32[0])) - v38;
        LOBYTE(v56) = *(v49 - 1);
        *(float *)&v58 = v55 * v44.n128_f32[0];
        v59 = (float)((float)v56 - (float)(v55 * v44.n128_f32[0])) - v38;
        LOBYTE(v58) = *v49;
        v60 = (float)((float)v58 - (float)(v55 * v45.n128_f32[0])) - v38;
        if (v57 >= 0.0)
          v61 = v57;
        else
          v61 = 0.0;
        if (v59 >= 0.0)
          v62 = v59;
        else
          v62 = 0.0;
        if (v60 < 0.0)
          v60 = 0.0;
        if ((int)(float)(v54 * v61) > 255 || (int)(float)(v54 * v62) > 255 || (int)(float)(v54 * v60) > 255)
          break;
      }
      --v50;
      v49 += 4;
      v41 = v50 == 0;
    }
    while (v50);
    if ((v72 & 1) != 0)
      goto LABEL_76;
LABEL_84:
    if (v17 || v18 || v19)
    {
      v64 = v51;
      result = (CGColorSpace **)(*(uint64_t (**)(_QWORD, __n128, __n128, __n128, __n128, __n128))(**((_QWORD **)v76 + 8) + 16))(*((_QWORD *)v76 + 8), v43, v44, v45, v46, v47);
      if (!v10)
      {
        v40 = 0;
        v77 = 0;
        v42 = 0;
        v39 = 1;
        if (!v64)
          goto LABEL_78;
LABEL_58:
        *a2 = 0;
LABEL_80:
        *a3 = 0;
        goto LABEL_102;
      }
      v65 = (char *)result + 3;
      v51 = v64;
      while (1)
      {
        if (*(v65 - 3))
        {
          v66 = 1132396544;
          v67 = 255.0 / (float)*(v65 - 3);
          LOBYTE(v66) = *(v65 - 2);
          v68 = v67 * (float)v66;
          if ((int)v68 > 255)
            break;
          LOBYTE(v68) = *(v65 - 1);
          v69 = v67 * (float)LODWORD(v68);
          if ((int)v69 > 255)
            break;
          LOBYTE(v69) = *v65;
          if ((int)(float)(v67 * (float)LODWORD(v69)) > 255)
            break;
        }
        v65 += 4;
        if (!--v10)
        {
          v40 = 0;
          v77 = 0;
          v42 = 0;
          goto LABEL_77;
        }
      }
    }
    v40 = 0;
    v39 = 0;
    if (!v51)
      goto LABEL_78;
    goto LABEL_58;
  }
  a3 = v74;
  a4 = v75;
  v42 = v12;
  v51 = v73;
  if ((v72 & 1) == 0)
    goto LABEL_84;
LABEL_76:
  v40 = 0;
LABEL_77:
  v39 = 1;
  if (v51)
    goto LABEL_58;
LABEL_78:
  if (v40 & 1 | !v41)
  {
    *a2 = 1;
    goto LABEL_80;
  }
  PCColor::PCColor((PCColor *)&v81.var1);
  PCImage::getColorSpace(v76, (CGColorSpace **)&v81);
  if (v39)
  {
    PCColor::setRGB((PCColor *)&v81.var1, (float)v42 / 255.0, (float)BYTE4(v77) / 255.0, (float)v77 / 255.0, &v81);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81);
    v63 = 0;
  }
  else
  {
    PCColor::setRGB((PCColor *)&v81.var1, (float)v17 / 255.0, (float)v18 / 255.0, (float)v19 / 255.0, &v81);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81);
    v63 = 1;
  }
  *a3 = v63;
  v80 = 0;
  v79 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v81);
  PCColor::getRGB((PCColor *)&v81.var1, (float *)&v80 + 1, (float *)&v80, &v79, (const PCColorSpaceHandle *)&v81);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81);
  if (*((float *)&v80 + 1) * 0.2126 + *(float *)&v80 * 0.7152 + v79 * 0.0722 >= 0.5)
    v70 = 3;
  else
    v70 = 2;
  *a2 = v70;
  result = PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81.var7);
LABEL_102:
  *a4 = v23 ^ 1;
  return result;
}

void sub_1B302F7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  CGColorSpace *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, CGColorSpace *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

CGColorSpace **PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)4>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  CGColorSpace **result;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  int v15;
  unsigned int v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  int v20;
  int v21;
  int v22;
  char v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  _BOOL4 v30;
  _BOOL4 v32;
  int v33;
  int v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  float v38;
  int v39;
  char v40;
  BOOL v41;
  unsigned __int8 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  int v48;
  _BYTE *v49;
  unsigned int v50;
  _BOOL4 v51;
  unsigned int v52;
  unsigned int v53;
  float v54;
  float v55;
  unsigned int v56;
  float v57;
  unsigned int v58;
  float v59;
  float v60;
  float v61;
  float v62;
  char v63;
  _BOOL4 v64;
  _BYTE *v65;
  unsigned int v66;
  float v67;
  float v68;
  float v69;
  int v70;
  unsigned __int8 v71;
  char v72;
  _BOOL4 v73;
  char *v74;
  _BYTE *v75;
  PCImage *v76;
  uint64_t v77;
  float v79;
  uint64_t v80;
  OZChannelBase v81;

  result = (CGColorSpace **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v10 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = *(unsigned __int8 *)result;
    v23 = 1;
    v24 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
    do
    {
      v25 = *(unsigned __int8 *)result;
      v9 = *((unsigned __int8 *)result + 3);
      v8 = *((unsigned __int8 *)result + 2);
      v26 = *((unsigned __int8 *)result + 1);
      if (v25 == 255)
      {
        v30 = (_DWORD)v9 == v17 && (_DWORD)v8 == v18 && v26 == v19;
        v20 &= v30;
        if (!v16)
        {
          v20 = 1;
          v19 = *((_BYTE *)result + 1);
          v18 = *((_BYTE *)result + 2);
          v17 = *((_BYTE *)result + 3);
        }
        ++v16;
      }
      else if (!*(_BYTE *)result)
      {
        if (v11)
        {
          v9 = v9 - v12;
          if ((_DWORD)v9 || __PAIR64__(v8, v26) != __PAIR64__(v13, v14))
          {
            v15 = 0;
            if ((int)v9 >= 0)
              v9 = v9;
            else
              v9 = -(int)v9;
            if ((int)v9 > v21)
              v21 = v9;
            LODWORD(v8) = v8 - v13;
            if ((int)v8 >= 0)
              v8 = v8;
            else
              v8 = -(int)v8;
            if (v8 > v21)
              v21 = v8;
            v27 = v26 - v14;
            if (v27 < 0)
              v27 = -v27;
            if (v27 > v21)
              v21 = v27;
          }
        }
        else
        {
          v15 = 1;
          v14 = *((_BYTE *)result + 1);
          v13 = *((_BYTE *)result + 2);
          v12 = *((_BYTE *)result + 3);
        }
        ++v11;
      }
      v23 &= v25 == v22;
      result = (CGColorSpace **)((char *)result + 4);
      --v24;
    }
    while (v24);
  }
  else
  {
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v11 = 0;
    v23 = 1;
  }
  LOBYTE(v77) = v14;
  BYTE4(v77) = v13;
  v32 = v11 == v10 || v16 == v10;
  v33 = (v11 > v10 / 0x64) & v15;
  if (v16 > v10 / 0x64)
    v34 = v20 & (v33 ^ 1);
  else
    v34 = 0;
  v76 = (PCImage *)a1;
  if (!v32 && ((v15 | v20) & 1) == 0 && v21 < 3)
  {
    v74 = a3;
    v75 = a4;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 2.0;
LABEL_56:
    v72 = 1;
    v73 = v32;
    LOBYTE(v77) = v36;
    BYTE4(v77) = v35;
    v71 = v35;
    v12 = v37;
    goto LABEL_60;
  }
  if (((v33 | v34) & 1) == 0)
  {
    v39 = 0;
    v40 = 1;
    v41 = 1;
    v42 = v12;
    if (!v32)
      goto LABEL_78;
    goto LABEL_58;
  }
  v38 = 0.0;
  v74 = a3;
  v75 = a4;
  if ((v33 & 1) != 0)
  {
    v37 = v12;
    v36 = v14;
    v35 = v13;
    goto LABEL_56;
  }
  v72 = 0;
  v73 = v32;
  v71 = v18;
  v37 = v17;
  v36 = v19;
LABEL_60:
  result = (CGColorSpace **)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64), v8, v9);
  v41 = v10 == 0;
  if (v10)
  {
    v43.n128_f32[0] = (float)v37;
    v44.n128_f32[0] = (float)v71;
    v45.n128_f32[0] = (float)v36;
    v48 = v34 << 31 >> 31;
    v49 = (char *)result + 3;
    v46.n128_u32[0] = 1.0;
    v47.n128_u32[0] = 0;
    v50 = v10;
    a3 = v74;
    a4 = v75;
    v42 = v12;
    v51 = v73;
    do
    {
      if (*(v49 - 3) != v48)
      {
        v52 = (*(v49 - 3) ^ v48);
        v53 = 1132396544;
        v54 = 255.0 / (float)v52;
        v55 = 1.0 - (float)((float)v52 / 255.0);
        LOBYTE(v53) = *v49;
        *(float *)&v56 = v55 * v43.n128_f32[0];
        v57 = (float)((float)v53 - (float)(v55 * v43.n128_f32[0])) - v38;
        LOBYTE(v56) = *(v49 - 1);
        *(float *)&v58 = v55 * v44.n128_f32[0];
        v59 = (float)((float)v56 - (float)(v55 * v44.n128_f32[0])) - v38;
        LOBYTE(v58) = *(v49 - 2);
        v60 = (float)((float)v58 - (float)(v55 * v45.n128_f32[0])) - v38;
        if (v57 >= 0.0)
          v61 = v57;
        else
          v61 = 0.0;
        if (v59 >= 0.0)
          v62 = v59;
        else
          v62 = 0.0;
        if (v60 < 0.0)
          v60 = 0.0;
        if ((int)(float)(v54 * v61) > 255 || (int)(float)(v54 * v62) > 255 || (int)(float)(v54 * v60) > 255)
          break;
      }
      --v50;
      v49 += 4;
      v41 = v50 == 0;
    }
    while (v50);
    if ((v72 & 1) != 0)
      goto LABEL_76;
LABEL_84:
    if (v17 || v18 || v19)
    {
      v64 = v51;
      result = (CGColorSpace **)(*(uint64_t (**)(_QWORD, __n128, __n128, __n128, __n128, __n128))(**((_QWORD **)v76 + 8) + 16))(*((_QWORD *)v76 + 8), v43, v44, v45, v46, v47);
      if (!v10)
      {
        v40 = 0;
        v77 = 0;
        v42 = 0;
        v39 = 1;
        if (!v64)
          goto LABEL_78;
LABEL_58:
        *a2 = 0;
LABEL_80:
        *a3 = 0;
        goto LABEL_102;
      }
      v65 = (char *)result + 3;
      v51 = v64;
      while (1)
      {
        if (*(v65 - 3))
        {
          v66 = 1132396544;
          v67 = 255.0 / (float)*(v65 - 3);
          LOBYTE(v66) = *v65;
          v68 = v67 * (float)v66;
          if ((int)v68 > 255)
            break;
          LOBYTE(v68) = *(v65 - 1);
          v69 = v67 * (float)LODWORD(v68);
          if ((int)v69 > 255)
            break;
          LOBYTE(v69) = *(v65 - 2);
          if ((int)(float)(v67 * (float)LODWORD(v69)) > 255)
            break;
        }
        v65 += 4;
        if (!--v10)
        {
          v40 = 0;
          v77 = 0;
          v42 = 0;
          goto LABEL_77;
        }
      }
    }
    v40 = 0;
    v39 = 0;
    if (!v51)
      goto LABEL_78;
    goto LABEL_58;
  }
  a3 = v74;
  a4 = v75;
  v42 = v12;
  v51 = v73;
  if ((v72 & 1) == 0)
    goto LABEL_84;
LABEL_76:
  v40 = 0;
LABEL_77:
  v39 = 1;
  if (v51)
    goto LABEL_58;
LABEL_78:
  if (v40 & 1 | !v41)
  {
    *a2 = 1;
    goto LABEL_80;
  }
  PCColor::PCColor((PCColor *)&v81.var1);
  PCImage::getColorSpace(v76, (CGColorSpace **)&v81);
  if (v39)
  {
    PCColor::setRGB((PCColor *)&v81.var1, (float)v42 / 255.0, (float)BYTE4(v77) / 255.0, (float)v77 / 255.0, &v81);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81);
    v63 = 0;
  }
  else
  {
    PCColor::setRGB((PCColor *)&v81.var1, (float)v17 / 255.0, (float)v18 / 255.0, (float)v19 / 255.0, &v81);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81);
    v63 = 1;
  }
  *a3 = v63;
  v80 = 0;
  v79 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v81);
  PCColor::getRGB((PCColor *)&v81.var1, (float *)&v80 + 1, (float *)&v80, &v79, (const PCColorSpaceHandle *)&v81);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81);
  if (*((float *)&v80 + 1) * 0.2126 + *(float *)&v80 * 0.7152 + v79 * 0.0722 >= 0.5)
    v70 = 3;
  else
    v70 = 2;
  *a2 = v70;
  result = PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v81.var7);
LABEL_102:
  *a4 = v23 ^ 1;
  return result;
}

void sub_1B302FE38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  CGColorSpace *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, CGColorSpace *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

uint64_t PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)5>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  int v15;
  unsigned int v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  int v20;
  int v21;
  int v22;
  _BYTE *v23;
  char v24;
  int v25;
  int v26;
  _BOOL4 v29;
  _BOOL4 v31;
  int v32;
  int v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  float v37;
  int v38;
  char v39;
  BOOL v40;
  unsigned __int8 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  int v47;
  unsigned __int8 *v48;
  unsigned int v49;
  unsigned __int8 *v50;
  _BOOL4 v51;
  unsigned __int8 v52;
  unsigned __int8 v53;
  unsigned int v54;
  float v55;
  float v56;
  unsigned int v57;
  float v58;
  unsigned int v59;
  float v60;
  float v61;
  float v62;
  float v63;
  char v64;
  _BOOL4 v65;
  unsigned __int8 *v66;
  unsigned __int8 *v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  float v71;
  float v72;
  float v73;
  int v74;
  unsigned __int8 v75;
  char v76;
  _BOOL4 v77;
  char *v78;
  _BYTE *v79;
  PCImage *v80;
  uint64_t v81;
  float v83;
  uint64_t v84;
  OZChannelBase v85;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v10 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = *(unsigned __int8 *)(result + 3);
    v23 = (_BYTE *)(result + 3);
    v24 = 1;
    v25 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
    do
    {
      v26 = *v23;
      v9 = *(v23 - 3);
      v8 = *(v23 - 2);
      result = *(v23 - 1);
      if (v26 == 255)
      {
        v29 = (_DWORD)v9 == v17 && (_DWORD)v8 == v18 && (_DWORD)result == v19;
        v20 &= v29;
        if (!v16)
        {
          v20 = 1;
          v19 = *(v23 - 1);
          v18 = *(v23 - 2);
          v17 = *(v23 - 3);
        }
        ++v16;
      }
      else if (!*v23)
      {
        if (v11)
        {
          v9 = v9 - v12;
          if ((_DWORD)v9 || __PAIR64__(result, v8) != __PAIR64__(v14, v13))
          {
            v15 = 0;
            if ((int)v9 >= 0)
              v9 = v9;
            else
              v9 = -(int)v9;
            if ((int)v9 > v21)
              v21 = v9;
            LODWORD(v8) = v8 - v13;
            if ((int)v8 >= 0)
              v8 = v8;
            else
              v8 = -(int)v8;
            if (v8 > v21)
              v21 = v8;
            LODWORD(result) = result - v14;
            if ((int)result >= 0)
              result = result;
            else
              result = -(int)result;
            if (result > v21)
              v21 = result;
          }
        }
        else
        {
          v15 = 1;
          v14 = *(v23 - 1);
          v13 = *(v23 - 2);
          v12 = *(v23 - 3);
        }
        ++v11;
      }
      v23 += 4;
      v24 &= v26 == v22;
      --v25;
    }
    while (v25);
  }
  else
  {
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v11 = 0;
    v24 = 1;
  }
  LOBYTE(v81) = v14;
  BYTE4(v81) = v13;
  v31 = v11 == v10 || v16 == v10;
  v32 = (v11 > v10 / 0x64) & v15;
  if (v16 > v10 / 0x64)
    v33 = v20 & (v32 ^ 1);
  else
    v33 = 0;
  v80 = (PCImage *)a1;
  if (!v31 && ((v15 | v20) & 1) == 0 && v21 < 3)
  {
    v78 = a3;
    v79 = a4;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 2.0;
LABEL_57:
    v76 = 1;
    v77 = v31;
    LOBYTE(v81) = v35;
    BYTE4(v81) = v34;
    v75 = v34;
    v12 = v36;
    goto LABEL_61;
  }
  if (((v32 | v33) & 1) == 0)
  {
    v38 = 0;
    v39 = 1;
    v40 = 1;
    v41 = v12;
    if (!v31)
      goto LABEL_79;
    goto LABEL_59;
  }
  v37 = 0.0;
  v78 = a3;
  v79 = a4;
  if ((v32 & 1) != 0)
  {
    v36 = v12;
    v35 = v14;
    v34 = v13;
    goto LABEL_57;
  }
  v76 = 0;
  v77 = v31;
  v75 = v18;
  v36 = v17;
  v35 = v19;
LABEL_61:
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64), v8, v9);
  v40 = v10 == 0;
  if (v10)
  {
    v47 = v33 << 31 >> 31;
    v42.n128_f32[0] = (float)v36;
    v43.n128_f32[0] = (float)v75;
    v44.n128_f32[0] = (float)v35;
    v48 = (unsigned __int8 *)(result + 3);
    v45.n128_u32[0] = 1.0;
    v46.n128_u32[0] = 0;
    v49 = v10;
    v50 = (unsigned __int8 *)(result + 3);
    a3 = v78;
    a4 = v79;
    v41 = v12;
    v51 = v77;
    do
    {
      v52 = *v50;
      v50 += 4;
      v53 = v52 ^ v47;
      if (v52 != v47)
      {
        v54 = 1132396544;
        v55 = 255.0 / (float)v53;
        v56 = 1.0 - (float)((float)v53 / 255.0);
        LOBYTE(v54) = *(v48 - 3);
        *(float *)&v57 = v56 * v42.n128_f32[0];
        v58 = (float)((float)v54 - (float)(v56 * v42.n128_f32[0])) - v37;
        LOBYTE(v57) = *(v48 - 2);
        *(float *)&v59 = v56 * v43.n128_f32[0];
        v60 = (float)((float)v57 - (float)(v56 * v43.n128_f32[0])) - v37;
        LOBYTE(v59) = *(v48 - 1);
        v61 = (float)((float)v59 - (float)(v56 * v44.n128_f32[0])) - v37;
        if (v58 >= 0.0)
          v62 = v58;
        else
          v62 = 0.0;
        if (v60 >= 0.0)
          v63 = v60;
        else
          v63 = 0.0;
        if (v61 < 0.0)
          v61 = 0.0;
        if ((int)(float)(v55 * v62) > 255 || (int)(float)(v55 * v63) > 255 || (int)(float)(v55 * v61) > 255)
          break;
      }
      v40 = --v49 == 0;
      v48 = v50;
    }
    while (v49);
    if ((v76 & 1) != 0)
      goto LABEL_77;
LABEL_85:
    if (v17 || v18 || v19)
    {
      v65 = v51;
      result = (*(uint64_t (**)(_QWORD, __n128, __n128, __n128, __n128, __n128))(**((_QWORD **)v80 + 8) + 16))(*((_QWORD *)v80 + 8), v42, v43, v44, v45, v46);
      if (!v10)
      {
        v39 = 0;
        v81 = 0;
        v41 = 0;
        v38 = 1;
        if (!v65)
          goto LABEL_79;
LABEL_59:
        *a2 = 0;
LABEL_81:
        *a3 = 0;
        goto LABEL_103;
      }
      v66 = (unsigned __int8 *)(result + 3);
      v67 = (unsigned __int8 *)(result + 3);
      v51 = v65;
      while (1)
      {
        v69 = *v67;
        v67 += 4;
        v68 = v69;
        if (v69)
        {
          v70 = 1132396544;
          v71 = 255.0 / (float)v68;
          LOBYTE(v70) = *(v66 - 3);
          v72 = v71 * (float)v70;
          if ((int)v72 > 255)
            break;
          LOBYTE(v72) = *(v66 - 2);
          v73 = v71 * (float)LODWORD(v72);
          if ((int)v73 > 255)
            break;
          LOBYTE(v73) = *(v66 - 1);
          if ((int)(float)(v71 * (float)LODWORD(v73)) > 255)
            break;
        }
        v66 = v67;
        if (!--v10)
        {
          v39 = 0;
          v81 = 0;
          v41 = 0;
          goto LABEL_78;
        }
      }
    }
    v39 = 0;
    v38 = 0;
    if (!v51)
      goto LABEL_79;
    goto LABEL_59;
  }
  a3 = v78;
  a4 = v79;
  v41 = v12;
  v51 = v77;
  if ((v76 & 1) == 0)
    goto LABEL_85;
LABEL_77:
  v39 = 0;
LABEL_78:
  v38 = 1;
  if (v51)
    goto LABEL_59;
LABEL_79:
  if (v39 & 1 | !v40)
  {
    *a2 = 1;
    goto LABEL_81;
  }
  PCColor::PCColor((PCColor *)&v85.var1);
  PCImage::getColorSpace(v80, (CGColorSpace **)&v85);
  if (v38)
  {
    PCColor::setRGB((PCColor *)&v85.var1, (float)v41 / 255.0, (float)BYTE4(v81) / 255.0, (float)v81 / 255.0, &v85);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85);
    v64 = 0;
  }
  else
  {
    PCColor::setRGB((PCColor *)&v85.var1, (float)v17 / 255.0, (float)v18 / 255.0, (float)v19 / 255.0, &v85);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85);
    v64 = 1;
  }
  *a3 = v64;
  v84 = 0;
  v83 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v85);
  PCColor::getRGB((PCColor *)&v85.var1, (float *)&v84 + 1, (float *)&v84, &v83, (const PCColorSpaceHandle *)&v85);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85);
  if (*((float *)&v84 + 1) * 0.2126 + *(float *)&v84 * 0.7152 + v83 * 0.0722 >= 0.5)
    v74 = 3;
  else
    v74 = 2;
  *a2 = v74;
  result = (uint64_t)PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85.var7);
LABEL_103:
  *a4 = v24 ^ 1;
  return result;
}

void sub_1B30304A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  CGColorSpace *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, CGColorSpace *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

uint64_t PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)6>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  int v15;
  unsigned int v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  int v20;
  int v21;
  int v22;
  _BYTE *v23;
  char v24;
  int v25;
  int v26;
  _BOOL4 v29;
  _BOOL4 v31;
  int v32;
  int v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  float v37;
  int v38;
  char v39;
  BOOL v40;
  unsigned __int8 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  int v47;
  unsigned __int8 *v48;
  unsigned int v49;
  unsigned __int8 *v50;
  _BOOL4 v51;
  unsigned __int8 v52;
  unsigned __int8 v53;
  unsigned int v54;
  float v55;
  float v56;
  unsigned int v57;
  float v58;
  unsigned int v59;
  float v60;
  float v61;
  float v62;
  float v63;
  char v64;
  _BOOL4 v65;
  unsigned __int8 *v66;
  unsigned __int8 *v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  float v71;
  float v72;
  float v73;
  int v74;
  unsigned __int8 v75;
  char v76;
  _BOOL4 v77;
  char *v78;
  _BYTE *v79;
  PCImage *v80;
  uint64_t v81;
  float v83;
  uint64_t v84;
  OZChannelBase v85;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v10 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = *(unsigned __int8 *)(result + 3);
    v23 = (_BYTE *)(result + 3);
    v24 = 1;
    v25 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
    do
    {
      v26 = *v23;
      v9 = *(v23 - 1);
      v8 = *(v23 - 2);
      result = *(v23 - 3);
      if (v26 == 255)
      {
        v29 = (_DWORD)v9 == v17 && (_DWORD)v8 == v18 && (_DWORD)result == v19;
        v20 &= v29;
        if (!v16)
        {
          v20 = 1;
          v19 = *(v23 - 3);
          v18 = *(v23 - 2);
          v17 = *(v23 - 1);
        }
        ++v16;
      }
      else if (!*v23)
      {
        if (v11)
        {
          v9 = v9 - v12;
          if ((_DWORD)v9 || __PAIR64__(v8, result) != __PAIR64__(v13, v14))
          {
            v15 = 0;
            if ((int)v9 >= 0)
              v9 = v9;
            else
              v9 = -(int)v9;
            if ((int)v9 > v21)
              v21 = v9;
            LODWORD(v8) = v8 - v13;
            if ((int)v8 >= 0)
              v8 = v8;
            else
              v8 = -(int)v8;
            if (v8 > v21)
              v21 = v8;
            LODWORD(result) = result - v14;
            if ((int)result >= 0)
              result = result;
            else
              result = -(int)result;
            if (result > v21)
              v21 = result;
          }
        }
        else
        {
          v15 = 1;
          v14 = *(v23 - 3);
          v13 = *(v23 - 2);
          v12 = *(v23 - 1);
        }
        ++v11;
      }
      v23 += 4;
      v24 &= v26 == v22;
      --v25;
    }
    while (v25);
  }
  else
  {
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v11 = 0;
    v24 = 1;
  }
  LOBYTE(v81) = v14;
  BYTE4(v81) = v13;
  v31 = v11 == v10 || v16 == v10;
  v32 = (v11 > v10 / 0x64) & v15;
  if (v16 > v10 / 0x64)
    v33 = v20 & (v32 ^ 1);
  else
    v33 = 0;
  v80 = (PCImage *)a1;
  if (!v31 && ((v15 | v20) & 1) == 0 && v21 < 3)
  {
    v78 = a3;
    v79 = a4;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 2.0;
LABEL_57:
    v76 = 1;
    v77 = v31;
    LOBYTE(v81) = v35;
    BYTE4(v81) = v34;
    v75 = v34;
    v12 = v36;
    goto LABEL_61;
  }
  if (((v32 | v33) & 1) == 0)
  {
    v38 = 0;
    v39 = 1;
    v40 = 1;
    v41 = v12;
    if (!v31)
      goto LABEL_79;
    goto LABEL_59;
  }
  v37 = 0.0;
  v78 = a3;
  v79 = a4;
  if ((v32 & 1) != 0)
  {
    v36 = v12;
    v35 = v14;
    v34 = v13;
    goto LABEL_57;
  }
  v76 = 0;
  v77 = v31;
  v75 = v18;
  v36 = v17;
  v35 = v19;
LABEL_61:
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64), v8, v9);
  v40 = v10 == 0;
  if (v10)
  {
    v47 = v33 << 31 >> 31;
    v42.n128_f32[0] = (float)v36;
    v43.n128_f32[0] = (float)v75;
    v44.n128_f32[0] = (float)v35;
    v48 = (unsigned __int8 *)(result + 3);
    v45.n128_u32[0] = 1.0;
    v46.n128_u32[0] = 0;
    v49 = v10;
    v50 = (unsigned __int8 *)(result + 3);
    a3 = v78;
    a4 = v79;
    v41 = v12;
    v51 = v77;
    do
    {
      v52 = *v50;
      v50 += 4;
      v53 = v52 ^ v47;
      if (v52 != v47)
      {
        v54 = 1132396544;
        v55 = 255.0 / (float)v53;
        v56 = 1.0 - (float)((float)v53 / 255.0);
        LOBYTE(v54) = *(v48 - 1);
        *(float *)&v57 = v56 * v42.n128_f32[0];
        v58 = (float)((float)v54 - (float)(v56 * v42.n128_f32[0])) - v37;
        LOBYTE(v57) = *(v48 - 2);
        *(float *)&v59 = v56 * v43.n128_f32[0];
        v60 = (float)((float)v57 - (float)(v56 * v43.n128_f32[0])) - v37;
        LOBYTE(v59) = *(v48 - 3);
        v61 = (float)((float)v59 - (float)(v56 * v44.n128_f32[0])) - v37;
        if (v58 >= 0.0)
          v62 = v58;
        else
          v62 = 0.0;
        if (v60 >= 0.0)
          v63 = v60;
        else
          v63 = 0.0;
        if (v61 < 0.0)
          v61 = 0.0;
        if ((int)(float)(v55 * v62) > 255 || (int)(float)(v55 * v63) > 255 || (int)(float)(v55 * v61) > 255)
          break;
      }
      v40 = --v49 == 0;
      v48 = v50;
    }
    while (v49);
    if ((v76 & 1) != 0)
      goto LABEL_77;
LABEL_85:
    if (v17 || v18 || v19)
    {
      v65 = v51;
      result = (*(uint64_t (**)(_QWORD, __n128, __n128, __n128, __n128, __n128))(**((_QWORD **)v80 + 8) + 16))(*((_QWORD *)v80 + 8), v42, v43, v44, v45, v46);
      if (!v10)
      {
        v39 = 0;
        v81 = 0;
        v41 = 0;
        v38 = 1;
        if (!v65)
          goto LABEL_79;
LABEL_59:
        *a2 = 0;
LABEL_81:
        *a3 = 0;
        goto LABEL_103;
      }
      v66 = (unsigned __int8 *)(result + 3);
      v67 = (unsigned __int8 *)(result + 3);
      v51 = v65;
      while (1)
      {
        v69 = *v67;
        v67 += 4;
        v68 = v69;
        if (v69)
        {
          v70 = 1132396544;
          v71 = 255.0 / (float)v68;
          LOBYTE(v70) = *(v66 - 1);
          v72 = v71 * (float)v70;
          if ((int)v72 > 255)
            break;
          LOBYTE(v72) = *(v66 - 2);
          v73 = v71 * (float)LODWORD(v72);
          if ((int)v73 > 255)
            break;
          LOBYTE(v73) = *(v66 - 3);
          if ((int)(float)(v71 * (float)LODWORD(v73)) > 255)
            break;
        }
        v66 = v67;
        if (!--v10)
        {
          v39 = 0;
          v81 = 0;
          v41 = 0;
          goto LABEL_78;
        }
      }
    }
    v39 = 0;
    v38 = 0;
    if (!v51)
      goto LABEL_79;
    goto LABEL_59;
  }
  a3 = v78;
  a4 = v79;
  v41 = v12;
  v51 = v77;
  if ((v76 & 1) == 0)
    goto LABEL_85;
LABEL_77:
  v39 = 0;
LABEL_78:
  v38 = 1;
  if (v51)
    goto LABEL_59;
LABEL_79:
  if (v39 & 1 | !v40)
  {
    *a2 = 1;
    goto LABEL_81;
  }
  PCColor::PCColor((PCColor *)&v85.var1);
  PCImage::getColorSpace(v80, (CGColorSpace **)&v85);
  if (v38)
  {
    PCColor::setRGB((PCColor *)&v85.var1, (float)v41 / 255.0, (float)BYTE4(v81) / 255.0, (float)v81 / 255.0, &v85);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85);
    v64 = 0;
  }
  else
  {
    PCColor::setRGB((PCColor *)&v85.var1, (float)v17 / 255.0, (float)v18 / 255.0, (float)v19 / 255.0, &v85);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85);
    v64 = 1;
  }
  *a3 = v64;
  v84 = 0;
  v83 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v85);
  PCColor::getRGB((PCColor *)&v85.var1, (float *)&v84 + 1, (float *)&v84, &v83, (const PCColorSpaceHandle *)&v85);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85);
  if (*((float *)&v84 + 1) * 0.2126 + *(float *)&v84 * 0.7152 + v83 * 0.0722 >= 0.5)
    v74 = 3;
  else
    v74 = 2;
  *a2 = v74;
  result = (uint64_t)PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v85.var7);
LABEL_103:
  *a4 = v24 ^ 1;
  return result;
}

void sub_1B3030B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  CGColorSpace *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, CGColorSpace *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

uint64_t PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)10>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  int v16;
  unsigned int v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  int v21;
  int v22;
  int v23;
  unsigned __int16 *v24;
  char v25;
  int v26;
  int v27;
  _BOOL4 v30;
  _BOOL4 v32;
  int v33;
  int v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  float v38;
  int v39;
  char v40;
  BOOL v41;
  unsigned __int16 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  float v49;
  int v50;
  _WORD *v51;
  unsigned int v52;
  _BOOL4 v53;
  unsigned int v54;
  float v55;
  float v56;
  unsigned int v57;
  float v58;
  unsigned int v59;
  float v60;
  float v61;
  float v62;
  float v63;
  char v64;
  _BOOL4 v65;
  float v66;
  _WORD *v67;
  float v68;
  float v69;
  float v70;
  int v71;
  unsigned __int16 v72;
  char v73;
  _BOOL4 v74;
  char *v75;
  _BYTE *v76;
  PCImage *v77;
  uint64_t v78;
  float v80;
  uint64_t v81;
  OZChannelBase v82;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v11 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  if (v11)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = *(unsigned __int16 *)(result + 6);
    v24 = (unsigned __int16 *)(result + 4);
    v25 = 1;
    v26 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
    do
    {
      v27 = v24[1];
      v10 = *(v24 - 2);
      v9 = *(v24 - 1);
      v8 = *v24;
      if (v27 == 0xFFFF)
      {
        v30 = (_DWORD)v10 == v18 && (_DWORD)v9 == v19 && (_DWORD)v8 == v20;
        v21 &= v30;
        if (!v17)
        {
          v21 = 1;
          v20 = *v24;
          v19 = *(v24 - 1);
          v18 = *(v24 - 2);
        }
        ++v17;
      }
      else if (!v24[1])
      {
        if (v12)
        {
          v10 = v10 - v13;
          if ((_DWORD)v10 || __PAIR64__(v8, v9) != __PAIR64__(v15, v14))
          {
            v16 = 0;
            if ((int)v10 >= 0)
              v10 = v10;
            else
              v10 = -(int)v10;
            if ((int)v10 > v22)
              v22 = v10;
            LODWORD(v9) = v9 - v14;
            if ((int)v9 >= 0)
              v9 = v9;
            else
              v9 = -(int)v9;
            if (v9 > v22)
              v22 = v9;
            LODWORD(v8) = v8 - v15;
            if ((int)v8 >= 0)
              v8 = v8;
            else
              v8 = -(int)v8;
            if (v8 > v22)
              v22 = v8;
          }
        }
        else
        {
          v16 = 1;
          v15 = *v24;
          v14 = *(v24 - 1);
          v13 = *(v24 - 2);
        }
        ++v12;
      }
      v24 += 4;
      result = v27 == v23;
      v25 &= result;
      --v26;
    }
    while (v26);
  }
  else
  {
    v22 = 0;
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v25 = 1;
  }
  LOWORD(v78) = v15;
  WORD2(v78) = v14;
  v32 = v12 == v11 || v17 == v11;
  v33 = (v12 > v11 / 0x64) & v16;
  if (v17 > v11 / 0x64)
    v34 = v21 & (v33 ^ 1);
  else
    v34 = 0;
  v77 = (PCImage *)a1;
  if (!v32 && ((v16 | v21) & 1) == 0 && v22 < 3)
  {
    v75 = a3;
    v76 = a4;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 2.0;
LABEL_57:
    v73 = 1;
    v74 = v32;
    LOWORD(v78) = v36;
    WORD2(v78) = v35;
    v72 = v35;
    v13 = v37;
    goto LABEL_61;
  }
  if (((v33 | v34) & 1) == 0)
  {
    v39 = 0;
    v40 = 1;
    v41 = 1;
    v42 = v13;
    if (!v32)
      goto LABEL_79;
    goto LABEL_59;
  }
  v38 = 0.0;
  v75 = a3;
  v76 = a4;
  if ((v33 & 1) != 0)
  {
    v37 = v13;
    v36 = v15;
    v35 = v14;
    goto LABEL_57;
  }
  v73 = 0;
  v74 = v32;
  v72 = v19;
  v37 = v18;
  v36 = v20;
LABEL_61:
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64), v8, v9, v10);
  v41 = v11 == 0;
  if (v11)
  {
    v50 = v34 << 31 >> 31;
    v43.n128_f32[0] = (float)v37;
    v44.n128_f32[0] = (float)v72;
    v45.n128_f32[0] = (float)v36;
    v51 = (_WORD *)(result + 4);
    v46.n128_u32[0] = 1199570688;
    v47.n128_u32[0] = 1.0;
    v48.n128_u32[0] = 0;
    v52 = v11;
    a3 = v75;
    a4 = v76;
    v42 = v13;
    v53 = v74;
    do
    {
      if (v51[1] != (unsigned __int16)v50)
      {
        v54 = (unsigned __int16)(v51[1] ^ v50);
        v55 = 65535.0 / (float)v54;
        v56 = 1.0 - (float)((float)v54 / 65535.0);
        LOWORD(v49) = *(v51 - 2);
        *(float *)&v57 = v56 * v43.n128_f32[0];
        v58 = (float)((float)LODWORD(v49) - (float)(v56 * v43.n128_f32[0])) - v38;
        LOWORD(v57) = *(v51 - 1);
        *(float *)&v59 = v56 * v44.n128_f32[0];
        v60 = (float)((float)v57 - (float)(v56 * v44.n128_f32[0])) - v38;
        LOWORD(v59) = *v51;
        v61 = (float)((float)v59 - (float)(v56 * v45.n128_f32[0])) - v38;
        if (v58 >= 0.0)
          v62 = v58;
        else
          v62 = 0.0;
        if (v60 >= 0.0)
          v63 = v60;
        else
          v63 = 0.0;
        if (v61 < 0.0)
          v61 = 0.0;
        if ((int)(float)(v55 * v62) >= 0x10000)
          break;
        v49 = v55 * v63;
        if ((int)v49 >= 0x10000 || (int)(float)(v55 * v61) >= 0x10000)
          break;
      }
      v51 += 4;
      v41 = --v52 == 0;
    }
    while (v52);
    if ((v73 & 1) != 0)
      goto LABEL_77;
LABEL_85:
    if (v18 || v19 || v20)
    {
      v65 = v53;
      result = (*(uint64_t (**)(_QWORD, __n128, __n128, __n128, __n128, __n128, __n128))(**((_QWORD **)v77 + 8)
                                                                                                 + 16))(*((_QWORD *)v77 + 8), v43, v44, v45, v46, v47, v48);
      if (!v11)
      {
        v40 = 0;
        v78 = 0;
        v42 = 0;
        v39 = 1;
        if (!v65)
          goto LABEL_79;
LABEL_59:
        *a2 = 0;
LABEL_81:
        *a3 = 0;
        goto LABEL_103;
      }
      v67 = (_WORD *)(result + 4);
      v53 = v65;
      while (1)
      {
        if (v67[1])
        {
          v68 = 65535.0 / (float)(unsigned __int16)v67[1];
          LOWORD(v66) = *(v67 - 2);
          v69 = v68 * (float)LODWORD(v66);
          if ((int)v69 >= 0x10000)
            break;
          LOWORD(v69) = *(v67 - 1);
          v70 = v68 * (float)LODWORD(v69);
          if ((int)v70 >= 0x10000)
            break;
          LOWORD(v70) = *v67;
          v66 = (float)LODWORD(v70);
          if ((int)(float)(v68 * v66) >= 0x10000)
            break;
        }
        v67 += 4;
        if (!--v11)
        {
          v40 = 0;
          v78 = 0;
          v42 = 0;
          goto LABEL_78;
        }
      }
    }
    v40 = 0;
    v39 = 0;
    if (!v53)
      goto LABEL_79;
    goto LABEL_59;
  }
  a3 = v75;
  a4 = v76;
  v42 = v13;
  v53 = v74;
  if ((v73 & 1) == 0)
    goto LABEL_85;
LABEL_77:
  v40 = 0;
LABEL_78:
  v39 = 1;
  if (v53)
    goto LABEL_59;
LABEL_79:
  if (v40 & 1 | !v41)
  {
    *a2 = 1;
    goto LABEL_81;
  }
  PCColor::PCColor((PCColor *)&v82.var1);
  PCImage::getColorSpace(v77, (CGColorSpace **)&v82);
  if (v39)
  {
    PCColor::setRGB((PCColor *)&v82.var1, (float)v42 / 255.0, (float)WORD2(v78) / 255.0, (float)(unsigned __int16)v78 / 255.0, &v82);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v82);
    v64 = 0;
  }
  else
  {
    PCColor::setRGB((PCColor *)&v82.var1, (float)v18 / 255.0, (float)v19 / 255.0, (float)v20 / 255.0, &v82);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v82);
    v64 = 1;
  }
  *a3 = v64;
  v81 = 0;
  v80 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v82);
  PCColor::getRGB((PCColor *)&v82.var1, (float *)&v81 + 1, (float *)&v81, &v80, (const PCColorSpaceHandle *)&v82);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v82);
  if (*((float *)&v81 + 1) * 0.2126 + *(float *)&v81 * 0.7152 + v80 * 0.0722 >= 0.5)
    v71 = 3;
  else
    v71 = 2;
  *a2 = v71;
  result = (uint64_t)PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v82.var7);
LABEL_103:
  *a4 = v25 ^ 1;
  return result;
}

void sub_1B3031178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  CGColorSpace *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, CGColorSpace *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

uint64_t PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)13>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t result;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  unsigned __int16 *v21;
  uint64_t v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  int v33;
  float v34;
  int v35;
  int v36;
  _BOOL4 v38;
  int v39;
  int v40;
  float v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  unsigned __int16 *v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  unsigned int v61;
  float v62;
  float v63;
  unsigned int v64;
  float v65;
  unsigned __int16 *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  float v70;
  unsigned int v71;
  float v72;
  unsigned int v73;
  float v74;
  unsigned int v75;
  float v76;
  float v77;
  float v78;
  unsigned int v79;
  float v80;
  unsigned int v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  char v87;
  float v88;
  float v89;
  float v90;
  int v91;
  _BYTE *v92;
  uint64_t v93;
  char *v94;
  int *v95;
  char v96;
  uint64_t v97;
  _BOOL4 v98;
  PCImage *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  float v108;
  uint64_t v109;
  OZChannelBase v110;

  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v99 = (PCImage *)a1;
  v9 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  result = 15360;
  if (v9)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v103 = 0;
    v20 = half::_toFloat[*(unsigned __int16 *)(v8 + 6)];
    v21 = (unsigned __int16 *)(v8 + 4);
    v22 = 0;
    v23 = 1;
    v24 = v9;
    while (1)
    {
      v25 = *(v21 - 2);
      v26 = *(v21 - 1);
      v27 = *v21;
      v28 = half::_toFloat[v21[1]];
      if (v28 != 0.0)
      {
        if (v28 == 1.0)
        {
          if (v13)
          {
            if (half::_toFloat[v18] != half::_toFloat[v25]
              || half::_toFloat[v19] != half::_toFloat[v26]
              || half::_toFloat[v103] != half::_toFloat[v27])
            {
              v14 = 0;
            }
          }
          else
          {
            v14 = 1;
            v103 = *v21;
            v19 = *(v21 - 1);
            v18 = *(v21 - 2);
          }
          ++v13;
        }
        goto LABEL_25;
      }
      if (v11)
      {
        v29 = half::_toFloat[v16];
        v30 = half::_toFloat[v25];
        if (v29 != v30)
        {
          v31 = half::_toFloat[v26];
          v32 = half::_toFloat[v17];
LABEL_16:
          v12 = 0;
          v33 = (int)vabds_f32(v30, v29);
          if (v15 <= v33)
            v15 = v33;
          v34 = half::_toFloat[v27];
          v35 = (int)vabds_f32(v31, v32);
          if (v15 <= v35)
            v15 = v35;
          v36 = (int)vabds_f32(v34, half::_toFloat[v22]);
          if (v15 <= v36)
            v15 = v36;
          goto LABEL_22;
        }
        v32 = half::_toFloat[v17];
        v31 = half::_toFloat[v26];
        if (v32 != v31 || half::_toFloat[v22] != half::_toFloat[v27])
          goto LABEL_16;
      }
      else
      {
        v12 = 1;
        v22 = *v21;
        v17 = *(v21 - 1);
        v16 = *(v21 - 2);
      }
LABEL_22:
      ++v11;
LABEL_25:
      v21 += 4;
      v23 &= v28 == v20;
      if (!--v24)
        goto LABEL_28;
    }
  }
  v103 = 0;
  v19 = 0;
  v18 = 0;
  v22 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v23 = 1;
LABEL_28:
  v97 = v16;
  v100 = v17;
  v38 = v11 == v9 || v13 == v9;
  v39 = (v11 > v9 / 0x64) & v12;
  if (v13 > v9 / 0x64)
    v40 = v14 & (v39 ^ 1);
  else
    v40 = 0;
  v98 = v38;
  if (((v38 | v12 | v14) & 1) != 0 || v15 >= 3)
  {
    if ((v39 | v40) != 1)
    {
      v42 = 0;
      v43 = 1;
      v44 = 1;
      v45 = v17;
      goto LABEL_133;
    }
    v41 = 0.0;
    if ((v39 & 1) != 0)
    {
      v96 = 1;
      v105 = v17;
      v107 = v22;
      v104 = v16;
    }
    else
    {
      v96 = 0;
      v105 = v19;
      v107 = v103;
      v104 = v18;
    }
  }
  else
  {
    v22 = 0;
    v100 = 0;
    v97 = 0;
    v105 = 0;
    v107 = 0;
    v104 = 0;
    v41 = 2.0;
    v96 = 1;
  }
  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v99 + 8) + 16))(*((_QWORD *)v99 + 8));
  v101 = v18;
  v102 = v19;
  v94 = a3;
  v95 = a2;
  v93 = v22;
  if (v9)
  {
    v92 = a4;
    v46 = (unsigned __int16 *)(result + 4);
    v47 = v9;
    while (1)
    {
      result = v46[1];
      v48 = *(v46 - 2);
      v49 = *(v46 - 1);
      v50 = *v46;
      if (v40)
      {
        v51 = 1.0 - half::_toFloat[result];
        if (v51 == 0.0)
        {
          result = 0;
        }
        else
        {
          v62 = 1.0 - half::_toFloat[result];
          if (half::_eLut[LODWORD(v51) >> 23])
            result = half::_eLut[LODWORD(v51) >> 23] + (((LODWORD(v62) & 0x7FF000u) + 4096) >> 13);
          else
            result = half::convert((half *)LODWORD(v51));
        }
      }
      v52 = half::_toFloat[(unsigned __int16)result];
      if (v52 > 0.0)
      {
        v53 = 1.0 / v52;
        v54 = 1.0 - (float)(v52 / 1.0);
        v55 = (float)(half::_toFloat[v48] - (float)(half::_toFloat[v104] * v54)) - v41;
        v56 = (float)(half::_toFloat[v49] - (float)(v54 * half::_toFloat[v105])) - v41;
        v57 = (float)(half::_toFloat[v50] - (float)(v54 * half::_toFloat[v107])) - v41;
        if (v55 < 0.0)
          v55 = 0.0;
        v58 = v56 >= 0.0 ? v56 : 0.0;
        v59 = v57 >= 0.0 ? v57 : 0.0;
        v60 = v53 * v55;
        if ((float)(v53 * v55) == 0.0)
        {
          LOWORD(v61) = 0;
        }
        else if (half::_eLut[LODWORD(v60) >> 23])
        {
          v61 = half::_eLut[LODWORD(v60) >> 23] + (((COERCE_UNSIGNED_INT(v53 * v55) & 0x7FF000) + 4096) >> 13);
        }
        else
        {
          LOWORD(v61) = half::convert((half *)LODWORD(v60));
        }
        v63 = v53 * v58;
        if ((float)(v53 * v58) == 0.0)
        {
          LOWORD(v64) = 0;
        }
        else if (half::_eLut[LODWORD(v63) >> 23])
        {
          v64 = half::_eLut[LODWORD(v63) >> 23] + (((COERCE_UNSIGNED_INT(v53 * v58) & 0x7FF000) + 4096) >> 13);
        }
        else
        {
          LOWORD(v64) = half::convert((half *)LODWORD(v63));
        }
        v65 = v53 * v59;
        if ((float)(v53 * v59) == 0.0)
          result = 0;
        else
          result = half::_eLut[LODWORD(v65) >> 23]
                 ? half::_eLut[LODWORD(v65) >> 23] + (((COERCE_UNSIGNED_INT(v53 * v59) & 0x7FF000) + 4096) >> 13)
                 : half::convert((half *)LODWORD(v65));
        if (half::_toFloat[(unsigned __int16)v61] > 1.0
          || half::_toFloat[(unsigned __int16)v64] > 1.0
          || half::_toFloat[(unsigned __int16)result] > 1.0)
        {
          break;
        }
      }
      v46 += 4;
      if (!--v47)
      {
        v44 = 1;
        goto LABEL_83;
      }
    }
    v44 = 0;
LABEL_83:
    a4 = v92;
    v22 = v93;
    a2 = v95;
    v18 = v101;
    v19 = v102;
  }
  else
  {
    v44 = 1;
  }
  v45 = v100;
  if ((v96 & 1) != 0)
  {
    v43 = 0;
    v42 = 1;
  }
  else if (half::_toFloat[v18] == 0.0 && half::_toFloat[v19] == 0.0 && half::_toFloat[v103] == 0.0)
  {
    v43 = 0;
    v42 = 0;
  }
  else
  {
    v106 = v44;
    result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v99 + 8) + 16))(*((_QWORD *)v99 + 8));
    if (v9)
    {
      v66 = (unsigned __int16 *)(result + 4);
      while (1)
      {
        v67 = v66[1];
        v68 = *(v66 - 1);
        v69 = *v66;
        v70 = half::_toFloat[*(v66 - 2)] - 0.0;
        if (v70 == 0.0)
        {
          LOWORD(v71) = 0;
        }
        else
        {
          result = LODWORD(v70);
          if (half::_eLut[LODWORD(v70) >> 23])
          {
            v71 = half::_eLut[LODWORD(v70) >> 23] + (((LODWORD(v70) & 0x7FF000u) + 4096) >> 13);
          }
          else
          {
            result = half::convert((half *)LODWORD(v70));
            LOWORD(v71) = result;
          }
        }
        v72 = half::_toFloat[v68] - 0.0;
        if (v72 == 0.0)
        {
          LOWORD(v73) = 0;
        }
        else
        {
          result = LODWORD(v72);
          if (half::_eLut[LODWORD(v72) >> 23])
          {
            v73 = half::_eLut[LODWORD(v72) >> 23] + (((LODWORD(v72) & 0x7FF000u) + 4096) >> 13);
          }
          else
          {
            result = half::convert((half *)LODWORD(v72));
            LOWORD(v73) = result;
          }
        }
        v74 = half::_toFloat[v69] - 0.0;
        if (v74 == 0.0)
        {
          LOWORD(v75) = 0;
        }
        else
        {
          result = LODWORD(v74);
          if (half::_eLut[LODWORD(v74) >> 23])
          {
            v75 = half::_eLut[LODWORD(v74) >> 23] + (((LODWORD(v74) & 0x7FF000u) + 4096) >> 13);
          }
          else
          {
            result = half::convert((half *)LODWORD(v74));
            LOWORD(v75) = result;
          }
        }
        v76 = half::_toFloat[v67];
        if (v76 > 0.0)
        {
          v77 = 1.0 / v76;
          v78 = half::_toFloat[(unsigned __int16)v71] * (float)(1.0 / v76);
          if (v78 == 0.0)
          {
            LOWORD(v79) = 0;
          }
          else if (half::_eLut[LODWORD(v78) >> 23])
          {
            v79 = half::_eLut[LODWORD(v78) >> 23]
                + (((COERCE_UNSIGNED_INT(half::_toFloat[(unsigned __int16)v71] * v77) & 0x7FF000) + 4096) >> 13);
          }
          else
          {
            LOWORD(v79) = half::convert((half *)LODWORD(v78));
          }
          v80 = v77 * half::_toFloat[(unsigned __int16)v73];
          if (v80 == 0.0)
          {
            LOWORD(v81) = 0;
          }
          else if (half::_eLut[LODWORD(v80) >> 23])
          {
            v81 = half::_eLut[LODWORD(v80) >> 23]
                + (((COERCE_UNSIGNED_INT(v77 * half::_toFloat[(unsigned __int16)v73]) & 0x7FF000) + 4096) >> 13);
          }
          else
          {
            LOWORD(v81) = half::convert((half *)LODWORD(v80));
          }
          v82 = v77 * half::_toFloat[(unsigned __int16)v75];
          if (v82 == 0.0)
          {
            result = 0;
            v18 = v101;
            v19 = v102;
          }
          else
          {
            v83 = v77 * half::_toFloat[(unsigned __int16)v75];
            v18 = v101;
            v19 = v102;
            if (half::_eLut[LODWORD(v82) >> 23])
              result = half::_eLut[LODWORD(v82) >> 23] + (((LODWORD(v83) & 0x7FF000u) + 4096) >> 13);
            else
              result = half::convert((half *)LODWORD(v82));
          }
          if (half::_toFloat[(unsigned __int16)v79] > 1.0 || half::_toFloat[(unsigned __int16)v81] > 1.0)
          {
            v43 = 0;
            v42 = 0;
            a3 = v94;
            a2 = v95;
            goto LABEL_131;
          }
          if (half::_toFloat[(unsigned __int16)result] > 1.0)
            break;
        }
        v66 += 4;
        if (!--v9)
        {
          v43 = 0;
          v22 = 0;
          v45 = 0;
          v97 = 0;
          v42 = 1;
          a3 = v94;
          a2 = v95;
          v18 = v101;
          v19 = v102;
          goto LABEL_132;
        }
      }
      v43 = 0;
      v42 = 0;
      a3 = v94;
      a2 = v95;
      v18 = v101;
      v19 = v102;
LABEL_131:
      v22 = v93;
      v45 = v100;
    }
    else
    {
      v43 = 0;
      v22 = 0;
      v45 = 0;
      v97 = 0;
      v42 = 1;
    }
LABEL_132:
    v44 = v106;
  }
LABEL_133:
  if (v98)
  {
    *a2 = 0;
LABEL_137:
    *a3 = 0;
    goto LABEL_145;
  }
  if (((v43 | v44 ^ 1) & 1) != 0)
  {
    *a2 = 1;
    goto LABEL_137;
  }
  PCColor::PCColor((PCColor *)&v110.var1);
  if (v42)
  {
    v84 = half::_toFloat[v97];
    v85 = half::_toFloat[v45];
    v86 = half::_toFloat[v22];
    PCImage::getColorSpace(v99, (CGColorSpace **)&v110);
    PCColor::setRGB((PCColor *)&v110.var1, v84 / 255.0, v85 / 255.0, v86 / 255.0, &v110);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v110);
    v87 = 0;
  }
  else
  {
    v88 = half::_toFloat[v18];
    v89 = half::_toFloat[v19];
    v90 = half::_toFloat[v103];
    PCImage::getColorSpace(v99, (CGColorSpace **)&v110);
    PCColor::setRGB((PCColor *)&v110.var1, v88 / 255.0, v89 / 255.0, v90 / 255.0, &v110);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v110);
    v87 = 1;
  }
  *a3 = v87;
  v109 = 0;
  v108 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v110);
  PCColor::getRGB((PCColor *)&v110.var1, (float *)&v109 + 1, (float *)&v109, &v108, (const PCColorSpaceHandle *)&v110);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v110);
  if (*((float *)&v109 + 1) * 0.2126 + *(float *)&v109 * 0.7152 + v108 * 0.0722 >= 0.5)
    v91 = 3;
  else
    v91 = 2;
  *a2 = v91;
  result = (uint64_t)PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v110.var7);
LABEL_145:
  *a4 = v23 ^ 1;
  return result;
}

void sub_1B3031BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,CGColorSpace *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,CGColorSpace *a35)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(&a28);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a35);
  _Unwind_Resume(a1);
}

CGColorSpace **PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)16>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  CGColorSpace **result;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  float v15;
  float *v16;
  char v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  int v30;
  int v31;
  int v32;
  _BOOL4 v33;
  _BOOL4 v35;
  int v36;
  int v37;
  float v38;
  char v39;
  float v40;
  float v41;
  int v42;
  char v43;
  BOOL v44;
  float *v45;
  unsigned int v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  BOOL v56;
  char v58;
  float *v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  BOOL v65;
  int v67;
  float v68;
  float v69;
  float v70;
  uint64_t v71;
  OZChannelBase v72;

  result = (CGColorSpace **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v9 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  if (v9)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0.0;
    v16 = (float *)(result + 1);
    v17 = 1;
    v18 = 0.0;
    v19 = 0.0;
    v20 = 0.0;
    v21 = 0.0;
    v22 = 0.0;
    v23 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
    do
    {
      v25 = *(v16 - 2);
      v24 = *(v16 - 1);
      v27 = *v16;
      v26 = v16[1];
      if (v26 == 0.0)
      {
        if (v10)
        {
          if (v15 != v25 || v18 != v24 || v19 != v27)
          {
            v11 = 0;
            v30 = (int)vabds_f32(v25, v15);
            if (v14 <= v30)
              v14 = v30;
            v31 = (int)vabds_f32(v24, v18);
            v32 = (int)vabds_f32(v27, v19);
            if (v14 <= v31)
              v14 = v31;
            if (v14 <= v32)
              v14 = v32;
          }
          v27 = v19;
          v24 = v18;
          v25 = v15;
        }
        else
        {
          v11 = 1;
        }
        ++v10;
        v19 = v27;
        v18 = v24;
        v15 = v25;
      }
      else if (v26 == 1.0)
      {
        if (v12)
        {
          v33 = v20 == v25;
          if (v21 != v24)
            v33 = 0;
          if (v22 != v27)
            v33 = 0;
          v13 &= v33;
        }
        else
        {
          v13 = 1;
          v22 = *v16;
          v21 = *(v16 - 1);
          v20 = *(v16 - 2);
        }
        ++v12;
      }
      v17 &= v26 == *((float *)result + 3);
      v16 += 4;
      --v23;
    }
    while (v23);
  }
  else
  {
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v11 = 0;
    v10 = 0;
    v22 = 0.0;
    v21 = 0.0;
    v17 = 1;
    v20 = 0.0;
    v19 = 0.0;
    v18 = 0.0;
    v15 = 0.0;
  }
  v35 = v10 == v9 || v12 == v9;
  v36 = (v10 > v9 / 0x64) & v11;
  if (v12 > v9 / 0x64)
    v37 = v13 & (v36 ^ 1);
  else
    v37 = 0;
  if (!v35 && ((v11 | v13) & 1) == 0 && v14 < 3)
  {
    v68 = v21;
    v69 = v22;
    v38 = 2.0;
    v18 = 0.0;
    v19 = 0.0;
    v15 = 0.0;
LABEL_48:
    v39 = 1;
    v40 = v18;
    v41 = v15;
    v22 = v19;
    goto LABEL_52;
  }
  if (((v36 | v37) & 1) == 0)
  {
    v42 = 0;
    v43 = 1;
    v44 = 1;
    if (!v35)
      goto LABEL_75;
    goto LABEL_50;
  }
  v38 = 0.0;
  v68 = v21;
  v69 = v22;
  if ((v36 & 1) != 0)
    goto LABEL_48;
  v39 = 0;
  v40 = v21;
  v41 = v20;
LABEL_52:
  result = (CGColorSpace **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v44 = v9 == 0;
  if (v9)
  {
    v45 = (float *)(result + 1);
    v46 = v9;
    do
    {
      v47 = v45[1];
      if ((v37 & 1) != 0)
        v47 = 1.0 - v47;
      if (v47 > 0.0)
      {
        v48 = 1.0 / v47;
        v49 = 1.0 - v47;
        v50 = (float)(*(v45 - 2) - (float)(v41 * v49)) - v38;
        v51 = (float)(*(v45 - 1) - (float)(v40 * v49)) - v38;
        v52 = (float)(*v45 - (float)(v22 * v49)) - v38;
        if (v50 >= 0.0)
          v53 = v50;
        else
          v53 = 0.0;
        if (v51 < 0.0)
          v51 = 0.0;
        if (v52 < 0.0)
          v52 = 0.0;
        v54 = v48 * v51;
        v55 = v48 * v52;
        v56 = (float)(v48 * v53) <= 1.0 && v54 <= 1.0;
        if (!v56 || v55 > 1.0)
          break;
      }
      --v46;
      v45 += 4;
      v44 = v46 == 0;
    }
    while (v46);
  }
  if ((v39 & 1) != 0)
  {
    v43 = 0;
    v42 = 1;
    v21 = v68;
    v22 = v69;
    if (!v35)
      goto LABEL_75;
LABEL_50:
    *a2 = 0;
LABEL_77:
    *a3 = 0;
    goto LABEL_104;
  }
  v21 = v68;
  v22 = v69;
  if (v20 == 0.0 && v68 == 0.0 && v69 == 0.0)
    goto LABEL_81;
  result = (CGColorSpace **)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  if (v9)
  {
    v59 = (float *)(result + 1);
    while (1)
    {
      v60 = v59[1];
      if (v60 > 0.0)
      {
        v61 = 1.0 / v60;
        v62 = v61 * *(v59 - 2);
        v63 = v61 * *(v59 - 1);
        v64 = v61 * *v59;
        v65 = v62 <= 1.0 && v63 <= 1.0;
        if (!v65 || v64 > 1.0)
          break;
      }
      v59 += 4;
      if (!--v9)
        goto LABEL_97;
    }
LABEL_81:
    v43 = 0;
    v42 = 0;
    if (v35)
      goto LABEL_50;
    goto LABEL_75;
  }
LABEL_97:
  v43 = 0;
  v42 = 1;
  v19 = 0.0;
  v18 = 0.0;
  v15 = 0.0;
  if (v35)
    goto LABEL_50;
LABEL_75:
  if (v43 & 1 | !v44)
  {
    *a2 = 1;
    goto LABEL_77;
  }
  PCColor::PCColor((PCColor *)&v72.var1);
  PCImage::getColorSpace((PCImage *)a1, (CGColorSpace **)&v72);
  if (v42)
  {
    PCColor::setRGB((PCColor *)&v72.var1, v15 / 255.0, v18 / 255.0, v19 / 255.0, &v72);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72);
    v58 = 0;
  }
  else
  {
    PCColor::setRGB((PCColor *)&v72.var1, v20 / 255.0, v21 / 255.0, v22 / 255.0, &v72);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72);
    v58 = 1;
  }
  *a3 = v58;
  v71 = 0;
  v70 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v72);
  PCColor::getRGB((PCColor *)&v72.var1, (float *)&v71 + 1, (float *)&v71, &v70, (const PCColorSpaceHandle *)&v72);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72);
  if (*((float *)&v71 + 1) * 0.2126 + *(float *)&v71 * 0.7152 + v70 * 0.0722 >= 0.5)
    v67 = 3;
  else
    v67 = 2;
  *a2 = v67;
  result = PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72.var7);
LABEL_104:
  *a4 = v17 ^ 1;
  return result;
}

void sub_1B3032130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  CGColorSpace *v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, CGColorSpace *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

float *PCGuessAlphaType<PCBitmap_t<PCPixel4<ProCore::Private::PixelInfoTemplate<(PCPixelFormat::ChannelOrder)17>>>>(uint64_t a1, int *a2, char *a3, _BYTE *a4)
{
  float *result;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  float v15;
  float v16;
  char v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  int v30;
  int v31;
  int v32;
  _BOOL4 v33;
  _BOOL4 v35;
  int v36;
  int v37;
  float v38;
  char v39;
  float v40;
  float v41;
  int v42;
  char v43;
  BOOL v44;
  float *v45;
  unsigned int v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  BOOL v56;
  char v58;
  float *v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  BOOL v65;
  int v67;
  float v68;
  float v69;
  float v70;
  uint64_t v71;
  OZChannelBase v72;

  result = (float *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v9 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
  if (v9)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0.0;
    v16 = *result;
    v17 = 1;
    v18 = 0.0;
    v19 = 0.0;
    v20 = 0.0;
    v21 = 0.0;
    v22 = 0.0;
    v23 = *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28);
    do
    {
      v24 = *result;
      v25 = result[1];
      v27 = result[2];
      v26 = result[3];
      if (*result == 0.0)
      {
        if (v10)
        {
          if (v15 != v25 || v18 != v27 || v19 != v26)
          {
            v11 = 0;
            v30 = (int)vabds_f32(v25, v15);
            if (v14 <= v30)
              v14 = v30;
            v31 = (int)vabds_f32(v27, v18);
            v32 = (int)vabds_f32(v26, v19);
            if (v14 <= v31)
              v14 = v31;
            if (v14 <= v32)
              v14 = v32;
          }
          v26 = v19;
          v27 = v18;
          v25 = v15;
        }
        else
        {
          v11 = 1;
        }
        ++v10;
        v19 = v26;
        v18 = v27;
        v15 = v25;
      }
      else if (v24 == 1.0)
      {
        if (v12)
        {
          v33 = v20 == v25;
          if (v21 != v27)
            v33 = 0;
          if (v22 != v26)
            v33 = 0;
          v13 &= v33;
        }
        else
        {
          v13 = 1;
          v22 = result[3];
          v21 = result[2];
          v20 = result[1];
        }
        ++v12;
      }
      v17 &= v24 == v16;
      result += 4;
      --v23;
    }
    while (v23);
  }
  else
  {
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v11 = 0;
    v10 = 0;
    v22 = 0.0;
    v21 = 0.0;
    v17 = 1;
    v20 = 0.0;
    v19 = 0.0;
    v18 = 0.0;
    v15 = 0.0;
  }
  v35 = v10 == v9 || v12 == v9;
  v36 = (v10 > v9 / 0x64) & v11;
  if (v12 > v9 / 0x64)
    v37 = v13 & (v36 ^ 1);
  else
    v37 = 0;
  if (!v35 && ((v11 | v13) & 1) == 0 && v14 < 3)
  {
    v68 = v21;
    v69 = v22;
    v38 = 2.0;
    v18 = 0.0;
    v19 = 0.0;
    v15 = 0.0;
LABEL_48:
    v39 = 1;
    v40 = v18;
    v41 = v15;
    v22 = v19;
    goto LABEL_52;
  }
  if (((v36 | v37) & 1) == 0)
  {
    v42 = 0;
    v43 = 1;
    v44 = 1;
    if (!v35)
      goto LABEL_75;
    goto LABEL_50;
  }
  v38 = 0.0;
  v68 = v21;
  v69 = v22;
  if ((v36 & 1) != 0)
    goto LABEL_48;
  v39 = 0;
  v40 = v21;
  v41 = v20;
LABEL_52:
  result = (float *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  v44 = v9 == 0;
  if (v9)
  {
    v45 = result + 2;
    v46 = v9;
    do
    {
      v47 = *(v45 - 2);
      if ((v37 & 1) != 0)
        v47 = 1.0 - v47;
      if (v47 > 0.0)
      {
        v48 = 1.0 / v47;
        v49 = 1.0 - v47;
        v50 = (float)(*(v45 - 1) - (float)(v41 * v49)) - v38;
        v51 = (float)(*v45 - (float)(v40 * v49)) - v38;
        v52 = (float)(v45[1] - (float)(v22 * v49)) - v38;
        if (v50 >= 0.0)
          v53 = v50;
        else
          v53 = 0.0;
        if (v51 < 0.0)
          v51 = 0.0;
        if (v52 < 0.0)
          v52 = 0.0;
        v54 = v48 * v51;
        v55 = v48 * v52;
        v56 = (float)(v48 * v53) <= 1.0 && v54 <= 1.0;
        if (!v56 || v55 > 1.0)
          break;
      }
      --v46;
      v45 += 4;
      v44 = v46 == 0;
    }
    while (v46);
  }
  if ((v39 & 1) != 0)
  {
    v43 = 0;
    v42 = 1;
    v21 = v68;
    v22 = v69;
    if (!v35)
      goto LABEL_75;
LABEL_50:
    *a2 = 0;
LABEL_77:
    *a3 = 0;
    goto LABEL_104;
  }
  v21 = v68;
  v22 = v69;
  if (v20 == 0.0 && v68 == 0.0 && v69 == 0.0)
    goto LABEL_81;
  result = (float *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64));
  if (v9)
  {
    v59 = result + 2;
    while (1)
    {
      v60 = *(v59 - 2);
      if (v60 > 0.0)
      {
        v61 = 1.0 / v60;
        v62 = v61 * *(v59 - 1);
        v63 = v61 * *v59;
        v64 = v61 * v59[1];
        v65 = v62 <= 1.0 && v63 <= 1.0;
        if (!v65 || v64 > 1.0)
          break;
      }
      v59 += 4;
      if (!--v9)
        goto LABEL_97;
    }
LABEL_81:
    v43 = 0;
    v42 = 0;
    if (v35)
      goto LABEL_50;
    goto LABEL_75;
  }
LABEL_97:
  v43 = 0;
  v42 = 1;
  v19 = 0.0;
  v18 = 0.0;
  v15 = 0.0;
  if (v35)
    goto LABEL_50;
LABEL_75:
  if (v43 & 1 | !v44)
  {
    *a2 = 1;
    goto LABEL_77;
  }
  PCColor::PCColor((PCColor *)&v72.var1);
  PCImage::getColorSpace((PCImage *)a1, (CGColorSpace **)&v72);
  if (v42)
  {
    PCColor::setRGB((PCColor *)&v72.var1, v15 / 255.0, v18 / 255.0, v19 / 255.0, &v72);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72);
    v58 = 0;
  }
  else
  {
    PCColor::setRGB((PCColor *)&v72.var1, v20 / 255.0, v21 / 255.0, v22 / 255.0, &v72);
    PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72);
    v58 = 1;
  }
  *a3 = v58;
  v71 = 0;
  v70 = 0.0;
  PCColorSpaceCache::rec709Linear((CGColorSpace **)&v72);
  PCColor::getRGB((PCColor *)&v72.var1, (float *)&v71 + 1, (float *)&v71, &v70, (const PCColorSpaceHandle *)&v72);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72);
  if (*((float *)&v71 + 1) * 0.2126 + *(float *)&v71 * 0.7152 + v70 * 0.0722 >= 0.5)
    v67 = 3;
  else
    v67 = 2;
  *a2 = v67;
  result = (float *)PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)&v72.var7);
LABEL_104:
  *a4 = v17 ^ 1;
  return result;
}

void sub_1B303269C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  CGColorSpace *v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, CGColorSpace *);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

uint64_t MyCG_AddFrame(const PMFormatDescription *a1, const PCURL *a2, PCBitmap *a3, void *a4)
{
  return 10;
}

uint64_t MyCG_CanRead()
{
  return 0;
}

uint64_t MyCG_CanWrite()
{
  return 0;
}

uint64_t MyCG_SupportsMultipleFrames()
{
  return 0;
}

const char *MyCG_GetName()
{
  return "MyCoreGraphics";
}

uint64_t MyCG_GetComponentType()
{
  return 1246775072;
}

const char *MyCG_GetExtension()
{
  return "jpg";
}

uint64_t MyCG_GetVersion()
{
  return 0x10000;
}

uint64_t MyCG_SupportsVideoOptions()
{
  return 0;
}

uint64_t MyCG_IsStill(void)
{
  return 1;
}

uint64_t initMyCoreGraphicsPlugin(PMMediaManager *a1)
{
  uint64_t v2;

  v2 = operator new();
  PMPluginInterface::PMPluginInterface((PMPluginInterface *)v2);
  *(_QWORD *)v2 = MyCG_Open;
  *(_QWORD *)(v2 + 8) = MyCG_Create;
  *(_QWORD *)(v2 + 16) = MyCG_Close;
  *(_QWORD *)(v2 + 24) = MyCG_GetInfo;
  *(_QWORD *)(v2 + 32) = MyCG_GetLayerDescription;
  *(_QWORD *)(v2 + 40) = MyCG_GetAlphaFormat;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_QWORD *)(v2 + 80) = MyCG_GetFrame;
  *(_QWORD *)(v2 + 88) = MyCG_AddFrame;
  *(_QWORD *)(v2 + 96) = 0;
  *(_QWORD *)(v2 + 104) = 0;
  *(_QWORD *)(v2 + 200) = MyCG_SetVideoOptions;
  *(_QWORD *)(v2 + 208) = 0;
  *(_QWORD *)(v2 + 216) = MyCG_CanRead;
  *(_QWORD *)(v2 + 224) = MyCG_CanWrite;
  *(_QWORD *)(v2 + 232) = MyCG_SupportsMultipleFrames;
  *(_QWORD *)(v2 + 240) = MyCG_GetName;
  *(_QWORD *)(v2 + 248) = MyCG_GetComponentType;
  *(_QWORD *)(v2 + 256) = MyCG_GetExtension;
  *(_QWORD *)(v2 + 264) = MyCG_GetVersion;
  *(_QWORD *)(v2 + 272) = 0;
  *(_QWORD *)(v2 + 280) = MyCG_MakeIdle;
  *(_QWORD *)(v2 + 288) = 0;
  *(_QWORD *)(v2 + 296) = 0;
  *(_QWORD *)(v2 + 304) = 0;
  *(_QWORD *)(v2 + 312) = MyCG_SupportsVideoOptions;
  *(_QWORD *)(v2 + 320) = 0;
  *(_QWORD *)(v2 + 112) = 0;
  *(_QWORD *)(v2 + 120) = 0;
  *(_QWORD *)(v2 + 128) = 0;
  *(_QWORD *)(v2 + 176) = 0;
  *(_QWORD *)(v2 + 184) = 0;
  *(_QWORD *)(v2 + 168) = 0;
  *(_QWORD *)(v2 + 336) = MyCG_IsStill;
  PMMediaManager::addPlugin(a1, v2);
  return v2;
}

void sub_1B303286C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1B5E29170](v1, 0x80C40B3C365DALL);
  _Unwind_Resume(a1);
}

void PMStillInstance::PMStillInstance(PMStillInstance *this)
{
  *((_QWORD *)this + 7) = 0;
  *(_QWORD *)this = off_1E65EC6E8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 6) = (char *)this + 56;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = (char *)this + 80;
}

void PMStillInstance::~PMStillInstance(PMStillInstance *this)
{
  *(_QWORD *)this = off_1E65EC6E8;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 72, *((_QWORD **)this + 10));
  std::__tree<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::__map_value_compare<std::pair<unsigned int,unsigned long long>,std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::less<std::pair<unsigned int,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>>>::destroy((uint64_t)this + 48, *((_QWORD **)this + 7));
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t PMStillInstance::open(PMStillInstance *this, const __CFURL **a2)
{
  const __CFURL *v4;
  const __CFString *v5;
  const __CFString *v6;
  CFIndex Length;
  PCURL *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  PCString *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  __int128 v20;
  PCString v21;
  CFErrorRef error;

  v4 = *a2;
  error = 0;
  PCURL::getAsFileSystemString(a2, &v21);
  if (PCString::empty(&v21)
    || (v5 = CFURLCopyScheme(v4), (v6 = v5) == 0)
    || (Length = CFStringGetLength(v5), CFRelease(v6), !Length))
  {
LABEL_19:
    v18 = 3;
    goto LABEL_20;
  }
  if (!CFURLResourceIsReachable(v4, &error))
  {
    if (error)
      CFRelease(error);
    goto LABEL_19;
  }
  v8 = (PCURL *)operator new();
  PCURL::PCURL(v8, (const PCURL *)a2);
  std::shared_ptr<PCURL>::shared_ptr[abi:ne180100]<PCURL,void>(&v20, (uint64_t)v8);
  std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)this + 8, &v20);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = (PCString *)operator new();
  PCString::PCString(v12, &v21);
  std::shared_ptr<PCString>::shared_ptr[abi:ne180100]<PCString,void>(&v20, (uint64_t)v12);
  std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)this + 24, &v20);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  do
  {
    v16 = __ldaxr(&getNextHashSalt(void)::hashSalt);
    v17 = v16 + 1;
  }
  while (__stlxr(v17, &getNextHashSalt(void)::hashSalt));
  v18 = 0;
  *((_QWORD *)this + 5) = v17;
LABEL_20:
  PCString::~PCString(&v21);
  return v18;
}

void sub_1B3032AD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
  uint64_t v11;

  MEMORY[0x1B5E29170](v11, 0x60C4044C4A2DFLL);
  PCString::~PCString(&a11);
  _Unwind_Resume(a1);
}

BOOL PMStillInstance::isOpen(PMStillInstance *this)
{
  const __CFURL **v1;
  const __CFURL *v2;
  int IsReachable;
  _BOOL8 v4;
  CFErrorRef error;

  v1 = (const __CFURL **)*((_QWORD *)this + 1);
  if (!v1)
    return 0;
  v2 = *v1;
  error = 0;
  IsReachable = CFURLResourceIsReachable(v2, &error);
  v4 = IsReachable != 0;
  if (!IsReachable)
    CFRelease(error);
  return v4;
}

void PMStillInstance::close(PMStillInstance *this)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  char *v5;
  char *v6;
  char *v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;

  v3 = *((_QWORD *)this + 1);
  v2 = (_QWORD *)((char *)this + 8);
  if (v3)
  {
    std::shared_ptr<OZFontFace>::reset[abi:ne180100](v2);
    v4 = (_QWORD *)*((_QWORD *)this + 9);
    v5 = (char *)this + 80;
    if (v4 != (_QWORD *)((char *)this + 80))
    {
      do
      {
        PMRemoveBitmapFromCache((const PCHash128 *)((char *)v4 + 28));
        v6 = (char *)v4[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = *(char **)v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            v7 = (char *)v4[2];
            v8 = *(_QWORD *)v7 == (_QWORD)v4;
            v4 = v7;
          }
          while (!v8);
        }
        v4 = v7;
      }
      while (v7 != v5);
    }
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 72, *((_QWORD **)this + 10));
    v9 = (_QWORD *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 9) = v5;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 11) = 0;
    std::__tree<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::__map_value_compare<std::pair<unsigned int,unsigned long long>,std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::less<std::pair<unsigned int,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>>>::destroy((uint64_t)this + 48, v9);
    *((_QWORD *)this + 6) = (char *)this + 56;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 8) = 0;
  }
  v11 = *((_QWORD *)this + 3);
  v10 = (_QWORD *)((char *)this + 24);
  if (v11)
    std::shared_ptr<OZFontFace>::reset[abi:ne180100](v10);
}

uint64_t PMStillInstance::computeRawBitmapCacheKey(const void **this, int8x8_t *a2, const PMFormatDescription *a3, const PMFrameRequest *a4)
{
  PCHashWriteStream::writeValue(a2, this[3]);
  (*(void (**)(int8x8_t *, _QWORD))(*(_QWORD *)a2 + 56))(a2, *((unsigned int *)a4 + 23));
  return (*(uint64_t (**)(int8x8_t *, const void *))(*(_QWORD *)a2 + 64))(a2, this[5]);
}

void PMStillInstance::getCacheKey(PMStillInstance *this, const PMFormatDescription *a2, const PMFrameRequest *a3, const FxColorDescription *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  _OWORD *v13;
  int8x8_t v14[521];

  MEMORY[0x1E0C80A78](this);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v14[520] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v14);
  (*(void (**)(uint64_t, int8x8_t *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 40))(v11, v14, v9, v7, v5);
  *v13 = *(_OWORD *)PCHashWriteStream::getHash(v14)->i8;
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v14);
}

void sub_1B3032D78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _Unwind_Resume(exception_object);
}

void PMStillInstance::getRawBitmapCacheKey(PMStillInstance *this, const PMFormatDescription *a2, const PMFrameRequest *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD *v9;
  _OWORD *v10;
  int8x8_t v11[521];

  MEMORY[0x1E0C80A78](this);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v11[520] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v11);
  (*(void (**)(uint64_t, int8x8_t *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v11, v6, v4);
  *v10 = *(_OWORD *)PCHashWriteStream::getHash(v11)->i8;
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v11);
}

void sub_1B3032E54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _Unwind_Resume(exception_object);
}

void PMStillInstance::getRawBitmap(uint64_t **this@<X0>, const PMFormatDescription *a2@<X1>, const PMFrameRequest *a3@<X2>, _QWORD *a4@<X8>)
{
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  const PCString *v10;
  double Seconds;
  id v12;
  __int128 v13;
  _BYTE v14[32];
  _OWORD _40[4];

  PMStillInstance::getRawBitmapCacheKey((PMStillInstance *)this, a2, a3);
  PMGetCachedBitmap((const PCHash128 *)_40, a4);
  if (!*a4)
  {
    PCTimer::PCTimer((PCTimer *)v14);
    PCTimer::start((PCTimer *)v14);
    ((void (*)(__int128 *__return_ptr, uint64_t **, const PMFrameRequest *))(*this)[9])(&v13, this, a3);
    std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)a4, &v13);
    v7 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (*((_QWORD *)&v13 + 1))
    {
      v8 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    PCTimer::stop((PCTimer *)v14);
    if (*a4)
    {
      Seconds = PCTimer::getSeconds((PCTimer *)v14);
      PMCacheBitmap((PCHash128 *)_40, a4, &v12, Seconds);
      ProCore_Impl::PCNSRefImpl::release(&v12);
      std::__tree<PCHash128>::__emplace_unique_key_args<PCHash128,PCHash128 const&>(this + 9, (const PCHash128 *)_40, _40);
    }
    OZChannelBase::setRangeName((OZChannelBase *)v14, v10);
  }
}

void sub_1B3032F78(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, uint64_t a4, OZChannelBase *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;

  OZChannelBase::setRangeName((OZChannelBase *)&a13, a2);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v13);
  _Unwind_Resume(a1);
}

CGColorSpace **PMStillInstance::getColorConformDescriptions(PMStillInstance *this, const PMFrameRequest *a2, FxColorDescription *a3, FxColorDescription *a4, FxColorDescription *a5)
{
  CGColorSpace *OverrideColorSpace;
  CGColorSpace *CGColorSpace;
  int DynamicRange;
  int v12;
  uint64_t v13;
  char isPremultiplied;
  CGColorSpace *obj;
  CGColorSpace *v16;
  uint64_t v17;
  CGColorSpace *v18;
  uint64_t *ToneMapMethod;
  int v20;
  CGColorSpace *v21;
  CGColorSpace *v22;
  uint64_t v24;
  CGColorSpace *v25;
  int v26;
  PCToneMapMethod v27;
  BOOL v28;
  uint64_t v29;
  FxColorDescription v30;

  (*(void (**)(FxColorDescription *__return_ptr))(*(_QWORD *)this + 64))(&v30);
  OverrideColorSpace = (CGColorSpace *)PMFrameRequest::getOverrideColorSpace(a2);
  CGColorSpace = OverrideColorSpace;
  if (OverrideColorSpace)
  {
    DynamicRange = PCIsHDRColorSpace(OverrideColorSpace);
  }
  else
  {
    CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace(&v30);
    DynamicRange = FxColorDescription::getDynamicRange(&v30);
  }
  v12 = DynamicRange;
  PMFrameRequest::getColorDescriptionOverrideToneMapMethod(a2, a3);
  v29 = v13;
  isPremultiplied = FxColorDescription::isPremultiplied(&v30);
  FxColorDescription::FxColorDescription((uint64_t)&v25, CGColorSpace, v12, &v29, isPremultiplied);
  obj = a4->_pcColorDesc._colorSpaceRef._obj;
  v16 = v25;
  if (a4->_pcColorDesc._colorSpaceRef._obj && obj != v25)
  {
    PCCFRefTraits<CGColorSpace *>::release(obj);
    v16 = v25;
  }
  a4->_pcColorDesc._colorSpaceRef._obj = v16;
  v25 = 0;
  a4->_pcColorDesc._dynamicRange = v26;
  a4->_pcColorDesc._toneMapMethod = v27;
  a4->_isPremultiplied = v28;
  PCCFRef<CGColorSpace *>::~PCCFRef(&v25);
  v17 = FxColorDescription::getCGColorSpace(a3);
  if (v17)
    v18 = (CGColorSpace *)v17;
  else
    v18 = CGColorSpace;
  if (PMFrameRequest::isDynamicRangeTrackingRender(a2))
    ToneMapMethod = (uint64_t *)FxColorDescription::getToneMapMethod(a3);
  else
    ToneMapMethod = &kPCNoToneMapMethod;
  v24 = *ToneMapMethod;
  v20 = FxColorDescription::getDynamicRange(a3);
  FxColorDescription::FxColorDescription((uint64_t)&v25, v18, v20, &v24, 1);
  v21 = a5->_pcColorDesc._colorSpaceRef._obj;
  v22 = v25;
  if (a5->_pcColorDesc._colorSpaceRef._obj && v21 != v25)
  {
    PCCFRefTraits<CGColorSpace *>::release(v21);
    v22 = v25;
  }
  a5->_pcColorDesc._colorSpaceRef._obj = v22;
  v25 = 0;
  a5->_pcColorDesc._dynamicRange = v26;
  a5->_pcColorDesc._toneMapMethod = v27;
  a5->_isPremultiplied = v28;
  PCCFRef<CGColorSpace *>::~PCCFRef(&v25);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v30._pcColorDesc._colorSpaceRef._obj);
}

void sub_1B303313C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  CGColorSpace *v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, CGColorSpace *);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  _Unwind_Resume(a1);
}

double PMStillInstance::getEffectiveResolutionModeScale(PMStillInstance *this, const PMFrameRequest *a2)
{
  return PMFrameRequest::getResolutionModeScale(a2);
}

uint64_t PMStillInstance::wantsColorClamping(PMStillInstance *this)
{
  return 0;
}

uint64_t PMStillInstance::getCachedBitmap@<X0>(uint64_t **this@<X0>, const PMFormatDescription *a2@<X1>, const PMFrameRequest *a3@<X2>, const PCHash128 *a4@<X4>, _QWORD *a5@<X8>)
{
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  const PCString *v14;
  double Seconds;
  id v17;
  __int128 v18;
  _BYTE _20[96];

  *a5 = 0;
  a5[1] = 0;
  PCTimer::PCTimer((PCTimer *)_20);
  PCTimer::start((PCTimer *)_20);
  PMStillInstance::getRawBitmap(this, a2, a3, &v18);
  std::shared_ptr<TXTextObject>::operator=[abi:ne180100]((uint64_t)a5, &v18);
  v11 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
  if (*((_QWORD *)&v18 + 1))
  {
    v12 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  PCTimer::stop((PCTimer *)_20);
  if (*a5)
  {
    Seconds = PCTimer::getSeconds((PCTimer *)_20);
    PMCacheBitmap(a4, a5, &v17, Seconds);
    ProCore_Impl::PCNSRefImpl::release(&v17);
  }
  return OZChannelBase::setRangeName((OZChannelBase *)_20, v14);
}

void sub_1B3033278(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, uint64_t a4, OZChannelBase *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;

  OZChannelBase::setRangeName((OZChannelBase *)&a13, a2);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100](v13);
  _Unwind_Resume(a1);
}

double PMStillInstance::computePixelTransform(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6)
{
  double v10;
  double v11;
  float64x2_t v12;
  double v13;
  float64x2_t v14;
  double result;

  *(_QWORD *)(a6 + 120) = 0x3FF0000000000000;
  *(_QWORD *)(a6 + 80) = 0x3FF0000000000000;
  *(_QWORD *)(a6 + 40) = 0x3FF0000000000000;
  *(_QWORD *)a6 = 0x3FF0000000000000;
  *(_OWORD *)(a6 + 8) = 0u;
  *(_OWORD *)(a6 + 24) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)(a6 + 64) = 0u;
  *(_OWORD *)(a6 + 88) = 0u;
  *(_OWORD *)(a6 + 104) = 0u;
  v10 = (double)a4;
  v11 = (double)a5;
  v12 = PCMatrix44Tmpl<double>::leftScale((float64x2_t *)a6, (double)(a4 - 2) / (double)a4, (double)(a5 - 2) / (double)a5, 1.0);
  v13 = (*(double (**)(uint64_t, uint64_t, float64x2_t))(*(_QWORD *)a1 + 80))(a1, a3, v12);
  v14 = PCMatrix44Tmpl<double>::leftScale((float64x2_t *)a6, v13 / *(double *)(a2 + 416), -v13, 1.0);
  v14.f64[0] = v10 * 0.5;
  *(_QWORD *)&result = *(_OWORD *)&PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a6, v14, v11 * 0.5, 0.0);
  return result;
}

uint64_t PMStillInstance::getBitmapNode(uint64_t a1, uint64_t a2, uint64_t a3, PCBitmap **a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  PMBitmapToHeliumNode(a4, &v17);
  v12 = *a5;
  v13 = v17;
  if (*a5 == v17)
  {
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  }
  else
  {
    if (v12)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
      v13 = v17;
    }
    *a5 = v13;
  }
  v14 = (*(uint64_t (**)(PCBitmap *))(*(_QWORD *)*a4 + 16))(*a4);
  v15 = (*(uint64_t (**)(PCBitmap *))(*(_QWORD *)*a4 + 24))(*a4);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, a2, a3, v14, v15, a6);
  return 0;
}

void sub_1B3033450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 24))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t PMStillInstance::getFrameCPU(uint64_t **a1, const PMFormatDescription *a2, const PMFrameRequest *a3, uint64_t a4, const PCHash128 *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v12;
  HGNode *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  PCBitmap *v19;
  std::__shared_weak_count *v20;

  PMStillInstance::getCachedBitmap(a1, a2, a3, a5, &v19);
  if (v19)
  {
    PMStillInstance::getBitmapNode((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, &v19, a6, a7);
    v12 = 0;
  }
  else
  {
    v13 = (HGNode *)HGObject::operator new(0x1A0uLL);
    HGNode::HGNode(v13);
    v14 = *a6;
    if ((HGNode *)*a6 == v13)
    {
      if (v13)
        (*(void (**)(HGNode *))(*(_QWORD *)v13 + 24))(v13);
    }
    else
    {
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
      *a6 = (uint64_t)v13;
    }
    *(_QWORD *)(a7 + 120) = 0x3FF0000000000000;
    *(_QWORD *)(a7 + 80) = 0x3FF0000000000000;
    *(_QWORD *)(a7 + 40) = 0x3FF0000000000000;
    *(_QWORD *)a7 = 0x3FF0000000000000;
    *(_OWORD *)(a7 + 8) = 0u;
    *(_OWORD *)(a7 + 24) = 0u;
    *(_OWORD *)(a7 + 48) = 0u;
    *(_OWORD *)(a7 + 64) = 0u;
    *(_OWORD *)(a7 + 88) = 0u;
    v12 = 10;
    *(_OWORD *)(a7 + 104) = 0u;
  }
  v15 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return v12;
}

void sub_1B30335A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  std::shared_ptr<HGCPUComputeDevice const>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t PMStillInstance::getFramePixelBuffer(PMStillInstance *a1, uint64_t a2, const PMFrameRequest *a3, FxColorDescription *a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  __CVBuffer *v13;
  HGCVPixelBuffer *v14;
  HGCV *PixelFormatType;
  char *v16;
  int v17;
  HGBitmap *v18;
  HGBitmapLoader *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t Width;
  size_t Height;
  int StillImageInverseToneMapOperator_Deprecated;
  CGColorSpace *v27;
  uint64_t v28;
  uint64_t v29;
  CGColorSpace *CGColorSpace;
  uint64_t v32;
  FxColorDescription v33;
  FxColorDescription v34;
  HGBitmap *v35;
  PCColorDescription v36;
  char v37;

  PCColorDescription::PCColorDescription(&v36);
  v37 = 1;
  v13 = (__CVBuffer *)(*(uint64_t (**)(PMStillInstance *, const PMFrameRequest *, PCColorDescription *))(*(_QWORD *)a1 + 96))(a1, a3, &v36);
  v14 = (HGCVPixelBuffer *)v13;
  if (!v13)
  {
    v23 = 10;
    goto LABEL_26;
  }
  PixelFormatType = (HGCV *)CVPixelBufferGetPixelFormatType(v13);
  v17 = HGCV::HGFormatForCVPixelFormat(PixelFormatType, 0, v16);
  HGCVBitmap::create(v14, v17, 0, &v35);
  v18 = v35;
  v19 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v19, v18);
  *((_DWORD *)v19 + 109) = 1;
  v20 = *a6;
  if ((HGBitmapLoader *)*a6 != v19)
  {
    if (v20)
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
    *a6 = (uint64_t)v19;
    (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v19 + 16))(v19);
  }
  PCColorDescription::PCColorDescription(&v34._pcColorDesc);
  v34._isPremultiplied = 1;
  PCColorDescription::PCColorDescription(&v33._pcColorDesc);
  v33._isPremultiplied = 1;
  PMStillInstance::getColorConformDescriptions(a1, a3, a4, &v34, &v33);
  FxApplyColorConform(a6, &v34, &v33, &v32);
  v21 = *a6;
  v22 = v32;
  if (*a6 == v32)
  {
    if (v21)
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
  }
  else
  {
    if (v21)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
      v22 = v32;
    }
    *a6 = v22;
  }
  Width = CVPixelBufferGetWidth((CVPixelBufferRef)v14);
  Height = CVPixelBufferGetHeight((CVPixelBufferRef)v14);
  (*(void (**)(PMStillInstance *, uint64_t, const PMFrameRequest *, size_t, size_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, a2, a3, Width, Height, a7);
  if (PMFrameRequest::isRenderForHDR_Deprecated(a3))
  {
    StillImageInverseToneMapOperator_Deprecated = PMFrameRequest::getStillImageInverseToneMapOperator_Deprecated(a3);
    if (StillImageInverseToneMapOperator_Deprecated == 1)
    {
      CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace(&v33);
      FxApplySDRToHDR((uint64_t)a6, CGColorSpace, 0, &v32);
      v28 = *a6;
      v29 = v32;
      if (*a6 != v32)
      {
        if (v28)
        {
LABEL_21:
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
          v29 = v32;
        }
LABEL_22:
        *a6 = v29;
        goto LABEL_23;
      }
      if (!v28)
        goto LABEL_23;
LABEL_28:
      (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
      goto LABEL_23;
    }
    if (StillImageInverseToneMapOperator_Deprecated == 2)
    {
      v27 = (CGColorSpace *)FxColorDescription::getCGColorSpace(&v33);
      FxApplySDRToHDR((uint64_t)a6, v27, 1, &v32);
      v28 = *a6;
      v29 = v32;
      if (*a6 != v32)
      {
        if (v28)
          goto LABEL_21;
        goto LABEL_22;
      }
      if (!v28)
        goto LABEL_23;
      goto LABEL_28;
    }
  }
LABEL_23:
  PCCFRef<CGColorSpace *>::~PCCFRef(&v33._pcColorDesc._colorSpaceRef._obj);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v34._pcColorDesc._colorSpaceRef._obj);
  (*(void (**)(HGBitmapLoader *))(*(_QWORD *)v19 + 24))(v19);
  if (v35)
    (*(void (**)(HGBitmap *))(*(_QWORD *)v35 + 24))(v35);
  v23 = 0;
LABEL_26:
  PCCFRef<CGColorSpace *>::~PCCFRef(&v36._colorSpaceRef._obj);
  return v23;
}

void sub_1B30338C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  CGColorSpace *v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CGColorSpace *v9;
  va_list va1;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, CGColorSpace *);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, CGColorSpace *);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  if (a2)
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va1);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va2);
  _Unwind_Resume(a1);
}

uint64_t PMStillInstance::getFrame(PMStillInstance *a1, const PMFormatDescription *a2, CFTypeRef *a3, uint64_t a4, FxColorDescription *a5, uint64_t *a6, uint64_t a7)
{
  CFTypeRef *v14;
  HGNode *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t FramePixelBuffer;
  HGNode *v19;
  uint64_t v20;
  CGColorSpace *CGColorSpace;
  uint64_t v22;
  uint64_t OverrideColorSpace;
  uint64_t v24;
  const void *v25;
  const HGRenderer *v26;
  uint64_t v27;
  __n128 v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  __int128 v35;
  unint64_t *p_shared_owners;
  unint64_t v38;
  CGColorSpace *v39;
  std::__shared_weak_count *v40;
  FxColorDescription v41;
  _BYTE v42[16];

  v14 = (CFTypeRef *)*((_QWORD *)a1 + 1);
  if (v14 && CFEqual(*v14, *a3))
  {
    if (((*(uint64_t (**)(PMStillInstance *))(*(_QWORD *)a1 + 32))(a1) & 1) == 0)
    {
      v15 = (HGNode *)HGObject::operator new(0x1A0uLL);
      HGNode::HGNode(v15);
      v16 = *a6;
      if ((HGNode *)*a6 == v15)
      {
        if (v15)
          (*(void (**)(HGNode *))(*(_QWORD *)v15 + 24))(v15);
      }
      else
      {
        if (v16)
          (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
        *a6 = (uint64_t)v15;
      }
      *(_QWORD *)(a7 + 120) = 0x3FF0000000000000;
      *(_QWORD *)(a7 + 80) = 0x3FF0000000000000;
      *(_QWORD *)(a7 + 40) = 0x3FF0000000000000;
      *(_QWORD *)a7 = 0x3FF0000000000000;
      v35 = 0uLL;
      *(_OWORD *)(a7 + 8) = 0u;
      *(_OWORD *)(a7 + 24) = 0u;
      *(_OWORD *)(a7 + 48) = 0u;
      *(_OWORD *)(a7 + 64) = 0u;
      *(_OWORD *)(a7 + 88) = 0u;
      FramePixelBuffer = 10;
LABEL_40:
      *(_OWORD *)(a7 + 104) = v35;
      return FramePixelBuffer;
    }
  }
  else
  {
    (*(void (**)(PMStillInstance *))(*(_QWORD *)a1 + 24))(a1);
    v17 = (*(uint64_t (**)(PMStillInstance *, CFTypeRef *))(*(_QWORD *)a1 + 16))(a1, a3);
    if ((_DWORD)v17)
    {
      FramePixelBuffer = v17;
      v19 = (HGNode *)HGObject::operator new(0x1A0uLL);
      HGNode::HGNode(v19);
      v20 = *a6;
      if ((HGNode *)*a6 == v19)
      {
        if (v19)
          (*(void (**)(HGNode *))(*(_QWORD *)v19 + 24))(v19);
      }
      else
      {
        if (v20)
          (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
        *a6 = (uint64_t)v19;
      }
      *(_QWORD *)(a7 + 120) = 0x3FF0000000000000;
      *(_QWORD *)(a7 + 80) = 0x3FF0000000000000;
      *(_QWORD *)(a7 + 40) = 0x3FF0000000000000;
      *(_QWORD *)a7 = 0x3FF0000000000000;
      v35 = 0uLL;
      *(_OWORD *)(a7 + 8) = 0u;
      *(_OWORD *)(a7 + 24) = 0u;
      *(_OWORD *)(a7 + 48) = 0u;
      *(_OWORD *)(a7 + 64) = 0u;
      *(_OWORD *)(a7 + 88) = 0u;
      goto LABEL_40;
    }
  }
  PMStillInstance::getCacheKey(a1, a2, (const PMFrameRequest *)a4, a5);
  CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace(a5);
  (*(void (**)(FxColorDescription *__return_ptr, PMStillInstance *))(*(_QWORD *)a1 + 64))(&v41, a1);
  v22 = FxColorDescription::getCGColorSpace(&v41);
  PCCFRef<CGColorSpace *>::~PCCFRef(&v41._pcColorDesc._colorSpaceRef._obj);
  if (!CGColorSpace)
  {
    OverrideColorSpace = PMFrameRequest::getOverrideColorSpace((PMFrameRequest *)a4);
    if (OverrideColorSpace)
      CGColorSpace = (CGColorSpace *)OverrideColorSpace;
    else
      CGColorSpace = (CGColorSpace *)v22;
  }
  FxColorDescription::setCGColorSpace(a5, CGColorSpace);
  v25 = *(const void **)(a4 + 152);
  if (!v25)
    return PMStillInstance::getFrameCPU((uint64_t **)a1, a2, (const PMFrameRequest *)a4, v24, (const PCHash128 *)v42, a6, a7);
  if (*(_BYTE *)(a4 + 145) || !v26)
    return PMStillInstance::getFrameCPU((uint64_t **)a1, a2, (const PMFrameRequest *)a4, v24, (const PCHash128 *)v42, a6, a7);
  v28.n128_f64[0] = FxDeviceGetComputeDeviceForRenderer(v26, &v39);
  if (v39 && *(void (***)(HGGPUComputeDevice *__hidden))v39 == off_1E6523A60)
  {
    v41._pcColorDesc._colorSpaceRef._obj = v39;
    *(_QWORD *)&v41._pcColorDesc._dynamicRange = v40;
    if (v40)
    {
      p_shared_owners = (unint64_t *)&v40->__shared_owners_;
      do
        v38 = __ldxr(p_shared_owners);
      while (__stxr(v38 + 1, p_shared_owners));
    }
  }
  else
  {
    v41._pcColorDesc._colorSpaceRef._obj = 0;
    *(_QWORD *)&v41._pcColorDesc._dynamicRange = 0;
  }
  v29 = v40;
  if (v40)
  {
    v30 = (unint64_t *)&v40->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v29->__on_zero_shared)(v29, v28);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  FramePixelBuffer = PMStillInstance::getFramePixelBuffer(a1, (uint64_t)a2, (const PMFrameRequest *)a4, a5, v27, a6, a7);
  v32 = *(std::__shared_weak_count **)&v41._pcColorDesc._dynamicRange;
  if (*(_QWORD *)&v41._pcColorDesc._dynamicRange)
  {
    v33 = (unint64_t *)(*(_QWORD *)&v41._pcColorDesc._dynamicRange + 8);
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  return FramePixelBuffer;
}

void sub_1B3033D18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::__map_value_compare<std::pair<unsigned int,unsigned long long>,std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::less<std::pair<unsigned int,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;

  if (a2)
  {
    std::__tree<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::__map_value_compare<std::pair<unsigned int,unsigned long long>,std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::less<std::pair<unsigned int,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::__map_value_compare<std::pair<unsigned int,unsigned long long>,std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>,std::less<std::pair<unsigned int,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned long long>,std::pair<PCHash128,HGRef<HGMetalTexture>>>>>::destroy(a1, a2[1]);
    v4 = a2[8];
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    operator delete(a2);
  }
}

_QWORD *std::shared_ptr<PCURL>::shared_ptr[abi:ne180100]<PCURL,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E65EC770;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B3033E58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<PCURL>::reset[abi:ne180100]((PCURL **)va, 0);
  _Unwind_Resume(a1);
}

PCURL *std::__shared_ptr_pointer<PCURL *,std::shared_ptr<PCURL>::__shared_ptr_default_delete<PCURL,PCURL>,std::allocator<PCURL>>::__on_zero_shared(uint64_t a1)
{
  PCURL *result;

  result = *(PCURL **)(a1 + 24);
  if (result)
  {
    PCURL::~PCURL(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<PCURL *,std::shared_ptr<PCURL>::__shared_ptr_default_delete<PCURL,PCURL>,std::allocator<PCURL>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::shared_ptr<PCString>::shared_ptr[abi:ne180100]<PCString,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E65EC7E8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B3033F48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<PCString>::reset[abi:ne180100]((PCString **)va, 0);
  _Unwind_Resume(a1);
}

PCString *std::__shared_ptr_pointer<PCString *,std::shared_ptr<PCString>::__shared_ptr_default_delete<PCString,PCString>,std::allocator<PCString>>::__on_zero_shared(uint64_t a1)
{
  PCString *result;

  result = *(PCString **)(a1 + 24);
  if (result)
  {
    PCString::~PCString(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<PCString *,std::shared_ptr<PCString>::__shared_ptr_default_delete<PCString,PCString>,std::allocator<PCString>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

PCString *std::unique_ptr<PCString>::reset[abi:ne180100](PCString **a1, PCString *a2)
{
  PCString *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    PCString::~PCString(result);
    JUMPOUT(0x1B5E29170);
  }
  return result;
}

void PMPluginInterface::PMPluginInterface(PMPluginInterface *this)
{
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
}

void PMCacheBitmap(PCHash128 *a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>, double a4@<D0>)
{
  int v8;
  const __CFString *v9;
  PMObjectCache *v10;
  PCString v11;

  if (*a2)
  {
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    PCHash128::getString(a1, &v11);
    v9 = PCString::ns_str(&v11);
    PCString::~PCString(&v11);
    v11.var0 = (__CFString *)-[PMCachedBitmapObject initWithBitmap:]([PMCachedBitmapObject alloc], "initWithBitmap:", a2);
    v10 = +[PMObjectCache sharedInstance](PMObjectCache, "sharedInstance");
    -[PMObjectCache addObject:cacheKey:size:cost:](v10, "addObject:cacheKey:size:cost:", v11.var0, v9, (v8 + 88), a4);
    *a3 = 0;
    ProCore_Impl::PCNSRefImpl::release((id *)&v11.var0);
  }
  else
  {
    *a3 = 0;
  }
}

void sub_1B3034230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

uint64_t PMRemoveBitmapFromCache(const PCHash128 *a1)
{
  const __CFString *v1;
  PCString v3;

  PCHash128::getString(a1, &v3);
  v1 = PCString::ns_str(&v3);
  PCString::~PCString(&v3);
  return -[PMObjectCache removeObjectForKey:](+[PMObjectCache sharedInstance](PMObjectCache, "sharedInstance"), "removeObjectForKey:", v1);
}

void sub_1B30342A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString(&a10);
  _Unwind_Resume(a1);
}

void PMGetCachedBitmap(const PCHash128 *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFString *v3;
  __CFString *v4;
  PCString v5;

  PCHash128::getString(a1, &v5);
  v3 = PCString::ns_str(&v5);
  PCString::~PCString(&v5);
  v4 = -[PMObjectCache copyObjectForKey:cost:](+[PMObjectCache sharedInstance](PMObjectCache, "sharedInstance"), "copyObjectForKey:cost:", v3, 0);
  v5.var0 = v4;
  if (v4)
  {
    -[__CFString bitmap](v4, "bitmap");
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  ProCore_Impl::PCNSRefImpl::release((id *)&v5.var0);
}

void sub_1B3034334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  ProCore_Impl::PCNSRefImpl::release((id *)&a10.var0);
  _Unwind_Resume(a1);
}

HGNode *PVHGApplyAuxiliaryMap::GetOutput(HGNode *this, HGRenderer *a2)
{
  HGNode *Input;
  HGNode *v5;
  unint64_t v6;
  unint64_t v7;
  HGNode *v8;
  unint64_t v9;
  unint64_t v10;
  HGXForm *v11;
  HgcApplyAuxiliaryMap *v12;
  HgcApplyAuxiliaryMap *v13;
  _BYTE v15[144];

  Input = HGRenderer::GetInput(a2, this, 0);
  v5 = HGRenderer::GetInput(a2, this, 1u);
  v6 = *((_QWORD *)this + 55);
  if (v6 <= 0xFFF)
  {
    if (v6)
    {
      v7 = *((_QWORD *)this + 56);
      if (v7 - 4096 >= 0xFFFFFFFFFFFFF001)
      {
        v8 = v5;
        v9 = *((_QWORD *)this + 53);
        v10 = *((_QWORD *)this + 54);
        v11 = (HGXForm *)HGObject::operator new(0x210uLL);
        HGXForm::HGXForm(v11);
        HGTransform::HGTransform((HGTransform *)v15);
        HGTransform::Scale((HGTransform *)v15, (float)((float)v9 / (float)v6), (float)((float)v10 / (float)v7), 1.0);
        (*(void (**)(HGXForm *, _QWORD, HGNode *))(*(_QWORD *)v11 + 120))(v11, 0, v8);
        (*(void (**)(HGXForm *, _BYTE *))(*(_QWORD *)v11 + 576))(v11, v15);
        v12 = (HgcApplyAuxiliaryMap *)HGObject::operator new(0x1A0uLL);
        HgcApplyAuxiliaryMap::HgcApplyAuxiliaryMap(v12);
        (*(void (**)(HgcApplyAuxiliaryMap *, _QWORD, HGNode *))(*(_QWORD *)v12 + 120))(v12, 0, Input);
        (*(void (**)(HgcApplyAuxiliaryMap *, uint64_t, HGXForm *))(*(_QWORD *)v12 + 120))(v12, 1, v11);
        (*(void (**)(HgcApplyAuxiliaryMap *, _QWORD, float, float, float, float))(*(_QWORD *)v12 + 96))(v12, 0, *((float *)this + 104), 0.0, 0.0, 0.0);
        v13 = (HgcApplyAuxiliaryMap *)*((_QWORD *)this + 51);
        Input = (HGNode *)v12;
        if (v13 != v12)
        {
          if (v13)
            (*(void (**)(HgcApplyAuxiliaryMap *))(*(_QWORD *)v13 + 24))(v13);
          *((_QWORD *)this + 51) = v12;
          (*(void (**)(HgcApplyAuxiliaryMap *))(*(_QWORD *)v12 + 16))(v12);
          Input = (HGNode *)*((_QWORD *)this + 51);
        }
        (*(void (**)(HgcApplyAuxiliaryMap *))(*(_QWORD *)v12 + 24))(v12);
        HGTransform::~HGTransform((HGTransform *)v15);
        (*(void (**)(HGXForm *))(*(_QWORD *)v11 + 24))(v11);
      }
    }
  }
  return Input;
}

void sub_1B3034C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void *v10;

  HGObject::operator delete(v10);
  HGTransform::~HGTransform((HGTransform *)&a9);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  _Unwind_Resume(a1);
}

uint64_t PVHGApplyAuxiliaryMap::SetParameter(PVHGApplyAuxiliaryMap *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 == 2)
  {
    if ((float)*((unint64_t *)this + 55) != a3 || (float)*((unint64_t *)this + 56) != a4)
    {
      *((_QWORD *)this + 55) = (unint64_t)a3;
      *((_QWORD *)this + 56) = (unint64_t)a4;
      return 1;
    }
  }
  else if (a2 == 1)
  {
    if ((float)*((unint64_t *)this + 53) != a3 || (float)*((unint64_t *)this + 54) != a4)
    {
      *((_QWORD *)this + 53) = (unint64_t)a3;
      *((_QWORD *)this + 54) = (unint64_t)a4;
      return 1;
    }
  }
  else
  {
    if (a2)
      return 0xFFFFFFFFLL;
    if (*((float *)this + 104) != a3)
    {
      *((float *)this + 104) = a3;
      return 1;
    }
  }
  return 0;
}

void PVHGApplyAuxiliaryMap::~PVHGApplyAuxiliaryMap(HGNode *this)
{
  void *v1;

  PVHGApplyAuxiliaryMap::~PVHGApplyAuxiliaryMap(this);
  HGObject::operator delete(v1);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E65EC860;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

void HGColorCorrect::HGColorCorrect(HGColorCorrect *this)
{
  _QWORD *v2;
  HgcColorCorrect *v3;
  HgcColorCorrect *v4;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65ECAC8;
  v2[51] = 0;
  v3 = (HgcColorCorrect *)HGObject::operator new(0x200uLL);
  HgcColorCorrect::HgcColorCorrect(v3);
  v4 = (HgcColorCorrect *)*((_QWORD *)this + 51);
  if (v4 == v3)
  {
    if (v3)
      (*(void (**)(HgcColorCorrect *))(*(_QWORD *)v3 + 24))(v3);
  }
  else
  {
    if (v4)
      (*(void (**)(HgcColorCorrect *))(*(_QWORD *)v4 + 24))(v4);
    *((_QWORD *)this + 51) = v3;
  }
}

void sub_1B3034DFC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v4 = *(_QWORD *)(v1 + 408);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGColorCorrect::~HGColorCorrect(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65ECAC8;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HGColorCorrect::~HGColorCorrect(this);
  HGObject::operator delete(v1);
}

uint64_t HGColorCorrect::SetParameter(HGColorCorrect *this, float a2, float a3, float a4, float a5)
{
  return (*(uint64_t (**)(_QWORD, float, float, float, float))(**((_QWORD **)this + 51) + 96))(*((_QWORD *)this + 51), a2, a3, a4, a5);
}

uint64_t HGColorCorrect::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3;
  HGNode *Input;

  v3 = *((_QWORD *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, _QWORD, HGNode *))(*(_QWORD *)v3 + 120))(v3, 0, Input);
  return *((_QWORD *)this + 51);
}

const char *HgcApplyAuxiliaryMap::GetProgram(HgcApplyAuxiliaryMap *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000003a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = mix(c0.xxx, half3(hg_Params[0].xyz), r0.xyz);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.xyz = float3(r1.xyz)*float3(r0.xyz);\n"
             "    output.color0.w = float(r1.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=be9d6af0:6016dd49:77d08db8:bcc61458\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000377\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).xyz;\n"
             "    r0.xyz = mix(c0.xxx, hg_Params[0].xyz, r0.xyz);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.xyz = r1.xyz*r0.xyz;\n"
             "    output.color0.w = r1.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5a708099:c9ffe141:8e47c2fe:6139bb5a\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000325\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture1, hg_TexCoord1.xy).xyz;\n"
           "    r0.xyz = mix(c0.xxx, hg_ProgramLocal0.xyz, r0.xyz);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor.xyz = r1.xyz*r0.xyz;\n"
           "    gl_FragColor.w = r1.w;\n"
           "}\n"
           "//MD5=184406a1:5249f001:2c7367ac:8a4d1966\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcApplyAuxiliaryMap::InitProgramDescriptor(HgcApplyAuxiliaryMap *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcApplyAuxiliaryMap_hgc_visible", "//Metal1.0     \n//LEN=00000001da\n[[ visible ]] FragmentOut HgcApplyAuxiliaryMap_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = color1.xyz;\n"
    "    r0.xyz = mix(c0.xxx, hg_Params[0].xyz, r0.xyz);\n"
    "    r1 = color0;\n"
    "    output.color0.xyz = r1.xyz*r0.xyz;\n"
    "    output.color0.w = r1.w;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B3034FDC()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcApplyAuxiliaryMap");
}

void sub_1B3034FEC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3051440;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B303512C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3035174()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B303516CLL);
}

_QWORD *HgcApplyAuxiliaryMap::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcApplyAuxiliaryMap [hgc1]");
}

uint64_t HgcApplyAuxiliaryMap::BindTexture(HgcApplyAuxiliaryMap *this, HGHandler *a2, int a3)
{
  HGHandler *v4;
  int v5;
  int v6;
  uint64_t result;

  if (a3)
  {
    if (a3 != 1)
      return 0xFFFFFFFFLL;
    (*(void (**)(HGHandler *, uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 1;
  }
  else
  {
    (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
    v4 = a2;
    v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcApplyAuxiliaryMap::Bind(HgcApplyAuxiliaryMap *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcApplyAuxiliaryMap *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcApplyAuxiliaryMap::RenderTile(HgcApplyAuxiliaryMap *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t *v20;
  uint64_t v21;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 26);
    v8 = *((_QWORD *)a2 + 12);
    v9 = 16 * *((int *)a2 + 22);
    v10 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v21) = 0;
      }
      else
      {
        v11 = 0;
        v12 = 32;
        do
        {
          v13 = *((_QWORD *)this + 51);
          v14 = *(float32x4_t *)(v13 + 16);
          v15 = vsubq_f32(*(float32x4_t *)v13, v14);
          v16 = *(int8x16_t *)(v13 + 32);
          v17 = vbslq_s8(v16, *(int8x16_t *)(v6 + v12 - 16), (int8x16_t)vmulq_f32(*(float32x4_t *)(v6 + v12 - 16), vmlaq_f32(v14, v15, *(float32x4_t *)(v8 + v12 - 16))));
          v18 = vbslq_s8(v16, *(int8x16_t *)(v6 + v12), (int8x16_t)vmulq_f32(vmlaq_f32(v14, v15, *(float32x4_t *)(v8 + v12)), *(float32x4_t *)(v6 + v12)));
          v19 = vbslq_s8(v16, *(int8x16_t *)(v6 + v12 + 16), (int8x16_t)vmulq_f32(vmlaq_f32(v14, v15, *(float32x4_t *)(v8 + v12 + 16)), *(float32x4_t *)(v6 + v12 + 16)));
          v20 = (int8x16_t *)(v5 + v12);
          v20[-2] = vbslq_s8(v16, *(int8x16_t *)(v6 + v12 - 32), (int8x16_t)vmulq_f32(*(float32x4_t *)(v6 + v12 - 32), vmlaq_f32(v14, v15, *(float32x4_t *)(v8 + v12 - 32))));
          v20[-1] = v17;
          *v20 = v18;
          v20[1] = v19;
          v11 -= 4;
          v12 += 64;
        }
        while (v4 + v11 > 3);
        LODWORD(v21) = -v11;
      }
      if ((int)v21 < v4)
      {
        v21 = v21;
        do
        {
          *(int8x16_t *)(v5 + 16 * v21) = vbslq_s8(*(int8x16_t *)(*((_QWORD *)this + 51) + 32), *(int8x16_t *)(v6 + 16 * v21), (int8x16_t)vmulq_f32(*(float32x4_t *)(v6 + 16 * v21), vmlaq_f32(*(float32x4_t *)(*((_QWORD *)this + 51) + 16), vsubq_f32(*(float32x4_t *)*((_QWORD *)this + 51), *(float32x4_t *)(*((_QWORD *)this + 51) + 16)), *(float32x4_t *)(v8 + 16 * v21))));
          ++v21;
        }
        while (v21 < v4);
      }
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcApplyAuxiliaryMap::GetDOD(HgcApplyAuxiliaryMap *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcApplyAuxiliaryMap::GetROI(HgcApplyAuxiliaryMap *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcApplyAuxiliaryMap::HgcApplyAuxiliaryMap(HgcApplyAuxiliaryMap *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65ECD30;
  v3 = (_OWORD *)operator new();
  *v3 = 0u;
  v3[1] = xmmword_1B3051560;
  v3[2] = xmmword_1B3050F70;
  v3[3] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B30354D0(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcApplyAuxiliaryMap::~HgcApplyAuxiliaryMap(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65ECD30;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FA0F61DDLL);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcApplyAuxiliaryMap::~HgcApplyAuxiliaryMap(this);
  HGObject::operator delete(v1);
}

uint64_t HgcApplyAuxiliaryMap::SetParameter(HgcApplyAuxiliaryMap *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  __n128 *v8;
  int32x4_t v9;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (__n128 *)*((_QWORD *)this + 51);
  if (v8->n128_f32[0] == a3.n128_f32[0]
    && v8->n128_f32[1] == a3.n128_f32[0]
    && v8->n128_f32[2] == a3.n128_f32[0]
    && v8->n128_f32[3] == 0.0)
  {
    return 0;
  }
  v9 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
  v9.i32[2] = a3.n128_u32[0];
  a3.n128_f32[1] = a4;
  *v8 = (__n128)v9;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v8[3] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcApplyAuxiliaryMap::GetParameter(HgcApplyAuxiliaryMap *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = v3[12];
    a3[1] = v3[13];
    a3[2] = v3[14];
    result = v3[15];
    a3[3] = result;
  }
  return result;
}

uint64_t HgcColorCorrect::Setup(HgcColorCorrect *this, void *a2)
{
  uint64_t v2;
  float32x4_t v3;
  float32x4_t v4;
  int8x16_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  int8x16_t v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  int8x16_t v106;
  int8x16_t v107;
  int8x16_t v108;
  int8x16_t v109;
  int8x16_t v110;
  int8x16_t v111;
  int8x16_t v112;
  float32x4_t v113;
  int8x16_t v114;
  int8x16_t v115;
  float32x4_t v116;
  int8x16_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int8x16_t v124;
  float32x4_t v125;
  int8x16_t v126;
  int8x16_t v127;
  int8x16_t v128;
  int8x16_t v129;
  int8x16_t v130;
  float32x4_t v131;
  float32x4_t v132;
  int8x16_t v133;
  int8x16_t v134;
  int8x16_t v135;
  int8x16_t v136;
  float32x4_t v137;
  float32x4_t v138;
  int8x16_t v139;
  int32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  int8x16_t v180;
  float32x4_t v181;
  int8x16_t v182;
  float32x4_t v183;
  int8x16_t v184;
  float32x4_t v185;
  int8x16_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  int8x16_t v191;
  int8x16_t v192;
  int8x16_t v193;
  int8x16_t v194;
  int8x16_t v195;
  int8x16_t v196;
  int8x16_t v197;
  int8x16_t v198;
  float32x4_t v199;
  float32x4_t v200;
  int8x16_t v201;
  float32x4_t v202;
  float32x4_t v203;
  int8x16_t v204;
  float32x4_t v205;
  float32x4_t v206;
  int8x16_t v207;
  float32x4_t v208;
  float32x4_t v209;
  int8x16_t v210;
  int8x16_t v211;
  int8x16_t v212;
  int8x16_t v213;
  int8x16_t v214;
  int8x16_t v215;
  int8x16_t v216;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;

  v2 = *((_QWORD *)this + 62);
  v3 = *(float32x4_t *)(v2 + 176);
  v5 = *(int8x16_t *)v2;
  v4 = *(float32x4_t *)(v2 + 16);
  v6 = (float32x4_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL);
  v7 = vmulq_laneq_f32(v6, v4, 2);
  v8 = *(float32x4_t *)(v2 + 208);
  v9 = *(float32x4_t *)(v2 + 224);
  v10 = vminq_f32(vmaxq_f32(vmulq_laneq_f32(v7, v4, 2), v8), v9);
  v11 = vminq_f32(vmaxq_f32(vrecpeq_f32(v10), v8), v9);
  v12 = vminq_f32(vmaxq_f32(vmulq_f32(v11, vrecpsq_f32(v10, v11)), v8), v9);
  v13 = vmulq_f32(v12, vrecpsq_f32(v10, v12));
  v14 = vminq_f32(vmaxq_f32(v7, v8), v9);
  v15 = vminq_f32(vmaxq_f32(vrecpeq_f32(v14), v8), v9);
  v16 = vminq_f32(vmaxq_f32(vmulq_f32(v15, vrecpsq_f32(v14, v15)), v8), v9);
  v17 = vmulq_f32(v16, vrecpsq_f32(v14, v16));
  v220 = *(float32x4_t *)(v2 + 864);
  v18 = vminq_f32(vmaxq_f32(v6, v8), v9);
  v19 = vminq_f32(vmaxq_f32(vrecpeq_f32(v18), v8), v9);
  v20 = vminq_f32(vmaxq_f32(vmulq_f32(v19, vrecpsq_f32(v18, v19)), v8), v9);
  v21 = vmulq_f32(v20, vrecpsq_f32(v18, v20));
  v22 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v2 + 256), vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_f32(v13, *(float32x4_t *)(v2 + 240)), v17, v220, 2), v21, v220, 3));
  v23 = *(float32x4_t *)(v2 + 832);
  v218 = *(float32x4_t *)(v2 + 848);
  v219 = v23;
  v24 = (int8x16_t)vaddq_f32(*(float32x4_t *)(v2 + 288), vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_f32(v13, *(float32x4_t *)(v2 + 272)), v17, v218, 2), v21, v218, 3));
  v25 = (int8x16_t)vcgtq_f32(v3, vsubq_f32(v6, *(float32x4_t *)(v2 + 192)));
  v26 = (float32x4_t)vbslq_s8(v25, v22, v24);
  v28 = *(float32x4_t *)(v2 + 800);
  v27 = *(float32x4_t *)(v2 + 816);
  v29 = vbslq_s8(v25, (int8x16_t)vsubq_f32(vmlaq_laneq_f32(vmlaq_f32(vmulq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)(v2 + 304), v26), v26), v26), v26, vmulq_f32(vnegq_f32(*(float32x4_t *)(v2 + 320)), v26)), v26, v23, 3), *(float32x4_t *)(v2 + 336)), (int8x16_t)vsubq_f32(vmlaq_laneq_f32(vmlaq_f32(vmulq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)(v2 + 352), v26), v26), v26), v26, vmulq_f32(vnegq_f32(*(float32x4_t *)(v2 + 368)), v26)), v26, v27,
                         3),
                       *(float32x4_t *)(v2 + 384)));
  v30 = *(float32x4_t *)(v2 + 464);
  v31 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v3, vsubq_f32(v6, *(float32x4_t *)(v2 + 400))), (int8x16_t)vsubq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(vmulq_f32(vmulq_f32(*(float32x4_t *)(v2 + 416), v26), v26), v26), v26, vmulq_f32(v26, vnegq_f32(*(float32x4_t *)(v2 + 432)))), *(float32x4_t *)(v2 + 448), v26), v30), v29);
  v32 = vminq_f32(vmaxq_f32(v31, v8), v9);
  v33 = vminq_f32(vmaxq_f32(vrecpeq_f32(v32), v8), v9);
  v34 = vminq_f32(vmaxq_f32(vmulq_f32(v33, vrecpsq_f32(v32, v33)), v8), v9);
  v35 = *(float32x4_t *)(v2 + 480);
  v36 = vmulq_f32(vmulq_f32(v34, vrecpsq_f32(v32, v34)), v35);
  v37.i32[0] = vmulq_f32(v36, v26).u32[0];
  v37.i32[1] = *(_DWORD *)"q=\n?";
  v37.i64[1] = vmulq_n_f32((float32x4_t)vdupq_lane_s64((uint64_t)vsubq_f32(vsubq_f32(v27, v26), v31), 0), *(float *)&v36).i64[1];
  v38 = vmulq_f32(*(float32x4_t *)(v2 + 496), v37);
  v39 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v38, 1), vaddq_f32(v38, (float32x4_t)vrev64q_s32((int32x4_t)v38)));
  v40 = *(int8x16_t *)(v2 + 528);
  v41 = vmulq_f32(*(float32x4_t *)(v2 + 512), v37);
  v42 = vmulq_f32(*(float32x4_t *)(v2 + 544), v37);
  v43 = (float32x4_t)vbslq_s8(v40, v39, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v23, 4uLL), vaddq_f32(v41, (float32x4_t)vrev64q_s32((int32x4_t)v41))));
  v43.i32[2] = vaddq_f32(v42, vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v42, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v42, 1))).i32[2];
  v44 = vmulq_f32(*(float32x4_t *)(v2 + 560), v43);
  v23.i32[0] = 1.0;
  v44.i32[3] = 1.0;
  v45 = vmulq_f32(*(float32x4_t *)(v2 + 128), v44);
  v46 = vmulq_f32(*(float32x4_t *)(v2 + 144), v44);
  v47 = vmulq_f32(*(float32x4_t *)(v2 + 160), v44);
  v48 = vmulq_f32(v3, v44);
  v49 = *(float32x4_t *)(v2 + 16);
  v50 = (float32x4_t)vrev64q_s32((int32x4_t)v49);
  v51 = vmulq_n_f32(*(float32x4_t *)v2, vsubq_f32(v27, v50).f32[0]);
  v52 = vaddq_f32(v51, (float32x4_t)vandq_s8(v40, (int8x16_t)v50));
  v53 = vmulq_f32(v52, v45);
  v54 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v53, 1), vaddq_f32(v53, (float32x4_t)vrev64q_s32((int32x4_t)v53)));
  v55 = vmulq_f32(v52, v46);
  v56 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v55, 1), vaddq_f32(v55, (float32x4_t)vrev64q_s32((int32x4_t)v55)));
  v57 = vmulq_f32(v52, v47);
  v58 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v57, 1), vaddq_f32(v57, (float32x4_t)vrev64q_s32((int32x4_t)v57)));
  v59 = vmulq_f32(v52, v48);
  v60 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v59, 1), vaddq_f32(v59, (float32x4_t)vrev64q_s32((int32x4_t)v59)));
  v62 = *(int8x16_t *)(v2 + 576);
  v61 = *(int8x16_t *)(v2 + 592);
  v63 = vaddq_f32(v51, (float32x4_t)vandq_s8(v62, (int8x16_t)v49));
  v64 = vmulq_f32(v63, v45);
  v54.i64[0] = vbslq_s8(v40, v54, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v64, (int8x16_t)v23, 4uLL), vaddq_f32(v64, (float32x4_t)vrev64q_s32((int32x4_t)v64)))).u64[0];
  v65 = vmulq_f32(v63, v46);
  v56.i64[0] = vbslq_s8(v40, v56, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v65, (int8x16_t)v23, 4uLL), vaddq_f32(v65, (float32x4_t)vrev64q_s32((int32x4_t)v65)))).u64[0];
  v66 = vmulq_f32(v63, v47);
  v58.i64[0] = vbslq_s8(v40, v58, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v66, (int8x16_t)v23, 4uLL), vaddq_f32(v66, (float32x4_t)vrev64q_s32((int32x4_t)v66)))).u64[0];
  v67 = vmulq_f32(v63, v48);
  v68 = vaddq_f32(v51, (float32x4_t)vandq_s8(v61, vextq_s8((int8x16_t)v49, (int8x16_t)v49, 0xCuLL)));
  v69 = vmulq_f32(v68, v45);
  v54.i64[1] = vaddq_f32(v69, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v69, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v23, *(int8x16_t *)&v69, 0xCuLL))).i64[1];
  v70 = vmulq_f32(v68, v46);
  v56.i64[1] = vaddq_f32(v70, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v70, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v23, *(int8x16_t *)&v70, 0xCuLL))).i64[1];
  v71 = vmulq_f32(v68, v47);
  v58.i64[1] = vaddq_f32(v71, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v71, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v23, *(int8x16_t *)&v71, 0xCuLL))).i64[1];
  v60.i64[0] = vbslq_s8(v40, v60, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v67, (int8x16_t)v23, 4uLL), vaddq_f32(v67, (float32x4_t)vrev64q_s32((int32x4_t)v67)))).u64[0];
  v72 = vmulq_f32(v68, v48);
  v60.i64[1] = vaddq_f32(v72, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v72, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v23, *(int8x16_t *)&v72, 0xCuLL))).i64[1];
  v73 = *(int8x16_t *)(v2 + 608);
  v74 = *(float32x4_t *)(v2 + 624);
  v75 = (float32x4_t)vbslq_s8(v73, (int8x16_t)v45, v54);
  v76 = (float32x4_t)vbslq_s8(v73, (int8x16_t)v46, v56);
  v77 = *(float32x4_t *)(v2 + 32);
  v78 = *(float32x4_t *)(v2 + 48);
  v79 = vmulq_f32(v77, v75);
  v80 = vmulq_f32(v77, v76);
  v81 = vmulq_f32(v77, (float32x4_t)vbslq_s8(v73, (int8x16_t)v47, v58));
  v82 = vmulq_f32(v77, (float32x4_t)vbslq_s8(v73, (int8x16_t)v48, v60));
  v83 = vmulq_laneq_f32(v74, v79, 3);
  v84 = vmulq_laneq_f32(v74, v80, 3);
  v85 = vmulq_laneq_f32(v74, v81, 3);
  v86 = vmulq_laneq_f32(v74, v82, 3);
  v87 = (int8x16_t)vmlaq_f32(v83, vsubq_f32(v79, v83), v78);
  v88 = (int8x16_t)vmlaq_f32(v84, vsubq_f32(v80, v84), v78);
  v89 = (int8x16_t)vmlaq_f32(v85, vsubq_f32(v81, v85), v78);
  v90 = (int8x16_t)vmlaq_f32(v86, vsubq_f32(v82, v86), v78);
  v91 = (float32x4_t)vextq_s8(v87, v87, 4uLL);
  v93 = *(float32x4_t *)(v2 + 640);
  v92 = *(float32x4_t *)(v2 + 656);
  v94 = vmulq_f32(v93, v91);
  v95 = vbslq_s8(v62, (int8x16_t)vaddq_f32(v94, (float32x4_t)vrev64q_s32((int32x4_t)v94)), v87);
  v96 = (float32x4_t)vextq_s8(v88, v88, 4uLL);
  v97 = vmulq_f32(v93, v96);
  v98 = vbslq_s8(v62, (int8x16_t)vaddq_f32(v97, (float32x4_t)vrev64q_s32((int32x4_t)v97)), v88);
  v99 = (float32x4_t)vextq_s8(v89, v89, 4uLL);
  v100 = vmulq_f32(v93, v99);
  v101 = vbslq_s8(v62, (int8x16_t)vaddq_f32(v100, (float32x4_t)vrev64q_s32((int32x4_t)v100)), v89);
  v102 = (float32x4_t)vextq_s8(v90, v90, 4uLL);
  v103 = vmulq_f32(v93, v102);
  v104 = (float32x4_t)vbslq_s8(v62, (int8x16_t)vaddq_f32(v103, (float32x4_t)vrev64q_s32((int32x4_t)v103)), v90);
  v105 = (int8x16_t)vmulq_f32(v92, v91);
  v106 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v105, v105, 8uLL), (float32x4_t)vextq_s8(v105, v105, 0xCuLL)), v95);
  v107 = (int8x16_t)vmulq_f32(v92, v96);
  v108 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v107, v107, 8uLL), (float32x4_t)vextq_s8(v107, v107, 0xCuLL)), v98);
  v109 = (int8x16_t)vmulq_f32(v92, v99);
  v110 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v109, v109, 8uLL), (float32x4_t)vextq_s8(v109, v109, 0xCuLL)), v101);
  v111 = (int8x16_t)vmulq_f32(v92, v102);
  v112 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v111, v111, 8uLL), (float32x4_t)vextq_s8(v111, v111, 0xCuLL)), (int8x16_t)v104);
  v113 = (float32x4_t)vextq_s8(v5, v5, 4uLL);
  v114 = (int8x16_t)vmulq_f32(v113, v92);
  v115 = vextq_s8((int8x16_t)v23, v114, 0xCuLL);
  *(float32x2_t *)v104.f32 = vadd_f32(*(float32x2_t *)v114.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v115, v115, 8uLL));
  v117 = *(int8x16_t *)(v2 + 672);
  v116 = *(float32x4_t *)(v2 + 688);
  *(int8x8_t *)v118.f32 = vqtbl1_s8(v106, *(int8x8_t *)v117.i8);
  v115.i64[0] = vextq_s8(v117, v117, 8uLL).u64[0];
  *(int8x8_t *)&v118.u32[2] = vqtbl1_s8(v106, *(int8x8_t *)v115.i8);
  v119 = vmulq_f32(v116, v118);
  *(int8x8_t *)v120.f32 = vqtbl1_s8(v108, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v120.u32[2] = vqtbl1_s8(v108, *(int8x8_t *)v115.i8);
  v121 = vmulq_f32(v116, v120);
  *(int8x8_t *)v122.f32 = vqtbl1_s8(v110, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v122.u32[2] = vqtbl1_s8(v110, *(int8x8_t *)v115.i8);
  v123 = vmulq_f32(v116, v122);
  v124 = (int8x16_t)vaddq_f32(v123, (float32x4_t)vrev64q_s32((int32x4_t)v123));
  *(int8x8_t *)v123.f32 = vqtbl1_s8(v112, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v123.u32[2] = vqtbl1_s8(v112, *(int8x8_t *)v115.i8);
  v125 = vmulq_f32(v116, v123);
  v126 = (int8x16_t)vaddq_f32(v125, (float32x4_t)vrev64q_s32((int32x4_t)v125));
  v127 = vbslq_s8(v40, (int8x16_t)vaddq_f32(v119, (float32x4_t)vrev64q_s32((int32x4_t)v119)), v106);
  v128 = vbslq_s8(v40, (int8x16_t)vaddq_f32(v121, (float32x4_t)vrev64q_s32((int32x4_t)v121)), v108);
  v129 = vbslq_s8(v40, v124, v110);
  v130 = vbslq_s8(v40, v126, v112);
  v131 = *(float32x4_t *)(v2 + 704);
  v132 = *(float32x4_t *)(v2 + 720);
  v133 = (int8x16_t)vmulq_f32(v118, v131);
  v134 = (int8x16_t)vmulq_f32(v120, v131);
  v135 = (int8x16_t)vmulq_f32(v122, v131);
  v5.i64[1] = v104.i64[0];
  *(int8x8_t *)v104.f32 = vqtbl1_s8(v5, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v104.u32[2] = vqtbl1_s8(v5, *(int8x8_t *)v115.i8);
  v136 = (int8x16_t)vmulq_f32(v131, v123);
  v137 = vmulq_f32(v116, v104);
  v138 = vmulq_f32(v113, v93);
  v137.i64[0] = vbslq_s8(v40, (int8x16_t)vaddq_f32(v137, (float32x4_t)vrev64q_s32((int32x4_t)v137)), (int8x16_t)vaddq_f32(v138, (float32x4_t)vrev64q_s32((int32x4_t)v138))).u64[0];
  v139 = (int8x16_t)vmulq_f32(v131, v104);
  v140 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_lane_s64(v139.i64[0], 0), (float32x4_t)vextq_s8(v130, v139, 0xCuLL));
  v137.i64[1] = v140.i64[1];
  v141 = vminq_f32(vmaxq_f32((float32x4_t)vdupq_laneq_s32(v140, 2), v8), v9);
  v142 = vminq_f32(vmaxq_f32(vrecpeq_f32(v141), v8), v9);
  v143 = vminq_f32(vmaxq_f32(vmulq_f32(v142, vrecpsq_f32(v141, v142)), v8), v9);
  v144 = vmulq_f32(vmulq_f32(v143, vrecpsq_f32(v141, v143)), v137);
  v145 = v144;
  v145.i32[2] = 1.0;
  v146 = vmulq_f32(v145, (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v133, v133, 8uLL), (float32x4_t)vextq_s8(v133, v133, 0xCuLL)), v127));
  v147 = (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32(v146, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v146, (int8x16_t)v146, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v146, (int8x16_t)v146, 0xCuLL))), v127);
  v148 = vmulq_f32(v145, (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v134, v134, 8uLL), (float32x4_t)vextq_s8(v134, v134, 0xCuLL)), v128));
  v149 = (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32(v148, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v148, (int8x16_t)v148, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v148, (int8x16_t)v148, 0xCuLL))), v128);
  v150 = vmulq_f32(v145, (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v135, v135, 8uLL), (float32x4_t)vextq_s8(v135, v135, 0xCuLL)), v129));
  v151 = (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32(v150, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v150, (int8x16_t)v150, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v150, (int8x16_t)v150, 0xCuLL))), v129);
  v152 = vmulq_f32(v145, (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v136, v136, 8uLL), (float32x4_t)vextq_s8(v136, v136, 0xCuLL)), v130));
  v153 = vmulq_f32(v49, v132);
  v154 = *(float32x4_t *)(v2 + 736);
  v155 = *(float32x4_t *)(v2 + 752);
  v156 = vmulq_f32(v153, v154);
  v157 = vcvtq_f32_s32(vcvtq_s32_f32(v156));
  v158 = vsubq_f32(vabdq_f32(vsubq_f32(v156, vsubq_f32(v157, (float32x4_t)vandq_s8((int8x16_t)v27, (int8x16_t)vcgtq_f32(v157, v156)))), v74), v155);
  v159 = vmulq_f32(v158, v158);
  v161 = *(float32x4_t *)(v2 + 768);
  v160 = *(float32x4_t *)(v2 + 784);
  v162 = vmlaq_f32(v28, v160, (float32x4_t)vrev64q_s32((int32x4_t)v153));
  v163 = vcvtq_f32_s32(vcvtq_s32_f32(v162));
  v164 = vaddq_f32(v28, vabdq_f32(vsubq_f32(v162, vsubq_f32(v163, (float32x4_t)vandq_s8((int8x16_t)v161, (int8x16_t)vcgtq_f32(v163, v162)))), v155));
  v165 = vmulq_f32(v164, v164);
  v166 = (float32x4_t)vbslq_s8(v61, (int8x16_t)vaddq_f32(v152, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v152, (int8x16_t)v152, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v152, (int8x16_t)v152, 0xCuLL))), v130);
  v167 = (float32x4_t)vbslq_s8(v40, (int8x16_t)vmulq_f32(v158, vmlaq_f32(v132, v159, vmlaq_f32(v28, v159, vmlaq_f32(v161, v160, v159)))), (int8x16_t)vmulq_f32(v164, vmlaq_f32(v30, v165, vmlaq_f32(v35, v165, vmlaq_f32(v154, v132, v165)))));
  v168 = vmulq_f32(v27, v167);
  v169 = vmulq_f32(v168, v147);
  v170 = vmulq_f32(v168, v149);
  v171 = vmulq_f32(v168, v151);
  v172 = vmulq_f32(v168, v166);
  v173 = (float32x4_t)vrev64q_s32((int32x4_t)v167);
  v174 = vmulq_f32(v173, v147);
  v169.i64[0] = vbslq_s8(v40, (int8x16_t)vaddq_f32(v169, (float32x4_t)vrev64q_s32((int32x4_t)v169)), (int8x16_t)vaddq_f32(v174, (float32x4_t)vrev64q_s32((int32x4_t)v174))).u64[0];
  v175 = vmulq_f32(v173, v149);
  v170.i64[0] = vbslq_s8(v40, (int8x16_t)vaddq_f32(v170, (float32x4_t)vrev64q_s32((int32x4_t)v170)), (int8x16_t)vaddq_f32(v175, (float32x4_t)vrev64q_s32((int32x4_t)v175))).u64[0];
  v176 = vmulq_f32(v173, v151);
  v171.i64[0] = vbslq_s8(v40, (int8x16_t)vaddq_f32(v171, (float32x4_t)vrev64q_s32((int32x4_t)v171)), (int8x16_t)vaddq_f32(v176, (float32x4_t)vrev64q_s32((int32x4_t)v176))).u64[0];
  v177 = vmulq_f32(v173, v166);
  v178 = vnegq_f32(v144);
  v172.i64[0] = vbslq_s8(v40, (int8x16_t)vaddq_f32(v172, (float32x4_t)vrev64q_s32((int32x4_t)v172)), (int8x16_t)vaddq_f32(v177, (float32x4_t)vrev64q_s32((int32x4_t)v177))).u64[0];
  v169.i64[1] = v147.i64[1];
  v170.i64[1] = v149.i64[1];
  v171.i64[1] = v151.i64[1];
  v172.i64[1] = v166.i64[1];
  v178.i32[2] = 1.0;
  v179 = vmulq_f32(v178, v169);
  v180 = vbslq_s8(v61, (int8x16_t)vaddq_f32(v179, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v179, (int8x16_t)v179, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v179, (int8x16_t)v179, 0xCuLL))), (int8x16_t)v169);
  v181 = vmulq_f32(v178, v170);
  v182 = vbslq_s8(v61, (int8x16_t)vaddq_f32(v181, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v181, (int8x16_t)v181, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v181, (int8x16_t)v181, 0xCuLL))), (int8x16_t)v170);
  v183 = vmulq_f32(v178, v171);
  v184 = vbslq_s8(v61, (int8x16_t)vaddq_f32(v183, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v183, (int8x16_t)v183, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v183, (int8x16_t)v183, 0xCuLL))), (int8x16_t)v171);
  v185 = vmulq_f32(v178, v172);
  v186 = vbslq_s8(v61, (int8x16_t)vaddq_f32(v185, vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v185, (int8x16_t)v185, 8uLL), (float32x4_t)vextq_s8((int8x16_t)v185, (int8x16_t)v185, 0xCuLL))), (int8x16_t)v172);
  *(int8x8_t *)v185.f32 = vqtbl1_s8(v180, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v185.u32[2] = vqtbl1_s8(v180, *(int8x8_t *)v115.i8);
  v187 = vmulq_f32(v219, v185);
  *(int8x8_t *)v170.f32 = vqtbl1_s8(v182, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v170.u32[2] = vqtbl1_s8(v182, *(int8x8_t *)v115.i8);
  v188 = vmulq_f32(v219, v170);
  *(int8x8_t *)v149.f32 = vqtbl1_s8(v184, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v149.u32[2] = vqtbl1_s8(v184, *(int8x8_t *)v115.i8);
  v189 = vmulq_f32(v219, v149);
  *(int8x8_t *)v176.f32 = vqtbl1_s8(v186, *(int8x8_t *)v117.i8);
  *(int8x8_t *)&v176.u32[2] = vqtbl1_s8(v186, *(int8x8_t *)v115.i8);
  v190 = vmulq_f32(v219, v176);
  v191 = (int8x16_t)vmulq_f32(v218, v185);
  v192 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v191, v191, 8uLL), (float32x4_t)vextq_s8(v191, v191, 0xCuLL)), vbslq_s8(v40, (int8x16_t)vaddq_f32(v187, (float32x4_t)vrev64q_s32((int32x4_t)v187)), v180));
  v193 = (int8x16_t)vmulq_f32(v218, v170);
  v194 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v193, v193, 8uLL), (float32x4_t)vextq_s8(v193, v193, 0xCuLL)), vbslq_s8(v40, (int8x16_t)vaddq_f32(v188, (float32x4_t)vrev64q_s32((int32x4_t)v188)), v182));
  v195 = (int8x16_t)vmulq_f32(v218, v149);
  v196 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v195, v195, 8uLL), (float32x4_t)vextq_s8(v195, v195, 0xCuLL)), vbslq_s8(v40, (int8x16_t)vaddq_f32(v189, (float32x4_t)vrev64q_s32((int32x4_t)v189)), v184));
  v197 = (int8x16_t)vmulq_f32(v218, v176);
  v198 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v197, v197, 8uLL), (float32x4_t)vextq_s8(v197, v197, 0xCuLL)), vbslq_s8(v40, (int8x16_t)vaddq_f32(v190, (float32x4_t)vrev64q_s32((int32x4_t)v190)), v186));
  v199 = (float32x4_t)vextq_s8(v192, v192, 4uLL);
  v200 = vmulq_f32(v92, v199);
  v201 = vbslq_s8(v62, (int8x16_t)vaddq_f32(v200, (float32x4_t)vrev64q_s32((int32x4_t)v200)), v192);
  v202 = (float32x4_t)vextq_s8(v194, v194, 4uLL);
  v203 = vmulq_f32(v92, v202);
  v204 = vbslq_s8(v62, (int8x16_t)vaddq_f32(v203, (float32x4_t)vrev64q_s32((int32x4_t)v203)), v194);
  v205 = (float32x4_t)vextq_s8(v196, v196, 4uLL);
  v206 = vmulq_f32(v92, v205);
  v207 = vbslq_s8(v62, (int8x16_t)vaddq_f32(v206, (float32x4_t)vrev64q_s32((int32x4_t)v206)), v196);
  v208 = (float32x4_t)vextq_s8(v198, v198, 4uLL);
  v209 = vmulq_f32(v92, v208);
  v210 = (int8x16_t)vmulq_f32(v220, v199);
  v211 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v210, v210, 8uLL), (float32x4_t)vextq_s8(v210, v210, 0xCuLL)), v201);
  v212 = (int8x16_t)vmulq_f32(v220, v202);
  v213 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v212, v212, 8uLL), (float32x4_t)vextq_s8(v212, v212, 0xCuLL)), v204);
  v214 = (int8x16_t)vmulq_f32(v220, v205);
  v215 = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v214, v214, 8uLL), (float32x4_t)vextq_s8(v214, v214, 0xCuLL)), v207);
  v216 = (int8x16_t)vmulq_f32(v220, v208);
  *(int8x16_t *)(v2 + 64) = v211;
  *(int8x16_t *)(*((_QWORD *)this + 62) + 80) = v213;
  *(int8x16_t *)(*((_QWORD *)this + 62) + 96) = v215;
  *(int8x16_t *)(*((_QWORD *)this + 62) + 112) = vbslq_s8(v61, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v216, v216, 8uLL), (float32x4_t)vextq_s8(v216, v216, 0xCuLL)), vbslq_s8(v62, (int8x16_t)vaddq_f32(v209, (float32x4_t)vrev64q_s32((int32x4_t)v209)), v198));
  return 0;
}

uint64_t HgcColorCorrect::BindTexture(HgcColorCorrect *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorCorrect::GetDOD(HgcColorCorrect *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcColorCorrect::GetROI(HgcColorCorrect *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcColorCorrect::HgcColorCorrect(HgcColorCorrect *this)
{
  uint64_t v2;
  HgcColorCorrect::State *v3;
  uint64_t v4;

  HGColorMatrix::HGColorMatrix(this);
  *(_QWORD *)v2 = off_1E65ECF98;
  *(_DWORD *)(v2 + 504) = 1;
  v3 = (HgcColorCorrect::State *)operator new();
  HgcColorCorrect::State::State(v3);
  *((_QWORD *)this + 62) = v4;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B30360DC(_Unwind_Exception *a1)
{
  HGColorMatrix *v1;

  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcColorCorrect::~HgcColorCorrect(HgcColorCorrect *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65ECF98;
  v2 = *((_QWORD *)this + 62);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C402C08F58ALL);
  HGColorMatrix::~HGColorMatrix(this);
}

{
  void *v1;

  HgcColorCorrect::~HgcColorCorrect(this);
  HGObject::operator delete(v1);
}

uint64_t HgcColorCorrect::SetParameter(HgcColorCorrect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  v7 = *((_QWORD *)this + 62);
  v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6)
      return 0;
  }
  *v8 = a3;
  v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  v11 = 1;
  *((_DWORD *)this + 126) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return v11;
}

uint64_t HgcColorCorrect::GetParameter(HgcColorCorrect *this, unsigned int a2, float *a3)
{
  uint64_t result;
  float *v5;

  if (a2 > 3)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (float *)(*((_QWORD *)this + 62) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

HGNode *HgcColorCorrect::GetOutput(HgcColorCorrect *this, HGRenderer *a2, __n128 a3, double a4, int32x2_t a5)
{
  uint64_t v7;

  if (*((_DWORD *)this + 126))
  {
    HgcColorCorrect::Setup(this, a2);
    v7 = *((_QWORD *)this + 62);
    *((_OWORD *)this + 27) = *(_OWORD *)(v7 + 64);
    *((_OWORD *)this + 28) = *(_OWORD *)(v7 + 80);
    *((_OWORD *)this + 29) = *(_OWORD *)(v7 + 96);
    a3 = *(__n128 *)(v7 + 112);
    *((__n128 *)this + 30) = a3;
    *((_DWORD *)this + 126) = 0;
  }
  return HGColorMatrix::GetOutput(this, a2, a3.n128_f64[0], a4, a5);
}

double HgcColorCorrect::State::State(HgcColorCorrect::State *this)
{
  __int128 v1;
  double result;

  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 4) = xmmword_1B304F230;
  *((_OWORD *)this + 5) = xmmword_1B304F240;
  *((_OWORD *)this + 6) = xmmword_1B304F250;
  *((_OWORD *)this + 7) = xmmword_1B304EFF0;
  *((_OWORD *)this + 8) = xmmword_1B304F230;
  *((_OWORD *)this + 9) = xmmword_1B304F240;
  *((_OWORD *)this + 10) = xmmword_1B304F250;
  *((_OWORD *)this + 11) = xmmword_1B304EFF0;
  *((_OWORD *)this + 12) = *(_OWORD *)"";
  *((_OWORD *)this + 13) = xmmword_1B30527A0;
  *((int32x4_t *)this + 14) = vdupq_n_s32(0x7F7FFFFFu);
  *((_OWORD *)this + 15) = xmmword_1B35664F0;
  *((_OWORD *)this + 16) = xmmword_1B3566500;
  *((_OWORD *)this + 17) = xmmword_1B3566510;
  *((_OWORD *)this + 18) = xmmword_1B3566520;
  *((_OWORD *)this + 19) = xmmword_1B3566530;
  *((_OWORD *)this + 20) = xmmword_1B3566540;
  *((_OWORD *)this + 21) = xmmword_1B3566550;
  *((_OWORD *)this + 22) = xmmword_1B3566560;
  *((_OWORD *)this + 23) = xmmword_1B3566570;
  *((_OWORD *)this + 24) = xmmword_1B3566580;
  *((_OWORD *)this + 25) = xmmword_1B3566590;
  *((_OWORD *)this + 26) = xmmword_1B35665A0;
  *((_OWORD *)this + 27) = xmmword_1B35665B0;
  *((_OWORD *)this + 28) = xmmword_1B35665C0;
  *((_OWORD *)this + 29) = xmmword_1B35665D0;
  *((_OWORD *)this + 30) = xmmword_1B35665E0;
  *((_OWORD *)this + 31) = xmmword_1B35665F0;
  *((_OWORD *)this + 32) = xmmword_1B3566600;
  *((_OWORD *)this + 33) = xmmword_1B3050E20;
  *((_OWORD *)this + 34) = xmmword_1B3566610;
  *((_OWORD *)this + 35) = xmmword_1B3566620;
  *((_OWORD *)this + 36) = xmmword_1B3050FF0;
  *((_OWORD *)this + 37) = xmmword_1B3050FE0;
  *(_QWORD *)&v1 = 0x3F0000003F000000;
  *((_QWORD *)&v1 + 1) = 0x3F0000003F000000;
  *((_OWORD *)this + 38) = xmmword_1B3050F70;
  *((_OWORD *)this + 39) = v1;
  *((_OWORD *)this + 40) = xmmword_1B3566630;
  *((_OWORD *)this + 41) = xmmword_1B3566640;
  *((_OWORD *)this + 42) = xmmword_1B30510C0;
  *((_OWORD *)this + 43) = xmmword_1B3566650;
  *((_OWORD *)this + 44) = xmmword_1B3566660;
  *((_OWORD *)this + 45) = xmmword_1B3566670;
  *((_OWORD *)this + 46) = xmmword_1B3566680;
  *((_OWORD *)this + 47) = xmmword_1B3051CC0;
  *((_OWORD *)this + 48) = xmmword_1B3051CB0;
  *((_OWORD *)this + 49) = xmmword_1B3051CA0;
  *((_OWORD *)this + 50) = xmmword_1B3051C90;
  *((_OWORD *)this + 51) = xmmword_1B3566690;
  *((_OWORD *)this + 52) = xmmword_1B35666A0;
  *((_OWORD *)this + 53) = xmmword_1B35666B0;
  result = 0.000320729741;
  *((_OWORD *)this + 54) = xmmword_1B35666C0;
  *((_OWORD *)this + 55) = xmmword_1B35666D0;
  return result;
}

const char *HgcHighlightHDRRegion::GetProgram(HgcHighlightHDRRegion *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=0000000345\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.06666667014, 1.000000000, 0.07843137532, 0.5764706135);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = clamp(r0, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz - r1.xyz;\n"
             "    r0.xyz = r0.xyz*c0.xxx;\n"
             "    r0.x = fmax(r0.x, r0.y);\n"
             "    r0.x = fmax(r0.x, r0.z);\n"
             "    output.color0 = mix(float4(r1), float4(c0.yzwy), float4(r0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=0f491771:8c56129f:a38de618:e328132d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000329\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.06666667014, 1.000000000, 0.07843137532, 0.5764706135);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = clamp(r0, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz - r1.xyz;\n"
             "    r0.xyz = r0.xyz*c0.xxx;\n"
             "    r0.x = fmax(r0.x, r0.y);\n"
             "    r0.x = fmax(r0.x, r0.z);\n"
             "    output.color0 = mix(r1, c0.yzwy, r0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ff467f12:4ce00e31:ad026719:065f9887\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.06666667014, 1.000000000, 0.07843137532, 0.5764706135);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = clamp(r0, vec4(0.00000), vec4(1.00000));\n"
           "    r0.xyz = r0.xyz - r1.xyz;\n"
           "    r0.xyz = r0.xyz*c0.xxx;\n"
           "    r0.x = max(r0.x, r0.y);\n"
           "    r0.x = max(r0.x, r0.z);\n"
           "    gl_FragColor = mix(r1, c0.yzwy, r0.xxxx);\n"
           "}\n"
           "//MD5=0ddea595:fd350b7b:a63b0c18:7d31ed17\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcHighlightHDRRegion::InitProgramDescriptor(HgcHighlightHDRRegion *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcHighlightHDRRegion_hgc_visible", "//Metal1.0     \n//LEN=0000000208\n[[ visible ]] FragmentOut HgcHighlightHDRRegion_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.06666667014, 1.000000000, 0.07843137532, 0.5764706135);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = clamp(r0, 0.00000f, 1.00000f);\n"
    "    r0.xyz = r0.xyz - r1.xyz;\n"
    "    r0.xyz = r0.xyz*c0.xxx;\n"
    "    r0.x = fmax(r0.x, r0.y);\n"
    "    r0.x = fmax(r0.x, r0.z);\n"
    "    output.color0 = mix(r1, c0.yzwy, r0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B3036548()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcHighlightHDRRegion");
}

void sub_1B3036558(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B30514B0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B3036658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3036698()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3036690);
}

_QWORD *HgcHighlightHDRRegion::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcHighlightHDRRegion [hgc1]");
}

uint64_t HgcHighlightHDRRegion::BindTexture(HgcHighlightHDRRegion *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcHighlightHDRRegion::Bind(HgcHighlightHDRRegion *this, HGHandler *a2)
{
  (*(void (**)(HgcHighlightHDRRegion *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcHighlightHDRRegion::RenderTile(HgcHighlightHDRRegion *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t *v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t *v35;
  uint64_t v36;
  float32x4_t v37;
  float32x4_t *v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 22);
    v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v36) = 0;
      }
      else
      {
        v9 = 0;
        v10 = 32;
        do
        {
          v11 = *(float32x4_t *)(v6 + v10 - 32);
          v12 = *(float32x4_t *)(v6 + v10 - 16);
          v13 = *(float32x4_t *)(v6 + v10);
          v14 = *(float32x4_t *)(v6 + v10 + 16);
          v15 = (float32x4_t *)*((_QWORD *)this + 51);
          v16 = v15[1];
          v17 = vminq_f32(vmaxq_f32(v11, *v15), v16);
          v18 = vminq_f32(vmaxq_f32(v12, *v15), v16);
          v19 = vminq_f32(vmaxq_f32(v13, *v15), v16);
          v20 = vminq_f32(vmaxq_f32(v14, *v15), v16);
          v21 = v15[2];
          v22 = v15[3];
          v23 = vmulq_f32(vsubq_f32(v11, v17), v21);
          v24 = vmulq_f32(vsubq_f32(v12, v18), v21);
          v25 = vmulq_f32(vsubq_f32(v13, v19), v21);
          v26 = vmulq_f32(vsubq_f32(v14, v20), v21);
          v27 = vmaxq_f32(v23, (float32x4_t)vrev64q_s32((int32x4_t)v23));
          v28 = vmaxq_f32(v24, (float32x4_t)vrev64q_s32((int32x4_t)v24));
          v29 = vmaxq_f32(v25, (float32x4_t)vrev64q_s32((int32x4_t)v25));
          v30 = (float32x4_t)vextq_s8((int8x16_t)v23, (int8x16_t)v27, 8uLL);
          v27.i64[1] = v23.i64[1];
          v31 = (float32x4_t)vextq_s8((int8x16_t)v24, (int8x16_t)v28, 8uLL);
          v28.i64[1] = v24.i64[1];
          v32 = vmaxq_f32(v26, (float32x4_t)vrev64q_s32((int32x4_t)v26));
          v33 = (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v29, 8uLL);
          v34 = (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v32, 8uLL);
          v29.i64[1] = v25.i64[1];
          v32.i64[1] = v26.i64[1];
          v35 = (float32x4_t *)(v5 + v10);
          v35[-2] = vmlaq_n_f32(v17, vsubq_f32(v22, v17), vmaxq_f32(v27, v30).f32[0]);
          v35[-1] = vmlaq_n_f32(v18, vsubq_f32(v22, v18), vmaxq_f32(v28, v31).f32[0]);
          *v35 = vmlaq_n_f32(v19, vsubq_f32(v22, v19), vmaxq_f32(v29, v33).f32[0]);
          v35[1] = vmlaq_n_f32(v20, vsubq_f32(v22, v20), vmaxq_f32(v32, v34).f32[0]);
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v36) = -v9;
      }
      if ((int)v36 < v4)
      {
        v36 = v36;
        do
        {
          v37 = *(float32x4_t *)(v6 + 16 * v36);
          v38 = (float32x4_t *)*((_QWORD *)this + 51);
          v39 = vminq_f32(vmaxq_f32(v37, *v38), v38[1]);
          v40 = vmulq_f32(vsubq_f32(v37, v39), v38[2]);
          v41 = vmaxq_f32(v40, (float32x4_t)vrev64q_s32((int32x4_t)v40));
          v42 = (float32x4_t)vextq_s8((int8x16_t)v40, (int8x16_t)v41, 8uLL);
          v41.i64[1] = v40.i64[1];
          *(float32x4_t *)(v5 + 16 * v36++) = vmlaq_n_f32(v39, vsubq_f32(v38[3], v39), vmaxq_f32(v41, v42).f32[0]);
        }
        while (v36 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcHighlightHDRRegion::GetDOD(HgcHighlightHDRRegion *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcHighlightHDRRegion::GetROI(HgcHighlightHDRRegion *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcHighlightHDRRegion::HgcHighlightHDRRegion(HgcHighlightHDRRegion *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65ED210;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 16) = _Q0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3566700;
  *(_OWORD *)(v3 + 48) = xmmword_1B3566710;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B30369E8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcHighlightHDRRegion::~HgcHighlightHDRRegion(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65ED210;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40FA0F61DDLL);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcHighlightHDRRegion::~HgcHighlightHDRRegion(this);
  HGObject::operator delete(v1);
}

uint64_t HgcHighlightHDRRegion::SetParameter(HgcHighlightHDRRegion *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcHighlightHDRRegion::GetParameter(HgcHighlightHDRRegion *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcOverexposureCheck::GetProgram(HgcOverexposureCheck *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = (half3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    output.color0.x = dot(float3(r0.xyz), hg_Params[0].xyz);\n"
             "    output.color0.yzw = float3(c0.xxy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=753e7e49:4673b5e4:9999ef5b:0a25a395\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=00000002d5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    output.color0.x = dot(r0.xyz, hg_Params[0].xyz);\n"
             "    output.color0.yzw = c0.xxy;\n"
             "    return output;\n"
             "}\n"
             "//MD5=08055fc8:a19b68f0:107c0018:aa18a62e\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002a6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    gl_FragColor.x = dot(r0.xyz, hg_ProgramLocal0.xyz);\n"
           "    gl_FragColor.yzw = c0.xxy;\n"
           "}\n"
           "//MD5=d59f6280:a2ae589f:7caf7a89:92a20f17\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcOverexposureCheck::InitProgramDescriptor(HgcOverexposureCheck *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcOverexposureCheck_hgc_visible", "//Metal1.0     \n//LEN=00000001b3\n[[ visible ]] FragmentOut HgcOverexposureCheck_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xyz = color0.xyz;\n"
    "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
    "    output.color0.x = dot(r0.xyz, hg_Params[0].xyz);\n"
    "    output.color0.yzw = c0.xxy;\n"
    "    return output;\n"
    "}\n");
}

void sub_1B3036B3C()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcOverexposureCheck");
}

void sub_1B3036B4C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3051440;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B3036C4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3036C8C()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3036C84);
}

_QWORD *HgcOverexposureCheck::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcOverexposureCheck [hgc1]");
}

uint64_t HgcOverexposureCheck::BindTexture(HgcOverexposureCheck *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcOverexposureCheck::Bind(HgcOverexposureCheck *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcOverexposureCheck *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcOverexposureCheck::RenderTile(HgcOverexposureCheck *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t *v18;
  uint64_t v19;
  uint64_t v20;
  float32x4_t v21;
  float32x4_t v22;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 22);
    v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v19) = 0;
      }
      else
      {
        v9 = 0;
        v10 = 32;
        do
        {
          v11 = *((_QWORD *)this + 51);
          v12 = *(float32x4_t *)(v11 + 16);
          v13 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10 - 32), v12), *(float32x4_t *)v11);
          v14 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10 - 16), v12), *(float32x4_t *)v11);
          v15 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10), v12), *(float32x4_t *)v11);
          v16 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v6 + v10 + 16), v12), *(float32x4_t *)v11);
          v17 = *(int8x16_t *)(v11 + 32);
          v18 = (int8x16_t *)(v5 + v10);
          v18[-2] = vbslq_s8(v17, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), vaddq_f32(v13, (float32x4_t)vrev64q_s32((int32x4_t)v13))), (int8x16_t)v12);
          v18[-1] = vbslq_s8(v17, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), vaddq_f32(v14, (float32x4_t)vrev64q_s32((int32x4_t)v14))), (int8x16_t)v12);
          *v18 = vbslq_s8(v17, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), vaddq_f32(v15, (float32x4_t)vrev64q_s32((int32x4_t)v15))), (int8x16_t)v12);
          v18[1] = vbslq_s8(v17, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL), vaddq_f32(v16, (float32x4_t)vrev64q_s32((int32x4_t)v16))), (int8x16_t)v12);
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v19) = -v9;
      }
      if ((int)v19 < v4)
      {
        v19 = v19;
        do
        {
          v20 = *((_QWORD *)this + 51);
          v21 = *(float32x4_t *)(v20 + 16);
          v22 = vmulq_f32(vmaxq_f32(*(float32x4_t *)(v6 + 16 * v19), v21), *(float32x4_t *)v20);
          *(int8x16_t *)(v5 + 16 * v19++) = vbslq_s8(*(int8x16_t *)(v20 + 32), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL), vaddq_f32(v22, (float32x4_t)vrev64q_s32((int32x4_t)v22))), (int8x16_t)v21);
        }
        while (v19 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcOverexposureCheck::GetDOD(HgcOverexposureCheck *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcOverexposureCheck::GetROI(HgcOverexposureCheck *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcOverexposureCheck::HgcOverexposureCheck(HgcOverexposureCheck *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65ED478;
  v3 = operator new();
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_OWORD *)(v3 + 16) = xmmword_1B304EFF0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3050E20;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B3036FB8(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcOverexposureCheck::~HgcOverexposureCheck(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65ED478;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcOverexposureCheck::~HgcOverexposureCheck(this);
  HGObject::operator delete(v1);
}

uint64_t HgcOverexposureCheck::SetParameter(HgcOverexposureCheck *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  float *v8;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (float *)*((_QWORD *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6)
    return 0;
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcOverexposureCheck::GetParameter(HgcOverexposureCheck *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcHighlightOutOfGamut::GetProgram(HgcHighlightOutOfGamut *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=000000048f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, -0.5500000119, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.y = half(c0.y < r0.x);\n"
             "    r1.x = half(r0.x < c0.x);\n"
             "    r1.z = fmax(r1.x, r1.y);\n"
             "    r1.x = half(r0.y < c0.x);\n"
             "    r1.y = half(c0.y < r0.y);\n"
             "    r1.x = fmax(r1.z, r1.x);\n"
             "    r1.z = fmax(r1.x, r1.y);\n"
             "    r1.x = half(r0.z < c0.x);\n"
             "    r1.y = half(c0.y < r0.z);\n"
             "    r1.x = fmax(r1.z, r1.x);\n"
             "    r1.x = fmax(r1.x, r1.y);\n"
             "    r1 = select(r0, c0.yyyy, -r1.xxxx < 0.00000h);\n"
             "    r0.xyz = half3(r0.xyz < c0.zzz);\n"
             "    r0.x = clamp(dot(r0.xyz, 1.00000h), 0.00000h, 1.00000h);\n"
             "    output.color0 = select(float4(r1), float4(c0.yxxy), -float4(r0.xxxx) < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=4c1f3fc4:fa2dabe7:592aa5f7:1ffd7108\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=000000047a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, -0.5500000119, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.y = float(c0.y < r0.x);\n"
             "    r1.x = float(r0.x < c0.x);\n"
             "    r1.z = fmax(r1.x, r1.y);\n"
             "    r1.x = float(r0.y < c0.x);\n"
             "    r1.y = float(c0.y < r0.y);\n"
             "    r1.x = fmax(r1.z, r1.x);\n"
             "    r1.z = fmax(r1.x, r1.y);\n"
             "    r1.x = float(r0.z < c0.x);\n"
             "    r1.y = float(c0.y < r0.z);\n"
             "    r1.x = fmax(r1.z, r1.x);\n"
             "    r1.x = fmax(r1.x, r1.y);\n"
             "    r1 = select(r0, c0.yyyy, -r1.xxxx < 0.00000f);\n"
             "    r0.xyz = float3(r0.xyz < c0.zzz);\n"
             "    r0.x = clamp(dot(r0.xyz, 1.00000f), 0.00000f, 1.00000f);\n"
             "    output.color0 = select(r1, c0.yxxy, -r0.xxxx < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e76d530a:353c1e57:61a46793:02f7204a\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 1.000000000, -0.5500000119, 0.000000000);\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.y = float(c0.y < r0.x);\n"
           "    r1.x = float(r0.x < c0.x);\n"
           "    r1.z = max(r1.x, r1.y);\n"
           "    r1.x = float(r0.y < c0.x);\n"
           "    r1.y = float(c0.y < r0.y);\n"
           "    r1.x = max(r1.z, r1.x);\n"
           "    r1.z = max(r1.x, r1.y);\n"
           "    r1.x = float(r0.z < c0.x);\n"
           "    r1.y = float(c0.y < r0.z);\n"
           "    r1.x = max(r1.z, r1.x);\n"
           "    r1.x = max(r1.x, r1.y);\n"
           "    r1 = vec4(-r1.x < 0.00000 ? c0.y : r0.x, -r1.x < 0.00000 ? c0.y : r0.y, -r1.x < 0.00000 ? c0.y : r0.z, -r"
           "1.x < 0.00000 ? c0.y : r0.w);\n"
           "    r0.xyz = vec3(lessThan(r0.xyz, c0.zzz));\n"
           "    r0.x = clamp(dot(r0.xyz, vec3(1.00000)), 0.00000, 1.00000);\n"
           "    gl_FragColor = vec4(-r0.x < 0.00000 ? c0.y : r1.x, -r0.x < 0.00000 ? c0.x : r1.y, -r0.x < 0.00000 ? c0.x "
           ": r1.z, -r0.x < 0.00000 ? c0.y : r1.w);\n"
           "}\n"
           "//MD5=60e8fc88:1fb00940:828ef5e9:c741a039\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcHighlightOutOfGamut::InitProgramDescriptor(HgcHighlightOutOfGamut *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcHighlightOutOfGamut_hgc_visible", "//Metal1.0     \n//LEN=000000035a\n[[ visible ]] FragmentOut HgcHighlightOutOfGamut_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 1.000000000, -0.5500000119, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.y = float(c0.y < r0.x);\n"
    "    r1.x = float(r0.x < c0.x);\n"
    "    r1.z = fmax(r1.x, r1.y);\n"
    "    r1.x = float(r0.y < c0.x);\n"
    "    r1.y = float(c0.y < r0.y);\n"
    "    r1.x = fmax(r1.z, r1.x);\n"
    "    r1.z = fmax(r1.x, r1.y);\n"
    "    r1.x = float(r0.z < c0.x);\n"
    "    r1.y = float(c0.y < r0.z);\n"
    "    r1.x = fmax(r1.z, r1.x);\n"
    "    r1.x = fmax(r1.x, r1.y);\n"
    "    r1 = select(r0, c0.yyyy, -r1.xxxx < 0.00000f);\n"
    "    r0.xyz = float3(r0.xyz < c0.zzz);\n"
    "    r0.x = clamp(dot(r0.xyz, 1.00000f), 0.00000f, 1.00000f);\n"
    "    output.color0 = select(r1, c0.yxxy, -r0.xxxx < 0.00000f);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B30371A0()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcHighlightOutOfGamut");
}

void sub_1B30371B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B30514B0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B30372B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B30372F0()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B30372E8);
}

_QWORD *HgcHighlightOutOfGamut::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcHighlightOutOfGamut [hgc1]");
}

uint64_t HgcHighlightOutOfGamut::BindTexture(HgcHighlightOutOfGamut *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcHighlightOutOfGamut::Bind(HgcHighlightOutOfGamut *this, HGHandler *a2)
{
  (*(void (**)(HgcHighlightOutOfGamut *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcHighlightOutOfGamut::RenderTile(HgcHighlightOutOfGamut *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int32x2_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t *v51;
  uint64_t v52;
  float32x4_t v53;
  float32x4_t v54;
  uint64_t v55;
  float32x4_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  float32x4_t v66;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 22);
    v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v52) = 0;
      }
      else
      {
        v9 = 0;
        v10 = 32;
        do
        {
          v12 = *(float32x4_t *)(v6 + v10 - 32);
          v11 = *(float32x4_t *)(v6 + v10 - 16);
          v13 = *(float32x4_t *)(v6 + v10);
          v14 = *(float32x4_t *)(v6 + v10 + 16);
          v15 = (float32x4_t)vrev64q_s32((int32x4_t)v12);
          v16 = (float32x4_t)vrev64q_s32((int32x4_t)v11);
          v17 = (float32x4_t)vrev64q_s32((int32x4_t)v13);
          v18 = *((_QWORD *)this + 51);
          v19 = *(float32x4_t *)(v18 + 16);
          v20 = (float32x4_t)vrev64q_s32((int32x4_t)v14);
          v21 = *(int8x16_t *)(v18 + 32);
          v22 = *(int8x16_t *)(v18 + 48);
          v23 = vbslq_s8(v21, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v12)), vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v15, *(float32x4_t *)v18)));
          v24 = vbslq_s8(v21, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v11)), vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v16, *(float32x4_t *)v18)));
          v25 = vbslq_s8(v21, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v13)), vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v17, *(float32x4_t *)v18)));
          v26 = vbslq_s8(v21, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v14)), vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v20, *(float32x4_t *)v18)));
          v15.i64[0] = vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v15)).u64[0];
          v16.i64[0] = vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v16)).u64[0];
          v17.i64[0] = vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v17)).u64[0];
          v15.i64[1] = vmaxq_f32((float32x4_t)vextq_s8(v23, v23, 8uLL), (float32x4_t)vextq_s8(v23, v23, 0xCuLL)).i64[1];
          v16.i64[1] = vmaxq_f32((float32x4_t)vextq_s8(v24, v24, 8uLL), (float32x4_t)vextq_s8(v24, v24, 0xCuLL)).i64[1];
          v17.i64[1] = vmaxq_f32((float32x4_t)vextq_s8(v25, v25, 8uLL), (float32x4_t)vextq_s8(v25, v25, 0xCuLL)).i64[1];
          v20.i64[0] = vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(*(float32x4_t *)v18, v20)).u64[0];
          v20.i64[1] = vmaxq_f32((float32x4_t)vextq_s8(v26, v26, 8uLL), (float32x4_t)vextq_s8(v26, v26, 0xCuLL)).i64[1];
          v27 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v12, v19)), (int8x16_t)v15);
          v28 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v11, v19)), (int8x16_t)v16);
          v29 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v13, v19)), (int8x16_t)v17);
          v30 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v14, v19)), (int8x16_t)v20);
          v31 = vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL), v27), (int8x16_t)v27);
          v32 = vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL), v28), (int8x16_t)v28);
          v33 = vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL), v29), (int8x16_t)v29);
          v34 = vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL), v30), (int8x16_t)v30);
          v35 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v12, (int8x16_t)v12, 4uLL), v19)), (int8x16_t)vzip2q_s64((int64x2_t)vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v19, v12)), (int64x2_t)vmaxq_f32((float32x4_t)vextq_s8(v31, v31, 8uLL), (float32x4_t)vextq_s8(v31, v31, 0xCuLL))));
          v36 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v11, (int8x16_t)v11, 4uLL), v19)), (int8x16_t)vzip2q_s64((int64x2_t)vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v19, v11)), (int64x2_t)vmaxq_f32((float32x4_t)vextq_s8(v32, v32, 8uLL), (float32x4_t)vextq_s8(v32, v32, 0xCuLL))));
          v37 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 4uLL), v19)), (int8x16_t)vzip2q_s64((int64x2_t)vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v19, v13)), (int64x2_t)vmaxq_f32((float32x4_t)vextq_s8(v33, v33, 8uLL), (float32x4_t)vextq_s8(v33, v33, 0xCuLL))));
          v38 = (float32x4_t)vbslq_s8(v22, vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)v14, 4uLL), v19)), (int8x16_t)vzip2q_s64((int64x2_t)vandq_s8(*(int8x16_t *)v18, (int8x16_t)vcgtq_f32(v19, v14)), (int64x2_t)vmaxq_f32((float32x4_t)vextq_s8(v34, v34, 8uLL), (float32x4_t)vextq_s8(v34, v34, 0xCuLL))));
          v39 = (int32x2_t)vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v35, 8uLL), v35), (int8x16_t)v35).u64[0];
          v35.i64[0] = vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL), v36), (int8x16_t)v36).u64[0];
          v36.i64[0] = vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL), v37), (int8x16_t)v37).u64[0];
          v21.i64[0] = vbslq_s8(v21, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL), v38), (int8x16_t)v38).u64[0];
          v40 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.i8, 1);
          v41 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.i8, 0);
          v43 = *(float32x4_t *)(v18 + 64);
          v42 = *(float32x4_t *)(v18 + 80);
          v44 = *(float32x4_t *)(v18 + 96);
          v45 = *(int8x16_t *)(v18 + 112);
          v46 = (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v44, v12));
          v47 = vmaxq_f32(v41, v40);
          v48 = (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v44, v11));
          v49 = (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v44, v13));
          v50 = (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v44, v14));
          v51 = (int8x16_t *)(v5 + v10);
          v51[-2] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v46, (int8x16_t)v46, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v46), v46)), v42), v43), 0), v42), v45, vbslq_s8((int8x16_t)vcgtq_f32(
                                     vmaxq_f32((float32x4_t)vdupq_lane_s32(v39, 0), (float32x4_t)vdupq_lane_s32(v39, 1)),
                                     v42),
                        (int8x16_t)v43,
                        (int8x16_t)v12));
          v51[-1] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v48), v48)), v42), v43), 0), v42), v45, vbslq_s8((int8x16_t)vcgtq_f32(
                                     vmaxq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1)), v42), (int8x16_t)v43, (int8x16_t)v11));
          *v51 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v49), v49)), v42), v43), 0), v42), v45, vbslq_s8((int8x16_t)vcgtq_f32(
                                  vmaxq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1)), v42), (int8x16_t)v43, (int8x16_t)v13));
          v51[1] = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v50), v50)), v42), v43), 0), v42), v45, vbslq_s8((int8x16_t)vcgtq_f32(v47, v42), (int8x16_t)v43, (int8x16_t)v14));
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v52) = -v9;
      }
      if ((int)v52 < v4)
      {
        v52 = v52;
        do
        {
          v53 = *(float32x4_t *)(v6 + 16 * v52);
          v54 = (float32x4_t)vrev64q_s32((int32x4_t)v53);
          v55 = *((_QWORD *)this + 51);
          v56 = *(float32x4_t *)(v55 + 16);
          v57 = *(int8x16_t *)(v55 + 32);
          v58 = *(int8x16_t *)(v55 + 48);
          v59 = vbslq_s8(v57, vandq_s8((int8x16_t)v56, (int8x16_t)vcgtq_f32(*(float32x4_t *)v55, v53)), vandq_s8(*(int8x16_t *)v55, (int8x16_t)vcgtq_f32(v54, *(float32x4_t *)v55)));
          v54.i64[0] = vandq_s8((int8x16_t)v56, (int8x16_t)vcgtq_f32(*(float32x4_t *)v55, v54)).u64[0];
          v54.i64[1] = vmaxq_f32((float32x4_t)vextq_s8(v59, v59, 8uLL), (float32x4_t)vextq_s8(v59, v59, 0xCuLL)).i64[1];
          v60 = (float32x4_t)vbslq_s8(v58, vandq_s8((int8x16_t)v56, (int8x16_t)vcgtq_f32(v53, v56)), (int8x16_t)v54);
          v61 = vbslq_s8(v57, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v60, (int8x16_t)v60, 8uLL), v60), (int8x16_t)v60);
          v62 = (float32x4_t)vbslq_s8(v58, vandq_s8((int8x16_t)v56, (int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v53, (int8x16_t)v53, 4uLL), v56)), (int8x16_t)vzip2q_s64((int64x2_t)vandq_s8(*(int8x16_t *)v55, (int8x16_t)vcgtq_f32(v56, v53)), (int64x2_t)vmaxq_f32((float32x4_t)vextq_s8(v61, v61, 8uLL), (float32x4_t)vextq_s8(v61, v61, 0xCuLL))));
          v62.i64[0] = vbslq_s8(v57, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v62, (int8x16_t)v62, 8uLL), v62), (int8x16_t)v62).u64[0];
          v64 = *(float32x4_t *)(v55 + 64);
          v63 = *(float32x4_t *)(v55 + 80);
          v65 = vbslq_s8((int8x16_t)vcgtq_f32(vmaxq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v62.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v62.f32, 1)), v63), (int8x16_t)v64, (int8x16_t)v53);
          v66 = (float32x4_t)vandq_s8((int8x16_t)v64, (int8x16_t)vcgtq_f32(*(float32x4_t *)(v55 + 96), v53));
          *(int8x16_t *)(v5 + 16 * v52++) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vminq_f32(vmaxq_f32(vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v66, (int8x16_t)v66, 8uLL), vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v66), v66)), v63), v64), 0), v63), *(int8x16_t *)(v55 + 112), v65);
        }
        while (v52 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcHighlightOutOfGamut::GetDOD(HgcHighlightOutOfGamut *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcHighlightOutOfGamut::GetROI(HgcHighlightOutOfGamut *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcHighlightOutOfGamut::HgcHighlightOutOfGamut(HgcHighlightOutOfGamut *this)
{
  _QWORD *v2;
  uint64_t v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65ED6E0;
  v3 = operator new();
  *(_OWORD *)v3 = xmmword_1B3557DE0;
  *(_OWORD *)(v3 + 16) = xmmword_1B30520F0;
  *(_OWORD *)(v3 + 32) = xmmword_1B3050E20;
  *(_OWORD *)(v3 + 48) = xmmword_1B3050FF0;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v3 + 64) = _Q0;
  *(_QWORD *)(v3 + 80) = 0;
  *(_QWORD *)(v3 + 88) = 0;
  *(_OWORD *)(v3 + 96) = xmmword_1B3566750;
  *(_OWORD *)(v3 + 112) = xmmword_1B304FAB0;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B3037950(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcHighlightOutOfGamut::~HgcHighlightOutOfGamut(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65ED6E0;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40AE2C30F4);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcHighlightOutOfGamut::~HgcHighlightOutOfGamut(this);
  HGObject::operator delete(v1);
}

uint64_t HgcHighlightOutOfGamut::SetParameter(HgcHighlightOutOfGamut *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcHighlightOutOfGamut::GetParameter(HgcHighlightOutOfGamut *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcExposureAdjust::GetProgram(HgcExposureAdjust *this, HGRenderer *a2)
{
  unsigned int Target;

  Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 20) == 27)
      return "//Metal1.0     \n"
             "//LEN=00000002b3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 + half4(hg_Params[0]);\n"
             "    output.color0 = fmin(float4(r0), float4(c0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=eb9df7c6:30dd8f51:acaefc17:02e6ae8c\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else
      return "//Metal1.0     \n"
             "//LEN=0000000298\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 + hg_Params[0];\n"
             "    output.color0 = fmin(r0, c0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9f403330:a5ffee84:f6c5632e:85d2d683\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000026a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 + hg_ProgramLocal0;\n"
           "    gl_FragColor = min(r0, c0.xxxx);\n"
           "}\n"
           "//MD5=388f355f:a6d62e01:ca926981:5f521d43\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcExposureAdjust::InitProgramDescriptor(HgcExposureAdjust *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcExposureAdjust_hgc_visible", "//Metal1.0     \n//LEN=0000000173\n[[ visible ]] FragmentOut HgcExposureAdjust_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = r0 + hg_Params[0];\n"
    "    output.color0 = fmin(r0, c0.xxxx);\n"
    "    return output;\n"
    "}\n");
}

void sub_1B3037AA4()
{
  HGProgramDescriptor *v0;

  HGProgramDescriptor::SetFragmentFunctionName(v0, "HgcExposureAdjust");
}

void sub_1B3037AB4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, __int128 a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  uint64_t v31;
  uint64_t v32;
  void **v33;
  void *v34[2];
  char v35;
  __int128 v36;
  uint64_t v37[13];

  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B3050DF0;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0)
    operator delete(*(void **)(v32 - 56));
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3051440;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  v36 = xmmword_1B3050DF0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0)
    operator delete(v34[0]);
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B3037BB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3037BF4()
{
  uint64_t v0;

  if (*(char *)(v0 - 33) < 0)
    operator delete(*(void **)(v0 - 56));
  JUMPOUT(0x1B3037BECLL);
}

_QWORD *HgcExposureAdjust::shaderDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcExposureAdjust [hgc1]");
}

uint64_t HgcExposureAdjust::BindTexture(HgcExposureAdjust *this, HGHandler *a2, int a3)
{
  uint64_t result;
  int v5;

  if (a3)
    return 0xFFFFFFFFLL;
  (*(void (**)(HGHandler *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, _QWORD, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 18) + 128))(*((_QWORD *)a2 + 18), 46);
  result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(_QWORD *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcExposureAdjust::Bind(HgcExposureAdjust *this, HGHandler *a2)
{
  (*(void (**)(HGHandler *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 144))(a2, 0, *((_QWORD *)this + 51), 1);
  (*(void (**)(HgcExposureAdjust *, HGHandler *))(*(_QWORD *)this + 192))(this, a2);
  return 0;
}

uint64_t HgcExposureAdjust::RenderTile(HgcExposureAdjust *this, HGTile *a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float32x4_t *v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t *v17;
  uint64_t v18;

  v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 10);
    v7 = 16 * *((int *)a2 + 22);
    v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v18) = 0;
      }
      else
      {
        v9 = 0;
        v10 = 32;
        do
        {
          v11 = (float32x4_t *)*((_QWORD *)this + 51);
          v12 = v11[1];
          v13 = vminq_f32(vaddq_f32(*(float32x4_t *)(v6 + v10 - 32), *v11), v12);
          v14 = vminq_f32(vaddq_f32(*(float32x4_t *)(v6 + v10 - 16), *v11), v12);
          v15 = vminq_f32(vaddq_f32(*(float32x4_t *)(v6 + v10), *v11), v12);
          v16 = vminq_f32(vaddq_f32(*(float32x4_t *)(v6 + v10 + 16), *v11), v12);
          v17 = (float32x4_t *)(v5 + v10);
          v17[-2] = v13;
          v17[-1] = v14;
          *v17 = v15;
          v17[1] = v16;
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v18) = -v9;
      }
      if ((int)v18 < v4)
      {
        v18 = v18;
        do
        {
          *(float32x4_t *)(v5 + 16 * v18) = vminq_f32(vaddq_f32(*(float32x4_t *)(v6 + 16 * v18), *(float32x4_t *)*((_QWORD *)this + 51)), *(float32x4_t *)(*((_QWORD *)this + 51) + 16));
          ++v18;
        }
        while (v18 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcExposureAdjust::GetDOD(HgcExposureAdjust *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

uint64_t HgcExposureAdjust::GetROI(HgcExposureAdjust *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
    return 0;
  else
    return *(_QWORD *)&a4.var0;
}

void HgcExposureAdjust::HgcExposureAdjust(HgcExposureAdjust *this)
{
  _QWORD *v2;
  _OWORD *v3;

  HGNode::HGNode((HGNode *)this);
  *v2 = off_1E65ED948;
  v3 = (_OWORD *)operator new();
  __asm { FMOV            V1.4S, #1.0 }
  *v3 = 0u;
  v3[1] = _Q1;
  v3[2] = 0u;
  *((_QWORD *)this + 51) = v3;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B3037EAC(_Unwind_Exception *a1)
{
  HGNode *v1;

  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcExposureAdjust::~HgcExposureAdjust(HGNode *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E65ED948;
  v2 = *((_QWORD *)this + 51);
  if (v2)
    MEMORY[0x1B5E29170](v2, 0x1000C40EED21634);
  HGNode::~HGNode(this);
}

{
  void *v1;

  HgcExposureAdjust::~HgcExposureAdjust(this);
  HGObject::operator delete(v1);
}

uint64_t HgcExposureAdjust::SetParameter(HgcExposureAdjust *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  __n128 *v8;
  int32x4_t v9;

  if ((_DWORD)a2)
    return 0xFFFFFFFFLL;
  v8 = (__n128 *)*((_QWORD *)this + 51);
  if (v8->n128_f32[0] == a3.n128_f32[0]
    && v8->n128_f32[1] == a3.n128_f32[0]
    && v8->n128_f32[2] == a3.n128_f32[0]
    && v8->n128_f32[3] == a3.n128_f32[0])
  {
    return 0;
  }
  v9 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
  a3.n128_f32[1] = a4;
  *v8 = (__n128)v9;
  a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v8[2] = a3;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcExposureAdjust::GetParameter(HgcExposureAdjust *this, int a2, float *a3)
{
  float *v3;
  float result;

  if (!a2)
  {
    v3 = (float *)*((_QWORD *)this + 51);
    *a3 = v3[8];
    a3[1] = v3[9];
    a3[2] = v3[10];
    result = v3[11];
    a3[3] = result;
  }
  return result;
}

CFTimeInterval CACurrentMediaTime(void)
{
  CFTimeInterval result;

  MEMORY[0x1E0CD2388]();
  return result;
}

CAFrameRateRange CAFrameRateRangeMake(float minimum, float maximum, float preferred)
{
  float v3;
  float v4;
  float v5;
  CAFrameRateRange result;

  MEMORY[0x1E0CD23D0](minimum, maximum, preferred);
  result.preferred = v5;
  result.maximum = v4;
  result.minimum = v3;
  return result;
}

unsigned __int8 *__cdecl CC_MD5(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1E0C80308](data, *(_QWORD *)&len, md);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1E0C80328](data, *(_QWORD *)&len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

CFIndex CFArrayBSearchValues(CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  return MEMORY[0x1E0C97D08](theArray, range.location, range.length, value, comparator, context);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

void CFAttributedStringBeginEditing(CFMutableAttributedStringRef aStr)
{
  MEMORY[0x1E0C97DE8](aStr);
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x1E0C97DF0](alloc, str, attributes);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1E0C97E00](alloc, maxLength);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFAttributedStringRef aStr)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1E0C97E08](alloc, maxLength, aStr);
}

void CFAttributedStringEndEditing(CFMutableAttributedStringRef aStr)
{
  MEMORY[0x1E0C97E18](aStr);
}

CFTypeRef CFAttributedStringGetAttribute(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange *effectiveRange)
{
  return (CFTypeRef)MEMORY[0x1E0C97E20](aStr, loc, attrName, effectiveRange);
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  return (CFTypeRef)MEMORY[0x1E0C97E28](aStr, loc, attrName, inRange.location, inRange.length, longestEffectiveRange);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x1E0C97E48](aStr);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  return (CFStringRef)MEMORY[0x1E0C97E50](aStr);
}

void CFAttributedStringRemoveAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName)
{
  MEMORY[0x1E0C97E60](aStr, range.location, range.length, attrName);
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C97E70](aStr, range.location, range.length, replacement);
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
  MEMORY[0x1E0C97E78](aStr, range.location, range.length, attrName, value);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1E0C98000](bundle);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1E0C98080](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1E0C98120](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0C98180](bundle, key);
}

UInt32 CFBundleGetVersionNumber(CFBundleRef bundle)
{
  return MEMORY[0x1E0C98188](bundle);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982E8](alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982F0](theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x1E0C98320](theSet, theChar);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1E0C98408](theData);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98630](err);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1E0C98798](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987D8](locale);
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1E0C98910](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

void CFPreferencesAddSuitePreferencesToApp(CFStringRef applicationID, CFStringRef suiteID)
{
  MEMORY[0x1E0C98A28](applicationID, suiteID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A78](key, applicationID, keyExistsAndHasValidFormat);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BE8](rl, observer, mode);
}

CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  return (CFRunLoopObserverRef)MEMORY[0x1E0C98C60](allocator, activities, repeats, order, callout, context);
}

void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer)
{
  MEMORY[0x1E0C98C78](observer);
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C88](rl, observer, mode);
}

void CFShow(CFTypeRef obj)
{
  MEMORY[0x1E0C98DF8](obj);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  MEMORY[0x1E0C98EE0](theString, cStr, *(_QWORD *)&encoding);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F18](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1E0C98F58](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1E0C98F68](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FE0](alloc, cStr, *(_QWORD *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1E0C98FE8](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1E0C99020](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  MEMORY[0x1E0C99038](theString, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x1E0C990C0](theString, range.location, range.length, buffer);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1E0C990F0](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99118](length, *(_QWORD *)&encoding);
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex v2;
  CFIndex v3;
  CFRange result;

  v2 = MEMORY[0x1E0C99160](theString, theIndex);
  result.length = v3;
  result.location = v2;
  return result;
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C991F0](theString, range.location, range.length, replacement);
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return MEMORY[0x1E0C99208](tokenizer);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x1E0C99220](alloc, string, range.location, range.length, options, locale);
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex v1;
  CFIndex v2;
  CFRange result;

  v1 = MEMORY[0x1E0C99230](tokenizer);
  result.length = v2;
  result.location = v1;
  return result;
}

CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(CFStringTokenizerRef tokenizer, CFIndex index)
{
  return MEMORY[0x1E0C99238](tokenizer, index);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1E0C992C8](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C992F8](url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99318](anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C99320](url);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99348](anURL);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99390](allocator, url);
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99398](allocator, url);
}

CFURLRef CFURLCreateFileReferenceURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  return (CFURLRef)MEMORY[0x1E0C993C0](allocator, url, error);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1E0C99400](allocator, originalString, charactersToLeaveEscaped);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99438](allocator, filePath, pathStyle, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C994A0](anURL);
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  return MEMORY[0x1E0C994D0](url, error);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1E0C99518](alloc);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1E0C99520](alloc, uuidStr);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1E0C99538](alloc, uuid);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1E0C99558](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BA90](retstr, t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformFromString(CGAffineTransform *__return_ptr retstr, NSString *string)
{
  return (CGAffineTransform *)MEMORY[0x1E0CEA030](retstr, string);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAB0](retstr, t);
}

BOOL CGAffineTransformIsIdentity(CGAffineTransform *t)
{
  return MEMORY[0x1E0C9BAB8](t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAD0](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAD8](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAE0](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAF0](retstr, t, angle);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAF8](retstr, t, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BB00](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1E0C9BB10](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x1E0C9BB20](context);
}

CGContextRef CGBitmapContextCreateWithData(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo, CGBitmapContextReleaseDataCallback releaseCallback, void *releaseInfo)
{
  return (CGContextRef)MEMORY[0x1E0C9BB38](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo, releaseCallback);
}

CGColorConversionInfoRef CGColorConversionInfoCreate(CGColorSpaceRef src, CGColorSpaceRef dst)
{
  return (CGColorConversionInfoRef)MEMORY[0x1E0C9BC48](src, dst);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x1E0C9BC78](space, components);
}

CGColorRef CGColorCreateCopyByMatchingToColorSpace(CGColorSpaceRef a1, CGColorRenderingIntent intent, CGColorRef color, CFDictionaryRef options)
{
  return (CGColorRef)MEMORY[0x1E0C9BC88](a1, *(_QWORD *)&intent, color, options);
}

CGFloat CGColorGetAlpha(CGColorRef color)
{
  CGFloat result;

  MEMORY[0x1E0C9BCF8](color);
  return result;
}

CGColorSpaceRef CGColorGetColorSpace(CGColorRef color)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BD00](color);
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  return (const CGFloat *)MEMORY[0x1E0C9BD08](color);
}

size_t CGColorGetNumberOfComponents(CGColorRef color)
{
  return MEMORY[0x1E0C9BD20](color);
}

void CGColorRelease(CGColorRef color)
{
  MEMORY[0x1E0C9BD60](color);
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x1E0C9BD68](color);
}

CFDataRef CGColorSpaceCopyICCData(CGColorSpaceRef space)
{
  return (CFDataRef)MEMORY[0x1E0C9BD98](space);
}

CFDataRef CGColorSpaceCopyICCProfile(CGColorSpaceRef space)
{
  return (CFDataRef)MEMORY[0x1E0C9BDA0](space);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDF0]();
}

CGColorSpaceRef CGColorSpaceCreateExtended(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDF8](space);
}

CGColorSpaceRef CGColorSpaceCreateWithColorSyncProfile(ColorSyncProfileRef a1, CFDictionaryRef options)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE38](a1, options);
}

CGColorSpaceRef CGColorSpaceCreateWithICCData(CFTypeRef data)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE40](data);
}

CGColorSpaceRef CGColorSpaceCreateWithICCProfile(CFDataRef data)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE48](data);
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE50](name);
}

CGColorSpaceRef CGColorSpaceGetBaseColorSpace(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE80](space);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BEC8](space);
}

size_t CGColorSpaceGetNumberOfComponents(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BED8](space);
}

BOOL CGColorSpaceIsHLGBased(CGColorSpaceRef s)
{
  return MEMORY[0x1E0C9BF08](s);
}

BOOL CGColorSpaceIsPQBased(CGColorSpaceRef s)
{
  return MEMORY[0x1E0C9BF18](s);
}

BOOL CGColorSpaceIsWideGamutRGB(CGColorSpaceRef a1)
{
  return MEMORY[0x1E0C9BF28](a1);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  MEMORY[0x1E0C9BF30](space);
}

CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BF38](space);
}

BOOL CGColorSpaceUsesExtendedRange(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BF48](space);
}

BOOL CGColorSpaceUsesITUR_2100TF(CGColorSpaceRef a1)
{
  return MEMORY[0x1E0C9BF50](a1);
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9BFD0](c, x, y);
}

void CGContextClearRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C020](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
  MEMORY[0x1E0C9C050](c, transform);
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x1E0C9C170](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C220](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextFlush(CGContextRef c)
{
  MEMORY[0x1E0C9C230](c);
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9C330](c, x, y);
}

void CGContextRelease(CGContextRef c)
{
  MEMORY[0x1E0C9C340](c);
}

void CGContextRestoreGState(CGContextRef c)
{
  MEMORY[0x1E0C9C370](c);
}

CGContextRef CGContextRetain(CGContextRef c)
{
  return (CGContextRef)MEMORY[0x1E0C9C378](c);
}

void CGContextSaveGState(CGContextRef c)
{
  MEMORY[0x1E0C9C388](c);
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  MEMORY[0x1E0C9C390](c, sx, sy);
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
  MEMORY[0x1E0C9C3B8](c, alpha);
}

void CGContextSetBlendMode(CGContextRef c, CGBlendMode mode)
{
  MEMORY[0x1E0C9C3C8](c, *(_QWORD *)&mode);
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x1E0C9C408](c, color);
}

void CGContextSetGrayFillColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  MEMORY[0x1E0C9C448](c, gray, alpha);
}

void CGContextSetGrayStrokeColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  MEMORY[0x1E0C9C450](c, gray, alpha);
}

void CGContextSetInterpolationQuality(CGContextRef c, CGInterpolationQuality quality)
{
  MEMORY[0x1E0C9C458](c, *(_QWORD *)&quality);
}

void CGContextSetLineJoin(CGContextRef c, CGLineJoin join)
{
  MEMORY[0x1E0C9C478](c, *(_QWORD *)&join);
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
  MEMORY[0x1E0C9C480](c, width);
}

void CGContextSetMiterLimit(CGContextRef c, CGFloat limit)
{
  MEMORY[0x1E0C9C490](c, limit);
}

void CGContextSetRGBFillColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x1E0C9C4A0](c, red, green, blue, alpha);
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x1E0C9C4A8](c, red, green, blue, alpha);
}

void CGContextSetTextDrawingMode(CGContextRef c, CGTextDrawingMode mode)
{
  MEMORY[0x1E0C9C520](c, *(_QWORD *)&mode);
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9C538](c, x, y);
}

void CGContextStrokePath(CGContextRef c)
{
  MEMORY[0x1E0C9C570](c);
}

void CGContextStrokeRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C578](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  MEMORY[0x1E0C9C588](c, tx, ty);
}

CFDataRef CGDataProviderCopyData(CGDataProviderRef provider)
{
  return (CFDataRef)MEMORY[0x1E0C9C5D8](provider);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C600](info, data, size, releaseData);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
  MEMORY[0x1E0C9C638](provider);
}

CGDataProviderRef CGDataProviderRetain(CGDataProviderRef provider)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C648](provider);
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x1E0C9CB80](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(_QWORD *)&bitmapInfo, provider);
}

CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space)
{
  return (CGImageRef)MEMORY[0x1E0C9CB98](image, space);
}

CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect)
{
  return (CGImageRef)MEMORY[0x1E0C9CBA8](image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
  MEMORY[0x1E0CBC308](idst, image, properties);
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x1E0CBC348](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x1E0CBC358](idst);
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  return MEMORY[0x1E0C9CBE8](image);
}

CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image)
{
  return MEMORY[0x1E0C9CBF0](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x1E0C9CBF8](image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return MEMORY[0x1E0C9CC00](image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return MEMORY[0x1E0C9CC08](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9CC20](image);
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9CC38](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1E0C9CC60](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1E0C9CCD0](image);
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x1E0C9CDA0](image);
}

CGImageRef CGImageRetain(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x1E0C9CDA8](image);
}

CFDictionaryRef CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CFDictionaryRef)MEMORY[0x1E0CBC530](isrc, index, options);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x1E0CBC568](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1E0CBC590](data, options);
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1E0CBC5C0](url, options);
}

size_t CGImageSourceGetCount(CGImageSourceRef isrc)
{
  return MEMORY[0x1E0CBC5F0](isrc);
}

CFStringRef CGImageSourceGetType(CGImageSourceRef isrc)
{
  return (CFStringRef)MEMORY[0x1E0CBC618](isrc);
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D2A8](path, m, x, y);
}

void CGPathAddPath(CGMutablePathRef path1, const CGAffineTransform *m, CGPathRef path2)
{
  MEMORY[0x1E0C9D2B8](path1, m, path2);
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
  MEMORY[0x1E0C9D310](path);
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return MEMORY[0x1E0C9D318](path, m, eoFill, (__n128)point, *(__n128 *)&point.y);
}

CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat lineWidth, CGLineCap lineCap, CGLineJoin lineJoin, CGFloat miterLimit)
{
  return (CGPathRef)MEMORY[0x1E0C9D348](path, transform, *(_QWORD *)&lineCap, *(_QWORD *)&lineJoin, lineWidth, miterLimit);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x1E0C9D388]();
}

CGMutablePathRef CGPathCreateMutableCopy(CGPathRef path)
{
  return (CGMutablePathRef)MEMORY[0x1E0C9D390](path);
}

CGPathRef CGPathCreateWithEllipseInRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x1E0C9D3C0](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D490](path, m, x, y);
}

void CGPathRelease(CGPathRef path)
{
  MEMORY[0x1E0C9D498](path);
}

CGPathRef CGPathRetain(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x1E0C9D4A0](path);
}

CGPoint CGPointFromString(NSString *string)
{
  double v1;
  double v2;
  CGPoint result;

  MEMORY[0x1E0CEA038](string);
  result.y = v2;
  result.x = v1;
  return result;
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D548](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return MEMORY[0x1E0C9D550]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, (__n128)point, *(__n128 *)&point.y);
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D558]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D570]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D580]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D588]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5A0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5A8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5B0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5D0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x1E0C9D5E8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CGRectIntegral(CGRect rect)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x1E0C9D5F0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D5F8]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectIntersectsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D600]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x1E0C9D608]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x1E0C9D620](dict, rect);
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D640]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

OSStatus CMMetadataFormatDescriptionCreateWithMetadataSpecifications(CFAllocatorRef allocator, CMMetadataFormatType metadataType, CFArrayRef metadataSpecifications, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  return MEMORY[0x1E0C9EE90](allocator, *(_QWORD *)&metadataType, metadataSpecifications, formatDescriptionOut);
}

OSStatus CMSampleBufferCreateReadyWithImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return MEMORY[0x1E0C9EF80](allocator, imageBuffer, formatDescription, sampleTiming, sampleBufferOut);
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  return (CVImageBufferRef)MEMORY[0x1E0C9EFD8](sbuf);
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return (CMTime *)MEMORY[0x1E0C9F008](retstr, sbuf);
}

CMTime *__cdecl CMTimeAdd(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  return (CMTime *)MEMORY[0x1E0C9F298](retstr, lhs, rhs);
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  return MEMORY[0x1E0C9F2D8](time1, time2);
}

CMTime *__cdecl CMTimeConvertScale(CMTime *__return_ptr retstr, CMTime *time, int32_t newTimescale, CMTimeRoundingMethod method)
{
  return (CMTime *)MEMORY[0x1E0C9F2E0](retstr, time, *(_QWORD *)&newTimescale, *(_QWORD *)&method);
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9F2F0](time, allocator);
}

CFStringRef CMTimeCopyDescription(CFAllocatorRef allocator, CMTime *time)
{
  return (CFStringRef)MEMORY[0x1E0C9F2F8](allocator, time);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  Float64 result;

  MEMORY[0x1E0C9F310](time);
  return result;
}

CMTime *__cdecl CMTimeMake(CMTime *__return_ptr retstr, int64_t value, int32_t timescale)
{
  return (CMTime *)MEMORY[0x1E0C9F318](retstr, value, *(_QWORD *)&timescale);
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  return (CMTime *)MEMORY[0x1E0C9F320](retstr, dictionaryRepresentation);
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  return (CMTime *)MEMORY[0x1E0C9F330](retstr, *(_QWORD *)&preferredTimescale, seconds);
}

CMTime *__cdecl CMTimeMaximum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  return (CMTime *)MEMORY[0x1E0C9F370](retstr, time1, time2);
}

CMTime *__cdecl CMTimeMinimum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  return (CMTime *)MEMORY[0x1E0C9F378](retstr, time1, time2);
}

CMTime *__cdecl CMTimeMultiply(CMTime *__return_ptr retstr, CMTime *time, int32_t multiplier)
{
  return (CMTime *)MEMORY[0x1E0C9F380](retstr, time, *(_QWORD *)&multiplier);
}

CMTime *__cdecl CMTimeMultiplyByFloat64(CMTime *__return_ptr retstr, CMTime *time, Float64 multiplier)
{
  return (CMTime *)MEMORY[0x1E0C9F388](retstr, time, multiplier);
}

Boolean CMTimeRangeContainsTime(CMTimeRange *range, CMTime *time)
{
  return MEMORY[0x1E0C9F3A0](range, time);
}

CFStringRef CMTimeRangeCopyDescription(CFAllocatorRef allocator, CMTimeRange *range)
{
  return (CFStringRef)MEMORY[0x1E0C9F3B8](allocator, range);
}

Boolean CMTimeRangeEqual(CMTimeRange *range1, CMTimeRange *range2)
{
  return MEMORY[0x1E0C9F3C0](range1, range2);
}

CMTime *__cdecl CMTimeRangeGetEnd(CMTime *__return_ptr retstr, CMTimeRange *range)
{
  return (CMTime *)MEMORY[0x1E0C9F3D0](retstr, range);
}

CMTime *__cdecl CMTimeSubtract(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  return (CMTime *)MEMORY[0x1E0C9F400](retstr, lhs, rhs);
}

OSStatus CMVideoFormatDescriptionCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return MEMORY[0x1E0C9F528](allocator, imageBuffer, formatDescriptionOut);
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  return (CMVideoDimensions)MEMORY[0x1E0C9F558](videoDesc);
}

CFStringRef CTFontCopyPostScriptName(CTFontRef font)
{
  return (CFStringRef)MEMORY[0x1E0CA79E0](font);
}

CTFontRef CTFontCreateCopyWithAttributes(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  return (CTFontRef)MEMORY[0x1E0CA7A30](font, matrix, attributes, size);
}

CTFontRef CTFontCreateWithFontDescriptor(CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x1E0CA7A70](descriptor, matrix, size);
}

CTFontRef CTFontCreateWithName(CFStringRef name, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x1E0CA7A88](name, matrix, size);
}

CTFontDescriptorRef CTFontDescriptorCreateWithAttributes(CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x1E0CA7B00](attributes);
}

CTFontDescriptorRef CTFontDescriptorCreateWithNameAndSize(CFStringRef name, CGFloat size)
{
  return (CTFontDescriptorRef)MEMORY[0x1E0CA7B10](name, size);
}

void CTFontDrawGlyphs(CTFontRef font, const CGGlyph *glyphs, const CGPoint *positions, size_t count, CGContextRef context)
{
  MEMORY[0x1E0CA7B70](font, glyphs, positions, count, context);
}

CGFloat CTFontGetAscent(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0CA7BA0](font);
  return result;
}

CGRect CTFontGetBoundingRectsForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGRect *boundingRects, CFIndex count)
{
  double v5;
  double v6;
  double v7;
  double v8;
  CGRect result;

  MEMORY[0x1E0CA7BB8](font, *(_QWORD *)&orientation, glyphs, boundingRects, count);
  result.size.height = v8;
  result.size.width = v7;
  result.origin.y = v6;
  result.origin.x = v5;
  return result;
}

CGFloat CTFontGetCapHeight(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0CA7BC0](font);
  return result;
}

CGFloat CTFontGetDescent(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0CA7BD8](font);
  return result;
}

CGFloat CTFontGetLeading(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0CA7C20](font);
  return result;
}

CGFloat CTFontGetSize(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0CA7C50](font);
  return result;
}

void CTFontGetVerticalTranslationsForGlyphs(CTFontRef font, const CGGlyph *glyphs, CGSize *translations, CFIndex count)
{
  MEMORY[0x1E0CA7CC0](font, glyphs, translations, count);
}

CGFloat CTFontGetXHeight(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0CA7CD0](font);
  return result;
}

BOOL CTFontManagerRegisterFontsForURL(CFURLRef fontURL, CTFontManagerScope scope, CFErrorRef *error)
{
  return MEMORY[0x1E0CA7D48](fontURL, *(_QWORD *)&scope, error);
}

CTLineRef CTLineCreateJustifiedLine(CTLineRef line, CGFloat justificationFactor, double justificationWidth)
{
  return (CTLineRef)MEMORY[0x1E0CA7E60](line, justificationFactor, justificationWidth);
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  return (CTLineRef)MEMORY[0x1E0CA7E88](attrString);
}

void CTLineEnumerateCaretOffsets(CTLineRef line, void *block)
{
  MEMORY[0x1E0CA7EB8](line, block);
}

CFIndex CTLineGetGlyphCount(CTLineRef line)
{
  return MEMORY[0x1E0CA7ED0](line);
}

CFArrayRef CTLineGetGlyphRuns(CTLineRef line)
{
  return (CFArrayRef)MEMORY[0x1E0CA7ED8](line);
}

double CTLineGetPenOffsetForFlush(CTLineRef line, CGFloat flushFactor, double flushWidth)
{
  double result;

  MEMORY[0x1E0CA7EF0](line, flushFactor, flushWidth);
  return result;
}

CFRange CTLineGetStringRange(CTLineRef line)
{
  CFIndex v1;
  CFIndex v2;
  CFRange result;

  v1 = MEMORY[0x1E0CA7F08](line);
  result.length = v2;
  result.location = v1;
  return result;
}

double CTLineGetTrailingWhitespaceWidth(CTLineRef line)
{
  double result;

  MEMORY[0x1E0CA7F10](line);
  return result;
}

double CTLineGetTypographicBounds(CTLineRef line, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  double result;

  MEMORY[0x1E0CA7F18](line, ascent, descent, leading);
  return result;
}

CTParagraphStyleRef CTParagraphStyleCreate(const CTParagraphStyleSetting *settings, size_t settingCount)
{
  return (CTParagraphStyleRef)MEMORY[0x1E0CA7F60](settings, settingCount);
}

BOOL CTParagraphStyleGetValueForSpecifier(CTParagraphStyleRef paragraphStyle, CTParagraphStyleSpecifier spec, size_t valueBufferSize, void *valueBuffer)
{
  return MEMORY[0x1E0CA7F70](paragraphStyle, *(_QWORD *)&spec, valueBufferSize, valueBuffer);
}

void CTRunGetAdvances(CTRunRef run, CFRange range, CGSize *buffer)
{
  MEMORY[0x1E0CA7FA0](run, range.location, range.length, buffer);
}

const CGSize *__cdecl CTRunGetAdvancesPtr(CTRunRef run)
{
  return (const CGSize *)MEMORY[0x1E0CA7FA8](run);
}

CFDictionaryRef CTRunGetAttributes(CTRunRef run)
{
  return (CFDictionaryRef)MEMORY[0x1E0CA7FB0](run);
}

CFIndex CTRunGetGlyphCount(CTRunRef run)
{
  return MEMORY[0x1E0CA7FD0](run);
}

void CTRunGetGlyphs(CTRunRef run, CFRange range, CGGlyph *buffer)
{
  MEMORY[0x1E0CA7FE0](run, range.location, range.length, buffer);
}

const CGGlyph *__cdecl CTRunGetGlyphsPtr(CTRunRef run)
{
  return (const CGGlyph *)MEMORY[0x1E0CA7FE8](run);
}

void CTRunGetPositions(CTRunRef run, CFRange range, CGPoint *buffer)
{
  MEMORY[0x1E0CA8008](run, range.location, range.length, buffer);
}

const CGPoint *__cdecl CTRunGetPositionsPtr(CTRunRef run)
{
  return (const CGPoint *)MEMORY[0x1E0CA8010](run);
}

CTRunStatus CTRunGetStatus(CTRunRef run)
{
  return MEMORY[0x1E0CA8020](run);
}

void CTRunGetStringIndices(CTRunRef run, CFRange range, CFIndex *buffer)
{
  MEMORY[0x1E0CA8030](run, range.location, range.length, buffer);
}

const CFIndex *__cdecl CTRunGetStringIndicesPtr(CTRunRef run)
{
  return (const CFIndex *)MEMORY[0x1E0CA8038](run);
}

CFRange CTRunGetStringRange(CTRunRef run)
{
  CFIndex v1;
  CFIndex v2;
  CFRange result;

  v1 = MEMORY[0x1E0CA8040](run);
  result.length = v2;
  result.location = v1;
  return result;
}

CGAffineTransform *__cdecl CTRunGetTextMatrix(CGAffineTransform *__return_ptr retstr, CTRunRef run)
{
  return (CGAffineTransform *)MEMORY[0x1E0CA8048](retstr, run);
}

double CTRunGetTypographicBounds(CTRunRef run, CFRange range, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  double result;

  MEMORY[0x1E0CA8050](run, range.location, range.length, ascent, descent, leading);
  return result;
}

CTTextTabRef CTTextTabCreate(CTTextAlignment alignment, double location, CFDictionaryRef options)
{
  return (CTTextTabRef)MEMORY[0x1E0CA8078](alignment, options, location);
}

CTTextAlignment CTTextTabGetAlignment(CTTextTabRef tab)
{
  return MEMORY[0x1E0CA8080](tab);
}

double CTTextTabGetLocation(CTTextTabRef tab)
{
  double result;

  MEMORY[0x1E0CA8088](tab);
  return result;
}

CTLineRef CTTypesetterCreateLine(CTTypesetterRef typesetter, CFRange stringRange)
{
  return (CTLineRef)MEMORY[0x1E0CA8090](typesetter, stringRange.location, stringRange.length);
}

CTTypesetterRef CTTypesetterCreateWithAttributedString(CFAttributedStringRef string)
{
  return (CTTypesetterRef)MEMORY[0x1E0CA8098](string);
}

CFIndex CTTypesetterSuggestLineBreak(CTTypesetterRef typesetter, CFIndex startIndex, double width)
{
  return MEMORY[0x1E0CA80C8](typesetter, startIndex, width);
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1E0CA8900](buffer, key, attachmentMode);
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
  MEMORY[0x1E0CA8950](buffer, key, value, *(_QWORD *)&attachmentMode);
}

CGColorSpaceRef CVImageBufferCreateColorSpaceFromAttachments(CFDictionaryRef attachments)
{
  return (CGColorSpaceRef)MEMORY[0x1E0CA89D0](attachments);
}

CVReturn CVMetalTextureCacheCreate(CFAllocatorRef allocator, CFDictionaryRef cacheAttributes, id metalDevice, CFDictionaryRef textureAttributes, CVMetalTextureCacheRef *cacheOut)
{
  return MEMORY[0x1E0CA8A30](allocator, cacheAttributes, metalDevice, textureAttributes, cacheOut);
}

CVReturn CVMetalTextureCacheCreateTextureFromImage(CFAllocatorRef allocator, CVMetalTextureCacheRef textureCache, CVImageBufferRef sourceImage, CFDictionaryRef textureAttributes, MTLPixelFormat pixelFormat, size_t width, size_t height, size_t planeIndex, CVMetalTextureRef *textureOut)
{
  return MEMORY[0x1E0CA8A38](allocator, textureCache, sourceImage, textureAttributes, pixelFormat, width, height, planeIndex);
}

void CVMetalTextureCacheFlush(CVMetalTextureCacheRef textureCache, CVOptionFlags options)
{
  MEMORY[0x1E0CA8A40](textureCache, options);
}

id CVMetalTextureGetTexture(CVMetalTextureRef image)
{
  return (id)MEMORY[0x1E0CA8A50](image);
}

CVReturn CVOpenGLESTextureCacheCreate(CFAllocatorRef allocator, CFDictionaryRef cacheAttributes, CVEAGLContext eaglContext, CFDictionaryRef textureAttributes, CVOpenGLESTextureCacheRef *cacheOut)
{
  return MEMORY[0x1E0CA8A60](allocator, cacheAttributes, eaglContext, textureAttributes, cacheOut);
}

CVReturn CVOpenGLESTextureCacheCreateTextureFromImage(CFAllocatorRef allocator, CVOpenGLESTextureCacheRef textureCache, CVImageBufferRef sourceImage, CFDictionaryRef textureAttributes, GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, size_t planeIndex, CVOpenGLESTextureRef *textureOut)
{
  return MEMORY[0x1E0CA8A68](allocator, textureCache, sourceImage, textureAttributes, *(_QWORD *)&target, *(_QWORD *)&internalFormat, *(_QWORD *)&width, *(_QWORD *)&height);
}

void CVOpenGLESTextureCacheFlush(CVOpenGLESTextureCacheRef textureCache, CVOptionFlags options)
{
  MEMORY[0x1E0CA8A70](textureCache, options);
}

GLuint CVOpenGLESTextureGetName(CVOpenGLESTextureRef image)
{
  return MEMORY[0x1E0CA8A78](image);
}

GLenum CVOpenGLESTextureGetTarget(CVOpenGLESTextureRef image)
{
  return MEMORY[0x1E0CA8A80](image);
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8A98](allocator, width, height, *(_QWORD *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x1E0CA8AE0](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x1E0CA8AE8](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8AF8](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1E0CA8B00](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B08](pixelBuffer);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B20](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1E0CA8B28](pixelBuffer, planeIndex);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x1E0CA8B30](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B38](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B40](pixelBuffer);
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B50](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1E0CA8B58](pixelBuffer, planeIndex);
}

Boolean CVPixelBufferIsPlanar(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B68](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x1E0CA8B70](pixelBuffer, lockFlags);
}

CVReturn CVPixelBufferPoolCreate(CFAllocatorRef allocator, CFDictionaryRef poolAttributes, CFDictionaryRef pixelBufferAttributes, CVPixelBufferPoolRef *poolOut)
{
  return MEMORY[0x1E0CA8B78](allocator, poolAttributes, pixelBufferAttributes, poolOut);
}

CVReturn CVPixelBufferPoolCreatePixelBuffer(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8B80](allocator, pixelBufferPool, pixelBufferOut);
}

void CVPixelBufferPoolFlush(CVPixelBufferPoolRef pool, CVPixelBufferPoolFlushFlags options)
{
  MEMORY[0x1E0CA8B90](pool, options);
}

void CVPixelBufferPoolRelease(CVPixelBufferPoolRef pixelBufferPool)
{
  MEMORY[0x1E0CA8BC8](pixelBufferPool);
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
  MEMORY[0x1E0CA8BF0](texture);
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x1E0CA8BF8](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x1E0CA8C00](pixelBuffer, unlockFlags);
}

CFDictionaryRef CVPixelFormatDescriptionCreateWithPixelFormatType(CFAllocatorRef allocator, OSType pixelFormat)
{
  return (CFDictionaryRef)MEMORY[0x1E0CA8C08](allocator, *(_QWORD *)&pixelFormat);
}

CFDataRef ColorSyncProfileCopyHeader(ColorSyncProfileRef prof)
{
  return (CFDataRef)MEMORY[0x1E0C95460](prof);
}

ColorSyncProfileRef ColorSyncProfileCreate(CFDataRef data, CFErrorRef *error)
{
  return (ColorSyncProfileRef)MEMORY[0x1E0C95470](data, error);
}

ColorSyncMutableProfileRef ColorSyncProfileCreateMutableCopy(ColorSyncProfileRef prof)
{
  return (ColorSyncMutableProfileRef)MEMORY[0x1E0C95480](prof);
}

ColorSyncMD5 ColorSyncProfileGetMD5(ColorSyncProfileRef prof)
{
  uint64_t v1;
  uint64_t v2;
  ColorSyncMD5 result;

  v1 = MEMORY[0x1E0C954A0](prof);
  *(_QWORD *)&result.digest[8] = v2;
  *(_QWORD *)result.digest = v1;
  return result;
}

void ColorSyncProfileSetHeader(ColorSyncMutableProfileRef prof, CFDataRef header)
{
  MEMORY[0x1E0C954B0](prof, header);
}

void ColorSyncProfileSetTag(ColorSyncMutableProfileRef prof, CFStringRef signature, CFDataRef data)
{
  MEMORY[0x1E0C954B8](prof, signature, data);
}

CFTypeRef ColorSyncTransformCopyProperty(ColorSyncTransformRef transform, CFTypeRef key, CFDictionaryRef options)
{
  return (CFTypeRef)MEMORY[0x1E0C954C8](transform, key, options);
}

ColorSyncTransformRef ColorSyncTransformCreate(CFArrayRef profileSequence, CFDictionaryRef options)
{
  return (ColorSyncTransformRef)MEMORY[0x1E0C954D0](profileSequence, options);
}

Boolean IOSurfaceAllowsPixelSizeCasting(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBAC8](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1E0CBBB40](buffer);
}

size_t IOSurfaceGetBytesPerRow(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB90](buffer);
}

IOSurfaceID IOSurfaceGetID(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC48](buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBD28](buffer, *(_QWORD *)&options, seed);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBE88](buffer, *(_QWORD *)&options, seed);
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x1E0CC6980]();
}

id NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone)
{
  return (id)MEMORY[0x1E0CB2868](aClass, extraBytes, zone);
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

NSString *NSHomeDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB2C00]();
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

void NSLogv(NSString *format, va_list args)
{
  MEMORY[0x1E0CB2D90](format, args);
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x1E0CB3178](directory, domainMask, expandTilde);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x1E0CB3190](aSelectorName);
}

NSString *__cdecl NSStringFromCGAffineTransform(CGAffineTransform *transform)
{
  return (NSString *)MEMORY[0x1E0CEA100](transform);
}

NSString *__cdecl NSStringFromCGPoint(CGPoint point)
{
  return (NSString *)MEMORY[0x1E0CEA108]((__n128)point, *(__n128 *)&point.y);
}

NSString *__cdecl NSStringFromCGRect(CGRect rect)
{
  return (NSString *)MEMORY[0x1E0CEA110]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

NSString *__cdecl NSStringFromCGSize(CGSize size)
{
  return (NSString *)MEMORY[0x1E0CEA118]((__n128)size, *(__n128 *)&size.height);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

NSString *__cdecl NSStringFromProtocol(Protocol *proto)
{
  return (NSString *)MEMORY[0x1E0CB3218](proto);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1E0CB3230](aSelector);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB3250]();
}

void SCNExportJavaScriptModule(JSContext *context)
{
  MEMORY[0x1E0CD5A48](context);
}

SCNMatrix4 *__cdecl SCNMatrix4Mult(SCNMatrix4 *__return_ptr retstr, SCNMatrix4 *a, SCNMatrix4 *b)
{
  return (SCNMatrix4 *)MEMORY[0x1E0CD5B30](retstr, a, b);
}

void UIGraphicsBeginImageContextWithOptions(CGSize size, BOOL opaque, CGFloat scale)
{
  MEMORY[0x1E0CEB630](opaque, (__n128)size, *(__n128 *)&size.height, scale);
}

void UIGraphicsEndImageContext(void)
{
  MEMORY[0x1E0CEB638]();
}

CGContextRef UIGraphicsGetCurrentContext(void)
{
  return (CGContextRef)MEMORY[0x1E0CEB640]();
}

UIImage *UIGraphicsGetImageFromCurrentImageContext(void)
{
  return (UIImage *)MEMORY[0x1E0CEB648]();
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x1E0C80940](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1E0DE41F0]();
}

{
  return MEMORY[0x1E0DE4800]();
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1E0DE4240](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

void std::exception_ptr::~exception_ptr(std::exception_ptr *this)
{
  MEMORY[0x1E0DE42F8](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1E0DE4308](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

void std::__call_once(std::once_flag::_State_type *a1, void *a2, void (__cdecl *a3)(void *))
{
  MEMORY[0x1E0DE43A8](a1, a2, a3);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1E0DE43B0](this, *(_QWORD *)&__ecode);
}

void std::this_thread::sleep_for (const std::chrono::nanoseconds *__ns)
{
  MEMORY[0x1E0DE43C0](__ns);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4420](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4430](this, __str, __pos, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4440](this, __s);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4468](this, __pos, __s);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
  MEMORY[0x1E0DE44A8](this, __requested_capacity);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
  MEMORY[0x1E0DE44B0](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

std::string *__cdecl std::string::operator=(std::string *this, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1E0DE44E0](this, __c);
}

std::future_error *__cdecl std::future_error::future_error(std::future_error *this, std::error_code __ec)
{
  return (std::future_error *)MEMORY[0x1E0DE4538](this, *(_QWORD *)&__ec.__val_, __ec.__cat_);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1E0DE4590]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1E0DE4598]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1E0DE45A8]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1E0DE45B0]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1E0DE4608]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1E0DE4628]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1E0DE4698]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1E0DE46A0]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE46D0]();
}

{
  return MEMORY[0x1E0DE46E0]();
}

{
  return MEMORY[0x1E0DE46E8]();
}

{
  return MEMORY[0x1E0DE46F8]();
}

{
  return MEMORY[0x1E0DE4700]();
}

{
  return MEMORY[0x1E0DE4708]();
}

{
  return MEMORY[0x1E0DE4710]();
}

{
  return MEMORY[0x1E0DE4718]();
}

{
  return MEMORY[0x1E0DE4730]();
}

{
  return MEMORY[0x1E0DE4738]();
}

void std::__shared_count::~__shared_count(std::__shared_count *this)
{
  MEMORY[0x1E0DE4790](this);
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1E0DE47A8]();
}

uint64_t std::ofstream::open()
{
  return MEMORY[0x1E0DE47B0]();
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1E0DE47C8](__s, __icase);
}

std::__thread_struct *__cdecl std::__thread_struct::__thread_struct(std::__thread_struct *this)
{
  return (std::__thread_struct *)MEMORY[0x1E0DE47D0](this);
}

void std::__thread_struct::~__thread_struct(std::__thread_struct *this)
{
  MEMORY[0x1E0DE47D8](this);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

const std::error_category *std::future_category(void)
{
  return (const std::error_category *)MEMORY[0x1E0DE4818]();
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
  MEMORY[0x1E0DE4820](this);
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
  MEMORY[0x1E0DE4828](this);
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x1E0DE4838](this);
}

void std::recursive_mutex::~recursive_mutex(std::recursive_mutex *this)
{
  MEMORY[0x1E0DE4840](this);
}

void std::__assoc_sub_state::set_exception(std::__assoc_sub_state *this, std::exception_ptr __p)
{
  MEMORY[0x1E0DE4868](this, __p.__ptr_);
}

void std::__assoc_sub_state::wait(std::__assoc_sub_state *this)
{
  MEMORY[0x1E0DE4870](this);
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
  MEMORY[0x1E0DE4890](this);
}

void std::condition_variable::__do_timed_wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk, std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> a3)
{
  MEMORY[0x1E0DE48A0](this, __lk, a3.__d_.__rep_);
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
  MEMORY[0x1E0DE48A8](this, __lk);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x1E0DE48B0](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

std::__thread_specific_ptr<std::__thread_struct> *std::__thread_local_data(void)
{
  return (std::__thread_specific_ptr<std::__thread_struct> *)MEMORY[0x1E0DE4908]();
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1E0DE4910](retstr, __s);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
  MEMORY[0x1E0DE4920](*(_QWORD *)&__ev, __what_arg);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

uint64_t std::__sort<std::__less<double,double> &,double *>()
{
  return MEMORY[0x1E0DE4AE0]();
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1E0DE4B38]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1E0DE4B48]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1E0DE4B88](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1E0DE4B90](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::thread::detach(std::thread *this)
{
  MEMORY[0x1E0DE4BC0](this);
}

void std::thread::~thread(std::thread *this)
{
  MEMORY[0x1E0DE4BC8](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x1E0DE4C50](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1E0DE4D40](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D58](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D60](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x1E0DE4D70](retstr, __val);
}

{
  return (std::string *)MEMORY[0x1E0DE4D80](retstr, __val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1E0DE4D88]();
}

void std::bad_cast::~bad_cast(std::bad_cast *this)
{
  MEMORY[0x1E0DE4DA0](this);
}

std::bad_alloc *__cdecl std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  return (std::bad_alloc *)MEMORY[0x1E0DE4DB0](this);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1E0DE4DD8](this);
}

std::exception_ptr std::current_exception(void)
{
  return (std::exception_ptr)MEMORY[0x1E0DE4DF0]();
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E64D30B8();
}

void operator delete(void *__p)
{
  off_1E64D30C0(__p);
}

void operator delete(void *__p, const std::nothrow_t *a2)
{
  off_1E64D30C8(__p, a2);
}

uint64_t operator delete()
{
  return off_1E64D30D0();
}

uint64_t operator new[]()
{
  return off_1E64D30D8();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E64D30E0(__sz);
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1E64D30E8(__sz, a2);
}

uint64_t operator new()
{
  return off_1E64D30F0();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1E0C80A98](lpfunc, obj, lpdso_handle);
}

void __cxa_bad_cast(void)
{
  MEMORY[0x1E0DE5070]();
}

void __cxa_bad_typeid(void)
{
  MEMORY[0x1E0DE5078]();
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_call_unexpected(void *a1)
{
  MEMORY[0x1E0DE5088](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void *__cxa_get_exception_ptr(void *a1)
{
  return (void *)MEMORY[0x1E0DE50A8](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x1E0DE50B0](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE50D0]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1E0DE50E0](lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

double __exp10(double a1)
{
  double result;

  MEMORY[0x1E0C80AC8](a1);
  return result;
}

uint64_t __invert_d3()
{
  return MEMORY[0x1E0C80B18]();
}

uint64_t __invert_d4()
{
  return MEMORY[0x1E0C80B20]();
}

simd_float3x3 __invert_f3(simd_float3x3 a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  simd_float3x3 result;

  MEMORY[0x1E0C80B30]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2]);
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

simd_float4x4 __invert_f4(simd_float4x4 a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  simd_float4x4 result;

  MEMORY[0x1E0C80B38]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2], (__n128)a1.columns[3]);
  result.columns[3].i64[1] = v8;
  result.columns[3].i64[0] = v7;
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

__double2 __sincos_stret(double a1)
{
  double v1;
  double v2;
  __double2 result;

  MEMORY[0x1E0C80BC8](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x1E0C80BD0](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C78](*(_QWORD *)&a1);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

simd_float4 _simd_exp2_f4(simd_float4 x)
{
  simd_float4 result;

  MEMORY[0x1E0C811C8]((__n128)x);
  return result;
}

simd_float4 _simd_log_f4(simd_float4 x)
{
  simd_float4 result;

  MEMORY[0x1E0C811E8]((__n128)x);
  return result;
}

simd_float4 _simd_pow_f4(simd_float4 x, simd_float4 y)
{
  simd_float4 result;

  MEMORY[0x1E0C811F8]((__n128)x, (__n128)y);
  return result;
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

long double acos(long double __x)
{
  long double result;

  MEMORY[0x1E0C81500](__x);
  return result;
}

float acosf(float a1)
{
  float result;

  MEMORY[0x1E0C81508](a1);
  return result;
}

long double asin(long double __x)
{
  long double result;

  MEMORY[0x1E0C81598](__x);
  return result;
}

float asinf(float a1)
{
  float result;

  MEMORY[0x1E0C815A0](a1);
  return result;
}

long double atan(long double __x)
{
  long double result;

  MEMORY[0x1E0C81618](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x1E0C81620](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C81628](a1, a2);
  return result;
}

float atanf(float a1)
{
  float result;

  MEMORY[0x1E0C81630](a1);
  return result;
}

double atof(const char *a1)
{
  double result;

  MEMORY[0x1E0C81658](a1);
  return result;
}

int atoi(const char *a1)
{
  return MEMORY[0x1E0C81668](a1);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

long double cbrt(long double __x)
{
  long double result;

  MEMORY[0x1E0C81850](__x);
  return result;
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x1E0C82B40](__x);
  return result;
}

float cosf(float a1)
{
  float result;

  MEMORY[0x1E0C82B48](a1);
  return result;
}

int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BD10](__jobu, __jobvt, __m, __n, __a, __lda, __s, __u);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *context, void (__cdecl *work)(void *, size_t))
{
  MEMORY[0x1E0C82BE0](iterations, queue, context, work);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C68](flags, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D10](group, queue, block);
}

void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82D18](group, queue, context, work);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  MEMORY[0x1E0C82E10](predicate, context, function);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

long double erfc(long double __x)
{
  long double result;

  MEMORY[0x1E0C831F8](__x);
  return result;
}

float erff(float a1)
{
  float result;

  MEMORY[0x1E0C83200](a1);
  return result;
}

void exit(int a1)
{
  MEMORY[0x1E0C83278](*(_QWORD *)&a1);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x1E0C83280](__x);
  return result;
}

long double exp2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83288](__x);
  return result;
}

float exp2f(float a1)
{
  float result;

  MEMORY[0x1E0C83290](a1);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x1E0C83298](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int fegetround(void)
{
  return MEMORY[0x1E0C83338]();
}

int fesetround(int a1)
{
  return MEMORY[0x1E0C83358](*(_QWORD *)&a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C83440](__x, __y);
  return result;
}

float fmodf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C83448](a1, a2);
  return result;
}

const char *__cdecl fmtcheck(const char *a1, const char *a2)
{
  return (const char *)MEMORY[0x1E0C83450](a1, a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1E0C83490](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

int gethostname(char *a1, size_t a2)
{
  return MEMORY[0x1E0C836B8](a1, a2);
}

int getpagesize(void)
{
  return MEMORY[0x1E0C83740]();
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x1E0C837B8](*(_QWORD *)&a1, a2);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1E0C83820](a1, a2);
}

void glActiveTexture(GLenum texture)
{
  MEMORY[0x1E0CD0960](*(_QWORD *)&texture);
}

void glAttachShader(GLuint program, GLuint shader)
{
  MEMORY[0x1E0CD0968](*(_QWORD *)&program, *(_QWORD *)&shader);
}

void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
  MEMORY[0x1E0CD0970](*(_QWORD *)&program, *(_QWORD *)&index, name);
}

void glBindBuffer(GLenum target, GLuint buffer)
{
  MEMORY[0x1E0CD0978](*(_QWORD *)&target, *(_QWORD *)&buffer);
}

void glBindFramebuffer(GLenum target, GLuint framebuffer)
{
  MEMORY[0x1E0CD0980](*(_QWORD *)&target, *(_QWORD *)&framebuffer);
}

void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
  MEMORY[0x1E0CD0988](*(_QWORD *)&target, *(_QWORD *)&renderbuffer);
}

void glBindTexture(GLenum target, GLuint texture)
{
  MEMORY[0x1E0CD0990](*(_QWORD *)&target, *(_QWORD *)&texture);
}

uint64_t glBindVertexArrayOES()
{
  return MEMORY[0x1E0CD0998]();
}

void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  MEMORY[0x1E0CD09A0](red, green, blue, alpha);
}

void glBlendEquation(GLenum mode)
{
  MEMORY[0x1E0CD09A8](*(_QWORD *)&mode);
}

void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
  MEMORY[0x1E0CD09B0](*(_QWORD *)&modeRGB, *(_QWORD *)&modeAlpha);
}

void glBlendFunc(GLenum sfactor, GLenum dfactor)
{
  MEMORY[0x1E0CD09B8](*(_QWORD *)&sfactor, *(_QWORD *)&dfactor);
}

void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  MEMORY[0x1E0CD09C0](*(_QWORD *)&srcRGB, *(_QWORD *)&dstRGB, *(_QWORD *)&srcAlpha, *(_QWORD *)&dstAlpha);
}

void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
  MEMORY[0x1E0CD09C8](*(_QWORD *)&target, size, data, *(_QWORD *)&usage);
}

GLenum glCheckFramebufferStatus(GLenum target)
{
  return MEMORY[0x1E0CD09D8](*(_QWORD *)&target);
}

void glClear(GLbitfield mask)
{
  MEMORY[0x1E0CD09E0](*(_QWORD *)&mask);
}

void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  MEMORY[0x1E0CD09E8](red, green, blue, alpha);
}

void glClearDepthf(GLclampf depth)
{
  MEMORY[0x1E0CD09F0](depth);
}

uint64_t glClientWaitSyncAPPLE()
{
  return MEMORY[0x1E0CD09F8]();
}

void glColorMask(GLBOOLean red, GLBOOLean green, GLBOOLean blue, GLBOOLean alpha)
{
  MEMORY[0x1E0CD0A00](red, green, blue, alpha);
}

void glCompileShader(GLuint shader)
{
  MEMORY[0x1E0CD0A08](*(_QWORD *)&shader);
}

GLuint glCreateProgram(void)
{
  return MEMORY[0x1E0CD0A18]();
}

GLuint glCreateShader(GLenum type)
{
  return MEMORY[0x1E0CD0A20](*(_QWORD *)&type);
}

void glCullFace(GLenum mode)
{
  MEMORY[0x1E0CD0A28](*(_QWORD *)&mode);
}

void glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
  MEMORY[0x1E0CD0A30](*(_QWORD *)&n, buffers);
}

void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
  MEMORY[0x1E0CD0A38](*(_QWORD *)&n, framebuffers);
}

void glDeleteProgram(GLuint program)
{
  MEMORY[0x1E0CD0A40](*(_QWORD *)&program);
}

void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
  MEMORY[0x1E0CD0A48](*(_QWORD *)&n, renderbuffers);
}

void glDeleteShader(GLuint shader)
{
  MEMORY[0x1E0CD0A50](*(_QWORD *)&shader);
}

uint64_t glDeleteSyncAPPLE()
{
  return MEMORY[0x1E0CD0A58]();
}

void glDeleteTextures(GLsizei n, const GLuint *textures)
{
  MEMORY[0x1E0CD0A60](*(_QWORD *)&n, textures);
}

uint64_t glDeleteVertexArraysOES()
{
  return MEMORY[0x1E0CD0A68]();
}

void glDepthFunc(GLenum func)
{
  MEMORY[0x1E0CD0A70](*(_QWORD *)&func);
}

void glDepthMask(GLBOOLean flag)
{
  MEMORY[0x1E0CD0A78](flag);
}

void glDetachShader(GLuint program, GLuint shader)
{
  MEMORY[0x1E0CD0A80](*(_QWORD *)&program, *(_QWORD *)&shader);
}

void glDisable(GLenum cap)
{
  MEMORY[0x1E0CD0A88](*(_QWORD *)&cap);
}

void glDisableVertexAttribArray(GLuint index)
{
  MEMORY[0x1E0CD0A90](*(_QWORD *)&index);
}

uint64_t glDiscardFramebufferEXT()
{
  return MEMORY[0x1E0CD0A98]();
}

void glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
  MEMORY[0x1E0CD0AA0](*(_QWORD *)&mode, *(_QWORD *)&first, *(_QWORD *)&count);
}

void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
  MEMORY[0x1E0CD0AB0](*(_QWORD *)&mode, *(_QWORD *)&count, *(_QWORD *)&type, indices);
}

void glEnable(GLenum cap)
{
  MEMORY[0x1E0CD0AB8](*(_QWORD *)&cap);
}

void glEnableVertexAttribArray(GLuint index)
{
  MEMORY[0x1E0CD0AC0](*(_QWORD *)&index);
}

uint64_t glFenceSyncAPPLE()
{
  return MEMORY[0x1E0CD0AC8]();
}

void glFinish(void)
{
  MEMORY[0x1E0CD0AD0]();
}

void glFlush(void)
{
  MEMORY[0x1E0CD0AD8]();
}

void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  MEMORY[0x1E0CD0AE8](*(_QWORD *)&target, *(_QWORD *)&attachment, *(_QWORD *)&renderbuffertarget, *(_QWORD *)&renderbuffer);
}

void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  MEMORY[0x1E0CD0AF0](*(_QWORD *)&target, *(_QWORD *)&attachment, *(_QWORD *)&textarget, *(_QWORD *)&texture, *(_QWORD *)&level);
}

void glFrontFace(GLenum mode)
{
  MEMORY[0x1E0CD0AF8](*(_QWORD *)&mode);
}

void glGenBuffers(GLsizei n, GLuint *buffers)
{
  MEMORY[0x1E0CD0B00](*(_QWORD *)&n, buffers);
}

void glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
  MEMORY[0x1E0CD0B08](*(_QWORD *)&n, framebuffers);
}

void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
  MEMORY[0x1E0CD0B10](*(_QWORD *)&n, renderbuffers);
}

void glGenTextures(GLsizei n, GLuint *textures)
{
  MEMORY[0x1E0CD0B18](*(_QWORD *)&n, textures);
}

uint64_t glGenVertexArraysOES()
{
  return MEMORY[0x1E0CD0B20]();
}

void glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei *count, GLuint *shaders)
{
  MEMORY[0x1E0CD0B40](*(_QWORD *)&program, *(_QWORD *)&maxcount, count, shaders);
}

int glGetAttribLocation(GLuint program, const GLchar *name)
{
  return MEMORY[0x1E0CD0B48](*(_QWORD *)&program, name);
}

void glGetBooleanv(GLenum pname, GLBOOLean *params)
{
  MEMORY[0x1E0CD0B50](*(_QWORD *)&pname, params);
}

GLenum glGetError(void)
{
  return MEMORY[0x1E0CD0B58]();
}

void glGetIntegerv(GLenum pname, GLint *params)
{
  MEMORY[0x1E0CD0B68](*(_QWORD *)&pname, params);
}

void glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei *length, GLchar *infolog)
{
  MEMORY[0x1E0CD0B70](*(_QWORD *)&program, *(_QWORD *)&bufsize, length, infolog);
}

void glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
  MEMORY[0x1E0CD0B78](*(_QWORD *)&program, *(_QWORD *)&pname, params);
}

void glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *infolog)
{
  MEMORY[0x1E0CD0B88](*(_QWORD *)&shader, *(_QWORD *)&bufsize, length, infolog);
}

void glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source)
{
  MEMORY[0x1E0CD0B90](*(_QWORD *)&shader, *(_QWORD *)&bufsize, length, source);
}

void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
  MEMORY[0x1E0CD0B98](*(_QWORD *)&shader, *(_QWORD *)&pname, params);
}

const GLubyte *__cdecl glGetString(GLenum name)
{
  return (const GLubyte *)MEMORY[0x1E0CD0BA0](*(_QWORD *)&name);
}

int glGetUniformLocation(GLuint program, const GLchar *name)
{
  return MEMORY[0x1E0CD0BA8](*(_QWORD *)&program, name);
}

void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
  MEMORY[0x1E0CD0BB0](*(_QWORD *)&index, *(_QWORD *)&pname, params);
}

GLBOOLean glIsTexture(GLuint texture)
{
  return MEMORY[0x1E0CD0BC0](*(_QWORD *)&texture);
}

void glLinkProgram(GLuint program)
{
  MEMORY[0x1E0CD0BD0](*(_QWORD *)&program);
}

void glPixelStorei(GLenum pname, GLint param)
{
  MEMORY[0x1E0CD0BE0](*(_QWORD *)&pname, *(_QWORD *)&param);
}

void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
  MEMORY[0x1E0CD0C00](*(_QWORD *)&x, *(_QWORD *)&y, *(_QWORD *)&width, *(_QWORD *)&height, *(_QWORD *)&format, *(_QWORD *)&type, pixels);
}

uint64_t glRenderbufferStorageMultisampleAPPLE()
{
  return MEMORY[0x1E0CD0C10]();
}

uint64_t glResolveMultisampleFramebufferAPPLE()
{
  return MEMORY[0x1E0CD0C18]();
}

void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
  MEMORY[0x1E0CD0C20](*(_QWORD *)&x, *(_QWORD *)&y, *(_QWORD *)&width, *(_QWORD *)&height);
}

void glShaderSource(GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length)
{
  MEMORY[0x1E0CD0C28](*(_QWORD *)&shader, *(_QWORD *)&count, string, length);
}

void glStencilMask(GLuint mask)
{
  MEMORY[0x1E0CD0C38](*(_QWORD *)&mask);
}

void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  MEMORY[0x1E0CD0C50](*(_QWORD *)&target, *(_QWORD *)&level, *(_QWORD *)&internalformat, *(_QWORD *)&width, *(_QWORD *)&height, *(_QWORD *)&border, *(_QWORD *)&format, *(_QWORD *)&type);
}

void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
  MEMORY[0x1E0CD0C58](*(_QWORD *)&target, *(_QWORD *)&pname, param);
}

void glTexParameteri(GLenum target, GLenum pname, GLint param)
{
  MEMORY[0x1E0CD0C60](*(_QWORD *)&target, *(_QWORD *)&pname, *(_QWORD *)&param);
}

void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  MEMORY[0x1E0CD0C68](*(_QWORD *)&target, *(_QWORD *)&level, *(_QWORD *)&xoffset, *(_QWORD *)&yoffset, *(_QWORD *)&width, *(_QWORD *)&height, *(_QWORD *)&format, *(_QWORD *)&type);
}

void glUniform1f(GLint location, GLfloat x)
{
  MEMORY[0x1E0CD0C70](*(_QWORD *)&location, x);
}

void glUniform1i(GLint location, GLint x)
{
  MEMORY[0x1E0CD0C80](*(_QWORD *)&location, *(_QWORD *)&x);
}

void glUniform2f(GLint location, GLfloat x, GLfloat y)
{
  MEMORY[0x1E0CD0C88](*(_QWORD *)&location, x, y);
}

void glUniform2i(GLint location, GLint x, GLint y)
{
  MEMORY[0x1E0CD0C98](*(_QWORD *)&location, *(_QWORD *)&x, *(_QWORD *)&y);
}

void glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z)
{
  MEMORY[0x1E0CD0CA0](*(_QWORD *)&location, x, y, z);
}

void glUniform3i(GLint location, GLint x, GLint y, GLint z)
{
  MEMORY[0x1E0CD0CB0](*(_QWORD *)&location, *(_QWORD *)&x, *(_QWORD *)&y, *(_QWORD *)&z);
}

void glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  MEMORY[0x1E0CD0CB8](*(_QWORD *)&location, x, y, z, w);
}

void glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w)
{
  MEMORY[0x1E0CD0CC8](*(_QWORD *)&location, *(_QWORD *)&x, *(_QWORD *)&y, *(_QWORD *)&z, *(_QWORD *)&w);
}

void glUniformMatrix3fv(GLint location, GLsizei count, GLBOOLean transpose, const GLfloat *value)
{
  MEMORY[0x1E0CD0CD0](*(_QWORD *)&location, *(_QWORD *)&count, transpose, value);
}

void glUniformMatrix4fv(GLint location, GLsizei count, GLBOOLean transpose, const GLfloat *value)
{
  MEMORY[0x1E0CD0CD8](*(_QWORD *)&location, *(_QWORD *)&count, transpose, value);
}

void glUseProgram(GLuint program)
{
  MEMORY[0x1E0CD0CE8](*(_QWORD *)&program);
}

void glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLBOOLean normalized, GLsizei stride, const GLvoid *ptr)
{
  MEMORY[0x1E0CD0D08](*(_QWORD *)&indx, *(_QWORD *)&size, *(_QWORD *)&type, normalized, *(_QWORD *)&stride, ptr);
}

void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
  MEMORY[0x1E0CD0D10](*(_QWORD *)&x, *(_QWORD *)&y, *(_QWORD *)&width, *(_QWORD *)&height);
}

kern_return_t host_page_size(host_t a1, vm_size_t *a2)
{
  return MEMORY[0x1E0C838C0](*(_QWORD *)&a1, a2);
}

kern_return_t host_statistics(host_t host_priv, host_flavor_t flavor, host_info_t host_info_out, mach_msg_type_number_t *host_info_outCnt)
{
  return MEMORY[0x1E0C838D8](*(_QWORD *)&host_priv, *(_QWORD *)&flavor, host_info_out, host_info_outCnt);
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C838E8](__x, __y);
  return result;
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

long double ldexp(long double __x, int __e)
{
  long double result;

  MEMORY[0x1E0C83B40](*(_QWORD *)&__e, __x);
  return result;
}

float ldexpf(float a1, int a2)
{
  float result;

  MEMORY[0x1E0C83B48](*(_QWORD *)&a2, a1);
  return result;
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1E0C83BA8](a1);
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BB8](__x);
  return result;
}

long double log10(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BC0](__x);
  return result;
}

float log10f(float a1)
{
  float result;

  MEMORY[0x1E0C83BC8](a1);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BE8](__x);
  return result;
}

float log2f(float a1)
{
  float result;

  MEMORY[0x1E0C83BF0](a1);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x1E0C83C00](a1);
  return result;
}

void longjmp(jmp_buf a1, int a2)
{
  MEMORY[0x1E0C83C08](a1, *(_QWORD *)&a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

mach_port_t mach_host_self(void)
{
  return MEMORY[0x1E0C83C90]();
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1E0C83CF8](*(_QWORD *)&task, *(_QWORD *)&name);
}

mach_port_t mach_thread_self(void)
{
  return MEMORY[0x1E0C83DB0]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

const char *__cdecl macho_arch_name_for_mach_header(const mach_header *mh)
{
  return (const char *)MEMORY[0x1E0C83E38](mh);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1E0C83EE0](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F18](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x1E0C840B8](__b, __pattern16, __len);
}

long double modf(long double __x, long double *__y)
{
  long double result;

  MEMORY[0x1E0C841E0](__y, __x);
  return result;
}

float nanf(const char *a1)
{
  float result;

  MEMORY[0x1E0C84230](a1);
  return result;
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x1E0C84238](__rqtp, __rmtp);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1E0C843E8](*(_QWORD *)&token, state64);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1E0DE7BF0](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_end_catch(void)
{
  MEMORY[0x1E0DE7C80]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

void objc_exception_throw(id exception)
{
  MEMORY[0x1E0DE7CA0](exception);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1E0DE7D00](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D20](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x1E0DE7D58]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E68](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F88](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F98](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7FA0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

void objc_terminate(void)
{
  MEMORY[0x1E0DE7FD8]();
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7FE0](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x1E0DE8000](a1);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C84BC0](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  const char *v4;
  char *v5;
  objc_method_description result;

  v4 = (const char *)MEMORY[0x1E0DE80A8](p, aSel, isRequiredMethod, isInstanceMethod);
  result.types = v5;
  result.name = v4;
  return result;
}

const char *__cdecl protocol_getName(Protocol *p)
{
  return (const char *)MEMORY[0x1E0DE80B0](p);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CB0](a1);
}

int pthread_attr_getstacksize(const pthread_attr_t *a1, size_t *a2)
{
  return MEMORY[0x1E0C84CC0](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CC8](a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CD8](a1, *(_QWORD *)&a2);
}

int pthread_attr_setstacksize(pthread_attr_t *a1, size_t a2)
{
  return MEMORY[0x1E0C84D00](a1, a2);
}

int pthread_cancel(pthread_t a1)
{
  return MEMORY[0x1E0C84D08](a1);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D18](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D20](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1E0C84D28](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D30](a1);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x1E0C84D38](a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1E0C84D48](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1E0C84D50](a1, a2, a3, a4);
}

int pthread_detach(pthread_t a1)
{
  return MEMORY[0x1E0C84D78](a1);
}

int pthread_equal(pthread_t a1, pthread_t a2)
{
  return MEMORY[0x1E0C84D80](a1, a2);
}

int pthread_getschedparam(pthread_t a1, int *a2, sched_param *a3)
{
  return MEMORY[0x1E0C84DB8](a1, a2, a3);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1E0C84DC0](a1);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x1E0C84DD8](a1, a2);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1E0C84DE0](a1, a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1E0C84E00](a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E40](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E48](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1E0C84E60](a1, *(_QWORD *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1E0C84E68](a1, a2);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84E90](a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return MEMORY[0x1E0C84E98](a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EA0](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EB8](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EC0](a1);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1E0C84ED8]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1E0C84F08](a1);
}

int pthread_setschedparam(pthread_t a1, int a2, const sched_param *a3)
{
  return MEMORY[0x1E0C84F10](a1, *(_QWORD *)&a2, a3);
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1E0C84F18](a1, a2);
}

void pthread_testcancel(void)
{
  MEMORY[0x1E0C84F30]();
}

int putchar(int a1)
{
  return MEMORY[0x1E0C84F50](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x1E0C84F60](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

const char *__cdecl sel_getName(SEL sel)
{
  return (const char *)MEMORY[0x1E0DE80C8](sel);
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x1E0DE80E8](str);
}

int setjmp(jmp_buf a1)
{
  return MEMORY[0x1E0C85348](a1);
}

char *__cdecl setlocale(int a1, const char *a2)
{
  return (char *)MEMORY[0x1E0C85358](*(_QWORD *)&a1, a2);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x1E0C85380](*(_QWORD *)&a1, a2);
}

long double sin(long double __x)
{
  long double result;

  MEMORY[0x1E0C85418](__x);
  return result;
}

float sinf(float a1)
{
  float result;

  MEMORY[0x1E0C85420](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85498](a1, a2);
}

int ssyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BF18](__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85510](__s1, __s2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1E0C85530](__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1E0C85558](a1, a2, a3, a4);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

double strtod(const char *a1, char **a2)
{
  double result;

  MEMORY[0x1E0C85618](a1, a2);
  return result;
}

float strtof(const char *a1, char **a2)
{
  float result;

  MEMORY[0x1E0C85628](a1, a2);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85658](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85678](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85698](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C856A8](__str, __endptr, *(_QWORD *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1E0C85798](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

long double tan(long double __x)
{
  long double result;

  MEMORY[0x1E0C857E8](__x);
  return result;
}

float tanf(float a1)
{
  float result;

  MEMORY[0x1E0C857F0](a1);
  return result;
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x1E0C85838](*(_QWORD *)&target_task, *(_QWORD *)&flavor, task_info_out, task_info_outCnt);
}

kern_return_t thread_policy_get(thread_inspect_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t *policy_infoCnt, BOOLean_t *get_default)
{
  return MEMORY[0x1E0C85900](*(_QWORD *)&thread, *(_QWORD *)&flavor, policy_info, policy_infoCnt, get_default);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return MEMORY[0x1E0C85908](*(_QWORD *)&thread, *(_QWORD *)&flavor, policy_info, *(_QWORD *)&policy_infoCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1E0C85950](a1);
}

int uname(utsname *a1)
{
  return MEMORY[0x1E0C859A0](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1E0C859E0](*(_QWORD *)&a1);
}

vImage_Error vImageBuffer_InitWithCGImage(vImage_Buffer *buf, vImage_CGImageFormat *format, const CGFloat *backgroundColor, CGImageRef image, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CC28](buf, format, backgroundColor, image, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_AnyToAny(const vImageConverterRef converter, const vImage_Buffer *srcs, const vImage_Buffer *dests, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CEF0](converter, srcs, dests, tempBuffer, *(_QWORD *)&flags);
}

vImageConverterRef vImageConverter_CreateWithCGColorConversionInfo(CGColorConversionInfoRef colorConversionInfoRef, const vImage_CGImageFormat *sFormat, const vImage_CGImageFormat *dFormat, const CGFloat *bg, vImage_Flags flags, vImage_Error *error)
{
  return (vImageConverterRef)MEMORY[0x1E0C8D118](colorConversionInfoRef, sFormat, dFormat, bg, *(_QWORD *)&flags, error);
}

vImageConverterRef vImageConverter_CreateWithCGImageFormat(const vImage_CGImageFormat *srcFormat, const vImage_CGImageFormat *destFormat, const CGFloat *backgroundColor, vImage_Flags flags, vImage_Error *error)
{
  return (vImageConverterRef)MEMORY[0x1E0C8D120](srcFormat, destFormat, backgroundColor, *(_QWORD *)&flags, error);
}

vImage_Error vImagePermuteChannels_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D520](src, dest, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImagePermuteChannels_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D528](src, dest, permuteMap, *(_QWORD *)&flags);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x1E0C85A68](a1, a2, a3);
}

kern_return_t vm_region_recurse_64(vm_map_read_t target_task, vm_address_t *address, vm_size_t *size, natural_t *nesting_depth, vm_region_recurse_info_t info, mach_msg_type_number_t *infoCnt)
{
  return MEMORY[0x1E0C85B00](*(_QWORD *)&target_task, address, size, nesting_depth, info, infoCnt);
}

int vprintf(const char *a1, va_list a2)
{
  return MEMORY[0x1E0C85B80](a1, a2);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1E0C85B98](__str, __size, __format, a4);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1E0C85CB8](__s, *(_QWORD *)&__c, __n);
}

void xmlFreeTextReader(xmlTextReaderPtr reader)
{
  MEMORY[0x1E0DE8D58](reader);
}

xmlTextReaderPtr xmlReaderForFile(const char *filename, const char *encoding, int options)
{
  return (xmlTextReaderPtr)MEMORY[0x1E0DE8EE8](filename, encoding, *(_QWORD *)&options);
}

xmlTextReaderPtr xmlReaderForMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  return (xmlTextReaderPtr)MEMORY[0x1E0DE8EF8](buffer, *(_QWORD *)&size, URL, encoding, *(_QWORD *)&options);
}

const xmlChar *__cdecl xmlTextReaderConstName(xmlTextReaderPtr reader)
{
  return (const xmlChar *)MEMORY[0x1E0DE9040](reader);
}

const xmlChar *__cdecl xmlTextReaderConstValue(xmlTextReaderPtr reader)
{
  return (const xmlChar *)MEMORY[0x1E0DE9048](reader);
}

int xmlTextReaderHasAttributes(xmlTextReaderPtr reader)
{
  return MEMORY[0x1E0DE9060](reader);
}

int xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader)
{
  return MEMORY[0x1E0DE9068](reader);
}

int xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader)
{
  return MEMORY[0x1E0DE9088](reader);
}

int xmlTextReaderNext(xmlTextReaderPtr reader)
{
  return MEMORY[0x1E0DE9090](reader);
}

int xmlTextReaderNodeType(xmlTextReaderPtr reader)
{
  return MEMORY[0x1E0DE9098](reader);
}

int xmlTextReaderRead(xmlTextReaderPtr reader)
{
  return MEMORY[0x1E0DE90A0](reader);
}

xmlChar *__cdecl xmlTextReaderReadString(xmlTextReaderPtr reader)
{
  return (xmlChar *)MEMORY[0x1E0DE90B8](reader);
}

